
./build/kernel.bin:     file format elf32-i386


Disassembly of section .text:

c0001500 <main>:
main():
/work/x86_os_my/kernel/main.c:36
用户进程
u_prog_a 的地址是在 0xc0000000 以上，位于内核空间，但这并不表示它无法模拟用户进程。
*/
void init(void);

int main(void) {
c0001500:	8d 4c 24 04          	lea    0x4(%esp),%ecx
c0001504:	83 e4 f0             	and    $0xfffffff0,%esp
c0001507:	ff 71 fc             	pushl  -0x4(%ecx)
c000150a:	55                   	push   %ebp
c000150b:	89 e5                	mov    %esp,%ebp
c000150d:	51                   	push   %ecx
c000150e:	83 ec 24             	sub    $0x24,%esp
/work/x86_os_my/kernel/main.c:37
	put_str("I am kernel\n");
c0001511:	83 ec 0c             	sub    $0xc,%esp
c0001514:	68 80 d8 00 c0       	push   $0xc000d880
c0001519:	e8 92 0e 00 00       	call   c00023b0 <put_str>
c000151e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:38
	init_all();
c0001521:	e8 94 02 00 00       	call   c00017ba <init_all>
/work/x86_os_my/kernel/main.c:44

	/*************    写入应用程序    *************/
	// 1.就第一次写入到hd80M.img就行，之后注释掉这块代码。
	// 2.不用注释掉了，我们每次都让他删掉重新写入，虽然写入文件系统时的 file_size 很大，
	// 但是load程序时，读的elf头里面告诉了有几个segment是PT_LOAD可加载的，所以没关系！！！
	uint32_t file_size = 512*50;	//书上编译出来可执行程序大小是 4777 字节【改成自己程序的大小，多个程序的话，取最大值，直接搞50个扇区(25k)，省的麻烦，】
c0001526:	c7 45 f4 00 64 00 00 	movl   $0x6400,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:45
	uint32_t sec_cnt = DIV_ROUND_UP(file_size, 512);
c000152d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001530:	05 ff 01 00 00       	add    $0x1ff,%eax
c0001535:	c1 e8 09             	shr    $0x9,%eax
c0001538:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/main.c:46
	struct disk* sda = &channels[0].devices[0];
c000153b:	c7 45 ec 00 4c 01 c0 	movl   $0xc0014c00,-0x14(%ebp)
/work/x86_os_my/kernel/main.c:47
	void* prog_buf = sys_malloc(file_size);
c0001542:	83 ec 0c             	sub    $0xc,%esp
c0001545:	ff 75 f4             	pushl  -0xc(%ebp)
c0001548:	e8 bf 19 00 00       	call   c0002f0c <sys_malloc>
c000154d:	83 c4 10             	add    $0x10,%esp
c0001550:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/main.c:48
	if(NULL == prog_buf) {
c0001553:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0001557:	75 1a                	jne    c0001573 <main+0x73>
/work/x86_os_my/kernel/main.c:49
		printk("sys_malloc error!\n");
c0001559:	83 ec 0c             	sub    $0xc,%esp
c000155c:	68 8d d8 00 c0       	push   $0xc000d88d
c0001561:	e8 e7 5a 00 00       	call   c000704d <printk>
c0001566:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:50
		return 0;
c0001569:	b8 00 00 00 00       	mov    $0x0,%eax
c000156e:	e9 dd 01 00 00       	jmp    c0001750 <main+0x250>
/work/x86_os_my/kernel/main.c:55
	}

	int32_t fd;
	// 在文件系统中 写入 prog_no_arg
	sys_unlink("/prog_no_arg");						//先删掉
c0001573:	83 ec 0c             	sub    $0xc,%esp
c0001576:	68 a0 d8 00 c0       	push   $0xc000d8a0
c000157b:	e8 04 6c 00 00       	call   c0008184 <sys_unlink>
c0001580:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:56
	ide_read(sda, 300, prog_buf, sec_cnt);
c0001583:	ff 75 f0             	pushl  -0x10(%ebp)
c0001586:	ff 75 e8             	pushl  -0x18(%ebp)
c0001589:	68 2c 01 00 00       	push   $0x12c
c000158e:	ff 75 ec             	pushl  -0x14(%ebp)
c0001591:	e8 3e 50 00 00       	call   c00065d4 <ide_read>
c0001596:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:57
	fd = sys_open("/prog_no_arg", O_CREAT|O_RDWR);	//创建文件
c0001599:	83 ec 08             	sub    $0x8,%esp
c000159c:	6a 06                	push   $0x6
c000159e:	68 a0 d8 00 c0       	push   $0xc000d8a0
c00015a3:	e8 c0 64 00 00       	call   c0007a68 <sys_open>
c00015a8:	83 c4 10             	add    $0x10,%esp
c00015ab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/main.c:58
	if (fd != -1) {
c00015ae:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
c00015b2:	74 2b                	je     c00015df <main+0xdf>
/work/x86_os_my/kernel/main.c:59
		if(sys_write(fd, prog_buf, file_size) == -1) {		//写入文件
c00015b4:	83 ec 04             	sub    $0x4,%esp
c00015b7:	ff 75 f4             	pushl  -0xc(%ebp)
c00015ba:	ff 75 e8             	pushl  -0x18(%ebp)
c00015bd:	ff 75 e4             	pushl  -0x1c(%ebp)
c00015c0:	e8 4d 68 00 00       	call   c0007e12 <sys_write>
c00015c5:	83 c4 10             	add    $0x10,%esp
c00015c8:	83 f8 ff             	cmp    $0xffffffff,%eax
c00015cb:	75 12                	jne    c00015df <main+0xdf>
/work/x86_os_my/kernel/main.c:60
			printk("file write error!\n");
c00015cd:	83 ec 0c             	sub    $0xc,%esp
c00015d0:	68 ad d8 00 c0       	push   $0xc000d8ad
c00015d5:	e8 73 5a 00 00       	call   c000704d <printk>
c00015da:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:61 (discriminator 1)
			while(1);
c00015dd:	eb fe                	jmp    c00015dd <main+0xdd>
/work/x86_os_my/kernel/main.c:66
		}
	}

	// 在文件系统中 写入 prog_arg
	sys_unlink("/prog_arg");						//先删掉
c00015df:	83 ec 0c             	sub    $0xc,%esp
c00015e2:	68 c0 d8 00 c0       	push   $0xc000d8c0
c00015e7:	e8 98 6b 00 00       	call   c0008184 <sys_unlink>
c00015ec:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:67
	ide_read(sda, 400, prog_buf, sec_cnt);
c00015ef:	ff 75 f0             	pushl  -0x10(%ebp)
c00015f2:	ff 75 e8             	pushl  -0x18(%ebp)
c00015f5:	68 90 01 00 00       	push   $0x190
c00015fa:	ff 75 ec             	pushl  -0x14(%ebp)
c00015fd:	e8 d2 4f 00 00       	call   c00065d4 <ide_read>
c0001602:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:68
	fd = sys_open("/prog_arg", O_CREAT|O_RDWR);		//创建文件
c0001605:	83 ec 08             	sub    $0x8,%esp
c0001608:	6a 06                	push   $0x6
c000160a:	68 c0 d8 00 c0       	push   $0xc000d8c0
c000160f:	e8 54 64 00 00       	call   c0007a68 <sys_open>
c0001614:	83 c4 10             	add    $0x10,%esp
c0001617:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/main.c:69
	if (fd != -1) {
c000161a:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
c000161e:	74 2b                	je     c000164b <main+0x14b>
/work/x86_os_my/kernel/main.c:70
		if(sys_write(fd, prog_buf, file_size) == -1) {		//写入文件
c0001620:	83 ec 04             	sub    $0x4,%esp
c0001623:	ff 75 f4             	pushl  -0xc(%ebp)
c0001626:	ff 75 e8             	pushl  -0x18(%ebp)
c0001629:	ff 75 e4             	pushl  -0x1c(%ebp)
c000162c:	e8 e1 67 00 00       	call   c0007e12 <sys_write>
c0001631:	83 c4 10             	add    $0x10,%esp
c0001634:	83 f8 ff             	cmp    $0xffffffff,%eax
c0001637:	75 12                	jne    c000164b <main+0x14b>
/work/x86_os_my/kernel/main.c:71
			printk("file write error!\n");
c0001639:	83 ec 0c             	sub    $0xc,%esp
c000163c:	68 ad d8 00 c0       	push   $0xc000d8ad
c0001641:	e8 07 5a 00 00       	call   c000704d <printk>
c0001646:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:72 (discriminator 2)
			while(1);
c0001649:	eb fe                	jmp    c0001649 <main+0x149>
/work/x86_os_my/kernel/main.c:77
		}
	}

	// 在文件系统中 写入 cat
	sys_unlink("/cat");							//先删掉
c000164b:	83 ec 0c             	sub    $0xc,%esp
c000164e:	68 ca d8 00 c0       	push   $0xc000d8ca
c0001653:	e8 2c 6b 00 00       	call   c0008184 <sys_unlink>
c0001658:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:78
	ide_read(sda, 500, prog_buf, sec_cnt);
c000165b:	ff 75 f0             	pushl  -0x10(%ebp)
c000165e:	ff 75 e8             	pushl  -0x18(%ebp)
c0001661:	68 f4 01 00 00       	push   $0x1f4
c0001666:	ff 75 ec             	pushl  -0x14(%ebp)
c0001669:	e8 66 4f 00 00       	call   c00065d4 <ide_read>
c000166e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:79
	fd = sys_open("/cat", O_CREAT|O_RDWR);		//创建文件
c0001671:	83 ec 08             	sub    $0x8,%esp
c0001674:	6a 06                	push   $0x6
c0001676:	68 ca d8 00 c0       	push   $0xc000d8ca
c000167b:	e8 e8 63 00 00       	call   c0007a68 <sys_open>
c0001680:	83 c4 10             	add    $0x10,%esp
c0001683:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/main.c:80
	if (fd != -1) {
c0001686:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
c000168a:	74 2b                	je     c00016b7 <main+0x1b7>
/work/x86_os_my/kernel/main.c:81
		if(sys_write(fd, prog_buf, file_size) == -1) {		//写入文件
c000168c:	83 ec 04             	sub    $0x4,%esp
c000168f:	ff 75 f4             	pushl  -0xc(%ebp)
c0001692:	ff 75 e8             	pushl  -0x18(%ebp)
c0001695:	ff 75 e4             	pushl  -0x1c(%ebp)
c0001698:	e8 75 67 00 00       	call   c0007e12 <sys_write>
c000169d:	83 c4 10             	add    $0x10,%esp
c00016a0:	83 f8 ff             	cmp    $0xffffffff,%eax
c00016a3:	75 12                	jne    c00016b7 <main+0x1b7>
/work/x86_os_my/kernel/main.c:82
			printk("file write error!\n");
c00016a5:	83 ec 0c             	sub    $0xc,%esp
c00016a8:	68 ad d8 00 c0       	push   $0xc000d8ad
c00016ad:	e8 9b 59 00 00       	call   c000704d <printk>
c00016b2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:83 (discriminator 3)
			while(1);
c00016b5:	eb fe                	jmp    c00016b5 <main+0x1b5>
/work/x86_os_my/kernel/main.c:88
		}
	}

	// 在文件系统中 写入 prog_pipe
	sys_unlink("/prog_pipe");							//先删掉
c00016b7:	83 ec 0c             	sub    $0xc,%esp
c00016ba:	68 cf d8 00 c0       	push   $0xc000d8cf
c00016bf:	e8 c0 6a 00 00       	call   c0008184 <sys_unlink>
c00016c4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:89
	ide_read(sda, 600, prog_buf, sec_cnt);
c00016c7:	ff 75 f0             	pushl  -0x10(%ebp)
c00016ca:	ff 75 e8             	pushl  -0x18(%ebp)
c00016cd:	68 58 02 00 00       	push   $0x258
c00016d2:	ff 75 ec             	pushl  -0x14(%ebp)
c00016d5:	e8 fa 4e 00 00       	call   c00065d4 <ide_read>
c00016da:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:90
	fd = sys_open("/prog_pipe", O_CREAT|O_RDWR);		//创建文件
c00016dd:	83 ec 08             	sub    $0x8,%esp
c00016e0:	6a 06                	push   $0x6
c00016e2:	68 cf d8 00 c0       	push   $0xc000d8cf
c00016e7:	e8 7c 63 00 00       	call   c0007a68 <sys_open>
c00016ec:	83 c4 10             	add    $0x10,%esp
c00016ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/main.c:91
	if (fd != -1) {
c00016f2:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
c00016f6:	74 2b                	je     c0001723 <main+0x223>
/work/x86_os_my/kernel/main.c:92
		if(sys_write(fd, prog_buf, file_size) == -1) {		//写入文件
c00016f8:	83 ec 04             	sub    $0x4,%esp
c00016fb:	ff 75 f4             	pushl  -0xc(%ebp)
c00016fe:	ff 75 e8             	pushl  -0x18(%ebp)
c0001701:	ff 75 e4             	pushl  -0x1c(%ebp)
c0001704:	e8 09 67 00 00       	call   c0007e12 <sys_write>
c0001709:	83 c4 10             	add    $0x10,%esp
c000170c:	83 f8 ff             	cmp    $0xffffffff,%eax
c000170f:	75 12                	jne    c0001723 <main+0x223>
/work/x86_os_my/kernel/main.c:93
			printk("file write error!\n");
c0001711:	83 ec 0c             	sub    $0xc,%esp
c0001714:	68 ad d8 00 c0       	push   $0xc000d8ad
c0001719:	e8 2f 59 00 00       	call   c000704d <printk>
c000171e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:94 (discriminator 4)
			while(1);
c0001721:	eb fe                	jmp    c0001721 <main+0x221>
/work/x86_os_my/kernel/main.c:98
		}
	}
	/*************    写入应用程序结束   *************/
	cls_screen();
c0001723:	e8 73 0d 00 00       	call   c000249b <cls_screen>
/work/x86_os_my/kernel/main.c:99
	console_put_str("[rabbit@localhost /]$ ");
c0001728:	83 ec 0c             	sub    $0xc,%esp
c000172b:	68 da d8 00 c0       	push   $0xc000d8da
c0001730:	e8 5b 35 00 00       	call   c0004c90 <console_put_str>
c0001735:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:100
	thread_exit(running_thread(), true);
c0001738:	e8 0f 27 00 00       	call   c0003e4c <running_thread>
c000173d:	83 ec 08             	sub    $0x8,%esp
c0001740:	6a 01                	push   $0x1
c0001742:	50                   	push   %eax
c0001743:	e8 3a 31 00 00       	call   c0004882 <thread_exit>
c0001748:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:101
	return 0;
c000174b:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/kernel/main.c:102
}
c0001750:	8b 4d fc             	mov    -0x4(%ebp),%ecx
c0001753:	c9                   	leave  
c0001754:	8d 61 fc             	lea    -0x4(%ecx),%esp
c0001757:	c3                   	ret    

c0001758 <init>:
init():
/work/x86_os_my/kernel/main.c:105

/* init进程 */
void init(void) {
c0001758:	55                   	push   %ebp
c0001759:	89 e5                	mov    %esp,%ebp
c000175b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:106
	uint32_t ret_pid = fork();
c000175e:	e8 95 44 00 00       	call   c0005bf8 <fork>
c0001763:	98                   	cwtl   
c0001764:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:107
	if(ret_pid) {  // 父进程
c0001767:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000176b:	74 2c                	je     c0001799 <init+0x41>
/work/x86_os_my/kernel/main.c:112 (discriminator 1)
		int status;
		int child_pid;
		/* init在此处不停的回收僵尸进程 */
		while(1) {
			child_pid = wait(&status);
c000176d:	83 ec 0c             	sub    $0xc,%esp
c0001770:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0001773:	50                   	push   %eax
c0001774:	e8 ec 46 00 00       	call   c0005e65 <wait>
c0001779:	83 c4 10             	add    $0x10,%esp
c000177c:	98                   	cwtl   
c000177d:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/main.c:113 (discriminator 1)
			printf("I`m init, My pid is 1, I recieve a child, It`s pid is %d, status is %d\n", child_pid, status);
c0001780:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001783:	83 ec 04             	sub    $0x4,%esp
c0001786:	50                   	push   %eax
c0001787:	ff 75 f0             	pushl  -0x10(%ebp)
c000178a:	68 f4 d8 00 c0       	push   $0xc000d8f4
c000178f:	e8 c1 4a 00 00       	call   c0006255 <printf>
c0001794:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:114 (discriminator 1)
		}
c0001797:	eb d4                	jmp    c000176d <init+0x15>
/work/x86_os_my/kernel/main.c:116
	} else {	  // 子进程
		my_shell();
c0001799:	e8 94 ab 00 00       	call   c000c332 <my_shell>
/work/x86_os_my/kernel/main.c:118
	}
	panic("init: should not be here");
c000179e:	68 3c d9 00 c0       	push   $0xc000d93c
c00017a3:	68 64 d9 00 c0       	push   $0xc000d964
c00017a8:	6a 76                	push   $0x76
c00017aa:	68 55 d9 00 c0       	push   $0xc000d955
c00017af:	e8 ee ad 00 00       	call   c000c5a2 <user_spin>
c00017b4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:119
}
c00017b7:	90                   	nop
c00017b8:	c9                   	leave  
c00017b9:	c3                   	ret    

c00017ba <init_all>:
init_all():
/work/x86_os_my/kernel/init.c:15
#include "syscall-init.h"
#include "ide.h"
#include "fs.h"

/*负责初始化所有模块 */
void init_all() {
c00017ba:	55                   	push   %ebp
c00017bb:	89 e5                	mov    %esp,%ebp
c00017bd:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/init.c:16
	put_str("init_all\n");
c00017c0:	83 ec 0c             	sub    $0xc,%esp
c00017c3:	68 69 d9 00 c0       	push   $0xc000d969
c00017c8:	e8 e3 0b 00 00       	call   c00023b0 <put_str>
c00017cd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/init.c:17
	idt_init();			// 初始化中断
c00017d0:	e8 38 04 00 00       	call   c0001c0d <idt_init>
/work/x86_os_my/kernel/init.c:18
	mem_init();			// 初始化内存管理系统
c00017d5:	e8 3a 22 00 00       	call   c0003a14 <mem_init>
/work/x86_os_my/kernel/init.c:19
	thread_init();		// 初始化线程相关结构
c00017da:	e8 d7 31 00 00       	call   c00049b6 <thread_init>
/work/x86_os_my/kernel/init.c:20
	timer_init();		// 初始化PIT
c00017df:	e8 16 06 00 00       	call   c0001dfa <timer_init>
/work/x86_os_my/kernel/init.c:21
	console_init();		// 控制台初始化最好放在开中断之前
c00017e4:	e8 5c 34 00 00       	call   c0004c45 <console_init>
/work/x86_os_my/kernel/init.c:22
	keyboard_init();	// 键盘初始化
c00017e9:	e8 d5 3a 00 00       	call   c00052c3 <keyboard_init>
/work/x86_os_my/kernel/init.c:23
	tss_init();			// tss初始化
c00017ee:	e8 1a 3f 00 00       	call   c000570d <tss_init>
/work/x86_os_my/kernel/init.c:24
	syscall_init();		// 初始化系统调用
c00017f3:	e8 f0 46 00 00       	call   c0005ee8 <syscall_init>
/work/x86_os_my/kernel/init.c:25
	intr_enable();		// 后面的ide_init需要打开中断
c00017f8:	e8 5f 03 00 00       	call   c0001b5c <intr_enable>
/work/x86_os_my/kernel/init.c:26
	ide_init();			// 初始化硬盘
c00017fd:	e8 3f 56 00 00       	call   c0006e41 <ide_init>
/work/x86_os_my/kernel/init.c:27
	filesys_init();		// 初始化文件系统
c0001802:	e8 87 78 00 00       	call   c000908e <filesys_init>
/work/x86_os_my/kernel/init.c:28
}
c0001807:	90                   	nop
c0001808:	c9                   	leave  
c0001809:	c3                   	ret    

c000180a <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c000180a:	55                   	push   %ebp
c000180b:	89 e5                	mov    %esp,%ebp
c000180d:	83 ec 08             	sub    $0x8,%esp
c0001810:	8b 55 08             	mov    0x8(%ebp),%edx
c0001813:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001816:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c000181a:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c000181d:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0001821:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0001825:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c0001826:	90                   	nop
c0001827:	c9                   	leave  
c0001828:	c3                   	ret    

c0001829 <pic_init>:
pic_init():
/work/x86_os_my/kernel/interrupt.c:41
//自定义类型 intr_handler = void*
extern intr_handler intr_entry_table[IDT_DESC_CNT];	    // 声明引用汇编kernel.S中的中断处理函数入口数组

/* 初始化可编程中断控制器8259A */
// outb 来着 lib/kernel/io.h 内联汇编写法
static void pic_init(void) {
c0001829:	55                   	push   %ebp
c000182a:	89 e5                	mov    %esp,%ebp
c000182c:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:43
	/* 初始化主片 */
	outb (PIC_M_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c000182f:	6a 11                	push   $0x11
c0001831:	6a 20                	push   $0x20
c0001833:	e8 d2 ff ff ff       	call   c000180a <outb>
c0001838:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:44
	outb (PIC_M_DATA, 0x20);	// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.
c000183b:	6a 20                	push   $0x20
c000183d:	6a 21                	push   $0x21
c000183f:	e8 c6 ff ff ff       	call   c000180a <outb>
c0001844:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:45
	outb (PIC_M_DATA, 0x04);	// ICW3: IR2接从片. 
c0001847:	6a 04                	push   $0x4
c0001849:	6a 21                	push   $0x21
c000184b:	e8 ba ff ff ff       	call   c000180a <outb>
c0001850:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:46
	outb (PIC_M_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c0001853:	6a 01                	push   $0x1
c0001855:	6a 21                	push   $0x21
c0001857:	e8 ae ff ff ff       	call   c000180a <outb>
c000185c:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:49

	/* 初始化从片 */
	outb (PIC_S_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c000185f:	6a 11                	push   $0x11
c0001861:	68 a0 00 00 00       	push   $0xa0
c0001866:	e8 9f ff ff ff       	call   c000180a <outb>
c000186b:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:50
	outb (PIC_S_DATA, 0x28);	// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.
c000186e:	6a 28                	push   $0x28
c0001870:	68 a1 00 00 00       	push   $0xa1
c0001875:	e8 90 ff ff ff       	call   c000180a <outb>
c000187a:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:51
	outb (PIC_S_DATA, 0x02);	// ICW3: 设置从片连接到主片的IR2引脚
c000187d:	6a 02                	push   $0x2
c000187f:	68 a1 00 00 00       	push   $0xa1
c0001884:	e8 81 ff ff ff       	call   c000180a <outb>
c0001889:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:52
	outb (PIC_S_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c000188c:	6a 01                	push   $0x1
c000188e:	68 a1 00 00 00       	push   $0xa1
c0001893:	e8 72 ff ff ff       	call   c000180a <outb>
c0001898:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:56

	/* IRQ2用于级联从片,必须打开,否则无法响应从片上的中断
	主片上打开的中断有IRQ0的时钟,IRQ1的键盘和级联从片的IRQ2,其它全部关闭 */
	outb (PIC_M_DATA, 0xf8);
c000189b:	68 f8 00 00 00       	push   $0xf8
c00018a0:	6a 21                	push   $0x21
c00018a2:	e8 63 ff ff ff       	call   c000180a <outb>
c00018a7:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:58
	/* 打开从片上的IRQ14,此引脚接收硬盘控制器的中断 */
	outb (PIC_S_DATA, 0xbf);
c00018aa:	68 bf 00 00 00       	push   $0xbf
c00018af:	68 a1 00 00 00       	push   $0xa1
c00018b4:	e8 51 ff ff ff       	call   c000180a <outb>
c00018b9:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:60

	put_str("   pic_init done\n");
c00018bc:	83 ec 0c             	sub    $0xc,%esp
c00018bf:	68 74 d9 00 c0       	push   $0xc000d974
c00018c4:	e8 e7 0a 00 00       	call   c00023b0 <put_str>
c00018c9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:61
}
c00018cc:	90                   	nop
c00018cd:	c9                   	leave  
c00018ce:	c3                   	ret    

c00018cf <make_idt_desc>:
make_idt_desc():
/work/x86_os_my/kernel/interrupt.c:64

/* 创建中断门描述符 */
static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function) { 
c00018cf:	55                   	push   %ebp
c00018d0:	89 e5                	mov    %esp,%ebp
c00018d2:	83 ec 04             	sub    $0x4,%esp
c00018d5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00018d8:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:65
	p_gdesc->func_offset_low_word = (uint32_t)function & 0x0000FFFF;
c00018db:	8b 45 10             	mov    0x10(%ebp),%eax
c00018de:	89 c2                	mov    %eax,%edx
c00018e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00018e3:	66 89 10             	mov    %dx,(%eax)
/work/x86_os_my/kernel/interrupt.c:66
	p_gdesc->selector = SELECTOR_K_CODE;
c00018e6:	8b 45 08             	mov    0x8(%ebp),%eax
c00018e9:	66 c7 40 02 08 00    	movw   $0x8,0x2(%eax)
/work/x86_os_my/kernel/interrupt.c:67
	p_gdesc->dcount = 0;
c00018ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00018f2:	c6 40 04 00          	movb   $0x0,0x4(%eax)
/work/x86_os_my/kernel/interrupt.c:68
	p_gdesc->attribute = attr;
c00018f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00018f9:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c00018fd:	88 50 05             	mov    %dl,0x5(%eax)
/work/x86_os_my/kernel/interrupt.c:69
	p_gdesc->func_offset_high_word = ((uint32_t)function & 0xFFFF0000) >> 16;
c0001900:	8b 45 10             	mov    0x10(%ebp),%eax
c0001903:	c1 e8 10             	shr    $0x10,%eax
c0001906:	89 c2                	mov    %eax,%edx
c0001908:	8b 45 08             	mov    0x8(%ebp),%eax
c000190b:	66 89 50 06          	mov    %dx,0x6(%eax)
/work/x86_os_my/kernel/interrupt.c:70
}
c000190f:	90                   	nop
c0001910:	c9                   	leave  
c0001911:	c3                   	ret    

c0001912 <idt_desc_init>:
idt_desc_init():
/work/x86_os_my/kernel/interrupt.c:73

/*初始化中断描述符表*/
static void idt_desc_init(void) {
c0001912:	55                   	push   %ebp
c0001913:	89 e5                	mov    %esp,%ebp
c0001915:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:75
	int i;
	int lastindex = IDT_DESC_CNT - 1;
c0001918:	c7 45 f0 80 00 00 00 	movl   $0x80,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:76
	for (i = 0; i < IDT_DESC_CNT; i++) {
c000191f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0001926:	eb 29                	jmp    c0001951 <idt_desc_init+0x3f>
/work/x86_os_my/kernel/interrupt.c:77 (discriminator 3)
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
c0001928:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000192b:	8b 04 85 00 30 01 c0 	mov    -0x3ffed000(,%eax,4),%eax
c0001932:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0001935:	c1 e2 03             	shl    $0x3,%edx
c0001938:	81 c2 60 31 01 c0    	add    $0xc0013160,%edx
c000193e:	50                   	push   %eax
c000193f:	68 8e 00 00 00       	push   $0x8e
c0001944:	52                   	push   %edx
c0001945:	e8 85 ff ff ff       	call   c00018cf <make_idt_desc>
c000194a:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/kernel/interrupt.c:76 (discriminator 3)

/*初始化中断描述符表*/
static void idt_desc_init(void) {
	int i;
	int lastindex = IDT_DESC_CNT - 1;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c000194d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:76 (discriminator 1)
c0001951:	81 7d f4 80 00 00 00 	cmpl   $0x80,-0xc(%ebp)
c0001958:	7e ce                	jle    c0001928 <idt_desc_init+0x16>
/work/x86_os_my/kernel/interrupt.c:81
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
	}
	/* 系统调用对应的中断门dpl为3！
	 * 中断处理程序为单独的syscall_handler */
	make_idt_desc(&idt[lastindex], IDT_DESC_ATTR_DPL3, syscall_handler);
c000195a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000195d:	c1 e0 03             	shl    $0x3,%eax
c0001960:	05 60 31 01 c0       	add    $0xc0013160,%eax
c0001965:	68 87 23 00 c0       	push   $0xc0002387
c000196a:	68 ee 00 00 00       	push   $0xee
c000196f:	50                   	push   %eax
c0001970:	e8 5a ff ff ff       	call   c00018cf <make_idt_desc>
c0001975:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/kernel/interrupt.c:82
	put_str("   idt_desc_init done\n");
c0001978:	83 ec 0c             	sub    $0xc,%esp
c000197b:	68 86 d9 00 c0       	push   $0xc000d986
c0001980:	e8 2b 0a 00 00       	call   c00023b0 <put_str>
c0001985:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:83
}
c0001988:	90                   	nop
c0001989:	c9                   	leave  
c000198a:	c3                   	ret    

c000198b <general_intr_handler>:
general_intr_handler():
/work/x86_os_my/kernel/interrupt.c:86

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
c000198b:	55                   	push   %ebp
c000198c:	89 e5                	mov    %esp,%ebp
c000198e:	83 ec 28             	sub    $0x28,%esp
c0001991:	8b 45 08             	mov    0x8(%ebp),%eax
c0001994:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/kernel/interrupt.c:87
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
c0001997:	80 7d e4 27          	cmpb   $0x27,-0x1c(%ebp)
c000199b:	0f 84 bf 00 00 00    	je     c0001a60 <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:87 (discriminator 1)
c00019a1:	80 7d e4 2f          	cmpb   $0x2f,-0x1c(%ebp)
c00019a5:	0f 84 b5 00 00 00    	je     c0001a60 <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:92
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
c00019ab:	83 ec 0c             	sub    $0xc,%esp
c00019ae:	6a 00                	push   $0x0
c00019b0:	e8 88 0b 00 00       	call   c000253d <set_cursor>
c00019b5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:93
	int cursor_pos = 0;
c00019b8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:94
	while(cursor_pos < 320) {
c00019bf:	eb 11                	jmp    c00019d2 <general_intr_handler+0x47>
/work/x86_os_my/kernel/interrupt.c:95
		put_char(' ');
c00019c1:	83 ec 0c             	sub    $0xc,%esp
c00019c4:	6a 20                	push   $0x20
c00019c6:	e8 03 0a 00 00       	call   c00023ce <put_char>
c00019cb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:96
		cursor_pos++;
c00019ce:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:94
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
	int cursor_pos = 0;
	while(cursor_pos < 320) {
c00019d2:	81 7d f4 3f 01 00 00 	cmpl   $0x13f,-0xc(%ebp)
c00019d9:	7e e6                	jle    c00019c1 <general_intr_handler+0x36>
/work/x86_os_my/kernel/interrupt.c:100
		put_char(' ');
		cursor_pos++;
	}

	/* 将光标置为左上角 打印信息 */
	set_cursor(0);
c00019db:	83 ec 0c             	sub    $0xc,%esp
c00019de:	6a 00                	push   $0x0
c00019e0:	e8 58 0b 00 00       	call   c000253d <set_cursor>
c00019e5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:101
	put_str("!!!!!!!      excetion message begin  !!!!!!!!\n");
c00019e8:	83 ec 0c             	sub    $0xc,%esp
c00019eb:	68 a0 d9 00 c0       	push   $0xc000d9a0
c00019f0:	e8 bb 09 00 00       	call   c00023b0 <put_str>
c00019f5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:102
	set_cursor(88);			// 第2行第8个字符
c00019f8:	83 ec 0c             	sub    $0xc,%esp
c00019fb:	6a 58                	push   $0x58
c00019fd:	e8 3b 0b 00 00       	call   c000253d <set_cursor>
c0001a02:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:103
	put_str(intr_name[vec_nr]);
c0001a05:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0001a09:	8b 04 85 00 3d 01 c0 	mov    -0x3ffec300(,%eax,4),%eax
c0001a10:	83 ec 0c             	sub    $0xc,%esp
c0001a13:	50                   	push   %eax
c0001a14:	e8 97 09 00 00       	call   c00023b0 <put_str>
c0001a19:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:104
	if (vec_nr == 14) {		// 若为Pagefault,将缺失的地址打印出来并悬停
c0001a1c:	80 7d e4 0e          	cmpb   $0xe,-0x1c(%ebp)
c0001a20:	75 2c                	jne    c0001a4e <general_intr_handler+0xc3>
/work/x86_os_my/kernel/interrupt.c:105
		int page_fault_vaddr = 0; 
c0001a22:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:106
		asm ("movl %%cr2, %0" : "=r" (page_fault_vaddr));	  // cr2是存放造成page_fault的地址
c0001a29:	0f 20 d0             	mov    %cr2,%eax
c0001a2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:107
		put_str("\npage fault addr is 0x");
c0001a2f:	83 ec 0c             	sub    $0xc,%esp
c0001a32:	68 cf d9 00 c0       	push   $0xc000d9cf
c0001a37:	e8 74 09 00 00       	call   c00023b0 <put_str>
c0001a3c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:108
		put_int(page_fault_vaddr); 
c0001a3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001a42:	83 ec 0c             	sub    $0xc,%esp
c0001a45:	50                   	push   %eax
c0001a46:	e8 8f 0a 00 00       	call   c00024da <put_int>
c0001a4b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:110
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
c0001a4e:	83 ec 0c             	sub    $0xc,%esp
c0001a51:	68 e8 d9 00 c0       	push   $0xc000d9e8
c0001a56:	e8 55 09 00 00       	call   c00023b0 <put_str>
c0001a5b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:113 (discriminator 1)
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
c0001a5e:	eb fe                	jmp    c0001a5e <general_intr_handler+0xd3>
/work/x86_os_my/kernel/interrupt.c:88
}

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
c0001a60:	90                   	nop
/work/x86_os_my/kernel/interrupt.c:114
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
}
c0001a61:	c9                   	leave  
c0001a62:	c3                   	ret    

c0001a63 <exception_init>:
exception_init():
/work/x86_os_my/kernel/interrupt.c:117

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
c0001a63:	55                   	push   %ebp
c0001a64:	89 e5                	mov    %esp,%ebp
c0001a66:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:119
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001a69:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0001a70:	eb 20                	jmp    c0001a92 <exception_init+0x2f>
/work/x86_os_my/kernel/interrupt.c:122 (discriminator 3)
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
c0001a72:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001a75:	c7 04 85 20 3f 01 c0 	movl   $0xc000198b,-0x3ffec0e0(,%eax,4)
c0001a7c:	8b 19 00 c0 
/work/x86_os_my/kernel/interrupt.c:123 (discriminator 3)
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
c0001a80:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001a83:	c7 04 85 00 3d 01 c0 	movl   $0xc000da18,-0x3ffec300(,%eax,4)
c0001a8a:	18 da 00 c0 
/work/x86_os_my/kernel/interrupt.c:119 (discriminator 3)
}

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001a8e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:119 (discriminator 1)
c0001a92:	81 7d fc 80 00 00 00 	cmpl   $0x80,-0x4(%ebp)
c0001a99:	7e d7                	jle    c0001a72 <exception_init+0xf>
/work/x86_os_my/kernel/interrupt.c:125
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
	}
	intr_name[0] = "#DE Divide Error";
c0001a9b:	c7 05 00 3d 01 c0 20 	movl   $0xc000da20,0xc0013d00
c0001aa2:	da 00 c0 
/work/x86_os_my/kernel/interrupt.c:126
	intr_name[1] = "#DB Debug Exception";
c0001aa5:	c7 05 04 3d 01 c0 31 	movl   $0xc000da31,0xc0013d04
c0001aac:	da 00 c0 
/work/x86_os_my/kernel/interrupt.c:127
	intr_name[2] = "NMI Interrupt";
c0001aaf:	c7 05 08 3d 01 c0 45 	movl   $0xc000da45,0xc0013d08
c0001ab6:	da 00 c0 
/work/x86_os_my/kernel/interrupt.c:128
	intr_name[3] = "#BP Breakpoint Exception";
c0001ab9:	c7 05 0c 3d 01 c0 53 	movl   $0xc000da53,0xc0013d0c
c0001ac0:	da 00 c0 
/work/x86_os_my/kernel/interrupt.c:129
	intr_name[4] = "#OF Overflow Exception";
c0001ac3:	c7 05 10 3d 01 c0 6c 	movl   $0xc000da6c,0xc0013d10
c0001aca:	da 00 c0 
/work/x86_os_my/kernel/interrupt.c:130
	intr_name[5] = "#BR BOUND Range Exceeded Exception";
c0001acd:	c7 05 14 3d 01 c0 84 	movl   $0xc000da84,0xc0013d14
c0001ad4:	da 00 c0 
/work/x86_os_my/kernel/interrupt.c:131
	intr_name[6] = "#UD Invalid Opcode Exception";
c0001ad7:	c7 05 18 3d 01 c0 a7 	movl   $0xc000daa7,0xc0013d18
c0001ade:	da 00 c0 
/work/x86_os_my/kernel/interrupt.c:132
	intr_name[7] = "#NM Device Not Available Exception";
c0001ae1:	c7 05 1c 3d 01 c0 c4 	movl   $0xc000dac4,0xc0013d1c
c0001ae8:	da 00 c0 
/work/x86_os_my/kernel/interrupt.c:133
	intr_name[8] = "#DF Double Fault Exception";
c0001aeb:	c7 05 20 3d 01 c0 e7 	movl   $0xc000dae7,0xc0013d20
c0001af2:	da 00 c0 
/work/x86_os_my/kernel/interrupt.c:134
	intr_name[9] = "Coprocessor Segment Overrun";
c0001af5:	c7 05 24 3d 01 c0 02 	movl   $0xc000db02,0xc0013d24
c0001afc:	db 00 c0 
/work/x86_os_my/kernel/interrupt.c:135
	intr_name[10] = "#TS Invalid TSS Exception";
c0001aff:	c7 05 28 3d 01 c0 1e 	movl   $0xc000db1e,0xc0013d28
c0001b06:	db 00 c0 
/work/x86_os_my/kernel/interrupt.c:136
	intr_name[11] = "#NP Segment Not Present";
c0001b09:	c7 05 2c 3d 01 c0 38 	movl   $0xc000db38,0xc0013d2c
c0001b10:	db 00 c0 
/work/x86_os_my/kernel/interrupt.c:137
	intr_name[12] = "#SS Stack Fault Exception";
c0001b13:	c7 05 30 3d 01 c0 50 	movl   $0xc000db50,0xc0013d30
c0001b1a:	db 00 c0 
/work/x86_os_my/kernel/interrupt.c:138
	intr_name[13] = "#GP General Protection Exception";
c0001b1d:	c7 05 34 3d 01 c0 6c 	movl   $0xc000db6c,0xc0013d34
c0001b24:	db 00 c0 
/work/x86_os_my/kernel/interrupt.c:139
	intr_name[14] = "#PF Page-Fault Exception";
c0001b27:	c7 05 38 3d 01 c0 8d 	movl   $0xc000db8d,0xc0013d38
c0001b2e:	db 00 c0 
/work/x86_os_my/kernel/interrupt.c:141
	// intr_name[15] 第15项是intel保留项，未使用
	intr_name[16] = "#MF x87 FPU Floating-Point Error";
c0001b31:	c7 05 40 3d 01 c0 a8 	movl   $0xc000dba8,0xc0013d40
c0001b38:	db 00 c0 
/work/x86_os_my/kernel/interrupt.c:142
	intr_name[17] = "#AC Alignment Check Exception";
c0001b3b:	c7 05 44 3d 01 c0 c9 	movl   $0xc000dbc9,0xc0013d44
c0001b42:	db 00 c0 
/work/x86_os_my/kernel/interrupt.c:143
	intr_name[18] = "#MC Machine-Check Exception";
c0001b45:	c7 05 48 3d 01 c0 e7 	movl   $0xc000dbe7,0xc0013d48
c0001b4c:	db 00 c0 
/work/x86_os_my/kernel/interrupt.c:144
	intr_name[19] = "#XF SIMD Floating-Point Exception";
c0001b4f:	c7 05 4c 3d 01 c0 04 	movl   $0xc000dc04,0xc0013d4c
c0001b56:	dc 00 c0 
/work/x86_os_my/kernel/interrupt.c:145
}
c0001b59:	90                   	nop
c0001b5a:	c9                   	leave  
c0001b5b:	c3                   	ret    

c0001b5c <intr_enable>:
intr_enable():
/work/x86_os_my/kernel/interrupt.c:148

/* 开中断并返回开中断前的状态*/
enum intr_status intr_enable() {
c0001b5c:	55                   	push   %ebp
c0001b5d:	89 e5                	mov    %esp,%ebp
c0001b5f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:150
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c0001b62:	e8 65 00 00 00       	call   c0001bcc <intr_get_status>
c0001b67:	83 f8 01             	cmp    $0x1,%eax
c0001b6a:	75 0c                	jne    c0001b78 <intr_enable+0x1c>
/work/x86_os_my/kernel/interrupt.c:151
		old_status = INTR_ON;
c0001b6c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:152
		return old_status;
c0001b73:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b76:	eb 0b                	jmp    c0001b83 <intr_enable+0x27>
/work/x86_os_my/kernel/interrupt.c:154
	} else {
		old_status = INTR_OFF;
c0001b78:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:155
		asm volatile("sti");	 // 开中断,sti指令将IF位置1
c0001b7f:	fb                   	sti    
/work/x86_os_my/kernel/interrupt.c:156
		return old_status;
c0001b80:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:158
	}
}
c0001b83:	c9                   	leave  
c0001b84:	c3                   	ret    

c0001b85 <intr_disable>:
intr_disable():
/work/x86_os_my/kernel/interrupt.c:161

/* 关中断,并且返回关中断前的状态 */
enum intr_status intr_disable() {     
c0001b85:	55                   	push   %ebp
c0001b86:	89 e5                	mov    %esp,%ebp
c0001b88:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:163
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c0001b8b:	e8 3c 00 00 00       	call   c0001bcc <intr_get_status>
c0001b90:	83 f8 01             	cmp    $0x1,%eax
c0001b93:	75 0d                	jne    c0001ba2 <intr_disable+0x1d>
/work/x86_os_my/kernel/interrupt.c:164
		old_status = INTR_ON;
c0001b95:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:165
		asm volatile("cli" : : : "memory"); // 关中断,cli指令将IF位置0
c0001b9c:	fa                   	cli    
/work/x86_os_my/kernel/interrupt.c:166
		return old_status;
c0001b9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001ba0:	eb 0a                	jmp    c0001bac <intr_disable+0x27>
/work/x86_os_my/kernel/interrupt.c:168
	} else {
		old_status = INTR_OFF;
c0001ba2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:169
		return old_status;
c0001ba9:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:171
	}
}
c0001bac:	c9                   	leave  
c0001bad:	c3                   	ret    

c0001bae <intr_set_status>:
intr_set_status():
/work/x86_os_my/kernel/interrupt.c:174

/* 将中断状态设置为status */
enum intr_status intr_set_status(enum intr_status status) {
c0001bae:	55                   	push   %ebp
c0001baf:	89 e5                	mov    %esp,%ebp
c0001bb1:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:175
	return status & INTR_ON ? intr_enable() : intr_disable();
c0001bb4:	8b 45 08             	mov    0x8(%ebp),%eax
c0001bb7:	83 e0 01             	and    $0x1,%eax
c0001bba:	85 c0                	test   %eax,%eax
c0001bbc:	74 07                	je     c0001bc5 <intr_set_status+0x17>
/work/x86_os_my/kernel/interrupt.c:175 (discriminator 1)
c0001bbe:	e8 99 ff ff ff       	call   c0001b5c <intr_enable>
c0001bc3:	eb 05                	jmp    c0001bca <intr_set_status+0x1c>
/work/x86_os_my/kernel/interrupt.c:175 (discriminator 2)
c0001bc5:	e8 bb ff ff ff       	call   c0001b85 <intr_disable>
/work/x86_os_my/kernel/interrupt.c:176 (discriminator 5)
}
c0001bca:	c9                   	leave  
c0001bcb:	c3                   	ret    

c0001bcc <intr_get_status>:
intr_get_status():
/work/x86_os_my/kernel/interrupt.c:179

/* 获取当前中断状态 */
enum intr_status intr_get_status() {
c0001bcc:	55                   	push   %ebp
c0001bcd:	89 e5                	mov    %esp,%ebp
c0001bcf:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:180
	uint32_t eflags = 0; 
c0001bd2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:181
	GET_EFLAGS(eflags);
c0001bd9:	9c                   	pushf  
c0001bda:	58                   	pop    %eax
c0001bdb:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:182
	return (EFLAGS_IF & eflags) ? INTR_ON : INTR_OFF;
c0001bde:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001be1:	25 00 02 00 00       	and    $0x200,%eax
c0001be6:	85 c0                	test   %eax,%eax
c0001be8:	0f 95 c0             	setne  %al
c0001beb:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/kernel/interrupt.c:183
}
c0001bee:	c9                   	leave  
c0001bef:	c3                   	ret    

c0001bf0 <register_handler>:
register_handler():
/work/x86_os_my/kernel/interrupt.c:186

/* 在中断处理程序数组第vector_no个元素中注册安装中断处理程序function */
void register_handler(uint8_t vector_no, intr_handler function) {
c0001bf0:	55                   	push   %ebp
c0001bf1:	89 e5                	mov    %esp,%ebp
c0001bf3:	83 ec 04             	sub    $0x4,%esp
c0001bf6:	8b 45 08             	mov    0x8(%ebp),%eax
c0001bf9:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:189
/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
 * 见kernel/kernel.S的call [idt_table + %1*4] */
   idt_table[vector_no] = function; 
c0001bfc:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0001c00:	8b 55 0c             	mov    0xc(%ebp),%edx
c0001c03:	89 14 85 20 3f 01 c0 	mov    %edx,-0x3ffec0e0(,%eax,4)
/work/x86_os_my/kernel/interrupt.c:190
}
c0001c0a:	90                   	nop
c0001c0b:	c9                   	leave  
c0001c0c:	c3                   	ret    

c0001c0d <idt_init>:
idt_init():
/work/x86_os_my/kernel/interrupt.c:193

/*完成有关中断的所有初始化工作*/
void idt_init() {
c0001c0d:	55                   	push   %ebp
c0001c0e:	89 e5                	mov    %esp,%ebp
c0001c10:	56                   	push   %esi
c0001c11:	53                   	push   %ebx
c0001c12:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:194
	put_str("idt_init start\n");
c0001c15:	83 ec 0c             	sub    $0xc,%esp
c0001c18:	68 26 dc 00 c0       	push   $0xc000dc26
c0001c1d:	e8 8e 07 00 00       	call   c00023b0 <put_str>
c0001c22:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:195
	idt_desc_init();	// 初始化中断描述符表
c0001c25:	e8 e8 fc ff ff       	call   c0001912 <idt_desc_init>
/work/x86_os_my/kernel/interrupt.c:196
	exception_init();	// 异常名初始化并注册通常的中断处理函数
c0001c2a:	e8 34 fe ff ff       	call   c0001a63 <exception_init>
/work/x86_os_my/kernel/interrupt.c:197
	pic_init();			// 初始化8259A
c0001c2f:	e8 f5 fb ff ff       	call   c0001829 <pic_init>
/work/x86_os_my/kernel/interrupt.c:201

	/* 加载idt */
	// IDTR 是 48 位的寄存器，低 16 位是 IDT 的界限 = IDT 尺寸大小-1，高 32 位是 IDT 的线性基地址
	uint64_t idt_operand = ((sizeof(idt) - 1) | ((uint64_t)(uint32_t)idt << 16));
c0001c34:	b8 60 31 01 c0       	mov    $0xc0013160,%eax
c0001c39:	ba 00 00 00 00       	mov    $0x0,%edx
c0001c3e:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0001c42:	c1 e0 10             	shl    $0x10,%eax
c0001c45:	89 c1                	mov    %eax,%ecx
c0001c47:	81 c9 07 04 00 00    	or     $0x407,%ecx
c0001c4d:	89 cb                	mov    %ecx,%ebx
c0001c4f:	89 d0                	mov    %edx,%eax
c0001c51:	80 cc 00             	or     $0x0,%ah
c0001c54:	89 c6                	mov    %eax,%esi
c0001c56:	89 5d f0             	mov    %ebx,-0x10(%ebp)
c0001c59:	89 75 f4             	mov    %esi,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:202
	asm volatile("lidt %0" : : "m" (idt_operand));
c0001c5c:	0f 01 5d f0          	lidtl  -0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:203
	put_str("idt_init done\n");
c0001c60:	83 ec 0c             	sub    $0xc,%esp
c0001c63:	68 36 dc 00 c0       	push   $0xc000dc36
c0001c68:	e8 43 07 00 00       	call   c00023b0 <put_str>
c0001c6d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:204
}
c0001c70:	90                   	nop
c0001c71:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001c74:	5b                   	pop    %ebx
c0001c75:	5e                   	pop    %esi
c0001c76:	5d                   	pop    %ebp
c0001c77:	c3                   	ret    

c0001c78 <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c0001c78:	55                   	push   %ebp
c0001c79:	89 e5                	mov    %esp,%ebp
c0001c7b:	83 ec 08             	sub    $0x8,%esp
c0001c7e:	8b 55 08             	mov    0x8(%ebp),%edx
c0001c81:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001c84:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0001c88:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c0001c8b:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0001c8f:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0001c93:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c0001c94:	90                   	nop
c0001c95:	c9                   	leave  
c0001c96:	c3                   	ret    

c0001c97 <frequency_set>:
frequency_set():
/work/x86_os_my/device/timer.c:27
/* 把操作的计数器counter_no、读写锁属性rwl、计数器模式counter_mode写入模式控制寄存器并赋予初始值counter_value */
static void frequency_set(uint8_t counter_port, \
		uint8_t counter_no, \
		uint8_t rwl, \
		uint8_t counter_mode, \
		uint16_t counter_value) {
c0001c97:	55                   	push   %ebp
c0001c98:	89 e5                	mov    %esp,%ebp
c0001c9a:	56                   	push   %esi
c0001c9b:	53                   	push   %ebx
c0001c9c:	83 ec 14             	sub    $0x14,%esp
c0001c9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ca2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c0001ca5:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001ca8:	8b 55 14             	mov    0x14(%ebp),%edx
c0001cab:	8b 75 18             	mov    0x18(%ebp),%esi
c0001cae:	88 45 f4             	mov    %al,-0xc(%ebp)
c0001cb1:	88 5d f0             	mov    %bl,-0x10(%ebp)
c0001cb4:	88 4d ec             	mov    %cl,-0x14(%ebp)
c0001cb7:	88 55 e8             	mov    %dl,-0x18(%ebp)
c0001cba:	66 89 75 e4          	mov    %si,-0x1c(%ebp)
/work/x86_os_my/device/timer.c:29
	/* 往控制字寄存器端口0x43中写入控制字 */
	outb(PIT_CONTROL_PORT, (uint8_t)(counter_no << 6 | rwl << 4 | counter_mode << 1));
c0001cbe:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0001cc2:	c1 e0 06             	shl    $0x6,%eax
c0001cc5:	89 c2                	mov    %eax,%edx
c0001cc7:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0001ccb:	c1 e0 04             	shl    $0x4,%eax
c0001cce:	09 c2                	or     %eax,%edx
c0001cd0:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0001cd4:	01 c0                	add    %eax,%eax
c0001cd6:	09 d0                	or     %edx,%eax
c0001cd8:	0f b6 c0             	movzbl %al,%eax
c0001cdb:	50                   	push   %eax
c0001cdc:	6a 43                	push   $0x43
c0001cde:	e8 95 ff ff ff       	call   c0001c78 <outb>
c0001ce3:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:31
	/* 先写入counter_value的低8位 */
	outb(counter_port, (uint8_t)counter_value);
c0001ce6:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0001cea:	0f b6 d0             	movzbl %al,%edx
c0001ced:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001cf1:	52                   	push   %edx
c0001cf2:	50                   	push   %eax
c0001cf3:	e8 80 ff ff ff       	call   c0001c78 <outb>
c0001cf8:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:33
	/* 再写入counter_value的高8位 */
	outb(counter_port, (uint8_t)counter_value >> 8);
c0001cfb:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001cff:	6a 00                	push   $0x0
c0001d01:	50                   	push   %eax
c0001d02:	e8 71 ff ff ff       	call   c0001c78 <outb>
c0001d07:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:34
}
c0001d0a:	90                   	nop
c0001d0b:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001d0e:	5b                   	pop    %ebx
c0001d0f:	5e                   	pop    %esi
c0001d10:	5d                   	pop    %ebp
c0001d11:	c3                   	ret    

c0001d12 <intr_timer_handler>:
intr_timer_handler():
/work/x86_os_my/device/timer.c:37

/* 时钟的中断处理函数 */
static void intr_timer_handler(void) {
c0001d12:	55                   	push   %ebp
c0001d13:	89 e5                	mov    %esp,%ebp
c0001d15:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/timer.c:38
	struct task_struct* cur_thread = running_thread();		// 返回线程PCB
c0001d18:	e8 2f 21 00 00       	call   c0003e4c <running_thread>
c0001d1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/timer.c:40

	ASSERT(cur_thread->stack_magic == 0x19870916);			// 检查栈是否溢出
c0001d20:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001d23:	8b 80 14 01 00 00    	mov    0x114(%eax),%eax
c0001d29:	3d 16 09 87 19       	cmp    $0x19870916,%eax
c0001d2e:	74 19                	je     c0001d49 <intr_timer_handler+0x37>
/work/x86_os_my/device/timer.c:40 (discriminator 1)
c0001d30:	68 48 dc 00 c0       	push   $0xc000dc48
c0001d35:	68 b0 dc 00 c0       	push   $0xc000dcb0
c0001d3a:	6a 28                	push   $0x28
c0001d3c:	68 6e dc 00 c0       	push   $0xc000dc6e
c0001d41:	e8 1b 08 00 00       	call   c0002561 <panic_spin>
c0001d46:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:42

	cur_thread->elapsed_ticks++;// 记录此线程占用的cpu时间
c0001d49:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001d4c:	8b 40 20             	mov    0x20(%eax),%eax
c0001d4f:	8d 50 01             	lea    0x1(%eax),%edx
c0001d52:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001d55:	89 50 20             	mov    %edx,0x20(%eax)
/work/x86_os_my/device/timer.c:43
	ticks++;	//从内核第一次处理时间中断开始,至今的滴哒数,是内核态和用户态总共的嘀哒数
c0001d58:	a1 24 41 01 c0       	mov    0xc0014124,%eax
c0001d5d:	83 c0 01             	add    $0x1,%eax
c0001d60:	a3 24 41 01 c0       	mov    %eax,0xc0014124
/work/x86_os_my/device/timer.c:45

	if (cur_thread->ticks == 0) {
c0001d65:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001d68:	0f b6 40 1d          	movzbl 0x1d(%eax),%eax
c0001d6c:	84 c0                	test   %al,%al
c0001d6e:	75 07                	jne    c0001d77 <intr_timer_handler+0x65>
/work/x86_os_my/device/timer.c:46
		schedule();				// 若进程时间片用完就开始调度新的进程上cpu
c0001d70:	e8 ea 24 00 00       	call   c000425f <schedule>
/work/x86_os_my/device/timer.c:50
	} else {
		cur_thread->ticks--;	// 将当前进程的时间片-1
	}
}
c0001d75:	eb 10                	jmp    c0001d87 <intr_timer_handler+0x75>
/work/x86_os_my/device/timer.c:48
	ticks++;	//从内核第一次处理时间中断开始,至今的滴哒数,是内核态和用户态总共的嘀哒数

	if (cur_thread->ticks == 0) {
		schedule();				// 若进程时间片用完就开始调度新的进程上cpu
	} else {
		cur_thread->ticks--;	// 将当前进程的时间片-1
c0001d77:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001d7a:	0f b6 40 1d          	movzbl 0x1d(%eax),%eax
c0001d7e:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001d81:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001d84:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/device/timer.c:50
	}
}
c0001d87:	90                   	nop
c0001d88:	c9                   	leave  
c0001d89:	c3                   	ret    

c0001d8a <ticks_to_sleep>:
ticks_to_sleep():
/work/x86_os_my/device/timer.c:53

/* 以tick为单位的sleep,任何时间形式的sleep会转换此ticks形式 */
static void ticks_to_sleep(uint32_t sleep_ticks) {
c0001d8a:	55                   	push   %ebp
c0001d8b:	89 e5                	mov    %esp,%ebp
c0001d8d:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/timer.c:54
	uint32_t start_tick = ticks;
c0001d90:	a1 24 41 01 c0       	mov    0xc0014124,%eax
c0001d95:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/timer.c:57

	/* 若间隔的ticks数不够便让出cpu */
	while (ticks - start_tick < sleep_ticks) {
c0001d98:	eb 05                	jmp    c0001d9f <ticks_to_sleep+0x15>
/work/x86_os_my/device/timer.c:58
		thread_yield();
c0001d9a:	e8 6a 27 00 00       	call   c0004509 <thread_yield>
/work/x86_os_my/device/timer.c:57
/* 以tick为单位的sleep,任何时间形式的sleep会转换此ticks形式 */
static void ticks_to_sleep(uint32_t sleep_ticks) {
	uint32_t start_tick = ticks;

	/* 若间隔的ticks数不够便让出cpu */
	while (ticks - start_tick < sleep_ticks) {
c0001d9f:	a1 24 41 01 c0       	mov    0xc0014124,%eax
c0001da4:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0001da7:	3b 45 08             	cmp    0x8(%ebp),%eax
c0001daa:	72 ee                	jb     c0001d9a <ticks_to_sleep+0x10>
/work/x86_os_my/device/timer.c:60
		thread_yield();
	}
}
c0001dac:	90                   	nop
c0001dad:	c9                   	leave  
c0001dae:	c3                   	ret    

c0001daf <mtime_sleep>:
mtime_sleep():
/work/x86_os_my/device/timer.c:62

void mtime_sleep(uint32_t m_seconds) {
c0001daf:	55                   	push   %ebp
c0001db0:	89 e5                	mov    %esp,%ebp
c0001db2:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/timer.c:63
	uint32_t sleep_ticks = DIV_ROUND_UP(m_seconds, mil_seconds_per_intr);
c0001db5:	8b 45 08             	mov    0x8(%ebp),%eax
c0001db8:	83 c0 09             	add    $0x9,%eax
c0001dbb:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
c0001dc0:	f7 e2                	mul    %edx
c0001dc2:	89 d0                	mov    %edx,%eax
c0001dc4:	c1 e8 03             	shr    $0x3,%eax
c0001dc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/timer.c:64
	ASSERT(sleep_ticks > 0);
c0001dca:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0001dce:	75 19                	jne    c0001de9 <mtime_sleep+0x3a>
/work/x86_os_my/device/timer.c:64 (discriminator 1)
c0001dd0:	68 7d dc 00 c0       	push   $0xc000dc7d
c0001dd5:	68 c4 dc 00 c0       	push   $0xc000dcc4
c0001dda:	6a 40                	push   $0x40
c0001ddc:	68 6e dc 00 c0       	push   $0xc000dc6e
c0001de1:	e8 7b 07 00 00       	call   c0002561 <panic_spin>
c0001de6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:65
	ticks_to_sleep(sleep_ticks); 
c0001de9:	83 ec 0c             	sub    $0xc,%esp
c0001dec:	ff 75 f4             	pushl  -0xc(%ebp)
c0001def:	e8 96 ff ff ff       	call   c0001d8a <ticks_to_sleep>
c0001df4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:66
}
c0001df7:	90                   	nop
c0001df8:	c9                   	leave  
c0001df9:	c3                   	ret    

c0001dfa <timer_init>:
timer_init():
/work/x86_os_my/device/timer.c:69

/* 初始化PIT8253 */
void timer_init() {
c0001dfa:	55                   	push   %ebp
c0001dfb:	89 e5                	mov    %esp,%ebp
c0001dfd:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/timer.c:70
	put_str("timer_init start\n");
c0001e00:	83 ec 0c             	sub    $0xc,%esp
c0001e03:	68 8d dc 00 c0       	push   $0xc000dc8d
c0001e08:	e8 a3 05 00 00       	call   c00023b0 <put_str>
c0001e0d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:72
	/* 设置8253的定时周期,也就是发中断的周期 */
	frequency_set(CONTRER0_PORT, COUNTER0_NO, READ_WRITE_LATCH, COUNTER_MODE, COUNTER0_VALUE);
c0001e10:	83 ec 0c             	sub    $0xc,%esp
c0001e13:	68 9b 2e 00 00       	push   $0x2e9b
c0001e18:	6a 02                	push   $0x2
c0001e1a:	6a 03                	push   $0x3
c0001e1c:	6a 00                	push   $0x0
c0001e1e:	6a 40                	push   $0x40
c0001e20:	e8 72 fe ff ff       	call   c0001c97 <frequency_set>
c0001e25:	83 c4 20             	add    $0x20,%esp
/work/x86_os_my/device/timer.c:73
	register_handler(0x20, intr_timer_handler);
c0001e28:	83 ec 08             	sub    $0x8,%esp
c0001e2b:	68 12 1d 00 c0       	push   $0xc0001d12
c0001e30:	6a 20                	push   $0x20
c0001e32:	e8 b9 fd ff ff       	call   c0001bf0 <register_handler>
c0001e37:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:74
	put_str("timer_init done\n");
c0001e3a:	83 ec 0c             	sub    $0xc,%esp
c0001e3d:	68 9f dc 00 c0       	push   $0xc000dc9f
c0001e42:	e8 69 05 00 00       	call   c00023b0 <put_str>
c0001e47:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:75
}
c0001e4a:	90                   	nop
c0001e4b:	c9                   	leave  
c0001e4c:	c3                   	ret    
c0001e4d:	66 90                	xchg   %ax,%ax
c0001e4f:	90                   	nop

c0001e50 <intr_exit>:
intr_exit():
c0001e50:	83 c4 04             	add    $0x4,%esp
c0001e53:	61                   	popa   
c0001e54:	0f a9                	pop    %gs
c0001e56:	0f a1                	pop    %fs
c0001e58:	07                   	pop    %es
c0001e59:	1f                   	pop    %ds
c0001e5a:	83 c4 04             	add    $0x4,%esp
c0001e5d:	cf                   	iret   

c0001e5e <intr0x00entry>:
intr0x00entry():
c0001e5e:	6a 00                	push   $0x0
c0001e60:	1e                   	push   %ds
c0001e61:	06                   	push   %es
c0001e62:	0f a0                	push   %fs
c0001e64:	0f a8                	push   %gs
c0001e66:	60                   	pusha  
c0001e67:	b0 20                	mov    $0x20,%al
c0001e69:	e6 a0                	out    %al,$0xa0
c0001e6b:	e6 20                	out    %al,$0x20
c0001e6d:	6a 00                	push   $0x0
c0001e6f:	ff 15 20 3f 01 c0    	call   *0xc0013f20
c0001e75:	eb d9                	jmp    c0001e50 <intr_exit>

c0001e77 <intr0x01entry>:
intr0x01entry():
c0001e77:	6a 00                	push   $0x0
c0001e79:	1e                   	push   %ds
c0001e7a:	06                   	push   %es
c0001e7b:	0f a0                	push   %fs
c0001e7d:	0f a8                	push   %gs
c0001e7f:	60                   	pusha  
c0001e80:	b0 20                	mov    $0x20,%al
c0001e82:	e6 a0                	out    %al,$0xa0
c0001e84:	e6 20                	out    %al,$0x20
c0001e86:	6a 01                	push   $0x1
c0001e88:	ff 15 24 3f 01 c0    	call   *0xc0013f24
c0001e8e:	eb c0                	jmp    c0001e50 <intr_exit>

c0001e90 <intr0x02entry>:
intr0x02entry():
c0001e90:	6a 00                	push   $0x0
c0001e92:	1e                   	push   %ds
c0001e93:	06                   	push   %es
c0001e94:	0f a0                	push   %fs
c0001e96:	0f a8                	push   %gs
c0001e98:	60                   	pusha  
c0001e99:	b0 20                	mov    $0x20,%al
c0001e9b:	e6 a0                	out    %al,$0xa0
c0001e9d:	e6 20                	out    %al,$0x20
c0001e9f:	6a 02                	push   $0x2
c0001ea1:	ff 15 28 3f 01 c0    	call   *0xc0013f28
c0001ea7:	eb a7                	jmp    c0001e50 <intr_exit>

c0001ea9 <intr0x03entry>:
intr0x03entry():
c0001ea9:	6a 00                	push   $0x0
c0001eab:	1e                   	push   %ds
c0001eac:	06                   	push   %es
c0001ead:	0f a0                	push   %fs
c0001eaf:	0f a8                	push   %gs
c0001eb1:	60                   	pusha  
c0001eb2:	b0 20                	mov    $0x20,%al
c0001eb4:	e6 a0                	out    %al,$0xa0
c0001eb6:	e6 20                	out    %al,$0x20
c0001eb8:	6a 03                	push   $0x3
c0001eba:	ff 15 2c 3f 01 c0    	call   *0xc0013f2c
c0001ec0:	eb 8e                	jmp    c0001e50 <intr_exit>

c0001ec2 <intr0x04entry>:
intr0x04entry():
c0001ec2:	6a 00                	push   $0x0
c0001ec4:	1e                   	push   %ds
c0001ec5:	06                   	push   %es
c0001ec6:	0f a0                	push   %fs
c0001ec8:	0f a8                	push   %gs
c0001eca:	60                   	pusha  
c0001ecb:	b0 20                	mov    $0x20,%al
c0001ecd:	e6 a0                	out    %al,$0xa0
c0001ecf:	e6 20                	out    %al,$0x20
c0001ed1:	6a 04                	push   $0x4
c0001ed3:	ff 15 30 3f 01 c0    	call   *0xc0013f30
c0001ed9:	e9 72 ff ff ff       	jmp    c0001e50 <intr_exit>

c0001ede <intr0x05entry>:
intr0x05entry():
c0001ede:	6a 00                	push   $0x0
c0001ee0:	1e                   	push   %ds
c0001ee1:	06                   	push   %es
c0001ee2:	0f a0                	push   %fs
c0001ee4:	0f a8                	push   %gs
c0001ee6:	60                   	pusha  
c0001ee7:	b0 20                	mov    $0x20,%al
c0001ee9:	e6 a0                	out    %al,$0xa0
c0001eeb:	e6 20                	out    %al,$0x20
c0001eed:	6a 05                	push   $0x5
c0001eef:	ff 15 34 3f 01 c0    	call   *0xc0013f34
c0001ef5:	e9 56 ff ff ff       	jmp    c0001e50 <intr_exit>

c0001efa <intr0x06entry>:
intr0x06entry():
c0001efa:	6a 00                	push   $0x0
c0001efc:	1e                   	push   %ds
c0001efd:	06                   	push   %es
c0001efe:	0f a0                	push   %fs
c0001f00:	0f a8                	push   %gs
c0001f02:	60                   	pusha  
c0001f03:	b0 20                	mov    $0x20,%al
c0001f05:	e6 a0                	out    %al,$0xa0
c0001f07:	e6 20                	out    %al,$0x20
c0001f09:	6a 06                	push   $0x6
c0001f0b:	ff 15 38 3f 01 c0    	call   *0xc0013f38
c0001f11:	e9 3a ff ff ff       	jmp    c0001e50 <intr_exit>

c0001f16 <intr0x07entry>:
intr0x07entry():
c0001f16:	6a 00                	push   $0x0
c0001f18:	1e                   	push   %ds
c0001f19:	06                   	push   %es
c0001f1a:	0f a0                	push   %fs
c0001f1c:	0f a8                	push   %gs
c0001f1e:	60                   	pusha  
c0001f1f:	b0 20                	mov    $0x20,%al
c0001f21:	e6 a0                	out    %al,$0xa0
c0001f23:	e6 20                	out    %al,$0x20
c0001f25:	6a 07                	push   $0x7
c0001f27:	ff 15 3c 3f 01 c0    	call   *0xc0013f3c
c0001f2d:	e9 1e ff ff ff       	jmp    c0001e50 <intr_exit>

c0001f32 <intr0x08entry>:
intr0x08entry():
c0001f32:	90                   	nop
c0001f33:	1e                   	push   %ds
c0001f34:	06                   	push   %es
c0001f35:	0f a0                	push   %fs
c0001f37:	0f a8                	push   %gs
c0001f39:	60                   	pusha  
c0001f3a:	b0 20                	mov    $0x20,%al
c0001f3c:	e6 a0                	out    %al,$0xa0
c0001f3e:	e6 20                	out    %al,$0x20
c0001f40:	6a 08                	push   $0x8
c0001f42:	ff 15 40 3f 01 c0    	call   *0xc0013f40
c0001f48:	e9 03 ff ff ff       	jmp    c0001e50 <intr_exit>

c0001f4d <intr0x09entry>:
intr0x09entry():
c0001f4d:	6a 00                	push   $0x0
c0001f4f:	1e                   	push   %ds
c0001f50:	06                   	push   %es
c0001f51:	0f a0                	push   %fs
c0001f53:	0f a8                	push   %gs
c0001f55:	60                   	pusha  
c0001f56:	b0 20                	mov    $0x20,%al
c0001f58:	e6 a0                	out    %al,$0xa0
c0001f5a:	e6 20                	out    %al,$0x20
c0001f5c:	6a 09                	push   $0x9
c0001f5e:	ff 15 44 3f 01 c0    	call   *0xc0013f44
c0001f64:	e9 e7 fe ff ff       	jmp    c0001e50 <intr_exit>

c0001f69 <intr0x0aentry>:
intr0x0aentry():
c0001f69:	90                   	nop
c0001f6a:	1e                   	push   %ds
c0001f6b:	06                   	push   %es
c0001f6c:	0f a0                	push   %fs
c0001f6e:	0f a8                	push   %gs
c0001f70:	60                   	pusha  
c0001f71:	b0 20                	mov    $0x20,%al
c0001f73:	e6 a0                	out    %al,$0xa0
c0001f75:	e6 20                	out    %al,$0x20
c0001f77:	6a 0a                	push   $0xa
c0001f79:	ff 15 48 3f 01 c0    	call   *0xc0013f48
c0001f7f:	e9 cc fe ff ff       	jmp    c0001e50 <intr_exit>

c0001f84 <intr0x0bentry>:
intr0x0bentry():
c0001f84:	90                   	nop
c0001f85:	1e                   	push   %ds
c0001f86:	06                   	push   %es
c0001f87:	0f a0                	push   %fs
c0001f89:	0f a8                	push   %gs
c0001f8b:	60                   	pusha  
c0001f8c:	b0 20                	mov    $0x20,%al
c0001f8e:	e6 a0                	out    %al,$0xa0
c0001f90:	e6 20                	out    %al,$0x20
c0001f92:	6a 0b                	push   $0xb
c0001f94:	ff 15 4c 3f 01 c0    	call   *0xc0013f4c
c0001f9a:	e9 b1 fe ff ff       	jmp    c0001e50 <intr_exit>

c0001f9f <intr0x0centry>:
intr0x0centry():
c0001f9f:	6a 00                	push   $0x0
c0001fa1:	1e                   	push   %ds
c0001fa2:	06                   	push   %es
c0001fa3:	0f a0                	push   %fs
c0001fa5:	0f a8                	push   %gs
c0001fa7:	60                   	pusha  
c0001fa8:	b0 20                	mov    $0x20,%al
c0001faa:	e6 a0                	out    %al,$0xa0
c0001fac:	e6 20                	out    %al,$0x20
c0001fae:	6a 0c                	push   $0xc
c0001fb0:	ff 15 50 3f 01 c0    	call   *0xc0013f50
c0001fb6:	e9 95 fe ff ff       	jmp    c0001e50 <intr_exit>

c0001fbb <intr0x0dentry>:
intr0x0dentry():
c0001fbb:	90                   	nop
c0001fbc:	1e                   	push   %ds
c0001fbd:	06                   	push   %es
c0001fbe:	0f a0                	push   %fs
c0001fc0:	0f a8                	push   %gs
c0001fc2:	60                   	pusha  
c0001fc3:	b0 20                	mov    $0x20,%al
c0001fc5:	e6 a0                	out    %al,$0xa0
c0001fc7:	e6 20                	out    %al,$0x20
c0001fc9:	6a 0d                	push   $0xd
c0001fcb:	ff 15 54 3f 01 c0    	call   *0xc0013f54
c0001fd1:	e9 7a fe ff ff       	jmp    c0001e50 <intr_exit>

c0001fd6 <intr0x0eentry>:
intr0x0eentry():
c0001fd6:	90                   	nop
c0001fd7:	1e                   	push   %ds
c0001fd8:	06                   	push   %es
c0001fd9:	0f a0                	push   %fs
c0001fdb:	0f a8                	push   %gs
c0001fdd:	60                   	pusha  
c0001fde:	b0 20                	mov    $0x20,%al
c0001fe0:	e6 a0                	out    %al,$0xa0
c0001fe2:	e6 20                	out    %al,$0x20
c0001fe4:	6a 0e                	push   $0xe
c0001fe6:	ff 15 58 3f 01 c0    	call   *0xc0013f58
c0001fec:	e9 5f fe ff ff       	jmp    c0001e50 <intr_exit>

c0001ff1 <intr0x0fentry>:
intr0x0fentry():
c0001ff1:	6a 00                	push   $0x0
c0001ff3:	1e                   	push   %ds
c0001ff4:	06                   	push   %es
c0001ff5:	0f a0                	push   %fs
c0001ff7:	0f a8                	push   %gs
c0001ff9:	60                   	pusha  
c0001ffa:	b0 20                	mov    $0x20,%al
c0001ffc:	e6 a0                	out    %al,$0xa0
c0001ffe:	e6 20                	out    %al,$0x20
c0002000:	6a 0f                	push   $0xf
c0002002:	ff 15 5c 3f 01 c0    	call   *0xc0013f5c
c0002008:	e9 43 fe ff ff       	jmp    c0001e50 <intr_exit>

c000200d <intr0x10entry>:
intr0x10entry():
c000200d:	6a 00                	push   $0x0
c000200f:	1e                   	push   %ds
c0002010:	06                   	push   %es
c0002011:	0f a0                	push   %fs
c0002013:	0f a8                	push   %gs
c0002015:	60                   	pusha  
c0002016:	b0 20                	mov    $0x20,%al
c0002018:	e6 a0                	out    %al,$0xa0
c000201a:	e6 20                	out    %al,$0x20
c000201c:	6a 10                	push   $0x10
c000201e:	ff 15 60 3f 01 c0    	call   *0xc0013f60
c0002024:	e9 27 fe ff ff       	jmp    c0001e50 <intr_exit>

c0002029 <intr0x11entry>:
intr0x11entry():
c0002029:	90                   	nop
c000202a:	1e                   	push   %ds
c000202b:	06                   	push   %es
c000202c:	0f a0                	push   %fs
c000202e:	0f a8                	push   %gs
c0002030:	60                   	pusha  
c0002031:	b0 20                	mov    $0x20,%al
c0002033:	e6 a0                	out    %al,$0xa0
c0002035:	e6 20                	out    %al,$0x20
c0002037:	6a 11                	push   $0x11
c0002039:	ff 15 64 3f 01 c0    	call   *0xc0013f64
c000203f:	e9 0c fe ff ff       	jmp    c0001e50 <intr_exit>

c0002044 <intr0x12entry>:
intr0x12entry():
c0002044:	6a 00                	push   $0x0
c0002046:	1e                   	push   %ds
c0002047:	06                   	push   %es
c0002048:	0f a0                	push   %fs
c000204a:	0f a8                	push   %gs
c000204c:	60                   	pusha  
c000204d:	b0 20                	mov    $0x20,%al
c000204f:	e6 a0                	out    %al,$0xa0
c0002051:	e6 20                	out    %al,$0x20
c0002053:	6a 12                	push   $0x12
c0002055:	ff 15 68 3f 01 c0    	call   *0xc0013f68
c000205b:	e9 f0 fd ff ff       	jmp    c0001e50 <intr_exit>

c0002060 <intr0x13entry>:
intr0x13entry():
c0002060:	6a 00                	push   $0x0
c0002062:	1e                   	push   %ds
c0002063:	06                   	push   %es
c0002064:	0f a0                	push   %fs
c0002066:	0f a8                	push   %gs
c0002068:	60                   	pusha  
c0002069:	b0 20                	mov    $0x20,%al
c000206b:	e6 a0                	out    %al,$0xa0
c000206d:	e6 20                	out    %al,$0x20
c000206f:	6a 13                	push   $0x13
c0002071:	ff 15 6c 3f 01 c0    	call   *0xc0013f6c
c0002077:	e9 d4 fd ff ff       	jmp    c0001e50 <intr_exit>

c000207c <intr0x14entry>:
intr0x14entry():
c000207c:	6a 00                	push   $0x0
c000207e:	1e                   	push   %ds
c000207f:	06                   	push   %es
c0002080:	0f a0                	push   %fs
c0002082:	0f a8                	push   %gs
c0002084:	60                   	pusha  
c0002085:	b0 20                	mov    $0x20,%al
c0002087:	e6 a0                	out    %al,$0xa0
c0002089:	e6 20                	out    %al,$0x20
c000208b:	6a 14                	push   $0x14
c000208d:	ff 15 70 3f 01 c0    	call   *0xc0013f70
c0002093:	e9 b8 fd ff ff       	jmp    c0001e50 <intr_exit>

c0002098 <intr0x15entry>:
intr0x15entry():
c0002098:	6a 00                	push   $0x0
c000209a:	1e                   	push   %ds
c000209b:	06                   	push   %es
c000209c:	0f a0                	push   %fs
c000209e:	0f a8                	push   %gs
c00020a0:	60                   	pusha  
c00020a1:	b0 20                	mov    $0x20,%al
c00020a3:	e6 a0                	out    %al,$0xa0
c00020a5:	e6 20                	out    %al,$0x20
c00020a7:	6a 15                	push   $0x15
c00020a9:	ff 15 74 3f 01 c0    	call   *0xc0013f74
c00020af:	e9 9c fd ff ff       	jmp    c0001e50 <intr_exit>

c00020b4 <intr0x16entry>:
intr0x16entry():
c00020b4:	6a 00                	push   $0x0
c00020b6:	1e                   	push   %ds
c00020b7:	06                   	push   %es
c00020b8:	0f a0                	push   %fs
c00020ba:	0f a8                	push   %gs
c00020bc:	60                   	pusha  
c00020bd:	b0 20                	mov    $0x20,%al
c00020bf:	e6 a0                	out    %al,$0xa0
c00020c1:	e6 20                	out    %al,$0x20
c00020c3:	6a 16                	push   $0x16
c00020c5:	ff 15 78 3f 01 c0    	call   *0xc0013f78
c00020cb:	e9 80 fd ff ff       	jmp    c0001e50 <intr_exit>

c00020d0 <intr0x17entry>:
intr0x17entry():
c00020d0:	6a 00                	push   $0x0
c00020d2:	1e                   	push   %ds
c00020d3:	06                   	push   %es
c00020d4:	0f a0                	push   %fs
c00020d6:	0f a8                	push   %gs
c00020d8:	60                   	pusha  
c00020d9:	b0 20                	mov    $0x20,%al
c00020db:	e6 a0                	out    %al,$0xa0
c00020dd:	e6 20                	out    %al,$0x20
c00020df:	6a 17                	push   $0x17
c00020e1:	ff 15 7c 3f 01 c0    	call   *0xc0013f7c
c00020e7:	e9 64 fd ff ff       	jmp    c0001e50 <intr_exit>

c00020ec <intr0x18entry>:
intr0x18entry():
c00020ec:	90                   	nop
c00020ed:	1e                   	push   %ds
c00020ee:	06                   	push   %es
c00020ef:	0f a0                	push   %fs
c00020f1:	0f a8                	push   %gs
c00020f3:	60                   	pusha  
c00020f4:	b0 20                	mov    $0x20,%al
c00020f6:	e6 a0                	out    %al,$0xa0
c00020f8:	e6 20                	out    %al,$0x20
c00020fa:	6a 18                	push   $0x18
c00020fc:	ff 15 80 3f 01 c0    	call   *0xc0013f80
c0002102:	e9 49 fd ff ff       	jmp    c0001e50 <intr_exit>

c0002107 <intr0x19entry>:
intr0x19entry():
c0002107:	6a 00                	push   $0x0
c0002109:	1e                   	push   %ds
c000210a:	06                   	push   %es
c000210b:	0f a0                	push   %fs
c000210d:	0f a8                	push   %gs
c000210f:	60                   	pusha  
c0002110:	b0 20                	mov    $0x20,%al
c0002112:	e6 a0                	out    %al,$0xa0
c0002114:	e6 20                	out    %al,$0x20
c0002116:	6a 19                	push   $0x19
c0002118:	ff 15 84 3f 01 c0    	call   *0xc0013f84
c000211e:	e9 2d fd ff ff       	jmp    c0001e50 <intr_exit>

c0002123 <intr0x1aentry>:
intr0x1aentry():
c0002123:	90                   	nop
c0002124:	1e                   	push   %ds
c0002125:	06                   	push   %es
c0002126:	0f a0                	push   %fs
c0002128:	0f a8                	push   %gs
c000212a:	60                   	pusha  
c000212b:	b0 20                	mov    $0x20,%al
c000212d:	e6 a0                	out    %al,$0xa0
c000212f:	e6 20                	out    %al,$0x20
c0002131:	6a 1a                	push   $0x1a
c0002133:	ff 15 88 3f 01 c0    	call   *0xc0013f88
c0002139:	e9 12 fd ff ff       	jmp    c0001e50 <intr_exit>

c000213e <intr0x1bentry>:
intr0x1bentry():
c000213e:	90                   	nop
c000213f:	1e                   	push   %ds
c0002140:	06                   	push   %es
c0002141:	0f a0                	push   %fs
c0002143:	0f a8                	push   %gs
c0002145:	60                   	pusha  
c0002146:	b0 20                	mov    $0x20,%al
c0002148:	e6 a0                	out    %al,$0xa0
c000214a:	e6 20                	out    %al,$0x20
c000214c:	6a 1b                	push   $0x1b
c000214e:	ff 15 8c 3f 01 c0    	call   *0xc0013f8c
c0002154:	e9 f7 fc ff ff       	jmp    c0001e50 <intr_exit>

c0002159 <intr0x1centry>:
intr0x1centry():
c0002159:	6a 00                	push   $0x0
c000215b:	1e                   	push   %ds
c000215c:	06                   	push   %es
c000215d:	0f a0                	push   %fs
c000215f:	0f a8                	push   %gs
c0002161:	60                   	pusha  
c0002162:	b0 20                	mov    $0x20,%al
c0002164:	e6 a0                	out    %al,$0xa0
c0002166:	e6 20                	out    %al,$0x20
c0002168:	6a 1c                	push   $0x1c
c000216a:	ff 15 90 3f 01 c0    	call   *0xc0013f90
c0002170:	e9 db fc ff ff       	jmp    c0001e50 <intr_exit>

c0002175 <intr0x1dentry>:
intr0x1dentry():
c0002175:	90                   	nop
c0002176:	1e                   	push   %ds
c0002177:	06                   	push   %es
c0002178:	0f a0                	push   %fs
c000217a:	0f a8                	push   %gs
c000217c:	60                   	pusha  
c000217d:	b0 20                	mov    $0x20,%al
c000217f:	e6 a0                	out    %al,$0xa0
c0002181:	e6 20                	out    %al,$0x20
c0002183:	6a 1d                	push   $0x1d
c0002185:	ff 15 94 3f 01 c0    	call   *0xc0013f94
c000218b:	e9 c0 fc ff ff       	jmp    c0001e50 <intr_exit>

c0002190 <intr0x1eentry>:
intr0x1eentry():
c0002190:	90                   	nop
c0002191:	1e                   	push   %ds
c0002192:	06                   	push   %es
c0002193:	0f a0                	push   %fs
c0002195:	0f a8                	push   %gs
c0002197:	60                   	pusha  
c0002198:	b0 20                	mov    $0x20,%al
c000219a:	e6 a0                	out    %al,$0xa0
c000219c:	e6 20                	out    %al,$0x20
c000219e:	6a 1e                	push   $0x1e
c00021a0:	ff 15 98 3f 01 c0    	call   *0xc0013f98
c00021a6:	e9 a5 fc ff ff       	jmp    c0001e50 <intr_exit>

c00021ab <intr0x1fentry>:
intr0x1fentry():
c00021ab:	6a 00                	push   $0x0
c00021ad:	1e                   	push   %ds
c00021ae:	06                   	push   %es
c00021af:	0f a0                	push   %fs
c00021b1:	0f a8                	push   %gs
c00021b3:	60                   	pusha  
c00021b4:	b0 20                	mov    $0x20,%al
c00021b6:	e6 a0                	out    %al,$0xa0
c00021b8:	e6 20                	out    %al,$0x20
c00021ba:	6a 1f                	push   $0x1f
c00021bc:	ff 15 9c 3f 01 c0    	call   *0xc0013f9c
c00021c2:	e9 89 fc ff ff       	jmp    c0001e50 <intr_exit>

c00021c7 <intr0x20entry>:
intr0x20entry():
c00021c7:	6a 00                	push   $0x0
c00021c9:	1e                   	push   %ds
c00021ca:	06                   	push   %es
c00021cb:	0f a0                	push   %fs
c00021cd:	0f a8                	push   %gs
c00021cf:	60                   	pusha  
c00021d0:	b0 20                	mov    $0x20,%al
c00021d2:	e6 a0                	out    %al,$0xa0
c00021d4:	e6 20                	out    %al,$0x20
c00021d6:	6a 20                	push   $0x20
c00021d8:	ff 15 a0 3f 01 c0    	call   *0xc0013fa0
c00021de:	e9 6d fc ff ff       	jmp    c0001e50 <intr_exit>

c00021e3 <intr0x21entry>:
intr0x21entry():
c00021e3:	6a 00                	push   $0x0
c00021e5:	1e                   	push   %ds
c00021e6:	06                   	push   %es
c00021e7:	0f a0                	push   %fs
c00021e9:	0f a8                	push   %gs
c00021eb:	60                   	pusha  
c00021ec:	b0 20                	mov    $0x20,%al
c00021ee:	e6 a0                	out    %al,$0xa0
c00021f0:	e6 20                	out    %al,$0x20
c00021f2:	6a 21                	push   $0x21
c00021f4:	ff 15 a4 3f 01 c0    	call   *0xc0013fa4
c00021fa:	e9 51 fc ff ff       	jmp    c0001e50 <intr_exit>

c00021ff <intr0x22entry>:
intr0x22entry():
c00021ff:	6a 00                	push   $0x0
c0002201:	1e                   	push   %ds
c0002202:	06                   	push   %es
c0002203:	0f a0                	push   %fs
c0002205:	0f a8                	push   %gs
c0002207:	60                   	pusha  
c0002208:	b0 20                	mov    $0x20,%al
c000220a:	e6 a0                	out    %al,$0xa0
c000220c:	e6 20                	out    %al,$0x20
c000220e:	6a 22                	push   $0x22
c0002210:	ff 15 a8 3f 01 c0    	call   *0xc0013fa8
c0002216:	e9 35 fc ff ff       	jmp    c0001e50 <intr_exit>

c000221b <intr0x23entry>:
intr0x23entry():
c000221b:	6a 00                	push   $0x0
c000221d:	1e                   	push   %ds
c000221e:	06                   	push   %es
c000221f:	0f a0                	push   %fs
c0002221:	0f a8                	push   %gs
c0002223:	60                   	pusha  
c0002224:	b0 20                	mov    $0x20,%al
c0002226:	e6 a0                	out    %al,$0xa0
c0002228:	e6 20                	out    %al,$0x20
c000222a:	6a 23                	push   $0x23
c000222c:	ff 15 ac 3f 01 c0    	call   *0xc0013fac
c0002232:	e9 19 fc ff ff       	jmp    c0001e50 <intr_exit>

c0002237 <intr0x24entry>:
intr0x24entry():
c0002237:	6a 00                	push   $0x0
c0002239:	1e                   	push   %ds
c000223a:	06                   	push   %es
c000223b:	0f a0                	push   %fs
c000223d:	0f a8                	push   %gs
c000223f:	60                   	pusha  
c0002240:	b0 20                	mov    $0x20,%al
c0002242:	e6 a0                	out    %al,$0xa0
c0002244:	e6 20                	out    %al,$0x20
c0002246:	6a 24                	push   $0x24
c0002248:	ff 15 b0 3f 01 c0    	call   *0xc0013fb0
c000224e:	e9 fd fb ff ff       	jmp    c0001e50 <intr_exit>

c0002253 <intr0x25entry>:
intr0x25entry():
c0002253:	6a 00                	push   $0x0
c0002255:	1e                   	push   %ds
c0002256:	06                   	push   %es
c0002257:	0f a0                	push   %fs
c0002259:	0f a8                	push   %gs
c000225b:	60                   	pusha  
c000225c:	b0 20                	mov    $0x20,%al
c000225e:	e6 a0                	out    %al,$0xa0
c0002260:	e6 20                	out    %al,$0x20
c0002262:	6a 25                	push   $0x25
c0002264:	ff 15 b4 3f 01 c0    	call   *0xc0013fb4
c000226a:	e9 e1 fb ff ff       	jmp    c0001e50 <intr_exit>

c000226f <intr0x26entry>:
intr0x26entry():
c000226f:	6a 00                	push   $0x0
c0002271:	1e                   	push   %ds
c0002272:	06                   	push   %es
c0002273:	0f a0                	push   %fs
c0002275:	0f a8                	push   %gs
c0002277:	60                   	pusha  
c0002278:	b0 20                	mov    $0x20,%al
c000227a:	e6 a0                	out    %al,$0xa0
c000227c:	e6 20                	out    %al,$0x20
c000227e:	6a 26                	push   $0x26
c0002280:	ff 15 b8 3f 01 c0    	call   *0xc0013fb8
c0002286:	e9 c5 fb ff ff       	jmp    c0001e50 <intr_exit>

c000228b <intr0x27entry>:
intr0x27entry():
c000228b:	6a 00                	push   $0x0
c000228d:	1e                   	push   %ds
c000228e:	06                   	push   %es
c000228f:	0f a0                	push   %fs
c0002291:	0f a8                	push   %gs
c0002293:	60                   	pusha  
c0002294:	b0 20                	mov    $0x20,%al
c0002296:	e6 a0                	out    %al,$0xa0
c0002298:	e6 20                	out    %al,$0x20
c000229a:	6a 27                	push   $0x27
c000229c:	ff 15 bc 3f 01 c0    	call   *0xc0013fbc
c00022a2:	e9 a9 fb ff ff       	jmp    c0001e50 <intr_exit>

c00022a7 <intr0x28entry>:
intr0x28entry():
c00022a7:	6a 00                	push   $0x0
c00022a9:	1e                   	push   %ds
c00022aa:	06                   	push   %es
c00022ab:	0f a0                	push   %fs
c00022ad:	0f a8                	push   %gs
c00022af:	60                   	pusha  
c00022b0:	b0 20                	mov    $0x20,%al
c00022b2:	e6 a0                	out    %al,$0xa0
c00022b4:	e6 20                	out    %al,$0x20
c00022b6:	6a 28                	push   $0x28
c00022b8:	ff 15 c0 3f 01 c0    	call   *0xc0013fc0
c00022be:	e9 8d fb ff ff       	jmp    c0001e50 <intr_exit>

c00022c3 <intr0x29entry>:
intr0x29entry():
c00022c3:	6a 00                	push   $0x0
c00022c5:	1e                   	push   %ds
c00022c6:	06                   	push   %es
c00022c7:	0f a0                	push   %fs
c00022c9:	0f a8                	push   %gs
c00022cb:	60                   	pusha  
c00022cc:	b0 20                	mov    $0x20,%al
c00022ce:	e6 a0                	out    %al,$0xa0
c00022d0:	e6 20                	out    %al,$0x20
c00022d2:	6a 29                	push   $0x29
c00022d4:	ff 15 c4 3f 01 c0    	call   *0xc0013fc4
c00022da:	e9 71 fb ff ff       	jmp    c0001e50 <intr_exit>

c00022df <intr0x2aentry>:
intr0x2aentry():
c00022df:	6a 00                	push   $0x0
c00022e1:	1e                   	push   %ds
c00022e2:	06                   	push   %es
c00022e3:	0f a0                	push   %fs
c00022e5:	0f a8                	push   %gs
c00022e7:	60                   	pusha  
c00022e8:	b0 20                	mov    $0x20,%al
c00022ea:	e6 a0                	out    %al,$0xa0
c00022ec:	e6 20                	out    %al,$0x20
c00022ee:	6a 2a                	push   $0x2a
c00022f0:	ff 15 c8 3f 01 c0    	call   *0xc0013fc8
c00022f6:	e9 55 fb ff ff       	jmp    c0001e50 <intr_exit>

c00022fb <intr0x2bentry>:
intr0x2bentry():
c00022fb:	6a 00                	push   $0x0
c00022fd:	1e                   	push   %ds
c00022fe:	06                   	push   %es
c00022ff:	0f a0                	push   %fs
c0002301:	0f a8                	push   %gs
c0002303:	60                   	pusha  
c0002304:	b0 20                	mov    $0x20,%al
c0002306:	e6 a0                	out    %al,$0xa0
c0002308:	e6 20                	out    %al,$0x20
c000230a:	6a 2b                	push   $0x2b
c000230c:	ff 15 cc 3f 01 c0    	call   *0xc0013fcc
c0002312:	e9 39 fb ff ff       	jmp    c0001e50 <intr_exit>

c0002317 <intr0x2centry>:
intr0x2centry():
c0002317:	6a 00                	push   $0x0
c0002319:	1e                   	push   %ds
c000231a:	06                   	push   %es
c000231b:	0f a0                	push   %fs
c000231d:	0f a8                	push   %gs
c000231f:	60                   	pusha  
c0002320:	b0 20                	mov    $0x20,%al
c0002322:	e6 a0                	out    %al,$0xa0
c0002324:	e6 20                	out    %al,$0x20
c0002326:	6a 2c                	push   $0x2c
c0002328:	ff 15 d0 3f 01 c0    	call   *0xc0013fd0
c000232e:	e9 1d fb ff ff       	jmp    c0001e50 <intr_exit>

c0002333 <intr0x2dentry>:
intr0x2dentry():
c0002333:	6a 00                	push   $0x0
c0002335:	1e                   	push   %ds
c0002336:	06                   	push   %es
c0002337:	0f a0                	push   %fs
c0002339:	0f a8                	push   %gs
c000233b:	60                   	pusha  
c000233c:	b0 20                	mov    $0x20,%al
c000233e:	e6 a0                	out    %al,$0xa0
c0002340:	e6 20                	out    %al,$0x20
c0002342:	6a 2d                	push   $0x2d
c0002344:	ff 15 d4 3f 01 c0    	call   *0xc0013fd4
c000234a:	e9 01 fb ff ff       	jmp    c0001e50 <intr_exit>

c000234f <intr0x2eentry>:
intr0x2eentry():
c000234f:	6a 00                	push   $0x0
c0002351:	1e                   	push   %ds
c0002352:	06                   	push   %es
c0002353:	0f a0                	push   %fs
c0002355:	0f a8                	push   %gs
c0002357:	60                   	pusha  
c0002358:	b0 20                	mov    $0x20,%al
c000235a:	e6 a0                	out    %al,$0xa0
c000235c:	e6 20                	out    %al,$0x20
c000235e:	6a 2e                	push   $0x2e
c0002360:	ff 15 d8 3f 01 c0    	call   *0xc0013fd8
c0002366:	e9 e5 fa ff ff       	jmp    c0001e50 <intr_exit>

c000236b <intr0x2fentry>:
intr0x2fentry():
c000236b:	6a 00                	push   $0x0
c000236d:	1e                   	push   %ds
c000236e:	06                   	push   %es
c000236f:	0f a0                	push   %fs
c0002371:	0f a8                	push   %gs
c0002373:	60                   	pusha  
c0002374:	b0 20                	mov    $0x20,%al
c0002376:	e6 a0                	out    %al,$0xa0
c0002378:	e6 20                	out    %al,$0x20
c000237a:	6a 2f                	push   $0x2f
c000237c:	ff 15 dc 3f 01 c0    	call   *0xc0013fdc
c0002382:	e9 c9 fa ff ff       	jmp    c0001e50 <intr_exit>

c0002387 <syscall_handler>:
syscall_handler():
c0002387:	6a 00                	push   $0x0
c0002389:	1e                   	push   %ds
c000238a:	06                   	push   %es
c000238b:	0f a0                	push   %fs
c000238d:	0f a8                	push   %gs
c000238f:	60                   	pusha  
c0002390:	68 80 00 00 00       	push   $0x80
c0002395:	52                   	push   %edx
c0002396:	51                   	push   %ecx
c0002397:	53                   	push   %ebx
c0002398:	ff 14 85 20 4b 01 c0 	call   *-0x3ffeb4e0(,%eax,4)
c000239f:	83 c4 0c             	add    $0xc,%esp
c00023a2:	89 44 24 20          	mov    %eax,0x20(%esp)
c00023a6:	e9 a5 fa ff ff       	jmp    c0001e50 <intr_exit>
c00023ab:	66 90                	xchg   %ax,%ax
c00023ad:	66 90                	xchg   %ax,%ax
c00023af:	90                   	nop

c00023b0 <put_str>:
put_str():
c00023b0:	53                   	push   %ebx
c00023b1:	51                   	push   %ecx
c00023b2:	31 c9                	xor    %ecx,%ecx
c00023b4:	8b 5c 24 0c          	mov    0xc(%esp),%ebx

c00023b8 <put_str.goon>:
put_str.goon():
c00023b8:	8a 0b                	mov    (%ebx),%cl
c00023ba:	80 f9 00             	cmp    $0x0,%cl
c00023bd:	74 0c                	je     c00023cb <put_str.str_over>
c00023bf:	51                   	push   %ecx
c00023c0:	e8 09 00 00 00       	call   c00023ce <put_char>
c00023c5:	83 c4 04             	add    $0x4,%esp
c00023c8:	43                   	inc    %ebx
c00023c9:	eb ed                	jmp    c00023b8 <put_str.goon>

c00023cb <put_str.str_over>:
put_str.str_over():
c00023cb:	59                   	pop    %ecx
c00023cc:	5b                   	pop    %ebx
c00023cd:	c3                   	ret    

c00023ce <put_char>:
put_char():
c00023ce:	60                   	pusha  
c00023cf:	66 b8 18 00          	mov    $0x18,%ax
c00023d3:	8e e8                	mov    %eax,%gs
c00023d5:	66 ba d4 03          	mov    $0x3d4,%dx
c00023d9:	b0 0e                	mov    $0xe,%al
c00023db:	ee                   	out    %al,(%dx)
c00023dc:	66 ba d5 03          	mov    $0x3d5,%dx
c00023e0:	ec                   	in     (%dx),%al
c00023e1:	88 c4                	mov    %al,%ah
c00023e3:	66 ba d4 03          	mov    $0x3d4,%dx
c00023e7:	b0 0f                	mov    $0xf,%al
c00023e9:	ee                   	out    %al,(%dx)
c00023ea:	66 ba d5 03          	mov    $0x3d5,%dx
c00023ee:	ec                   	in     (%dx),%al
c00023ef:	66 89 c3             	mov    %ax,%bx
c00023f2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c00023f6:	80 f9 0d             	cmp    $0xd,%cl
c00023f9:	74 3c                	je     c0002437 <put_char.is_carriage_return>
c00023fb:	80 f9 0a             	cmp    $0xa,%cl
c00023fe:	74 37                	je     c0002437 <put_char.is_carriage_return>
c0002400:	80 f9 08             	cmp    $0x8,%cl
c0002403:	74 02                	je     c0002407 <put_char.is_backspace>
c0002405:	eb 16                	jmp    c000241d <put_char.put_other>

c0002407 <put_char.is_backspace>:
put_char.is_backspace():
c0002407:	66 4b                	dec    %bx
c0002409:	66 d1 e3             	shl    %bx
c000240c:	65 67 c6 07 20       	movb   $0x20,%gs:(%bx)
c0002411:	66 43                	inc    %bx
c0002413:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c0002418:	66 d1 eb             	shr    %bx
c000241b:	eb 60                	jmp    c000247d <put_char.set_cursor>

c000241d <put_char.put_other>:
put_char.put_other():
c000241d:	66 d1 e3             	shl    %bx
c0002420:	65 67 88 0f          	mov    %cl,%gs:(%bx)
c0002424:	66 43                	inc    %bx
c0002426:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c000242b:	66 d1 eb             	shr    %bx
c000242e:	66 43                	inc    %bx
c0002430:	66 81 fb d0 07       	cmp    $0x7d0,%bx
c0002435:	7c 46                	jl     c000247d <put_char.set_cursor>

c0002437 <put_char.is_carriage_return>:
put_char.is_line_feed():
c0002437:	66 31 d2             	xor    %dx,%dx
c000243a:	66 89 d8             	mov    %bx,%ax
c000243d:	66 be 50 00          	mov    $0x50,%si
c0002441:	66 f7 f6             	div    %si
c0002444:	66 29 d3             	sub    %dx,%bx

c0002447 <put_char.is_carriage_return_end>:
put_char.is_carriage_return_end():
c0002447:	66 83 c3 50          	add    $0x50,%bx
c000244b:	66 81 fb d0 07       	cmp    $0x7d0,%bx

c0002450 <put_char.is_line_feed_end>:
put_char.is_line_feed_end():
c0002450:	7c 2b                	jl     c000247d <put_char.set_cursor>

c0002452 <put_char.roll_screen>:
put_char.roll_screen():
c0002452:	fc                   	cld    
c0002453:	b9 c0 03 00 00       	mov    $0x3c0,%ecx
c0002458:	be a0 80 0b c0       	mov    $0xc00b80a0,%esi
c000245d:	bf 00 80 0b c0       	mov    $0xc00b8000,%edi
c0002462:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
c0002464:	bb 00 0f 00 00       	mov    $0xf00,%ebx
c0002469:	b9 50 00 00 00       	mov    $0x50,%ecx

c000246e <put_char.cls>:
put_char.cls():
c000246e:	65 66 c7 03 20 07    	movw   $0x720,%gs:(%ebx)
c0002474:	83 c3 02             	add    $0x2,%ebx
c0002477:	e2 f5                	loop   c000246e <put_char.cls>
c0002479:	66 bb 80 07          	mov    $0x780,%bx

c000247d <put_char.set_cursor>:
put_char.set_cursor():
c000247d:	66 ba d4 03          	mov    $0x3d4,%dx
c0002481:	b0 0e                	mov    $0xe,%al
c0002483:	ee                   	out    %al,(%dx)
c0002484:	66 ba d5 03          	mov    $0x3d5,%dx
c0002488:	88 f8                	mov    %bh,%al
c000248a:	ee                   	out    %al,(%dx)
c000248b:	66 ba d4 03          	mov    $0x3d4,%dx
c000248f:	b0 0f                	mov    $0xf,%al
c0002491:	ee                   	out    %al,(%dx)
c0002492:	66 ba d5 03          	mov    $0x3d5,%dx
c0002496:	88 d8                	mov    %bl,%al
c0002498:	ee                   	out    %al,(%dx)

c0002499 <put_char.put_char_done>:
put_char.put_char_done():
c0002499:	61                   	popa   
c000249a:	c3                   	ret    

c000249b <cls_screen>:
cls_screen():
c000249b:	60                   	pusha  
c000249c:	66 b8 18 00          	mov    $0x18,%ax
c00024a0:	8e e8                	mov    %eax,%gs
c00024a2:	bb 00 00 00 00       	mov    $0x0,%ebx
c00024a7:	b9 d0 07 00 00       	mov    $0x7d0,%ecx

c00024ac <cls_screen.cls>:
cls_screen.cls():
c00024ac:	65 66 c7 03 20 07    	movw   $0x720,%gs:(%ebx)
c00024b2:	83 c3 02             	add    $0x2,%ebx
c00024b5:	e2 f5                	loop   c00024ac <cls_screen.cls>
c00024b7:	bb 00 00 00 00       	mov    $0x0,%ebx

c00024bc <cls_screen.set_cursor>:
cls_screen.set_cursor():
c00024bc:	66 ba d4 03          	mov    $0x3d4,%dx
c00024c0:	b0 0e                	mov    $0xe,%al
c00024c2:	ee                   	out    %al,(%dx)
c00024c3:	66 ba d5 03          	mov    $0x3d5,%dx
c00024c7:	88 f8                	mov    %bh,%al
c00024c9:	ee                   	out    %al,(%dx)
c00024ca:	66 ba d4 03          	mov    $0x3d4,%dx
c00024ce:	b0 0f                	mov    $0xf,%al
c00024d0:	ee                   	out    %al,(%dx)
c00024d1:	66 ba d5 03          	mov    $0x3d5,%dx
c00024d5:	88 d8                	mov    %bl,%al
c00024d7:	ee                   	out    %al,(%dx)
c00024d8:	61                   	popa   
c00024d9:	c3                   	ret    

c00024da <put_int>:
put_int():
c00024da:	60                   	pusha  
c00024db:	89 e5                	mov    %esp,%ebp
c00024dd:	8b 45 24             	mov    0x24(%ebp),%eax
c00024e0:	89 c2                	mov    %eax,%edx
c00024e2:	bf 07 00 00 00       	mov    $0x7,%edi
c00024e7:	b9 08 00 00 00       	mov    $0x8,%ecx
c00024ec:	bb c0 30 01 c0       	mov    $0xc00130c0,%ebx

c00024f1 <put_int.16based_4bits>:
put_int.16based_4bits():
c00024f1:	83 e2 0f             	and    $0xf,%edx
c00024f4:	83 fa 09             	cmp    $0x9,%edx
c00024f7:	7f 05                	jg     c00024fe <put_int.is_A2F>
c00024f9:	83 c2 30             	add    $0x30,%edx
c00024fc:	eb 06                	jmp    c0002504 <put_int.store>

c00024fe <put_int.is_A2F>:
put_int.is_A2F():
c00024fe:	83 ea 0a             	sub    $0xa,%edx
c0002501:	83 c2 41             	add    $0x41,%edx

c0002504 <put_int.store>:
put_int.store():
c0002504:	88 14 3b             	mov    %dl,(%ebx,%edi,1)
c0002507:	4f                   	dec    %edi
c0002508:	c1 e8 04             	shr    $0x4,%eax
c000250b:	89 c2                	mov    %eax,%edx
c000250d:	e2 e2                	loop   c00024f1 <put_int.16based_4bits>

c000250f <put_int.ready_to_print>:
put_int.ready_to_print():
c000250f:	47                   	inc    %edi

c0002510 <put_int.skip_prefix_0>:
put_int.skip_prefix_0():
c0002510:	83 ff 08             	cmp    $0x8,%edi
c0002513:	74 0f                	je     c0002524 <put_int.full0>

c0002515 <put_int.go_on_skip>:
put_int.go_on_skip():
c0002515:	8a 8f c0 30 01 c0    	mov    -0x3ffecf40(%edi),%cl
c000251b:	47                   	inc    %edi
c000251c:	80 f9 30             	cmp    $0x30,%cl
c000251f:	74 ef                	je     c0002510 <put_int.skip_prefix_0>
c0002521:	4f                   	dec    %edi
c0002522:	eb 02                	jmp    c0002526 <put_int.put_each_num>

c0002524 <put_int.full0>:
put_int.full0():
c0002524:	b1 30                	mov    $0x30,%cl

c0002526 <put_int.put_each_num>:
put_int.put_each_num():
c0002526:	51                   	push   %ecx
c0002527:	e8 a2 fe ff ff       	call   c00023ce <put_char>
c000252c:	83 c4 04             	add    $0x4,%esp
c000252f:	47                   	inc    %edi
c0002530:	8a 8f c0 30 01 c0    	mov    -0x3ffecf40(%edi),%cl
c0002536:	83 ff 08             	cmp    $0x8,%edi
c0002539:	7c eb                	jl     c0002526 <put_int.put_each_num>
c000253b:	61                   	popa   
c000253c:	c3                   	ret    

c000253d <set_cursor>:
set_cursor():
c000253d:	60                   	pusha  
c000253e:	66 8b 5c 24 24       	mov    0x24(%esp),%bx
c0002543:	66 ba d4 03          	mov    $0x3d4,%dx
c0002547:	b0 0e                	mov    $0xe,%al
c0002549:	ee                   	out    %al,(%dx)
c000254a:	66 ba d5 03          	mov    $0x3d5,%dx
c000254e:	88 f8                	mov    %bh,%al
c0002550:	ee                   	out    %al,(%dx)
c0002551:	66 ba d4 03          	mov    $0x3d4,%dx
c0002555:	b0 0f                	mov    $0xf,%al
c0002557:	ee                   	out    %al,(%dx)
c0002558:	66 ba d5 03          	mov    $0x3d5,%dx
c000255c:	88 d8                	mov    %bl,%al
c000255e:	ee                   	out    %al,(%dx)
c000255f:	61                   	popa   
c0002560:	c3                   	ret    

c0002561 <panic_spin>:
panic_spin():
/work/x86_os_my/kernel/debug.c:10
/* 打印文件名,行号,函数名,条件并使程序悬停 */
void panic_spin(char* filename,	       \
	        int line,	       \
		const char* func,      \
		const char* condition) \
{
c0002561:	55                   	push   %ebp
c0002562:	89 e5                	mov    %esp,%ebp
c0002564:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/debug.c:11
   intr_disable();	// 因为有时候会单独调用panic_spin,所以在此处关中断。
c0002567:	e8 19 f6 ff ff       	call   c0001b85 <intr_disable>
/work/x86_os_my/kernel/debug.c:12
   put_str("\n\n\n!!!!! error !!!!!\n");
c000256c:	83 ec 0c             	sub    $0xc,%esp
c000256f:	68 d0 dc 00 c0       	push   $0xc000dcd0
c0002574:	e8 37 fe ff ff       	call   c00023b0 <put_str>
c0002579:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:13
   put_str("filename:");put_str(filename);put_str("\n");
c000257c:	83 ec 0c             	sub    $0xc,%esp
c000257f:	68 e6 dc 00 c0       	push   $0xc000dce6
c0002584:	e8 27 fe ff ff       	call   c00023b0 <put_str>
c0002589:	83 c4 10             	add    $0x10,%esp
c000258c:	83 ec 0c             	sub    $0xc,%esp
c000258f:	ff 75 08             	pushl  0x8(%ebp)
c0002592:	e8 19 fe ff ff       	call   c00023b0 <put_str>
c0002597:	83 c4 10             	add    $0x10,%esp
c000259a:	83 ec 0c             	sub    $0xc,%esp
c000259d:	68 f0 dc 00 c0       	push   $0xc000dcf0
c00025a2:	e8 09 fe ff ff       	call   c00023b0 <put_str>
c00025a7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:14
   put_str("line:0x");put_int(line);put_str("\n");
c00025aa:	83 ec 0c             	sub    $0xc,%esp
c00025ad:	68 f2 dc 00 c0       	push   $0xc000dcf2
c00025b2:	e8 f9 fd ff ff       	call   c00023b0 <put_str>
c00025b7:	83 c4 10             	add    $0x10,%esp
c00025ba:	8b 45 0c             	mov    0xc(%ebp),%eax
c00025bd:	83 ec 0c             	sub    $0xc,%esp
c00025c0:	50                   	push   %eax
c00025c1:	e8 14 ff ff ff       	call   c00024da <put_int>
c00025c6:	83 c4 10             	add    $0x10,%esp
c00025c9:	83 ec 0c             	sub    $0xc,%esp
c00025cc:	68 f0 dc 00 c0       	push   $0xc000dcf0
c00025d1:	e8 da fd ff ff       	call   c00023b0 <put_str>
c00025d6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:15
   put_str("function:");put_str((char*)func);put_str("\n");
c00025d9:	83 ec 0c             	sub    $0xc,%esp
c00025dc:	68 fa dc 00 c0       	push   $0xc000dcfa
c00025e1:	e8 ca fd ff ff       	call   c00023b0 <put_str>
c00025e6:	83 c4 10             	add    $0x10,%esp
c00025e9:	83 ec 0c             	sub    $0xc,%esp
c00025ec:	ff 75 10             	pushl  0x10(%ebp)
c00025ef:	e8 bc fd ff ff       	call   c00023b0 <put_str>
c00025f4:	83 c4 10             	add    $0x10,%esp
c00025f7:	83 ec 0c             	sub    $0xc,%esp
c00025fa:	68 f0 dc 00 c0       	push   $0xc000dcf0
c00025ff:	e8 ac fd ff ff       	call   c00023b0 <put_str>
c0002604:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:16
   put_str("condition:");put_str((char*)condition);put_str("\n");
c0002607:	83 ec 0c             	sub    $0xc,%esp
c000260a:	68 04 dd 00 c0       	push   $0xc000dd04
c000260f:	e8 9c fd ff ff       	call   c00023b0 <put_str>
c0002614:	83 c4 10             	add    $0x10,%esp
c0002617:	83 ec 0c             	sub    $0xc,%esp
c000261a:	ff 75 14             	pushl  0x14(%ebp)
c000261d:	e8 8e fd ff ff       	call   c00023b0 <put_str>
c0002622:	83 c4 10             	add    $0x10,%esp
c0002625:	83 ec 0c             	sub    $0xc,%esp
c0002628:	68 f0 dc 00 c0       	push   $0xc000dcf0
c000262d:	e8 7e fd ff ff       	call   c00023b0 <put_str>
c0002632:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:17 (discriminator 1)
   while(1);
c0002635:	eb fe                	jmp    c0002635 <panic_spin+0xd4>

c0002637 <bitmap_init>:
bitmap_init():
/work/x86_os_my/lib/kernel/bitmap.c:16
	uint8_t* bits;				位图空间
};
*/

/* 将位图btmp初始化 */
void bitmap_init(struct bitmap* btmp) {
c0002637:	55                   	push   %ebp
c0002638:	89 e5                	mov    %esp,%ebp
c000263a:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/bitmap.c:17
	memset(btmp->bits, 0, btmp->btmp_bytes_len);   
c000263d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002640:	8b 10                	mov    (%eax),%edx
c0002642:	8b 45 08             	mov    0x8(%ebp),%eax
c0002645:	8b 40 04             	mov    0x4(%eax),%eax
c0002648:	83 ec 04             	sub    $0x4,%esp
c000264b:	52                   	push   %edx
c000264c:	6a 00                	push   $0x0
c000264e:	50                   	push   %eax
c000264f:	e8 11 14 00 00       	call   c0003a65 <memset>
c0002654:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:18
}
c0002657:	90                   	nop
c0002658:	c9                   	leave  
c0002659:	c3                   	ret    

c000265a <bitmap_scan_test>:
bitmap_scan_test():
/work/x86_os_my/lib/kernel/bitmap.c:23

/* 判断bit_idx位是否为1
若为1则返回true
否则返回false */
bool bitmap_scan_test(struct bitmap* btmp, uint32_t bit_idx) {
c000265a:	55                   	push   %ebp
c000265b:	89 e5                	mov    %esp,%ebp
c000265d:	53                   	push   %ebx
c000265e:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:24
	uint32_t byte_idx = bit_idx / 8;    // 向下取整用于索引数组下标
c0002661:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002664:	c1 e8 03             	shr    $0x3,%eax
c0002667:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:25
	uint32_t bit_odd  = bit_idx % 8;    // 取余用于索引数组内的位
c000266a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000266d:	83 e0 07             	and    $0x7,%eax
c0002670:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:26
	return (btmp->bits[byte_idx] & (BITMAP_MASK << bit_odd));
c0002673:	8b 45 08             	mov    0x8(%ebp),%eax
c0002676:	8b 50 04             	mov    0x4(%eax),%edx
c0002679:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000267c:	01 d0                	add    %edx,%eax
c000267e:	0f b6 00             	movzbl (%eax),%eax
c0002681:	0f b6 d0             	movzbl %al,%edx
c0002684:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002687:	bb 01 00 00 00       	mov    $0x1,%ebx
c000268c:	89 c1                	mov    %eax,%ecx
c000268e:	d3 e3                	shl    %cl,%ebx
c0002690:	89 d8                	mov    %ebx,%eax
c0002692:	21 d0                	and    %edx,%eax
/work/x86_os_my/lib/kernel/bitmap.c:27
}
c0002694:	83 c4 10             	add    $0x10,%esp
c0002697:	5b                   	pop    %ebx
c0002698:	5d                   	pop    %ebp
c0002699:	c3                   	ret    

c000269a <bitmap_scan>:
bitmap_scan():
/work/x86_os_my/lib/kernel/bitmap.c:32

/* 在位图中申请连续cnt个位
成功：返回其起始位下标
失败：返回-1 */
int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {
c000269a:	55                   	push   %ebp
c000269b:	89 e5                	mov    %esp,%ebp
c000269d:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/lib/kernel/bitmap.c:33
	uint32_t idx_byte = 0;	 // 用于记录空闲位所在的字节
c00026a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:35
	/* 先逐字节比较,蛮力法 */
	while (( 0xff == btmp->bits[idx_byte]) && (idx_byte < btmp->btmp_bytes_len)) {
c00026a7:	eb 04                	jmp    c00026ad <bitmap_scan+0x13>
/work/x86_os_my/lib/kernel/bitmap.c:37
		/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */
		idx_byte++;
c00026a9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:35
成功：返回其起始位下标
失败：返回-1 */
int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {
	uint32_t idx_byte = 0;	 // 用于记录空闲位所在的字节
	/* 先逐字节比较,蛮力法 */
	while (( 0xff == btmp->bits[idx_byte]) && (idx_byte < btmp->btmp_bytes_len)) {
c00026ad:	8b 45 08             	mov    0x8(%ebp),%eax
c00026b0:	8b 50 04             	mov    0x4(%eax),%edx
c00026b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00026b6:	01 d0                	add    %edx,%eax
c00026b8:	0f b6 00             	movzbl (%eax),%eax
c00026bb:	3c ff                	cmp    $0xff,%al
c00026bd:	75 0a                	jne    c00026c9 <bitmap_scan+0x2f>
/work/x86_os_my/lib/kernel/bitmap.c:35 (discriminator 1)
c00026bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00026c2:	8b 00                	mov    (%eax),%eax
c00026c4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00026c7:	77 e0                	ja     c00026a9 <bitmap_scan+0xf>
/work/x86_os_my/lib/kernel/bitmap.c:39
		/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */
		idx_byte++;
	}
	ASSERT(idx_byte < btmp->btmp_bytes_len);	//这里应该是"<="
c00026c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00026cc:	8b 00                	mov    (%eax),%eax
c00026ce:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00026d1:	77 19                	ja     c00026ec <bitmap_scan+0x52>
/work/x86_os_my/lib/kernel/bitmap.c:39 (discriminator 1)
c00026d3:	68 10 dd 00 c0       	push   $0xc000dd10
c00026d8:	68 64 dd 00 c0       	push   $0xc000dd64
c00026dd:	6a 27                	push   $0x27
c00026df:	68 30 dd 00 c0       	push   $0xc000dd30
c00026e4:	e8 78 fe ff ff       	call   c0002561 <panic_spin>
c00026e9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:40
	if (idx_byte == btmp->btmp_bytes_len) {		// 若该内存池找不到可用空间		
c00026ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00026ef:	8b 00                	mov    (%eax),%eax
c00026f1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00026f4:	75 0a                	jne    c0002700 <bitmap_scan+0x66>
/work/x86_os_my/lib/kernel/bitmap.c:41
		return -1;
c00026f6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00026fb:	e9 cd 00 00 00       	jmp    c00027cd <bitmap_scan+0x133>
/work/x86_os_my/lib/kernel/bitmap.c:46
	}

	/* 若在位图数组范围内的某字节内找到了空闲位，
	 * 在该字节内逐位比对,返回空闲位的索引。*/
	int idx_bit = 0;
c0002700:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:48
	/* 和btmp->bits[idx_byte]这个字节逐位对比 */
	while ((uint8_t)(BITMAP_MASK << idx_bit) & btmp->bits[idx_byte]) { 
c0002707:	eb 04                	jmp    c000270d <bitmap_scan+0x73>
/work/x86_os_my/lib/kernel/bitmap.c:49
		idx_bit++;
c0002709:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:48

	/* 若在位图数组范围内的某字节内找到了空闲位，
	 * 在该字节内逐位比对,返回空闲位的索引。*/
	int idx_bit = 0;
	/* 和btmp->bits[idx_byte]这个字节逐位对比 */
	while ((uint8_t)(BITMAP_MASK << idx_bit) & btmp->bits[idx_byte]) { 
c000270d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002710:	ba 01 00 00 00       	mov    $0x1,%edx
c0002715:	89 c1                	mov    %eax,%ecx
c0002717:	d3 e2                	shl    %cl,%edx
c0002719:	89 d0                	mov    %edx,%eax
c000271b:	0f b6 d0             	movzbl %al,%edx
c000271e:	8b 45 08             	mov    0x8(%ebp),%eax
c0002721:	8b 48 04             	mov    0x4(%eax),%ecx
c0002724:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002727:	01 c8                	add    %ecx,%eax
c0002729:	0f b6 00             	movzbl (%eax),%eax
c000272c:	0f b6 c0             	movzbl %al,%eax
c000272f:	21 d0                	and    %edx,%eax
c0002731:	85 c0                	test   %eax,%eax
c0002733:	75 d4                	jne    c0002709 <bitmap_scan+0x6f>
/work/x86_os_my/lib/kernel/bitmap.c:52
		idx_bit++;
	}
	
	int bit_idx_start = idx_byte * 8 + idx_bit;		// 空闲位在位图内的下标
c0002735:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002738:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c000273f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002742:	01 d0                	add    %edx,%eax
c0002744:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:53
	if (cnt == 1) {
c0002747:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
c000274b:	75 05                	jne    c0002752 <bitmap_scan+0xb8>
/work/x86_os_my/lib/kernel/bitmap.c:54
		return bit_idx_start;
c000274d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002750:	eb 7b                	jmp    c00027cd <bitmap_scan+0x133>
/work/x86_os_my/lib/kernel/bitmap.c:57
	}

	uint32_t bit_left = (btmp->btmp_bytes_len * 8 - bit_idx_start);	// 记录还有多少位可以判断
c0002752:	8b 45 08             	mov    0x8(%ebp),%eax
c0002755:	8b 00                	mov    (%eax),%eax
c0002757:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c000275e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002761:	29 c2                	sub    %eax,%edx
c0002763:	89 d0                	mov    %edx,%eax
c0002765:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:58
	uint32_t next_bit = bit_idx_start + 1;
c0002768:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000276b:	83 c0 01             	add    $0x1,%eax
c000276e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:59
	uint32_t count = 1;			// 用于记录找到的空闲位的个数
c0002771:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:61

	bit_idx_start = -1;			// 初始化为-1，若找不到连续的位就直接返回-1
c0002778:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:62
	while (bit_left-- > 0) {
c000277f:	eb 3c                	jmp    c00027bd <bitmap_scan+0x123>
/work/x86_os_my/lib/kernel/bitmap.c:63
		if (!(bitmap_scan_test(btmp, next_bit))) {	// 判断next_bit位是否为1,=1返回true，=0返回false
c0002781:	83 ec 08             	sub    $0x8,%esp
c0002784:	ff 75 e4             	pushl  -0x1c(%ebp)
c0002787:	ff 75 08             	pushl  0x8(%ebp)
c000278a:	e8 cb fe ff ff       	call   c000265a <bitmap_scan_test>
c000278f:	83 c4 10             	add    $0x10,%esp
c0002792:	85 c0                	test   %eax,%eax
c0002794:	75 06                	jne    c000279c <bitmap_scan+0x102>
/work/x86_os_my/lib/kernel/bitmap.c:64
			count++;
c0002796:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
c000279a:	eb 07                	jmp    c00027a3 <bitmap_scan+0x109>
/work/x86_os_my/lib/kernel/bitmap.c:66
		} else {
			count = 0;			// 重新从0找cnt个连续的bit
c000279c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:69
		}
		
		if (count == cnt) {		// 已找到连续的cnt个空位
c00027a3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00027a6:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00027a9:	75 0e                	jne    c00027b9 <bitmap_scan+0x11f>
/work/x86_os_my/lib/kernel/bitmap.c:70
			bit_idx_start = next_bit - cnt + 1;
c00027ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00027ae:	2b 45 0c             	sub    0xc(%ebp),%eax
c00027b1:	83 c0 01             	add    $0x1,%eax
c00027b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:71
			break;
c00027b7:	eb 11                	jmp    c00027ca <bitmap_scan+0x130>
/work/x86_os_my/lib/kernel/bitmap.c:73
		}
		next_bit++;
c00027b9:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:62
	uint32_t bit_left = (btmp->btmp_bytes_len * 8 - bit_idx_start);	// 记录还有多少位可以判断
	uint32_t next_bit = bit_idx_start + 1;
	uint32_t count = 1;			// 用于记录找到的空闲位的个数

	bit_idx_start = -1;			// 初始化为-1，若找不到连续的位就直接返回-1
	while (bit_left-- > 0) {
c00027bd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00027c0:	8d 50 ff             	lea    -0x1(%eax),%edx
c00027c3:	89 55 e8             	mov    %edx,-0x18(%ebp)
c00027c6:	85 c0                	test   %eax,%eax
c00027c8:	75 b7                	jne    c0002781 <bitmap_scan+0xe7>
/work/x86_os_my/lib/kernel/bitmap.c:75
			bit_idx_start = next_bit - cnt + 1;
			break;
		}
		next_bit++;
	}
	return bit_idx_start;
c00027ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/lib/kernel/bitmap.c:76
}
c00027cd:	c9                   	leave  
c00027ce:	c3                   	ret    

c00027cf <bitmap_set>:
bitmap_set():
/work/x86_os_my/lib/kernel/bitmap.c:79

/* 将位图btmp的bit_idx位设置为value */
void bitmap_set(struct bitmap* btmp, uint32_t bit_idx, int8_t value) {
c00027cf:	55                   	push   %ebp
c00027d0:	89 e5                	mov    %esp,%ebp
c00027d2:	56                   	push   %esi
c00027d3:	53                   	push   %ebx
c00027d4:	83 ec 20             	sub    $0x20,%esp
c00027d7:	8b 45 10             	mov    0x10(%ebp),%eax
c00027da:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:80
	ASSERT((value == 0) || (value == 1));
c00027dd:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c00027e1:	74 1f                	je     c0002802 <bitmap_set+0x33>
/work/x86_os_my/lib/kernel/bitmap.c:80 (discriminator 1)
c00027e3:	80 7d e4 01          	cmpb   $0x1,-0x1c(%ebp)
c00027e7:	74 19                	je     c0002802 <bitmap_set+0x33>
/work/x86_os_my/lib/kernel/bitmap.c:80 (discriminator 2)
c00027e9:	68 44 dd 00 c0       	push   $0xc000dd44
c00027ee:	68 70 dd 00 c0       	push   $0xc000dd70
c00027f3:	6a 50                	push   $0x50
c00027f5:	68 30 dd 00 c0       	push   $0xc000dd30
c00027fa:	e8 62 fd ff ff       	call   c0002561 <panic_spin>
c00027ff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:81
	uint32_t byte_idx = bit_idx / 8;    // 向下取整用于索引数组下标
c0002802:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002805:	c1 e8 03             	shr    $0x3,%eax
c0002808:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:82
	uint32_t bit_odd  = bit_idx % 8;    // 取余用于索引数组内的位
c000280b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000280e:	83 e0 07             	and    $0x7,%eax
c0002811:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:86

	/* 一般都会用个0x1这样的数对字节中的位操作,
	* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/
	if (value) {
c0002814:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c0002818:	74 2f                	je     c0002849 <bitmap_set+0x7a>
/work/x86_os_my/lib/kernel/bitmap.c:87
		btmp->bits[byte_idx] |= (BITMAP_MASK << bit_odd);
c000281a:	8b 45 08             	mov    0x8(%ebp),%eax
c000281d:	8b 50 04             	mov    0x4(%eax),%edx
c0002820:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002823:	01 c2                	add    %eax,%edx
c0002825:	8b 45 08             	mov    0x8(%ebp),%eax
c0002828:	8b 48 04             	mov    0x4(%eax),%ecx
c000282b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000282e:	01 c8                	add    %ecx,%eax
c0002830:	0f b6 00             	movzbl (%eax),%eax
c0002833:	89 c6                	mov    %eax,%esi
c0002835:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002838:	bb 01 00 00 00       	mov    $0x1,%ebx
c000283d:	89 c1                	mov    %eax,%ecx
c000283f:	d3 e3                	shl    %cl,%ebx
c0002841:	89 d8                	mov    %ebx,%eax
c0002843:	09 f0                	or     %esi,%eax
c0002845:	88 02                	mov    %al,(%edx)
/work/x86_os_my/lib/kernel/bitmap.c:91
	} else {
		btmp->bits[byte_idx] &= ~(BITMAP_MASK << bit_odd);
	}
}
c0002847:	eb 2f                	jmp    c0002878 <bitmap_set+0xa9>
/work/x86_os_my/lib/kernel/bitmap.c:89
	/* 一般都会用个0x1这样的数对字节中的位操作,
	* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/
	if (value) {
		btmp->bits[byte_idx] |= (BITMAP_MASK << bit_odd);
	} else {
		btmp->bits[byte_idx] &= ~(BITMAP_MASK << bit_odd);
c0002849:	8b 45 08             	mov    0x8(%ebp),%eax
c000284c:	8b 50 04             	mov    0x4(%eax),%edx
c000284f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002852:	01 c2                	add    %eax,%edx
c0002854:	8b 45 08             	mov    0x8(%ebp),%eax
c0002857:	8b 48 04             	mov    0x4(%eax),%ecx
c000285a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000285d:	01 c8                	add    %ecx,%eax
c000285f:	0f b6 00             	movzbl (%eax),%eax
c0002862:	89 c3                	mov    %eax,%ebx
c0002864:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002867:	be 01 00 00 00       	mov    $0x1,%esi
c000286c:	89 c1                	mov    %eax,%ecx
c000286e:	d3 e6                	shl    %cl,%esi
c0002870:	89 f0                	mov    %esi,%eax
c0002872:	f7 d0                	not    %eax
c0002874:	21 d8                	and    %ebx,%eax
c0002876:	88 02                	mov    %al,(%edx)
/work/x86_os_my/lib/kernel/bitmap.c:91
	}
}
c0002878:	90                   	nop
c0002879:	8d 65 f8             	lea    -0x8(%ebp),%esp
c000287c:	5b                   	pop    %ebx
c000287d:	5e                   	pop    %esi
c000287e:	5d                   	pop    %ebp
c000287f:	c3                   	ret    

c0002880 <vaddr_get>:
vaddr_get():
/work/x86_os_my/kernel/memory.c:66
struct pool kernel_pool, user_pool;		// 生成内核内存池和用户内存池
struct virtual_addr kernel_vaddr;		// 此结构是用来给内核分配虚拟地址

/* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页,
 * 成功则返回虚拟页的起始地址, 失败则返回NULL */
static void* vaddr_get(enum pool_flags pf, uint32_t pg_cnt) {
c0002880:	55                   	push   %ebp
c0002881:	89 e5                	mov    %esp,%ebp
c0002883:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:67
	int vaddr_start = 0, bit_idx_start = -1;
c0002886:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000288d:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:68
	uint32_t cnt = 0;
c0002894:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:69
	if (pf == PF_KERNEL) {
c000289b:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c000289f:	75 64                	jne    c0002905 <vaddr_get+0x85>
/work/x86_os_my/kernel/memory.c:71
		// 在位图中申请连续cnt个位 成功：返回其起始位下标
		bit_idx_start  = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
c00028a1:	83 ec 08             	sub    $0x8,%esp
c00028a4:	ff 75 0c             	pushl  0xc(%ebp)
c00028a7:	68 28 42 01 c0       	push   $0xc0014228
c00028ac:	e8 e9 fd ff ff       	call   c000269a <bitmap_scan>
c00028b1:	83 c4 10             	add    $0x10,%esp
c00028b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:72
		if (bit_idx_start == -1) {	//失败
c00028b7:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c00028bb:	75 2b                	jne    c00028e8 <vaddr_get+0x68>
/work/x86_os_my/kernel/memory.c:73
			return NULL;
c00028bd:	b8 00 00 00 00       	mov    $0x0,%eax
c00028c2:	e9 cd 00 00 00       	jmp    c0002994 <vaddr_get+0x114>
/work/x86_os_my/kernel/memory.c:77
		}
		while(cnt < pg_cnt) {
			// 设置位图中的位，表示内存已被占用
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
c00028c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00028ca:	8d 50 01             	lea    0x1(%eax),%edx
c00028cd:	89 55 f0             	mov    %edx,-0x10(%ebp)
c00028d0:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00028d3:	01 d0                	add    %edx,%eax
c00028d5:	83 ec 04             	sub    $0x4,%esp
c00028d8:	6a 01                	push   $0x1
c00028da:	50                   	push   %eax
c00028db:	68 28 42 01 c0       	push   $0xc0014228
c00028e0:	e8 ea fe ff ff       	call   c00027cf <bitmap_set>
c00028e5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:75
		// 在位图中申请连续cnt个位 成功：返回其起始位下标
		bit_idx_start  = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
		if (bit_idx_start == -1) {	//失败
			return NULL;
		}
		while(cnt < pg_cnt) {
c00028e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00028eb:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00028ee:	72 d7                	jb     c00028c7 <vaddr_get+0x47>
/work/x86_os_my/kernel/memory.c:79
			// 设置位图中的位，表示内存已被占用
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
		}
		vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
c00028f0:	a1 30 42 01 c0       	mov    0xc0014230,%eax
c00028f5:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00028f8:	c1 e2 0c             	shl    $0xc,%edx
c00028fb:	01 d0                	add    %edx,%eax
c00028fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002900:	e9 8c 00 00 00       	jmp    c0002991 <vaddr_get+0x111>
/work/x86_os_my/kernel/memory.c:81
	} else {
		struct task_struct* cur = running_thread();
c0002905:	e8 42 15 00 00       	call   c0003e4c <running_thread>
c000290a:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:82
		bit_idx_start  = bitmap_scan(&cur->userprog_vaddr.vaddr_bitmap, pg_cnt);
c000290d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002910:	83 c0 58             	add    $0x58,%eax
c0002913:	83 ec 08             	sub    $0x8,%esp
c0002916:	ff 75 0c             	pushl  0xc(%ebp)
c0002919:	50                   	push   %eax
c000291a:	e8 7b fd ff ff       	call   c000269a <bitmap_scan>
c000291f:	83 c4 10             	add    $0x10,%esp
c0002922:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:83
		if (bit_idx_start == -1) {
c0002925:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c0002929:	75 2a                	jne    c0002955 <vaddr_get+0xd5>
/work/x86_os_my/kernel/memory.c:84
			return NULL;
c000292b:	b8 00 00 00 00       	mov    $0x0,%eax
c0002930:	eb 62                	jmp    c0002994 <vaddr_get+0x114>
/work/x86_os_my/kernel/memory.c:87
		}
		while(cnt < pg_cnt) {
			bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
c0002932:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002935:	8d 50 01             	lea    0x1(%eax),%edx
c0002938:	89 55 f0             	mov    %edx,-0x10(%ebp)
c000293b:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000293e:	01 c2                	add    %eax,%edx
c0002940:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002943:	83 c0 58             	add    $0x58,%eax
c0002946:	83 ec 04             	sub    $0x4,%esp
c0002949:	6a 01                	push   $0x1
c000294b:	52                   	push   %edx
c000294c:	50                   	push   %eax
c000294d:	e8 7d fe ff ff       	call   c00027cf <bitmap_set>
c0002952:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:86
		struct task_struct* cur = running_thread();
		bit_idx_start  = bitmap_scan(&cur->userprog_vaddr.vaddr_bitmap, pg_cnt);
		if (bit_idx_start == -1) {
			return NULL;
		}
		while(cnt < pg_cnt) {
c0002955:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002958:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000295b:	72 d5                	jb     c0002932 <vaddr_get+0xb2>
/work/x86_os_my/kernel/memory.c:89
			bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
		}
		vaddr_start = cur->userprog_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
c000295d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002960:	8b 40 60             	mov    0x60(%eax),%eax
c0002963:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002966:	c1 e2 0c             	shl    $0xc,%edx
c0002969:	01 d0                	add    %edx,%eax
c000296b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:92

		/* (0xc0000000 - PG_SIZE)做为用户3级栈已经在start_process被分配 */
		ASSERT((uint32_t)vaddr_start < (0xc0000000 - PG_SIZE));
c000296e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002971:	3d ff ef ff bf       	cmp    $0xbfffefff,%eax
c0002976:	76 19                	jbe    c0002991 <vaddr_get+0x111>
/work/x86_os_my/kernel/memory.c:92 (discriminator 1)
c0002978:	68 7c dd 00 c0       	push   $0xc000dd7c
c000297d:	68 f0 e0 00 c0       	push   $0xc000e0f0
c0002982:	6a 5c                	push   $0x5c
c0002984:	68 ab dd 00 c0       	push   $0xc000ddab
c0002989:	e8 d3 fb ff ff       	call   c0002561 <panic_spin>
c000298e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:95
		
	}
	return (void*)vaddr_start;
c0002991:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:96
}
c0002994:	c9                   	leave  
c0002995:	c3                   	ret    

c0002996 <pte_ptr>:
pte_ptr():
/work/x86_os_my/kernel/memory.c:103
// 页表项 page table
/* 得到虚拟地址vaddr对应的pte指针*/
// 虚拟地址 vaddr 所在 pte 的"虚拟地址"!!!
// *pte 代表的是 pte 页表项的内容,
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页表项"属性
uint32_t* pte_ptr(uint32_t vaddr) {
c0002996:	55                   	push   %ebp
c0002997:	89 e5                	mov    %esp,%ebp
c0002999:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:108
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
					((vaddr & 0xffc00000) >> 10) + \
c000299c:	8b 45 08             	mov    0x8(%ebp),%eax
c000299f:	25 00 00 c0 ff       	and    $0xffc00000,%eax
c00029a4:	c1 e8 0a             	shr    $0xa,%eax
c00029a7:	89 c2                	mov    %eax,%edx
/work/x86_os_my/kernel/memory.c:109
					PTE_IDX(vaddr) * 4);
c00029a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00029ac:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c00029b1:	c1 e8 0c             	shr    $0xc,%eax
c00029b4:	c1 e0 02             	shl    $0x2,%eax
/work/x86_os_my/kernel/memory.c:108
uint32_t* pte_ptr(uint32_t vaddr) {
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
					((vaddr & 0xffc00000) >> 10) + \
c00029b7:	01 d0                	add    %edx,%eax
c00029b9:	2d 00 00 40 00       	sub    $0x400000,%eax
/work/x86_os_my/kernel/memory.c:107
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页表项"属性
uint32_t* pte_ptr(uint32_t vaddr) {
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
c00029be:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:110
					((vaddr & 0xffc00000) >> 10) + \
					PTE_IDX(vaddr) * 4);
	return pte;
c00029c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/kernel/memory.c:111
}
c00029c4:	c9                   	leave  
c00029c5:	c3                   	ret    

c00029c6 <pde_ptr>:
pde_ptr():
/work/x86_os_my/kernel/memory.c:118
// 页目录表项 page Directory table entry
/* 得到虚拟地址vaddr对应的pde的指针 */
// 虚拟地址 vaddr 所在 pde 的"虚拟地址"!!!
// *pde 代表的是 pde 页目录项的内容
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页目录项"属性
uint32_t* pde_ptr(uint32_t vaddr) {
c00029c6:	55                   	push   %ebp
c00029c7:	89 e5                	mov    %esp,%ebp
c00029c9:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:120
	/* 0xfffff是用来访问到页目录表本身所在的地址 */
	uint32_t* pde = (uint32_t*)((0xfffff000) + PDE_IDX(vaddr) * 4);
c00029cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00029cf:	c1 e8 16             	shr    $0x16,%eax
c00029d2:	05 00 fc ff 3f       	add    $0x3ffffc00,%eax
c00029d7:	c1 e0 02             	shl    $0x2,%eax
c00029da:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:121
	return pde;
c00029dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/kernel/memory.c:122
}
c00029e0:	c9                   	leave  
c00029e1:	c3                   	ret    

c00029e2 <palloc>:
palloc():
/work/x86_os_my/kernel/memory.c:126

/* 在m_pool指向的物理内存池中分配1个物理页,
 * 成功则返回页框的物理地址,失败则返回NULL */
static void* palloc(struct pool* m_pool) {
c00029e2:	55                   	push   %ebp
c00029e3:	89 e5                	mov    %esp,%ebp
c00029e5:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:128
	/* 扫描或设置位图要保证原子操作 */
	int bit_idx = bitmap_scan(&m_pool->pool_bitmap, 1);    // 找一个物理页面
c00029e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00029eb:	83 ec 08             	sub    $0x8,%esp
c00029ee:	6a 01                	push   $0x1
c00029f0:	50                   	push   %eax
c00029f1:	e8 a4 fc ff ff       	call   c000269a <bitmap_scan>
c00029f6:	83 c4 10             	add    $0x10,%esp
c00029f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:129
	if (bit_idx == -1 ) {
c00029fc:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0002a00:	75 07                	jne    c0002a09 <palloc+0x27>
/work/x86_os_my/kernel/memory.c:130
		return NULL;
c0002a02:	b8 00 00 00 00       	mov    $0x0,%eax
c0002a07:	eb 2b                	jmp    c0002a34 <palloc+0x52>
/work/x86_os_my/kernel/memory.c:132
	}
	bitmap_set(&m_pool->pool_bitmap, bit_idx, 1);	// 将此位bit_idx置1
c0002a09:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a0c:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a0f:	83 ec 04             	sub    $0x4,%esp
c0002a12:	6a 01                	push   $0x1
c0002a14:	52                   	push   %edx
c0002a15:	50                   	push   %eax
c0002a16:	e8 b4 fd ff ff       	call   c00027cf <bitmap_set>
c0002a1b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:133
	uint32_t page_phyaddr = ((bit_idx * PG_SIZE) + m_pool->phy_addr_start);
c0002a1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002a21:	c1 e0 0c             	shl    $0xc,%eax
c0002a24:	89 c2                	mov    %eax,%edx
c0002a26:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a29:	8b 40 08             	mov    0x8(%eax),%eax
c0002a2c:	01 d0                	add    %edx,%eax
c0002a2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:134
	return (void*)page_phyaddr;
c0002a31:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/kernel/memory.c:135
}
c0002a34:	c9                   	leave  
c0002a35:	c3                   	ret    

c0002a36 <page_table_add>:
page_table_add():
/work/x86_os_my/kernel/memory.c:138

/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */
static void page_table_add(void* _vaddr, void* _page_phyaddr) {
c0002a36:	55                   	push   %ebp
c0002a37:	89 e5                	mov    %esp,%ebp
c0002a39:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:139
	uint32_t vaddr = (uint32_t)_vaddr, page_phyaddr = (uint32_t)_page_phyaddr;
c0002a3c:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002a42:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002a45:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:140
	uint32_t* pde = pde_ptr(vaddr);	//变量pde是虚拟地址!!!
c0002a48:	ff 75 f4             	pushl  -0xc(%ebp)
c0002a4b:	e8 76 ff ff ff       	call   c00029c6 <pde_ptr>
c0002a50:	83 c4 04             	add    $0x4,%esp
c0002a53:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:141
	uint32_t* pte = pte_ptr(vaddr);	//变量pte是虚拟地址!!!
c0002a56:	ff 75 f4             	pushl  -0xc(%ebp)
c0002a59:	e8 38 ff ff ff       	call   c0002996 <pte_ptr>
c0002a5e:	83 c4 04             	add    $0x4,%esp
c0002a61:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:149
	* pde页目录项 pte页表项
	* 执行*pte可能会访问到空的pde。所以确保pde创建完成后才能执行*pte，否则会引发page_fault。
	* 因此在*pde为0时，*pte只能出现在下面else语句块中的*pde后面。
	* *********************************************************/
	/* 先在页目录内判断目录项的P位，若为1,则表示该表已存在 */
	if (*pde & 0x00000001) {			// 页目录项 存在
c0002a64:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002a67:	8b 00                	mov    (%eax),%eax
c0002a69:	83 e0 01             	and    $0x1,%eax
c0002a6c:	85 c0                	test   %eax,%eax
c0002a6e:	74 64                	je     c0002ad4 <page_table_add+0x9e>
/work/x86_os_my/kernel/memory.c:150
		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
c0002a70:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002a73:	8b 00                	mov    (%eax),%eax
c0002a75:	83 e0 01             	and    $0x1,%eax
c0002a78:	85 c0                	test   %eax,%eax
c0002a7a:	74 1c                	je     c0002a98 <page_table_add+0x62>
/work/x86_os_my/kernel/memory.c:150 (discriminator 1)
c0002a7c:	68 bb dd 00 c0       	push   $0xc000ddbb
c0002a81:	68 fc e0 00 c0       	push   $0xc000e0fc
c0002a86:	68 96 00 00 00       	push   $0x96
c0002a8b:	68 ab dd 00 c0       	push   $0xc000ddab
c0002a90:	e8 cc fa ff ff       	call   c0002561 <panic_spin>
c0002a95:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:152

		if (!(*pte & 0x00000001)) {		// 页表项pte不存在，创建PTE
c0002a98:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002a9b:	8b 00                	mov    (%eax),%eax
c0002a9d:	83 e0 01             	and    $0x1,%eax
c0002aa0:	85 c0                	test   %eax,%eax
c0002aa2:	75 12                	jne    c0002ab6 <page_table_add+0x80>
/work/x86_os_my/kernel/memory.c:153
			*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);		// 物理地址 | US=1,RW=1,P=1
c0002aa4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002aa7:	83 c8 07             	or     $0x7,%eax
c0002aaa:	89 c2                	mov    %eax,%edx
c0002aac:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002aaf:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:173
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
	}
}
c0002ab1:	e9 8e 00 00 00       	jmp    c0002b44 <page_table_add+0x10e>
/work/x86_os_my/kernel/memory.c:155
		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic

		if (!(*pte & 0x00000001)) {		// 页表项pte不存在，创建PTE
			*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);		// 物理地址 | US=1,RW=1,P=1
		} else {						// 不会执行到这，因为上面的ASSERT
			PANIC("pte repeat");
c0002ab6:	68 d0 dd 00 c0       	push   $0xc000ddd0
c0002abb:	68 fc e0 00 c0       	push   $0xc000e0fc
c0002ac0:	68 9b 00 00 00       	push   $0x9b
c0002ac5:	68 ab dd 00 c0       	push   $0xc000ddab
c0002aca:	e8 92 fa ff ff       	call   c0002561 <panic_spin>
c0002acf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:173
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
	}
}
c0002ad2:	eb 70                	jmp    c0002b44 <page_table_add+0x10e>
/work/x86_os_my/kernel/memory.c:159
		} else {						// 不会执行到这，因为上面的ASSERT
			PANIC("pte repeat");
		}
	} else {							// 页目录项不存在，先创建页目录，再创建页表项
		/* 页表中用到的页一律从内核空间分配 */
		uint32_t pde_phyaddr = (uint32_t)palloc(&kernel_pool);
c0002ad4:	83 ec 0c             	sub    $0xc,%esp
c0002ad7:	68 40 42 01 c0       	push   $0xc0014240
c0002adc:	e8 01 ff ff ff       	call   c00029e2 <palloc>
c0002ae1:	83 c4 10             	add    $0x10,%esp
c0002ae4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:160
		*pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 注意这行是pde_phyaddr，不是page_phyaddr!!!
c0002ae7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0002aea:	83 c8 07             	or     $0x7,%eax
c0002aed:	89 c2                	mov    %eax,%edx
c0002aef:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002af2:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:168
		 * 访问物理地址 pde_phyaddr，需要找到它的虚拟地址！
		 * 只要用_vaddr的 PTE 取高20位即可。
		   搞得这么难理解，其实就是0xffc00000找到页目录表，然后加上vaddr的PDE在页目录表中的索引
		   (uint32_t*)(0xffc00000 + ((vaddr & 0xffc00000) >> 10))
		 */
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);
c0002af4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002af7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002afc:	83 ec 04             	sub    $0x4,%esp
c0002aff:	68 00 10 00 00       	push   $0x1000
c0002b04:	6a 00                	push   $0x0
c0002b06:	50                   	push   %eax
c0002b07:	e8 59 0f 00 00       	call   c0003a65 <memset>
c0002b0c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:170

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
c0002b0f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002b12:	8b 00                	mov    (%eax),%eax
c0002b14:	83 e0 01             	and    $0x1,%eax
c0002b17:	85 c0                	test   %eax,%eax
c0002b19:	74 1c                	je     c0002b37 <page_table_add+0x101>
/work/x86_os_my/kernel/memory.c:170 (discriminator 1)
c0002b1b:	68 bb dd 00 c0       	push   $0xc000ddbb
c0002b20:	68 fc e0 00 c0       	push   $0xc000e0fc
c0002b25:	68 aa 00 00 00       	push   $0xaa
c0002b2a:	68 ab dd 00 c0       	push   $0xc000ddab
c0002b2f:	e8 2d fa ff ff       	call   c0002561 <panic_spin>
c0002b34:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:171
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
c0002b37:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002b3a:	83 c8 07             	or     $0x7,%eax
c0002b3d:	89 c2                	mov    %eax,%edx
c0002b3f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002b42:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:173
	}
}
c0002b44:	90                   	nop
c0002b45:	c9                   	leave  
c0002b46:	c3                   	ret    

c0002b47 <malloc_page>:
malloc_page():
/work/x86_os_my/kernel/memory.c:176

/* 分配pg_cnt个页空间,成功则返回起始虚拟地址,失败时返回NULL */
void* malloc_page(enum pool_flags pf, uint32_t pg_cnt) {
c0002b47:	55                   	push   %ebp
c0002b48:	89 e5                	mov    %esp,%ebp
c0002b4a:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:177
	ASSERT(pg_cnt > 0 && pg_cnt < 3840);
c0002b4d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002b51:	74 09                	je     c0002b5c <malloc_page+0x15>
/work/x86_os_my/kernel/memory.c:177 (discriminator 1)
c0002b53:	81 7d 0c ff 0e 00 00 	cmpl   $0xeff,0xc(%ebp)
c0002b5a:	76 1c                	jbe    c0002b78 <malloc_page+0x31>
/work/x86_os_my/kernel/memory.c:177 (discriminator 3)
c0002b5c:	68 db dd 00 c0       	push   $0xc000dddb
c0002b61:	68 0c e1 00 c0       	push   $0xc000e10c
c0002b66:	68 b1 00 00 00       	push   $0xb1
c0002b6b:	68 ab dd 00 c0       	push   $0xc000ddab
c0002b70:	e8 ec f9 ff ff       	call   c0002561 <panic_spin>
c0002b75:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:183
	/***********   malloc_page的原理是三个动作的合成:   ***********
		1 通过vaddr_get在虚拟内存池中申请虚拟地址
		2 通过palloc在物理内存池中申请物理页
		3 通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射
	***************************************************************/
	void* vaddr_start = vaddr_get(pf, pg_cnt);
c0002b78:	83 ec 08             	sub    $0x8,%esp
c0002b7b:	ff 75 0c             	pushl  0xc(%ebp)
c0002b7e:	ff 75 08             	pushl  0x8(%ebp)
c0002b81:	e8 fa fc ff ff       	call   c0002880 <vaddr_get>
c0002b86:	83 c4 10             	add    $0x10,%esp
c0002b89:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:184
	if (vaddr_start == NULL) {
c0002b8c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002b90:	75 07                	jne    c0002b99 <malloc_page+0x52>
/work/x86_os_my/kernel/memory.c:185
		return NULL;
c0002b92:	b8 00 00 00 00       	mov    $0x0,%eax
c0002b97:	eb 6e                	jmp    c0002c07 <malloc_page+0xc0>
/work/x86_os_my/kernel/memory.c:188
	}

	uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
c0002b99:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002b9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002b9f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002ba2:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:189
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c0002ba5:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ba8:	83 e0 01             	and    $0x1,%eax
c0002bab:	85 c0                	test   %eax,%eax
c0002bad:	74 07                	je     c0002bb6 <malloc_page+0x6f>
/work/x86_os_my/kernel/memory.c:189 (discriminator 1)
c0002baf:	b8 40 42 01 c0       	mov    $0xc0014240,%eax
c0002bb4:	eb 05                	jmp    c0002bbb <malloc_page+0x74>
/work/x86_os_my/kernel/memory.c:189 (discriminator 2)
c0002bb6:	b8 40 41 01 c0       	mov    $0xc0014140,%eax
/work/x86_os_my/kernel/memory.c:189 (discriminator 4)
c0002bbb:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:192 (discriminator 4)

	/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
	while (cnt-- > 0) {
c0002bbe:	eb 37                	jmp    c0002bf7 <malloc_page+0xb0>
/work/x86_os_my/kernel/memory.c:193
		void* page_phyaddr = palloc(mem_pool);
c0002bc0:	83 ec 0c             	sub    $0xc,%esp
c0002bc3:	ff 75 e8             	pushl  -0x18(%ebp)
c0002bc6:	e8 17 fe ff ff       	call   c00029e2 <palloc>
c0002bcb:	83 c4 10             	add    $0x10,%esp
c0002bce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:194
		if (page_phyaddr == NULL) {  // 失败时要将曾经已申请的虚拟地址和物理页全部回滚，在将来完成内存回收时再补充
c0002bd1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0002bd5:	75 07                	jne    c0002bde <malloc_page+0x97>
/work/x86_os_my/kernel/memory.c:195
			return NULL;
c0002bd7:	b8 00 00 00 00       	mov    $0x0,%eax
c0002bdc:	eb 29                	jmp    c0002c07 <malloc_page+0xc0>
/work/x86_os_my/kernel/memory.c:197
		}
		page_table_add((void*)vaddr, page_phyaddr); // 在页表中做映射 
c0002bde:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002be1:	83 ec 08             	sub    $0x8,%esp
c0002be4:	ff 75 e4             	pushl  -0x1c(%ebp)
c0002be7:	50                   	push   %eax
c0002be8:	e8 49 fe ff ff       	call   c0002a36 <page_table_add>
c0002bed:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:198
		vaddr += PG_SIZE;		 // 下一个虚拟页
c0002bf0:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:192

	uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;

	/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
	while (cnt-- > 0) {
c0002bf7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002bfa:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002bfd:	89 55 f0             	mov    %edx,-0x10(%ebp)
c0002c00:	85 c0                	test   %eax,%eax
c0002c02:	75 bc                	jne    c0002bc0 <malloc_page+0x79>
/work/x86_os_my/kernel/memory.c:200
			return NULL;
		}
		page_table_add((void*)vaddr, page_phyaddr); // 在页表中做映射 
		vaddr += PG_SIZE;		 // 下一个虚拟页
	}
	return vaddr_start;
c0002c04:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/kernel/memory.c:201
}
c0002c07:	c9                   	leave  
c0002c08:	c3                   	ret    

c0002c09 <get_kernel_pages>:
get_kernel_pages():
/work/x86_os_my/kernel/memory.c:204

/* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */
void* get_kernel_pages(uint32_t pg_cnt) {
c0002c09:	55                   	push   %ebp
c0002c0a:	89 e5                	mov    %esp,%ebp
c0002c0c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:205
	lock_acquire(&kernel_pool.lock);
c0002c0f:	83 ec 0c             	sub    $0xc,%esp
c0002c12:	68 50 42 01 c0       	push   $0xc0014250
c0002c17:	e8 e3 22 00 00       	call   c0004eff <lock_acquire>
c0002c1c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:206
	void* vaddr =  malloc_page(PF_KERNEL, pg_cnt);
c0002c1f:	83 ec 08             	sub    $0x8,%esp
c0002c22:	ff 75 08             	pushl  0x8(%ebp)
c0002c25:	6a 01                	push   $0x1
c0002c27:	e8 1b ff ff ff       	call   c0002b47 <malloc_page>
c0002c2c:	83 c4 10             	add    $0x10,%esp
c0002c2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:207
	if (vaddr != NULL) {
c0002c32:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002c36:	74 17                	je     c0002c4f <get_kernel_pages+0x46>
/work/x86_os_my/kernel/memory.c:208
		memset(vaddr, 0, pg_cnt * PG_SIZE);
c0002c38:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c3b:	c1 e0 0c             	shl    $0xc,%eax
c0002c3e:	83 ec 04             	sub    $0x4,%esp
c0002c41:	50                   	push   %eax
c0002c42:	6a 00                	push   $0x0
c0002c44:	ff 75 f4             	pushl  -0xc(%ebp)
c0002c47:	e8 19 0e 00 00       	call   c0003a65 <memset>
c0002c4c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:210
	}
	lock_release(&kernel_pool.lock);
c0002c4f:	83 ec 0c             	sub    $0xc,%esp
c0002c52:	68 50 42 01 c0       	push   $0xc0014250
c0002c57:	e8 1a 23 00 00       	call   c0004f76 <lock_release>
c0002c5c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:211
	return vaddr;
c0002c5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:212
}
c0002c62:	c9                   	leave  
c0002c63:	c3                   	ret    

c0002c64 <get_user_pages>:
get_user_pages():
/work/x86_os_my/kernel/memory.c:215

/* 在用户空间中申请4k内存,并返回其虚拟地址 */
void* get_user_pages(uint32_t pg_cnt) {
c0002c64:	55                   	push   %ebp
c0002c65:	89 e5                	mov    %esp,%ebp
c0002c67:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:216
	lock_acquire(&user_pool.lock);
c0002c6a:	83 ec 0c             	sub    $0xc,%esp
c0002c6d:	68 50 41 01 c0       	push   $0xc0014150
c0002c72:	e8 88 22 00 00       	call   c0004eff <lock_acquire>
c0002c77:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:217
	void* vaddr = malloc_page(PF_USER, pg_cnt);
c0002c7a:	83 ec 08             	sub    $0x8,%esp
c0002c7d:	ff 75 08             	pushl  0x8(%ebp)
c0002c80:	6a 02                	push   $0x2
c0002c82:	e8 c0 fe ff ff       	call   c0002b47 <malloc_page>
c0002c87:	83 c4 10             	add    $0x10,%esp
c0002c8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:218
	if (vaddr != NULL) {
c0002c8d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002c91:	74 17                	je     c0002caa <get_user_pages+0x46>
/work/x86_os_my/kernel/memory.c:219
		memset(vaddr, 0, pg_cnt * PG_SIZE);
c0002c93:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c96:	c1 e0 0c             	shl    $0xc,%eax
c0002c99:	83 ec 04             	sub    $0x4,%esp
c0002c9c:	50                   	push   %eax
c0002c9d:	6a 00                	push   $0x0
c0002c9f:	ff 75 f4             	pushl  -0xc(%ebp)
c0002ca2:	e8 be 0d 00 00       	call   c0003a65 <memset>
c0002ca7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:221
	}
	lock_release(&user_pool.lock);
c0002caa:	83 ec 0c             	sub    $0xc,%esp
c0002cad:	68 50 41 01 c0       	push   $0xc0014150
c0002cb2:	e8 bf 22 00 00       	call   c0004f76 <lock_release>
c0002cb7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:222
	return vaddr;
c0002cba:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:223
}
c0002cbd:	c9                   	leave  
c0002cbe:	c3                   	ret    

c0002cbf <get_a_page>:
get_a_page():
/work/x86_os_my/kernel/memory.c:227

/* 将虚拟地址vaddr与pf池中的物理地址关联,仅支持一页空间分配
 * 功能是，可以指定虚拟地址的内存分配 */
void* get_a_page(enum pool_flags pf, uint32_t vaddr) {
c0002cbf:	55                   	push   %ebp
c0002cc0:	89 e5                	mov    %esp,%ebp
c0002cc2:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:228
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c0002cc5:	8b 45 08             	mov    0x8(%ebp),%eax
c0002cc8:	83 e0 01             	and    $0x1,%eax
c0002ccb:	85 c0                	test   %eax,%eax
c0002ccd:	74 07                	je     c0002cd6 <get_a_page+0x17>
/work/x86_os_my/kernel/memory.c:228 (discriminator 1)
c0002ccf:	b8 40 42 01 c0       	mov    $0xc0014240,%eax
c0002cd4:	eb 05                	jmp    c0002cdb <get_a_page+0x1c>
/work/x86_os_my/kernel/memory.c:228 (discriminator 2)
c0002cd6:	b8 40 41 01 c0       	mov    $0xc0014140,%eax
/work/x86_os_my/kernel/memory.c:228 (discriminator 4)
c0002cdb:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:229 (discriminator 4)
	lock_acquire(&mem_pool->lock);
c0002cde:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002ce1:	83 c0 10             	add    $0x10,%eax
c0002ce4:	83 ec 0c             	sub    $0xc,%esp
c0002ce7:	50                   	push   %eax
c0002ce8:	e8 12 22 00 00       	call   c0004eff <lock_acquire>
c0002ced:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:232 (discriminator 4)

	/* 先将虚拟地址对应的位图置1 */
	struct task_struct* cur = running_thread();
c0002cf0:	e8 57 11 00 00       	call   c0003e4c <running_thread>
c0002cf5:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:233 (discriminator 4)
	int32_t bit_idx = -1;
c0002cf8:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:235 (discriminator 4)

	if (cur->pgdir != NULL && pf == PF_USER) {
c0002cff:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002d02:	8b 40 54             	mov    0x54(%eax),%eax
c0002d05:	85 c0                	test   %eax,%eax
c0002d07:	74 55                	je     c0002d5e <get_a_page+0x9f>
/work/x86_os_my/kernel/memory.c:235 (discriminator 1)
c0002d09:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0002d0d:	75 4f                	jne    c0002d5e <get_a_page+0x9f>
/work/x86_os_my/kernel/memory.c:237
		/* 若当前是用户进程申请用户内存,就修改用户进程自己的虚拟地址池的 位图 */
		bit_idx = (vaddr - cur->userprog_vaddr.vaddr_start) / PG_SIZE;
c0002d0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002d12:	8b 40 60             	mov    0x60(%eax),%eax
c0002d15:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002d18:	29 c2                	sub    %eax,%edx
c0002d1a:	89 d0                	mov    %edx,%eax
c0002d1c:	c1 e8 0c             	shr    $0xc,%eax
c0002d1f:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:238
		ASSERT(bit_idx >= 0);
c0002d22:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002d26:	79 1c                	jns    c0002d44 <get_a_page+0x85>
/work/x86_os_my/kernel/memory.c:238 (discriminator 1)
c0002d28:	68 f7 dd 00 c0       	push   $0xc000ddf7
c0002d2d:	68 18 e1 00 c0       	push   $0xc000e118
c0002d32:	68 ee 00 00 00       	push   $0xee
c0002d37:	68 ab dd 00 c0       	push   $0xc000ddab
c0002d3c:	e8 20 f8 ff ff       	call   c0002561 <panic_spin>
c0002d41:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:239
		bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx, 1);
c0002d44:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002d47:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002d4a:	83 c2 58             	add    $0x58,%edx
c0002d4d:	83 ec 04             	sub    $0x4,%esp
c0002d50:	6a 01                	push   $0x1
c0002d52:	50                   	push   %eax
c0002d53:	52                   	push   %edx
c0002d54:	e8 76 fa ff ff       	call   c00027cf <bitmap_set>
c0002d59:	83 c4 10             	add    $0x10,%esp
c0002d5c:	eb 78                	jmp    c0002dd6 <get_a_page+0x117>
/work/x86_os_my/kernel/memory.c:241

	} else if (cur->pgdir == NULL && pf == PF_KERNEL) {
c0002d5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002d61:	8b 40 54             	mov    0x54(%eax),%eax
c0002d64:	85 c0                	test   %eax,%eax
c0002d66:	75 52                	jne    c0002dba <get_a_page+0xfb>
/work/x86_os_my/kernel/memory.c:241 (discriminator 1)
c0002d68:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0002d6c:	75 4c                	jne    c0002dba <get_a_page+0xfb>
/work/x86_os_my/kernel/memory.c:243
		/* 如果是内核线程申请内核内存,就修改 kernel_vaddr */
		bit_idx = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
c0002d6e:	a1 30 42 01 c0       	mov    0xc0014230,%eax
c0002d73:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002d76:	29 c2                	sub    %eax,%edx
c0002d78:	89 d0                	mov    %edx,%eax
c0002d7a:	c1 e8 0c             	shr    $0xc,%eax
c0002d7d:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:244
		ASSERT(bit_idx > 0);
c0002d80:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002d84:	7f 1c                	jg     c0002da2 <get_a_page+0xe3>
/work/x86_os_my/kernel/memory.c:244 (discriminator 1)
c0002d86:	68 04 de 00 c0       	push   $0xc000de04
c0002d8b:	68 18 e1 00 c0       	push   $0xc000e118
c0002d90:	68 f4 00 00 00       	push   $0xf4
c0002d95:	68 ab dd 00 c0       	push   $0xc000ddab
c0002d9a:	e8 c2 f7 ff ff       	call   c0002561 <panic_spin>
c0002d9f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:245
		bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx, 1);
c0002da2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002da5:	83 ec 04             	sub    $0x4,%esp
c0002da8:	6a 01                	push   $0x1
c0002daa:	50                   	push   %eax
c0002dab:	68 28 42 01 c0       	push   $0xc0014228
c0002db0:	e8 1a fa ff ff       	call   c00027cf <bitmap_set>
c0002db5:	83 c4 10             	add    $0x10,%esp
c0002db8:	eb 1c                	jmp    c0002dd6 <get_a_page+0x117>
/work/x86_os_my/kernel/memory.c:248

	} else {
		PANIC("get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page");
c0002dba:	68 10 de 00 c0       	push   $0xc000de10
c0002dbf:	68 18 e1 00 c0       	push   $0xc000e118
c0002dc4:	68 f8 00 00 00       	push   $0xf8
c0002dc9:	68 ab dd 00 c0       	push   $0xc000ddab
c0002dce:	e8 8e f7 ff ff       	call   c0002561 <panic_spin>
c0002dd3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:251
	}

	void* page_phyaddr = palloc(mem_pool);
c0002dd6:	83 ec 0c             	sub    $0xc,%esp
c0002dd9:	ff 75 f4             	pushl  -0xc(%ebp)
c0002ddc:	e8 01 fc ff ff       	call   c00029e2 <palloc>
c0002de1:	83 c4 10             	add    $0x10,%esp
c0002de4:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:252
	if (page_phyaddr == NULL) {
c0002de7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0002deb:	75 19                	jne    c0002e06 <get_a_page+0x147>
/work/x86_os_my/kernel/memory.c:253
		lock_release(&mem_pool->lock);	//哈哈
c0002ded:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002df0:	83 c0 10             	add    $0x10,%eax
c0002df3:	83 ec 0c             	sub    $0xc,%esp
c0002df6:	50                   	push   %eax
c0002df7:	e8 7a 21 00 00       	call   c0004f76 <lock_release>
c0002dfc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:254
		return NULL;
c0002dff:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e04:	eb 27                	jmp    c0002e2d <get_a_page+0x16e>
/work/x86_os_my/kernel/memory.c:256
	}
	page_table_add((void*)vaddr, page_phyaddr);
c0002e06:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002e09:	83 ec 08             	sub    $0x8,%esp
c0002e0c:	ff 75 e8             	pushl  -0x18(%ebp)
c0002e0f:	50                   	push   %eax
c0002e10:	e8 21 fc ff ff       	call   c0002a36 <page_table_add>
c0002e15:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:258
	
	lock_release(&mem_pool->lock);
c0002e18:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002e1b:	83 c0 10             	add    $0x10,%eax
c0002e1e:	83 ec 0c             	sub    $0xc,%esp
c0002e21:	50                   	push   %eax
c0002e22:	e8 4f 21 00 00       	call   c0004f76 <lock_release>
c0002e27:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:259
	return (void*)vaddr;
c0002e2a:	8b 45 0c             	mov    0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:260
}
c0002e2d:	c9                   	leave  
c0002e2e:	c3                   	ret    

c0002e2f <get_a_page_without_opvaddrbitmap>:
get_a_page_without_opvaddrbitmap():
/work/x86_os_my/kernel/memory.c:265

/* 安装1页大小的vaddr，专门针对fork时不修改虚拟地址位图的情况
 * 函数功能和 get_a_page 类似，为 vaddr 分配一物理页，只是少了虚拟地址池位图的操作
 */
void* get_a_page_without_opvaddrbitmap(enum pool_flags pf, uint32_t vaddr) {
c0002e2f:	55                   	push   %ebp
c0002e30:	89 e5                	mov    %esp,%ebp
c0002e32:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:266
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c0002e35:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e38:	83 e0 01             	and    $0x1,%eax
c0002e3b:	85 c0                	test   %eax,%eax
c0002e3d:	74 07                	je     c0002e46 <get_a_page_without_opvaddrbitmap+0x17>
/work/x86_os_my/kernel/memory.c:266 (discriminator 1)
c0002e3f:	b8 40 42 01 c0       	mov    $0xc0014240,%eax
c0002e44:	eb 05                	jmp    c0002e4b <get_a_page_without_opvaddrbitmap+0x1c>
/work/x86_os_my/kernel/memory.c:266 (discriminator 2)
c0002e46:	b8 40 41 01 c0       	mov    $0xc0014140,%eax
/work/x86_os_my/kernel/memory.c:266 (discriminator 4)
c0002e4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:267 (discriminator 4)
	lock_acquire(&mem_pool->lock);
c0002e4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002e51:	83 c0 10             	add    $0x10,%eax
c0002e54:	83 ec 0c             	sub    $0xc,%esp
c0002e57:	50                   	push   %eax
c0002e58:	e8 a2 20 00 00       	call   c0004eff <lock_acquire>
c0002e5d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:268 (discriminator 4)
	void* page_phyaddr = palloc(mem_pool);
c0002e60:	83 ec 0c             	sub    $0xc,%esp
c0002e63:	ff 75 f4             	pushl  -0xc(%ebp)
c0002e66:	e8 77 fb ff ff       	call   c00029e2 <palloc>
c0002e6b:	83 c4 10             	add    $0x10,%esp
c0002e6e:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:269 (discriminator 4)
	if (page_phyaddr == NULL) {
c0002e71:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0002e75:	75 19                	jne    c0002e90 <get_a_page_without_opvaddrbitmap+0x61>
/work/x86_os_my/kernel/memory.c:270
		lock_release(&mem_pool->lock);
c0002e77:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002e7a:	83 c0 10             	add    $0x10,%eax
c0002e7d:	83 ec 0c             	sub    $0xc,%esp
c0002e80:	50                   	push   %eax
c0002e81:	e8 f0 20 00 00       	call   c0004f76 <lock_release>
c0002e86:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:271
		return NULL;
c0002e89:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e8e:	eb 27                	jmp    c0002eb7 <get_a_page_without_opvaddrbitmap+0x88>
/work/x86_os_my/kernel/memory.c:273
	}
	page_table_add((void*)vaddr, page_phyaddr);
c0002e90:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002e93:	83 ec 08             	sub    $0x8,%esp
c0002e96:	ff 75 f0             	pushl  -0x10(%ebp)
c0002e99:	50                   	push   %eax
c0002e9a:	e8 97 fb ff ff       	call   c0002a36 <page_table_add>
c0002e9f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:274
	lock_release(&mem_pool->lock);
c0002ea2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002ea5:	83 c0 10             	add    $0x10,%eax
c0002ea8:	83 ec 0c             	sub    $0xc,%esp
c0002eab:	50                   	push   %eax
c0002eac:	e8 c5 20 00 00       	call   c0004f76 <lock_release>
c0002eb1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:275
	return (void*)vaddr;
c0002eb4:	8b 45 0c             	mov    0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:276
}
c0002eb7:	c9                   	leave  
c0002eb8:	c3                   	ret    

c0002eb9 <addr_v2p>:
addr_v2p():
/work/x86_os_my/kernel/memory.c:279

/* 得到虚拟地址映射到的物理地址 */
uint32_t addr_v2p(uint32_t vaddr) {
c0002eb9:	55                   	push   %ebp
c0002eba:	89 e5                	mov    %esp,%ebp
c0002ebc:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:280
	uint32_t* pte = pte_ptr(vaddr);
c0002ebf:	ff 75 08             	pushl  0x8(%ebp)
c0002ec2:	e8 cf fa ff ff       	call   c0002996 <pte_ptr>
c0002ec7:	83 c4 04             	add    $0x4,%esp
c0002eca:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:284
	/* (*pte)的内容是 vaddr 所在 pte 的内容，也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的页表项属性，
	 * 因为页框都是自然页，低 12 位地址是 0，所以页表项 pte（和页目录项 pde）中只需要记录页框的高 20 位地址即可。
	 */
	return ((*pte & 0xfffff000) + (vaddr & 0x00000fff));
c0002ecd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002ed0:	8b 00                	mov    (%eax),%eax
c0002ed2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002ed7:	89 c2                	mov    %eax,%edx
c0002ed9:	8b 45 08             	mov    0x8(%ebp),%eax
c0002edc:	25 ff 0f 00 00       	and    $0xfff,%eax
c0002ee1:	01 d0                	add    %edx,%eax
/work/x86_os_my/kernel/memory.c:285
}
c0002ee3:	c9                   	leave  
c0002ee4:	c3                   	ret    

c0002ee5 <arena2block>:
arena2block():
/work/x86_os_my/kernel/memory.c:299
|                     |
| +-----------------+ |
+-+  mem_block_desc |←+
  +-----------------+
*/
static struct mem_block* arena2block(struct arena* a, uint32_t idx) {
c0002ee5:	55                   	push   %ebp
c0002ee6:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/kernel/memory.c:300
	return (struct mem_block*)((uint32_t)a + sizeof(struct arena) + idx * a->desc->block_size);
c0002ee8:	8b 45 08             	mov    0x8(%ebp),%eax
c0002eeb:	8b 00                	mov    (%eax),%eax
c0002eed:	8b 00                	mov    (%eax),%eax
c0002eef:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0002ef3:	89 c2                	mov    %eax,%edx
c0002ef5:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ef8:	01 d0                	add    %edx,%eax
c0002efa:	83 c0 0c             	add    $0xc,%eax
/work/x86_os_my/kernel/memory.c:301
}
c0002efd:	5d                   	pop    %ebp
c0002efe:	c3                   	ret    

c0002eff <block2arena>:
block2arena():
/work/x86_os_my/kernel/memory.c:306

/* 返回内存块mem_block所在的arena地址
 * 取到了虚拟地址mem_block那一整页的地址
 */
static struct arena* block2arena(struct mem_block* b) {
c0002eff:	55                   	push   %ebp
c0002f00:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/kernel/memory.c:307
	return (struct arena*)((uint32_t)b & 0xfffff000);
c0002f02:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f05:	25 00 f0 ff ff       	and    $0xfffff000,%eax
/work/x86_os_my/kernel/memory.c:308
}
c0002f0a:	5d                   	pop    %ebp
c0002f0b:	c3                   	ret    

c0002f0c <sys_malloc>:
sys_malloc():
/work/x86_os_my/kernel/memory.c:319
 * 3.内存块地址被返回给用户后，用户可以自由使用此内存块 mem_block
 *   会把此内存块中的 list_elem 型变量 free_elem 覆盖
 *   不过 arena->mem_block_desc->free_list 中的元素已经记录了 mem_block->list_elem 的地址
 *   使用时覆盖的，只是 mem_block 的内容。
 */
void* sys_malloc(uint32_t size) {
c0002f0c:	55                   	push   %ebp
c0002f0d:	89 e5                	mov    %esp,%ebp
c0002f0f:	83 ec 38             	sub    $0x38,%esp
/work/x86_os_my/kernel/memory.c:324
	enum pool_flags PF;
	struct pool* mem_pool;
	uint32_t pool_size;
	struct mem_block_desc* descs;
	struct task_struct* cur_thread = running_thread();
c0002f12:	e8 35 0f 00 00       	call   c0003e4c <running_thread>
c0002f17:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/kernel/memory.c:327

	/* 判断用哪个内存池*/
	if (cur_thread->pgdir == NULL) {	// 是内核线程
c0002f1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0002f1d:	8b 40 54             	mov    0x54(%eax),%eax
c0002f20:	85 c0                	test   %eax,%eax
c0002f22:	75 1f                	jne    c0002f43 <sys_malloc+0x37>
/work/x86_os_my/kernel/memory.c:328
		PF = PF_KERNEL;
c0002f24:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:329
		pool_size = kernel_pool.pool_size;
c0002f2b:	a1 4c 42 01 c0       	mov    0xc001424c,%eax
c0002f30:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:330
		mem_pool = &kernel_pool;
c0002f33:	c7 45 f0 40 42 01 c0 	movl   $0xc0014240,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:331
		descs = k_block_descs;
c0002f3a:	c7 45 e8 80 41 01 c0 	movl   $0xc0014180,-0x18(%ebp)
c0002f41:	eb 1f                	jmp    c0002f62 <sys_malloc+0x56>
/work/x86_os_my/kernel/memory.c:333
	} else {							// 用户进程pcb中的pgdir（页目录表）会在为其分配页表时创建【create_page_dir】
		PF = PF_USER;
c0002f43:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:334
		pool_size = user_pool.pool_size;
c0002f4a:	a1 4c 41 01 c0       	mov    0xc001414c,%eax
c0002f4f:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:335
		mem_pool = &user_pool;
c0002f52:	c7 45 f0 40 41 01 c0 	movl   $0xc0014140,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:336
		descs = cur_thread->u_block_desc;
c0002f59:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0002f5c:	83 c0 64             	add    $0x64,%eax
c0002f5f:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:340
	}

	/* 若申请的内存不在内存池容量范围内则直接返回NULL */
	if (!(size > 0 && size < pool_size)) {
c0002f62:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002f66:	74 08                	je     c0002f70 <sys_malloc+0x64>
/work/x86_os_my/kernel/memory.c:340 (discriminator 1)
c0002f68:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f6b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0002f6e:	72 0a                	jb     c0002f7a <sys_malloc+0x6e>
/work/x86_os_my/kernel/memory.c:341
		return NULL;
c0002f70:	b8 00 00 00 00       	mov    $0x0,%eax
c0002f75:	e9 c5 02 00 00       	jmp    c000323f <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:346
	}

	struct arena* a;
	struct mem_block* b;
	lock_acquire(&mem_pool->lock);
c0002f7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002f7d:	83 c0 10             	add    $0x10,%eax
c0002f80:	83 ec 0c             	sub    $0xc,%esp
c0002f83:	50                   	push   %eax
c0002f84:	e8 76 1f 00 00       	call   c0004eff <lock_acquire>
c0002f89:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:349

	/* 超过最大内存块1024, 就分配页框 */
	if (size > 1024) {
c0002f8c:	81 7d 08 00 04 00 00 	cmpl   $0x400,0x8(%ebp)
c0002f93:	0f 86 94 00 00 00    	jbe    c000302d <sys_malloc+0x121>
/work/x86_os_my/kernel/memory.c:350
		uint32_t page_cnt = DIV_ROUND_UP(size + sizeof(struct arena), PG_SIZE);	// 向上取整需要的页框数
c0002f99:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f9c:	05 0b 10 00 00       	add    $0x100b,%eax
c0002fa1:	c1 e8 0c             	shr    $0xc,%eax
c0002fa4:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/kernel/memory.c:352

		a = malloc_page(PF, page_cnt);
c0002fa7:	83 ec 08             	sub    $0x8,%esp
c0002faa:	ff 75 d8             	pushl  -0x28(%ebp)
c0002fad:	ff 75 f4             	pushl  -0xc(%ebp)
c0002fb0:	e8 92 fb ff ff       	call   c0002b47 <malloc_page>
c0002fb5:	83 c4 10             	add    $0x10,%esp
c0002fb8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:353
		if (a != NULL) {
c0002fbb:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0002fbf:	74 50                	je     c0003011 <sys_malloc+0x105>
/work/x86_os_my/kernel/memory.c:354
			memset(a, 0, page_cnt * PG_SIZE);
c0002fc1:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0002fc4:	c1 e0 0c             	shl    $0xc,%eax
c0002fc7:	83 ec 04             	sub    $0x4,%esp
c0002fca:	50                   	push   %eax
c0002fcb:	6a 00                	push   $0x0
c0002fcd:	ff 75 d4             	pushl  -0x2c(%ebp)
c0002fd0:	e8 90 0a 00 00       	call   c0003a65 <memset>
c0002fd5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:358

			// 【arena结构体初始化，情况1】
			/* 对于分配的大块页框,将desc置为NULL, cnt置为页框数, large置为true */
			a->desc = NULL;
c0002fd8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002fdb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/kernel/memory.c:359
			a->cnt = page_cnt;
c0002fe1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002fe4:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0002fe7:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/kernel/memory.c:360
			a->large = true;
c0002fea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002fed:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/kernel/memory.c:362

			lock_release(&mem_pool->lock);
c0002ff4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002ff7:	83 c0 10             	add    $0x10,%eax
c0002ffa:	83 ec 0c             	sub    $0xc,%esp
c0002ffd:	50                   	push   %eax
c0002ffe:	e8 73 1f 00 00       	call   c0004f76 <lock_release>
c0003003:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:363
			return (void*)(a + 1);	// 跨过arena大小，把剩下的内存返回
c0003006:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0003009:	83 c0 0c             	add    $0xc,%eax
c000300c:	e9 2e 02 00 00       	jmp    c000323f <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:365
		} else {
			lock_release(&mem_pool->lock);
c0003011:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003014:	83 c0 10             	add    $0x10,%eax
c0003017:	83 ec 0c             	sub    $0xc,%esp
c000301a:	50                   	push   %eax
c000301b:	e8 56 1f 00 00       	call   c0004f76 <lock_release>
c0003020:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:366
			return NULL;
c0003023:	b8 00 00 00 00       	mov    $0x0,%eax
c0003028:	e9 12 02 00 00       	jmp    c000323f <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:374
	} else {
	/* 若申请的内存小于等于1024,可在各种规格的mem_block_desc中去适配 */
		uint8_t desc_idx;

		/* 从内存块描述符中匹配合适的内存块规格 */
		for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c000302d:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
c0003031:	eb 25                	jmp    c0003058 <sys_malloc+0x14c>
/work/x86_os_my/kernel/memory.c:375
			if (size <= descs[desc_idx].block_size) {	// 从小往大后,找到后退出
c0003033:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0003037:	89 d0                	mov    %edx,%eax
c0003039:	01 c0                	add    %eax,%eax
c000303b:	01 d0                	add    %edx,%eax
c000303d:	c1 e0 03             	shl    $0x3,%eax
c0003040:	89 c2                	mov    %eax,%edx
c0003042:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0003045:	01 d0                	add    %edx,%eax
c0003047:	8b 00                	mov    (%eax),%eax
c0003049:	3b 45 08             	cmp    0x8(%ebp),%eax
c000304c:	73 12                	jae    c0003060 <sys_malloc+0x154>
/work/x86_os_my/kernel/memory.c:374 (discriminator 2)
	} else {
	/* 若申请的内存小于等于1024,可在各种规格的mem_block_desc中去适配 */
		uint8_t desc_idx;

		/* 从内存块描述符中匹配合适的内存块规格 */
		for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c000304e:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
c0003052:	83 c0 01             	add    $0x1,%eax
c0003055:	88 45 e7             	mov    %al,-0x19(%ebp)
/work/x86_os_my/kernel/memory.c:374 (discriminator 1)
c0003058:	80 7d e7 06          	cmpb   $0x6,-0x19(%ebp)
c000305c:	76 d5                	jbe    c0003033 <sys_malloc+0x127>
c000305e:	eb 01                	jmp    c0003061 <sys_malloc+0x155>
/work/x86_os_my/kernel/memory.c:376
			if (size <= descs[desc_idx].block_size) {	// 从小往大后,找到后退出
				break;
c0003060:	90                   	nop
/work/x86_os_my/kernel/memory.c:382
			}
		}

		/* 若mem_block_desc的free_list中已经没有可用的mem_block,
		 * 就创建新的arena提供mem_block */
		if (list_empty(&descs[desc_idx].free_list)) {
c0003061:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0003065:	89 d0                	mov    %edx,%eax
c0003067:	01 c0                	add    %eax,%eax
c0003069:	01 d0                	add    %edx,%eax
c000306b:	c1 e0 03             	shl    $0x3,%eax
c000306e:	89 c2                	mov    %eax,%edx
c0003070:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0003073:	01 d0                	add    %edx,%eax
c0003075:	83 c0 08             	add    $0x8,%eax
c0003078:	83 ec 0c             	sub    $0xc,%esp
c000307b:	50                   	push   %eax
c000307c:	e8 90 1b 00 00       	call   c0004c11 <list_empty>
c0003081:	83 c4 10             	add    $0x10,%esp
c0003084:	85 c0                	test   %eax,%eax
c0003086:	0f 84 31 01 00 00    	je     c00031bd <sys_malloc+0x2b1>
/work/x86_os_my/kernel/memory.c:383
			a = malloc_page(PF, 1);       // 分配1页框做为arena
c000308c:	83 ec 08             	sub    $0x8,%esp
c000308f:	6a 01                	push   $0x1
c0003091:	ff 75 f4             	pushl  -0xc(%ebp)
c0003094:	e8 ae fa ff ff       	call   c0002b47 <malloc_page>
c0003099:	83 c4 10             	add    $0x10,%esp
c000309c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:384
			if (a == NULL) {
c000309f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c00030a3:	75 1c                	jne    c00030c1 <sys_malloc+0x1b5>
/work/x86_os_my/kernel/memory.c:385
				lock_release(&mem_pool->lock);
c00030a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00030a8:	83 c0 10             	add    $0x10,%eax
c00030ab:	83 ec 0c             	sub    $0xc,%esp
c00030ae:	50                   	push   %eax
c00030af:	e8 c2 1e 00 00       	call   c0004f76 <lock_release>
c00030b4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:386
				return NULL;
c00030b7:	b8 00 00 00 00       	mov    $0x0,%eax
c00030bc:	e9 7e 01 00 00       	jmp    c000323f <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:388
			}
			memset(a, 0, PG_SIZE);
c00030c1:	83 ec 04             	sub    $0x4,%esp
c00030c4:	68 00 10 00 00       	push   $0x1000
c00030c9:	6a 00                	push   $0x0
c00030cb:	ff 75 d4             	pushl  -0x2c(%ebp)
c00030ce:	e8 92 09 00 00       	call   c0003a65 <memset>
c00030d3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:392

			// 【arena结构体初始化，情况2】
			/* 对于分配的小块内存,将desc置为相应内存块描述符, cnt置为此arena可用的内存块数, large置为false */
			a->desc = &descs[desc_idx];
c00030d6:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c00030da:	89 d0                	mov    %edx,%eax
c00030dc:	01 c0                	add    %eax,%eax
c00030de:	01 d0                	add    %edx,%eax
c00030e0:	c1 e0 03             	shl    $0x3,%eax
c00030e3:	89 c2                	mov    %eax,%edx
c00030e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00030e8:	01 c2                	add    %eax,%edx
c00030ea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00030ed:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:393
			a->large = false;
c00030ef:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00030f2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/kernel/memory.c:394
			a->cnt = descs[desc_idx].blocks_per_arena;
c00030f9:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c00030fd:	89 d0                	mov    %edx,%eax
c00030ff:	01 c0                	add    %eax,%eax
c0003101:	01 d0                	add    %edx,%eax
c0003103:	c1 e0 03             	shl    $0x3,%eax
c0003106:	89 c2                	mov    %eax,%edx
c0003108:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000310b:	01 d0                	add    %edx,%eax
c000310d:	8b 50 04             	mov    0x4(%eax),%edx
c0003110:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0003113:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/kernel/memory.c:396

			enum intr_status old_status = intr_disable();
c0003116:	e8 6a ea ff ff       	call   c0001b85 <intr_disable>
c000311b:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/kernel/memory.c:399
			/* 开始将arena拆分成内存块,并添加到内存块描述符的free_list中 */
			uint32_t block_idx;
			for (block_idx = 0; block_idx < descs[desc_idx].blocks_per_arena; block_idx++) {
c000311e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c0003125:	eb 68                	jmp    c000318f <sys_malloc+0x283>
/work/x86_os_my/kernel/memory.c:400
				b = arena2block(a, block_idx);
c0003127:	83 ec 08             	sub    $0x8,%esp
c000312a:	ff 75 e0             	pushl  -0x20(%ebp)
c000312d:	ff 75 d4             	pushl  -0x2c(%ebp)
c0003130:	e8 b0 fd ff ff       	call   c0002ee5 <arena2block>
c0003135:	83 c4 10             	add    $0x10,%esp
c0003138:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/kernel/memory.c:401
				ASSERT(!elem_find(&a->desc->free_list, &b->free_elem));
c000313b:	8b 45 cc             	mov    -0x34(%ebp),%eax
c000313e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0003141:	8b 12                	mov    (%edx),%edx
c0003143:	83 c2 08             	add    $0x8,%edx
c0003146:	83 ec 08             	sub    $0x8,%esp
c0003149:	50                   	push   %eax
c000314a:	52                   	push   %edx
c000314b:	e8 f4 19 00 00       	call   c0004b44 <elem_find>
c0003150:	83 c4 10             	add    $0x10,%esp
c0003153:	85 c0                	test   %eax,%eax
c0003155:	74 1c                	je     c0003173 <sys_malloc+0x267>
/work/x86_os_my/kernel/memory.c:401 (discriminator 1)
c0003157:	68 64 de 00 c0       	push   $0xc000de64
c000315c:	68 24 e1 00 c0       	push   $0xc000e124
c0003161:	68 91 01 00 00       	push   $0x191
c0003166:	68 ab dd 00 c0       	push   $0xc000ddab
c000316b:	e8 f1 f3 ff ff       	call   c0002561 <panic_spin>
c0003170:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:402 (discriminator 2)
				list_append(&a->desc->free_list, &b->free_elem);
c0003173:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0003176:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0003179:	8b 12                	mov    (%edx),%edx
c000317b:	83 c2 08             	add    $0x8,%edx
c000317e:	83 ec 08             	sub    $0x8,%esp
c0003181:	50                   	push   %eax
c0003182:	52                   	push   %edx
c0003183:	e8 42 19 00 00       	call   c0004aca <list_append>
c0003188:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:399 (discriminator 2)
			a->cnt = descs[desc_idx].blocks_per_arena;

			enum intr_status old_status = intr_disable();
			/* 开始将arena拆分成内存块,并添加到内存块描述符的free_list中 */
			uint32_t block_idx;
			for (block_idx = 0; block_idx < descs[desc_idx].blocks_per_arena; block_idx++) {
c000318b:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
/work/x86_os_my/kernel/memory.c:399 (discriminator 1)
c000318f:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0003193:	89 d0                	mov    %edx,%eax
c0003195:	01 c0                	add    %eax,%eax
c0003197:	01 d0                	add    %edx,%eax
c0003199:	c1 e0 03             	shl    $0x3,%eax
c000319c:	89 c2                	mov    %eax,%edx
c000319e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00031a1:	01 d0                	add    %edx,%eax
c00031a3:	8b 40 04             	mov    0x4(%eax),%eax
c00031a6:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c00031a9:	0f 87 78 ff ff ff    	ja     c0003127 <sys_malloc+0x21b>
/work/x86_os_my/kernel/memory.c:404
				b = arena2block(a, block_idx);
				ASSERT(!elem_find(&a->desc->free_list, &b->free_elem));
				list_append(&a->desc->free_list, &b->free_elem);
			}
			intr_set_status(old_status);
c00031af:	83 ec 0c             	sub    $0xc,%esp
c00031b2:	ff 75 d0             	pushl  -0x30(%ebp)
c00031b5:	e8 f4 e9 ff ff       	call   c0001bae <intr_set_status>
c00031ba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:408
		}

		/* 开始分配内存块 */
		b = elem2entry(struct mem_block, free_elem, list_pop(&(descs[desc_idx].free_list)));
c00031bd:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c00031c1:	89 d0                	mov    %edx,%eax
c00031c3:	01 c0                	add    %eax,%eax
c00031c5:	01 d0                	add    %edx,%eax
c00031c7:	c1 e0 03             	shl    $0x3,%eax
c00031ca:	89 c2                	mov    %eax,%edx
c00031cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00031cf:	01 d0                	add    %edx,%eax
c00031d1:	83 c0 08             	add    $0x8,%eax
c00031d4:	83 ec 0c             	sub    $0xc,%esp
c00031d7:	50                   	push   %eax
c00031d8:	e8 45 19 00 00       	call   c0004b22 <list_pop>
c00031dd:	83 c4 10             	add    $0x10,%esp
c00031e0:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/kernel/memory.c:409
		memset(b, 0, descs[desc_idx].block_size);
c00031e3:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c00031e7:	89 d0                	mov    %edx,%eax
c00031e9:	01 c0                	add    %eax,%eax
c00031eb:	01 d0                	add    %edx,%eax
c00031ed:	c1 e0 03             	shl    $0x3,%eax
c00031f0:	89 c2                	mov    %eax,%edx
c00031f2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00031f5:	01 d0                	add    %edx,%eax
c00031f7:	8b 00                	mov    (%eax),%eax
c00031f9:	83 ec 04             	sub    $0x4,%esp
c00031fc:	50                   	push   %eax
c00031fd:	6a 00                	push   $0x0
c00031ff:	ff 75 cc             	pushl  -0x34(%ebp)
c0003202:	e8 5e 08 00 00       	call   c0003a65 <memset>
c0003207:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:411

		a = block2arena(b);	// 获取内存块b所在的arena
c000320a:	83 ec 0c             	sub    $0xc,%esp
c000320d:	ff 75 cc             	pushl  -0x34(%ebp)
c0003210:	e8 ea fc ff ff       	call   c0002eff <block2arena>
c0003215:	83 c4 10             	add    $0x10,%esp
c0003218:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:412
		a->cnt--;			// 将此arena中的空闲内存块数减1
c000321b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000321e:	8b 40 04             	mov    0x4(%eax),%eax
c0003221:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003224:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0003227:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/kernel/memory.c:414

		lock_release(&mem_pool->lock);
c000322a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000322d:	83 c0 10             	add    $0x10,%eax
c0003230:	83 ec 0c             	sub    $0xc,%esp
c0003233:	50                   	push   %eax
c0003234:	e8 3d 1d 00 00       	call   c0004f76 <lock_release>
c0003239:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:415
		return (void*)b;
c000323c:	8b 45 cc             	mov    -0x34(%ebp),%eax
/work/x86_os_my/kernel/memory.c:417
	}
}
c000323f:	c9                   	leave  
c0003240:	c3                   	ret    

c0003241 <pfree>:
pfree():
/work/x86_os_my/kernel/memory.c:422

/* 将物理地址pg_phy_addr回收到物理内存池
 * 清理物理地址池位图
 */
void pfree(uint32_t pg_phy_addr) {
c0003241:	55                   	push   %ebp
c0003242:	89 e5                	mov    %esp,%ebp
c0003244:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:424
	struct pool* mem_pool;
	uint32_t bit_idx = 0;
c0003247:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:425
	if (pg_phy_addr >= user_pool.phy_addr_start) {	// 用户物理内存池
c000324e:	a1 48 41 01 c0       	mov    0xc0014148,%eax
c0003253:	3b 45 08             	cmp    0x8(%ebp),%eax
c0003256:	77 1b                	ja     c0003273 <pfree+0x32>
/work/x86_os_my/kernel/memory.c:426
		mem_pool = &user_pool;
c0003258:	c7 45 f4 40 41 01 c0 	movl   $0xc0014140,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:427
		bit_idx = (pg_phy_addr - user_pool.phy_addr_start) / PG_SIZE;
c000325f:	a1 48 41 01 c0       	mov    0xc0014148,%eax
c0003264:	8b 55 08             	mov    0x8(%ebp),%edx
c0003267:	29 c2                	sub    %eax,%edx
c0003269:	89 d0                	mov    %edx,%eax
c000326b:	c1 e8 0c             	shr    $0xc,%eax
c000326e:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0003271:	eb 19                	jmp    c000328c <pfree+0x4b>
/work/x86_os_my/kernel/memory.c:429
	} else {	// 内核物理内存池
		mem_pool = &kernel_pool;
c0003273:	c7 45 f4 40 42 01 c0 	movl   $0xc0014240,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:430
		bit_idx = (pg_phy_addr - kernel_pool.phy_addr_start) / PG_SIZE;
c000327a:	a1 48 42 01 c0       	mov    0xc0014248,%eax
c000327f:	8b 55 08             	mov    0x8(%ebp),%edx
c0003282:	29 c2                	sub    %eax,%edx
c0003284:	89 d0                	mov    %edx,%eax
c0003286:	c1 e8 0c             	shr    $0xc,%eax
c0003289:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:432
	}
	bitmap_set(&mem_pool->pool_bitmap, bit_idx, 0);	// 将位图中该位清0
c000328c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000328f:	83 ec 04             	sub    $0x4,%esp
c0003292:	6a 00                	push   $0x0
c0003294:	ff 75 f0             	pushl  -0x10(%ebp)
c0003297:	50                   	push   %eax
c0003298:	e8 32 f5 ff ff       	call   c00027cf <bitmap_set>
c000329d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:433
}
c00032a0:	90                   	nop
c00032a1:	c9                   	leave  
c00032a2:	c3                   	ret    

c00032a3 <page_table_pte_remove>:
page_table_pte_remove():
/work/x86_os_my/kernel/memory.c:436

/* 去掉页表中虚拟地址vaddr的映射,只去掉vaddr对应的pte */
static void page_table_pte_remove(uint32_t vaddr) {
c00032a3:	55                   	push   %ebp
c00032a4:	89 e5                	mov    %esp,%ebp
c00032a6:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:437
	uint32_t* pte = pte_ptr(vaddr);
c00032a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00032ac:	50                   	push   %eax
c00032ad:	e8 e4 f6 ff ff       	call   c0002996 <pte_ptr>
c00032b2:	83 c4 04             	add    $0x4,%esp
c00032b5:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:438
	*pte &= ~PG_P_1;	// 将页表项pte的P位置0
c00032b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00032bb:	8b 00                	mov    (%eax),%eax
c00032bd:	83 e0 fe             	and    $0xfffffffe,%eax
c00032c0:	89 c2                	mov    %eax,%edx
c00032c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00032c5:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:439
	asm volatile ("invlpg %0"::"m" (vaddr):"memory");	//更新tlb
c00032c7:	0f 01 7d 08          	invlpg 0x8(%ebp)
/work/x86_os_my/kernel/memory.c:442
	/*更新 TLB 有两种方式，一是用 invlpg 指令更新单条虚拟地址条目，
	另外一个是重新加载 cr3 寄存器，这将直接清空 TLB，相当于更新整个页表。*/
}
c00032cb:	90                   	nop
c00032cc:	c9                   	leave  
c00032cd:	c3                   	ret    

c00032ce <vaddr_remove>:
vaddr_remove():
/work/x86_os_my/kernel/memory.c:447

/* 在虚拟地址池中释放以_vaddr起始的连续pg_cnt个虚拟页地址
 * 清理虚拟地址池位图
 */
static void vaddr_remove(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {
c00032ce:	55                   	push   %ebp
c00032cf:	89 e5                	mov    %esp,%ebp
c00032d1:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:448
	uint32_t bit_idx_start = 0, vaddr = (uint32_t)_vaddr, cnt = 0;
c00032d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00032db:	8b 45 0c             	mov    0xc(%ebp),%eax
c00032de:	89 45 ec             	mov    %eax,-0x14(%ebp)
c00032e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:450

	if (pf == PF_KERNEL) {	// 内核虚拟内存池
c00032e8:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c00032ec:	75 3f                	jne    c000332d <vaddr_remove+0x5f>
/work/x86_os_my/kernel/memory.c:451
		bit_idx_start = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
c00032ee:	a1 30 42 01 c0       	mov    0xc0014230,%eax
c00032f3:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00032f6:	29 c2                	sub    %eax,%edx
c00032f8:	89 d0                	mov    %edx,%eax
c00032fa:	c1 e8 0c             	shr    $0xc,%eax
c00032fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:452
		while(cnt < pg_cnt) {
c0003300:	eb 21                	jmp    c0003323 <vaddr_remove+0x55>
/work/x86_os_my/kernel/memory.c:453
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
c0003302:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003305:	8d 50 01             	lea    0x1(%eax),%edx
c0003308:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000330b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000330e:	01 d0                	add    %edx,%eax
c0003310:	83 ec 04             	sub    $0x4,%esp
c0003313:	6a 00                	push   $0x0
c0003315:	50                   	push   %eax
c0003316:	68 28 42 01 c0       	push   $0xc0014228
c000331b:	e8 af f4 ff ff       	call   c00027cf <bitmap_set>
c0003320:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:452
static void vaddr_remove(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {
	uint32_t bit_idx_start = 0, vaddr = (uint32_t)_vaddr, cnt = 0;

	if (pf == PF_KERNEL) {	// 内核虚拟内存池
		bit_idx_start = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
c0003323:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003326:	3b 45 10             	cmp    0x10(%ebp),%eax
c0003329:	72 d7                	jb     c0003302 <vaddr_remove+0x34>
/work/x86_os_my/kernel/memory.c:462
		bit_idx_start = (vaddr - cur_thread->userprog_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
			bitmap_set(&cur_thread->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	}
}
c000332b:	eb 48                	jmp    c0003375 <vaddr_remove+0xa7>
/work/x86_os_my/kernel/memory.c:456
		bit_idx_start = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	} else {	// 用户虚拟内存池
		struct task_struct* cur_thread = running_thread();
c000332d:	e8 1a 0b 00 00       	call   c0003e4c <running_thread>
c0003332:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:457
		bit_idx_start = (vaddr - cur_thread->userprog_vaddr.vaddr_start) / PG_SIZE;
c0003335:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0003338:	8b 40 60             	mov    0x60(%eax),%eax
c000333b:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000333e:	29 c2                	sub    %eax,%edx
c0003340:	89 d0                	mov    %edx,%eax
c0003342:	c1 e8 0c             	shr    $0xc,%eax
c0003345:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:458
		while(cnt < pg_cnt) {
c0003348:	eb 23                	jmp    c000336d <vaddr_remove+0x9f>
/work/x86_os_my/kernel/memory.c:459
			bitmap_set(&cur_thread->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
c000334a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000334d:	8d 50 01             	lea    0x1(%eax),%edx
c0003350:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003353:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0003356:	01 c2                	add    %eax,%edx
c0003358:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000335b:	83 c0 58             	add    $0x58,%eax
c000335e:	83 ec 04             	sub    $0x4,%esp
c0003361:	6a 00                	push   $0x0
c0003363:	52                   	push   %edx
c0003364:	50                   	push   %eax
c0003365:	e8 65 f4 ff ff       	call   c00027cf <bitmap_set>
c000336a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:458
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	} else {	// 用户虚拟内存池
		struct task_struct* cur_thread = running_thread();
		bit_idx_start = (vaddr - cur_thread->userprog_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
c000336d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003370:	3b 45 10             	cmp    0x10(%ebp),%eax
c0003373:	72 d5                	jb     c000334a <vaddr_remove+0x7c>
/work/x86_os_my/kernel/memory.c:462
			bitmap_set(&cur_thread->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	}
}
c0003375:	90                   	nop
c0003376:	c9                   	leave  
c0003377:	c3                   	ret    

c0003378 <mfree_page>:
mfree_page():
/work/x86_os_my/kernel/memory.c:465

/* 释放以虚拟地址vaddr为起始的cnt个物理页框 */
void mfree_page(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {
c0003378:	55                   	push   %ebp
c0003379:	89 e5                	mov    %esp,%ebp
c000337b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:467
	uint32_t pg_phy_addr;
	uint32_t vaddr = (int32_t)_vaddr, page_cnt = 0;
c000337e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003381:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0003384:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:468
	ASSERT(pg_cnt >=1 && vaddr % PG_SIZE == 0);
c000338b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c000338f:	74 0c                	je     c000339d <mfree_page+0x25>
/work/x86_os_my/kernel/memory.c:468 (discriminator 1)
c0003391:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003394:	25 ff 0f 00 00       	and    $0xfff,%eax
c0003399:	85 c0                	test   %eax,%eax
c000339b:	74 1c                	je     c00033b9 <mfree_page+0x41>
/work/x86_os_my/kernel/memory.c:468 (discriminator 3)
c000339d:	68 94 de 00 c0       	push   $0xc000de94
c00033a2:	68 30 e1 00 c0       	push   $0xc000e130
c00033a7:	68 d4 01 00 00       	push   $0x1d4
c00033ac:	68 ab dd 00 c0       	push   $0xc000ddab
c00033b1:	e8 ab f1 ff ff       	call   c0002561 <panic_spin>
c00033b6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:469
	pg_phy_addr = addr_v2p(vaddr);
c00033b9:	83 ec 0c             	sub    $0xc,%esp
c00033bc:	ff 75 f4             	pushl  -0xc(%ebp)
c00033bf:	e8 f5 fa ff ff       	call   c0002eb9 <addr_v2p>
c00033c4:	83 c4 10             	add    $0x10,%esp
c00033c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:472

	/* 确保待释放的物理内存在低端1M+1k大小的页目录+1k大小的页表地址范围外【内核空间】 */
	ASSERT((pg_phy_addr % PG_SIZE) == 0 && pg_phy_addr >= 0x102000);
c00033ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00033cd:	25 ff 0f 00 00       	and    $0xfff,%eax
c00033d2:	85 c0                	test   %eax,%eax
c00033d4:	75 09                	jne    c00033df <mfree_page+0x67>
/work/x86_os_my/kernel/memory.c:472 (discriminator 1)
c00033d6:	81 7d ec ff 1f 10 00 	cmpl   $0x101fff,-0x14(%ebp)
c00033dd:	77 1c                	ja     c00033fb <mfree_page+0x83>
/work/x86_os_my/kernel/memory.c:472 (discriminator 3)
c00033df:	68 b8 de 00 c0       	push   $0xc000deb8
c00033e4:	68 30 e1 00 c0       	push   $0xc000e130
c00033e9:	68 d8 01 00 00       	push   $0x1d8
c00033ee:	68 ab dd 00 c0       	push   $0xc000ddab
c00033f3:	e8 69 f1 ff ff       	call   c0002561 <panic_spin>
c00033f8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:476

	/* 判断pg_phy_addr属于用户物理内存池还是内核物理内存池 */
	/* 位于user_pool内存池 */
	if (pg_phy_addr >= user_pool.phy_addr_start) {
c00033fb:	a1 48 41 01 c0       	mov    0xc0014148,%eax
c0003400:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0003403:	0f 87 94 00 00 00    	ja     c000349d <mfree_page+0x125>
/work/x86_os_my/kernel/memory.c:477
		vaddr -= PG_SIZE;
c0003409:	81 6d f4 00 10 00 00 	subl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:478
		while (page_cnt < pg_cnt) {
c0003410:	eb 6a                	jmp    c000347c <mfree_page+0x104>
/work/x86_os_my/kernel/memory.c:479
			vaddr += PG_SIZE;
c0003412:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:480
			pg_phy_addr = addr_v2p(vaddr);
c0003419:	83 ec 0c             	sub    $0xc,%esp
c000341c:	ff 75 f4             	pushl  -0xc(%ebp)
c000341f:	e8 95 fa ff ff       	call   c0002eb9 <addr_v2p>
c0003424:	83 c4 10             	add    $0x10,%esp
c0003427:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:483

			/* 确保物理地址属于用户物理内存池 */
			ASSERT((pg_phy_addr % PG_SIZE) == 0 && pg_phy_addr >= user_pool.phy_addr_start);
c000342a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000342d:	25 ff 0f 00 00       	and    $0xfff,%eax
c0003432:	85 c0                	test   %eax,%eax
c0003434:	75 0a                	jne    c0003440 <mfree_page+0xc8>
/work/x86_os_my/kernel/memory.c:483 (discriminator 1)
c0003436:	a1 48 41 01 c0       	mov    0xc0014148,%eax
c000343b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c000343e:	76 1c                	jbe    c000345c <mfree_page+0xe4>
/work/x86_os_my/kernel/memory.c:483 (discriminator 3)
c0003440:	68 f0 de 00 c0       	push   $0xc000def0
c0003445:	68 30 e1 00 c0       	push   $0xc000e130
c000344a:	68 e3 01 00 00       	push   $0x1e3
c000344f:	68 ab dd 00 c0       	push   $0xc000ddab
c0003454:	e8 08 f1 ff ff       	call   c0002561 <panic_spin>
c0003459:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:486

			/* 先将对应的物理页框归还到内存池 */
			pfree(pg_phy_addr);
c000345c:	83 ec 0c             	sub    $0xc,%esp
c000345f:	ff 75 ec             	pushl  -0x14(%ebp)
c0003462:	e8 da fd ff ff       	call   c0003241 <pfree>
c0003467:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:489

			/* 再从页表中清除此虚拟地址所在的页表项pte */
			page_table_pte_remove(vaddr);
c000346a:	83 ec 0c             	sub    $0xc,%esp
c000346d:	ff 75 f4             	pushl  -0xc(%ebp)
c0003470:	e8 2e fe ff ff       	call   c00032a3 <page_table_pte_remove>
c0003475:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:491

			page_cnt++;
c0003478:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:478

	/* 判断pg_phy_addr属于用户物理内存池还是内核物理内存池 */
	/* 位于user_pool内存池 */
	if (pg_phy_addr >= user_pool.phy_addr_start) {
		vaddr -= PG_SIZE;
		while (page_cnt < pg_cnt) {
c000347c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000347f:	3b 45 10             	cmp    0x10(%ebp),%eax
c0003482:	72 8e                	jb     c0003412 <mfree_page+0x9a>
/work/x86_os_my/kernel/memory.c:494
			page_table_pte_remove(vaddr);

			page_cnt++;
		}
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);
c0003484:	83 ec 04             	sub    $0x4,%esp
c0003487:	ff 75 10             	pushl  0x10(%ebp)
c000348a:	ff 75 0c             	pushl  0xc(%ebp)
c000348d:	ff 75 08             	pushl  0x8(%ebp)
c0003490:	e8 39 fe ff ff       	call   c00032ce <vaddr_remove>
c0003495:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:518
			page_cnt++;
		}
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);
	}
}
c0003498:	e9 99 00 00 00       	jmp    c0003536 <mfree_page+0x1be>
/work/x86_os_my/kernel/memory.c:498
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);

	} else {
		/* 位于kernel_pool内存池 */
		vaddr -= PG_SIZE;
c000349d:	81 6d f4 00 10 00 00 	subl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:499
		while (page_cnt < pg_cnt) {
c00034a4:	eb 74                	jmp    c000351a <mfree_page+0x1a2>
/work/x86_os_my/kernel/memory.c:500
			vaddr += PG_SIZE;
c00034a6:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:501
			pg_phy_addr = addr_v2p(vaddr);
c00034ad:	83 ec 0c             	sub    $0xc,%esp
c00034b0:	ff 75 f4             	pushl  -0xc(%ebp)
c00034b3:	e8 01 fa ff ff       	call   c0002eb9 <addr_v2p>
c00034b8:	83 c4 10             	add    $0x10,%esp
c00034bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:504

			/* 确保待释放的物理内存只属于内核物理内存池 */
			ASSERT((pg_phy_addr % PG_SIZE) == 0 && pg_phy_addr >= kernel_pool.phy_addr_start && \
c00034be:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00034c1:	25 ff 0f 00 00       	and    $0xfff,%eax
c00034c6:	85 c0                	test   %eax,%eax
c00034c8:	75 14                	jne    c00034de <mfree_page+0x166>
/work/x86_os_my/kernel/memory.c:504 (discriminator 1)
c00034ca:	a1 48 42 01 c0       	mov    0xc0014248,%eax
c00034cf:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00034d2:	77 0a                	ja     c00034de <mfree_page+0x166>
/work/x86_os_my/kernel/memory.c:504 (discriminator 3)
c00034d4:	a1 48 41 01 c0       	mov    0xc0014148,%eax
c00034d9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00034dc:	77 1c                	ja     c00034fa <mfree_page+0x182>
/work/x86_os_my/kernel/memory.c:504 (discriminator 5)
c00034de:	68 38 df 00 c0       	push   $0xc000df38
c00034e3:	68 30 e1 00 c0       	push   $0xc000e130
c00034e8:	68 f9 01 00 00       	push   $0x1f9
c00034ed:	68 ab dd 00 c0       	push   $0xc000ddab
c00034f2:	e8 6a f0 ff ff       	call   c0002561 <panic_spin>
c00034f7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:508
					pg_phy_addr < user_pool.phy_addr_start);

			/* 先将对应的物理页框归还到内存池 */
			pfree(pg_phy_addr);
c00034fa:	83 ec 0c             	sub    $0xc,%esp
c00034fd:	ff 75 ec             	pushl  -0x14(%ebp)
c0003500:	e8 3c fd ff ff       	call   c0003241 <pfree>
c0003505:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:511

			/* 再从页表中清除此虚拟地址所在的页表项pte */
			page_table_pte_remove(vaddr);
c0003508:	83 ec 0c             	sub    $0xc,%esp
c000350b:	ff 75 f4             	pushl  -0xc(%ebp)
c000350e:	e8 90 fd ff ff       	call   c00032a3 <page_table_pte_remove>
c0003513:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:513

			page_cnt++;
c0003516:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:499
		vaddr_remove(pf, _vaddr, pg_cnt);

	} else {
		/* 位于kernel_pool内存池 */
		vaddr -= PG_SIZE;
		while (page_cnt < pg_cnt) {
c000351a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000351d:	3b 45 10             	cmp    0x10(%ebp),%eax
c0003520:	72 84                	jb     c00034a6 <mfree_page+0x12e>
/work/x86_os_my/kernel/memory.c:516
			page_table_pte_remove(vaddr);

			page_cnt++;
		}
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);
c0003522:	83 ec 04             	sub    $0x4,%esp
c0003525:	ff 75 10             	pushl  0x10(%ebp)
c0003528:	ff 75 0c             	pushl  0xc(%ebp)
c000352b:	ff 75 08             	pushl  0x8(%ebp)
c000352e:	e8 9b fd ff ff       	call   c00032ce <vaddr_remove>
c0003533:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:518
	}
}
c0003536:	90                   	nop
c0003537:	c9                   	leave  
c0003538:	c3                   	ret    

c0003539 <sys_free>:
sys_free():
/work/x86_os_my/kernel/memory.c:521

/* 回收内存ptr */
void sys_free(void* ptr) {
c0003539:	55                   	push   %ebp
c000353a:	89 e5                	mov    %esp,%ebp
c000353c:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:522
	ASSERT(ptr != NULL);
c000353f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003543:	75 1c                	jne    c0003561 <sys_free+0x28>
/work/x86_os_my/kernel/memory.c:522 (discriminator 1)
c0003545:	68 ac df 00 c0       	push   $0xc000dfac
c000354a:	68 3c e1 00 c0       	push   $0xc000e13c
c000354f:	68 0a 02 00 00       	push   $0x20a
c0003554:	68 ab dd 00 c0       	push   $0xc000ddab
c0003559:	e8 03 f0 ff ff       	call   c0002561 <panic_spin>
c000355e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:523
	if (ptr != NULL) {
c0003561:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003565:	0f 84 b2 01 00 00    	je     c000371d <sys_free+0x1e4>
/work/x86_os_my/kernel/memory.c:528
		enum pool_flags PF;
		struct pool* mem_pool;

		/* 判断是线程还是进程 */
		if (running_thread()->pgdir == NULL) {
c000356b:	e8 dc 08 00 00       	call   c0003e4c <running_thread>
c0003570:	8b 40 54             	mov    0x54(%eax),%eax
c0003573:	85 c0                	test   %eax,%eax
c0003575:	75 36                	jne    c00035ad <sys_free+0x74>
/work/x86_os_my/kernel/memory.c:529
			ASSERT((uint32_t)ptr >= K_HEAP_START);
c0003577:	8b 45 08             	mov    0x8(%ebp),%eax
c000357a:	3d ff ff 0f c0       	cmp    $0xc00fffff,%eax
c000357f:	77 1c                	ja     c000359d <sys_free+0x64>
/work/x86_os_my/kernel/memory.c:529 (discriminator 1)
c0003581:	68 b8 df 00 c0       	push   $0xc000dfb8
c0003586:	68 3c e1 00 c0       	push   $0xc000e13c
c000358b:	68 11 02 00 00       	push   $0x211
c0003590:	68 ab dd 00 c0       	push   $0xc000ddab
c0003595:	e8 c7 ef ff ff       	call   c0002561 <panic_spin>
c000359a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:530
			PF = PF_KERNEL;
c000359d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:531
			mem_pool = &kernel_pool;
c00035a4:	c7 45 f0 40 42 01 c0 	movl   $0xc0014240,-0x10(%ebp)
c00035ab:	eb 0e                	jmp    c00035bb <sys_free+0x82>
/work/x86_os_my/kernel/memory.c:533
		} else {
			PF = PF_USER;
c00035ad:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:534
			mem_pool = &user_pool;
c00035b4:	c7 45 f0 40 41 01 c0 	movl   $0xc0014140,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:537
		}

		lock_acquire(&mem_pool->lock);
c00035bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00035be:	83 c0 10             	add    $0x10,%eax
c00035c1:	83 ec 0c             	sub    $0xc,%esp
c00035c4:	50                   	push   %eax
c00035c5:	e8 35 19 00 00       	call   c0004eff <lock_acquire>
c00035ca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:538
		struct mem_block* b = ptr;
c00035cd:	8b 45 08             	mov    0x8(%ebp),%eax
c00035d0:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:539
		struct arena* a = block2arena(b);			// 把mem_block转换成arena,获取元信息
c00035d3:	83 ec 0c             	sub    $0xc,%esp
c00035d6:	ff 75 e8             	pushl  -0x18(%ebp)
c00035d9:	e8 21 f9 ff ff       	call   c0002eff <block2arena>
c00035de:	83 c4 10             	add    $0x10,%esp
c00035e1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:540
		ASSERT(a->large == 0 || a->large == 1);
c00035e4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00035e7:	8b 40 08             	mov    0x8(%eax),%eax
c00035ea:	85 c0                	test   %eax,%eax
c00035ec:	74 27                	je     c0003615 <sys_free+0xdc>
/work/x86_os_my/kernel/memory.c:540 (discriminator 1)
c00035ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00035f1:	8b 40 08             	mov    0x8(%eax),%eax
c00035f4:	83 f8 01             	cmp    $0x1,%eax
c00035f7:	74 1c                	je     c0003615 <sys_free+0xdc>
/work/x86_os_my/kernel/memory.c:540 (discriminator 2)
c00035f9:	68 d8 df 00 c0       	push   $0xc000dfd8
c00035fe:	68 3c e1 00 c0       	push   $0xc000e13c
c0003603:	68 1c 02 00 00       	push   $0x21c
c0003608:	68 ab dd 00 c0       	push   $0xc000ddab
c000360d:	e8 4f ef ff ff       	call   c0002561 <panic_spin>
c0003612:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:541
		if (a->desc == NULL && a->large == true) {	// 大于1024的内存
c0003615:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003618:	8b 00                	mov    (%eax),%eax
c000361a:	85 c0                	test   %eax,%eax
c000361c:	75 28                	jne    c0003646 <sys_free+0x10d>
/work/x86_os_my/kernel/memory.c:541 (discriminator 1)
c000361e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003621:	8b 40 08             	mov    0x8(%eax),%eax
c0003624:	83 f8 01             	cmp    $0x1,%eax
c0003627:	75 1d                	jne    c0003646 <sys_free+0x10d>
/work/x86_os_my/kernel/memory.c:542
			mfree_page(PF, a, a->cnt);
c0003629:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000362c:	8b 40 04             	mov    0x4(%eax),%eax
c000362f:	83 ec 04             	sub    $0x4,%esp
c0003632:	50                   	push   %eax
c0003633:	ff 75 e4             	pushl  -0x1c(%ebp)
c0003636:	ff 75 f4             	pushl  -0xc(%ebp)
c0003639:	e8 3a fd ff ff       	call   c0003378 <mfree_page>
c000363e:	83 c4 10             	add    $0x10,%esp
c0003641:	e9 c5 00 00 00       	jmp    c000370b <sys_free+0x1d2>
/work/x86_os_my/kernel/memory.c:546
		} else {									// 小于等于1024的内存块
			/* 先将内存块回收到free_list */
			// &b->free_elem == &b
			list_append(&a->desc->free_list, &b->free_elem);
c0003646:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0003649:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000364c:	8b 12                	mov    (%edx),%edx
c000364e:	83 c2 08             	add    $0x8,%edx
c0003651:	83 ec 08             	sub    $0x8,%esp
c0003654:	50                   	push   %eax
c0003655:	52                   	push   %edx
c0003656:	e8 6f 14 00 00       	call   c0004aca <list_append>
c000365b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:549

			/* 再判断此arena中的内存块是否都是空闲,如果是就释放arena */
			if (++a->cnt == a->desc->blocks_per_arena) {
c000365e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003661:	8b 40 04             	mov    0x4(%eax),%eax
c0003664:	8d 50 01             	lea    0x1(%eax),%edx
c0003667:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000366a:	89 50 04             	mov    %edx,0x4(%eax)
c000366d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003670:	8b 50 04             	mov    0x4(%eax),%edx
c0003673:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003676:	8b 00                	mov    (%eax),%eax
c0003678:	8b 40 04             	mov    0x4(%eax),%eax
c000367b:	39 c2                	cmp    %eax,%edx
c000367d:	0f 85 88 00 00 00    	jne    c000370b <sys_free+0x1d2>
/work/x86_os_my/kernel/memory.c:551
				uint32_t block_idx;
				for (block_idx = 0; block_idx < a->desc->blocks_per_arena; block_idx++) {
c0003683:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c000368a:	eb 5f                	jmp    c00036eb <sys_free+0x1b2>
/work/x86_os_my/kernel/memory.c:552
					struct mem_block*  b = arena2block(a, block_idx);
c000368c:	83 ec 08             	sub    $0x8,%esp
c000368f:	ff 75 ec             	pushl  -0x14(%ebp)
c0003692:	ff 75 e4             	pushl  -0x1c(%ebp)
c0003695:	e8 4b f8 ff ff       	call   c0002ee5 <arena2block>
c000369a:	83 c4 10             	add    $0x10,%esp
c000369d:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/kernel/memory.c:553
					ASSERT(elem_find(&a->desc->free_list, &b->free_elem));
c00036a0:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00036a3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00036a6:	8b 12                	mov    (%edx),%edx
c00036a8:	83 c2 08             	add    $0x8,%edx
c00036ab:	83 ec 08             	sub    $0x8,%esp
c00036ae:	50                   	push   %eax
c00036af:	52                   	push   %edx
c00036b0:	e8 8f 14 00 00       	call   c0004b44 <elem_find>
c00036b5:	83 c4 10             	add    $0x10,%esp
c00036b8:	85 c0                	test   %eax,%eax
c00036ba:	75 1c                	jne    c00036d8 <sys_free+0x19f>
/work/x86_os_my/kernel/memory.c:553 (discriminator 1)
c00036bc:	68 f8 df 00 c0       	push   $0xc000dff8
c00036c1:	68 3c e1 00 c0       	push   $0xc000e13c
c00036c6:	68 29 02 00 00       	push   $0x229
c00036cb:	68 ab dd 00 c0       	push   $0xc000ddab
c00036d0:	e8 8c ee ff ff       	call   c0002561 <panic_spin>
c00036d5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:554 (discriminator 2)
					list_remove(&b->free_elem);
c00036d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00036db:	83 ec 0c             	sub    $0xc,%esp
c00036de:	50                   	push   %eax
c00036df:	e8 04 14 00 00       	call   c0004ae8 <list_remove>
c00036e4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:551 (discriminator 2)
			list_append(&a->desc->free_list, &b->free_elem);

			/* 再判断此arena中的内存块是否都是空闲,如果是就释放arena */
			if (++a->cnt == a->desc->blocks_per_arena) {
				uint32_t block_idx;
				for (block_idx = 0; block_idx < a->desc->blocks_per_arena; block_idx++) {
c00036e7:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:551 (discriminator 1)
c00036eb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00036ee:	8b 00                	mov    (%eax),%eax
c00036f0:	8b 40 04             	mov    0x4(%eax),%eax
c00036f3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00036f6:	77 94                	ja     c000368c <sys_free+0x153>
/work/x86_os_my/kernel/memory.c:556
					struct mem_block*  b = arena2block(a, block_idx);
					ASSERT(elem_find(&a->desc->free_list, &b->free_elem));
					list_remove(&b->free_elem);
				}
				mfree_page(PF, a, 1);
c00036f8:	83 ec 04             	sub    $0x4,%esp
c00036fb:	6a 01                	push   $0x1
c00036fd:	ff 75 e4             	pushl  -0x1c(%ebp)
c0003700:	ff 75 f4             	pushl  -0xc(%ebp)
c0003703:	e8 70 fc ff ff       	call   c0003378 <mfree_page>
c0003708:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:559
			}
		}
		lock_release(&mem_pool->lock);
c000370b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000370e:	83 c0 10             	add    $0x10,%eax
c0003711:	83 ec 0c             	sub    $0xc,%esp
c0003714:	50                   	push   %eax
c0003715:	e8 5c 18 00 00       	call   c0004f76 <lock_release>
c000371a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:561
	}
}
c000371d:	90                   	nop
c000371e:	c9                   	leave  
c000371f:	c3                   	ret    

c0003720 <mem_pool_init>:
mem_pool_init():
/work/x86_os_my/kernel/memory.c:564

/* 初始化内存池 */
static void mem_pool_init(uint32_t all_mem) {
c0003720:	55                   	push   %ebp
c0003721:	89 e5                	mov    %esp,%ebp
c0003723:	83 ec 38             	sub    $0x38,%esp
/work/x86_os_my/kernel/memory.c:565
	put_str("   mem_pool_init start\n");
c0003726:	83 ec 0c             	sub    $0xc,%esp
c0003729:	68 26 e0 00 c0       	push   $0xc000e026
c000372e:	e8 7d ec ff ff       	call   c00023b0 <put_str>
c0003733:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:566
	uint32_t page_table_size = PG_SIZE * 256;		// 页表大小= 1页的页目录表+第0和第768个页目录项指向同一个页表+
c0003736:	c7 45 f4 00 00 10 00 	movl   $0x100000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:568
													// 第769~1022个页目录项共指向254个页表,共256个页框
	uint32_t used_mem = page_table_size + 0x100000;	// 0x100000为低端1M内存
c000373d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003740:	05 00 00 10 00       	add    $0x100000,%eax
c0003745:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:569
	uint32_t free_mem = all_mem - used_mem;
c0003748:	8b 45 08             	mov    0x8(%ebp),%eax
c000374b:	2b 45 f0             	sub    -0x10(%ebp),%eax
c000374e:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:570
	uint16_t all_free_pages = free_mem / PG_SIZE;	// 1页为4k,不管总内存是不是4k的倍数,
c0003751:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0003754:	c1 e8 0c             	shr    $0xc,%eax
c0003757:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
/work/x86_os_my/kernel/memory.c:572
													// 对于以页为单位的内存分配策略，不足1页的内存不用考虑了。
	uint16_t kernel_free_pages = all_free_pages / 2;
c000375b:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c000375f:	66 d1 e8             	shr    %ax
c0003762:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:573
	uint16_t user_free_pages = all_free_pages - kernel_free_pages;
c0003766:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c000376a:	66 2b 45 e8          	sub    -0x18(%ebp),%ax
c000376e:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
/work/x86_os_my/kernel/memory.c:577

	/* 为简化位图操作，余数不处理，坏处是这样做会丢内存。
	好处是不用做内存的越界检查,因为位图表示的内存少于实际物理内存*/
	uint32_t kbm_length = kernel_free_pages / 8;	// Kernel BitMap的长度,位图中的一位表示一页,以字节为单位
c0003772:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0003776:	66 c1 e8 03          	shr    $0x3,%ax
c000377a:	0f b7 c0             	movzwl %ax,%eax
c000377d:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/kernel/memory.c:578
	uint32_t ubm_length = user_free_pages / 8;		// User BitMap的长度.
c0003780:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c0003784:	66 c1 e8 03          	shr    $0x3,%ax
c0003788:	0f b7 c0             	movzwl %ax,%eax
c000378b:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/kernel/memory.c:580

	uint32_t kp_start = used_mem;								// Kernel Pool start,内核内存池的起始地址
c000378e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003791:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/kernel/memory.c:581
	uint32_t up_start = kp_start + kernel_free_pages * PG_SIZE;	// User Pool start,用户内存池的起始地址
c0003794:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0003798:	c1 e0 0c             	shl    $0xc,%eax
c000379b:	89 c2                	mov    %eax,%edx
c000379d:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00037a0:	01 d0                	add    %edx,%eax
c00037a2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:583

	kernel_pool.phy_addr_start = kp_start;
c00037a5:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00037a8:	a3 48 42 01 c0       	mov    %eax,0xc0014248
/work/x86_os_my/kernel/memory.c:584
	user_pool.phy_addr_start   = up_start;
c00037ad:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00037b0:	a3 48 41 01 c0       	mov    %eax,0xc0014148
/work/x86_os_my/kernel/memory.c:586

	kernel_pool.pool_size = kernel_free_pages * PG_SIZE;
c00037b5:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c00037b9:	c1 e0 0c             	shl    $0xc,%eax
c00037bc:	a3 4c 42 01 c0       	mov    %eax,0xc001424c
/work/x86_os_my/kernel/memory.c:587
	user_pool.pool_size	 = user_free_pages * PG_SIZE;
c00037c1:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c00037c5:	c1 e0 0c             	shl    $0xc,%eax
c00037c8:	a3 4c 41 01 c0       	mov    %eax,0xc001414c
/work/x86_os_my/kernel/memory.c:589

	kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;
c00037cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00037d0:	a3 40 42 01 c0       	mov    %eax,0xc0014240
/work/x86_os_my/kernel/memory.c:590
	user_pool.pool_bitmap.btmp_bytes_len	  = ubm_length;
c00037d5:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00037d8:	a3 40 41 01 c0       	mov    %eax,0xc0014140
/work/x86_os_my/kernel/memory.c:599
	*	而我们需要根据总内存大小在运行时，计算出位图的数组需要多少字节。
	*   所以改为指定一块内存来生成位图.
	*   ************************************************/
	// 内核使用的最高地址是0xc009f000,这是主线程的栈地址.(内核的大小预计为70K左右)
	// 32M内存占用的位图是2k.内核内存池的位图先定在MEM_BITMAP_BASE(0xc009a000)处.
	kernel_pool.pool_bitmap.bits = (void*)MEM_BITMAP_BASE;
c00037dd:	c7 05 44 42 01 c0 00 	movl   $0xc009a000,0xc0014244
c00037e4:	a0 09 c0 
/work/x86_os_my/kernel/memory.c:601
	/* 用户内存池的位图紧跟在内核内存池位图之后 */
	user_pool.pool_bitmap.bits = (void*)(MEM_BITMAP_BASE + kbm_length);
c00037e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00037ea:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c00037ef:	a3 44 41 01 c0       	mov    %eax,0xc0014144
/work/x86_os_my/kernel/memory.c:604
	
	/******************** 输出内存池信息 **********************/
	put_str("      kernel_pool_bitmap_start:");put_int((int)kernel_pool.pool_bitmap.bits);
c00037f4:	83 ec 0c             	sub    $0xc,%esp
c00037f7:	68 40 e0 00 c0       	push   $0xc000e040
c00037fc:	e8 af eb ff ff       	call   c00023b0 <put_str>
c0003801:	83 c4 10             	add    $0x10,%esp
c0003804:	a1 44 42 01 c0       	mov    0xc0014244,%eax
c0003809:	83 ec 0c             	sub    $0xc,%esp
c000380c:	50                   	push   %eax
c000380d:	e8 c8 ec ff ff       	call   c00024da <put_int>
c0003812:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:605
	put_str(" kernel_pool_phy_addr_start:");put_int(kernel_pool.phy_addr_start);
c0003815:	83 ec 0c             	sub    $0xc,%esp
c0003818:	68 60 e0 00 c0       	push   $0xc000e060
c000381d:	e8 8e eb ff ff       	call   c00023b0 <put_str>
c0003822:	83 c4 10             	add    $0x10,%esp
c0003825:	a1 48 42 01 c0       	mov    0xc0014248,%eax
c000382a:	83 ec 0c             	sub    $0xc,%esp
c000382d:	50                   	push   %eax
c000382e:	e8 a7 ec ff ff       	call   c00024da <put_int>
c0003833:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:606
	put_str("\n");
c0003836:	83 ec 0c             	sub    $0xc,%esp
c0003839:	68 7d e0 00 c0       	push   $0xc000e07d
c000383e:	e8 6d eb ff ff       	call   c00023b0 <put_str>
c0003843:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:607
	put_str("      user_pool_bitmap_start:");put_int((int)user_pool.pool_bitmap.bits);
c0003846:	83 ec 0c             	sub    $0xc,%esp
c0003849:	68 7f e0 00 c0       	push   $0xc000e07f
c000384e:	e8 5d eb ff ff       	call   c00023b0 <put_str>
c0003853:	83 c4 10             	add    $0x10,%esp
c0003856:	a1 44 41 01 c0       	mov    0xc0014144,%eax
c000385b:	83 ec 0c             	sub    $0xc,%esp
c000385e:	50                   	push   %eax
c000385f:	e8 76 ec ff ff       	call   c00024da <put_int>
c0003864:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:608
	put_str(" user_pool_phy_addr_start:");put_int(user_pool.phy_addr_start);
c0003867:	83 ec 0c             	sub    $0xc,%esp
c000386a:	68 9d e0 00 c0       	push   $0xc000e09d
c000386f:	e8 3c eb ff ff       	call   c00023b0 <put_str>
c0003874:	83 c4 10             	add    $0x10,%esp
c0003877:	a1 48 41 01 c0       	mov    0xc0014148,%eax
c000387c:	83 ec 0c             	sub    $0xc,%esp
c000387f:	50                   	push   %eax
c0003880:	e8 55 ec ff ff       	call   c00024da <put_int>
c0003885:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:609
	put_str("\n");
c0003888:	83 ec 0c             	sub    $0xc,%esp
c000388b:	68 7d e0 00 c0       	push   $0xc000e07d
c0003890:	e8 1b eb ff ff       	call   c00023b0 <put_str>
c0003895:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:612

	/* 将位图置0*/
	bitmap_init(&kernel_pool.pool_bitmap);
c0003898:	83 ec 0c             	sub    $0xc,%esp
c000389b:	68 40 42 01 c0       	push   $0xc0014240
c00038a0:	e8 92 ed ff ff       	call   c0002637 <bitmap_init>
c00038a5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:613
	bitmap_init(&user_pool.pool_bitmap);
c00038a8:	83 ec 0c             	sub    $0xc,%esp
c00038ab:	68 40 41 01 c0       	push   $0xc0014140
c00038b0:	e8 82 ed ff ff       	call   c0002637 <bitmap_init>
c00038b5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:615

	lock_init(&kernel_pool.lock);
c00038b8:	83 ec 0c             	sub    $0xc,%esp
c00038bb:	68 50 42 01 c0       	push   $0xc0014250
c00038c0:	e8 60 14 00 00       	call   c0004d25 <lock_init>
c00038c5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:616
	lock_init(&user_pool.lock);
c00038c8:	83 ec 0c             	sub    $0xc,%esp
c00038cb:	68 50 41 01 c0       	push   $0xc0014150
c00038d0:	e8 50 14 00 00       	call   c0004d25 <lock_init>
c00038d5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:620
	
	/* 下面初始化内核虚拟地址的位图(bp_len + bits数组),按实际物理内存大小生成数组。*/
	// 用于维护内核堆的虚拟地址,所以要和内核内存池大小一致
	kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;
c00038d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00038db:	a3 28 42 01 c0       	mov    %eax,0xc0014228
/work/x86_os_my/kernel/memory.c:622
	/* 位图的数组指向一块未使用的内存,目前定位在内核内存池和用户内存池之外*/
	kernel_vaddr.vaddr_bitmap.bits = (void*)(MEM_BITMAP_BASE + kbm_length + ubm_length);
c00038e0:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00038e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00038e6:	01 d0                	add    %edx,%eax
c00038e8:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c00038ed:	a3 2c 42 01 c0       	mov    %eax,0xc001422c
/work/x86_os_my/kernel/memory.c:624

	kernel_vaddr.vaddr_start = K_HEAP_START;
c00038f2:	c7 05 30 42 01 c0 00 	movl   $0xc0100000,0xc0014230
c00038f9:	00 10 c0 
/work/x86_os_my/kernel/memory.c:625
	bitmap_init(&kernel_vaddr.vaddr_bitmap);
c00038fc:	83 ec 0c             	sub    $0xc,%esp
c00038ff:	68 28 42 01 c0       	push   $0xc0014228
c0003904:	e8 2e ed ff ff       	call   c0002637 <bitmap_init>
c0003909:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:626
	put_str("   mem_pool_init done\n");
c000390c:	83 ec 0c             	sub    $0xc,%esp
c000390f:	68 b8 e0 00 c0       	push   $0xc000e0b8
c0003914:	e8 97 ea ff ff       	call   c00023b0 <put_str>
c0003919:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:627
}
c000391c:	90                   	nop
c000391d:	c9                   	leave  
c000391e:	c3                   	ret    

c000391f <block_desc_init>:
block_desc_init():
/work/x86_os_my/kernel/memory.c:630

/* 为malloc做准备 */
void block_desc_init(struct mem_block_desc* desc_array) {
c000391f:	55                   	push   %ebp
c0003920:	89 e5                	mov    %esp,%ebp
c0003922:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:631
   uint16_t desc_idx, block_size = 16;
c0003925:	66 c7 45 f4 10 00    	movw   $0x10,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:634

   /* 初始化每个mem_block_desc描述符 */
   for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c000392b:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
c0003931:	eb 75                	jmp    c00039a8 <block_desc_init+0x89>
/work/x86_os_my/kernel/memory.c:635 (discriminator 3)
      desc_array[desc_idx].block_size = block_size;
c0003933:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c0003937:	89 d0                	mov    %edx,%eax
c0003939:	01 c0                	add    %eax,%eax
c000393b:	01 d0                	add    %edx,%eax
c000393d:	c1 e0 03             	shl    $0x3,%eax
c0003940:	89 c2                	mov    %eax,%edx
c0003942:	8b 45 08             	mov    0x8(%ebp),%eax
c0003945:	01 c2                	add    %eax,%edx
c0003947:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c000394b:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/kernel/memory.c:638 (discriminator 3)

      /* 初始化arena中的内存块数量【注意计算方法】 */
      desc_array[desc_idx].blocks_per_arena = (PG_SIZE - sizeof(struct arena)) / block_size;
c000394d:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c0003951:	89 d0                	mov    %edx,%eax
c0003953:	01 c0                	add    %eax,%eax
c0003955:	01 d0                	add    %edx,%eax
c0003957:	c1 e0 03             	shl    $0x3,%eax
c000395a:	89 c2                	mov    %eax,%edx
c000395c:	8b 45 08             	mov    0x8(%ebp),%eax
c000395f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c0003962:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c0003967:	ba 00 00 00 00       	mov    $0x0,%edx
c000396c:	66 f7 75 f4          	divw   -0xc(%ebp)
c0003970:	0f b7 c0             	movzwl %ax,%eax
c0003973:	89 41 04             	mov    %eax,0x4(%ecx)
/work/x86_os_my/kernel/memory.c:640 (discriminator 3)

      list_init(&desc_array[desc_idx].free_list);
c0003976:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c000397a:	89 d0                	mov    %edx,%eax
c000397c:	01 c0                	add    %eax,%eax
c000397e:	01 d0                	add    %edx,%eax
c0003980:	c1 e0 03             	shl    $0x3,%eax
c0003983:	89 c2                	mov    %eax,%edx
c0003985:	8b 45 08             	mov    0x8(%ebp),%eax
c0003988:	01 d0                	add    %edx,%eax
c000398a:	83 c0 08             	add    $0x8,%eax
c000398d:	83 ec 0c             	sub    $0xc,%esp
c0003990:	50                   	push   %eax
c0003991:	e8 a3 10 00 00       	call   c0004a39 <list_init>
c0003996:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:642 (discriminator 3)

      block_size *= 2;		// 下一个规格内存块！
c0003999:	66 d1 65 f4          	shlw   -0xc(%ebp)
/work/x86_os_my/kernel/memory.c:634 (discriminator 3)
/* 为malloc做准备 */
void block_desc_init(struct mem_block_desc* desc_array) {
   uint16_t desc_idx, block_size = 16;

   /* 初始化每个mem_block_desc描述符 */
   for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c000399d:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c00039a1:	83 c0 01             	add    $0x1,%eax
c00039a4:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/kernel/memory.c:634 (discriminator 1)
c00039a8:	66 83 7d f6 06       	cmpw   $0x6,-0xa(%ebp)
c00039ad:	76 84                	jbe    c0003933 <block_desc_init+0x14>
/work/x86_os_my/kernel/memory.c:645
      list_init(&desc_array[desc_idx].free_list);

      block_size *= 2;		// 下一个规格内存块！
	  // 16/32/64/128/256/512/1024 总共 7 种规格
   }
}
c00039af:	90                   	nop
c00039b0:	c9                   	leave  
c00039b1:	c3                   	ret    

c00039b2 <free_a_phy_page>:
free_a_phy_page():
/work/x86_os_my/kernel/memory.c:648

/* 根据物理页框地址pg_phy_addr在相应的内存池的位图清0,不改动页表*/
void free_a_phy_page(uint32_t pg_phy_addr) {
c00039b2:	55                   	push   %ebp
c00039b3:	89 e5                	mov    %esp,%ebp
c00039b5:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:650
	struct pool* mem_pool;
	uint32_t bit_idx = 0;
c00039b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:651
	if (pg_phy_addr >= user_pool.phy_addr_start) {
c00039bf:	a1 48 41 01 c0       	mov    0xc0014148,%eax
c00039c4:	3b 45 08             	cmp    0x8(%ebp),%eax
c00039c7:	77 1b                	ja     c00039e4 <free_a_phy_page+0x32>
/work/x86_os_my/kernel/memory.c:652
		mem_pool = &user_pool;
c00039c9:	c7 45 f4 40 41 01 c0 	movl   $0xc0014140,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:653
		bit_idx = (pg_phy_addr - user_pool.phy_addr_start) / PG_SIZE;
c00039d0:	a1 48 41 01 c0       	mov    0xc0014148,%eax
c00039d5:	8b 55 08             	mov    0x8(%ebp),%edx
c00039d8:	29 c2                	sub    %eax,%edx
c00039da:	89 d0                	mov    %edx,%eax
c00039dc:	c1 e8 0c             	shr    $0xc,%eax
c00039df:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00039e2:	eb 19                	jmp    c00039fd <free_a_phy_page+0x4b>
/work/x86_os_my/kernel/memory.c:655
	} else {
		mem_pool = &kernel_pool;
c00039e4:	c7 45 f4 40 42 01 c0 	movl   $0xc0014240,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:656
		bit_idx = (pg_phy_addr - kernel_pool.phy_addr_start) / PG_SIZE;
c00039eb:	a1 48 42 01 c0       	mov    0xc0014248,%eax
c00039f0:	8b 55 08             	mov    0x8(%ebp),%edx
c00039f3:	29 c2                	sub    %eax,%edx
c00039f5:	89 d0                	mov    %edx,%eax
c00039f7:	c1 e8 0c             	shr    $0xc,%eax
c00039fa:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:658
	}
	bitmap_set(&mem_pool->pool_bitmap, bit_idx, 0);
c00039fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003a00:	83 ec 04             	sub    $0x4,%esp
c0003a03:	6a 00                	push   $0x0
c0003a05:	ff 75 f0             	pushl  -0x10(%ebp)
c0003a08:	50                   	push   %eax
c0003a09:	e8 c1 ed ff ff       	call   c00027cf <bitmap_set>
c0003a0e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:659
}
c0003a11:	90                   	nop
c0003a12:	c9                   	leave  
c0003a13:	c3                   	ret    

c0003a14 <mem_init>:
mem_init():
/work/x86_os_my/kernel/memory.c:662

/* 内存管理部分初始化入口 */
void mem_init() {
c0003a14:	55                   	push   %ebp
c0003a15:	89 e5                	mov    %esp,%ebp
c0003a17:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:663
	put_str("mem_init start\n");
c0003a1a:	83 ec 0c             	sub    $0xc,%esp
c0003a1d:	68 cf e0 00 c0       	push   $0xc000e0cf
c0003a22:	e8 89 e9 ff ff       	call   c00023b0 <put_str>
c0003a27:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:664
	uint32_t mem_bytes_total = (*(uint32_t*)(0xb00));	//内存总数在汇编中获取，放到了地址0xb00处。
c0003a2a:	b8 00 0b 00 00       	mov    $0xb00,%eax
c0003a2f:	8b 00                	mov    (%eax),%eax
c0003a31:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:665
	mem_pool_init(mem_bytes_total);	// 初始化内存池
c0003a34:	83 ec 0c             	sub    $0xc,%esp
c0003a37:	ff 75 f4             	pushl  -0xc(%ebp)
c0003a3a:	e8 e1 fc ff ff       	call   c0003720 <mem_pool_init>
c0003a3f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:666
	block_desc_init(k_block_descs);	// 初始化mem_block_desc数组descs,为malloc做准备
c0003a42:	83 ec 0c             	sub    $0xc,%esp
c0003a45:	68 80 41 01 c0       	push   $0xc0014180
c0003a4a:	e8 d0 fe ff ff       	call   c000391f <block_desc_init>
c0003a4f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:667
	put_str("mem_init done\n");
c0003a52:	83 ec 0c             	sub    $0xc,%esp
c0003a55:	68 df e0 00 c0       	push   $0xc000e0df
c0003a5a:	e8 51 e9 ff ff       	call   c00023b0 <put_str>
c0003a5f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:668
}
c0003a62:	90                   	nop
c0003a63:	c9                   	leave  
c0003a64:	c3                   	ret    

c0003a65 <memset>:
memset():
/work/x86_os_my/lib/string.c:6
#include "string.h"
//#include "global.h"
#include "assert.h"

/* 将dst_起始的size个字节置为value */
void memset(void* dst_, uint8_t value, uint32_t size) {
c0003a65:	55                   	push   %ebp
c0003a66:	89 e5                	mov    %esp,%ebp
c0003a68:	83 ec 28             	sub    $0x28,%esp
c0003a6b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003a6e:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:7
   assert(dst_ != NULL);
c0003a71:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003a75:	75 19                	jne    c0003a90 <memset+0x2b>
/work/x86_os_my/lib/string.c:7 (discriminator 1)
c0003a77:	68 48 e1 00 c0       	push   $0xc000e148
c0003a7c:	68 bc e1 00 c0       	push   $0xc000e1bc
c0003a81:	6a 07                	push   $0x7
c0003a83:	68 55 e1 00 c0       	push   $0xc000e155
c0003a88:	e8 15 8b 00 00       	call   c000c5a2 <user_spin>
c0003a8d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:8
   uint8_t* dst = (uint8_t*)dst_;
c0003a90:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a93:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:9
   while (size-- > 0)
c0003a96:	eb 0f                	jmp    c0003aa7 <memset+0x42>
/work/x86_os_my/lib/string.c:10
      *dst++ = value;
c0003a98:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003a9b:	8d 50 01             	lea    0x1(%eax),%edx
c0003a9e:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003aa1:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c0003aa5:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/string.c:9

/* 将dst_起始的size个字节置为value */
void memset(void* dst_, uint8_t value, uint32_t size) {
   assert(dst_ != NULL);
   uint8_t* dst = (uint8_t*)dst_;
   while (size-- > 0)
c0003aa7:	8b 45 10             	mov    0x10(%ebp),%eax
c0003aaa:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003aad:	89 55 10             	mov    %edx,0x10(%ebp)
c0003ab0:	85 c0                	test   %eax,%eax
c0003ab2:	75 e4                	jne    c0003a98 <memset+0x33>
/work/x86_os_my/lib/string.c:11
      *dst++ = value;
}
c0003ab4:	90                   	nop
c0003ab5:	c9                   	leave  
c0003ab6:	c3                   	ret    

c0003ab7 <memcpy>:
memcpy():
/work/x86_os_my/lib/string.c:14

/* 将src_起始的size个字节复制到dst_ */
void memcpy(void* dst_, const void* src_, uint32_t size) {
c0003ab7:	55                   	push   %ebp
c0003ab8:	89 e5                	mov    %esp,%ebp
c0003aba:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:15
   assert(dst_ != NULL && src_ != NULL);
c0003abd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003ac1:	74 06                	je     c0003ac9 <memcpy+0x12>
/work/x86_os_my/lib/string.c:15 (discriminator 2)
c0003ac3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0003ac7:	75 19                	jne    c0003ae2 <memcpy+0x2b>
/work/x86_os_my/lib/string.c:15 (discriminator 3)
c0003ac9:	68 62 e1 00 c0       	push   $0xc000e162
c0003ace:	68 c4 e1 00 c0       	push   $0xc000e1c4
c0003ad3:	6a 0f                	push   $0xf
c0003ad5:	68 55 e1 00 c0       	push   $0xc000e155
c0003ada:	e8 c3 8a 00 00       	call   c000c5a2 <user_spin>
c0003adf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:16
   uint8_t* dst = dst_;
c0003ae2:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ae5:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:17
   const uint8_t* src = src_;
c0003ae8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003aeb:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:18
   while (size-- > 0)
c0003aee:	eb 17                	jmp    c0003b07 <memcpy+0x50>
/work/x86_os_my/lib/string.c:19
      *dst++ = *src++;
c0003af0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003af3:	8d 50 01             	lea    0x1(%eax),%edx
c0003af6:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003af9:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0003afc:	8d 4a 01             	lea    0x1(%edx),%ecx
c0003aff:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0003b02:	0f b6 12             	movzbl (%edx),%edx
c0003b05:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/string.c:18
/* 将src_起始的size个字节复制到dst_ */
void memcpy(void* dst_, const void* src_, uint32_t size) {
   assert(dst_ != NULL && src_ != NULL);
   uint8_t* dst = dst_;
   const uint8_t* src = src_;
   while (size-- > 0)
c0003b07:	8b 45 10             	mov    0x10(%ebp),%eax
c0003b0a:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003b0d:	89 55 10             	mov    %edx,0x10(%ebp)
c0003b10:	85 c0                	test   %eax,%eax
c0003b12:	75 dc                	jne    c0003af0 <memcpy+0x39>
/work/x86_os_my/lib/string.c:20
      *dst++ = *src++;
}
c0003b14:	90                   	nop
c0003b15:	c9                   	leave  
c0003b16:	c3                   	ret    

c0003b17 <memcmp>:
memcmp():
/work/x86_os_my/lib/string.c:23

/* 连续比较以地址a_和地址b_开头的size个字节,若相等则返回0,若a_大于b_返回+1,否则返回-1 */
int memcmp(const void* a_, const void* b_, uint32_t size) {
c0003b17:	55                   	push   %ebp
c0003b18:	89 e5                	mov    %esp,%ebp
c0003b1a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:24
   const char* a = a_;
c0003b1d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b20:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:25
   const char* b = b_;
c0003b23:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003b26:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:26
   assert(a != NULL || b != NULL);
c0003b29:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0003b2d:	75 57                	jne    c0003b86 <memcmp+0x6f>
/work/x86_os_my/lib/string.c:26 (discriminator 1)
c0003b2f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0003b33:	75 51                	jne    c0003b86 <memcmp+0x6f>
/work/x86_os_my/lib/string.c:26 (discriminator 2)
c0003b35:	68 7f e1 00 c0       	push   $0xc000e17f
c0003b3a:	68 cc e1 00 c0       	push   $0xc000e1cc
c0003b3f:	6a 1a                	push   $0x1a
c0003b41:	68 55 e1 00 c0       	push   $0xc000e155
c0003b46:	e8 57 8a 00 00       	call   c000c5a2 <user_spin>
c0003b4b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:27 (discriminator 2)
   while (size-- > 0) {
c0003b4e:	eb 36                	jmp    c0003b86 <memcmp+0x6f>
/work/x86_os_my/lib/string.c:28
      if(*a != *b) {
c0003b50:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003b53:	0f b6 10             	movzbl (%eax),%edx
c0003b56:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003b59:	0f b6 00             	movzbl (%eax),%eax
c0003b5c:	38 c2                	cmp    %al,%dl
c0003b5e:	74 1e                	je     c0003b7e <memcmp+0x67>
/work/x86_os_my/lib/string.c:29
	 return *a > *b ? 1 : -1; 
c0003b60:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003b63:	0f b6 10             	movzbl (%eax),%edx
c0003b66:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003b69:	0f b6 00             	movzbl (%eax),%eax
c0003b6c:	38 c2                	cmp    %al,%dl
c0003b6e:	7e 07                	jle    c0003b77 <memcmp+0x60>
/work/x86_os_my/lib/string.c:29 (discriminator 1)
c0003b70:	b8 01 00 00 00       	mov    $0x1,%eax
c0003b75:	eb 21                	jmp    c0003b98 <memcmp+0x81>
/work/x86_os_my/lib/string.c:29 (discriminator 2)
c0003b77:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003b7c:	eb 1a                	jmp    c0003b98 <memcmp+0x81>
/work/x86_os_my/lib/string.c:31
      }
      a++;
c0003b7e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:32
      b++;
c0003b82:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/string.c:27
/* 连续比较以地址a_和地址b_开头的size个字节,若相等则返回0,若a_大于b_返回+1,否则返回-1 */
int memcmp(const void* a_, const void* b_, uint32_t size) {
   const char* a = a_;
   const char* b = b_;
   assert(a != NULL || b != NULL);
   while (size-- > 0) {
c0003b86:	8b 45 10             	mov    0x10(%ebp),%eax
c0003b89:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003b8c:	89 55 10             	mov    %edx,0x10(%ebp)
c0003b8f:	85 c0                	test   %eax,%eax
c0003b91:	75 bd                	jne    c0003b50 <memcmp+0x39>
/work/x86_os_my/lib/string.c:34
	 return *a > *b ? 1 : -1; 
      }
      a++;
      b++;
   }
   return 0;
c0003b93:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/string.c:35
}
c0003b98:	c9                   	leave  
c0003b99:	c3                   	ret    

c0003b9a <strcpy>:
strcpy():
/work/x86_os_my/lib/string.c:38

/* 将字符串从src_复制到dst_ */
char* strcpy(char* dst_, const char* src_) {
c0003b9a:	55                   	push   %ebp
c0003b9b:	89 e5                	mov    %esp,%ebp
c0003b9d:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:39
   assert(dst_ != NULL && src_ != NULL);
c0003ba0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003ba4:	74 06                	je     c0003bac <strcpy+0x12>
/work/x86_os_my/lib/string.c:39 (discriminator 2)
c0003ba6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0003baa:	75 19                	jne    c0003bc5 <strcpy+0x2b>
/work/x86_os_my/lib/string.c:39 (discriminator 3)
c0003bac:	68 62 e1 00 c0       	push   $0xc000e162
c0003bb1:	68 d4 e1 00 c0       	push   $0xc000e1d4
c0003bb6:	6a 27                	push   $0x27
c0003bb8:	68 55 e1 00 c0       	push   $0xc000e155
c0003bbd:	e8 e0 89 00 00       	call   c000c5a2 <user_spin>
c0003bc2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:40
   char* r = dst_;		       // 用来返回目的字符串起始地址
c0003bc5:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bc8:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:41
   while((*dst_++ = *src_++));
c0003bcb:	90                   	nop
/work/x86_os_my/lib/string.c:41 (discriminator 1)
c0003bcc:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bcf:	8d 50 01             	lea    0x1(%eax),%edx
c0003bd2:	89 55 08             	mov    %edx,0x8(%ebp)
c0003bd5:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003bd8:	8d 4a 01             	lea    0x1(%edx),%ecx
c0003bdb:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c0003bde:	0f b6 12             	movzbl (%edx),%edx
c0003be1:	88 10                	mov    %dl,(%eax)
c0003be3:	0f b6 00             	movzbl (%eax),%eax
c0003be6:	84 c0                	test   %al,%al
c0003be8:	75 e2                	jne    c0003bcc <strcpy+0x32>
/work/x86_os_my/lib/string.c:42
   return r;
c0003bea:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:43
}
c0003bed:	c9                   	leave  
c0003bee:	c3                   	ret    

c0003bef <strlen>:
strlen():
/work/x86_os_my/lib/string.c:46

/* 返回字符串长度 */
uint32_t strlen(const char* str) {
c0003bef:	55                   	push   %ebp
c0003bf0:	89 e5                	mov    %esp,%ebp
c0003bf2:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:47
   assert(str != NULL);
c0003bf5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003bf9:	75 19                	jne    c0003c14 <strlen+0x25>
/work/x86_os_my/lib/string.c:47 (discriminator 1)
c0003bfb:	68 96 e1 00 c0       	push   $0xc000e196
c0003c00:	68 dc e1 00 c0       	push   $0xc000e1dc
c0003c05:	6a 2f                	push   $0x2f
c0003c07:	68 55 e1 00 c0       	push   $0xc000e155
c0003c0c:	e8 91 89 00 00       	call   c000c5a2 <user_spin>
c0003c11:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:48
   const char* p = str;
c0003c14:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c17:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:49
   while(*p++);
c0003c1a:	90                   	nop
/work/x86_os_my/lib/string.c:49 (discriminator 1)
c0003c1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003c1e:	8d 50 01             	lea    0x1(%eax),%edx
c0003c21:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003c24:	0f b6 00             	movzbl (%eax),%eax
c0003c27:	84 c0                	test   %al,%al
c0003c29:	75 f0                	jne    c0003c1b <strlen+0x2c>
/work/x86_os_my/lib/string.c:50
   return (p - str - 1);
c0003c2b:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0003c2e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c31:	29 c2                	sub    %eax,%edx
c0003c33:	89 d0                	mov    %edx,%eax
c0003c35:	83 e8 01             	sub    $0x1,%eax
/work/x86_os_my/lib/string.c:51
}
c0003c38:	c9                   	leave  
c0003c39:	c3                   	ret    

c0003c3a <strcmp>:
strcmp():
/work/x86_os_my/lib/string.c:54

/* 比较两个字符串,若a_中的字符大于b_中的字符返回1,相等时返回0,否则返回-1. */
int8_t strcmp (const char* a, const char* b) {
c0003c3a:	55                   	push   %ebp
c0003c3b:	89 e5                	mov    %esp,%ebp
c0003c3d:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/string.c:55
   assert(a != NULL && b != NULL);
c0003c40:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003c44:	74 06                	je     c0003c4c <strcmp+0x12>
/work/x86_os_my/lib/string.c:55 (discriminator 2)
c0003c46:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0003c4a:	75 23                	jne    c0003c6f <strcmp+0x35>
/work/x86_os_my/lib/string.c:55 (discriminator 3)
c0003c4c:	68 a2 e1 00 c0       	push   $0xc000e1a2
c0003c51:	68 e4 e1 00 c0       	push   $0xc000e1e4
c0003c56:	6a 37                	push   $0x37
c0003c58:	68 55 e1 00 c0       	push   $0xc000e155
c0003c5d:	e8 40 89 00 00       	call   c000c5a2 <user_spin>
c0003c62:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:56 (discriminator 3)
   while (*a != 0 && *a == *b) {
c0003c65:	eb 08                	jmp    c0003c6f <strcmp+0x35>
/work/x86_os_my/lib/string.c:57
      a++;
c0003c67:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:58
      b++;
c0003c6b:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
/work/x86_os_my/lib/string.c:56
}

/* 比较两个字符串,若a_中的字符大于b_中的字符返回1,相等时返回0,否则返回-1. */
int8_t strcmp (const char* a, const char* b) {
   assert(a != NULL && b != NULL);
   while (*a != 0 && *a == *b) {
c0003c6f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c72:	0f b6 00             	movzbl (%eax),%eax
c0003c75:	84 c0                	test   %al,%al
c0003c77:	74 10                	je     c0003c89 <strcmp+0x4f>
/work/x86_os_my/lib/string.c:56 (discriminator 1)
c0003c79:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c7c:	0f b6 10             	movzbl (%eax),%edx
c0003c7f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003c82:	0f b6 00             	movzbl (%eax),%eax
c0003c85:	38 c2                	cmp    %al,%dl
c0003c87:	74 de                	je     c0003c67 <strcmp+0x2d>
/work/x86_os_my/lib/string.c:62
      a++;
      b++;
   }
/* 如果*a小于*b就返回-1,否则就属于*a大于等于*b的情况。在后面的布尔表达式"*a > *b"中,
 * 若*a大于*b,表达式就等于1,否则就表达式不成立,也就是布尔值为0,恰恰表示*a等于*b */
   return *a < *b ? -1 : *a > *b;
c0003c89:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c8c:	0f b6 10             	movzbl (%eax),%edx
c0003c8f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003c92:	0f b6 00             	movzbl (%eax),%eax
c0003c95:	38 c2                	cmp    %al,%dl
c0003c97:	7c 13                	jl     c0003cac <strcmp+0x72>
/work/x86_os_my/lib/string.c:62 (discriminator 1)
c0003c99:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c9c:	0f b6 10             	movzbl (%eax),%edx
c0003c9f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003ca2:	0f b6 00             	movzbl (%eax),%eax
c0003ca5:	38 c2                	cmp    %al,%dl
c0003ca7:	0f 9f c0             	setg   %al
c0003caa:	eb 05                	jmp    c0003cb1 <strcmp+0x77>
/work/x86_os_my/lib/string.c:62 (discriminator 2)
c0003cac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/lib/string.c:63 (discriminator 5)
}
c0003cb1:	c9                   	leave  
c0003cb2:	c3                   	ret    

c0003cb3 <strchr>:
strchr():
/work/x86_os_my/lib/string.c:66

/* 从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strchr(const char* str, const uint8_t ch) {
c0003cb3:	55                   	push   %ebp
c0003cb4:	89 e5                	mov    %esp,%ebp
c0003cb6:	83 ec 18             	sub    $0x18,%esp
c0003cb9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003cbc:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/lib/string.c:67
   assert(str != NULL);
c0003cbf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003cc3:	75 35                	jne    c0003cfa <strchr+0x47>
/work/x86_os_my/lib/string.c:67 (discriminator 1)
c0003cc5:	68 96 e1 00 c0       	push   $0xc000e196
c0003cca:	68 ec e1 00 c0       	push   $0xc000e1ec
c0003ccf:	6a 43                	push   $0x43
c0003cd1:	68 55 e1 00 c0       	push   $0xc000e155
c0003cd6:	e8 c7 88 00 00       	call   c000c5a2 <user_spin>
c0003cdb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:68 (discriminator 1)
   while (*str != 0) {
c0003cde:	eb 1a                	jmp    c0003cfa <strchr+0x47>
/work/x86_os_my/lib/string.c:69
      if (*str == ch) {
c0003ce0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ce3:	0f b6 00             	movzbl (%eax),%eax
c0003ce6:	0f be d0             	movsbl %al,%edx
c0003ce9:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0003ced:	39 c2                	cmp    %eax,%edx
c0003cef:	75 05                	jne    c0003cf6 <strchr+0x43>
/work/x86_os_my/lib/string.c:70
	 return (char*)str;	    // 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.
c0003cf1:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cf4:	eb 13                	jmp    c0003d09 <strchr+0x56>
/work/x86_os_my/lib/string.c:72
      }
      str++;
c0003cf6:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:68
}

/* 从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strchr(const char* str, const uint8_t ch) {
   assert(str != NULL);
   while (*str != 0) {
c0003cfa:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cfd:	0f b6 00             	movzbl (%eax),%eax
c0003d00:	84 c0                	test   %al,%al
c0003d02:	75 dc                	jne    c0003ce0 <strchr+0x2d>
/work/x86_os_my/lib/string.c:74
      if (*str == ch) {
	 return (char*)str;	    // 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.
      }
      str++;
   }
   return NULL;
c0003d04:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/string.c:75
}
c0003d09:	c9                   	leave  
c0003d0a:	c3                   	ret    

c0003d0b <strrchr>:
strrchr():
/work/x86_os_my/lib/string.c:78

/* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strrchr(const char* str, const uint8_t ch) {
c0003d0b:	55                   	push   %ebp
c0003d0c:	89 e5                	mov    %esp,%ebp
c0003d0e:	83 ec 28             	sub    $0x28,%esp
c0003d11:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003d14:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:79
   assert(str != NULL);
c0003d17:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003d1b:	75 19                	jne    c0003d36 <strrchr+0x2b>
/work/x86_os_my/lib/string.c:79 (discriminator 1)
c0003d1d:	68 96 e1 00 c0       	push   $0xc000e196
c0003d22:	68 f4 e1 00 c0       	push   $0xc000e1f4
c0003d27:	6a 4f                	push   $0x4f
c0003d29:	68 55 e1 00 c0       	push   $0xc000e155
c0003d2e:	e8 6f 88 00 00       	call   c000c5a2 <user_spin>
c0003d33:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:80
   const char* last_char = NULL;
c0003d36:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/string.c:82
   /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/
   while (*str != 0) {
c0003d3d:	eb 1b                	jmp    c0003d5a <strrchr+0x4f>
/work/x86_os_my/lib/string.c:83
      if (*str == ch) {
c0003d3f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d42:	0f b6 00             	movzbl (%eax),%eax
c0003d45:	0f be d0             	movsbl %al,%edx
c0003d48:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0003d4c:	39 c2                	cmp    %eax,%edx
c0003d4e:	75 06                	jne    c0003d56 <strrchr+0x4b>
/work/x86_os_my/lib/string.c:84
	 last_char = str;
c0003d50:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d53:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:86
      }
      str++;
c0003d56:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:82
/* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strrchr(const char* str, const uint8_t ch) {
   assert(str != NULL);
   const char* last_char = NULL;
   /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/
   while (*str != 0) {
c0003d5a:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d5d:	0f b6 00             	movzbl (%eax),%eax
c0003d60:	84 c0                	test   %al,%al
c0003d62:	75 db                	jne    c0003d3f <strrchr+0x34>
/work/x86_os_my/lib/string.c:88
      if (*str == ch) {
	 last_char = str;
      }
      str++;
   }
   return (char*)last_char;
c0003d64:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:89
}
c0003d67:	c9                   	leave  
c0003d68:	c3                   	ret    

c0003d69 <strcat>:
strcat():
/work/x86_os_my/lib/string.c:92

/* 将字符串src_拼接到dst_后,将回拼接的串地址 */
char* strcat(char* dst_, const char* src_) {
c0003d69:	55                   	push   %ebp
c0003d6a:	89 e5                	mov    %esp,%ebp
c0003d6c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:93
   assert(dst_ != NULL && src_ != NULL);
c0003d6f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003d73:	74 06                	je     c0003d7b <strcat+0x12>
/work/x86_os_my/lib/string.c:93 (discriminator 2)
c0003d75:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0003d79:	75 19                	jne    c0003d94 <strcat+0x2b>
/work/x86_os_my/lib/string.c:93 (discriminator 3)
c0003d7b:	68 62 e1 00 c0       	push   $0xc000e162
c0003d80:	68 fc e1 00 c0       	push   $0xc000e1fc
c0003d85:	6a 5d                	push   $0x5d
c0003d87:	68 55 e1 00 c0       	push   $0xc000e155
c0003d8c:	e8 11 88 00 00       	call   c000c5a2 <user_spin>
c0003d91:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:94
   char* str = dst_;
c0003d94:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d97:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:95
   while (*str++);
c0003d9a:	90                   	nop
/work/x86_os_my/lib/string.c:95 (discriminator 1)
c0003d9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003d9e:	8d 50 01             	lea    0x1(%eax),%edx
c0003da1:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003da4:	0f b6 00             	movzbl (%eax),%eax
c0003da7:	84 c0                	test   %al,%al
c0003da9:	75 f0                	jne    c0003d9b <strcat+0x32>
/work/x86_os_my/lib/string.c:96
   --str;      // 别看错了，--str是独立的一句，并不是while的循环体
c0003dab:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:97
   while((*str++ = *src_++));	 // 当*str被赋值为0时,此时表达式不成立,正好添加了字符串结尾的0.
c0003daf:	90                   	nop
/work/x86_os_my/lib/string.c:97 (discriminator 1)
c0003db0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003db3:	8d 50 01             	lea    0x1(%eax),%edx
c0003db6:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003db9:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003dbc:	8d 4a 01             	lea    0x1(%edx),%ecx
c0003dbf:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c0003dc2:	0f b6 12             	movzbl (%edx),%edx
c0003dc5:	88 10                	mov    %dl,(%eax)
c0003dc7:	0f b6 00             	movzbl (%eax),%eax
c0003dca:	84 c0                	test   %al,%al
c0003dcc:	75 e2                	jne    c0003db0 <strcat+0x47>
/work/x86_os_my/lib/string.c:98
   return dst_;
c0003dce:	8b 45 08             	mov    0x8(%ebp),%eax
/work/x86_os_my/lib/string.c:99
}
c0003dd1:	c9                   	leave  
c0003dd2:	c3                   	ret    

c0003dd3 <strchrs>:
strchrs():
/work/x86_os_my/lib/string.c:102

/* 在字符串str中查找指定字符ch出现的次数 */
uint32_t strchrs(const char* str, uint8_t ch) {
c0003dd3:	55                   	push   %ebp
c0003dd4:	89 e5                	mov    %esp,%ebp
c0003dd6:	83 ec 28             	sub    $0x28,%esp
c0003dd9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003ddc:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:103
   assert(str != NULL);
c0003ddf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003de3:	75 19                	jne    c0003dfe <strchrs+0x2b>
/work/x86_os_my/lib/string.c:103 (discriminator 1)
c0003de5:	68 96 e1 00 c0       	push   $0xc000e196
c0003dea:	68 04 e2 00 c0       	push   $0xc000e204
c0003def:	6a 67                	push   $0x67
c0003df1:	68 55 e1 00 c0       	push   $0xc000e155
c0003df6:	e8 a7 87 00 00       	call   c000c5a2 <user_spin>
c0003dfb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:104
   uint32_t ch_cnt = 0;
c0003dfe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/string.c:105
   const char* p = str;
c0003e05:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e08:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:106
   while(*p != 0) {
c0003e0b:	eb 19                	jmp    c0003e26 <strchrs+0x53>
/work/x86_os_my/lib/string.c:107
      if (*p == ch) {
c0003e0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003e10:	0f b6 00             	movzbl (%eax),%eax
c0003e13:	0f be d0             	movsbl %al,%edx
c0003e16:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0003e1a:	39 c2                	cmp    %eax,%edx
c0003e1c:	75 04                	jne    c0003e22 <strchrs+0x4f>
/work/x86_os_my/lib/string.c:108
	 ch_cnt++;
c0003e1e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:110
      }
      p++;
c0003e22:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/string.c:106
/* 在字符串str中查找指定字符ch出现的次数 */
uint32_t strchrs(const char* str, uint8_t ch) {
   assert(str != NULL);
   uint32_t ch_cnt = 0;
   const char* p = str;
   while(*p != 0) {
c0003e26:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003e29:	0f b6 00             	movzbl (%eax),%eax
c0003e2c:	84 c0                	test   %al,%al
c0003e2e:	75 dd                	jne    c0003e0d <strchrs+0x3a>
/work/x86_os_my/lib/string.c:112
      if (*p == ch) {
	 ch_cnt++;
      }
      p++;
   }
   return ch_cnt;
c0003e30:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:113
}
c0003e33:	c9                   	leave  
c0003e34:	c3                   	ret    

c0003e35 <idle>:
idle():
/work/x86_os_my/thread/thread.c:37

extern void switch_to(struct task_struct* cur, struct task_struct* next);
extern void init(void);

/* idle线程 */
static void idle(void* arg UNUSED) {
c0003e35:	55                   	push   %ebp
c0003e36:	89 e5                	mov    %esp,%ebp
c0003e38:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:39 (discriminator 1)
	while(1) {
		thread_block(TASK_BLOCKED);
c0003e3b:	83 ec 0c             	sub    $0xc,%esp
c0003e3e:	6a 02                	push   $0x2
c0003e40:	e8 67 05 00 00       	call   c00043ac <thread_block>
c0003e45:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:43 (discriminator 1)
		//CPU停机
		//唯一能唤醒处理器的就是外部中断
		//执行hlt时必须要保证目前处在开中断的情况下
		asm volatile ("sti; hlt" : : : "memory");
c0003e48:	fb                   	sti    
c0003e49:	f4                   	hlt    
/work/x86_os_my/thread/thread.c:44 (discriminator 1)
	}
c0003e4a:	eb ef                	jmp    c0003e3b <idle+0x6>

c0003e4c <running_thread>:
running_thread():
/work/x86_os_my/thread/thread.c:51

/* 返回线程 PCB 地址。
 * 各个线程所用的 0 级栈都是在自己的 PCB 当中，
 * 取当前栈指针的高 20 位，就是当前运行线程的 PCB（PCB是在自然页的起始地址！）
 */
struct task_struct* running_thread() {
c0003e4c:	55                   	push   %ebp
c0003e4d:	89 e5                	mov    %esp,%ebp
c0003e4f:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:53
	uint32_t esp;
	asm ("mov %%esp, %0" : "=g" (esp));	//esp寄存器的值，放入变量esp
c0003e52:	89 e0                	mov    %esp,%eax
c0003e54:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:54
	return (struct task_struct*)(esp & 0xfffff000);
c0003e57:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003e5a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
/work/x86_os_my/thread/thread.c:55
}
c0003e5f:	c9                   	leave  
c0003e60:	c3                   	ret    

c0003e61 <kernel_thread>:
kernel_thread():
/work/x86_os_my/thread/thread.c:58

/* 由kernel_thread去执行function(func_arg) */
static void kernel_thread(thread_func* function, void* func_arg) {
c0003e61:	55                   	push   %ebp
c0003e62:	89 e5                	mov    %esp,%ebp
c0003e64:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:64
	/* 线程的首次运行是由时钟中断处理函数调用任务调度器 schedule 完成的，
	 * 进入中断后处理器会自动关中断，
	 * 因此在执行 function 前要打开中断，否则 kernel_thread 中的 function 在关中断的情况下运行，
	 * 也就是时钟中断被屏蔽了，再也不会调度到新的线程，function 会独享处理器。
	 */
	intr_enable();
c0003e67:	e8 f0 dc ff ff       	call   c0001b5c <intr_enable>
/work/x86_os_my/thread/thread.c:65
	function(func_arg); 
c0003e6c:	83 ec 0c             	sub    $0xc,%esp
c0003e6f:	ff 75 0c             	pushl  0xc(%ebp)
c0003e72:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e75:	ff d0                	call   *%eax
c0003e77:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:66
}
c0003e7a:	90                   	nop
c0003e7b:	c9                   	leave  
c0003e7c:	c3                   	ret    

c0003e7d <pid_pool_init>:
pid_pool_init():
/work/x86_os_my/thread/thread.c:69

/* 初始化pid池 */
static void pid_pool_init(void) {
c0003e7d:	55                   	push   %ebp
c0003e7e:	89 e5                	mov    %esp,%ebp
c0003e80:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:70
	pid_pool.pid_start = 1;
c0003e83:	c7 05 88 42 01 c0 01 	movl   $0x1,0xc0014288
c0003e8a:	00 00 00 
/work/x86_os_my/thread/thread.c:71
	pid_pool.pid_bitmap.bits = pid_bitmap_bits;
c0003e8d:	c7 05 84 42 01 c0 80 	movl   $0xc0013580,0xc0014284
c0003e94:	35 01 c0 
/work/x86_os_my/thread/thread.c:72
	pid_pool.pid_bitmap.btmp_bytes_len = 128;
c0003e97:	c7 05 80 42 01 c0 80 	movl   $0x80,0xc0014280
c0003e9e:	00 00 00 
/work/x86_os_my/thread/thread.c:73
	bitmap_init(&pid_pool.pid_bitmap);
c0003ea1:	83 ec 0c             	sub    $0xc,%esp
c0003ea4:	68 80 42 01 c0       	push   $0xc0014280
c0003ea9:	e8 89 e7 ff ff       	call   c0002637 <bitmap_init>
c0003eae:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:74
	lock_init(&pid_pool.pid_lock);
c0003eb1:	83 ec 0c             	sub    $0xc,%esp
c0003eb4:	68 8c 42 01 c0       	push   $0xc001428c
c0003eb9:	e8 67 0e 00 00       	call   c0004d25 <lock_init>
c0003ebe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:75
}
c0003ec1:	90                   	nop
c0003ec2:	c9                   	leave  
c0003ec3:	c3                   	ret    

c0003ec4 <allocate_pid>:
allocate_pid():
/work/x86_os_my/thread/thread.c:78

/* 分配pid */
static pid_t allocate_pid(void) {
c0003ec4:	55                   	push   %ebp
c0003ec5:	89 e5                	mov    %esp,%ebp
c0003ec7:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:79
	lock_acquire(&pid_pool.pid_lock);
c0003eca:	83 ec 0c             	sub    $0xc,%esp
c0003ecd:	68 8c 42 01 c0       	push   $0xc001428c
c0003ed2:	e8 28 10 00 00       	call   c0004eff <lock_acquire>
c0003ed7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:80
	int32_t bit_idx = bitmap_scan(&pid_pool.pid_bitmap, 1);
c0003eda:	83 ec 08             	sub    $0x8,%esp
c0003edd:	6a 01                	push   $0x1
c0003edf:	68 80 42 01 c0       	push   $0xc0014280
c0003ee4:	e8 b1 e7 ff ff       	call   c000269a <bitmap_scan>
c0003ee9:	83 c4 10             	add    $0x10,%esp
c0003eec:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:81
	bitmap_set(&pid_pool.pid_bitmap, bit_idx, 1);
c0003eef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003ef2:	83 ec 04             	sub    $0x4,%esp
c0003ef5:	6a 01                	push   $0x1
c0003ef7:	50                   	push   %eax
c0003ef8:	68 80 42 01 c0       	push   $0xc0014280
c0003efd:	e8 cd e8 ff ff       	call   c00027cf <bitmap_set>
c0003f02:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:82
	lock_release(&pid_pool.pid_lock);
c0003f05:	83 ec 0c             	sub    $0xc,%esp
c0003f08:	68 8c 42 01 c0       	push   $0xc001428c
c0003f0d:	e8 64 10 00 00       	call   c0004f76 <lock_release>
c0003f12:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:83
	return (bit_idx + pid_pool.pid_start);
c0003f15:	a1 88 42 01 c0       	mov    0xc0014288,%eax
c0003f1a:	89 c2                	mov    %eax,%edx
c0003f1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003f1f:	01 d0                	add    %edx,%eax
/work/x86_os_my/thread/thread.c:84
}
c0003f21:	c9                   	leave  
c0003f22:	c3                   	ret    

c0003f23 <release_pid>:
release_pid():
/work/x86_os_my/thread/thread.c:87

/* 释放pid */
void release_pid(pid_t pid) {
c0003f23:	55                   	push   %ebp
c0003f24:	89 e5                	mov    %esp,%ebp
c0003f26:	83 ec 28             	sub    $0x28,%esp
c0003f29:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f2c:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
/work/x86_os_my/thread/thread.c:88
	lock_acquire(&pid_pool.pid_lock);
c0003f30:	83 ec 0c             	sub    $0xc,%esp
c0003f33:	68 8c 42 01 c0       	push   $0xc001428c
c0003f38:	e8 c2 0f 00 00       	call   c0004eff <lock_acquire>
c0003f3d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:89
	int32_t bit_idx = pid - pid_pool.pid_start;
c0003f40:	0f bf 55 e4          	movswl -0x1c(%ebp),%edx
c0003f44:	a1 88 42 01 c0       	mov    0xc0014288,%eax
c0003f49:	29 c2                	sub    %eax,%edx
c0003f4b:	89 d0                	mov    %edx,%eax
c0003f4d:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:90
	bitmap_set(&pid_pool.pid_bitmap, bit_idx, 0);
c0003f50:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003f53:	83 ec 04             	sub    $0x4,%esp
c0003f56:	6a 00                	push   $0x0
c0003f58:	50                   	push   %eax
c0003f59:	68 80 42 01 c0       	push   $0xc0014280
c0003f5e:	e8 6c e8 ff ff       	call   c00027cf <bitmap_set>
c0003f63:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:91
	lock_release(&pid_pool.pid_lock);
c0003f66:	83 ec 0c             	sub    $0xc,%esp
c0003f69:	68 8c 42 01 c0       	push   $0xc001428c
c0003f6e:	e8 03 10 00 00       	call   c0004f76 <lock_release>
c0003f73:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:92
}
c0003f76:	90                   	nop
c0003f77:	c9                   	leave  
c0003f78:	c3                   	ret    

c0003f79 <fork_pid>:
fork_pid():
/work/x86_os_my/thread/thread.c:95

/* fork进程时为其分配pid，只是再封装一次 allocate_pid */
pid_t fork_pid(void) {
c0003f79:	55                   	push   %ebp
c0003f7a:	89 e5                	mov    %esp,%ebp
c0003f7c:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:96
	return allocate_pid();
c0003f7f:	e8 40 ff ff ff       	call   c0003ec4 <allocate_pid>
/work/x86_os_my/thread/thread.c:97
}
c0003f84:	c9                   	leave  
c0003f85:	c3                   	ret    

c0003f86 <thread_create>:
thread_create():
/work/x86_os_my/thread/thread.c:100

/* 初始化线程栈结构体 struct thread_stack */
void thread_create(struct task_struct* pthread, thread_func function, void* func_arg) {
c0003f86:	55                   	push   %ebp
c0003f87:	89 e5                	mov    %esp,%ebp
c0003f89:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:104
	/* 先预留中断使用栈的空间 
	 *（1）将来线程进入中断后，位于 kernel.S 中的中断代码会通过此栈来保存上下文。
	 *（2）将来实现用户进程时，会将用户进程的初始信息放在中断栈中。*/
	pthread->self_kstack -= sizeof(struct intr_stack);
c0003f8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f8f:	8b 00                	mov    (%eax),%eax
c0003f91:	8d 90 d0 fe ff ff    	lea    -0x130(%eax),%edx
c0003f97:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f9a:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:107

	/* 再留出线程栈空间（unused_retaddr 所在的栈）*/
	pthread->self_kstack -= sizeof(struct thread_stack);
c0003f9c:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f9f:	8b 00                	mov    (%eax),%eax
c0003fa1:	8d 50 80             	lea    -0x80(%eax),%edx
c0003fa4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003fa7:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:108
	struct thread_stack* kthread_stack = (struct thread_stack*)pthread->self_kstack;
c0003fa9:	8b 45 08             	mov    0x8(%ebp),%eax
c0003fac:	8b 00                	mov    (%eax),%eax
c0003fae:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:116
	 * kernel_thread 并不是通过 call 指令调用的，而是通过 ret 来执行的，
	 * 因此无法按照正常的函数调用形式传递 kernel_thread 所需要的参数，
	 * 这样调用是不行的： kernel_thread(function, func_arg)，
	 * 只能将参数放在 kernel_thread 所用的栈中，即处理器进入 kernel_thread 函数体时，
	 * 栈顶为返回地址，栈顶+4 为参数function，栈顶+8 为参数func_arg */
	kthread_stack->eip = kernel_thread;
c0003fb1:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003fb4:	c7 40 10 61 3e 00 c0 	movl   $0xc0003e61,0x10(%eax)
/work/x86_os_my/thread/thread.c:117
	kthread_stack->function = function;
c0003fbb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003fbe:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003fc1:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/thread.c:118
	kthread_stack->func_arg = func_arg;
c0003fc4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003fc7:	8b 55 10             	mov    0x10(%ebp),%edx
c0003fca:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/thread/thread.c:119
	kthread_stack->ebp = kthread_stack->ebx = kthread_stack->esi = kthread_stack->edi = 0;
c0003fcd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003fd0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c0003fd7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003fda:	8b 50 08             	mov    0x8(%eax),%edx
c0003fdd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003fe0:	89 50 0c             	mov    %edx,0xc(%eax)
c0003fe3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003fe6:	8b 50 0c             	mov    0xc(%eax),%edx
c0003fe9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003fec:	89 50 04             	mov    %edx,0x4(%eax)
c0003fef:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003ff2:	8b 50 04             	mov    0x4(%eax),%edx
c0003ff5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003ff8:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:120
}
c0003ffa:	90                   	nop
c0003ffb:	c9                   	leave  
c0003ffc:	c3                   	ret    

c0003ffd <init_thread>:
init_thread():
/work/x86_os_my/thread/thread.c:123

/* 初始化线程PCB结构体 struct task_struct */
void init_thread(struct task_struct* pthread, char* name, int prio) {
c0003ffd:	55                   	push   %ebp
c0003ffe:	89 e5                	mov    %esp,%ebp
c0004000:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:124
	memset(pthread, 0, sizeof(*pthread));	//清空PCB
c0004003:	83 ec 04             	sub    $0x4,%esp
c0004006:	68 18 01 00 00       	push   $0x118
c000400b:	6a 00                	push   $0x0
c000400d:	ff 75 08             	pushl  0x8(%ebp)
c0004010:	e8 50 fa ff ff       	call   c0003a65 <memset>
c0004015:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:125
	pthread->pid = allocate_pid();
c0004018:	e8 a7 fe ff ff       	call   c0003ec4 <allocate_pid>
c000401d:	89 c2                	mov    %eax,%edx
c000401f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004022:	66 89 50 04          	mov    %dx,0x4(%eax)
/work/x86_os_my/thread/thread.c:126
	strcpy(pthread->name, name);
c0004026:	8b 45 08             	mov    0x8(%ebp),%eax
c0004029:	83 c0 0c             	add    $0xc,%eax
c000402c:	83 ec 08             	sub    $0x8,%esp
c000402f:	ff 75 0c             	pushl  0xc(%ebp)
c0004032:	50                   	push   %eax
c0004033:	e8 62 fb ff ff       	call   c0003b9a <strcpy>
c0004038:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:128

	if (pthread == g_main_thread) {
c000403b:	a1 cc 42 01 c0       	mov    0xc00142cc,%eax
c0004040:	39 45 08             	cmp    %eax,0x8(%ebp)
c0004043:	75 0c                	jne    c0004051 <init_thread+0x54>
/work/x86_os_my/thread/thread.c:130
		/* 由于把main函数也封装成一个线程,并且它一直是运行的,故将其直接设为TASK_RUNNING */
		pthread->status = TASK_RUNNING;
c0004045:	8b 45 08             	mov    0x8(%ebp),%eax
c0004048:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c000404f:	eb 0a                	jmp    c000405b <init_thread+0x5e>
/work/x86_os_my/thread/thread.c:132
	} else {
		pthread->status = TASK_READY;
c0004051:	8b 45 08             	mov    0x8(%ebp),%eax
c0004054:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:138
	}

	/* self_kstack是线程自己在内核态下使用的栈顶地址 
	 * 线程自己在 0 特权级下所用的栈，在线程创建之初，
	 * 它被初始化为线程 PCB 的最顶端，即(uint32_t)pthread + PG_SIZE。*/
	pthread->self_kstack = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c000405b:	8b 45 08             	mov    0x8(%ebp),%eax
c000405e:	05 00 10 00 00       	add    $0x1000,%eax
c0004063:	89 c2                	mov    %eax,%edx
c0004065:	8b 45 08             	mov    0x8(%ebp),%eax
c0004068:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:139
	pthread->priority = prio;
c000406a:	8b 45 10             	mov    0x10(%ebp),%eax
c000406d:	89 c2                	mov    %eax,%edx
c000406f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004072:	88 50 1c             	mov    %dl,0x1c(%eax)
/work/x86_os_my/thread/thread.c:140
	pthread->ticks = prio;
c0004075:	8b 45 10             	mov    0x10(%ebp),%eax
c0004078:	89 c2                	mov    %eax,%edx
c000407a:	8b 45 08             	mov    0x8(%ebp),%eax
c000407d:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/thread/thread.c:141
	pthread->elapsed_ticks = 0;
c0004080:	8b 45 08             	mov    0x8(%ebp),%eax
c0004083:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
/work/x86_os_my/thread/thread.c:142
	pthread->pgdir = NULL;
c000408a:	8b 45 08             	mov    0x8(%ebp),%eax
c000408d:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
/work/x86_os_my/thread/thread.c:145

	/* 预留标准输入输出 */
	pthread->fd_table[0] = 0;
c0004094:	8b 45 08             	mov    0x8(%ebp),%eax
c0004097:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
/work/x86_os_my/thread/thread.c:146
	pthread->fd_table[1] = 1;
c000409e:	8b 45 08             	mov    0x8(%ebp),%eax
c00040a1:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
/work/x86_os_my/thread/thread.c:147
	pthread->fd_table[2] = 2;
c00040a8:	8b 45 08             	mov    0x8(%ebp),%eax
c00040ab:	c7 40 2c 02 00 00 00 	movl   $0x2,0x2c(%eax)
/work/x86_os_my/thread/thread.c:149
	/* 其余的全置为-1 */
	uint8_t fd_idx = 3;
c00040b2:	c6 45 f7 03          	movb   $0x3,-0x9(%ebp)
/work/x86_os_my/thread/thread.c:150
	while (fd_idx < MAX_FILES_OPEN_PER_PROC) {
c00040b6:	eb 1c                	jmp    c00040d4 <init_thread+0xd7>
/work/x86_os_my/thread/thread.c:151
		pthread->fd_table[fd_idx] = -1;
c00040b8:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c00040bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00040bf:	83 c2 08             	add    $0x8,%edx
c00040c2:	c7 44 90 04 ff ff ff 	movl   $0xffffffff,0x4(%eax,%edx,4)
c00040c9:	ff 
/work/x86_os_my/thread/thread.c:152
		fd_idx++;
c00040ca:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00040ce:	83 c0 01             	add    $0x1,%eax
c00040d1:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/thread/thread.c:150
	pthread->fd_table[0] = 0;
	pthread->fd_table[1] = 1;
	pthread->fd_table[2] = 2;
	/* 其余的全置为-1 */
	uint8_t fd_idx = 3;
	while (fd_idx < MAX_FILES_OPEN_PER_PROC) {
c00040d4:	80 7d f7 07          	cmpb   $0x7,-0x9(%ebp)
c00040d8:	76 de                	jbe    c00040b8 <init_thread+0xbb>
/work/x86_os_my/thread/thread.c:155
		pthread->fd_table[fd_idx] = -1;
		fd_idx++;
	}

	pthread->cwd_inode_nr = 0;			// 以根目录做为默认工作路径
c00040da:	8b 45 08             	mov    0x8(%ebp),%eax
c00040dd:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%eax)
c00040e4:	00 00 00 
/work/x86_os_my/thread/thread.c:156
	pthread->parent_pid = -1;			// -1表示没有父进程
c00040e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00040ea:	66 c7 80 10 01 00 00 	movw   $0xffff,0x110(%eax)
c00040f1:	ff ff 
/work/x86_os_my/thread/thread.c:157
	pthread->stack_magic = 0x19870916;	// 自定义的魔数
c00040f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00040f6:	c7 80 14 01 00 00 16 	movl   $0x19870916,0x114(%eax)
c00040fd:	09 87 19 
/work/x86_os_my/thread/thread.c:158
}
c0004100:	90                   	nop
c0004101:	c9                   	leave  
c0004102:	c3                   	ret    

c0004103 <thread_start>:
thread_start():
/work/x86_os_my/thread/thread.c:161

/* 创建线程 */
struct task_struct* thread_start(char* name, int prio, thread_func function, void* func_arg) {
c0004103:	55                   	push   %ebp
c0004104:	89 e5                	mov    %esp,%ebp
c0004106:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:163
	/* pcb都位于内核空间,包括用户进程的pcb也是在内核空间 */
	struct task_struct* thread = get_kernel_pages(1);
c0004109:	83 ec 0c             	sub    $0xc,%esp
c000410c:	6a 01                	push   $0x1
c000410e:	e8 f6 ea ff ff       	call   c0002c09 <get_kernel_pages>
c0004113:	83 c4 10             	add    $0x10,%esp
c0004116:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:165

	init_thread(thread, name, prio);			//初始化线程PCB
c0004119:	83 ec 04             	sub    $0x4,%esp
c000411c:	ff 75 0c             	pushl  0xc(%ebp)
c000411f:	ff 75 08             	pushl  0x8(%ebp)
c0004122:	ff 75 f4             	pushl  -0xc(%ebp)
c0004125:	e8 d3 fe ff ff       	call   c0003ffd <init_thread>
c000412a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:166
	thread_create(thread, function, func_arg);	//初始化线程栈结构体
c000412d:	83 ec 04             	sub    $0x4,%esp
c0004130:	ff 75 14             	pushl  0x14(%ebp)
c0004133:	ff 75 10             	pushl  0x10(%ebp)
c0004136:	ff 75 f4             	pushl  -0xc(%ebp)
c0004139:	e8 48 fe ff ff       	call   c0003f86 <thread_create>
c000413e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:168
	
	ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));	// 确保之前不在队列中
c0004141:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004144:	83 c0 44             	add    $0x44,%eax
c0004147:	83 ec 08             	sub    $0x8,%esp
c000414a:	50                   	push   %eax
c000414b:	68 a8 42 01 c0       	push   $0xc00142a8
c0004150:	e8 ef 09 00 00       	call   c0004b44 <elem_find>
c0004155:	83 c4 10             	add    $0x10,%esp
c0004158:	85 c0                	test   %eax,%eax
c000415a:	74 1c                	je     c0004178 <thread_start+0x75>
/work/x86_os_my/thread/thread.c:168 (discriminator 1)
c000415c:	68 0c e2 00 c0       	push   $0xc000e20c
c0004161:	68 6c e5 00 c0       	push   $0xc000e56c
c0004166:	68 a8 00 00 00       	push   $0xa8
c000416b:	68 41 e2 00 c0       	push   $0xc000e241
c0004170:	e8 ec e3 ff ff       	call   c0002561 <panic_spin>
c0004175:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:169
	list_append(&thread_ready_list, &thread->general_tag);			// 加入就绪线程队列
c0004178:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000417b:	83 c0 44             	add    $0x44,%eax
c000417e:	83 ec 08             	sub    $0x8,%esp
c0004181:	50                   	push   %eax
c0004182:	68 a8 42 01 c0       	push   $0xc00142a8
c0004187:	e8 3e 09 00 00       	call   c0004aca <list_append>
c000418c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:171

	ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
c000418f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004192:	83 c0 4c             	add    $0x4c,%eax
c0004195:	83 ec 08             	sub    $0x8,%esp
c0004198:	50                   	push   %eax
c0004199:	68 b8 42 01 c0       	push   $0xc00142b8
c000419e:	e8 a1 09 00 00       	call   c0004b44 <elem_find>
c00041a3:	83 c4 10             	add    $0x10,%esp
c00041a6:	85 c0                	test   %eax,%eax
c00041a8:	74 1c                	je     c00041c6 <thread_start+0xc3>
/work/x86_os_my/thread/thread.c:171 (discriminator 1)
c00041aa:	68 54 e2 00 c0       	push   $0xc000e254
c00041af:	68 6c e5 00 c0       	push   $0xc000e56c
c00041b4:	68 ab 00 00 00       	push   $0xab
c00041b9:	68 41 e2 00 c0       	push   $0xc000e241
c00041be:	e8 9e e3 ff ff       	call   c0002561 <panic_spin>
c00041c3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:172
	list_append(&thread_all_list, &thread->all_list_tag);			// 加入全部线程队列
c00041c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00041c9:	83 c0 4c             	add    $0x4c,%eax
c00041cc:	83 ec 08             	sub    $0x8,%esp
c00041cf:	50                   	push   %eax
c00041d0:	68 b8 42 01 c0       	push   $0xc00142b8
c00041d5:	e8 f0 08 00 00       	call   c0004aca <list_append>
c00041da:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:188
	 * 在执行 ret 后，esp 指向的数值被弹岀到 eip。
	 * 处理器会去执行 kernel_thread 函数。
	 * 在执行 kernel_thread 时，处理器以为栈顶是返回地址，其实只是一个假的占位置的变量 unused_retaddr！
	 * 接着会调用函数 function(func_arg) */
	//asm volatile ("movl %0, %%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret" : : "g" (thread->self_kstack) : "memory");
	return thread;
c00041dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/thread/thread.c:189
}
c00041e0:	c9                   	leave  
c00041e1:	c3                   	ret    

c00041e2 <make_main_thread>:
make_main_thread():
/work/x86_os_my/thread/thread.c:193


/* 将kernel中的main函数完善为主线程 */
static void make_main_thread(void) {
c00041e2:	55                   	push   %ebp
c00041e3:	89 e5                	mov    %esp,%ebp
c00041e5:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:198
	/* 因为main线程早已运行,咱们在loader.S中进入内核时的mov esp, 0xc009f000设置了栈顶，也预留了pcb, 地址为0xc009e000
	 * 主线程不需要再为PCB申请页，只需要通过 init_thread 填充PCB成员：名称和优先级等。
	 * 也不需要再通过 thread_create 构造它的线程栈。
	 */
	g_main_thread = running_thread();	//用栈指针的高20位，当做当前线程的PCB
c00041e8:	e8 5f fc ff ff       	call   c0003e4c <running_thread>
c00041ed:	a3 cc 42 01 c0       	mov    %eax,0xc00142cc
/work/x86_os_my/thread/thread.c:199
	init_thread(g_main_thread, "main", 31);
c00041f2:	a1 cc 42 01 c0       	mov    0xc00142cc,%eax
c00041f7:	83 ec 04             	sub    $0x4,%esp
c00041fa:	6a 1f                	push   $0x1f
c00041fc:	68 88 e2 00 c0       	push   $0xc000e288
c0004201:	50                   	push   %eax
c0004202:	e8 f6 fd ff ff       	call   c0003ffd <init_thread>
c0004207:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:203

	/* main函数是当前线程,当前线程不在thread_ready_list中,
	 * 所以只将其加在thread_all_list中. */
	ASSERT(!elem_find(&thread_all_list, &g_main_thread->all_list_tag));
c000420a:	a1 cc 42 01 c0       	mov    0xc00142cc,%eax
c000420f:	83 c0 4c             	add    $0x4c,%eax
c0004212:	83 ec 08             	sub    $0x8,%esp
c0004215:	50                   	push   %eax
c0004216:	68 b8 42 01 c0       	push   $0xc00142b8
c000421b:	e8 24 09 00 00       	call   c0004b44 <elem_find>
c0004220:	83 c4 10             	add    $0x10,%esp
c0004223:	85 c0                	test   %eax,%eax
c0004225:	74 1c                	je     c0004243 <make_main_thread+0x61>
/work/x86_os_my/thread/thread.c:203 (discriminator 1)
c0004227:	68 90 e2 00 c0       	push   $0xc000e290
c000422c:	68 7c e5 00 c0       	push   $0xc000e57c
c0004231:	68 cb 00 00 00       	push   $0xcb
c0004236:	68 41 e2 00 c0       	push   $0xc000e241
c000423b:	e8 21 e3 ff ff       	call   c0002561 <panic_spin>
c0004240:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:204
	list_append(&thread_all_list, &g_main_thread->all_list_tag);
c0004243:	a1 cc 42 01 c0       	mov    0xc00142cc,%eax
c0004248:	83 c0 4c             	add    $0x4c,%eax
c000424b:	83 ec 08             	sub    $0x8,%esp
c000424e:	50                   	push   %eax
c000424f:	68 b8 42 01 c0       	push   $0xc00142b8
c0004254:	e8 71 08 00 00       	call   c0004aca <list_append>
c0004259:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:205
}
c000425c:	90                   	nop
c000425d:	c9                   	leave  
c000425e:	c3                   	ret    

c000425f <schedule>:
schedule():
/work/x86_os_my/thread/thread.c:215
（2）调度器 schedule。
（3）任务切换函数 switch_to。
*/
/* 实现任务调度 */
void schedule()
{
c000425f:	55                   	push   %ebp
c0004260:	89 e5                	mov    %esp,%ebp
c0004262:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:216
	ASSERT(intr_get_status() == INTR_OFF);
c0004265:	e8 62 d9 ff ff       	call   c0001bcc <intr_get_status>
c000426a:	85 c0                	test   %eax,%eax
c000426c:	74 1c                	je     c000428a <schedule+0x2b>
/work/x86_os_my/thread/thread.c:216 (discriminator 1)
c000426e:	68 cb e2 00 c0       	push   $0xc000e2cb
c0004273:	68 90 e5 00 c0       	push   $0xc000e590
c0004278:	68 d8 00 00 00       	push   $0xd8
c000427d:	68 41 e2 00 c0       	push   $0xc000e241
c0004282:	e8 da e2 ff ff       	call   c0002561 <panic_spin>
c0004287:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:219

	/* 换下 */
	struct task_struct* cur = running_thread(); 
c000428a:	e8 bd fb ff ff       	call   c0003e4c <running_thread>
c000428f:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:220
	if (cur->status == TASK_RUNNING) { // 若此线程只是cpu时间片到了,将其加入到就绪队列尾
c0004292:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004295:	8b 40 08             	mov    0x8(%eax),%eax
c0004298:	85 c0                	test   %eax,%eax
c000429a:	75 65                	jne    c0004301 <schedule+0xa2>
/work/x86_os_my/thread/thread.c:221
		ASSERT(!elem_find(&thread_ready_list, &cur->general_tag));
c000429c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000429f:	83 c0 44             	add    $0x44,%eax
c00042a2:	83 ec 08             	sub    $0x8,%esp
c00042a5:	50                   	push   %eax
c00042a6:	68 a8 42 01 c0       	push   $0xc00142a8
c00042ab:	e8 94 08 00 00       	call   c0004b44 <elem_find>
c00042b0:	83 c4 10             	add    $0x10,%esp
c00042b3:	85 c0                	test   %eax,%eax
c00042b5:	74 1c                	je     c00042d3 <schedule+0x74>
/work/x86_os_my/thread/thread.c:221 (discriminator 1)
c00042b7:	68 ec e2 00 c0       	push   $0xc000e2ec
c00042bc:	68 90 e5 00 c0       	push   $0xc000e590
c00042c1:	68 dd 00 00 00       	push   $0xdd
c00042c6:	68 41 e2 00 c0       	push   $0xc000e241
c00042cb:	e8 91 e2 ff ff       	call   c0002561 <panic_spin>
c00042d0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:222
		list_append(&thread_ready_list, &cur->general_tag);
c00042d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00042d6:	83 c0 44             	add    $0x44,%eax
c00042d9:	83 ec 08             	sub    $0x8,%esp
c00042dc:	50                   	push   %eax
c00042dd:	68 a8 42 01 c0       	push   $0xc00142a8
c00042e2:	e8 e3 07 00 00       	call   c0004aca <list_append>
c00042e7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:223
		cur->ticks = cur->priority;     // 重新将当前线程的ticks再重置为其priority;
c00042ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00042ed:	0f b6 50 1c          	movzbl 0x1c(%eax),%edx
c00042f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00042f4:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/thread/thread.c:224
		cur->status = TASK_READY;
c00042f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00042fa:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:231
		/* 若此线程需要某事件发生后才能继续上cpu运行,
		不需要将其加入队列,因为当前线程不在就绪队列中。*/
	}

	/* 如果就绪队列中没有可运行的任务,就唤醒idle */
	if (list_empty(&thread_ready_list)) {
c0004301:	83 ec 0c             	sub    $0xc,%esp
c0004304:	68 a8 42 01 c0       	push   $0xc00142a8
c0004309:	e8 03 09 00 00       	call   c0004c11 <list_empty>
c000430e:	83 c4 10             	add    $0x10,%esp
c0004311:	85 c0                	test   %eax,%eax
c0004313:	74 11                	je     c0004326 <schedule+0xc7>
/work/x86_os_my/thread/thread.c:232
		thread_unblock(idle_thread);
c0004315:	a1 c8 42 01 c0       	mov    0xc00142c8,%eax
c000431a:	83 ec 0c             	sub    $0xc,%esp
c000431d:	50                   	push   %eax
c000431e:	e8 ec 00 00 00       	call   c000440f <thread_unblock>
c0004323:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:236
	}
	
	/* 换上 */
	ASSERT(!list_empty(&thread_ready_list));
c0004326:	83 ec 0c             	sub    $0xc,%esp
c0004329:	68 a8 42 01 c0       	push   $0xc00142a8
c000432e:	e8 de 08 00 00       	call   c0004c11 <list_empty>
c0004333:	83 c4 10             	add    $0x10,%esp
c0004336:	85 c0                	test   %eax,%eax
c0004338:	74 1c                	je     c0004356 <schedule+0xf7>
/work/x86_os_my/thread/thread.c:236 (discriminator 1)
c000433a:	68 20 e3 00 c0       	push   $0xc000e320
c000433f:	68 90 e5 00 c0       	push   $0xc000e590
c0004344:	68 ec 00 00 00       	push   $0xec
c0004349:	68 41 e2 00 c0       	push   $0xc000e241
c000434e:	e8 0e e2 ff ff       	call   c0002561 <panic_spin>
c0004353:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:237
	g_thread_tag = NULL;	  // g_thread_tag清空
c0004356:	c7 05 00 36 01 c0 00 	movl   $0x0,0xc0013600
c000435d:	00 00 00 
/work/x86_os_my/thread/thread.c:239
	/* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */
	g_thread_tag = list_pop(&thread_ready_list);   
c0004360:	83 ec 0c             	sub    $0xc,%esp
c0004363:	68 a8 42 01 c0       	push   $0xc00142a8
c0004368:	e8 b5 07 00 00       	call   c0004b22 <list_pop>
c000436d:	83 c4 10             	add    $0x10,%esp
c0004370:	a3 00 36 01 c0       	mov    %eax,0xc0013600
/work/x86_os_my/thread/thread.c:240
	struct task_struct* next = elem2entry(struct task_struct, general_tag, g_thread_tag);
c0004375:	a1 00 36 01 c0       	mov    0xc0013600,%eax
c000437a:	83 e8 44             	sub    $0x44,%eax
c000437d:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:241
	next->status = TASK_RUNNING;
c0004380:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0004383:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/thread/thread.c:245
	
	/* 1.激活线程或进程的页表,【更新CR3寄存器】
	 * 2.用户进程，更新tss中的esp0为进程的特权级0的栈 */
	process_activate(next);
c000438a:	83 ec 0c             	sub    $0xc,%esp
c000438d:	ff 75 f0             	pushl  -0x10(%ebp)
c0004390:	e8 bc 15 00 00       	call   c0005951 <process_activate>
c0004395:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:247

	switch_to(cur, next);
c0004398:	83 ec 08             	sub    $0x8,%esp
c000439b:	ff 75 f0             	pushl  -0x10(%ebp)
c000439e:	ff 75 f4             	pushl  -0xc(%ebp)
c00043a1:	e8 8a 08 00 00       	call   c0004c30 <switch_to>
c00043a6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:248
}
c00043a9:	90                   	nop
c00043aa:	c9                   	leave  
c00043ab:	c3                   	ret    

c00043ac <thread_block>:
thread_block():
/work/x86_os_my/thread/thread.c:251

/* 当前线程将自己阻塞,标志其状态为stat. */
void thread_block(enum task_status stat) {
c00043ac:	55                   	push   %ebp
c00043ad:	89 e5                	mov    %esp,%ebp
c00043af:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:253
	/* stat取值为TASK_BLOCKED,TASK_WAITING,TASK_HANGING,也就是只有这三种状态才不会被调度*/
	ASSERT(((stat == TASK_BLOCKED) || (stat == TASK_WAITING) || (stat == TASK_HANGING)));
c00043b2:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c00043b6:	74 28                	je     c00043e0 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:253 (discriminator 1)
c00043b8:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c00043bc:	74 22                	je     c00043e0 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:253 (discriminator 2)
c00043be:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
c00043c2:	74 1c                	je     c00043e0 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:253 (discriminator 3)
c00043c4:	68 40 e3 00 c0       	push   $0xc000e340
c00043c9:	68 9c e5 00 c0       	push   $0xc000e59c
c00043ce:	68 fd 00 00 00       	push   $0xfd
c00043d3:	68 41 e2 00 c0       	push   $0xc000e241
c00043d8:	e8 84 e1 ff ff       	call   c0002561 <panic_spin>
c00043dd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:254
	enum intr_status old_status = intr_disable();
c00043e0:	e8 a0 d7 ff ff       	call   c0001b85 <intr_disable>
c00043e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:256
	
	struct task_struct* cur_thread = running_thread();
c00043e8:	e8 5f fa ff ff       	call   c0003e4c <running_thread>
c00043ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:257
	cur_thread->status = stat;
c00043f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00043f3:	8b 55 08             	mov    0x8(%ebp),%edx
c00043f6:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/thread/thread.c:258
	schedule();
c00043f9:	e8 61 fe ff ff       	call   c000425f <schedule>
/work/x86_os_my/thread/thread.c:261
	
	/* 待当前线程被解除阻塞后才继续运行下面的intr_set_status */
	intr_set_status(old_status);
c00043fe:	83 ec 0c             	sub    $0xc,%esp
c0004401:	ff 75 f4             	pushl  -0xc(%ebp)
c0004404:	e8 a5 d7 ff ff       	call   c0001bae <intr_set_status>
c0004409:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:262
}
c000440c:	90                   	nop
c000440d:	c9                   	leave  
c000440e:	c3                   	ret    

c000440f <thread_unblock>:
thread_unblock():
/work/x86_os_my/thread/thread.c:265

/* 将线程pthread解除阻塞 */
void thread_unblock(struct task_struct* pthread) {
c000440f:	55                   	push   %ebp
c0004410:	89 e5                	mov    %esp,%ebp
c0004412:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:266
	enum intr_status old_status = intr_disable();
c0004415:	e8 6b d7 ff ff       	call   c0001b85 <intr_disable>
c000441a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:267
	ASSERT(((pthread->status == TASK_BLOCKED) || (pthread->status == TASK_WAITING) || (pthread->status == TASK_HANGING)));
c000441d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004420:	8b 40 08             	mov    0x8(%eax),%eax
c0004423:	83 f8 02             	cmp    $0x2,%eax
c0004426:	74 32                	je     c000445a <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:267 (discriminator 1)
c0004428:	8b 45 08             	mov    0x8(%ebp),%eax
c000442b:	8b 40 08             	mov    0x8(%eax),%eax
c000442e:	83 f8 03             	cmp    $0x3,%eax
c0004431:	74 27                	je     c000445a <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:267 (discriminator 2)
c0004433:	8b 45 08             	mov    0x8(%ebp),%eax
c0004436:	8b 40 08             	mov    0x8(%eax),%eax
c0004439:	83 f8 04             	cmp    $0x4,%eax
c000443c:	74 1c                	je     c000445a <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:267 (discriminator 3)
c000443e:	68 90 e3 00 c0       	push   $0xc000e390
c0004443:	68 ac e5 00 c0       	push   $0xc000e5ac
c0004448:	68 0b 01 00 00       	push   $0x10b
c000444d:	68 41 e2 00 c0       	push   $0xc000e241
c0004452:	e8 0a e1 ff ff       	call   c0002561 <panic_spin>
c0004457:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:269
	
	if (pthread->status != TASK_READY) {
c000445a:	8b 45 08             	mov    0x8(%ebp),%eax
c000445d:	8b 40 08             	mov    0x8(%eax),%eax
c0004460:	83 f8 01             	cmp    $0x1,%eax
c0004463:	0f 84 8f 00 00 00    	je     c00044f8 <thread_unblock+0xe9>
/work/x86_os_my/thread/thread.c:270
		ASSERT(!elem_find(&thread_ready_list, &pthread->general_tag));
c0004469:	8b 45 08             	mov    0x8(%ebp),%eax
c000446c:	83 c0 44             	add    $0x44,%eax
c000446f:	83 ec 08             	sub    $0x8,%esp
c0004472:	50                   	push   %eax
c0004473:	68 a8 42 01 c0       	push   $0xc00142a8
c0004478:	e8 c7 06 00 00       	call   c0004b44 <elem_find>
c000447d:	83 c4 10             	add    $0x10,%esp
c0004480:	85 c0                	test   %eax,%eax
c0004482:	74 1c                	je     c00044a0 <thread_unblock+0x91>
/work/x86_os_my/thread/thread.c:270 (discriminator 1)
c0004484:	68 00 e4 00 c0       	push   $0xc000e400
c0004489:	68 ac e5 00 c0       	push   $0xc000e5ac
c000448e:	68 0e 01 00 00       	push   $0x10e
c0004493:	68 41 e2 00 c0       	push   $0xc000e241
c0004498:	e8 c4 e0 ff ff       	call   c0002561 <panic_spin>
c000449d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:271
		if (elem_find(&thread_ready_list, &pthread->general_tag)) {
c00044a0:	8b 45 08             	mov    0x8(%ebp),%eax
c00044a3:	83 c0 44             	add    $0x44,%eax
c00044a6:	83 ec 08             	sub    $0x8,%esp
c00044a9:	50                   	push   %eax
c00044aa:	68 a8 42 01 c0       	push   $0xc00142a8
c00044af:	e8 90 06 00 00       	call   c0004b44 <elem_find>
c00044b4:	83 c4 10             	add    $0x10,%esp
c00044b7:	85 c0                	test   %eax,%eax
c00044b9:	74 1c                	je     c00044d7 <thread_unblock+0xc8>
/work/x86_os_my/thread/thread.c:272
			PANIC("thread_unblock: blocked thread in ready_list\n");
c00044bb:	68 38 e4 00 c0       	push   $0xc000e438
c00044c0:	68 ac e5 00 c0       	push   $0xc000e5ac
c00044c5:	68 10 01 00 00       	push   $0x110
c00044ca:	68 41 e2 00 c0       	push   $0xc000e241
c00044cf:	e8 8d e0 ff ff       	call   c0002561 <panic_spin>
c00044d4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:274
		}
		list_push(&thread_ready_list, &pthread->general_tag);	// 放到队列的最前面,使其尽快得到调度
c00044d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00044da:	83 c0 44             	add    $0x44,%eax
c00044dd:	83 ec 08             	sub    $0x8,%esp
c00044e0:	50                   	push   %eax
c00044e1:	68 a8 42 01 c0       	push   $0xc00142a8
c00044e6:	e8 c1 05 00 00       	call   c0004aac <list_push>
c00044eb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:275
		pthread->status = TASK_READY;
c00044ee:	8b 45 08             	mov    0x8(%ebp),%eax
c00044f1:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:278
	}
	
	intr_set_status(old_status);
c00044f8:	83 ec 0c             	sub    $0xc,%esp
c00044fb:	ff 75 f4             	pushl  -0xc(%ebp)
c00044fe:	e8 ab d6 ff ff       	call   c0001bae <intr_set_status>
c0004503:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:279
}
c0004506:	90                   	nop
c0004507:	c9                   	leave  
c0004508:	c3                   	ret    

c0004509 <thread_yield>:
thread_yield():
/work/x86_os_my/thread/thread.c:282

/* 主动让出cpu，换其它线程运行，但状态仍是ready */
void thread_yield(void) {
c0004509:	55                   	push   %ebp
c000450a:	89 e5                	mov    %esp,%ebp
c000450c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:283
	struct task_struct* cur = running_thread();
c000450f:	e8 38 f9 ff ff       	call   c0003e4c <running_thread>
c0004514:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:284
	enum intr_status old_status = intr_disable();
c0004517:	e8 69 d6 ff ff       	call   c0001b85 <intr_disable>
c000451c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:285
	ASSERT(!elem_find(&thread_ready_list, &cur->general_tag));
c000451f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004522:	83 c0 44             	add    $0x44,%eax
c0004525:	83 ec 08             	sub    $0x8,%esp
c0004528:	50                   	push   %eax
c0004529:	68 a8 42 01 c0       	push   $0xc00142a8
c000452e:	e8 11 06 00 00       	call   c0004b44 <elem_find>
c0004533:	83 c4 10             	add    $0x10,%esp
c0004536:	85 c0                	test   %eax,%eax
c0004538:	74 1c                	je     c0004556 <thread_yield+0x4d>
/work/x86_os_my/thread/thread.c:285 (discriminator 1)
c000453a:	68 ec e2 00 c0       	push   $0xc000e2ec
c000453f:	68 bc e5 00 c0       	push   $0xc000e5bc
c0004544:	68 1d 01 00 00       	push   $0x11d
c0004549:	68 41 e2 00 c0       	push   $0xc000e241
c000454e:	e8 0e e0 ff ff       	call   c0002561 <panic_spin>
c0004553:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:286
	list_append(&thread_ready_list, &cur->general_tag);
c0004556:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004559:	83 c0 44             	add    $0x44,%eax
c000455c:	83 ec 08             	sub    $0x8,%esp
c000455f:	50                   	push   %eax
c0004560:	68 a8 42 01 c0       	push   $0xc00142a8
c0004565:	e8 60 05 00 00       	call   c0004aca <list_append>
c000456a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:287
	cur->status = TASK_READY;
c000456d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004570:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:288
	schedule();
c0004577:	e8 e3 fc ff ff       	call   c000425f <schedule>
/work/x86_os_my/thread/thread.c:289
	intr_set_status(old_status);
c000457c:	83 ec 0c             	sub    $0xc,%esp
c000457f:	ff 75 f0             	pushl  -0x10(%ebp)
c0004582:	e8 27 d6 ff ff       	call   c0001bae <intr_set_status>
c0004587:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:290
}
c000458a:	90                   	nop
c000458b:	c9                   	leave  
c000458c:	c3                   	ret    

c000458d <pad_print>:
pad_print():
/work/x86_os_my/thread/thread.c:294


/* 前边填充空格 后边按format格式输出ptr的内容 输出的总长度都是buf_len个字符 */
static void pad_print(char* buf, int32_t buf_len, void* ptr, char format) {
c000458d:	55                   	push   %ebp
c000458e:	89 e5                	mov    %esp,%ebp
c0004590:	83 ec 28             	sub    $0x28,%esp
c0004593:	8b 45 14             	mov    0x14(%ebp),%eax
c0004596:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/thread/thread.c:295
	memset(buf, 0, buf_len);
c0004599:	8b 45 0c             	mov    0xc(%ebp),%eax
c000459c:	83 ec 04             	sub    $0x4,%esp
c000459f:	50                   	push   %eax
c00045a0:	6a 00                	push   $0x0
c00045a2:	ff 75 08             	pushl  0x8(%ebp)
c00045a5:	e8 bb f4 ff ff       	call   c0003a65 <memset>
c00045aa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:296
	uint8_t out_pad_0idx = 0;
c00045ad:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/thread/thread.c:297
	switch(format) {
c00045b1:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
c00045b5:	83 f8 73             	cmp    $0x73,%eax
c00045b8:	74 0c                	je     c00045c6 <pad_print+0x39>
c00045ba:	83 f8 78             	cmp    $0x78,%eax
c00045bd:	74 40                	je     c00045ff <pad_print+0x72>
c00045bf:	83 f8 64             	cmp    $0x64,%eax
c00045c2:	74 1d                	je     c00045e1 <pad_print+0x54>
c00045c4:	eb 55                	jmp    c000461b <pad_print+0x8e>
/work/x86_os_my/thread/thread.c:299
		case 's':
		out_pad_0idx = sprintf(buf, "%s", ptr);
c00045c6:	83 ec 04             	sub    $0x4,%esp
c00045c9:	ff 75 10             	pushl  0x10(%ebp)
c00045cc:	68 66 e4 00 c0       	push   $0xc000e466
c00045d1:	ff 75 08             	pushl  0x8(%ebp)
c00045d4:	e8 4c 1c 00 00       	call   c0006225 <sprintf>
c00045d9:	83 c4 10             	add    $0x10,%esp
c00045dc:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/thread/thread.c:300
		break;
c00045df:	eb 3a                	jmp    c000461b <pad_print+0x8e>
/work/x86_os_my/thread/thread.c:302
		case 'd':
		out_pad_0idx = sprintf(buf, "%d", *((int16_t*)ptr));
c00045e1:	8b 45 10             	mov    0x10(%ebp),%eax
c00045e4:	0f b7 00             	movzwl (%eax),%eax
c00045e7:	98                   	cwtl   
c00045e8:	83 ec 04             	sub    $0x4,%esp
c00045eb:	50                   	push   %eax
c00045ec:	68 69 e4 00 c0       	push   $0xc000e469
c00045f1:	ff 75 08             	pushl  0x8(%ebp)
c00045f4:	e8 2c 1c 00 00       	call   c0006225 <sprintf>
c00045f9:	83 c4 10             	add    $0x10,%esp
c00045fc:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/thread/thread.c:304
		case 'x':
		out_pad_0idx = sprintf(buf, "%x", *((uint32_t*)ptr));
c00045ff:	8b 45 10             	mov    0x10(%ebp),%eax
c0004602:	8b 00                	mov    (%eax),%eax
c0004604:	83 ec 04             	sub    $0x4,%esp
c0004607:	50                   	push   %eax
c0004608:	68 6c e4 00 c0       	push   $0xc000e46c
c000460d:	ff 75 08             	pushl  0x8(%ebp)
c0004610:	e8 10 1c 00 00       	call   c0006225 <sprintf>
c0004615:	83 c4 10             	add    $0x10,%esp
c0004618:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/thread/thread.c:306
	}
	while(out_pad_0idx < buf_len) { // 以空格填充
c000461b:	eb 16                	jmp    c0004633 <pad_print+0xa6>
/work/x86_os_my/thread/thread.c:307
		buf[out_pad_0idx] = ' ';
c000461d:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0004621:	8b 45 08             	mov    0x8(%ebp),%eax
c0004624:	01 d0                	add    %edx,%eax
c0004626:	c6 00 20             	movb   $0x20,(%eax)
/work/x86_os_my/thread/thread.c:308
		out_pad_0idx++;
c0004629:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000462d:	83 c0 01             	add    $0x1,%eax
c0004630:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/thread/thread.c:306
		case 'd':
		out_pad_0idx = sprintf(buf, "%d", *((int16_t*)ptr));
		case 'x':
		out_pad_0idx = sprintf(buf, "%x", *((uint32_t*)ptr));
	}
	while(out_pad_0idx < buf_len) { // 以空格填充
c0004633:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0004637:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000463a:	7c e1                	jl     c000461d <pad_print+0x90>
/work/x86_os_my/thread/thread.c:310
		buf[out_pad_0idx] = ' ';
		out_pad_0idx++;
	}
	sys_write(stdout_no, buf, buf_len - 1);
c000463c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000463f:	83 e8 01             	sub    $0x1,%eax
c0004642:	83 ec 04             	sub    $0x4,%esp
c0004645:	50                   	push   %eax
c0004646:	ff 75 08             	pushl  0x8(%ebp)
c0004649:	6a 01                	push   $0x1
c000464b:	e8 c2 37 00 00       	call   c0007e12 <sys_write>
c0004650:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:311
}
c0004653:	90                   	nop
c0004654:	c9                   	leave  
c0004655:	c3                   	ret    

c0004656 <elem2thread_info>:
elem2thread_info():
/work/x86_os_my/thread/thread.c:314

/* 用于在list_traversal函数中的回调函数,用于针对线程队列的处理 */
static bool elem2thread_info(struct list_elem* pelem, int arg UNUSED) {
c0004656:	55                   	push   %ebp
c0004657:	89 e5                	mov    %esp,%ebp
c0004659:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/thread/thread.c:315
	struct task_struct* pthread = elem2entry(struct task_struct, all_list_tag, pelem);
c000465c:	8b 45 08             	mov    0x8(%ebp),%eax
c000465f:	83 e8 4c             	sub    $0x4c,%eax
c0004662:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:316
	char out_pad[16] = {0};
c0004665:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c000466c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c0004673:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c000467a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:318

	pad_print(out_pad, 16, &pthread->pid, 'd');
c0004681:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004684:	83 c0 04             	add    $0x4,%eax
c0004687:	6a 64                	push   $0x64
c0004689:	50                   	push   %eax
c000468a:	6a 10                	push   $0x10
c000468c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c000468f:	50                   	push   %eax
c0004690:	e8 f8 fe ff ff       	call   c000458d <pad_print>
c0004695:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:320

	if (pthread->parent_pid == -1) {
c0004698:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000469b:	0f b7 80 10 01 00 00 	movzwl 0x110(%eax),%eax
c00046a2:	66 83 f8 ff          	cmp    $0xffff,%ax
c00046a6:	75 17                	jne    c00046bf <elem2thread_info+0x69>
/work/x86_os_my/thread/thread.c:321
		pad_print(out_pad, 16, "NULL", 's');
c00046a8:	6a 73                	push   $0x73
c00046aa:	68 6f e4 00 c0       	push   $0xc000e46f
c00046af:	6a 10                	push   $0x10
c00046b1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c00046b4:	50                   	push   %eax
c00046b5:	e8 d3 fe ff ff       	call   c000458d <pad_print>
c00046ba:	83 c4 10             	add    $0x10,%esp
c00046bd:	eb 19                	jmp    c00046d8 <elem2thread_info+0x82>
/work/x86_os_my/thread/thread.c:323
	} else {
		pad_print(out_pad, 16, &pthread->parent_pid, 'd');
c00046bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00046c2:	05 10 01 00 00       	add    $0x110,%eax
c00046c7:	6a 64                	push   $0x64
c00046c9:	50                   	push   %eax
c00046ca:	6a 10                	push   $0x10
c00046cc:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c00046cf:	50                   	push   %eax
c00046d0:	e8 b8 fe ff ff       	call   c000458d <pad_print>
c00046d5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:326
	}

	switch (pthread->status) {
c00046d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00046db:	8b 40 08             	mov    0x8(%eax),%eax
c00046de:	83 f8 05             	cmp    $0x5,%eax
c00046e1:	0f 87 91 00 00 00    	ja     c0004778 <elem2thread_info+0x122>
c00046e7:	8b 04 85 bc e4 00 c0 	mov    -0x3fff1b44(,%eax,4),%eax
c00046ee:	ff e0                	jmp    *%eax
/work/x86_os_my/thread/thread.c:328
		case 0:
		pad_print(out_pad, 16, "RUNNING", 's');
c00046f0:	6a 73                	push   $0x73
c00046f2:	68 74 e4 00 c0       	push   $0xc000e474
c00046f7:	6a 10                	push   $0x10
c00046f9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c00046fc:	50                   	push   %eax
c00046fd:	e8 8b fe ff ff       	call   c000458d <pad_print>
c0004702:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:329
		break;
c0004705:	eb 71                	jmp    c0004778 <elem2thread_info+0x122>
/work/x86_os_my/thread/thread.c:331
		case 1:
		pad_print(out_pad, 16, "READY", 's');
c0004707:	6a 73                	push   $0x73
c0004709:	68 7c e4 00 c0       	push   $0xc000e47c
c000470e:	6a 10                	push   $0x10
c0004710:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0004713:	50                   	push   %eax
c0004714:	e8 74 fe ff ff       	call   c000458d <pad_print>
c0004719:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:332
		break;
c000471c:	eb 5a                	jmp    c0004778 <elem2thread_info+0x122>
/work/x86_os_my/thread/thread.c:334
		case 2:
		pad_print(out_pad, 16, "BLOCKED", 's');
c000471e:	6a 73                	push   $0x73
c0004720:	68 82 e4 00 c0       	push   $0xc000e482
c0004725:	6a 10                	push   $0x10
c0004727:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c000472a:	50                   	push   %eax
c000472b:	e8 5d fe ff ff       	call   c000458d <pad_print>
c0004730:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:335
		break;
c0004733:	eb 43                	jmp    c0004778 <elem2thread_info+0x122>
/work/x86_os_my/thread/thread.c:337
		case 3:
		pad_print(out_pad, 16, "WAITING", 's');
c0004735:	6a 73                	push   $0x73
c0004737:	68 8a e4 00 c0       	push   $0xc000e48a
c000473c:	6a 10                	push   $0x10
c000473e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0004741:	50                   	push   %eax
c0004742:	e8 46 fe ff ff       	call   c000458d <pad_print>
c0004747:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:338
		break;
c000474a:	eb 2c                	jmp    c0004778 <elem2thread_info+0x122>
/work/x86_os_my/thread/thread.c:340
		case 4:
		pad_print(out_pad, 16, "HANGING", 's');
c000474c:	6a 73                	push   $0x73
c000474e:	68 92 e4 00 c0       	push   $0xc000e492
c0004753:	6a 10                	push   $0x10
c0004755:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0004758:	50                   	push   %eax
c0004759:	e8 2f fe ff ff       	call   c000458d <pad_print>
c000475e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:341
		break;
c0004761:	eb 15                	jmp    c0004778 <elem2thread_info+0x122>
/work/x86_os_my/thread/thread.c:343
		case 5:
		pad_print(out_pad, 16, "DIED", 's');
c0004763:	6a 73                	push   $0x73
c0004765:	68 9a e4 00 c0       	push   $0xc000e49a
c000476a:	6a 10                	push   $0x10
c000476c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c000476f:	50                   	push   %eax
c0004770:	e8 18 fe ff ff       	call   c000458d <pad_print>
c0004775:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:345
	}
	pad_print(out_pad, 16, &pthread->elapsed_ticks, 'x');
c0004778:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000477b:	83 c0 20             	add    $0x20,%eax
c000477e:	6a 78                	push   $0x78
c0004780:	50                   	push   %eax
c0004781:	6a 10                	push   $0x10
c0004783:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0004786:	50                   	push   %eax
c0004787:	e8 01 fe ff ff       	call   c000458d <pad_print>
c000478c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:347

	memset(out_pad, 0, 16);
c000478f:	83 ec 04             	sub    $0x4,%esp
c0004792:	6a 10                	push   $0x10
c0004794:	6a 00                	push   $0x0
c0004796:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c0004799:	50                   	push   %eax
c000479a:	e8 c6 f2 ff ff       	call   c0003a65 <memset>
c000479f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:348
	ASSERT(strlen(pthread->name) < 17);
c00047a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00047a5:	83 c0 0c             	add    $0xc,%eax
c00047a8:	83 ec 0c             	sub    $0xc,%esp
c00047ab:	50                   	push   %eax
c00047ac:	e8 3e f4 ff ff       	call   c0003bef <strlen>
c00047b1:	83 c4 10             	add    $0x10,%esp
c00047b4:	83 f8 10             	cmp    $0x10,%eax
c00047b7:	76 1c                	jbe    c00047d5 <elem2thread_info+0x17f>
/work/x86_os_my/thread/thread.c:348 (discriminator 1)
c00047b9:	68 9f e4 00 c0       	push   $0xc000e49f
c00047be:	68 cc e5 00 c0       	push   $0xc000e5cc
c00047c3:	68 5c 01 00 00       	push   $0x15c
c00047c8:	68 41 e2 00 c0       	push   $0xc000e241
c00047cd:	e8 8f dd ff ff       	call   c0002561 <panic_spin>
c00047d2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:349
	memcpy(out_pad, pthread->name, strlen(pthread->name));
c00047d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00047d8:	83 c0 0c             	add    $0xc,%eax
c00047db:	83 ec 0c             	sub    $0xc,%esp
c00047de:	50                   	push   %eax
c00047df:	e8 0b f4 ff ff       	call   c0003bef <strlen>
c00047e4:	83 c4 10             	add    $0x10,%esp
c00047e7:	89 c2                	mov    %eax,%edx
c00047e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00047ec:	83 c0 0c             	add    $0xc,%eax
c00047ef:	83 ec 04             	sub    $0x4,%esp
c00047f2:	52                   	push   %edx
c00047f3:	50                   	push   %eax
c00047f4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c00047f7:	50                   	push   %eax
c00047f8:	e8 ba f2 ff ff       	call   c0003ab7 <memcpy>
c00047fd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:350
	strcat(out_pad, "\n");
c0004800:	83 ec 08             	sub    $0x8,%esp
c0004803:	68 ba e4 00 c0       	push   $0xc000e4ba
c0004808:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c000480b:	50                   	push   %eax
c000480c:	e8 58 f5 ff ff       	call   c0003d69 <strcat>
c0004811:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:351
	sys_write(stdout_no, out_pad, strlen(out_pad));
c0004814:	83 ec 0c             	sub    $0xc,%esp
c0004817:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c000481a:	50                   	push   %eax
c000481b:	e8 cf f3 ff ff       	call   c0003bef <strlen>
c0004820:	83 c4 10             	add    $0x10,%esp
c0004823:	83 ec 04             	sub    $0x4,%esp
c0004826:	50                   	push   %eax
c0004827:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c000482a:	50                   	push   %eax
c000482b:	6a 01                	push   $0x1
c000482d:	e8 e0 35 00 00       	call   c0007e12 <sys_write>
c0004832:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:352
	return false;	// 此处返回false是为了迎合主调函数list_traversal,只有回调函数返回false时才会继续调用此函数
c0004835:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/thread/thread.c:353
}
c000483a:	c9                   	leave  
c000483b:	c3                   	ret    

c000483c <sys_ps>:
sys_ps():
/work/x86_os_my/thread/thread.c:356

/* 打印任务列表 */
void sys_ps(void) {
c000483c:	55                   	push   %ebp
c000483d:	89 e5                	mov    %esp,%ebp
c000483f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:358
	///////////////   |<--   15  -->||<--   15  -->||<--   15  -->||<--   15  -->||<-7->|
	char* ps_title = "PID            PPID           STAT           TICKS          COMMAND\n";
c0004842:	c7 45 f4 d4 e4 00 c0 	movl   $0xc000e4d4,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:359
	sys_write(stdout_no, ps_title, strlen(ps_title));
c0004849:	83 ec 0c             	sub    $0xc,%esp
c000484c:	ff 75 f4             	pushl  -0xc(%ebp)
c000484f:	e8 9b f3 ff ff       	call   c0003bef <strlen>
c0004854:	83 c4 10             	add    $0x10,%esp
c0004857:	83 ec 04             	sub    $0x4,%esp
c000485a:	50                   	push   %eax
c000485b:	ff 75 f4             	pushl  -0xc(%ebp)
c000485e:	6a 01                	push   $0x1
c0004860:	e8 ad 35 00 00       	call   c0007e12 <sys_write>
c0004865:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:360
	list_traversal(&thread_all_list, elem2thread_info, 0);
c0004868:	83 ec 04             	sub    $0x4,%esp
c000486b:	6a 00                	push   $0x0
c000486d:	68 56 46 00 c0       	push   $0xc0004656
c0004872:	68 b8 42 01 c0       	push   $0xc00142b8
c0004877:	e8 03 03 00 00       	call   c0004b7f <list_traversal>
c000487c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:361
}
c000487f:	90                   	nop
c0004880:	c9                   	leave  
c0004881:	c3                   	ret    

c0004882 <thread_exit>:
thread_exit():
/work/x86_os_my/thread/thread.c:364

/* 回收thread_over的pcb和页表,并将其从调度队列中去除 */
void thread_exit(struct task_struct* thread_over, bool need_schedule) {
c0004882:	55                   	push   %ebp
c0004883:	89 e5                	mov    %esp,%ebp
c0004885:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:366
	/* 要保证schedule在关中断情况下调用 */
	intr_disable();
c0004888:	e8 f8 d2 ff ff       	call   c0001b85 <intr_disable>
/work/x86_os_my/thread/thread.c:367
	thread_over->status = TASK_DIED;
c000488d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004890:	c7 40 08 05 00 00 00 	movl   $0x5,0x8(%eax)
/work/x86_os_my/thread/thread.c:370

	/* 如果thread_over不是当前线程,就有可能还在就绪队列中,将其从中删除 */
	if (elem_find(&thread_ready_list, &thread_over->general_tag)) {
c0004897:	8b 45 08             	mov    0x8(%ebp),%eax
c000489a:	83 c0 44             	add    $0x44,%eax
c000489d:	83 ec 08             	sub    $0x8,%esp
c00048a0:	50                   	push   %eax
c00048a1:	68 a8 42 01 c0       	push   $0xc00142a8
c00048a6:	e8 99 02 00 00       	call   c0004b44 <elem_find>
c00048ab:	83 c4 10             	add    $0x10,%esp
c00048ae:	85 c0                	test   %eax,%eax
c00048b0:	74 12                	je     c00048c4 <thread_exit+0x42>
/work/x86_os_my/thread/thread.c:371
		list_remove(&thread_over->general_tag);
c00048b2:	8b 45 08             	mov    0x8(%ebp),%eax
c00048b5:	83 c0 44             	add    $0x44,%eax
c00048b8:	83 ec 0c             	sub    $0xc,%esp
c00048bb:	50                   	push   %eax
c00048bc:	e8 27 02 00 00       	call   c0004ae8 <list_remove>
c00048c1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:373
	}
	if (thread_over->pgdir) {	// 如是进程,回收进程的页表【线程的pgdir、内核进程的pgdir都是NULL】
c00048c4:	8b 45 08             	mov    0x8(%ebp),%eax
c00048c7:	8b 40 54             	mov    0x54(%eax),%eax
c00048ca:	85 c0                	test   %eax,%eax
c00048cc:	74 16                	je     c00048e4 <thread_exit+0x62>
/work/x86_os_my/thread/thread.c:374
		mfree_page(PF_KERNEL, thread_over->pgdir, 1);
c00048ce:	8b 45 08             	mov    0x8(%ebp),%eax
c00048d1:	8b 40 54             	mov    0x54(%eax),%eax
c00048d4:	83 ec 04             	sub    $0x4,%esp
c00048d7:	6a 01                	push   $0x1
c00048d9:	50                   	push   %eax
c00048da:	6a 01                	push   $0x1
c00048dc:	e8 97 ea ff ff       	call   c0003378 <mfree_page>
c00048e1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:378
	}

	/* 从all_thread_list中去掉此任务 */
	list_remove(&thread_over->all_list_tag);
c00048e4:	8b 45 08             	mov    0x8(%ebp),%eax
c00048e7:	83 c0 4c             	add    $0x4c,%eax
c00048ea:	83 ec 0c             	sub    $0xc,%esp
c00048ed:	50                   	push   %eax
c00048ee:	e8 f5 01 00 00       	call   c0004ae8 <list_remove>
c00048f3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:381

	/* 回收pcb所在的页,主线程的pcb不在堆中,跨过 */
	if (thread_over != g_main_thread) {
c00048f6:	a1 cc 42 01 c0       	mov    0xc00142cc,%eax
c00048fb:	39 45 08             	cmp    %eax,0x8(%ebp)
c00048fe:	74 12                	je     c0004912 <thread_exit+0x90>
/work/x86_os_my/thread/thread.c:382
		mfree_page(PF_KERNEL, thread_over, 1);
c0004900:	83 ec 04             	sub    $0x4,%esp
c0004903:	6a 01                	push   $0x1
c0004905:	ff 75 08             	pushl  0x8(%ebp)
c0004908:	6a 01                	push   $0x1
c000490a:	e8 69 ea ff ff       	call   c0003378 <mfree_page>
c000490f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:386
	}

	/* 归还pid */
	release_pid(thread_over->pid);
c0004912:	8b 45 08             	mov    0x8(%ebp),%eax
c0004915:	0f b7 40 04          	movzwl 0x4(%eax),%eax
c0004919:	98                   	cwtl   
c000491a:	83 ec 0c             	sub    $0xc,%esp
c000491d:	50                   	push   %eax
c000491e:	e8 00 f6 ff ff       	call   c0003f23 <release_pid>
c0004923:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:389

	/* 如果需要下一轮调度则主动调用schedule */
	if (need_schedule) {
c0004926:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c000492a:	74 21                	je     c000494d <thread_exit+0xcb>
/work/x86_os_my/thread/thread.c:390
		schedule();
c000492c:	e8 2e f9 ff ff       	call   c000425f <schedule>
/work/x86_os_my/thread/thread.c:391
		PANIC("thread_exit: should not be here\n");
c0004931:	68 1c e5 00 c0       	push   $0xc000e51c
c0004936:	68 e0 e5 00 c0       	push   $0xc000e5e0
c000493b:	68 87 01 00 00       	push   $0x187
c0004940:	68 41 e2 00 c0       	push   $0xc000e241
c0004945:	e8 17 dc ff ff       	call   c0002561 <panic_spin>
c000494a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:393
	}
}
c000494d:	90                   	nop
c000494e:	c9                   	leave  
c000494f:	c3                   	ret    

c0004950 <pid_check>:
pid_check():
/work/x86_os_my/thread/thread.c:396

/* 比对任务的pid */
static bool pid_check(struct list_elem* pelem, int32_t pid) {
c0004950:	55                   	push   %ebp
c0004951:	89 e5                	mov    %esp,%ebp
c0004953:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:397
	struct task_struct* pthread = elem2entry(struct task_struct, all_list_tag, pelem);
c0004956:	8b 45 08             	mov    0x8(%ebp),%eax
c0004959:	83 e8 4c             	sub    $0x4c,%eax
c000495c:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:398
	if (pthread->pid == pid) {
c000495f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004962:	0f b7 40 04          	movzwl 0x4(%eax),%eax
c0004966:	98                   	cwtl   
c0004967:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000496a:	75 07                	jne    c0004973 <pid_check+0x23>
/work/x86_os_my/thread/thread.c:399
		return true;
c000496c:	b8 01 00 00 00       	mov    $0x1,%eax
c0004971:	eb 05                	jmp    c0004978 <pid_check+0x28>
/work/x86_os_my/thread/thread.c:401
	}
	return false;	//list_traversal继续遍历
c0004973:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/thread/thread.c:402
}
c0004978:	c9                   	leave  
c0004979:	c3                   	ret    

c000497a <pid2thread>:
pid2thread():
/work/x86_os_my/thread/thread.c:405

/* 根据pid找pcb,若找到则返回该pcb,否则返回NULL */
struct task_struct* pid2thread(int32_t pid) {
c000497a:	55                   	push   %ebp
c000497b:	89 e5                	mov    %esp,%ebp
c000497d:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:406
	struct list_elem* pelem = list_traversal(&thread_all_list, pid_check, pid);
c0004980:	83 ec 04             	sub    $0x4,%esp
c0004983:	ff 75 08             	pushl  0x8(%ebp)
c0004986:	68 50 49 00 c0       	push   $0xc0004950
c000498b:	68 b8 42 01 c0       	push   $0xc00142b8
c0004990:	e8 ea 01 00 00       	call   c0004b7f <list_traversal>
c0004995:	83 c4 10             	add    $0x10,%esp
c0004998:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:407
	if (pelem == NULL) {
c000499b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000499f:	75 07                	jne    c00049a8 <pid2thread+0x2e>
/work/x86_os_my/thread/thread.c:408
		return NULL;
c00049a1:	b8 00 00 00 00       	mov    $0x0,%eax
c00049a6:	eb 0c                	jmp    c00049b4 <pid2thread+0x3a>
/work/x86_os_my/thread/thread.c:410
	}
	struct task_struct* thread = elem2entry(struct task_struct, all_list_tag, pelem);
c00049a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00049ab:	83 e8 4c             	sub    $0x4c,%eax
c00049ae:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:411
	return thread;
c00049b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/thread/thread.c:412
}
c00049b4:	c9                   	leave  
c00049b5:	c3                   	ret    

c00049b6 <thread_init>:
thread_init():
/work/x86_os_my/thread/thread.c:416


/* 初始化线程环境 */
void thread_init(void) {
c00049b6:	55                   	push   %ebp
c00049b7:	89 e5                	mov    %esp,%ebp
c00049b9:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:417
	put_str("thread_init start\n");
c00049bc:	83 ec 0c             	sub    $0xc,%esp
c00049bf:	68 3d e5 00 c0       	push   $0xc000e53d
c00049c4:	e8 e7 d9 ff ff       	call   c00023b0 <put_str>
c00049c9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:418
	list_init(&thread_ready_list);
c00049cc:	83 ec 0c             	sub    $0xc,%esp
c00049cf:	68 a8 42 01 c0       	push   $0xc00142a8
c00049d4:	e8 60 00 00 00       	call   c0004a39 <list_init>
c00049d9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:419
	list_init(&thread_all_list);
c00049dc:	83 ec 0c             	sub    $0xc,%esp
c00049df:	68 b8 42 01 c0       	push   $0xc00142b8
c00049e4:	e8 50 00 00 00       	call   c0004a39 <list_init>
c00049e9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:420
	pid_pool_init();
c00049ec:	e8 8c f4 ff ff       	call   c0003e7d <pid_pool_init>
/work/x86_os_my/thread/thread.c:423

	/* 先创建第一个用户进程:init */
	process_execute(init, "init");	// 放在第一个初始化,这是第一个进程,init进程的pid为1
c00049f1:	83 ec 08             	sub    $0x8,%esp
c00049f4:	68 50 e5 00 c0       	push   $0xc000e550
c00049f9:	68 58 17 00 c0       	push   $0xc0001758
c00049fe:	e8 60 10 00 00       	call   c0005a63 <process_execute>
c0004a03:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:425
	/* 将当前main函数创建为线程 */
	make_main_thread();
c0004a06:	e8 d7 f7 ff ff       	call   c00041e2 <make_main_thread>
/work/x86_os_my/thread/thread.c:427
	/* 创建idle线程 */
	idle_thread = thread_start("idle", 10, idle, NULL);
c0004a0b:	6a 00                	push   $0x0
c0004a0d:	68 35 3e 00 c0       	push   $0xc0003e35
c0004a12:	6a 0a                	push   $0xa
c0004a14:	68 55 e5 00 c0       	push   $0xc000e555
c0004a19:	e8 e5 f6 ff ff       	call   c0004103 <thread_start>
c0004a1e:	83 c4 10             	add    $0x10,%esp
c0004a21:	a3 c8 42 01 c0       	mov    %eax,0xc00142c8
/work/x86_os_my/thread/thread.c:428
	put_str("thread_init done\n");
c0004a26:	83 ec 0c             	sub    $0xc,%esp
c0004a29:	68 5a e5 00 c0       	push   $0xc000e55a
c0004a2e:	e8 7d d9 ff ff       	call   c00023b0 <put_str>
c0004a33:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:429
}
c0004a36:	90                   	nop
c0004a37:	c9                   	leave  
c0004a38:	c3                   	ret    

c0004a39 <list_init>:
list_init():
/work/x86_os_my/lib/kernel/list.c:6
#include "list.h"
#include "interrupt.h"
/* 注意关中断的操作：临界区 */

/* 初始化双向链表list */
void list_init (struct list* list) {
c0004a39:	55                   	push   %ebp
c0004a3a:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/lib/kernel/list.c:7
	list->head.prev = NULL;
c0004a3c:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a3f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/lib/kernel/list.c:8
	list->head.next = &list->tail;
c0004a45:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a48:	8d 50 08             	lea    0x8(%eax),%edx
c0004a4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a4e:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:9
	list->tail.prev = &list->head;
c0004a51:	8b 55 08             	mov    0x8(%ebp),%edx
c0004a54:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a57:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/lib/kernel/list.c:10
	list->tail.next = NULL;
c0004a5a:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a5d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/lib/kernel/list.c:11
}
c0004a64:	90                   	nop
c0004a65:	5d                   	pop    %ebp
c0004a66:	c3                   	ret    

c0004a67 <list_insert_before>:
list_insert_before():
/work/x86_os_my/lib/kernel/list.c:14

/* 把链表元素elem插入在元素before之前 */
void list_insert_before(struct list_elem* before, struct list_elem* elem) { 
c0004a67:	55                   	push   %ebp
c0004a68:	89 e5                	mov    %esp,%ebp
c0004a6a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:15
	enum intr_status old_status = intr_disable();
c0004a6d:	e8 13 d1 ff ff       	call   c0001b85 <intr_disable>
c0004a72:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:18

	/* 将before前驱元素的后继元素更新为elem, 暂时使before脱离链表*/ 
	before->prev->next = elem; 
c0004a75:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a78:	8b 00                	mov    (%eax),%eax
c0004a7a:	8b 55 0c             	mov    0xc(%ebp),%edx
c0004a7d:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:22

	/* 更新elem自己的前驱结点为before的前驱,
	* 更新elem自己的后继结点为before, 于是before又回到链表 */
	elem->prev = before->prev;
c0004a80:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a83:	8b 10                	mov    (%eax),%edx
c0004a85:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004a88:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:23
	elem->next = before;
c0004a8a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004a8d:	8b 55 08             	mov    0x8(%ebp),%edx
c0004a90:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:26

	/* 更新before的前驱结点为elem */
	before->prev = elem;
c0004a93:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a96:	8b 55 0c             	mov    0xc(%ebp),%edx
c0004a99:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:28

	intr_set_status(old_status);
c0004a9b:	83 ec 0c             	sub    $0xc,%esp
c0004a9e:	ff 75 f4             	pushl  -0xc(%ebp)
c0004aa1:	e8 08 d1 ff ff       	call   c0001bae <intr_set_status>
c0004aa6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:29
}
c0004aa9:	90                   	nop
c0004aaa:	c9                   	leave  
c0004aab:	c3                   	ret    

c0004aac <list_push>:
list_push():
/work/x86_os_my/lib/kernel/list.c:32

/* 添加元素到列表队首,类似栈push操作 */
void list_push(struct list* plist, struct list_elem* elem) {
c0004aac:	55                   	push   %ebp
c0004aad:	89 e5                	mov    %esp,%ebp
c0004aaf:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/list.c:33
	list_insert_before(plist->head.next, elem); // 在队头插入elem
c0004ab2:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ab5:	8b 40 04             	mov    0x4(%eax),%eax
c0004ab8:	83 ec 08             	sub    $0x8,%esp
c0004abb:	ff 75 0c             	pushl  0xc(%ebp)
c0004abe:	50                   	push   %eax
c0004abf:	e8 a3 ff ff ff       	call   c0004a67 <list_insert_before>
c0004ac4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:34
}
c0004ac7:	90                   	nop
c0004ac8:	c9                   	leave  
c0004ac9:	c3                   	ret    

c0004aca <list_append>:
list_append():
/work/x86_os_my/lib/kernel/list.c:37

/* 追加元素到链表队尾,类似队列的先进先出操作 */
void list_append(struct list* plist, struct list_elem* elem) {
c0004aca:	55                   	push   %ebp
c0004acb:	89 e5                	mov    %esp,%ebp
c0004acd:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/list.c:38
	list_insert_before(&plist->tail, elem);     // 在队尾的前面插入
c0004ad0:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ad3:	83 c0 08             	add    $0x8,%eax
c0004ad6:	83 ec 08             	sub    $0x8,%esp
c0004ad9:	ff 75 0c             	pushl  0xc(%ebp)
c0004adc:	50                   	push   %eax
c0004add:	e8 85 ff ff ff       	call   c0004a67 <list_insert_before>
c0004ae2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:39
}
c0004ae5:	90                   	nop
c0004ae6:	c9                   	leave  
c0004ae7:	c3                   	ret    

c0004ae8 <list_remove>:
list_remove():
/work/x86_os_my/lib/kernel/list.c:42

/* 使元素pelem脱离链表 */
void list_remove(struct list_elem* pelem) {
c0004ae8:	55                   	push   %ebp
c0004ae9:	89 e5                	mov    %esp,%ebp
c0004aeb:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:43
	enum intr_status old_status = intr_disable();
c0004aee:	e8 92 d0 ff ff       	call   c0001b85 <intr_disable>
c0004af3:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:45

	pelem->prev->next = pelem->next;
c0004af6:	8b 45 08             	mov    0x8(%ebp),%eax
c0004af9:	8b 00                	mov    (%eax),%eax
c0004afb:	8b 55 08             	mov    0x8(%ebp),%edx
c0004afe:	8b 52 04             	mov    0x4(%edx),%edx
c0004b01:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:46
	pelem->next->prev = pelem->prev;
c0004b04:	8b 45 08             	mov    0x8(%ebp),%eax
c0004b07:	8b 40 04             	mov    0x4(%eax),%eax
c0004b0a:	8b 55 08             	mov    0x8(%ebp),%edx
c0004b0d:	8b 12                	mov    (%edx),%edx
c0004b0f:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:48

	intr_set_status(old_status);
c0004b11:	83 ec 0c             	sub    $0xc,%esp
c0004b14:	ff 75 f4             	pushl  -0xc(%ebp)
c0004b17:	e8 92 d0 ff ff       	call   c0001bae <intr_set_status>
c0004b1c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:49
}
c0004b1f:	90                   	nop
c0004b20:	c9                   	leave  
c0004b21:	c3                   	ret    

c0004b22 <list_pop>:
list_pop():
/work/x86_os_my/lib/kernel/list.c:52

/* 将链表第一个元素弹出并返回,类似栈的pop操作 */
struct list_elem* list_pop(struct list* plist) {
c0004b22:	55                   	push   %ebp
c0004b23:	89 e5                	mov    %esp,%ebp
c0004b25:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:53
	struct list_elem* elem = plist->head.next;
c0004b28:	8b 45 08             	mov    0x8(%ebp),%eax
c0004b2b:	8b 40 04             	mov    0x4(%eax),%eax
c0004b2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:54
	list_remove(elem);
c0004b31:	83 ec 0c             	sub    $0xc,%esp
c0004b34:	ff 75 f4             	pushl  -0xc(%ebp)
c0004b37:	e8 ac ff ff ff       	call   c0004ae8 <list_remove>
c0004b3c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:55
	return elem;
c0004b3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/kernel/list.c:56
} 
c0004b42:	c9                   	leave  
c0004b43:	c3                   	ret    

c0004b44 <elem_find>:
elem_find():
/work/x86_os_my/lib/kernel/list.c:59

/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */
bool elem_find(struct list* plist, struct list_elem* obj_elem) {
c0004b44:	55                   	push   %ebp
c0004b45:	89 e5                	mov    %esp,%ebp
c0004b47:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:60
	struct list_elem* elem = plist->head.next;
c0004b4a:	8b 45 08             	mov    0x8(%ebp),%eax
c0004b4d:	8b 40 04             	mov    0x4(%eax),%eax
c0004b50:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:61
	while (elem != &plist->tail) {
c0004b53:	eb 18                	jmp    c0004b6d <elem_find+0x29>
/work/x86_os_my/lib/kernel/list.c:62
	if (elem == obj_elem) {
c0004b55:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004b58:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0004b5b:	75 07                	jne    c0004b64 <elem_find+0x20>
/work/x86_os_my/lib/kernel/list.c:63
		return true;
c0004b5d:	b8 01 00 00 00       	mov    $0x1,%eax
c0004b62:	eb 19                	jmp    c0004b7d <elem_find+0x39>
/work/x86_os_my/lib/kernel/list.c:65
	}
		elem = elem->next;
c0004b64:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004b67:	8b 40 04             	mov    0x4(%eax),%eax
c0004b6a:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:61
} 

/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */
bool elem_find(struct list* plist, struct list_elem* obj_elem) {
	struct list_elem* elem = plist->head.next;
	while (elem != &plist->tail) {
c0004b6d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004b70:	83 c0 08             	add    $0x8,%eax
c0004b73:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c0004b76:	75 dd                	jne    c0004b55 <elem_find+0x11>
/work/x86_os_my/lib/kernel/list.c:67
	if (elem == obj_elem) {
		return true;
	}
		elem = elem->next;
	}
	return false;
c0004b78:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/kernel/list.c:68
}
c0004b7d:	c9                   	leave  
c0004b7e:	c3                   	ret    

c0004b7f <list_traversal>:
list_traversal():
/work/x86_os_my/lib/kernel/list.c:74

/* 把列表plist中的每个元素elem和arg传给回调函数func,
 * arg给func用来判断elem是否符合条件.
 * 本函数的功能是遍历列表内所有元素,逐个判断是否有符合条件的元素。
 * 找到符合条件的元素返回元素指针,否则返回NULL. */
struct list_elem* list_traversal(struct list* plist, function func, int arg) {
c0004b7f:	55                   	push   %ebp
c0004b80:	89 e5                	mov    %esp,%ebp
c0004b82:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:75
	struct list_elem* elem = plist->head.next;
c0004b85:	8b 45 08             	mov    0x8(%ebp),%eax
c0004b88:	8b 40 04             	mov    0x4(%eax),%eax
c0004b8b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:77
	/* 如果队列为空,就必然没有符合条件的结点,故直接返回NULL */
	if (list_empty(plist)) { 
c0004b8e:	83 ec 0c             	sub    $0xc,%esp
c0004b91:	ff 75 08             	pushl  0x8(%ebp)
c0004b94:	e8 78 00 00 00       	call   c0004c11 <list_empty>
c0004b99:	83 c4 10             	add    $0x10,%esp
c0004b9c:	85 c0                	test   %eax,%eax
c0004b9e:	74 2a                	je     c0004bca <list_traversal+0x4b>
/work/x86_os_my/lib/kernel/list.c:78
		return NULL;
c0004ba0:	b8 00 00 00 00       	mov    $0x0,%eax
c0004ba5:	eb 33                	jmp    c0004bda <list_traversal+0x5b>
/work/x86_os_my/lib/kernel/list.c:82
	}

	while (elem != &plist->tail) {
	if (func(elem, arg)) {		// func返回ture则认为该元素在回调函数中符合条件,命中,故停止继续遍历
c0004ba7:	83 ec 08             	sub    $0x8,%esp
c0004baa:	ff 75 10             	pushl  0x10(%ebp)
c0004bad:	ff 75 f4             	pushl  -0xc(%ebp)
c0004bb0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004bb3:	ff d0                	call   *%eax
c0004bb5:	83 c4 10             	add    $0x10,%esp
c0004bb8:	85 c0                	test   %eax,%eax
c0004bba:	74 05                	je     c0004bc1 <list_traversal+0x42>
/work/x86_os_my/lib/kernel/list.c:83
		return elem;
c0004bbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004bbf:	eb 19                	jmp    c0004bda <list_traversal+0x5b>
/work/x86_os_my/lib/kernel/list.c:85
	}
		elem = elem->next;		// 若回调函数func返回false,则继续遍历
c0004bc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004bc4:	8b 40 04             	mov    0x4(%eax),%eax
c0004bc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:81
	/* 如果队列为空,就必然没有符合条件的结点,故直接返回NULL */
	if (list_empty(plist)) { 
		return NULL;
	}

	while (elem != &plist->tail) {
c0004bca:	8b 45 08             	mov    0x8(%ebp),%eax
c0004bcd:	83 c0 08             	add    $0x8,%eax
c0004bd0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0004bd3:	75 d2                	jne    c0004ba7 <list_traversal+0x28>
/work/x86_os_my/lib/kernel/list.c:87
	if (func(elem, arg)) {		// func返回ture则认为该元素在回调函数中符合条件,命中,故停止继续遍历
		return elem;
	}
		elem = elem->next;		// 若回调函数func返回false,则继续遍历
	}
	return NULL;
c0004bd5:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/kernel/list.c:88
}
c0004bda:	c9                   	leave  
c0004bdb:	c3                   	ret    

c0004bdc <list_len>:
list_len():
/work/x86_os_my/lib/kernel/list.c:91

/* 返回链表长度 */
uint32_t list_len(struct list* plist) {
c0004bdc:	55                   	push   %ebp
c0004bdd:	89 e5                	mov    %esp,%ebp
c0004bdf:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:92
	struct list_elem* elem = plist->head.next;
c0004be2:	8b 45 08             	mov    0x8(%ebp),%eax
c0004be5:	8b 40 04             	mov    0x4(%eax),%eax
c0004be8:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:93
	uint32_t length = 0;
c0004beb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
/work/x86_os_my/lib/kernel/list.c:94
	while (elem != &plist->tail) {
c0004bf2:	eb 0d                	jmp    c0004c01 <list_len+0x25>
/work/x86_os_my/lib/kernel/list.c:95
		length++; 
c0004bf4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
/work/x86_os_my/lib/kernel/list.c:96
		elem = elem->next;
c0004bf8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004bfb:	8b 40 04             	mov    0x4(%eax),%eax
c0004bfe:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:94

/* 返回链表长度 */
uint32_t list_len(struct list* plist) {
	struct list_elem* elem = plist->head.next;
	uint32_t length = 0;
	while (elem != &plist->tail) {
c0004c01:	8b 45 08             	mov    0x8(%ebp),%eax
c0004c04:	83 c0 08             	add    $0x8,%eax
c0004c07:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c0004c0a:	75 e8                	jne    c0004bf4 <list_len+0x18>
/work/x86_os_my/lib/kernel/list.c:98
		length++; 
		elem = elem->next;
	}
	return length;
c0004c0c:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/kernel/list.c:99
}
c0004c0f:	c9                   	leave  
c0004c10:	c3                   	ret    

c0004c11 <list_empty>:
list_empty():
/work/x86_os_my/lib/kernel/list.c:102

/* 判断链表是否为空,空时返回true,否则返回false */
bool list_empty(struct list* plist) {		// 判断队列是否为空
c0004c11:	55                   	push   %ebp
c0004c12:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/lib/kernel/list.c:103
	return (plist->head.next == &plist->tail ? true : false);
c0004c14:	8b 45 08             	mov    0x8(%ebp),%eax
c0004c17:	8b 40 04             	mov    0x4(%eax),%eax
c0004c1a:	8b 55 08             	mov    0x8(%ebp),%edx
c0004c1d:	83 c2 08             	add    $0x8,%edx
c0004c20:	39 d0                	cmp    %edx,%eax
c0004c22:	0f 94 c0             	sete   %al
c0004c25:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/lib/kernel/list.c:104
}
c0004c28:	5d                   	pop    %ebp
c0004c29:	c3                   	ret    
c0004c2a:	66 90                	xchg   %ax,%ax
c0004c2c:	66 90                	xchg   %ax,%ax
c0004c2e:	66 90                	xchg   %ax,%ax

c0004c30 <switch_to>:
switch_to():
c0004c30:	56                   	push   %esi
c0004c31:	57                   	push   %edi
c0004c32:	53                   	push   %ebx
c0004c33:	55                   	push   %ebp
c0004c34:	8b 44 24 14          	mov    0x14(%esp),%eax
c0004c38:	89 20                	mov    %esp,(%eax)
c0004c3a:	8b 44 24 18          	mov    0x18(%esp),%eax
c0004c3e:	8b 20                	mov    (%eax),%esp
c0004c40:	5d                   	pop    %ebp
c0004c41:	5b                   	pop    %ebx
c0004c42:	5f                   	pop    %edi
c0004c43:	5e                   	pop    %esi
c0004c44:	c3                   	ret    

c0004c45 <console_init>:
console_init():
/work/x86_os_my/device/console.c:9
#include "sync.h"
#include "thread.h"
static struct lock console_lock;	// 控制台锁

/* 初始化终端 */
void console_init() {
c0004c45:	55                   	push   %ebp
c0004c46:	89 e5                	mov    %esp,%ebp
c0004c48:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:10
	lock_init(&console_lock);
c0004c4b:	83 ec 0c             	sub    $0xc,%esp
c0004c4e:	68 04 36 01 c0       	push   $0xc0013604
c0004c53:	e8 cd 00 00 00       	call   c0004d25 <lock_init>
c0004c58:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:11
}
c0004c5b:	90                   	nop
c0004c5c:	c9                   	leave  
c0004c5d:	c3                   	ret    

c0004c5e <console_acquire>:
console_acquire():
/work/x86_os_my/device/console.c:14

/* 获取终端 */
void console_acquire() {
c0004c5e:	55                   	push   %ebp
c0004c5f:	89 e5                	mov    %esp,%ebp
c0004c61:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:15
	lock_acquire(&console_lock);
c0004c64:	83 ec 0c             	sub    $0xc,%esp
c0004c67:	68 04 36 01 c0       	push   $0xc0013604
c0004c6c:	e8 8e 02 00 00       	call   c0004eff <lock_acquire>
c0004c71:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:16
}
c0004c74:	90                   	nop
c0004c75:	c9                   	leave  
c0004c76:	c3                   	ret    

c0004c77 <console_release>:
console_release():
/work/x86_os_my/device/console.c:19

/* 释放终端 */
void console_release() {
c0004c77:	55                   	push   %ebp
c0004c78:	89 e5                	mov    %esp,%ebp
c0004c7a:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:20
	lock_release(&console_lock);
c0004c7d:	83 ec 0c             	sub    $0xc,%esp
c0004c80:	68 04 36 01 c0       	push   $0xc0013604
c0004c85:	e8 ec 02 00 00       	call   c0004f76 <lock_release>
c0004c8a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:21
}
c0004c8d:	90                   	nop
c0004c8e:	c9                   	leave  
c0004c8f:	c3                   	ret    

c0004c90 <console_put_str>:
console_put_str():
/work/x86_os_my/device/console.c:24

/* 终端中输出字符串 */
void console_put_str(char* str) {
c0004c90:	55                   	push   %ebp
c0004c91:	89 e5                	mov    %esp,%ebp
c0004c93:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:25
	console_acquire();
c0004c96:	e8 c3 ff ff ff       	call   c0004c5e <console_acquire>
/work/x86_os_my/device/console.c:26
	put_str(str);
c0004c9b:	83 ec 0c             	sub    $0xc,%esp
c0004c9e:	ff 75 08             	pushl  0x8(%ebp)
c0004ca1:	e8 0a d7 ff ff       	call   c00023b0 <put_str>
c0004ca6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:27
	console_release();
c0004ca9:	e8 c9 ff ff ff       	call   c0004c77 <console_release>
/work/x86_os_my/device/console.c:28
}
c0004cae:	90                   	nop
c0004caf:	c9                   	leave  
c0004cb0:	c3                   	ret    

c0004cb1 <console_put_char>:
console_put_char():
/work/x86_os_my/device/console.c:31

/* 终端中输出字符 */
void console_put_char(uint8_t char_asci) {
c0004cb1:	55                   	push   %ebp
c0004cb2:	89 e5                	mov    %esp,%ebp
c0004cb4:	83 ec 18             	sub    $0x18,%esp
c0004cb7:	8b 45 08             	mov    0x8(%ebp),%eax
c0004cba:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/console.c:32
	console_acquire();
c0004cbd:	e8 9c ff ff ff       	call   c0004c5e <console_acquire>
/work/x86_os_my/device/console.c:33
	put_char(char_asci);
c0004cc2:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0004cc6:	83 ec 0c             	sub    $0xc,%esp
c0004cc9:	50                   	push   %eax
c0004cca:	e8 ff d6 ff ff       	call   c00023ce <put_char>
c0004ccf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:34
	console_release();
c0004cd2:	e8 a0 ff ff ff       	call   c0004c77 <console_release>
/work/x86_os_my/device/console.c:35
}
c0004cd7:	90                   	nop
c0004cd8:	c9                   	leave  
c0004cd9:	c3                   	ret    

c0004cda <console_put_int>:
console_put_int():
/work/x86_os_my/device/console.c:38

/* 终端中输出16进制整数 */
void console_put_int(uint32_t num) {
c0004cda:	55                   	push   %ebp
c0004cdb:	89 e5                	mov    %esp,%ebp
c0004cdd:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:39
	console_acquire();
c0004ce0:	e8 79 ff ff ff       	call   c0004c5e <console_acquire>
/work/x86_os_my/device/console.c:40
	put_int(num);
c0004ce5:	83 ec 0c             	sub    $0xc,%esp
c0004ce8:	ff 75 08             	pushl  0x8(%ebp)
c0004ceb:	e8 ea d7 ff ff       	call   c00024da <put_int>
c0004cf0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:41
	console_release();
c0004cf3:	e8 7f ff ff ff       	call   c0004c77 <console_release>
/work/x86_os_my/device/console.c:42
}
c0004cf8:	90                   	nop
c0004cf9:	c9                   	leave  
c0004cfa:	c3                   	ret    

c0004cfb <sema_init>:
sema_init():
/work/x86_os_my/thread/sync.c:8
#include "global.h"
#include "debug.h"
#include "interrupt.h"

/* 初始化信号量 */
void sema_init(struct semaphore* psema, uint8_t value) {
c0004cfb:	55                   	push   %ebp
c0004cfc:	89 e5                	mov    %esp,%ebp
c0004cfe:	83 ec 18             	sub    $0x18,%esp
c0004d01:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004d04:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:9
	psema->value = value;       // 为信号量赋初值
c0004d07:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d0a:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0004d0e:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:10
	list_init(&psema->waiters); //初始化信号量的等待队列
c0004d10:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d13:	83 c0 04             	add    $0x4,%eax
c0004d16:	83 ec 0c             	sub    $0xc,%esp
c0004d19:	50                   	push   %eax
c0004d1a:	e8 1a fd ff ff       	call   c0004a39 <list_init>
c0004d1f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:11
}
c0004d22:	90                   	nop
c0004d23:	c9                   	leave  
c0004d24:	c3                   	ret    

c0004d25 <lock_init>:
lock_init():
/work/x86_os_my/thread/sync.c:14

/* 初始化锁plock */
void lock_init(struct lock* plock) {
c0004d25:	55                   	push   %ebp
c0004d26:	89 e5                	mov    %esp,%ebp
c0004d28:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/sync.c:15
	plock->holder = NULL;
c0004d2b:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d2e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:16
	plock->holder_repeat_nr = 0;
c0004d34:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d37:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:17
	sema_init(&plock->semaphore, 1);  // 信号量初值为1
c0004d3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d41:	83 c0 04             	add    $0x4,%eax
c0004d44:	83 ec 08             	sub    $0x8,%esp
c0004d47:	6a 01                	push   $0x1
c0004d49:	50                   	push   %eax
c0004d4a:	e8 ac ff ff ff       	call   c0004cfb <sema_init>
c0004d4f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:18
}
c0004d52:	90                   	nop
c0004d53:	c9                   	leave  
c0004d54:	c3                   	ret    

c0004d55 <sema_down>:
sema_down():
/work/x86_os_my/thread/sync.c:21

/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
c0004d55:	55                   	push   %ebp
c0004d56:	89 e5                	mov    %esp,%ebp
c0004d58:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:23
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
c0004d5b:	e8 25 ce ff ff       	call   c0001b85 <intr_disable>
c0004d60:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:25
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c0004d63:	e9 98 00 00 00       	jmp    c0004e00 <sema_down+0xab>
/work/x86_os_my/thread/sync.c:26
		ASSERT(!elem_find(&psema->waiters, &running_thread()->general_tag));
c0004d68:	e8 df f0 ff ff       	call   c0003e4c <running_thread>
c0004d6d:	8d 50 44             	lea    0x44(%eax),%edx
c0004d70:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d73:	83 c0 04             	add    $0x4,%eax
c0004d76:	83 ec 08             	sub    $0x8,%esp
c0004d79:	52                   	push   %edx
c0004d7a:	50                   	push   %eax
c0004d7b:	e8 c4 fd ff ff       	call   c0004b44 <elem_find>
c0004d80:	83 c4 10             	add    $0x10,%esp
c0004d83:	85 c0                	test   %eax,%eax
c0004d85:	74 19                	je     c0004da0 <sema_down+0x4b>
/work/x86_os_my/thread/sync.c:26 (discriminator 1)
c0004d87:	68 ec e5 00 c0       	push   $0xc000e5ec
c0004d8c:	68 f0 e6 00 c0       	push   $0xc000e6f0
c0004d91:	6a 1a                	push   $0x1a
c0004d93:	68 28 e6 00 c0       	push   $0xc000e628
c0004d98:	e8 c4 d7 ff ff       	call   c0002561 <panic_spin>
c0004d9d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:28
		/* 当前线程不应该已在信号量的waiters队列中 */
		if (elem_find(&psema->waiters, &running_thread()->general_tag)) {
c0004da0:	e8 a7 f0 ff ff       	call   c0003e4c <running_thread>
c0004da5:	8d 50 44             	lea    0x44(%eax),%edx
c0004da8:	8b 45 08             	mov    0x8(%ebp),%eax
c0004dab:	83 c0 04             	add    $0x4,%eax
c0004dae:	83 ec 08             	sub    $0x8,%esp
c0004db1:	52                   	push   %edx
c0004db2:	50                   	push   %eax
c0004db3:	e8 8c fd ff ff       	call   c0004b44 <elem_find>
c0004db8:	83 c4 10             	add    $0x10,%esp
c0004dbb:	85 c0                	test   %eax,%eax
c0004dbd:	74 19                	je     c0004dd8 <sema_down+0x83>
/work/x86_os_my/thread/sync.c:29
			PANIC("sema_down: thread blocked has been in waiters_list\n");
c0004dbf:	68 38 e6 00 c0       	push   $0xc000e638
c0004dc4:	68 f0 e6 00 c0       	push   $0xc000e6f0
c0004dc9:	6a 1d                	push   $0x1d
c0004dcb:	68 28 e6 00 c0       	push   $0xc000e628
c0004dd0:	e8 8c d7 ff ff       	call   c0002561 <panic_spin>
c0004dd5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:32
		}
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
c0004dd8:	e8 6f f0 ff ff       	call   c0003e4c <running_thread>
c0004ddd:	8d 50 44             	lea    0x44(%eax),%edx
c0004de0:	8b 45 08             	mov    0x8(%ebp),%eax
c0004de3:	83 c0 04             	add    $0x4,%eax
c0004de6:	83 ec 08             	sub    $0x8,%esp
c0004de9:	52                   	push   %edx
c0004dea:	50                   	push   %eax
c0004deb:	e8 da fc ff ff       	call   c0004aca <list_append>
c0004df0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:33
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
c0004df3:	83 ec 0c             	sub    $0xc,%esp
c0004df6:	6a 02                	push   $0x2
c0004df8:	e8 af f5 ff ff       	call   c00043ac <thread_block>
c0004dfd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:25
/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c0004e00:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e03:	0f b6 00             	movzbl (%eax),%eax
c0004e06:	84 c0                	test   %al,%al
c0004e08:	0f 84 5a ff ff ff    	je     c0004d68 <sema_down+0x13>
/work/x86_os_my/thread/sync.c:36
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
	}
	/* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*/
	psema->value--;
c0004e0e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e11:	0f b6 00             	movzbl (%eax),%eax
c0004e14:	8d 50 ff             	lea    -0x1(%eax),%edx
c0004e17:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e1a:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:37
	ASSERT(psema->value == 0);
c0004e1c:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e1f:	0f b6 00             	movzbl (%eax),%eax
c0004e22:	84 c0                	test   %al,%al
c0004e24:	74 19                	je     c0004e3f <sema_down+0xea>
/work/x86_os_my/thread/sync.c:37 (discriminator 1)
c0004e26:	68 6c e6 00 c0       	push   $0xc000e66c
c0004e2b:	68 f0 e6 00 c0       	push   $0xc000e6f0
c0004e30:	6a 25                	push   $0x25
c0004e32:	68 28 e6 00 c0       	push   $0xc000e628
c0004e37:	e8 25 d7 ff ff       	call   c0002561 <panic_spin>
c0004e3c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:40
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c0004e3f:	83 ec 0c             	sub    $0xc,%esp
c0004e42:	ff 75 f4             	pushl  -0xc(%ebp)
c0004e45:	e8 64 cd ff ff       	call   c0001bae <intr_set_status>
c0004e4a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:41
}
c0004e4d:	90                   	nop
c0004e4e:	c9                   	leave  
c0004e4f:	c3                   	ret    

c0004e50 <sema_up>:
sema_up():
/work/x86_os_my/thread/sync.c:44

/* 信号量的up操作 */
void sema_up(struct semaphore* psema) {
c0004e50:	55                   	push   %ebp
c0004e51:	89 e5                	mov    %esp,%ebp
c0004e53:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:46
	/* 关中断,保证原子操作 */
	enum intr_status old_status = intr_disable();
c0004e56:	e8 2a cd ff ff       	call   c0001b85 <intr_disable>
c0004e5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:48
	
	ASSERT(psema->value == 0);
c0004e5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e61:	0f b6 00             	movzbl (%eax),%eax
c0004e64:	84 c0                	test   %al,%al
c0004e66:	74 19                	je     c0004e81 <sema_up+0x31>
/work/x86_os_my/thread/sync.c:48 (discriminator 1)
c0004e68:	68 6c e6 00 c0       	push   $0xc000e66c
c0004e6d:	68 fc e6 00 c0       	push   $0xc000e6fc
c0004e72:	6a 30                	push   $0x30
c0004e74:	68 28 e6 00 c0       	push   $0xc000e628
c0004e79:	e8 e3 d6 ff ff       	call   c0002561 <panic_spin>
c0004e7e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:49
	if (!list_empty(&psema->waiters)) {
c0004e81:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e84:	83 c0 04             	add    $0x4,%eax
c0004e87:	83 ec 0c             	sub    $0xc,%esp
c0004e8a:	50                   	push   %eax
c0004e8b:	e8 81 fd ff ff       	call   c0004c11 <list_empty>
c0004e90:	83 c4 10             	add    $0x10,%esp
c0004e93:	85 c0                	test   %eax,%eax
c0004e95:	75 26                	jne    c0004ebd <sema_up+0x6d>
/work/x86_os_my/thread/sync.c:50
		struct task_struct* thread_blocked = elem2entry(struct task_struct, general_tag, list_pop(&psema->waiters));
c0004e97:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e9a:	83 c0 04             	add    $0x4,%eax
c0004e9d:	83 ec 0c             	sub    $0xc,%esp
c0004ea0:	50                   	push   %eax
c0004ea1:	e8 7c fc ff ff       	call   c0004b22 <list_pop>
c0004ea6:	83 c4 10             	add    $0x10,%esp
c0004ea9:	83 e8 44             	sub    $0x44,%eax
c0004eac:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/sync.c:51
		thread_unblock(thread_blocked);
c0004eaf:	83 ec 0c             	sub    $0xc,%esp
c0004eb2:	ff 75 f0             	pushl  -0x10(%ebp)
c0004eb5:	e8 55 f5 ff ff       	call   c000440f <thread_unblock>
c0004eba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:53
	}
	psema->value++;
c0004ebd:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ec0:	0f b6 00             	movzbl (%eax),%eax
c0004ec3:	8d 50 01             	lea    0x1(%eax),%edx
c0004ec6:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ec9:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:54
	ASSERT(psema->value == 1);
c0004ecb:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ece:	0f b6 00             	movzbl (%eax),%eax
c0004ed1:	3c 01                	cmp    $0x1,%al
c0004ed3:	74 19                	je     c0004eee <sema_up+0x9e>
/work/x86_os_my/thread/sync.c:54 (discriminator 1)
c0004ed5:	68 7e e6 00 c0       	push   $0xc000e67e
c0004eda:	68 fc e6 00 c0       	push   $0xc000e6fc
c0004edf:	6a 36                	push   $0x36
c0004ee1:	68 28 e6 00 c0       	push   $0xc000e628
c0004ee6:	e8 76 d6 ff ff       	call   c0002561 <panic_spin>
c0004eeb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:57
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c0004eee:	83 ec 0c             	sub    $0xc,%esp
c0004ef1:	ff 75 f4             	pushl  -0xc(%ebp)
c0004ef4:	e8 b5 cc ff ff       	call   c0001bae <intr_set_status>
c0004ef9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:58
}
c0004efc:	90                   	nop
c0004efd:	c9                   	leave  
c0004efe:	c3                   	ret    

c0004eff <lock_acquire>:
lock_acquire():
/work/x86_os_my/thread/sync.c:61

/* 获取锁plock */
void lock_acquire(struct lock* plock) {
c0004eff:	55                   	push   %ebp
c0004f00:	89 e5                	mov    %esp,%ebp
c0004f02:	53                   	push   %ebx
c0004f03:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:63
	/* 排除曾经自己已经持有锁但还未将其释放的情况。*/
	if (plock->holder != running_thread()) {
c0004f06:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f09:	8b 18                	mov    (%eax),%ebx
c0004f0b:	e8 3c ef ff ff       	call   c0003e4c <running_thread>
c0004f10:	39 c3                	cmp    %eax,%ebx
c0004f12:	74 4d                	je     c0004f61 <lock_acquire+0x62>
/work/x86_os_my/thread/sync.c:64
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
c0004f14:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f17:	83 c0 04             	add    $0x4,%eax
c0004f1a:	83 ec 0c             	sub    $0xc,%esp
c0004f1d:	50                   	push   %eax
c0004f1e:	e8 32 fe ff ff       	call   c0004d55 <sema_down>
c0004f23:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:65
		plock->holder = running_thread();
c0004f26:	e8 21 ef ff ff       	call   c0003e4c <running_thread>
c0004f2b:	89 c2                	mov    %eax,%edx
c0004f2d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f30:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/sync.c:66
		ASSERT(plock->holder_repeat_nr == 0);
c0004f32:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f35:	8b 40 18             	mov    0x18(%eax),%eax
c0004f38:	85 c0                	test   %eax,%eax
c0004f3a:	74 19                	je     c0004f55 <lock_acquire+0x56>
/work/x86_os_my/thread/sync.c:66 (discriminator 1)
c0004f3c:	68 90 e6 00 c0       	push   $0xc000e690
c0004f41:	68 04 e7 00 c0       	push   $0xc000e704
c0004f46:	6a 42                	push   $0x42
c0004f48:	68 28 e6 00 c0       	push   $0xc000e628
c0004f4d:	e8 0f d6 ff ff       	call   c0002561 <panic_spin>
c0004f52:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:67
		plock->holder_repeat_nr = 1;
c0004f55:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f58:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	} else {
		plock->holder_repeat_nr++;
	}
}
c0004f5f:	eb 0f                	jmp    c0004f70 <lock_acquire+0x71>
/work/x86_os_my/thread/sync.c:69
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
		plock->holder = running_thread();
		ASSERT(plock->holder_repeat_nr == 0);
		plock->holder_repeat_nr = 1;
	} else {
		plock->holder_repeat_nr++;
c0004f61:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f64:	8b 40 18             	mov    0x18(%eax),%eax
c0004f67:	8d 50 01             	lea    0x1(%eax),%edx
c0004f6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f6d:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	}
}
c0004f70:	90                   	nop
c0004f71:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0004f74:	c9                   	leave  
c0004f75:	c3                   	ret    

c0004f76 <lock_release>:
lock_release():
/work/x86_os_my/thread/sync.c:74

/* 释放锁plock */
void lock_release(struct lock* plock) {
c0004f76:	55                   	push   %ebp
c0004f77:	89 e5                	mov    %esp,%ebp
c0004f79:	53                   	push   %ebx
c0004f7a:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:75
	ASSERT(plock->holder == running_thread());
c0004f7d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f80:	8b 18                	mov    (%eax),%ebx
c0004f82:	e8 c5 ee ff ff       	call   c0003e4c <running_thread>
c0004f87:	39 c3                	cmp    %eax,%ebx
c0004f89:	74 19                	je     c0004fa4 <lock_release+0x2e>
/work/x86_os_my/thread/sync.c:75 (discriminator 1)
c0004f8b:	68 b0 e6 00 c0       	push   $0xc000e6b0
c0004f90:	68 14 e7 00 c0       	push   $0xc000e714
c0004f95:	6a 4b                	push   $0x4b
c0004f97:	68 28 e6 00 c0       	push   $0xc000e628
c0004f9c:	e8 c0 d5 ff ff       	call   c0002561 <panic_spin>
c0004fa1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:76
	if (plock->holder_repeat_nr > 1) {
c0004fa4:	8b 45 08             	mov    0x8(%ebp),%eax
c0004fa7:	8b 40 18             	mov    0x18(%eax),%eax
c0004faa:	83 f8 01             	cmp    $0x1,%eax
c0004fad:	76 11                	jbe    c0004fc0 <lock_release+0x4a>
/work/x86_os_my/thread/sync.c:77
		plock->holder_repeat_nr--;
c0004faf:	8b 45 08             	mov    0x8(%ebp),%eax
c0004fb2:	8b 40 18             	mov    0x18(%eax),%eax
c0004fb5:	8d 50 ff             	lea    -0x1(%eax),%edx
c0004fb8:	8b 45 08             	mov    0x8(%ebp),%eax
c0004fbb:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:78
		return;
c0004fbe:	eb 49                	jmp    c0005009 <lock_release+0x93>
/work/x86_os_my/thread/sync.c:80
	}
	ASSERT(plock->holder_repeat_nr == 1);
c0004fc0:	8b 45 08             	mov    0x8(%ebp),%eax
c0004fc3:	8b 40 18             	mov    0x18(%eax),%eax
c0004fc6:	83 f8 01             	cmp    $0x1,%eax
c0004fc9:	74 19                	je     c0004fe4 <lock_release+0x6e>
/work/x86_os_my/thread/sync.c:80 (discriminator 1)
c0004fcb:	68 d2 e6 00 c0       	push   $0xc000e6d2
c0004fd0:	68 14 e7 00 c0       	push   $0xc000e714
c0004fd5:	6a 50                	push   $0x50
c0004fd7:	68 28 e6 00 c0       	push   $0xc000e628
c0004fdc:	e8 80 d5 ff ff       	call   c0002561 <panic_spin>
c0004fe1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:82

	plock->holder = NULL;			// 把锁的持有者置空放在V操作之前
c0004fe4:	8b 45 08             	mov    0x8(%ebp),%eax
c0004fe7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:83
	plock->holder_repeat_nr = 0;
c0004fed:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ff0:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:84
	sema_up(&plock->semaphore);		// 信号量的V操作,也是原子操作
c0004ff7:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ffa:	83 c0 04             	add    $0x4,%eax
c0004ffd:	83 ec 0c             	sub    $0xc,%esp
c0005000:	50                   	push   %eax
c0005001:	e8 4a fe ff ff       	call   c0004e50 <sema_up>
c0005006:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:85
}
c0005009:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000500c:	c9                   	leave  
c000500d:	c3                   	ret    

c000500e <inb>:
inb():
/work/x86_os_my/lib/kernel/io.h:36
   asm volatile ("cld; rep outsw" : "+S" (addr), "+c" (word_cnt) : "d" (port));
/******************************************************/
}

/* 将从端口port读入的一个字节返回 */
static inline uint8_t inb(uint16_t port) {
c000500e:	55                   	push   %ebp
c000500f:	89 e5                	mov    %esp,%ebp
c0005011:	83 ec 14             	sub    $0x14,%esp
c0005014:	8b 45 08             	mov    0x8(%ebp),%eax
c0005017:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/io.h:38
   uint8_t data;
   asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c000501b:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c000501f:	89 c2                	mov    %eax,%edx
c0005021:	ec                   	in     (%dx),%al
c0005022:	88 45 ff             	mov    %al,-0x1(%ebp)
/work/x86_os_my/lib/kernel/io.h:39
   return data;
c0005025:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
/work/x86_os_my/lib/kernel/io.h:40
}
c0005029:	c9                   	leave  
c000502a:	c3                   	ret    

c000502b <intr_keyboard_handler>:
intr_keyboard_handler():
/work/x86_os_my/device/keyboard.c:111
/* 0x3A */	{caps_lock_char, caps_lock_char}
/*其它按键暂不处理*/
};

/* 键盘中断处理程序 */
static void intr_keyboard_handler(void) {
c000502b:	55                   	push   %ebp
c000502c:	89 e5                	mov    %esp,%ebp
c000502e:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/device/keyboard.c:114

/* 这次中断发生前的上一次中断,以下任意三个键是否有按下 */
   bool ctrl_down_last = ctrl_status;	  
c0005031:	a1 20 36 01 c0       	mov    0xc0013620,%eax
c0005036:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/device/keyboard.c:115
   bool shift_down_last = shift_status;
c0005039:	a1 24 36 01 c0       	mov    0xc0013624,%eax
c000503e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/device/keyboard.c:116
   bool caps_lock_last = caps_lock_status;
c0005041:	a1 2c 36 01 c0       	mov    0xc001362c,%eax
c0005046:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/device/keyboard.c:119

   bool break_code;
   uint16_t scancode = inb(KBD_BUF_PORT);
c0005049:	6a 60                	push   $0x60
c000504b:	e8 be ff ff ff       	call   c000500e <inb>
c0005050:	83 c4 04             	add    $0x4,%esp
c0005053:	0f b6 c0             	movzbl %al,%eax
c0005056:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:123

/* 若扫描码是e0开头的,表示此键的按下将产生多个扫描码,
 * 所以马上结束此次中断处理函数,等待下一个扫描码进来*/ 
   if (scancode == 0xe0) { 
c000505a:	66 81 7d f6 e0 00    	cmpw   $0xe0,-0xa(%ebp)
c0005060:	75 0f                	jne    c0005071 <intr_keyboard_handler+0x46>
/work/x86_os_my/device/keyboard.c:124
      ext_scancode = true;    // 打开e0标记
c0005062:	c7 05 30 36 01 c0 01 	movl   $0x1,0xc0013630
c0005069:	00 00 00 
/work/x86_os_my/device/keyboard.c:125
      return;
c000506c:	e9 50 02 00 00       	jmp    c00052c1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:129
   }

/* 如果上次是以0xe0开头,将扫描码合并 */
   if (ext_scancode) {
c0005071:	a1 30 36 01 c0       	mov    0xc0013630,%eax
c0005076:	85 c0                	test   %eax,%eax
c0005078:	74 10                	je     c000508a <intr_keyboard_handler+0x5f>
/work/x86_os_my/device/keyboard.c:130
      scancode = ((0xe000) | scancode);
c000507a:	66 81 4d f6 00 e0    	orw    $0xe000,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:131
      ext_scancode = false;   // 关闭e0标记
c0005080:	c7 05 30 36 01 c0 00 	movl   $0x0,0xc0013630
c0005087:	00 00 00 
/work/x86_os_my/device/keyboard.c:134
   }   

   break_code = ((scancode & 0x0080) != 0);   // 获取break_code
c000508a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c000508e:	25 80 00 00 00       	and    $0x80,%eax
c0005093:	85 c0                	test   %eax,%eax
c0005095:	0f 95 c0             	setne  %al
c0005098:	0f b6 c0             	movzbl %al,%eax
c000509b:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/device/keyboard.c:136
   
   if (break_code) {   // 若是断码break_code(按键弹起时产生的扫描码)
c000509e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c00050a2:	74 6a                	je     c000510e <intr_keyboard_handler+0xe3>
/work/x86_os_my/device/keyboard.c:140

   /* 由于ctrl_r 和alt_r的make_code和break_code都是两字节,
   所以可用下面的方法取make_code,多字节的扫描码暂不处理 */
      uint16_t make_code = (scancode &= 0xff7f);   // 得到其make_code(按键按下时产生的扫描码)
c00050a4:	66 81 65 f6 7f ff    	andw   $0xff7f,-0xa(%ebp)
c00050aa:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c00050ae:	66 89 45 da          	mov    %ax,-0x26(%ebp)
/work/x86_os_my/device/keyboard.c:143

   /* 若是任意以下三个键弹起了,将状态置为false */
      if (make_code == ctrl_l_make || make_code == ctrl_r_make) {
c00050b2:	66 83 7d da 1d       	cmpw   $0x1d,-0x26(%ebp)
c00050b7:	74 08                	je     c00050c1 <intr_keyboard_handler+0x96>
/work/x86_os_my/device/keyboard.c:143 (discriminator 1)
c00050b9:	66 81 7d da 1d e0    	cmpw   $0xe01d,-0x26(%ebp)
c00050bf:	75 0c                	jne    c00050cd <intr_keyboard_handler+0xa2>
/work/x86_os_my/device/keyboard.c:144
	 ctrl_status = false;
c00050c1:	c7 05 20 36 01 c0 00 	movl   $0x0,0xc0013620
c00050c8:	00 00 00 
c00050cb:	eb 3c                	jmp    c0005109 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:145
      } else if (make_code == shift_l_make || make_code == shift_r_make) {
c00050cd:	66 83 7d da 2a       	cmpw   $0x2a,-0x26(%ebp)
c00050d2:	74 07                	je     c00050db <intr_keyboard_handler+0xb0>
/work/x86_os_my/device/keyboard.c:145 (discriminator 1)
c00050d4:	66 83 7d da 36       	cmpw   $0x36,-0x26(%ebp)
c00050d9:	75 0c                	jne    c00050e7 <intr_keyboard_handler+0xbc>
/work/x86_os_my/device/keyboard.c:146
	 shift_status = false;
c00050db:	c7 05 24 36 01 c0 00 	movl   $0x0,0xc0013624
c00050e2:	00 00 00 
c00050e5:	eb 22                	jmp    c0005109 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:147
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
c00050e7:	66 83 7d da 38       	cmpw   $0x38,-0x26(%ebp)
c00050ec:	74 0c                	je     c00050fa <intr_keyboard_handler+0xcf>
/work/x86_os_my/device/keyboard.c:147 (discriminator 1)
c00050ee:	66 81 7d da 38 e0    	cmpw   $0xe038,-0x26(%ebp)
c00050f4:	0f 85 c0 01 00 00    	jne    c00052ba <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:148
	 alt_status = false;
c00050fa:	c7 05 28 36 01 c0 00 	movl   $0x0,0xc0013628
c0005101:	00 00 00 
/work/x86_os_my/device/keyboard.c:151
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c0005104:	e9 b1 01 00 00       	jmp    c00052ba <intr_keyboard_handler+0x28f>
c0005109:	e9 ac 01 00 00       	jmp    c00052ba <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:155

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
c000510e:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c0005113:	74 07                	je     c000511c <intr_keyboard_handler+0xf1>
/work/x86_os_my/device/keyboard.c:155 (discriminator 1)
c0005115:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c000511a:	76 14                	jbe    c0005130 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:155 (discriminator 3)
c000511c:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c0005122:	74 0c                	je     c0005130 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:156
	       (scancode == alt_r_make) || \
c0005124:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c000512a:	0f 85 78 01 00 00    	jne    c00052a8 <intr_keyboard_handler+0x27d>
/work/x86_os_my/device/keyboard.c:158
	       (scancode == ctrl_r_make)) {
      bool shift = false;  // 判断是否与shift组合,用来在一维数组中索引对应的字符
c0005130:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:159
      if ((scancode < 0x0e) || (scancode == 0x29) || \
c0005137:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%ebp)
c000513c:	76 3f                	jbe    c000517d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 1)
c000513e:	66 83 7d f6 29       	cmpw   $0x29,-0xa(%ebp)
c0005143:	74 38                	je     c000517d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 2)
c0005145:	66 83 7d f6 1a       	cmpw   $0x1a,-0xa(%ebp)
c000514a:	74 31                	je     c000517d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160
	 (scancode == 0x1a) || (scancode == 0x1b) || \
c000514c:	66 83 7d f6 1b       	cmpw   $0x1b,-0xa(%ebp)
c0005151:	74 2a                	je     c000517d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160 (discriminator 1)
c0005153:	66 83 7d f6 2b       	cmpw   $0x2b,-0xa(%ebp)
c0005158:	74 23                	je     c000517d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161
	 (scancode == 0x2b) || (scancode == 0x27) || \
c000515a:	66 83 7d f6 27       	cmpw   $0x27,-0xa(%ebp)
c000515f:	74 1c                	je     c000517d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161 (discriminator 1)
c0005161:	66 83 7d f6 28       	cmpw   $0x28,-0xa(%ebp)
c0005166:	74 15                	je     c000517d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162
	 (scancode == 0x28) || (scancode == 0x33) || \
c0005168:	66 83 7d f6 33       	cmpw   $0x33,-0xa(%ebp)
c000516d:	74 0e                	je     c000517d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162 (discriminator 1)
c000516f:	66 83 7d f6 34       	cmpw   $0x34,-0xa(%ebp)
c0005174:	74 07                	je     c000517d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:163
	 (scancode == 0x34) || (scancode == 0x35)) {  
c0005176:	66 83 7d f6 35       	cmpw   $0x35,-0xa(%ebp)
c000517b:	75 0f                	jne    c000518c <intr_keyboard_handler+0x161>
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c000517d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0005181:	74 3a                	je     c00051bd <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:177
	    shift = true;
c0005183:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c000518a:	eb 31                	jmp    c00051bd <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:180
	    shift = true;
	 }
      } else {	  // 默认为字母键
	 if (shift_down_last && caps_lock_last) {  // 如果shift和capslock同时按下
c000518c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0005190:	74 0f                	je     c00051a1 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:180 (discriminator 1)
c0005192:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0005196:	74 09                	je     c00051a1 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:181
	    shift = false;
c0005198:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c000519f:	eb 1c                	jmp    c00051bd <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:182
	 } else if (shift_down_last || caps_lock_last) { // 如果shift和capslock任意被按下
c00051a1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00051a5:	75 06                	jne    c00051ad <intr_keyboard_handler+0x182>
/work/x86_os_my/device/keyboard.c:182 (discriminator 1)
c00051a7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c00051ab:	74 09                	je     c00051b6 <intr_keyboard_handler+0x18b>
/work/x86_os_my/device/keyboard.c:183
	    shift = true;
c00051ad:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c00051b4:	eb 07                	jmp    c00051bd <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:185
	 } else {
	    shift = false;
c00051b6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:189
	 }
      }

      uint8_t index = (scancode &= 0x00ff);  // 将扫描码的高字节置0,主要是针对高字节是e0的扫描码.
c00051bd:	66 81 65 f6 ff 00    	andw   $0xff,-0xa(%ebp)
c00051c3:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c00051c7:	88 45 d9             	mov    %al,-0x27(%ebp)
/work/x86_os_my/device/keyboard.c:190
      char cur_char = keymap[index][shift];  // 在数组中找到对应的字符
c00051ca:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
c00051ce:	8d 14 00             	lea    (%eax,%eax,1),%edx
c00051d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00051d4:	01 d0                	add    %edx,%eax
c00051d6:	05 e0 30 01 c0       	add    $0xc00130e0,%eax
c00051db:	0f b6 00             	movzbl (%eax),%eax
c00051de:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:193

   /* 如果cur_char不为0,也就是ascii码为除'\0'外的字符就加入键盘缓冲区中 */
      if (cur_char) {
c00051e1:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c00051e5:	74 54                	je     c000523b <intr_keyboard_handler+0x210>
/work/x86_os_my/device/keyboard.c:200
     /*****************  快捷键ctrl+l和ctrl+u的处理 *********************
      * 下面是把ctrl+l和ctrl+u这两种组合键产生的字符置为:
      * cur_char的asc码-字符a的asc码, 此差值比较小,
      * 属于asc码表中不可见的字符部分.故不会产生可见字符.
      * 我们在shell中将ascii值为l-a和u-a的分别处理为清屏和删除输入的快捷键*/
	 if ((ctrl_down_last && cur_char == 'l') || (ctrl_down_last && cur_char == 'u')) {
c00051e7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c00051eb:	74 06                	je     c00051f3 <intr_keyboard_handler+0x1c8>
/work/x86_os_my/device/keyboard.c:200 (discriminator 1)
c00051ed:	80 7d ef 6c          	cmpb   $0x6c,-0x11(%ebp)
c00051f1:	74 0c                	je     c00051ff <intr_keyboard_handler+0x1d4>
/work/x86_os_my/device/keyboard.c:200 (discriminator 3)
c00051f3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c00051f7:	74 10                	je     c0005209 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:200 (discriminator 4)
c00051f9:	80 7d ef 75          	cmpb   $0x75,-0x11(%ebp)
c00051fd:	75 0a                	jne    c0005209 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:201
	    cur_char -= 'a';
c00051ff:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c0005203:	83 e8 61             	sub    $0x61,%eax
c0005206:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:207
	 }
      /****************************************************************/
      
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
c0005209:	83 ec 0c             	sub    $0xc,%esp
c000520c:	68 e0 42 01 c0       	push   $0xc00142e0
c0005211:	e8 64 01 00 00       	call   c000537a <ioq_full>
c0005216:	83 c4 10             	add    $0x10,%esp
c0005219:	85 c0                	test   %eax,%eax
c000521b:	0f 85 9c 00 00 00    	jne    c00052bd <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:208
	    ioq_putchar(&kbd_buf, cur_char);
c0005221:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
c0005225:	83 ec 08             	sub    $0x8,%esp
c0005228:	50                   	push   %eax
c0005229:	68 e0 42 01 c0       	push   $0xc00142e0
c000522e:	e8 2e 03 00 00       	call   c0005561 <ioq_putchar>
c0005233:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:210
	 }
	 return;
c0005236:	e9 82 00 00 00       	jmp    c00052bd <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:214
      }

      /* 记录本次是否按下了下面几类控制键之一,供下次键入时判断组合键 */
      if (scancode == ctrl_l_make || scancode == ctrl_r_make) {
c000523b:	66 83 7d f6 1d       	cmpw   $0x1d,-0xa(%ebp)
c0005240:	74 08                	je     c000524a <intr_keyboard_handler+0x21f>
/work/x86_os_my/device/keyboard.c:214 (discriminator 1)
c0005242:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0005248:	75 0c                	jne    c0005256 <intr_keyboard_handler+0x22b>
/work/x86_os_my/device/keyboard.c:215
	 ctrl_status = true;
c000524a:	c7 05 20 36 01 c0 01 	movl   $0x1,0xc0013620
c0005251:	00 00 00 
c0005254:	eb 50                	jmp    c00052a6 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:216
      } else if (scancode == shift_l_make || scancode == shift_r_make) {
c0005256:	66 83 7d f6 2a       	cmpw   $0x2a,-0xa(%ebp)
c000525b:	74 07                	je     c0005264 <intr_keyboard_handler+0x239>
/work/x86_os_my/device/keyboard.c:216 (discriminator 1)
c000525d:	66 83 7d f6 36       	cmpw   $0x36,-0xa(%ebp)
c0005262:	75 0c                	jne    c0005270 <intr_keyboard_handler+0x245>
/work/x86_os_my/device/keyboard.c:217
	 shift_status = true;
c0005264:	c7 05 24 36 01 c0 01 	movl   $0x1,0xc0013624
c000526b:	00 00 00 
c000526e:	eb 36                	jmp    c00052a6 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:218
      } else if (scancode == alt_l_make || scancode == alt_r_make) {
c0005270:	66 83 7d f6 38       	cmpw   $0x38,-0xa(%ebp)
c0005275:	74 08                	je     c000527f <intr_keyboard_handler+0x254>
/work/x86_os_my/device/keyboard.c:218 (discriminator 1)
c0005277:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c000527d:	75 0c                	jne    c000528b <intr_keyboard_handler+0x260>
/work/x86_os_my/device/keyboard.c:219
	 alt_status = true;
c000527f:	c7 05 28 36 01 c0 01 	movl   $0x1,0xc0013628
c0005286:	00 00 00 
c0005289:	eb 1b                	jmp    c00052a6 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:220
      } else if (scancode == caps_lock_make) {
c000528b:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0005290:	75 2e                	jne    c00052c0 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:223
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
c0005292:	a1 2c 36 01 c0       	mov    0xc001362c,%eax
c0005297:	85 c0                	test   %eax,%eax
c0005299:	0f 94 c0             	sete   %al
c000529c:	0f b6 c0             	movzbl %al,%eax
c000529f:	a3 2c 36 01 c0       	mov    %eax,0xc001362c
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c00052a4:	eb 1a                	jmp    c00052c0 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:157 (discriminator 3)
c00052a6:	eb 18                	jmp    c00052c0 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:226
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
c00052a8:	83 ec 0c             	sub    $0xc,%esp
c00052ab:	68 21 e7 00 c0       	push   $0xc000e721
c00052b0:	e8 fb d0 ff ff       	call   c00023b0 <put_str>
c00052b5:	83 c4 10             	add    $0x10,%esp
c00052b8:	eb 07                	jmp    c00052c1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:151
	 shift_status = false;
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
	 alt_status = false;
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c00052ba:	90                   	nop
c00052bb:	eb 04                	jmp    c00052c1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:210
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
	    ioq_putchar(&kbd_buf, cur_char);
	 }
	 return;
c00052bd:	90                   	nop
c00052be:	eb 01                	jmp    c00052c1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c00052c0:	90                   	nop
/work/x86_os_my/device/keyboard.c:228
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
   }
}
c00052c1:	c9                   	leave  
c00052c2:	c3                   	ret    

c00052c3 <keyboard_init>:
keyboard_init():
/work/x86_os_my/device/keyboard.c:231

/* 键盘初始化 */
void keyboard_init() {
c00052c3:	55                   	push   %ebp
c00052c4:	89 e5                	mov    %esp,%ebp
c00052c6:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/keyboard.c:232
   put_str("keyboard init start\n");
c00052c9:	83 ec 0c             	sub    $0xc,%esp
c00052cc:	68 2e e7 00 c0       	push   $0xc000e72e
c00052d1:	e8 da d0 ff ff       	call   c00023b0 <put_str>
c00052d6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:233
   ioqueue_init(&kbd_buf);
c00052d9:	83 ec 0c             	sub    $0xc,%esp
c00052dc:	68 e0 42 01 c0       	push   $0xc00142e0
c00052e1:	e8 28 00 00 00       	call   c000530e <ioqueue_init>
c00052e6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:234
   register_handler(0x21, intr_keyboard_handler);
c00052e9:	83 ec 08             	sub    $0x8,%esp
c00052ec:	68 2b 50 00 c0       	push   $0xc000502b
c00052f1:	6a 21                	push   $0x21
c00052f3:	e8 f8 c8 ff ff       	call   c0001bf0 <register_handler>
c00052f8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:235
   put_str("keyboard init done\n");
c00052fb:	83 ec 0c             	sub    $0xc,%esp
c00052fe:	68 43 e7 00 c0       	push   $0xc000e743
c0005303:	e8 a8 d0 ff ff       	call   c00023b0 <put_str>
c0005308:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:236
}
c000530b:	90                   	nop
c000530c:	c9                   	leave  
c000530d:	c3                   	ret    

c000530e <ioqueue_init>:
ioqueue_init():
/work/x86_os_my/device/ioqueue.c:7
#include "interrupt.h"
#include "global.h"
#include "debug.h"

/* 初始化io队列ioq */
void ioqueue_init(struct ioqueue* ioq) {
c000530e:	55                   	push   %ebp
c000530f:	89 e5                	mov    %esp,%ebp
c0005311:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:8
   lock_init(&ioq->lock);     // 初始化io队列的锁
c0005314:	8b 45 08             	mov    0x8(%ebp),%eax
c0005317:	83 ec 0c             	sub    $0xc,%esp
c000531a:	50                   	push   %eax
c000531b:	e8 05 fa ff ff       	call   c0004d25 <lock_init>
c0005320:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:9
   ioq->producer = ioq->consumer = NULL;  // 生产者和消费者置空
c0005323:	8b 45 08             	mov    0x8(%ebp),%eax
c0005326:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c000532d:	8b 45 08             	mov    0x8(%ebp),%eax
c0005330:	8b 50 20             	mov    0x20(%eax),%edx
c0005333:	8b 45 08             	mov    0x8(%ebp),%eax
c0005336:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/device/ioqueue.c:10
   ioq->head = ioq->tail = 0; // 队列的首尾指针指向缓冲区数组第0个位置
c0005339:	8b 45 08             	mov    0x8(%ebp),%eax
c000533c:	c7 80 28 08 00 00 00 	movl   $0x0,0x828(%eax)
c0005343:	00 00 00 
c0005346:	8b 45 08             	mov    0x8(%ebp),%eax
c0005349:	8b 90 28 08 00 00    	mov    0x828(%eax),%edx
c000534f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005352:	89 90 24 08 00 00    	mov    %edx,0x824(%eax)
/work/x86_os_my/device/ioqueue.c:11
}
c0005358:	90                   	nop
c0005359:	c9                   	leave  
c000535a:	c3                   	ret    

c000535b <next_pos>:
next_pos():
/work/x86_os_my/device/ioqueue.c:14

/* 返回pos在缓冲区中的下一个位置值 */
static int32_t next_pos(int32_t pos) {
c000535b:	55                   	push   %ebp
c000535c:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/device/ioqueue.c:15
   return (pos + 1) % bufsize; 
c000535e:	8b 45 08             	mov    0x8(%ebp),%eax
c0005361:	8d 50 01             	lea    0x1(%eax),%edx
c0005364:	89 d0                	mov    %edx,%eax
c0005366:	c1 f8 1f             	sar    $0x1f,%eax
c0005369:	c1 e8 15             	shr    $0x15,%eax
c000536c:	01 c2                	add    %eax,%edx
c000536e:	81 e2 ff 07 00 00    	and    $0x7ff,%edx
c0005374:	29 c2                	sub    %eax,%edx
c0005376:	89 d0                	mov    %edx,%eax
/work/x86_os_my/device/ioqueue.c:16
}
c0005378:	5d                   	pop    %ebp
c0005379:	c3                   	ret    

c000537a <ioq_full>:
ioq_full():
/work/x86_os_my/device/ioqueue.c:19

/* 判断队列是否已满 */
bool ioq_full(struct ioqueue* ioq) {
c000537a:	55                   	push   %ebp
c000537b:	89 e5                	mov    %esp,%ebp
c000537d:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:20
   ASSERT(intr_get_status() == INTR_OFF);
c0005380:	e8 47 c8 ff ff       	call   c0001bcc <intr_get_status>
c0005385:	85 c0                	test   %eax,%eax
c0005387:	74 19                	je     c00053a2 <ioq_full+0x28>
/work/x86_os_my/device/ioqueue.c:20 (discriminator 1)
c0005389:	68 58 e7 00 c0       	push   $0xc000e758
c000538e:	68 bc e7 00 c0       	push   $0xc000e7bc
c0005393:	6a 14                	push   $0x14
c0005395:	68 76 e7 00 c0       	push   $0xc000e776
c000539a:	e8 c2 d1 ff ff       	call   c0002561 <panic_spin>
c000539f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:21
   return next_pos(ioq->head) == ioq->tail;
c00053a2:	8b 45 08             	mov    0x8(%ebp),%eax
c00053a5:	8b 80 24 08 00 00    	mov    0x824(%eax),%eax
c00053ab:	83 ec 0c             	sub    $0xc,%esp
c00053ae:	50                   	push   %eax
c00053af:	e8 a7 ff ff ff       	call   c000535b <next_pos>
c00053b4:	83 c4 10             	add    $0x10,%esp
c00053b7:	89 c2                	mov    %eax,%edx
c00053b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00053bc:	8b 80 28 08 00 00    	mov    0x828(%eax),%eax
c00053c2:	39 c2                	cmp    %eax,%edx
c00053c4:	0f 94 c0             	sete   %al
c00053c7:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:22
}
c00053ca:	c9                   	leave  
c00053cb:	c3                   	ret    

c00053cc <ioq_empty>:
ioq_empty():
/work/x86_os_my/device/ioqueue.c:25

/* 判断队列是否已空 */
static bool ioq_empty(struct ioqueue* ioq) {
c00053cc:	55                   	push   %ebp
c00053cd:	89 e5                	mov    %esp,%ebp
c00053cf:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:26
   ASSERT(intr_get_status() == INTR_OFF);
c00053d2:	e8 f5 c7 ff ff       	call   c0001bcc <intr_get_status>
c00053d7:	85 c0                	test   %eax,%eax
c00053d9:	74 19                	je     c00053f4 <ioq_empty+0x28>
/work/x86_os_my/device/ioqueue.c:26 (discriminator 1)
c00053db:	68 58 e7 00 c0       	push   $0xc000e758
c00053e0:	68 c8 e7 00 c0       	push   $0xc000e7c8
c00053e5:	6a 1a                	push   $0x1a
c00053e7:	68 76 e7 00 c0       	push   $0xc000e776
c00053ec:	e8 70 d1 ff ff       	call   c0002561 <panic_spin>
c00053f1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:27
   return ioq->head == ioq->tail;
c00053f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00053f7:	8b 90 24 08 00 00    	mov    0x824(%eax),%edx
c00053fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0005400:	8b 80 28 08 00 00    	mov    0x828(%eax),%eax
c0005406:	39 c2                	cmp    %eax,%edx
c0005408:	0f 94 c0             	sete   %al
c000540b:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:28
}
c000540e:	c9                   	leave  
c000540f:	c3                   	ret    

c0005410 <ioq_wait>:
ioq_wait():
/work/x86_os_my/device/ioqueue.c:31

/* 使当前生产者或消费者在此缓冲区上等待 */
static void ioq_wait(struct task_struct** waiter) {
c0005410:	55                   	push   %ebp
c0005411:	89 e5                	mov    %esp,%ebp
c0005413:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:32
   ASSERT(*waiter == NULL && waiter != NULL);
c0005416:	8b 45 08             	mov    0x8(%ebp),%eax
c0005419:	8b 00                	mov    (%eax),%eax
c000541b:	85 c0                	test   %eax,%eax
c000541d:	75 06                	jne    c0005425 <ioq_wait+0x15>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 1)
c000541f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0005423:	75 19                	jne    c000543e <ioq_wait+0x2e>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 3)
c0005425:	68 88 e7 00 c0       	push   $0xc000e788
c000542a:	68 d4 e7 00 c0       	push   $0xc000e7d4
c000542f:	6a 20                	push   $0x20
c0005431:	68 76 e7 00 c0       	push   $0xc000e776
c0005436:	e8 26 d1 ff ff       	call   c0002561 <panic_spin>
c000543b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:33
   *waiter = running_thread();
c000543e:	e8 09 ea ff ff       	call   c0003e4c <running_thread>
c0005443:	89 c2                	mov    %eax,%edx
c0005445:	8b 45 08             	mov    0x8(%ebp),%eax
c0005448:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ioqueue.c:34
   thread_block(TASK_BLOCKED);
c000544a:	83 ec 0c             	sub    $0xc,%esp
c000544d:	6a 02                	push   $0x2
c000544f:	e8 58 ef ff ff       	call   c00043ac <thread_block>
c0005454:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:35
}
c0005457:	90                   	nop
c0005458:	c9                   	leave  
c0005459:	c3                   	ret    

c000545a <wakeup>:
wakeup():
/work/x86_os_my/device/ioqueue.c:38

/* 唤醒waiter */
static void wakeup(struct task_struct** waiter) {
c000545a:	55                   	push   %ebp
c000545b:	89 e5                	mov    %esp,%ebp
c000545d:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:39
   ASSERT(*waiter != NULL);
c0005460:	8b 45 08             	mov    0x8(%ebp),%eax
c0005463:	8b 00                	mov    (%eax),%eax
c0005465:	85 c0                	test   %eax,%eax
c0005467:	75 19                	jne    c0005482 <wakeup+0x28>
/work/x86_os_my/device/ioqueue.c:39 (discriminator 1)
c0005469:	68 aa e7 00 c0       	push   $0xc000e7aa
c000546e:	68 e0 e7 00 c0       	push   $0xc000e7e0
c0005473:	6a 27                	push   $0x27
c0005475:	68 76 e7 00 c0       	push   $0xc000e776
c000547a:	e8 e2 d0 ff ff       	call   c0002561 <panic_spin>
c000547f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:40
   thread_unblock(*waiter); 
c0005482:	8b 45 08             	mov    0x8(%ebp),%eax
c0005485:	8b 00                	mov    (%eax),%eax
c0005487:	83 ec 0c             	sub    $0xc,%esp
c000548a:	50                   	push   %eax
c000548b:	e8 7f ef ff ff       	call   c000440f <thread_unblock>
c0005490:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:41
   *waiter = NULL;
c0005493:	8b 45 08             	mov    0x8(%ebp),%eax
c0005496:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/device/ioqueue.c:42
}
c000549c:	90                   	nop
c000549d:	c9                   	leave  
c000549e:	c3                   	ret    

c000549f <ioq_getchar>:
ioq_getchar():
/work/x86_os_my/device/ioqueue.c:45

/* 消费者从ioq队列中获取一个字符 */
char ioq_getchar(struct ioqueue* ioq) {
c000549f:	55                   	push   %ebp
c00054a0:	89 e5                	mov    %esp,%ebp
c00054a2:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ioqueue.c:46
   ASSERT(intr_get_status() == INTR_OFF);
c00054a5:	e8 22 c7 ff ff       	call   c0001bcc <intr_get_status>
c00054aa:	85 c0                	test   %eax,%eax
c00054ac:	74 4b                	je     c00054f9 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:46 (discriminator 1)
c00054ae:	68 58 e7 00 c0       	push   $0xc000e758
c00054b3:	68 e8 e7 00 c0       	push   $0xc000e7e8
c00054b8:	6a 2e                	push   $0x2e
c00054ba:	68 76 e7 00 c0       	push   $0xc000e776
c00054bf:	e8 9d d0 ff ff       	call   c0002561 <panic_spin>
c00054c4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51 (discriminator 1)

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c00054c7:	eb 30                	jmp    c00054f9 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:52
      lock_acquire(&ioq->lock);	 
c00054c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00054cc:	83 ec 0c             	sub    $0xc,%esp
c00054cf:	50                   	push   %eax
c00054d0:	e8 2a fa ff ff       	call   c0004eff <lock_acquire>
c00054d5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:53
      ioq_wait(&ioq->consumer);
c00054d8:	8b 45 08             	mov    0x8(%ebp),%eax
c00054db:	83 c0 20             	add    $0x20,%eax
c00054de:	83 ec 0c             	sub    $0xc,%esp
c00054e1:	50                   	push   %eax
c00054e2:	e8 29 ff ff ff       	call   c0005410 <ioq_wait>
c00054e7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:54
      lock_release(&ioq->lock);
c00054ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00054ed:	83 ec 0c             	sub    $0xc,%esp
c00054f0:	50                   	push   %eax
c00054f1:	e8 80 fa ff ff       	call   c0004f76 <lock_release>
c00054f6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c00054f9:	83 ec 0c             	sub    $0xc,%esp
c00054fc:	ff 75 08             	pushl  0x8(%ebp)
c00054ff:	e8 c8 fe ff ff       	call   c00053cc <ioq_empty>
c0005504:	83 c4 10             	add    $0x10,%esp
c0005507:	85 c0                	test   %eax,%eax
c0005509:	75 be                	jne    c00054c9 <ioq_getchar+0x2a>
/work/x86_os_my/device/ioqueue.c:57
      lock_acquire(&ioq->lock);	 
      ioq_wait(&ioq->consumer);
      lock_release(&ioq->lock);
   }

   char byte = ioq->buf[ioq->tail];	  // 从缓冲区中取出
c000550b:	8b 45 08             	mov    0x8(%ebp),%eax
c000550e:	8b 80 28 08 00 00    	mov    0x828(%eax),%eax
c0005514:	8b 55 08             	mov    0x8(%ebp),%edx
c0005517:	0f b6 44 02 24       	movzbl 0x24(%edx,%eax,1),%eax
c000551c:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ioqueue.c:58
   ioq->tail = next_pos(ioq->tail);	  // 把读游标移到下一位置
c000551f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005522:	8b 80 28 08 00 00    	mov    0x828(%eax),%eax
c0005528:	83 ec 0c             	sub    $0xc,%esp
c000552b:	50                   	push   %eax
c000552c:	e8 2a fe ff ff       	call   c000535b <next_pos>
c0005531:	83 c4 10             	add    $0x10,%esp
c0005534:	89 c2                	mov    %eax,%edx
c0005536:	8b 45 08             	mov    0x8(%ebp),%eax
c0005539:	89 90 28 08 00 00    	mov    %edx,0x828(%eax)
/work/x86_os_my/device/ioqueue.c:60

   if (ioq->producer != NULL) {
c000553f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005542:	8b 40 1c             	mov    0x1c(%eax),%eax
c0005545:	85 c0                	test   %eax,%eax
c0005547:	74 12                	je     c000555b <ioq_getchar+0xbc>
/work/x86_os_my/device/ioqueue.c:61
      wakeup(&ioq->producer);		  // 唤醒生产者
c0005549:	8b 45 08             	mov    0x8(%ebp),%eax
c000554c:	83 c0 1c             	add    $0x1c,%eax
c000554f:	83 ec 0c             	sub    $0xc,%esp
c0005552:	50                   	push   %eax
c0005553:	e8 02 ff ff ff       	call   c000545a <wakeup>
c0005558:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:64
   }

   return byte; 
c000555b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
/work/x86_os_my/device/ioqueue.c:65
}
c000555f:	c9                   	leave  
c0005560:	c3                   	ret    

c0005561 <ioq_putchar>:
ioq_putchar():
/work/x86_os_my/device/ioqueue.c:68

/* 生产者往ioq队列中写入一个字符byte */
void ioq_putchar(struct ioqueue* ioq, char byte) {
c0005561:	55                   	push   %ebp
c0005562:	89 e5                	mov    %esp,%ebp
c0005564:	83 ec 18             	sub    $0x18,%esp
c0005567:	8b 45 0c             	mov    0xc(%ebp),%eax
c000556a:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/ioqueue.c:69
   ASSERT(intr_get_status() == INTR_OFF);
c000556d:	e8 5a c6 ff ff       	call   c0001bcc <intr_get_status>
c0005572:	85 c0                	test   %eax,%eax
c0005574:	74 4b                	je     c00055c1 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:69 (discriminator 1)
c0005576:	68 58 e7 00 c0       	push   $0xc000e758
c000557b:	68 f4 e7 00 c0       	push   $0xc000e7f4
c0005580:	6a 45                	push   $0x45
c0005582:	68 76 e7 00 c0       	push   $0xc000e776
c0005587:	e8 d5 cf ff ff       	call   c0002561 <panic_spin>
c000558c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74 (discriminator 1)

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c000558f:	eb 30                	jmp    c00055c1 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:75
      lock_acquire(&ioq->lock);
c0005591:	8b 45 08             	mov    0x8(%ebp),%eax
c0005594:	83 ec 0c             	sub    $0xc,%esp
c0005597:	50                   	push   %eax
c0005598:	e8 62 f9 ff ff       	call   c0004eff <lock_acquire>
c000559d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:76
      ioq_wait(&ioq->producer);
c00055a0:	8b 45 08             	mov    0x8(%ebp),%eax
c00055a3:	83 c0 1c             	add    $0x1c,%eax
c00055a6:	83 ec 0c             	sub    $0xc,%esp
c00055a9:	50                   	push   %eax
c00055aa:	e8 61 fe ff ff       	call   c0005410 <ioq_wait>
c00055af:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:77
      lock_release(&ioq->lock);
c00055b2:	8b 45 08             	mov    0x8(%ebp),%eax
c00055b5:	83 ec 0c             	sub    $0xc,%esp
c00055b8:	50                   	push   %eax
c00055b9:	e8 b8 f9 ff ff       	call   c0004f76 <lock_release>
c00055be:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c00055c1:	83 ec 0c             	sub    $0xc,%esp
c00055c4:	ff 75 08             	pushl  0x8(%ebp)
c00055c7:	e8 ae fd ff ff       	call   c000537a <ioq_full>
c00055cc:	83 c4 10             	add    $0x10,%esp
c00055cf:	85 c0                	test   %eax,%eax
c00055d1:	75 be                	jne    c0005591 <ioq_putchar+0x30>
/work/x86_os_my/device/ioqueue.c:79
      lock_acquire(&ioq->lock);
      ioq_wait(&ioq->producer);
      lock_release(&ioq->lock);
   }
   ioq->buf[ioq->head] = byte;      // 把字节放入缓冲区中
c00055d3:	8b 45 08             	mov    0x8(%ebp),%eax
c00055d6:	8b 80 24 08 00 00    	mov    0x824(%eax),%eax
c00055dc:	8b 55 08             	mov    0x8(%ebp),%edx
c00055df:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
c00055e3:	88 4c 02 24          	mov    %cl,0x24(%edx,%eax,1)
/work/x86_os_my/device/ioqueue.c:80
   ioq->head = next_pos(ioq->head); // 把写游标移到下一位置
c00055e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00055ea:	8b 80 24 08 00 00    	mov    0x824(%eax),%eax
c00055f0:	83 ec 0c             	sub    $0xc,%esp
c00055f3:	50                   	push   %eax
c00055f4:	e8 62 fd ff ff       	call   c000535b <next_pos>
c00055f9:	83 c4 10             	add    $0x10,%esp
c00055fc:	89 c2                	mov    %eax,%edx
c00055fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0005601:	89 90 24 08 00 00    	mov    %edx,0x824(%eax)
/work/x86_os_my/device/ioqueue.c:82

   if (ioq->consumer != NULL) {
c0005607:	8b 45 08             	mov    0x8(%ebp),%eax
c000560a:	8b 40 20             	mov    0x20(%eax),%eax
c000560d:	85 c0                	test   %eax,%eax
c000560f:	74 12                	je     c0005623 <ioq_putchar+0xc2>
/work/x86_os_my/device/ioqueue.c:83
      wakeup(&ioq->consumer);          // 唤醒消费者
c0005611:	8b 45 08             	mov    0x8(%ebp),%eax
c0005614:	83 c0 20             	add    $0x20,%eax
c0005617:	83 ec 0c             	sub    $0xc,%esp
c000561a:	50                   	push   %eax
c000561b:	e8 3a fe ff ff       	call   c000545a <wakeup>
c0005620:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:85
   }
}
c0005623:	90                   	nop
c0005624:	c9                   	leave  
c0005625:	c3                   	ret    

c0005626 <ioq_length>:
ioq_length():
/work/x86_os_my/device/ioqueue.c:88

/* 返回环形缓冲区中的数据长度 */
uint32_t ioq_length(struct ioqueue* ioq) {
c0005626:	55                   	push   %ebp
c0005627:	89 e5                	mov    %esp,%ebp
c0005629:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:89
   uint32_t len = 0;
c000562c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
/work/x86_os_my/device/ioqueue.c:90
   if (ioq->head >= ioq->tail) {
c0005633:	8b 45 08             	mov    0x8(%ebp),%eax
c0005636:	8b 90 24 08 00 00    	mov    0x824(%eax),%edx
c000563c:	8b 45 08             	mov    0x8(%ebp),%eax
c000563f:	8b 80 28 08 00 00    	mov    0x828(%eax),%eax
c0005645:	39 c2                	cmp    %eax,%edx
c0005647:	7c 1b                	jl     c0005664 <ioq_length+0x3e>
/work/x86_os_my/device/ioqueue.c:91
      len = ioq->head - ioq->tail;
c0005649:	8b 45 08             	mov    0x8(%ebp),%eax
c000564c:	8b 90 24 08 00 00    	mov    0x824(%eax),%edx
c0005652:	8b 45 08             	mov    0x8(%ebp),%eax
c0005655:	8b 80 28 08 00 00    	mov    0x828(%eax),%eax
c000565b:	29 c2                	sub    %eax,%edx
c000565d:	89 d0                	mov    %edx,%eax
c000565f:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0005662:	eb 22                	jmp    c0005686 <ioq_length+0x60>
/work/x86_os_my/device/ioqueue.c:93
   } else {
      len = bufsize - (ioq->tail - ioq->head);
c0005664:	8b 45 08             	mov    0x8(%ebp),%eax
c0005667:	8b 90 28 08 00 00    	mov    0x828(%eax),%edx
c000566d:	8b 45 08             	mov    0x8(%ebp),%eax
c0005670:	8b 80 24 08 00 00    	mov    0x824(%eax),%eax
c0005676:	29 c2                	sub    %eax,%edx
c0005678:	89 d0                	mov    %edx,%eax
c000567a:	ba 00 08 00 00       	mov    $0x800,%edx
c000567f:	29 c2                	sub    %eax,%edx
c0005681:	89 d0                	mov    %edx,%eax
c0005683:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/device/ioqueue.c:95
   }
   return len;
c0005686:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/device/ioqueue.c:96
c0005689:	c9                   	leave  
c000568a:	c3                   	ret    

c000568b <update_tss_esp>:
update_tss_esp():
/work/x86_os_my/userprog/tss.c:40
	uint32_t io_base;
}; 
static struct tss g_tss;

/* 更新tss中esp0字段的值为pthread的0级栈 */
void update_tss_esp(struct task_struct* pthread) {
c000568b:	55                   	push   %ebp
c000568c:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/userprog/tss.c:41
	g_tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c000568e:	8b 45 08             	mov    0x8(%ebp),%eax
c0005691:	05 00 10 00 00       	add    $0x1000,%eax
c0005696:	a3 44 36 01 c0       	mov    %eax,0xc0013644
/work/x86_os_my/userprog/tss.c:42
}
c000569b:	90                   	nop
c000569c:	5d                   	pop    %ebp
c000569d:	c3                   	ret    

c000569e <make_gdt_desc>:
make_gdt_desc():
/work/x86_os_my/userprog/tss.c:45

/* c语言方式，创建gdt描述符 */
static struct gdt_desc make_gdt_desc(uint32_t* desc_addr, uint32_t limit, uint8_t attr_low, uint8_t attr_high) {
c000569e:	55                   	push   %ebp
c000569f:	89 e5                	mov    %esp,%ebp
c00056a1:	83 ec 18             	sub    $0x18,%esp
c00056a4:	8b 55 14             	mov    0x14(%ebp),%edx
c00056a7:	8b 45 18             	mov    0x18(%ebp),%eax
c00056aa:	88 55 ec             	mov    %dl,-0x14(%ebp)
c00056ad:	88 45 e8             	mov    %al,-0x18(%ebp)
/work/x86_os_my/userprog/tss.c:46
	uint32_t desc_base = (uint32_t)desc_addr;
c00056b0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00056b3:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/userprog/tss.c:48
	struct gdt_desc desc;
	desc.limit_low_word = limit & 0x0000ffff;
c00056b6:	8b 45 10             	mov    0x10(%ebp),%eax
c00056b9:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/userprog/tss.c:49
	desc.base_low_word = desc_base & 0x0000ffff;
c00056bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00056c0:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/userprog/tss.c:50
	desc.base_mid_byte = ((desc_base & 0x00ff0000) >> 16);
c00056c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00056c7:	25 00 00 ff 00       	and    $0xff0000,%eax
c00056cc:	c1 e8 10             	shr    $0x10,%eax
c00056cf:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/userprog/tss.c:51
	desc.attr_low_byte = (uint8_t)(attr_low);
c00056d2:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c00056d6:	88 45 f9             	mov    %al,-0x7(%ebp)
/work/x86_os_my/userprog/tss.c:52
	desc.limit_high_attr_high = (((limit & 0x000f0000) >> 16) + (uint8_t)(attr_high));
c00056d9:	8b 45 10             	mov    0x10(%ebp),%eax
c00056dc:	25 00 00 0f 00       	and    $0xf0000,%eax
c00056e1:	c1 e8 10             	shr    $0x10,%eax
c00056e4:	89 c2                	mov    %eax,%edx
c00056e6:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c00056ea:	01 d0                	add    %edx,%eax
c00056ec:	88 45 fa             	mov    %al,-0x6(%ebp)
/work/x86_os_my/userprog/tss.c:53
	desc.base_high_byte = desc_base >> 24;
c00056ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00056f2:	c1 e8 18             	shr    $0x18,%eax
c00056f5:	88 45 fb             	mov    %al,-0x5(%ebp)
/work/x86_os_my/userprog/tss.c:54
	return desc;
c00056f8:	8b 4d 08             	mov    0x8(%ebp),%ecx
c00056fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00056fe:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0005701:	89 01                	mov    %eax,(%ecx)
c0005703:	89 51 04             	mov    %edx,0x4(%ecx)
/work/x86_os_my/userprog/tss.c:55
}
c0005706:	8b 45 08             	mov    0x8(%ebp),%eax
c0005709:	c9                   	leave  
c000570a:	c2 04 00             	ret    $0x4

c000570d <tss_init>:
tss_init():
/work/x86_os_my/userprog/tss.c:61

/* 在gdt中创建tss描述符
 * 重新加载 gdt
 * 加载 tr
 */
void tss_init() {
c000570d:	55                   	push   %ebp
c000570e:	89 e5                	mov    %esp,%ebp
c0005710:	53                   	push   %ebx
c0005711:	83 ec 24             	sub    $0x24,%esp
/work/x86_os_my/userprog/tss.c:62
	put_str("tss_init start\n");
c0005714:	83 ec 0c             	sub    $0xc,%esp
c0005717:	68 00 e8 00 c0       	push   $0xc000e800
c000571c:	e8 8f cc ff ff       	call   c00023b0 <put_str>
c0005721:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:63
	uint32_t tss_size = sizeof(g_tss);
c0005724:	c7 45 f4 6c 00 00 00 	movl   $0x6c,-0xc(%ebp)
/work/x86_os_my/userprog/tss.c:64
	memset(&g_tss, 0, tss_size);
c000572b:	83 ec 04             	sub    $0x4,%esp
c000572e:	ff 75 f4             	pushl  -0xc(%ebp)
c0005731:	6a 00                	push   $0x0
c0005733:	68 40 36 01 c0       	push   $0xc0013640
c0005738:	e8 28 e3 ff ff       	call   c0003a65 <memset>
c000573d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:66
	
	g_tss.ss0 = SELECTOR_K_STACK;	// 0 级栈段的选择子 
c0005740:	c7 05 48 36 01 c0 10 	movl   $0x10,0xc0013648
c0005747:	00 00 00 
/work/x86_os_my/userprog/tss.c:67
	g_tss.io_base = tss_size;		// 当 IO 位图的偏移地址大于等于 TSS 大小减 1 时，就表示没有 IO 位图。
c000574a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000574d:	a3 a8 36 01 c0       	mov    %eax,0xc00136a8
/work/x86_os_my/userprog/tss.c:75
	 * 内核地址 0xC000_0900 是映射到 0x900 的 
	 * 在GDT中，第 0 个段描述符不可用，第 1 个为代码段，第 2 个为数据段和栈，第 3 个为显存段
	 */

	/* 在gdt中添加dpl为0的TSS描述符 */
	*((struct gdt_desc*)0xc0000920) = make_gdt_desc((uint32_t*)&g_tss, tss_size - 1, TSS_ATTR_LOW, TSS_ATTR_HIGH);
c0005752:	bb 20 09 00 c0       	mov    $0xc0000920,%ebx
c0005757:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000575a:	8d 50 ff             	lea    -0x1(%eax),%edx
c000575d:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0005760:	83 ec 0c             	sub    $0xc,%esp
c0005763:	68 80 00 00 00       	push   $0x80
c0005768:	68 89 00 00 00       	push   $0x89
c000576d:	52                   	push   %edx
c000576e:	68 40 36 01 c0       	push   $0xc0013640
c0005773:	50                   	push   %eax
c0005774:	e8 25 ff ff ff       	call   c000569e <make_gdt_desc>
c0005779:	83 c4 1c             	add    $0x1c,%esp
c000577c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000577f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0005782:	89 03                	mov    %eax,(%ebx)
c0005784:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:78

	/* 在gdt中添加dpl为3的,用户级,数据段和代码段描述符 */
	*((struct gdt_desc*)0xc0000928) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
c0005787:	bb 28 09 00 c0       	mov    $0xc0000928,%ebx
c000578c:	8d 45 e0             	lea    -0x20(%ebp),%eax
c000578f:	83 ec 0c             	sub    $0xc,%esp
c0005792:	68 c0 00 00 00       	push   $0xc0
c0005797:	68 f8 00 00 00       	push   $0xf8
c000579c:	68 ff ff 0f 00       	push   $0xfffff
c00057a1:	6a 00                	push   $0x0
c00057a3:	50                   	push   %eax
c00057a4:	e8 f5 fe ff ff       	call   c000569e <make_gdt_desc>
c00057a9:	83 c4 1c             	add    $0x1c,%esp
c00057ac:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00057af:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00057b2:	89 03                	mov    %eax,(%ebx)
c00057b4:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:79
	*((struct gdt_desc*)0xc0000930) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
c00057b7:	bb 30 09 00 c0       	mov    $0xc0000930,%ebx
c00057bc:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00057bf:	83 ec 0c             	sub    $0xc,%esp
c00057c2:	68 c0 00 00 00       	push   $0xc0
c00057c7:	68 f2 00 00 00       	push   $0xf2
c00057cc:	68 ff ff 0f 00       	push   $0xfffff
c00057d1:	6a 00                	push   $0x0
c00057d3:	50                   	push   %eax
c00057d4:	e8 c5 fe ff ff       	call   c000569e <make_gdt_desc>
c00057d9:	83 c4 1c             	add    $0x1c,%esp
c00057dc:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00057df:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00057e2:	89 03                	mov    %eax,(%ebx)
c00057e4:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:83

	/* GDTR 16位的limit、32位的段基址 */
	// 先转换成 uint32_t 后，再将其转换成 uint64_t 位（不可一步到位转为 uint64_t）
	uint64_t gdt_operand = ((8 * 7 - 1) | ((uint64_t)(uint32_t)0xc0000900 << 16));   // 7个描述符大小
c00057e7:	c7 45 e8 37 00 00 09 	movl   $0x9000037,-0x18(%ebp)
c00057ee:	c7 45 ec 00 c0 00 00 	movl   $0xc000,-0x14(%ebp)
/work/x86_os_my/userprog/tss.c:84
	asm volatile ("lgdt %0" : : "m" (gdt_operand));
c00057f5:	0f 01 55 e8          	lgdtl  -0x18(%ebp)
/work/x86_os_my/userprog/tss.c:85
	asm volatile ("ltr %w0" : : "r" (SELECTOR_TSS));
c00057f9:	b8 20 00 00 00       	mov    $0x20,%eax
c00057fe:	0f 00 d8             	ltr    %ax
/work/x86_os_my/userprog/tss.c:86
	put_str("tss_init and ltr done\n");
c0005801:	83 ec 0c             	sub    $0xc,%esp
c0005804:	68 10 e8 00 c0       	push   $0xc000e810
c0005809:	e8 a2 cb ff ff       	call   c00023b0 <put_str>
c000580e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:87
}
c0005811:	90                   	nop
c0005812:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0005815:	c9                   	leave  
c0005816:	c3                   	ret    

c0005817 <start_process>:
start_process():
/work/x86_os_my/userprog/process.c:17
extern void intr_exit(void);

/* 构建用户进程初始上下文信息
 * 填充用户进程的中断栈，并将中断栈的信息，利用iretd填充到 CPU 中
 */
void start_process(void* filename_) {
c0005817:	55                   	push   %ebp
c0005818:	89 e5                	mov    %esp,%ebp
c000581a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:18
	void* function = filename_;
c000581d:	8b 45 08             	mov    0x8(%ebp),%eax
c0005820:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:19
	struct task_struct* cur = running_thread();
c0005823:	e8 24 e6 ff ff       	call   c0003e4c <running_thread>
c0005828:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:20
	cur->self_kstack += sizeof(struct thread_stack);
c000582b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000582e:	8b 00                	mov    (%eax),%eax
c0005830:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
c0005836:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005839:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/process.c:21
	struct intr_stack* proc_stack = (struct intr_stack*)cur->self_kstack;	 
c000583b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000583e:	8b 00                	mov    (%eax),%eax
c0005840:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/userprog/process.c:22
	proc_stack->edi = proc_stack->esi = proc_stack->ebp = proc_stack->esp_dummy = 0;
c0005843:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005846:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
c000584d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005850:	8b 50 10             	mov    0x10(%eax),%edx
c0005853:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005856:	89 50 0c             	mov    %edx,0xc(%eax)
c0005859:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000585c:	8b 50 0c             	mov    0xc(%eax),%edx
c000585f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005862:	89 50 08             	mov    %edx,0x8(%eax)
c0005865:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005868:	8b 50 08             	mov    0x8(%eax),%edx
c000586b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000586e:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/userprog/process.c:23
	proc_stack->ebx = proc_stack->edx = proc_stack->ecx = proc_stack->eax = 0;
c0005871:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005874:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c000587b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000587e:	8b 50 20             	mov    0x20(%eax),%edx
c0005881:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005884:	89 50 1c             	mov    %edx,0x1c(%eax)
c0005887:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000588a:	8b 50 1c             	mov    0x1c(%eax),%edx
c000588d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005890:	89 50 18             	mov    %edx,0x18(%eax)
c0005893:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005896:	8b 50 18             	mov    0x18(%eax),%edx
c0005899:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000589c:	89 50 14             	mov    %edx,0x14(%eax)
/work/x86_os_my/userprog/process.c:28
	/* 在iretd返回时，如果发现未来的 CPL（也就是内核栈中 CS.RPL，或者说是返回到的用户进程的代码段CS.CPL）
	 * 权限低于（数值上大于） CPU 中段寄存器（如 DS、 ES、 FS、 GS）中选择子指向的内存段的 DPL，
	 * CPU 会自动将相应段寄存器的选择子置为 0 
	 * 这里gs的选择子在iretd返回后，会被自动清零。*/
	proc_stack->gs = 0;					// 用户态用不上,直接初始为0
c000589f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00058a2:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
/work/x86_os_my/userprog/process.c:29
	proc_stack->ds = proc_stack->es = proc_stack->fs = SELECTOR_U_DATA;		// 用户级数据段
c00058a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00058ac:	c7 40 28 33 00 00 00 	movl   $0x33,0x28(%eax)
c00058b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00058b6:	8b 50 28             	mov    0x28(%eax),%edx
c00058b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00058bc:	89 50 2c             	mov    %edx,0x2c(%eax)
c00058bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00058c2:	8b 50 2c             	mov    0x2c(%eax),%edx
c00058c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00058c8:	89 50 30             	mov    %edx,0x30(%eax)
/work/x86_os_my/userprog/process.c:33

	/* 中断栈中，上边几个是中断处理函数手动压栈的，下边几个是硬件自动压栈的 */

	proc_stack->eip = function;			// 待执行的用户程序地址
c00058cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00058ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00058d1:	89 50 38             	mov    %edx,0x38(%eax)
/work/x86_os_my/userprog/process.c:34
	proc_stack->cs = SELECTOR_U_CODE;	// 用户级代码段
c00058d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00058d7:	c7 40 3c 2b 00 00 00 	movl   $0x2b,0x3c(%eax)
/work/x86_os_my/userprog/process.c:35
	proc_stack->eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);
c00058de:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00058e1:	c7 40 40 02 02 00 00 	movl   $0x202,0x40(%eax)
/work/x86_os_my/userprog/process.c:44
	 * process_activate 使用户进程页表生效【已经把CR3寄存器 更新为 用户进程的页表了】
	 * start_process    为用户进程创建3特权级栈【所以申请的内存空间来自用户进程的页表】
	 * 
	 * USER_STACK3_VADDR=(0xc0000000 - 0x1000)
	 */
	proc_stack->esp = (void*)((uint32_t)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE) ;
c00058e8:	83 ec 08             	sub    $0x8,%esp
c00058eb:	68 00 f0 ff bf       	push   $0xbffff000
c00058f0:	6a 02                	push   $0x2
c00058f2:	e8 c8 d3 ff ff       	call   c0002cbf <get_a_page>
c00058f7:	83 c4 10             	add    $0x10,%esp
c00058fa:	05 00 10 00 00       	add    $0x1000,%eax
c00058ff:	89 c2                	mov    %eax,%edx
c0005901:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005904:	89 50 44             	mov    %edx,0x44(%eax)
/work/x86_os_my/userprog/process.c:45
	proc_stack->ss = SELECTOR_U_DATA;
c0005907:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000590a:	c7 40 48 33 00 00 00 	movl   $0x33,0x48(%eax)
/work/x86_os_my/userprog/process.c:52
	/* 将 esp 替换为 proc_stack
	 * 通过 jmp intr_exit 那里的一系列 pop 指令和 iretd 指令，
	 * 将 proc_stack 中的数据载入 CPU 的寄存器，
	 * 从而使程序“假装”退出中断，进入特权级 3
	 */
	asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (proc_stack) : "memory");
c0005911:	8b 65 ec             	mov    -0x14(%ebp),%esp
c0005914:	e9 37 c5 ff ff       	jmp    c0001e50 <intr_exit>
/work/x86_os_my/userprog/process.c:53
}
c0005919:	90                   	nop
c000591a:	c9                   	leave  
c000591b:	c3                   	ret    

c000591c <page_dir_activate>:
page_dir_activate():
/work/x86_os_my/userprog/process.c:56

/* 更新CR3寄存器，激活页目录表 */
void page_dir_activate(struct task_struct* p_thread) {
c000591c:	55                   	push   %ebp
c000591d:	89 e5                	mov    %esp,%ebp
c000591f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:59
	
	/* 若为"内核线程",需要重新填充页表为0x100000 */
	uint32_t pagedir_phy_addr = 0x100000;	// 默认为内核的页目录物理地址,也就是内核线程所用的页目录表
c0005922:	c7 45 f4 00 00 10 00 	movl   $0x100000,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:62
	
	/* "用户态进程"有自己的页目录表 */
	if (p_thread->pgdir != NULL) {
c0005929:	8b 45 08             	mov    0x8(%ebp),%eax
c000592c:	8b 40 54             	mov    0x54(%eax),%eax
c000592f:	85 c0                	test   %eax,%eax
c0005931:	74 15                	je     c0005948 <page_dir_activate+0x2c>
/work/x86_os_my/userprog/process.c:63
		pagedir_phy_addr = addr_v2p((uint32_t)p_thread->pgdir);
c0005933:	8b 45 08             	mov    0x8(%ebp),%eax
c0005936:	8b 40 54             	mov    0x54(%eax),%eax
c0005939:	83 ec 0c             	sub    $0xc,%esp
c000593c:	50                   	push   %eax
c000593d:	e8 77 d5 ff ff       	call   c0002eb9 <addr_v2p>
c0005942:	83 c4 10             	add    $0x10,%esp
c0005945:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:69
	}

	/* 更新页目录寄存器cr3,使新页表生效
	 * 实现进程间，虚拟地址空间的隔离。
	 */
	asm volatile ("movl %0, %%cr3" : : "r" (pagedir_phy_addr) : "memory");
c0005948:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000594b:	0f 22 d8             	mov    %eax,%cr3
/work/x86_os_my/userprog/process.c:70
}
c000594e:	90                   	nop
c000594f:	c9                   	leave  
c0005950:	c3                   	ret    

c0005951 <process_activate>:
process_activate():
/work/x86_os_my/userprog/process.c:76

/* 1.激活线程或进程的页表,【更新CR3寄存器】
 * 2.用户进程，更新tss中的esp0为进程的特权级0的栈
 * 【只有在任务调度时（中断时），才会切换页表及更新 0 级栈，因此 process_activate 是被"中断执行流"的 schedule 调用的！】
 */
void process_activate(struct task_struct* p_thread) {
c0005951:	55                   	push   %ebp
c0005952:	89 e5                	mov    %esp,%ebp
c0005954:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/process.c:77
	ASSERT(p_thread != NULL);
c0005957:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000595b:	75 19                	jne    c0005976 <process_activate+0x25>
/work/x86_os_my/userprog/process.c:77 (discriminator 1)
c000595d:	68 28 e8 00 c0       	push   $0xc000e828
c0005962:	68 e4 e8 00 c0       	push   $0xc000e8e4
c0005967:	6a 4d                	push   $0x4d
c0005969:	68 39 e8 00 c0       	push   $0xc000e839
c000596e:	e8 ee cb ff ff       	call   c0002561 <panic_spin>
c0005973:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:80
	
	/* 激活该进程或线程的页目录表【重新加载了CR3】 */
	page_dir_activate(p_thread);
c0005976:	83 ec 0c             	sub    $0xc,%esp
c0005979:	ff 75 08             	pushl  0x8(%ebp)
c000597c:	e8 9b ff ff ff       	call   c000591c <page_dir_activate>
c0005981:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:83

	/* 内核线程特权级本身就是0,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */
	if (p_thread->pgdir != NULL) {
c0005984:	8b 45 08             	mov    0x8(%ebp),%eax
c0005987:	8b 40 54             	mov    0x54(%eax),%eax
c000598a:	85 c0                	test   %eax,%eax
c000598c:	74 0e                	je     c000599c <process_activate+0x4b>
/work/x86_os_my/userprog/process.c:86
		/* 若为用户进程,更新该进程的esp0,用于此进程被中断时保留上下文 
		 * 需要从tss中获取0特权级栈地址 */
		update_tss_esp(p_thread);	//就一行：g_tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c000598e:	83 ec 0c             	sub    $0xc,%esp
c0005991:	ff 75 08             	pushl  0x8(%ebp)
c0005994:	e8 f2 fc ff ff       	call   c000568b <update_tss_esp>
c0005999:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:88
	}
}
c000599c:	90                   	nop
c000599d:	c9                   	leave  
c000599e:	c3                   	ret    

c000599f <create_page_dir>:
create_page_dir():
/work/x86_os_my/userprog/process.c:97
 * 
 * 要确保用户进程，在自己的地址空间中，能够访问到内核。
 * 即：任意进程的页目录表中，用户进程占第 0~767 个页目录项，内核占第 768~1023 个页目录项。
 * 0x300 = 768
 */
uint32_t* create_page_dir(void) {
c000599f:	55                   	push   %ebp
c00059a0:	89 e5                	mov    %esp,%ebp
c00059a2:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:100

	/* 用户进程的页表不能让用户直接访问到,所以在内核空间来申请 */
	uint32_t* page_dir_vaddr = get_kernel_pages(1);
c00059a5:	83 ec 0c             	sub    $0xc,%esp
c00059a8:	6a 01                	push   $0x1
c00059aa:	e8 5a d2 ff ff       	call   c0002c09 <get_kernel_pages>
c00059af:	83 c4 10             	add    $0x10,%esp
c00059b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:101
	if (page_dir_vaddr == NULL) {
c00059b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00059b9:	75 17                	jne    c00059d2 <create_page_dir+0x33>
/work/x86_os_my/userprog/process.c:102
		console_put_str("create_page_dir: get_kernel_page failed!");
c00059bb:	83 ec 0c             	sub    $0xc,%esp
c00059be:	68 4c e8 00 c0       	push   $0xc000e84c
c00059c3:	e8 c8 f2 ff ff       	call   c0004c90 <console_put_str>
c00059c8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:103
		return NULL;
c00059cb:	b8 00 00 00 00       	mov    $0x0,%eax
c00059d0:	eb 43                	jmp    c0005a15 <create_page_dir+0x76>
/work/x86_os_my/userprog/process.c:109
	}

	/*** 1 复制内核的页目录表  ***/
	// page_dir_vaddr + 0x300*4 是内核页目录的第768项
	// 复制的页目录项个数=1024/4
	memcpy((uint32_t*)((uint32_t)page_dir_vaddr + 0x300*4), (uint32_t*)(0xfffff000+0x300*4), 1024);
c00059d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00059d5:	05 00 0c 00 00       	add    $0xc00,%eax
c00059da:	83 ec 04             	sub    $0x4,%esp
c00059dd:	68 00 04 00 00       	push   $0x400
c00059e2:	68 00 fc ff ff       	push   $0xfffffc00
c00059e7:	50                   	push   %eax
c00059e8:	e8 ca e0 ff ff       	call   c0003ab7 <memcpy>
c00059ed:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:113

	/*** 2 更新页目录表地址 ***/
	// 页目录表地址是页目录的最后一项
	uint32_t new_page_dir_phy_addr = addr_v2p((uint32_t)page_dir_vaddr);
c00059f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00059f3:	83 ec 0c             	sub    $0xc,%esp
c00059f6:	50                   	push   %eax
c00059f7:	e8 bd d4 ff ff       	call   c0002eb9 <addr_v2p>
c00059fc:	83 c4 10             	add    $0x10,%esp
c00059ff:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:114
	page_dir_vaddr[1023] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1;
c0005a02:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005a05:	05 fc 0f 00 00       	add    $0xffc,%eax
c0005a0a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0005a0d:	83 ca 07             	or     $0x7,%edx
c0005a10:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/process.c:116

	return page_dir_vaddr;
c0005a12:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/userprog/process.c:117
}
c0005a15:	c9                   	leave  
c0005a16:	c3                   	ret    

c0005a17 <create_user_vaddr_bitmap>:
create_user_vaddr_bitmap():
/work/x86_os_my/userprog/process.c:120

/* 创建用户进程虚拟地址位图 */
void create_user_vaddr_bitmap(struct task_struct* user_prog) {
c0005a17:	55                   	push   %ebp
c0005a18:	89 e5                	mov    %esp,%ebp
c0005a1a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:121
   user_prog->userprog_vaddr.vaddr_start = USER_VADDR_START;	// linux用户程序入口地址 0x80480000
c0005a1d:	8b 45 08             	mov    0x8(%ebp),%eax
c0005a20:	c7 40 60 00 80 04 08 	movl   $0x8048000,0x60(%eax)
/work/x86_os_my/userprog/process.c:122
   uint32_t bitmap_pg_cnt = DIV_ROUND_UP((0xc0000000 - USER_VADDR_START) / PG_SIZE / 8 , PG_SIZE);
c0005a27:	c7 45 f4 17 00 00 00 	movl   $0x17,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:123
   user_prog->userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt);
c0005a2e:	83 ec 0c             	sub    $0xc,%esp
c0005a31:	ff 75 f4             	pushl  -0xc(%ebp)
c0005a34:	e8 d0 d1 ff ff       	call   c0002c09 <get_kernel_pages>
c0005a39:	83 c4 10             	add    $0x10,%esp
c0005a3c:	89 c2                	mov    %eax,%edx
c0005a3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0005a41:	89 50 5c             	mov    %edx,0x5c(%eax)
/work/x86_os_my/userprog/process.c:124
   user_prog->userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (0xc0000000 - USER_VADDR_START) / PG_SIZE / 8;
c0005a44:	8b 45 08             	mov    0x8(%ebp),%eax
c0005a47:	c7 40 58 f7 6f 01 00 	movl   $0x16ff7,0x58(%eax)
/work/x86_os_my/userprog/process.c:125
   bitmap_init(&user_prog->userprog_vaddr.vaddr_bitmap);
c0005a4e:	8b 45 08             	mov    0x8(%ebp),%eax
c0005a51:	83 c0 58             	add    $0x58,%eax
c0005a54:	83 ec 0c             	sub    $0xc,%esp
c0005a57:	50                   	push   %eax
c0005a58:	e8 da cb ff ff       	call   c0002637 <bitmap_init>
c0005a5d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:126
}
c0005a60:	90                   	nop
c0005a61:	c9                   	leave  
c0005a62:	c3                   	ret    

c0005a63 <process_execute>:
process_execute():
/work/x86_os_my/userprog/process.c:129

/* 创建用户进程 */
void process_execute(void* filename, char* name) {
c0005a63:	55                   	push   %ebp
c0005a64:	89 e5                	mov    %esp,%ebp
c0005a66:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:131
   /* pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 */
   struct task_struct* thread = get_kernel_pages(1);
c0005a69:	83 ec 0c             	sub    $0xc,%esp
c0005a6c:	6a 01                	push   $0x1
c0005a6e:	e8 96 d1 ff ff       	call   c0002c09 <get_kernel_pages>
c0005a73:	83 c4 10             	add    $0x10,%esp
c0005a76:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:132
   init_thread(thread, name, default_prio);			//初始化线程PCB结构体 struct task_struct
c0005a79:	83 ec 04             	sub    $0x4,%esp
c0005a7c:	6a 1f                	push   $0x1f
c0005a7e:	ff 75 0c             	pushl  0xc(%ebp)
c0005a81:	ff 75 f4             	pushl  -0xc(%ebp)
c0005a84:	e8 74 e5 ff ff       	call   c0003ffd <init_thread>
c0005a89:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:133
   create_user_vaddr_bitmap(thread);				//【进程新增】创建用户进程，虚拟地址空间位图
c0005a8c:	83 ec 0c             	sub    $0xc,%esp
c0005a8f:	ff 75 f4             	pushl  -0xc(%ebp)
c0005a92:	e8 80 ff ff ff       	call   c0005a17 <create_user_vaddr_bitmap>
c0005a97:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:134
   thread_create(thread, start_process, filename);	//初始化线程栈结构体 struct thread_stack
c0005a9a:	83 ec 04             	sub    $0x4,%esp
c0005a9d:	ff 75 08             	pushl  0x8(%ebp)
c0005aa0:	68 17 58 00 c0       	push   $0xc0005817
c0005aa5:	ff 75 f4             	pushl  -0xc(%ebp)
c0005aa8:	e8 d9 e4 ff ff       	call   c0003f86 <thread_create>
c0005aad:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:135
   thread->pgdir = create_page_dir();				//【进程新增】创建用户进程，页目录表
c0005ab0:	e8 ea fe ff ff       	call   c000599f <create_page_dir>
c0005ab5:	89 c2                	mov    %eax,%edx
c0005ab7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005aba:	89 50 54             	mov    %edx,0x54(%eax)
/work/x86_os_my/userprog/process.c:136
   block_desc_init(thread->u_block_desc);
c0005abd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005ac0:	83 c0 64             	add    $0x64,%eax
c0005ac3:	83 ec 0c             	sub    $0xc,%esp
c0005ac6:	50                   	push   %eax
c0005ac7:	e8 53 de ff ff       	call   c000391f <block_desc_init>
c0005acc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:138
   
   enum intr_status old_status = intr_disable();
c0005acf:	e8 b1 c0 ff ff       	call   c0001b85 <intr_disable>
c0005ad4:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:139
   ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));
c0005ad7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005ada:	83 c0 44             	add    $0x44,%eax
c0005add:	83 ec 08             	sub    $0x8,%esp
c0005ae0:	50                   	push   %eax
c0005ae1:	68 a8 42 01 c0       	push   $0xc00142a8
c0005ae6:	e8 59 f0 ff ff       	call   c0004b44 <elem_find>
c0005aeb:	83 c4 10             	add    $0x10,%esp
c0005aee:	85 c0                	test   %eax,%eax
c0005af0:	74 1c                	je     c0005b0e <process_execute+0xab>
/work/x86_os_my/userprog/process.c:139 (discriminator 1)
c0005af2:	68 78 e8 00 c0       	push   $0xc000e878
c0005af7:	68 f8 e8 00 c0       	push   $0xc000e8f8
c0005afc:	68 8b 00 00 00       	push   $0x8b
c0005b01:	68 39 e8 00 c0       	push   $0xc000e839
c0005b06:	e8 56 ca ff ff       	call   c0002561 <panic_spin>
c0005b0b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:140
   list_append(&thread_ready_list, &thread->general_tag);
c0005b0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005b11:	83 c0 44             	add    $0x44,%eax
c0005b14:	83 ec 08             	sub    $0x8,%esp
c0005b17:	50                   	push   %eax
c0005b18:	68 a8 42 01 c0       	push   $0xc00142a8
c0005b1d:	e8 a8 ef ff ff       	call   c0004aca <list_append>
c0005b22:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:141
   ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
c0005b25:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005b28:	83 c0 4c             	add    $0x4c,%eax
c0005b2b:	83 ec 08             	sub    $0x8,%esp
c0005b2e:	50                   	push   %eax
c0005b2f:	68 b8 42 01 c0       	push   $0xc00142b8
c0005b34:	e8 0b f0 ff ff       	call   c0004b44 <elem_find>
c0005b39:	83 c4 10             	add    $0x10,%esp
c0005b3c:	85 c0                	test   %eax,%eax
c0005b3e:	74 1c                	je     c0005b5c <process_execute+0xf9>
/work/x86_os_my/userprog/process.c:141 (discriminator 1)
c0005b40:	68 b0 e8 00 c0       	push   $0xc000e8b0
c0005b45:	68 f8 e8 00 c0       	push   $0xc000e8f8
c0005b4a:	68 8d 00 00 00       	push   $0x8d
c0005b4f:	68 39 e8 00 c0       	push   $0xc000e839
c0005b54:	e8 08 ca ff ff       	call   c0002561 <panic_spin>
c0005b59:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:142
   list_append(&thread_all_list, &thread->all_list_tag);
c0005b5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005b5f:	83 c0 4c             	add    $0x4c,%eax
c0005b62:	83 ec 08             	sub    $0x8,%esp
c0005b65:	50                   	push   %eax
c0005b66:	68 b8 42 01 c0       	push   $0xc00142b8
c0005b6b:	e8 5a ef ff ff       	call   c0004aca <list_append>
c0005b70:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:143
   intr_set_status(old_status);
c0005b73:	83 ec 0c             	sub    $0xc,%esp
c0005b76:	ff 75 f0             	pushl  -0x10(%ebp)
c0005b79:	e8 30 c0 ff ff       	call   c0001bae <intr_set_status>
c0005b7e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:144
}
c0005b81:	90                   	nop
c0005b82:	c9                   	leave  
c0005b83:	c3                   	ret    

c0005b84 <getpid>:
getpid():
/work/x86_os_my/lib/user/syscall.c:52
   );							       \
   retval;						       \
})

/* 返回当前任务pid */
uint32_t getpid() {
c0005b84:	55                   	push   %ebp
c0005b85:	89 e5                	mov    %esp,%ebp
c0005b87:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:53
	return _syscall0(SYS_GETPID);
c0005b8a:	b8 00 00 00 00       	mov    $0x0,%eax
c0005b8f:	cd 80                	int    $0x80
c0005b91:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0005b94:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:54
}
c0005b97:	c9                   	leave  
c0005b98:	c3                   	ret    

c0005b99 <write>:
write():
/work/x86_os_my/lib/user/syscall.c:57

/* 把buf中count个字符写入文件描述符fd */
uint32_t write(int32_t fd, const void* buf, uint32_t count) {
c0005b99:	55                   	push   %ebp
c0005b9a:	89 e5                	mov    %esp,%ebp
c0005b9c:	53                   	push   %ebx
c0005b9d:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:58
	return _syscall3(SYS_WRITE, fd, buf, count);
c0005ba0:	b8 01 00 00 00       	mov    $0x1,%eax
c0005ba5:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0005ba8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0005bab:	8b 55 10             	mov    0x10(%ebp),%edx
c0005bae:	cd 80                	int    $0x80
c0005bb0:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005bb3:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:59
}
c0005bb6:	83 c4 10             	add    $0x10,%esp
c0005bb9:	5b                   	pop    %ebx
c0005bba:	5d                   	pop    %ebp
c0005bbb:	c3                   	ret    

c0005bbc <malloc>:
malloc():
/work/x86_os_my/lib/user/syscall.c:62

/* 申请size字节大小的内存,并返回结果 */
void* malloc(uint32_t size) {
c0005bbc:	55                   	push   %ebp
c0005bbd:	89 e5                	mov    %esp,%ebp
c0005bbf:	53                   	push   %ebx
c0005bc0:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:63
	return (void*)_syscall1(SYS_MALLOC, size);
c0005bc3:	b8 02 00 00 00       	mov    $0x2,%eax
c0005bc8:	8b 55 08             	mov    0x8(%ebp),%edx
c0005bcb:	89 d3                	mov    %edx,%ebx
c0005bcd:	cd 80                	int    $0x80
c0005bcf:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005bd2:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:64
}
c0005bd5:	83 c4 10             	add    $0x10,%esp
c0005bd8:	5b                   	pop    %ebx
c0005bd9:	5d                   	pop    %ebp
c0005bda:	c3                   	ret    

c0005bdb <free>:
free():
/work/x86_os_my/lib/user/syscall.c:67

/* 释放ptr指向的内存 */
void free(void* ptr) {
c0005bdb:	55                   	push   %ebp
c0005bdc:	89 e5                	mov    %esp,%ebp
c0005bde:	53                   	push   %ebx
c0005bdf:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:68
	_syscall1(SYS_FREE, ptr);
c0005be2:	b8 03 00 00 00       	mov    $0x3,%eax
c0005be7:	8b 55 08             	mov    0x8(%ebp),%edx
c0005bea:	89 d3                	mov    %edx,%ebx
c0005bec:	cd 80                	int    $0x80
c0005bee:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/lib/user/syscall.c:69
}
c0005bf1:	90                   	nop
c0005bf2:	83 c4 10             	add    $0x10,%esp
c0005bf5:	5b                   	pop    %ebx
c0005bf6:	5d                   	pop    %ebp
c0005bf7:	c3                   	ret    

c0005bf8 <fork>:
fork():
/work/x86_os_my/lib/user/syscall.c:72

/* 派生子进程,返回子进程pid */
pid_t fork(void){
c0005bf8:	55                   	push   %ebp
c0005bf9:	89 e5                	mov    %esp,%ebp
c0005bfb:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:73
	return _syscall0(SYS_FORK);
c0005bfe:	b8 04 00 00 00       	mov    $0x4,%eax
c0005c03:	cd 80                	int    $0x80
c0005c05:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0005c08:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:74
}
c0005c0b:	c9                   	leave  
c0005c0c:	c3                   	ret    

c0005c0d <read>:
read():
/work/x86_os_my/lib/user/syscall.c:77

/* 从文件描述符fd中读取count个字节到buf */
int32_t read(int32_t fd, void* buf, uint32_t count) {
c0005c0d:	55                   	push   %ebp
c0005c0e:	89 e5                	mov    %esp,%ebp
c0005c10:	53                   	push   %ebx
c0005c11:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:78
	return _syscall3(SYS_READ, fd, buf, count);
c0005c14:	b8 05 00 00 00       	mov    $0x5,%eax
c0005c19:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0005c1c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0005c1f:	8b 55 10             	mov    0x10(%ebp),%edx
c0005c22:	cd 80                	int    $0x80
c0005c24:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005c27:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:79
}
c0005c2a:	83 c4 10             	add    $0x10,%esp
c0005c2d:	5b                   	pop    %ebx
c0005c2e:	5d                   	pop    %ebp
c0005c2f:	c3                   	ret    

c0005c30 <putchar>:
putchar():
/work/x86_os_my/lib/user/syscall.c:82

/* 输出一个字符 */
void putchar(char char_asci) {
c0005c30:	55                   	push   %ebp
c0005c31:	89 e5                	mov    %esp,%ebp
c0005c33:	53                   	push   %ebx
c0005c34:	83 ec 14             	sub    $0x14,%esp
c0005c37:	8b 45 08             	mov    0x8(%ebp),%eax
c0005c3a:	88 45 e8             	mov    %al,-0x18(%ebp)
/work/x86_os_my/lib/user/syscall.c:83
	_syscall1(SYS_PUTCHAR, char_asci);
c0005c3d:	b8 06 00 00 00       	mov    $0x6,%eax
c0005c42:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
c0005c46:	89 d3                	mov    %edx,%ebx
c0005c48:	cd 80                	int    $0x80
c0005c4a:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/lib/user/syscall.c:84
}
c0005c4d:	90                   	nop
c0005c4e:	83 c4 14             	add    $0x14,%esp
c0005c51:	5b                   	pop    %ebx
c0005c52:	5d                   	pop    %ebp
c0005c53:	c3                   	ret    

c0005c54 <clear>:
clear():
/work/x86_os_my/lib/user/syscall.c:87

/* 清空屏幕 */
void clear(void) {
c0005c54:	55                   	push   %ebp
c0005c55:	89 e5                	mov    %esp,%ebp
c0005c57:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:88
	_syscall0(SYS_CLEAR);
c0005c5a:	b8 07 00 00 00       	mov    $0x7,%eax
c0005c5f:	cd 80                	int    $0x80
c0005c61:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/user/syscall.c:89
}
c0005c64:	90                   	nop
c0005c65:	c9                   	leave  
c0005c66:	c3                   	ret    

c0005c67 <getcwd>:
getcwd():
/work/x86_os_my/lib/user/syscall.c:92

/* 获取当前工作目录 */
char* getcwd(char* buf, uint32_t size) {
c0005c67:	55                   	push   %ebp
c0005c68:	89 e5                	mov    %esp,%ebp
c0005c6a:	53                   	push   %ebx
c0005c6b:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:93
	return (char*)_syscall2(SYS_GETCWD, buf, size);
c0005c6e:	b8 08 00 00 00       	mov    $0x8,%eax
c0005c73:	8b 55 08             	mov    0x8(%ebp),%edx
c0005c76:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0005c79:	89 d3                	mov    %edx,%ebx
c0005c7b:	cd 80                	int    $0x80
c0005c7d:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005c80:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:94
}
c0005c83:	83 c4 10             	add    $0x10,%esp
c0005c86:	5b                   	pop    %ebx
c0005c87:	5d                   	pop    %ebp
c0005c88:	c3                   	ret    

c0005c89 <open>:
open():
/work/x86_os_my/lib/user/syscall.c:97

/* 以flag方式打开文件pathname */
int32_t open(char* pathname, uint8_t flag) {
c0005c89:	55                   	push   %ebp
c0005c8a:	89 e5                	mov    %esp,%ebp
c0005c8c:	53                   	push   %ebx
c0005c8d:	83 ec 14             	sub    $0x14,%esp
c0005c90:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005c93:	88 45 e8             	mov    %al,-0x18(%ebp)
/work/x86_os_my/lib/user/syscall.c:98
	return _syscall2(SYS_OPEN, pathname, flag);
c0005c96:	b8 09 00 00 00       	mov    $0x9,%eax
c0005c9b:	8b 55 08             	mov    0x8(%ebp),%edx
c0005c9e:	0f b6 4d e8          	movzbl -0x18(%ebp),%ecx
c0005ca2:	89 d3                	mov    %edx,%ebx
c0005ca4:	cd 80                	int    $0x80
c0005ca6:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005ca9:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:99
}
c0005cac:	83 c4 14             	add    $0x14,%esp
c0005caf:	5b                   	pop    %ebx
c0005cb0:	5d                   	pop    %ebp
c0005cb1:	c3                   	ret    

c0005cb2 <close>:
close():
/work/x86_os_my/lib/user/syscall.c:102

/* 关闭文件fd */
int32_t close(int32_t fd) {
c0005cb2:	55                   	push   %ebp
c0005cb3:	89 e5                	mov    %esp,%ebp
c0005cb5:	53                   	push   %ebx
c0005cb6:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:103
	return _syscall1(SYS_CLOSE, fd);
c0005cb9:	b8 0a 00 00 00       	mov    $0xa,%eax
c0005cbe:	8b 55 08             	mov    0x8(%ebp),%edx
c0005cc1:	89 d3                	mov    %edx,%ebx
c0005cc3:	cd 80                	int    $0x80
c0005cc5:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005cc8:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:104
}
c0005ccb:	83 c4 10             	add    $0x10,%esp
c0005cce:	5b                   	pop    %ebx
c0005ccf:	5d                   	pop    %ebp
c0005cd0:	c3                   	ret    

c0005cd1 <lseek>:
lseek():
/work/x86_os_my/lib/user/syscall.c:107

/* 设置文件偏移量 */
int32_t lseek(int32_t fd, int32_t offset, uint8_t whence) {
c0005cd1:	55                   	push   %ebp
c0005cd2:	89 e5                	mov    %esp,%ebp
c0005cd4:	53                   	push   %ebx
c0005cd5:	83 ec 14             	sub    $0x14,%esp
c0005cd8:	8b 45 10             	mov    0x10(%ebp),%eax
c0005cdb:	88 45 e8             	mov    %al,-0x18(%ebp)
/work/x86_os_my/lib/user/syscall.c:108
	return _syscall3(SYS_LSEEK, fd, offset, whence);
c0005cde:	b8 0b 00 00 00       	mov    $0xb,%eax
c0005ce3:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0005ce6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0005ce9:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
c0005ced:	cd 80                	int    $0x80
c0005cef:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005cf2:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:109
}
c0005cf5:	83 c4 14             	add    $0x14,%esp
c0005cf8:	5b                   	pop    %ebx
c0005cf9:	5d                   	pop    %ebp
c0005cfa:	c3                   	ret    

c0005cfb <unlink>:
unlink():
/work/x86_os_my/lib/user/syscall.c:112

/* 删除文件pathname */
int32_t unlink(const char* pathname) {
c0005cfb:	55                   	push   %ebp
c0005cfc:	89 e5                	mov    %esp,%ebp
c0005cfe:	53                   	push   %ebx
c0005cff:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:113
	return _syscall1(SYS_UNLINK, pathname);
c0005d02:	b8 0c 00 00 00       	mov    $0xc,%eax
c0005d07:	8b 55 08             	mov    0x8(%ebp),%edx
c0005d0a:	89 d3                	mov    %edx,%ebx
c0005d0c:	cd 80                	int    $0x80
c0005d0e:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005d11:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:114
}
c0005d14:	83 c4 10             	add    $0x10,%esp
c0005d17:	5b                   	pop    %ebx
c0005d18:	5d                   	pop    %ebp
c0005d19:	c3                   	ret    

c0005d1a <mkdir>:
mkdir():
/work/x86_os_my/lib/user/syscall.c:117

/* 创建目录pathname */
int32_t mkdir(const char* pathname) {
c0005d1a:	55                   	push   %ebp
c0005d1b:	89 e5                	mov    %esp,%ebp
c0005d1d:	53                   	push   %ebx
c0005d1e:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:118
	return _syscall1(SYS_MKDIR, pathname);
c0005d21:	b8 0d 00 00 00       	mov    $0xd,%eax
c0005d26:	8b 55 08             	mov    0x8(%ebp),%edx
c0005d29:	89 d3                	mov    %edx,%ebx
c0005d2b:	cd 80                	int    $0x80
c0005d2d:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005d30:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:119
}
c0005d33:	83 c4 10             	add    $0x10,%esp
c0005d36:	5b                   	pop    %ebx
c0005d37:	5d                   	pop    %ebp
c0005d38:	c3                   	ret    

c0005d39 <opendir>:
opendir():
/work/x86_os_my/lib/user/syscall.c:122

/* 打开目录name */
struct dir* opendir(const char* name) {
c0005d39:	55                   	push   %ebp
c0005d3a:	89 e5                	mov    %esp,%ebp
c0005d3c:	53                   	push   %ebx
c0005d3d:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:123
	return (struct dir*)_syscall1(SYS_OPENDIR, name);
c0005d40:	b8 0e 00 00 00       	mov    $0xe,%eax
c0005d45:	8b 55 08             	mov    0x8(%ebp),%edx
c0005d48:	89 d3                	mov    %edx,%ebx
c0005d4a:	cd 80                	int    $0x80
c0005d4c:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005d4f:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:124
}
c0005d52:	83 c4 10             	add    $0x10,%esp
c0005d55:	5b                   	pop    %ebx
c0005d56:	5d                   	pop    %ebp
c0005d57:	c3                   	ret    

c0005d58 <closedir>:
closedir():
/work/x86_os_my/lib/user/syscall.c:127

/* 关闭目录dir */
int32_t closedir(struct dir* dir) {
c0005d58:	55                   	push   %ebp
c0005d59:	89 e5                	mov    %esp,%ebp
c0005d5b:	53                   	push   %ebx
c0005d5c:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:128
	return _syscall1(SYS_CLOSEDIR, dir);
c0005d5f:	b8 0f 00 00 00       	mov    $0xf,%eax
c0005d64:	8b 55 08             	mov    0x8(%ebp),%edx
c0005d67:	89 d3                	mov    %edx,%ebx
c0005d69:	cd 80                	int    $0x80
c0005d6b:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005d6e:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:129
}
c0005d71:	83 c4 10             	add    $0x10,%esp
c0005d74:	5b                   	pop    %ebx
c0005d75:	5d                   	pop    %ebp
c0005d76:	c3                   	ret    

c0005d77 <rmdir>:
rmdir():
/work/x86_os_my/lib/user/syscall.c:132

/* 删除目录pathname */
int32_t rmdir(const char* pathname) {
c0005d77:	55                   	push   %ebp
c0005d78:	89 e5                	mov    %esp,%ebp
c0005d7a:	53                   	push   %ebx
c0005d7b:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:133
	return _syscall1(SYS_RMDIR, pathname);
c0005d7e:	b8 11 00 00 00       	mov    $0x11,%eax
c0005d83:	8b 55 08             	mov    0x8(%ebp),%edx
c0005d86:	89 d3                	mov    %edx,%ebx
c0005d88:	cd 80                	int    $0x80
c0005d8a:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005d8d:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:134
}
c0005d90:	83 c4 10             	add    $0x10,%esp
c0005d93:	5b                   	pop    %ebx
c0005d94:	5d                   	pop    %ebp
c0005d95:	c3                   	ret    

c0005d96 <readdir>:
readdir():
/work/x86_os_my/lib/user/syscall.c:137

/* 读取目录dir */
struct dir_entry* readdir(struct dir* dir) {
c0005d96:	55                   	push   %ebp
c0005d97:	89 e5                	mov    %esp,%ebp
c0005d99:	53                   	push   %ebx
c0005d9a:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:138
	return (struct dir_entry*)_syscall1(SYS_READDIR, dir);
c0005d9d:	b8 12 00 00 00       	mov    $0x12,%eax
c0005da2:	8b 55 08             	mov    0x8(%ebp),%edx
c0005da5:	89 d3                	mov    %edx,%ebx
c0005da7:	cd 80                	int    $0x80
c0005da9:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005dac:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:139
}
c0005daf:	83 c4 10             	add    $0x10,%esp
c0005db2:	5b                   	pop    %ebx
c0005db3:	5d                   	pop    %ebp
c0005db4:	c3                   	ret    

c0005db5 <rewinddir>:
rewinddir():
/work/x86_os_my/lib/user/syscall.c:142

/* 回归目录指针 */
void rewinddir(struct dir* dir) {
c0005db5:	55                   	push   %ebp
c0005db6:	89 e5                	mov    %esp,%ebp
c0005db8:	53                   	push   %ebx
c0005db9:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:143
	_syscall1(SYS_REWINDDIR, dir);
c0005dbc:	b8 13 00 00 00       	mov    $0x13,%eax
c0005dc1:	8b 55 08             	mov    0x8(%ebp),%edx
c0005dc4:	89 d3                	mov    %edx,%ebx
c0005dc6:	cd 80                	int    $0x80
c0005dc8:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/lib/user/syscall.c:144
}
c0005dcb:	90                   	nop
c0005dcc:	83 c4 10             	add    $0x10,%esp
c0005dcf:	5b                   	pop    %ebx
c0005dd0:	5d                   	pop    %ebp
c0005dd1:	c3                   	ret    

c0005dd2 <stat>:
stat():
/work/x86_os_my/lib/user/syscall.c:147

/* 获取path属性到buf中 */
int32_t stat(const char* path, struct stat* buf) {
c0005dd2:	55                   	push   %ebp
c0005dd3:	89 e5                	mov    %esp,%ebp
c0005dd5:	53                   	push   %ebx
c0005dd6:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:148
	return _syscall2(SYS_STAT, path, buf);
c0005dd9:	b8 14 00 00 00       	mov    $0x14,%eax
c0005dde:	8b 55 08             	mov    0x8(%ebp),%edx
c0005de1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0005de4:	89 d3                	mov    %edx,%ebx
c0005de6:	cd 80                	int    $0x80
c0005de8:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005deb:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:149
}
c0005dee:	83 c4 10             	add    $0x10,%esp
c0005df1:	5b                   	pop    %ebx
c0005df2:	5d                   	pop    %ebp
c0005df3:	c3                   	ret    

c0005df4 <chdir>:
chdir():
/work/x86_os_my/lib/user/syscall.c:152

/* 改变工作目录为path */
int32_t chdir(const char* path) {
c0005df4:	55                   	push   %ebp
c0005df5:	89 e5                	mov    %esp,%ebp
c0005df7:	53                   	push   %ebx
c0005df8:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:153
	return _syscall1(SYS_CHDIR, path);
c0005dfb:	b8 10 00 00 00       	mov    $0x10,%eax
c0005e00:	8b 55 08             	mov    0x8(%ebp),%edx
c0005e03:	89 d3                	mov    %edx,%ebx
c0005e05:	cd 80                	int    $0x80
c0005e07:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005e0a:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:154
}
c0005e0d:	83 c4 10             	add    $0x10,%esp
c0005e10:	5b                   	pop    %ebx
c0005e11:	5d                   	pop    %ebp
c0005e12:	c3                   	ret    

c0005e13 <ps>:
ps():
/work/x86_os_my/lib/user/syscall.c:157

/* 显示任务列表 */
void ps(void) {
c0005e13:	55                   	push   %ebp
c0005e14:	89 e5                	mov    %esp,%ebp
c0005e16:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:158
	_syscall0(SYS_PS);
c0005e19:	b8 15 00 00 00       	mov    $0x15,%eax
c0005e1e:	cd 80                	int    $0x80
c0005e20:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/user/syscall.c:159
}
c0005e23:	90                   	nop
c0005e24:	c9                   	leave  
c0005e25:	c3                   	ret    

c0005e26 <execv>:
execv():
/work/x86_os_my/lib/user/syscall.c:162

/* 执行pathname */
int32_t execv(const char* pathname, char** argv) {
c0005e26:	55                   	push   %ebp
c0005e27:	89 e5                	mov    %esp,%ebp
c0005e29:	53                   	push   %ebx
c0005e2a:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:163
	return _syscall2(SYS_EXECV, pathname, argv);
c0005e2d:	b8 16 00 00 00       	mov    $0x16,%eax
c0005e32:	8b 55 08             	mov    0x8(%ebp),%edx
c0005e35:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0005e38:	89 d3                	mov    %edx,%ebx
c0005e3a:	cd 80                	int    $0x80
c0005e3c:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005e3f:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:164
}
c0005e42:	83 c4 10             	add    $0x10,%esp
c0005e45:	5b                   	pop    %ebx
c0005e46:	5d                   	pop    %ebp
c0005e47:	c3                   	ret    

c0005e48 <exit>:
exit():
/work/x86_os_my/lib/user/syscall.c:167

/* 以状态status退出 */
void exit(int32_t status) {
c0005e48:	55                   	push   %ebp
c0005e49:	89 e5                	mov    %esp,%ebp
c0005e4b:	53                   	push   %ebx
c0005e4c:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:168
	_syscall1(SYS_EXIT, status);
c0005e4f:	b8 17 00 00 00       	mov    $0x17,%eax
c0005e54:	8b 55 08             	mov    0x8(%ebp),%edx
c0005e57:	89 d3                	mov    %edx,%ebx
c0005e59:	cd 80                	int    $0x80
c0005e5b:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/lib/user/syscall.c:169
}
c0005e5e:	90                   	nop
c0005e5f:	83 c4 10             	add    $0x10,%esp
c0005e62:	5b                   	pop    %ebx
c0005e63:	5d                   	pop    %ebp
c0005e64:	c3                   	ret    

c0005e65 <wait>:
wait():
/work/x86_os_my/lib/user/syscall.c:172

/* 等待子进程,子进程状态存储到status */
pid_t wait(int32_t* status) {
c0005e65:	55                   	push   %ebp
c0005e66:	89 e5                	mov    %esp,%ebp
c0005e68:	53                   	push   %ebx
c0005e69:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:173
	return _syscall1(SYS_WAIT, status);
c0005e6c:	b8 18 00 00 00       	mov    $0x18,%eax
c0005e71:	8b 55 08             	mov    0x8(%ebp),%edx
c0005e74:	89 d3                	mov    %edx,%ebx
c0005e76:	cd 80                	int    $0x80
c0005e78:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005e7b:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:174
}
c0005e7e:	83 c4 10             	add    $0x10,%esp
c0005e81:	5b                   	pop    %ebx
c0005e82:	5d                   	pop    %ebp
c0005e83:	c3                   	ret    

c0005e84 <pipe>:
pipe():
/work/x86_os_my/lib/user/syscall.c:177

/* 生成管道,pipefd[0]负责读入管道,pipefd[1]负责写入管道 */
int32_t pipe(int32_t pipefd[2]) {
c0005e84:	55                   	push   %ebp
c0005e85:	89 e5                	mov    %esp,%ebp
c0005e87:	53                   	push   %ebx
c0005e88:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:178
	return _syscall1(SYS_PIPE, pipefd);
c0005e8b:	b8 19 00 00 00       	mov    $0x19,%eax
c0005e90:	8b 55 08             	mov    0x8(%ebp),%edx
c0005e93:	89 d3                	mov    %edx,%ebx
c0005e95:	cd 80                	int    $0x80
c0005e97:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005e9a:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:179
}
c0005e9d:	83 c4 10             	add    $0x10,%esp
c0005ea0:	5b                   	pop    %ebx
c0005ea1:	5d                   	pop    %ebp
c0005ea2:	c3                   	ret    

c0005ea3 <fd_redirect>:
fd_redirect():
/work/x86_os_my/lib/user/syscall.c:182

/* 将文件描述符old_local_fd重定向到new_local_fd */
void fd_redirect(uint32_t old_local_fd, uint32_t new_local_fd) {
c0005ea3:	55                   	push   %ebp
c0005ea4:	89 e5                	mov    %esp,%ebp
c0005ea6:	53                   	push   %ebx
c0005ea7:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:183
	_syscall2(SYS_FD_REDIRECT, old_local_fd, new_local_fd);
c0005eaa:	b8 1a 00 00 00       	mov    $0x1a,%eax
c0005eaf:	8b 55 08             	mov    0x8(%ebp),%edx
c0005eb2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0005eb5:	89 d3                	mov    %edx,%ebx
c0005eb7:	cd 80                	int    $0x80
c0005eb9:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/lib/user/syscall.c:184
}
c0005ebc:	90                   	nop
c0005ebd:	83 c4 10             	add    $0x10,%esp
c0005ec0:	5b                   	pop    %ebx
c0005ec1:	5d                   	pop    %ebp
c0005ec2:	c3                   	ret    

c0005ec3 <help>:
help():
/work/x86_os_my/lib/user/syscall.c:187

/* 显示系统支持的命令 */
void help(void) {
c0005ec3:	55                   	push   %ebp
c0005ec4:	89 e5                	mov    %esp,%ebp
c0005ec6:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:188
	_syscall0(SYS_HELP);
c0005ec9:	b8 1b 00 00 00       	mov    $0x1b,%eax
c0005ece:	cd 80                	int    $0x80
c0005ed0:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/user/syscall.c:189
}
c0005ed3:	90                   	nop
c0005ed4:	c9                   	leave  
c0005ed5:	c3                   	ret    

c0005ed6 <sys_getpid>:
sys_getpid():
/work/x86_os_my/userprog/syscall-init.c:20
#define syscall_nr 32 
typedef void* syscall;
syscall syscall_table[syscall_nr];

/* 返回当前任务的pid */
uint32_t sys_getpid(void) {
c0005ed6:	55                   	push   %ebp
c0005ed7:	89 e5                	mov    %esp,%ebp
c0005ed9:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/syscall-init.c:21
	return running_thread()->pid;
c0005edc:	e8 6b df ff ff       	call   c0003e4c <running_thread>
c0005ee1:	0f b7 40 04          	movzwl 0x4(%eax),%eax
c0005ee5:	98                   	cwtl   
/work/x86_os_my/userprog/syscall-init.c:22
}
c0005ee6:	c9                   	leave  
c0005ee7:	c3                   	ret    

c0005ee8 <syscall_init>:
syscall_init():
/work/x86_os_my/userprog/syscall-init.c:25

/* 初始化系统调用 */
void syscall_init(void) {
c0005ee8:	55                   	push   %ebp
c0005ee9:	89 e5                	mov    %esp,%ebp
c0005eeb:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/syscall-init.c:26
	put_str("syscall_init start\n");
c0005eee:	83 ec 0c             	sub    $0xc,%esp
c0005ef1:	68 08 e9 00 c0       	push   $0xc000e908
c0005ef6:	e8 b5 c4 ff ff       	call   c00023b0 <put_str>
c0005efb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:27
	syscall_table[SYS_GETPID]	= sys_getpid;
c0005efe:	c7 05 20 4b 01 c0 d6 	movl   $0xc0005ed6,0xc0014b20
c0005f05:	5e 00 c0 
/work/x86_os_my/userprog/syscall-init.c:28
	syscall_table[SYS_WRITE]	= sys_write;
c0005f08:	c7 05 24 4b 01 c0 12 	movl   $0xc0007e12,0xc0014b24
c0005f0f:	7e 00 c0 
/work/x86_os_my/userprog/syscall-init.c:29
	syscall_table[SYS_MALLOC]	= sys_malloc;
c0005f12:	c7 05 28 4b 01 c0 0c 	movl   $0xc0002f0c,0xc0014b28
c0005f19:	2f 00 c0 
/work/x86_os_my/userprog/syscall-init.c:30
	syscall_table[SYS_FREE]		= sys_free;
c0005f1c:	c7 05 2c 4b 01 c0 39 	movl   $0xc0003539,0xc0014b2c
c0005f23:	35 00 c0 
/work/x86_os_my/userprog/syscall-init.c:31
	syscall_table[SYS_FORK]		= sys_fork;
c0005f26:	c7 05 30 4b 01 c0 16 	movl   $0xc000bd16,0xc0014b30
c0005f2d:	bd 00 c0 
/work/x86_os_my/userprog/syscall-init.c:32
	syscall_table[SYS_READ]		= sys_read;
c0005f30:	c7 05 34 4b 01 c0 53 	movl   $0xc0007f53,0xc0014b34
c0005f37:	7f 00 c0 
/work/x86_os_my/userprog/syscall-init.c:33
	syscall_table[SYS_PUTCHAR]	= sys_putchar;
c0005f3a:	c7 05 38 4b 01 c0 53 	movl   $0xc0009053,0xc0014b38
c0005f41:	90 00 c0 
/work/x86_os_my/userprog/syscall-init.c:34
	syscall_table[SYS_CLEAR]	= cls_screen;
c0005f44:	c7 05 3c 4b 01 c0 9b 	movl   $0xc000249b,0xc0014b3c
c0005f4b:	24 00 c0 
/work/x86_os_my/userprog/syscall-init.c:35
	syscall_table[SYS_GETCWD]	= sys_getcwd;
c0005f4e:	c7 05 40 4b 01 c0 a6 	movl   $0xc0008ca6,0xc0014b40
c0005f55:	8c 00 c0 
/work/x86_os_my/userprog/syscall-init.c:36
	syscall_table[SYS_OPEN]		= sys_open;
c0005f58:	c7 05 44 4b 01 c0 68 	movl   $0xc0007a68,0xc0014b44
c0005f5f:	7a 00 c0 
/work/x86_os_my/userprog/syscall-init.c:37
	syscall_table[SYS_CLOSE]	= sys_close;
c0005f62:	c7 05 48 4b 01 c0 15 	movl   $0xc0007d15,0xc0014b48
c0005f69:	7d 00 c0 
/work/x86_os_my/userprog/syscall-init.c:38
	syscall_table[SYS_LSEEK]	= sys_lseek;
c0005f6c:	c7 05 4c 4b 01 c0 99 	movl   $0xc0008099,0xc0014b4c
c0005f73:	80 00 c0 
/work/x86_os_my/userprog/syscall-init.c:39
	syscall_table[SYS_UNLINK]	= sys_unlink;
c0005f76:	c7 05 50 4b 01 c0 84 	movl   $0xc0008184,0xc0014b50
c0005f7d:	81 00 c0 
/work/x86_os_my/userprog/syscall-init.c:40
	syscall_table[SYS_MKDIR]	= sys_mkdir;
c0005f80:	c7 05 54 4b 01 c0 a7 	movl   $0xc00083a7,0xc0014b54
c0005f87:	83 00 c0 
/work/x86_os_my/userprog/syscall-init.c:41
	syscall_table[SYS_OPENDIR]	= sys_opendir;
c0005f8a:	c7 05 58 4b 01 c0 97 	movl   $0xc0008797,0xc0014b58
c0005f91:	87 00 c0 
/work/x86_os_my/userprog/syscall-init.c:42
	syscall_table[SYS_CLOSEDIR]	= sys_closedir;
c0005f94:	c7 05 5c 4b 01 c0 a7 	movl   $0xc00088a7,0xc0014b5c
c0005f9b:	88 00 c0 
/work/x86_os_my/userprog/syscall-init.c:43
	syscall_table[SYS_CHDIR]	= sys_chdir;
c0005f9e:	c7 05 60 4b 01 c0 9a 	movl   $0xc0008e9a,0xc0014b60
c0005fa5:	8e 00 c0 
/work/x86_os_my/userprog/syscall-init.c:44
	syscall_table[SYS_RMDIR]	= sys_rmdir;
c0005fa8:	c7 05 64 4b 01 c0 1c 	movl   $0xc000891c,0xc0014b64
c0005faf:	89 00 c0 
/work/x86_os_my/userprog/syscall-init.c:45
	syscall_table[SYS_READDIR]	= sys_readdir;
c0005fb2:	c7 05 68 4b 01 c0 d4 	movl   $0xc00088d4,0xc0014b68
c0005fb9:	88 00 c0 
/work/x86_os_my/userprog/syscall-init.c:46
	syscall_table[SYS_REWINDDIR]	= sys_rewinddir;
c0005fbc:	c7 05 6c 4b 01 c0 0c 	movl   $0xc000890c,0xc0014b6c
c0005fc3:	89 00 c0 
/work/x86_os_my/userprog/syscall-init.c:47
	syscall_table[SYS_STAT]		= sys_stat;
c0005fc6:	c7 05 70 4b 01 c0 29 	movl   $0xc0008f29,0xc0014b70
c0005fcd:	8f 00 c0 
/work/x86_os_my/userprog/syscall-init.c:48
	syscall_table[SYS_PS]		= sys_ps;
c0005fd0:	c7 05 74 4b 01 c0 3c 	movl   $0xc000483c,0xc0014b74
c0005fd7:	48 00 c0 
/work/x86_os_my/userprog/syscall-init.c:49
	syscall_table[SYS_EXECV]	= sys_execv;
c0005fda:	c7 05 78 4b 01 c0 35 	movl   $0xc000d135,0xc0014b78
c0005fe1:	d1 00 c0 
/work/x86_os_my/userprog/syscall-init.c:50
	syscall_table[SYS_EXIT]		= sys_exit;
c0005fe4:	c7 05 7c 4b 01 c0 62 	movl   $0xc000d562,0xc0014b7c
c0005feb:	d5 00 c0 
/work/x86_os_my/userprog/syscall-init.c:51
	syscall_table[SYS_WAIT]		= sys_wait;
c0005fee:	c7 05 80 4b 01 c0 af 	movl   $0xc000d4af,0xc0014b80
c0005ff5:	d4 00 c0 
/work/x86_os_my/userprog/syscall-init.c:52
	syscall_table[SYS_PIPE]		= sys_pipe;
c0005ff8:	c7 05 84 4b 01 c0 50 	movl   $0xc000d650,0xc0014b84
c0005fff:	d6 00 c0 
/work/x86_os_my/userprog/syscall-init.c:53
	syscall_table[SYS_FD_REDIRECT]	= sys_fd_redirect;
c0006002:	c7 05 88 4b 01 c0 37 	movl   $0xc000d837,0xc0014b88
c0006009:	d8 00 c0 
/work/x86_os_my/userprog/syscall-init.c:54
	syscall_table[SYS_HELP]		= sys_help;
c000600c:	c7 05 8c 4b 01 c0 75 	movl   $0xc0009075,0xc0014b8c
c0006013:	90 00 c0 
/work/x86_os_my/userprog/syscall-init.c:55
	put_str("syscall_init done\n");
c0006016:	83 ec 0c             	sub    $0xc,%esp
c0006019:	68 1c e9 00 c0       	push   $0xc000e91c
c000601e:	e8 8d c3 ff ff       	call   c00023b0 <put_str>
c0006023:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:56
}
c0006026:	90                   	nop
c0006027:	c9                   	leave  
c0006028:	c3                   	ret    

c0006029 <itoa>:
itoa():
/work/x86_os_my/lib/stdio.c:13
#define va_start(ap, v) ap = (va_list)&v	// 把ap指向第一个固定参数v
#define va_arg(ap, t) *((t*)(ap += 4))		// ap指向下一个参数并返回其值
#define va_end(ap) ap = NULL				// 清除ap

/* 将整型转换成字符(integer to ascii) */
static void itoa(uint32_t value, char** buf_ptr_addr, uint8_t base) {
c0006029:	55                   	push   %ebp
c000602a:	89 e5                	mov    %esp,%ebp
c000602c:	83 ec 28             	sub    $0x28,%esp
c000602f:	8b 45 10             	mov    0x10(%ebp),%eax
c0006032:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/stdio.c:14
	uint32_t m = value % base;	// 求模,最先掉下来的是最低位【比如base是16代表16进制】 
c0006035:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c0006039:	8b 45 08             	mov    0x8(%ebp),%eax
c000603c:	ba 00 00 00 00       	mov    $0x0,%edx
c0006041:	f7 f1                	div    %ecx
c0006043:	89 55 f4             	mov    %edx,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:15
	uint32_t i = value / base;	// 取整
c0006046:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c000604a:	8b 45 08             	mov    0x8(%ebp),%eax
c000604d:	ba 00 00 00 00       	mov    $0x0,%edx
c0006052:	f7 f1                	div    %ecx
c0006054:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/stdio.c:16
	if (i) {
c0006057:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000605b:	74 16                	je     c0006073 <itoa+0x4a>
/work/x86_os_my/lib/stdio.c:17
		itoa(i, buf_ptr_addr, base);	// 如果倍数不为0则递归调用。
c000605d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0006061:	83 ec 04             	sub    $0x4,%esp
c0006064:	50                   	push   %eax
c0006065:	ff 75 0c             	pushl  0xc(%ebp)
c0006068:	ff 75 f0             	pushl  -0x10(%ebp)
c000606b:	e8 b9 ff ff ff       	call   c0006029 <itoa>
c0006070:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:19
	}
	if (m < 10) {	// 如果余数是0~9
c0006073:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0006077:	77 17                	ja     c0006090 <itoa+0x67>
/work/x86_os_my/lib/stdio.c:20
		*((*buf_ptr_addr)++) = m + '0';			// 将数字0~9转换为字符'0'~'9'
c0006079:	8b 45 0c             	mov    0xc(%ebp),%eax
c000607c:	8b 00                	mov    (%eax),%eax
c000607e:	8d 48 01             	lea    0x1(%eax),%ecx
c0006081:	8b 55 0c             	mov    0xc(%ebp),%edx
c0006084:	89 0a                	mov    %ecx,(%edx)
c0006086:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0006089:	83 c2 30             	add    $0x30,%edx
c000608c:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:24
	} else {		// 否则余数是A~F
		*((*buf_ptr_addr)++) = m - 10 + 'A';	// 将数字A~F转换为字符'A'~'F'
	}
}
c000608e:	eb 15                	jmp    c00060a5 <itoa+0x7c>
/work/x86_os_my/lib/stdio.c:22
		itoa(i, buf_ptr_addr, base);	// 如果倍数不为0则递归调用。
	}
	if (m < 10) {	// 如果余数是0~9
		*((*buf_ptr_addr)++) = m + '0';			// 将数字0~9转换为字符'0'~'9'
	} else {		// 否则余数是A~F
		*((*buf_ptr_addr)++) = m - 10 + 'A';	// 将数字A~F转换为字符'A'~'F'
c0006090:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006093:	8b 00                	mov    (%eax),%eax
c0006095:	8d 48 01             	lea    0x1(%eax),%ecx
c0006098:	8b 55 0c             	mov    0xc(%ebp),%edx
c000609b:	89 0a                	mov    %ecx,(%edx)
c000609d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00060a0:	83 c2 37             	add    $0x37,%edx
c00060a3:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:24
	}
}
c00060a5:	90                   	nop
c00060a6:	c9                   	leave  
c00060a7:	c3                   	ret    

c00060a8 <vsprintf>:
vsprintf():
/work/x86_os_my/lib/stdio.c:27

/* 将参数ap按照格式format输出到字符串str,并返回替换后str长度 */
uint32_t vsprintf(char* str, const char* format, va_list ap) {
c00060a8:	55                   	push   %ebp
c00060a9:	89 e5                	mov    %esp,%ebp
c00060ab:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/lib/stdio.c:28
	char* buf_ptr = str;
c00060ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00060b1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/stdio.c:29
	const char* index_ptr = format;
c00060b4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00060b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:30
	char index_char = *index_ptr;
c00060ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00060bd:	0f b6 00             	movzbl (%eax),%eax
c00060c0:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:33
	int32_t arg_int;
	char* arg_str;
	while(index_char) {
c00060c3:	e9 43 01 00 00       	jmp    c000620b <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:34
		if (index_char != '%') {
c00060c8:	80 7d f3 25          	cmpb   $0x25,-0xd(%ebp)
c00060cc:	74 21                	je     c00060ef <vsprintf+0x47>
/work/x86_os_my/lib/stdio.c:35
			*(buf_ptr++) = index_char;
c00060ce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00060d1:	8d 50 01             	lea    0x1(%eax),%edx
c00060d4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c00060d7:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
c00060db:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:36
			index_char = *(++index_ptr);
c00060dd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00060e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00060e4:	0f b6 00             	movzbl (%eax),%eax
c00060e7:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:37
			continue;
c00060ea:	e9 1c 01 00 00       	jmp    c000620b <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:39
		}
		index_char = *(++index_ptr);	 // 得到%后面的字符
c00060ef:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00060f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00060f6:	0f b6 00             	movzbl (%eax),%eax
c00060f9:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:40
		switch(index_char) {
c00060fc:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
c0006100:	83 f8 64             	cmp    $0x64,%eax
c0006103:	0f 84 8e 00 00 00    	je     c0006197 <vsprintf+0xef>
c0006109:	83 f8 64             	cmp    $0x64,%eax
c000610c:	7f 0a                	jg     c0006118 <vsprintf+0x70>
c000610e:	83 f8 63             	cmp    $0x63,%eax
c0006111:	74 60                	je     c0006173 <vsprintf+0xcb>
c0006113:	e9 f3 00 00 00       	jmp    c000620b <vsprintf+0x163>
c0006118:	83 f8 73             	cmp    $0x73,%eax
c000611b:	74 0e                	je     c000612b <vsprintf+0x83>
c000611d:	83 f8 78             	cmp    $0x78,%eax
c0006120:	0f 84 b6 00 00 00    	je     c00061dc <vsprintf+0x134>
c0006126:	e9 e0 00 00 00       	jmp    c000620b <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:42
			case 's':
			arg_str = va_arg(ap, char*);
c000612b:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c000612f:	8b 45 10             	mov    0x10(%ebp),%eax
c0006132:	8b 00                	mov    (%eax),%eax
c0006134:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/lib/stdio.c:43
			strcpy(buf_ptr, arg_str);
c0006137:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000613a:	83 ec 08             	sub    $0x8,%esp
c000613d:	ff 75 e8             	pushl  -0x18(%ebp)
c0006140:	50                   	push   %eax
c0006141:	e8 54 da ff ff       	call   c0003b9a <strcpy>
c0006146:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:44
			buf_ptr += strlen(arg_str);
c0006149:	83 ec 0c             	sub    $0xc,%esp
c000614c:	ff 75 e8             	pushl  -0x18(%ebp)
c000614f:	e8 9b da ff ff       	call   c0003bef <strlen>
c0006154:	83 c4 10             	add    $0x10,%esp
c0006157:	89 c2                	mov    %eax,%edx
c0006159:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000615c:	01 d0                	add    %edx,%eax
c000615e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/stdio.c:45
			index_char = *(++index_ptr);
c0006161:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0006165:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0006168:	0f b6 00             	movzbl (%eax),%eax
c000616b:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:46
			break;
c000616e:	e9 98 00 00 00       	jmp    c000620b <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:49

			case 'c':
			*(buf_ptr++) = va_arg(ap, char);
c0006173:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0006176:	8d 50 01             	lea    0x1(%eax),%edx
c0006179:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c000617c:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c0006180:	8b 55 10             	mov    0x10(%ebp),%edx
c0006183:	0f b6 12             	movzbl (%edx),%edx
c0006186:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:50
			index_char = *(++index_ptr);
c0006188:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c000618c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000618f:	0f b6 00             	movzbl (%eax),%eax
c0006192:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:51
			break;
c0006195:	eb 74                	jmp    c000620b <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:54

			case 'd':
			arg_int = va_arg(ap, int);
c0006197:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c000619b:	8b 45 10             	mov    0x10(%ebp),%eax
c000619e:	8b 00                	mov    (%eax),%eax
c00061a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/stdio.c:56
			/* 若是负数, 将其转为正数后,再正数前面输出个负号'-'. */
			if (arg_int < 0) {
c00061a3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00061a7:	79 0f                	jns    c00061b8 <vsprintf+0x110>
/work/x86_os_my/lib/stdio.c:57
				arg_int = 0 - arg_int;
c00061a9:	f7 5d ec             	negl   -0x14(%ebp)
/work/x86_os_my/lib/stdio.c:58
				*buf_ptr++ = '-';
c00061ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00061af:	8d 50 01             	lea    0x1(%eax),%edx
c00061b2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c00061b5:	c6 00 2d             	movb   $0x2d,(%eax)
/work/x86_os_my/lib/stdio.c:60
			}
			itoa(arg_int, &buf_ptr, 10); 
c00061b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00061bb:	83 ec 04             	sub    $0x4,%esp
c00061be:	6a 0a                	push   $0xa
c00061c0:	8d 55 e4             	lea    -0x1c(%ebp),%edx
c00061c3:	52                   	push   %edx
c00061c4:	50                   	push   %eax
c00061c5:	e8 5f fe ff ff       	call   c0006029 <itoa>
c00061ca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:61
			index_char = *(++index_ptr);
c00061cd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00061d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00061d4:	0f b6 00             	movzbl (%eax),%eax
c00061d7:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:62
			break;
c00061da:	eb 2f                	jmp    c000620b <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:65

			case 'x':
			arg_int = va_arg(ap, int);
c00061dc:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c00061e0:	8b 45 10             	mov    0x10(%ebp),%eax
c00061e3:	8b 00                	mov    (%eax),%eax
c00061e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/stdio.c:66
			itoa(arg_int, &buf_ptr, 16); 
c00061e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00061eb:	83 ec 04             	sub    $0x4,%esp
c00061ee:	6a 10                	push   $0x10
c00061f0:	8d 55 e4             	lea    -0x1c(%ebp),%edx
c00061f3:	52                   	push   %edx
c00061f4:	50                   	push   %eax
c00061f5:	e8 2f fe ff ff       	call   c0006029 <itoa>
c00061fa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:67
			index_char = *(++index_ptr); // 跳过格式字符并更新index_char
c00061fd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0006201:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0006204:	0f b6 00             	movzbl (%eax),%eax
c0006207:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:68
			break;
c000620a:	90                   	nop
/work/x86_os_my/lib/stdio.c:33
	char* buf_ptr = str;
	const char* index_ptr = format;
	char index_char = *index_ptr;
	int32_t arg_int;
	char* arg_str;
	while(index_char) {
c000620b:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c000620f:	0f 85 b3 fe ff ff    	jne    c00060c8 <vsprintf+0x20>
/work/x86_os_my/lib/stdio.c:71
			itoa(arg_int, &buf_ptr, 16); 
			index_char = *(++index_ptr); // 跳过格式字符并更新index_char
			break;
		}
	}
	return strlen(str);
c0006215:	83 ec 0c             	sub    $0xc,%esp
c0006218:	ff 75 08             	pushl  0x8(%ebp)
c000621b:	e8 cf d9 ff ff       	call   c0003bef <strlen>
c0006220:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:72
}
c0006223:	c9                   	leave  
c0006224:	c3                   	ret    

c0006225 <sprintf>:
sprintf():
/work/x86_os_my/lib/stdio.c:75

/* 同printf不同的地方就是字符串不是写到终端,而是写到buf中 */
uint32_t sprintf(char* buf, const char* format, ...) {
c0006225:	55                   	push   %ebp
c0006226:	89 e5                	mov    %esp,%ebp
c0006228:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/stdio.c:78
	va_list args;
	uint32_t retval;
	va_start(args, format);
c000622b:	8d 45 0c             	lea    0xc(%ebp),%eax
c000622e:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:79
	retval = vsprintf(buf, format, args);
c0006231:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006234:	83 ec 04             	sub    $0x4,%esp
c0006237:	ff 75 f4             	pushl  -0xc(%ebp)
c000623a:	50                   	push   %eax
c000623b:	ff 75 08             	pushl  0x8(%ebp)
c000623e:	e8 65 fe ff ff       	call   c00060a8 <vsprintf>
c0006243:	83 c4 10             	add    $0x10,%esp
c0006246:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/stdio.c:80
	va_end(args);
c0006249:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:81
	return retval;
c0006250:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/lib/stdio.c:82
}
c0006253:	c9                   	leave  
c0006254:	c3                   	ret    

c0006255 <printf>:
printf():
/work/x86_os_my/lib/stdio.c:85

/* 格式化输出字符串format */
uint32_t printf(const char* format, ...) {
c0006255:	55                   	push   %ebp
c0006256:	89 e5                	mov    %esp,%ebp
c0006258:	57                   	push   %edi
c0006259:	81 ec 14 04 00 00    	sub    $0x414,%esp
/work/x86_os_my/lib/stdio.c:87
	va_list args;
	va_start(args, format);	       // 使args指向format
c000625f:	8d 45 08             	lea    0x8(%ebp),%eax
c0006262:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:88
	char buf[1024] = {0};	       // 用于存储拼接后的字符串
c0006265:	8d 95 f4 fb ff ff    	lea    -0x40c(%ebp),%edx
c000626b:	b8 00 00 00 00       	mov    $0x0,%eax
c0006270:	b9 00 01 00 00       	mov    $0x100,%ecx
c0006275:	89 d7                	mov    %edx,%edi
c0006277:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/lib/stdio.c:89
	vsprintf(buf, format, args);
c0006279:	8b 45 08             	mov    0x8(%ebp),%eax
c000627c:	83 ec 04             	sub    $0x4,%esp
c000627f:	ff 75 f4             	pushl  -0xc(%ebp)
c0006282:	50                   	push   %eax
c0006283:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c0006289:	50                   	push   %eax
c000628a:	e8 19 fe ff ff       	call   c00060a8 <vsprintf>
c000628f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:90
	va_end(args);
c0006292:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:91
	return write(1, buf, strlen(buf));
c0006299:	83 ec 0c             	sub    $0xc,%esp
c000629c:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c00062a2:	50                   	push   %eax
c00062a3:	e8 47 d9 ff ff       	call   c0003bef <strlen>
c00062a8:	83 c4 10             	add    $0x10,%esp
c00062ab:	83 ec 04             	sub    $0x4,%esp
c00062ae:	50                   	push   %eax
c00062af:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c00062b5:	50                   	push   %eax
c00062b6:	6a 01                	push   $0x1
c00062b8:	e8 dc f8 ff ff       	call   c0005b99 <write>
c00062bd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:92
}
c00062c0:	8b 7d fc             	mov    -0x4(%ebp),%edi
c00062c3:	c9                   	leave  
c00062c4:	c3                   	ret    

c00062c5 <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c00062c5:	55                   	push   %ebp
c00062c6:	89 e5                	mov    %esp,%ebp
c00062c8:	83 ec 08             	sub    $0x8,%esp
c00062cb:	8b 55 08             	mov    0x8(%ebp),%edx
c00062ce:	8b 45 0c             	mov    0xc(%ebp),%eax
c00062d1:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c00062d5:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c00062d8:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c00062dc:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c00062e0:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c00062e1:	90                   	nop
c00062e2:	c9                   	leave  
c00062e3:	c3                   	ret    

c00062e4 <outsw>:
outsw():
/work/x86_os_my/lib/kernel/io.h:26

/* 将addr处起始的word_cnt个字写入端口port */
static inline void outsw(uint16_t port, const void* addr, uint32_t word_cnt) {
c00062e4:	55                   	push   %ebp
c00062e5:	89 e5                	mov    %esp,%ebp
c00062e7:	56                   	push   %esi
c00062e8:	53                   	push   %ebx
c00062e9:	83 ec 04             	sub    $0x4,%esp
c00062ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00062ef:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/io.h:31
/*********************************************************
   +表示此限制即做输入又做输出.
   outsw是把ds:esi处的16位的内容写入port端口, 我们在设置段描述符时, 
   已经将ds,es,ss段的选择子都设置为相同的值了,此时不用担心数据错乱。*/
   asm volatile ("cld; rep outsw" : "+S" (addr), "+c" (word_cnt) : "d" (port));
c00062f3:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c00062f7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c00062fa:	8b 45 10             	mov    0x10(%ebp),%eax
c00062fd:	89 cb                	mov    %ecx,%ebx
c00062ff:	89 de                	mov    %ebx,%esi
c0006301:	89 c1                	mov    %eax,%ecx
c0006303:	fc                   	cld    
c0006304:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
c0006307:	89 c8                	mov    %ecx,%eax
c0006309:	89 f3                	mov    %esi,%ebx
c000630b:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c000630e:	89 45 10             	mov    %eax,0x10(%ebp)
/work/x86_os_my/lib/kernel/io.h:33
/******************************************************/
}
c0006311:	90                   	nop
c0006312:	83 c4 04             	add    $0x4,%esp
c0006315:	5b                   	pop    %ebx
c0006316:	5e                   	pop    %esi
c0006317:	5d                   	pop    %ebp
c0006318:	c3                   	ret    

c0006319 <inb>:
inb():
/work/x86_os_my/lib/kernel/io.h:36

/* 将从端口port读入的一个字节返回 */
static inline uint8_t inb(uint16_t port) {
c0006319:	55                   	push   %ebp
c000631a:	89 e5                	mov    %esp,%ebp
c000631c:	83 ec 14             	sub    $0x14,%esp
c000631f:	8b 45 08             	mov    0x8(%ebp),%eax
c0006322:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/io.h:38
   uint8_t data;
   asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0006326:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c000632a:	89 c2                	mov    %eax,%edx
c000632c:	ec                   	in     (%dx),%al
c000632d:	88 45 ff             	mov    %al,-0x1(%ebp)
/work/x86_os_my/lib/kernel/io.h:39
   return data;
c0006330:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
/work/x86_os_my/lib/kernel/io.h:40
}
c0006334:	c9                   	leave  
c0006335:	c3                   	ret    

c0006336 <insw>:
insw():
/work/x86_os_my/lib/kernel/io.h:43

/* 将从端口port读入的word_cnt个字写入addr */
static inline void insw(uint16_t port, void* addr, uint32_t word_cnt) {
c0006336:	55                   	push   %ebp
c0006337:	89 e5                	mov    %esp,%ebp
c0006339:	57                   	push   %edi
c000633a:	53                   	push   %ebx
c000633b:	83 ec 04             	sub    $0x4,%esp
c000633e:	8b 45 08             	mov    0x8(%ebp),%eax
c0006341:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/io.h:48
/******************************************************
   insw是将从端口port处读入的16位内容写入es:edi指向的内存,
   我们在设置段描述符时, 已经将ds,es,ss段的选择子都设置为相同的值了,
   此时不用担心数据错乱。*/
   asm volatile ("cld; rep insw" : "+D" (addr), "+c" (word_cnt) : "d" (port) : "memory");
c0006345:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c0006349:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c000634c:	8b 45 10             	mov    0x10(%ebp),%eax
c000634f:	89 cb                	mov    %ecx,%ebx
c0006351:	89 df                	mov    %ebx,%edi
c0006353:	89 c1                	mov    %eax,%ecx
c0006355:	fc                   	cld    
c0006356:	66 f3 6d             	rep insw (%dx),%es:(%edi)
c0006359:	89 c8                	mov    %ecx,%eax
c000635b:	89 fb                	mov    %edi,%ebx
c000635d:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c0006360:	89 45 10             	mov    %eax,0x10(%ebp)
/work/x86_os_my/lib/kernel/io.h:50
/******************************************************/
}
c0006363:	90                   	nop
c0006364:	83 c4 04             	add    $0x4,%esp
c0006367:	5b                   	pop    %ebx
c0006368:	5f                   	pop    %edi
c0006369:	5d                   	pop    %ebp
c000636a:	c3                   	ret    

c000636b <select_disk>:
select_disk():
/work/x86_os_my/device/ide.c:78
} __attribute__ ((packed));


/////////////////////////////////////// ide驱动部分 ////////////////////////////////////////////////
/* 选择读写的硬盘 */
static void select_disk(struct disk* hd) {
c000636b:	55                   	push   %ebp
c000636c:	89 e5                	mov    %esp,%ebp
c000636e:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/device/ide.c:79
	uint8_t reg_device = BIT_DEV_MBS | BIT_DEV_LBA;
c0006371:	c6 45 ff e0          	movb   $0xe0,-0x1(%ebp)
/work/x86_os_my/device/ide.c:80
	if (hd->dev_no == 1) {	// 若是从盘就置DEV位为1
c0006375:	8b 45 08             	mov    0x8(%ebp),%eax
c0006378:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
c000637c:	3c 01                	cmp    $0x1,%al
c000637e:	75 04                	jne    c0006384 <select_disk+0x19>
/work/x86_os_my/device/ide.c:81
		reg_device |= BIT_DEV_DEV;
c0006380:	80 4d ff 10          	orb    $0x10,-0x1(%ebp)
/work/x86_os_my/device/ide.c:83
	}
	outb(reg_dev(hd->my_channel), reg_device);
c0006384:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c0006388:	8b 45 08             	mov    0x8(%ebp),%eax
c000638b:	8b 40 08             	mov    0x8(%eax),%eax
c000638e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0006392:	83 c0 06             	add    $0x6,%eax
c0006395:	0f b7 c0             	movzwl %ax,%eax
c0006398:	52                   	push   %edx
c0006399:	50                   	push   %eax
c000639a:	e8 26 ff ff ff       	call   c00062c5 <outb>
c000639f:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/ide.c:84
}
c00063a2:	90                   	nop
c00063a3:	c9                   	leave  
c00063a4:	c3                   	ret    

c00063a5 <select_sector>:
select_sector():
/work/x86_os_my/device/ide.c:87

/* 向硬盘控制器写入起始扇区地址及要读写的扇区数 */
static void select_sector(struct disk* hd, uint32_t lba, uint8_t sec_cnt) {
c00063a5:	55                   	push   %ebp
c00063a6:	89 e5                	mov    %esp,%ebp
c00063a8:	83 ec 28             	sub    $0x28,%esp
c00063ab:	8b 45 10             	mov    0x10(%ebp),%eax
c00063ae:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/device/ide.c:88
	ASSERT(lba <= max_lba);
c00063b1:	81 7d 0c ff 7f 02 00 	cmpl   $0x27fff,0xc(%ebp)
c00063b8:	76 19                	jbe    c00063d3 <select_sector+0x2e>
/work/x86_os_my/device/ide.c:88 (discriminator 1)
c00063ba:	68 30 e9 00 c0       	push   $0xc000e930
c00063bf:	68 c8 ea 00 c0       	push   $0xc000eac8
c00063c4:	6a 58                	push   $0x58
c00063c6:	68 3f e9 00 c0       	push   $0xc000e93f
c00063cb:	e8 91 c1 ff ff       	call   c0002561 <panic_spin>
c00063d0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:89
	struct ide_channel* channel = hd->my_channel;
c00063d3:	8b 45 08             	mov    0x8(%ebp),%eax
c00063d6:	8b 40 08             	mov    0x8(%eax),%eax
c00063d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:92

	/* 写入要读写的扇区数*/
	outb(reg_sect_cnt(channel), sec_cnt);	// 如果sec_cnt为0,则表示写入256个扇区
c00063dc:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c00063e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00063e3:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00063e7:	83 c0 02             	add    $0x2,%eax
c00063ea:	0f b7 c0             	movzwl %ax,%eax
c00063ed:	83 ec 08             	sub    $0x8,%esp
c00063f0:	52                   	push   %edx
c00063f1:	50                   	push   %eax
c00063f2:	e8 ce fe ff ff       	call   c00062c5 <outb>
c00063f7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:95

	/* 写入lba地址(即扇区号) */
	outb(reg_lba_l(channel), lba);			// lba地址的低8位,不用单独取出低8位.outb函数中的汇编指令outb %b0, %w1会只用al。
c00063fa:	8b 45 0c             	mov    0xc(%ebp),%eax
c00063fd:	0f b6 d0             	movzbl %al,%edx
c0006400:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0006403:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0006407:	83 c0 03             	add    $0x3,%eax
c000640a:	0f b7 c0             	movzwl %ax,%eax
c000640d:	83 ec 08             	sub    $0x8,%esp
c0006410:	52                   	push   %edx
c0006411:	50                   	push   %eax
c0006412:	e8 ae fe ff ff       	call   c00062c5 <outb>
c0006417:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:96
	outb(reg_lba_m(channel), lba >> 8);		// lba地址的8~15位
c000641a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000641d:	c1 e8 08             	shr    $0x8,%eax
c0006420:	0f b6 d0             	movzbl %al,%edx
c0006423:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0006426:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c000642a:	83 c0 04             	add    $0x4,%eax
c000642d:	0f b7 c0             	movzwl %ax,%eax
c0006430:	83 ec 08             	sub    $0x8,%esp
c0006433:	52                   	push   %edx
c0006434:	50                   	push   %eax
c0006435:	e8 8b fe ff ff       	call   c00062c5 <outb>
c000643a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:97
	outb(reg_lba_h(channel), lba >> 16);	// lba地址的16~23位
c000643d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006440:	c1 e8 10             	shr    $0x10,%eax
c0006443:	0f b6 d0             	movzbl %al,%edx
c0006446:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0006449:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c000644d:	83 c0 05             	add    $0x5,%eax
c0006450:	0f b7 c0             	movzwl %ax,%eax
c0006453:	83 ec 08             	sub    $0x8,%esp
c0006456:	52                   	push   %edx
c0006457:	50                   	push   %eax
c0006458:	e8 68 fe ff ff       	call   c00062c5 <outb>
c000645d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:101

	/* 因为lba地址的24~27位要存储在device寄存器的0～3位,
	* 无法单独写入这4位,所以在此处把device寄存器再重新写入一次*/
	outb(reg_dev(channel), BIT_DEV_MBS | BIT_DEV_LBA | (hd->dev_no == 1 ? BIT_DEV_DEV : 0) | lba >> 24);
c0006460:	8b 45 08             	mov    0x8(%ebp),%eax
c0006463:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
c0006467:	3c 01                	cmp    $0x1,%al
c0006469:	75 07                	jne    c0006472 <select_sector+0xcd>
/work/x86_os_my/device/ide.c:101 (discriminator 1)
c000646b:	ba f0 ff ff ff       	mov    $0xfffffff0,%edx
c0006470:	eb 05                	jmp    c0006477 <select_sector+0xd2>
/work/x86_os_my/device/ide.c:101 (discriminator 2)
c0006472:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
/work/x86_os_my/device/ide.c:101 (discriminator 4)
c0006477:	8b 45 0c             	mov    0xc(%ebp),%eax
c000647a:	c1 e8 18             	shr    $0x18,%eax
c000647d:	09 d0                	or     %edx,%eax
c000647f:	0f b6 d0             	movzbl %al,%edx
c0006482:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0006485:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0006489:	83 c0 06             	add    $0x6,%eax
c000648c:	0f b7 c0             	movzwl %ax,%eax
c000648f:	83 ec 08             	sub    $0x8,%esp
c0006492:	52                   	push   %edx
c0006493:	50                   	push   %eax
c0006494:	e8 2c fe ff ff       	call   c00062c5 <outb>
c0006499:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:102 (discriminator 4)
}
c000649c:	90                   	nop
c000649d:	c9                   	leave  
c000649e:	c3                   	ret    

c000649f <cmd_out>:
cmd_out():
/work/x86_os_my/device/ide.c:105

/* 向通道channel发命令cmd */
static void cmd_out(struct ide_channel* channel, uint8_t cmd) {
c000649f:	55                   	push   %ebp
c00064a0:	89 e5                	mov    %esp,%ebp
c00064a2:	83 ec 04             	sub    $0x4,%esp
c00064a5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00064a8:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/device/ide.c:107
	/* 只要向硬盘发出了命令便将此标记置为true,硬盘中断处理程序需要根据它来判断 */
	channel->expecting_intr = true;
c00064ab:	8b 45 08             	mov    0x8(%ebp),%eax
c00064ae:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
/work/x86_os_my/device/ide.c:108
	outb(reg_cmd(channel), cmd);
c00064b5:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c00064b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00064bc:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00064c0:	83 c0 07             	add    $0x7,%eax
c00064c3:	0f b7 c0             	movzwl %ax,%eax
c00064c6:	52                   	push   %edx
c00064c7:	50                   	push   %eax
c00064c8:	e8 f8 fd ff ff       	call   c00062c5 <outb>
c00064cd:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/ide.c:109
}
c00064d0:	90                   	nop
c00064d1:	c9                   	leave  
c00064d2:	c3                   	ret    

c00064d3 <read_from_sector>:
read_from_sector():
/work/x86_os_my/device/ide.c:112

/* 硬盘读入sec_cnt个扇区的数据到buf */
static void read_from_sector(struct disk* hd, void* buf, uint8_t sec_cnt) {
c00064d3:	55                   	push   %ebp
c00064d4:	89 e5                	mov    %esp,%ebp
c00064d6:	83 ec 14             	sub    $0x14,%esp
c00064d9:	8b 45 10             	mov    0x10(%ebp),%eax
c00064dc:	88 45 ec             	mov    %al,-0x14(%ebp)
/work/x86_os_my/device/ide.c:114
	uint32_t size_in_byte;
	if (sec_cnt == 0) {
c00064df:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
c00064e3:	75 09                	jne    c00064ee <read_from_sector+0x1b>
/work/x86_os_my/device/ide.c:116
		/* 因为sec_cnt是8位变量,由主调函数将其赋值时,若为256则会将最高位的1丢掉变为0 */
		size_in_byte = 256 * 512;
c00064e5:	c7 45 fc 00 00 02 00 	movl   $0x20000,-0x4(%ebp)
c00064ec:	eb 0a                	jmp    c00064f8 <read_from_sector+0x25>
/work/x86_os_my/device/ide.c:118
	} else { 
		size_in_byte = sec_cnt * 512; 
c00064ee:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c00064f2:	c1 e0 09             	shl    $0x9,%eax
c00064f5:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/device/ide.c:120
	}
	insw(reg_data(hd->my_channel), buf, size_in_byte / 2);
c00064f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00064fb:	d1 e8                	shr    %eax
c00064fd:	89 c2                	mov    %eax,%edx
c00064ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0006502:	8b 40 08             	mov    0x8(%eax),%eax
c0006505:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0006509:	0f b7 c0             	movzwl %ax,%eax
c000650c:	52                   	push   %edx
c000650d:	ff 75 0c             	pushl  0xc(%ebp)
c0006510:	50                   	push   %eax
c0006511:	e8 20 fe ff ff       	call   c0006336 <insw>
c0006516:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/device/ide.c:121
}
c0006519:	90                   	nop
c000651a:	c9                   	leave  
c000651b:	c3                   	ret    

c000651c <write2sector>:
write2sector():
/work/x86_os_my/device/ide.c:124

/* 将buf中sec_cnt扇区的数据写入硬盘 */
static void write2sector(struct disk* hd, void* buf, uint8_t sec_cnt) {
c000651c:	55                   	push   %ebp
c000651d:	89 e5                	mov    %esp,%ebp
c000651f:	83 ec 14             	sub    $0x14,%esp
c0006522:	8b 45 10             	mov    0x10(%ebp),%eax
c0006525:	88 45 ec             	mov    %al,-0x14(%ebp)
/work/x86_os_my/device/ide.c:126
	uint32_t size_in_byte;
	if (sec_cnt == 0) {
c0006528:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
c000652c:	75 09                	jne    c0006537 <write2sector+0x1b>
/work/x86_os_my/device/ide.c:128
		/* 因为sec_cnt是8位变量,由主调函数将其赋值时,若为256则会将最高位的1丢掉变为0 */
		size_in_byte = 256 * 512;
c000652e:	c7 45 fc 00 00 02 00 	movl   $0x20000,-0x4(%ebp)
c0006535:	eb 0a                	jmp    c0006541 <write2sector+0x25>
/work/x86_os_my/device/ide.c:130
	} else { 
		size_in_byte = sec_cnt * 512; 
c0006537:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c000653b:	c1 e0 09             	shl    $0x9,%eax
c000653e:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/device/ide.c:132
	}
	outsw(reg_data(hd->my_channel), buf, size_in_byte / 2);
c0006541:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0006544:	d1 e8                	shr    %eax
c0006546:	89 c2                	mov    %eax,%edx
c0006548:	8b 45 08             	mov    0x8(%ebp),%eax
c000654b:	8b 40 08             	mov    0x8(%eax),%eax
c000654e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0006552:	0f b7 c0             	movzwl %ax,%eax
c0006555:	52                   	push   %edx
c0006556:	ff 75 0c             	pushl  0xc(%ebp)
c0006559:	50                   	push   %eax
c000655a:	e8 85 fd ff ff       	call   c00062e4 <outsw>
c000655f:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/device/ide.c:133
}
c0006562:	90                   	nop
c0006563:	c9                   	leave  
c0006564:	c3                   	ret    

c0006565 <busy_wait>:
busy_wait():
/work/x86_os_my/device/ide.c:136

/* 等待30秒 */
static bool busy_wait(struct disk* hd) {
c0006565:	55                   	push   %ebp
c0006566:	89 e5                	mov    %esp,%ebp
c0006568:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ide.c:137
	struct ide_channel* channel = hd->my_channel;
c000656b:	8b 45 08             	mov    0x8(%ebp),%eax
c000656e:	8b 40 08             	mov    0x8(%eax),%eax
c0006571:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:138
	uint16_t time_limit = 30 * 1000;	// 可以等待30000毫秒
c0006574:	66 c7 45 f6 30 75    	movw   $0x7530,-0xa(%ebp)
/work/x86_os_my/device/ide.c:139
	while (time_limit -= 10 >= 0) {
c000657a:	eb 45                	jmp    c00065c1 <busy_wait+0x5c>
/work/x86_os_my/device/ide.c:140
		if (!(inb(reg_status(channel)) & BIT_STAT_BSY)) {
c000657c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000657f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0006583:	83 c0 07             	add    $0x7,%eax
c0006586:	0f b7 c0             	movzwl %ax,%eax
c0006589:	50                   	push   %eax
c000658a:	e8 8a fd ff ff       	call   c0006319 <inb>
c000658f:	83 c4 04             	add    $0x4,%esp
c0006592:	84 c0                	test   %al,%al
c0006594:	78 1e                	js     c00065b4 <busy_wait+0x4f>
/work/x86_os_my/device/ide.c:141
			return (inb(reg_status(channel)) & BIT_STAT_DRQ);
c0006596:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006599:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c000659d:	83 c0 07             	add    $0x7,%eax
c00065a0:	0f b7 c0             	movzwl %ax,%eax
c00065a3:	50                   	push   %eax
c00065a4:	e8 70 fd ff ff       	call   c0006319 <inb>
c00065a9:	83 c4 04             	add    $0x4,%esp
c00065ac:	0f b6 c0             	movzbl %al,%eax
c00065af:	83 e0 08             	and    $0x8,%eax
c00065b2:	eb 1e                	jmp    c00065d2 <busy_wait+0x6d>
/work/x86_os_my/device/ide.c:143
		} else {
			mtime_sleep(10);			// 睡眠10毫秒
c00065b4:	83 ec 0c             	sub    $0xc,%esp
c00065b7:	6a 0a                	push   $0xa
c00065b9:	e8 f1 b7 ff ff       	call   c0001daf <mtime_sleep>
c00065be:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:139

/* 等待30秒 */
static bool busy_wait(struct disk* hd) {
	struct ide_channel* channel = hd->my_channel;
	uint16_t time_limit = 30 * 1000;	// 可以等待30000毫秒
	while (time_limit -= 10 >= 0) {
c00065c1:	66 83 6d f6 01       	subw   $0x1,-0xa(%ebp)
c00065c6:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c00065cb:	75 af                	jne    c000657c <busy_wait+0x17>
/work/x86_os_my/device/ide.c:146
			return (inb(reg_status(channel)) & BIT_STAT_DRQ);
		} else {
			mtime_sleep(10);			// 睡眠10毫秒
		}
	}
	return false;
c00065cd:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/device/ide.c:147
}
c00065d2:	c9                   	leave  
c00065d3:	c3                   	ret    

c00065d4 <ide_read>:
ide_read():
/work/x86_os_my/device/ide.c:150

/* 从硬盘读取sec_cnt个扇区到buf */
void ide_read(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt) { 
c00065d4:	55                   	push   %ebp
c00065d5:	89 e5                	mov    %esp,%ebp
c00065d7:	83 ec 58             	sub    $0x58,%esp
/work/x86_os_my/device/ide.c:151
	ASSERT(lba <= max_lba);
c00065da:	81 7d 0c ff 7f 02 00 	cmpl   $0x27fff,0xc(%ebp)
c00065e1:	76 1c                	jbe    c00065ff <ide_read+0x2b>
/work/x86_os_my/device/ide.c:151 (discriminator 1)
c00065e3:	68 30 e9 00 c0       	push   $0xc000e930
c00065e8:	68 d8 ea 00 c0       	push   $0xc000ead8
c00065ed:	68 97 00 00 00       	push   $0x97
c00065f2:	68 3f e9 00 c0       	push   $0xc000e93f
c00065f7:	e8 65 bf ff ff       	call   c0002561 <panic_spin>
c00065fc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:152
	ASSERT(sec_cnt > 0);
c00065ff:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0006603:	75 1c                	jne    c0006621 <ide_read+0x4d>
/work/x86_os_my/device/ide.c:152 (discriminator 1)
c0006605:	68 4c e9 00 c0       	push   $0xc000e94c
c000660a:	68 d8 ea 00 c0       	push   $0xc000ead8
c000660f:	68 98 00 00 00       	push   $0x98
c0006614:	68 3f e9 00 c0       	push   $0xc000e93f
c0006619:	e8 43 bf ff ff       	call   c0002561 <panic_spin>
c000661e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:153
	lock_acquire (&hd->my_channel->lock);
c0006621:	8b 45 08             	mov    0x8(%ebp),%eax
c0006624:	8b 40 08             	mov    0x8(%eax),%eax
c0006627:	83 c0 0c             	add    $0xc,%eax
c000662a:	83 ec 0c             	sub    $0xc,%esp
c000662d:	50                   	push   %eax
c000662e:	e8 cc e8 ff ff       	call   c0004eff <lock_acquire>
c0006633:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:156

	/* 1 先选择操作的硬盘 */
	select_disk(hd);
c0006636:	83 ec 0c             	sub    $0xc,%esp
c0006639:	ff 75 08             	pushl  0x8(%ebp)
c000663c:	e8 2a fd ff ff       	call   c000636b <select_disk>
c0006641:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:159

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
c0006644:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/ide.c:160
	while(secs_done < sec_cnt) {
c000664b:	e9 d4 00 00 00       	jmp    c0006724 <ide_read+0x150>
/work/x86_os_my/device/ide.c:161
		if ((secs_done + 256) <= sec_cnt) {
c0006650:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006653:	05 00 01 00 00       	add    $0x100,%eax
c0006658:	3b 45 14             	cmp    0x14(%ebp),%eax
c000665b:	77 09                	ja     c0006666 <ide_read+0x92>
/work/x86_os_my/device/ide.c:162
			secs_op = 256;
c000665d:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
c0006664:	eb 09                	jmp    c000666f <ide_read+0x9b>
/work/x86_os_my/device/ide.c:164
		} else {
			secs_op = sec_cnt - secs_done;
c0006666:	8b 45 14             	mov    0x14(%ebp),%eax
c0006669:	2b 45 f0             	sub    -0x10(%ebp),%eax
c000666c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:168
		}

		/* 2 写入待读入的扇区数和起始扇区号 */
		select_sector(hd, lba + secs_done, secs_op);
c000666f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0006672:	0f b6 c0             	movzbl %al,%eax
c0006675:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0006678:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000667b:	01 ca                	add    %ecx,%edx
c000667d:	83 ec 04             	sub    $0x4,%esp
c0006680:	50                   	push   %eax
c0006681:	52                   	push   %edx
c0006682:	ff 75 08             	pushl  0x8(%ebp)
c0006685:	e8 1b fd ff ff       	call   c00063a5 <select_sector>
c000668a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:171

		/* 3 执行的命令写入reg_cmd寄存器 */
		cmd_out(hd->my_channel, CMD_READ_SECTOR);	// 准备开始读数据
c000668d:	8b 45 08             	mov    0x8(%ebp),%eax
c0006690:	8b 40 08             	mov    0x8(%eax),%eax
c0006693:	83 ec 08             	sub    $0x8,%esp
c0006696:	6a 20                	push   $0x20
c0006698:	50                   	push   %eax
c0006699:	e8 01 fe ff ff       	call   c000649f <cmd_out>
c000669e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:176

		/*********************   阻塞自己的时机  ***********************
		在硬盘已经开始工作(开始在内部读数据或写数据)后才能阻塞自己,现在硬盘已经开始忙了,
		将自己阻塞,等待硬盘完成读操作后通过中断处理程序唤醒自己*/
		sema_down(&hd->my_channel->disk_done);
c00066a1:	8b 45 08             	mov    0x8(%ebp),%eax
c00066a4:	8b 40 08             	mov    0x8(%eax),%eax
c00066a7:	83 c0 2c             	add    $0x2c,%eax
c00066aa:	83 ec 0c             	sub    $0xc,%esp
c00066ad:	50                   	push   %eax
c00066ae:	e8 a2 e6 ff ff       	call   c0004d55 <sema_down>
c00066b3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:181
		/*************************************************************/

		/* 4 检测硬盘状态是否可读 */
		/* 醒来后开始执行下面代码*/
		if (!busy_wait(hd)) {	// 若失败
c00066b6:	83 ec 0c             	sub    $0xc,%esp
c00066b9:	ff 75 08             	pushl  0x8(%ebp)
c00066bc:	e8 a4 fe ff ff       	call   c0006565 <busy_wait>
c00066c1:	83 c4 10             	add    $0x10,%esp
c00066c4:	85 c0                	test   %eax,%eax
c00066c6:	75 33                	jne    c00066fb <ide_read+0x127>
/work/x86_os_my/device/ide.c:183
			char error[64];
			sprintf(error, "%s read sector %d failed!!!!!!\n", hd->name, lba);
c00066c8:	8b 45 08             	mov    0x8(%ebp),%eax
c00066cb:	ff 75 0c             	pushl  0xc(%ebp)
c00066ce:	50                   	push   %eax
c00066cf:	68 58 e9 00 c0       	push   $0xc000e958
c00066d4:	8d 45 b0             	lea    -0x50(%ebp),%eax
c00066d7:	50                   	push   %eax
c00066d8:	e8 48 fb ff ff       	call   c0006225 <sprintf>
c00066dd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:184
			PANIC(error);
c00066e0:	8d 45 b0             	lea    -0x50(%ebp),%eax
c00066e3:	50                   	push   %eax
c00066e4:	68 d8 ea 00 c0       	push   $0xc000ead8
c00066e9:	68 b8 00 00 00       	push   $0xb8
c00066ee:	68 3f e9 00 c0       	push   $0xc000e93f
c00066f3:	e8 69 be ff ff       	call   c0002561 <panic_spin>
c00066f8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:188
		}

		/* 5 把数据从硬盘的缓冲区中读出 */
		read_from_sector(hd, (void*)((uint32_t)buf + secs_done * 512), secs_op);
c00066fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00066fe:	0f b6 c0             	movzbl %al,%eax
c0006701:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0006704:	89 d1                	mov    %edx,%ecx
c0006706:	c1 e1 09             	shl    $0x9,%ecx
c0006709:	8b 55 10             	mov    0x10(%ebp),%edx
c000670c:	01 ca                	add    %ecx,%edx
c000670e:	83 ec 04             	sub    $0x4,%esp
c0006711:	50                   	push   %eax
c0006712:	52                   	push   %edx
c0006713:	ff 75 08             	pushl  0x8(%ebp)
c0006716:	e8 b8 fd ff ff       	call   c00064d3 <read_from_sector>
c000671b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:189
		secs_done += secs_op;
c000671e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0006721:	01 45 f0             	add    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:160
	/* 1 先选择操作的硬盘 */
	select_disk(hd);

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
	while(secs_done < sec_cnt) {
c0006724:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006727:	3b 45 14             	cmp    0x14(%ebp),%eax
c000672a:	0f 82 20 ff ff ff    	jb     c0006650 <ide_read+0x7c>
/work/x86_os_my/device/ide.c:191

		/* 5 把数据从硬盘的缓冲区中读出 */
		read_from_sector(hd, (void*)((uint32_t)buf + secs_done * 512), secs_op);
		secs_done += secs_op;
	}
	lock_release(&hd->my_channel->lock);
c0006730:	8b 45 08             	mov    0x8(%ebp),%eax
c0006733:	8b 40 08             	mov    0x8(%eax),%eax
c0006736:	83 c0 0c             	add    $0xc,%eax
c0006739:	83 ec 0c             	sub    $0xc,%esp
c000673c:	50                   	push   %eax
c000673d:	e8 34 e8 ff ff       	call   c0004f76 <lock_release>
c0006742:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:192
}
c0006745:	90                   	nop
c0006746:	c9                   	leave  
c0006747:	c3                   	ret    

c0006748 <ide_write>:
ide_write():
/work/x86_os_my/device/ide.c:195

/* 将buf中sec_cnt扇区数据写入硬盘 */
void ide_write(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt) {
c0006748:	55                   	push   %ebp
c0006749:	89 e5                	mov    %esp,%ebp
c000674b:	83 ec 58             	sub    $0x58,%esp
/work/x86_os_my/device/ide.c:196
	ASSERT(lba <= max_lba);
c000674e:	81 7d 0c ff 7f 02 00 	cmpl   $0x27fff,0xc(%ebp)
c0006755:	76 1c                	jbe    c0006773 <ide_write+0x2b>
/work/x86_os_my/device/ide.c:196 (discriminator 1)
c0006757:	68 30 e9 00 c0       	push   $0xc000e930
c000675c:	68 e4 ea 00 c0       	push   $0xc000eae4
c0006761:	68 c4 00 00 00       	push   $0xc4
c0006766:	68 3f e9 00 c0       	push   $0xc000e93f
c000676b:	e8 f1 bd ff ff       	call   c0002561 <panic_spin>
c0006770:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:197
	ASSERT(sec_cnt > 0);
c0006773:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0006777:	75 1c                	jne    c0006795 <ide_write+0x4d>
/work/x86_os_my/device/ide.c:197 (discriminator 1)
c0006779:	68 4c e9 00 c0       	push   $0xc000e94c
c000677e:	68 e4 ea 00 c0       	push   $0xc000eae4
c0006783:	68 c5 00 00 00       	push   $0xc5
c0006788:	68 3f e9 00 c0       	push   $0xc000e93f
c000678d:	e8 cf bd ff ff       	call   c0002561 <panic_spin>
c0006792:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:198
	lock_acquire (&hd->my_channel->lock);
c0006795:	8b 45 08             	mov    0x8(%ebp),%eax
c0006798:	8b 40 08             	mov    0x8(%eax),%eax
c000679b:	83 c0 0c             	add    $0xc,%eax
c000679e:	83 ec 0c             	sub    $0xc,%esp
c00067a1:	50                   	push   %eax
c00067a2:	e8 58 e7 ff ff       	call   c0004eff <lock_acquire>
c00067a7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:201

	/* 1 先选择操作的硬盘 */
	select_disk(hd);
c00067aa:	83 ec 0c             	sub    $0xc,%esp
c00067ad:	ff 75 08             	pushl  0x8(%ebp)
c00067b0:	e8 b6 fb ff ff       	call   c000636b <select_disk>
c00067b5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:204

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
c00067b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/ide.c:205
	while(secs_done < sec_cnt) {
c00067bf:	e9 d4 00 00 00       	jmp    c0006898 <ide_write+0x150>
/work/x86_os_my/device/ide.c:206
		if ((secs_done + 256) <= sec_cnt) {
c00067c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00067c7:	05 00 01 00 00       	add    $0x100,%eax
c00067cc:	3b 45 14             	cmp    0x14(%ebp),%eax
c00067cf:	77 09                	ja     c00067da <ide_write+0x92>
/work/x86_os_my/device/ide.c:207
			secs_op = 256;
c00067d1:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
c00067d8:	eb 09                	jmp    c00067e3 <ide_write+0x9b>
/work/x86_os_my/device/ide.c:209
		} else {
			secs_op = sec_cnt - secs_done;
c00067da:	8b 45 14             	mov    0x14(%ebp),%eax
c00067dd:	2b 45 f0             	sub    -0x10(%ebp),%eax
c00067e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:213
		}

		/* 2 写入待写入的扇区数和起始扇区号 */
		select_sector(hd, lba + secs_done, secs_op);
c00067e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00067e6:	0f b6 c0             	movzbl %al,%eax
c00067e9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c00067ec:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00067ef:	01 ca                	add    %ecx,%edx
c00067f1:	83 ec 04             	sub    $0x4,%esp
c00067f4:	50                   	push   %eax
c00067f5:	52                   	push   %edx
c00067f6:	ff 75 08             	pushl  0x8(%ebp)
c00067f9:	e8 a7 fb ff ff       	call   c00063a5 <select_sector>
c00067fe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:216

		/* 3 执行的命令写入reg_cmd寄存器 */
		cmd_out(hd->my_channel, CMD_WRITE_SECTOR);	// 准备开始写数据
c0006801:	8b 45 08             	mov    0x8(%ebp),%eax
c0006804:	8b 40 08             	mov    0x8(%eax),%eax
c0006807:	83 ec 08             	sub    $0x8,%esp
c000680a:	6a 30                	push   $0x30
c000680c:	50                   	push   %eax
c000680d:	e8 8d fc ff ff       	call   c000649f <cmd_out>
c0006812:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:219

		/* 4 检测硬盘状态是否可读 */
		if (!busy_wait(hd)) {	// 若失败
c0006815:	83 ec 0c             	sub    $0xc,%esp
c0006818:	ff 75 08             	pushl  0x8(%ebp)
c000681b:	e8 45 fd ff ff       	call   c0006565 <busy_wait>
c0006820:	83 c4 10             	add    $0x10,%esp
c0006823:	85 c0                	test   %eax,%eax
c0006825:	75 33                	jne    c000685a <ide_write+0x112>
/work/x86_os_my/device/ide.c:221
			char error[64];
			sprintf(error, "%s write sector %d failed!!!!!!\n", hd->name, lba);
c0006827:	8b 45 08             	mov    0x8(%ebp),%eax
c000682a:	ff 75 0c             	pushl  0xc(%ebp)
c000682d:	50                   	push   %eax
c000682e:	68 78 e9 00 c0       	push   $0xc000e978
c0006833:	8d 45 b0             	lea    -0x50(%ebp),%eax
c0006836:	50                   	push   %eax
c0006837:	e8 e9 f9 ff ff       	call   c0006225 <sprintf>
c000683c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:222
			PANIC(error);
c000683f:	8d 45 b0             	lea    -0x50(%ebp),%eax
c0006842:	50                   	push   %eax
c0006843:	68 e4 ea 00 c0       	push   $0xc000eae4
c0006848:	68 de 00 00 00       	push   $0xde
c000684d:	68 3f e9 00 c0       	push   $0xc000e93f
c0006852:	e8 0a bd ff ff       	call   c0002561 <panic_spin>
c0006857:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:226
		}

		/* 5 将数据写入硬盘 */
		write2sector(hd, (void*)((uint32_t)buf + secs_done * 512), secs_op);
c000685a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000685d:	0f b6 c0             	movzbl %al,%eax
c0006860:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0006863:	89 d1                	mov    %edx,%ecx
c0006865:	c1 e1 09             	shl    $0x9,%ecx
c0006868:	8b 55 10             	mov    0x10(%ebp),%edx
c000686b:	01 ca                	add    %ecx,%edx
c000686d:	83 ec 04             	sub    $0x4,%esp
c0006870:	50                   	push   %eax
c0006871:	52                   	push   %edx
c0006872:	ff 75 08             	pushl  0x8(%ebp)
c0006875:	e8 a2 fc ff ff       	call   c000651c <write2sector>
c000687a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:229

		/* 在硬盘响应期间阻塞自己 */
		sema_down(&hd->my_channel->disk_done);
c000687d:	8b 45 08             	mov    0x8(%ebp),%eax
c0006880:	8b 40 08             	mov    0x8(%eax),%eax
c0006883:	83 c0 2c             	add    $0x2c,%eax
c0006886:	83 ec 0c             	sub    $0xc,%esp
c0006889:	50                   	push   %eax
c000688a:	e8 c6 e4 ff ff       	call   c0004d55 <sema_down>
c000688f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:230
		secs_done += secs_op;
c0006892:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0006895:	01 45 f0             	add    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:205
	/* 1 先选择操作的硬盘 */
	select_disk(hd);

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
	while(secs_done < sec_cnt) {
c0006898:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000689b:	3b 45 14             	cmp    0x14(%ebp),%eax
c000689e:	0f 82 20 ff ff ff    	jb     c00067c4 <ide_write+0x7c>
/work/x86_os_my/device/ide.c:233
		/* 在硬盘响应期间阻塞自己 */
		sema_down(&hd->my_channel->disk_done);
		secs_done += secs_op;
	}
	/* 醒来后开始释放锁*/
	lock_release(&hd->my_channel->lock);
c00068a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00068a7:	8b 40 08             	mov    0x8(%eax),%eax
c00068aa:	83 c0 0c             	add    $0xc,%eax
c00068ad:	83 ec 0c             	sub    $0xc,%esp
c00068b0:	50                   	push   %eax
c00068b1:	e8 c0 e6 ff ff       	call   c0004f76 <lock_release>
c00068b6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:234
}
c00068b9:	90                   	nop
c00068ba:	c9                   	leave  
c00068bb:	c3                   	ret    

c00068bc <swap_pairs_bytes>:
swap_pairs_bytes():
/work/x86_os_my/device/ide.c:238

/////////////////////////////////////// 读取分区表部分 ////////////////////////////////////////////////
/* 将dst中len个相邻字节交换位置后存入buf */
static void swap_pairs_bytes(const char* dst, char* buf, uint32_t len) {
c00068bc:	55                   	push   %ebp
c00068bd:	89 e5                	mov    %esp,%ebp
c00068bf:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/device/ide.c:240
	uint8_t idx;
	for (idx = 0; idx < len; idx += 2) {
c00068c2:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
c00068c6:	eb 37                	jmp    c00068ff <swap_pairs_bytes+0x43>
/work/x86_os_my/device/ide.c:242 (discriminator 3)
		/* buf中存储dst中两相邻元素交换位置后的字符串*/
		buf[idx + 1] = *dst++;
c00068c8:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c00068cc:	8d 50 01             	lea    0x1(%eax),%edx
c00068cf:	8b 45 0c             	mov    0xc(%ebp),%eax
c00068d2:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c00068d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00068d8:	8d 50 01             	lea    0x1(%eax),%edx
c00068db:	89 55 08             	mov    %edx,0x8(%ebp)
c00068de:	0f b6 00             	movzbl (%eax),%eax
c00068e1:	88 01                	mov    %al,(%ecx)
/work/x86_os_my/device/ide.c:243 (discriminator 3)
		buf[idx]     = *dst++;
c00068e3:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c00068e7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00068ea:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c00068ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00068f0:	8d 50 01             	lea    0x1(%eax),%edx
c00068f3:	89 55 08             	mov    %edx,0x8(%ebp)
c00068f6:	0f b6 00             	movzbl (%eax),%eax
c00068f9:	88 01                	mov    %al,(%ecx)
/work/x86_os_my/device/ide.c:240 (discriminator 3)

/////////////////////////////////////// 读取分区表部分 ////////////////////////////////////////////////
/* 将dst中len个相邻字节交换位置后存入buf */
static void swap_pairs_bytes(const char* dst, char* buf, uint32_t len) {
	uint8_t idx;
	for (idx = 0; idx < len; idx += 2) {
c00068fb:	80 45 ff 02          	addb   $0x2,-0x1(%ebp)
/work/x86_os_my/device/ide.c:240 (discriminator 1)
c00068ff:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c0006903:	3b 45 10             	cmp    0x10(%ebp),%eax
c0006906:	72 c0                	jb     c00068c8 <swap_pairs_bytes+0xc>
/work/x86_os_my/device/ide.c:245
		/* buf中存储dst中两相邻元素交换位置后的字符串*/
		buf[idx + 1] = *dst++;
		buf[idx]     = *dst++;
	}
	buf[idx] = '\0';
c0006908:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c000690c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000690f:	01 d0                	add    %edx,%eax
c0006911:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/device/ide.c:246
}
c0006914:	90                   	nop
c0006915:	c9                   	leave  
c0006916:	c3                   	ret    

c0006917 <identify_disk>:
identify_disk():
/work/x86_os_my/device/ide.c:249

/* 获得硬盘参数信息 */
static void identify_disk(struct disk* hd) {
c0006917:	55                   	push   %ebp
c0006918:	89 e5                	mov    %esp,%ebp
c000691a:	81 ec 98 02 00 00    	sub    $0x298,%esp
/work/x86_os_my/device/ide.c:251
	char id_info[512];
	select_disk(hd);
c0006920:	ff 75 08             	pushl  0x8(%ebp)
c0006923:	e8 43 fa ff ff       	call   c000636b <select_disk>
c0006928:	83 c4 04             	add    $0x4,%esp
/work/x86_os_my/device/ide.c:252
	cmd_out(hd->my_channel, CMD_IDENTIFY);
c000692b:	8b 45 08             	mov    0x8(%ebp),%eax
c000692e:	8b 40 08             	mov    0x8(%eax),%eax
c0006931:	68 ec 00 00 00       	push   $0xec
c0006936:	50                   	push   %eax
c0006937:	e8 63 fb ff ff       	call   c000649f <cmd_out>
c000693c:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/ide.c:255
	/* 向硬盘发送指令后便通过信号量阻塞自己,
	* 待硬盘处理完成后,通过中断处理程序将自己唤醒 */
	sema_down(&hd->my_channel->disk_done);
c000693f:	8b 45 08             	mov    0x8(%ebp),%eax
c0006942:	8b 40 08             	mov    0x8(%eax),%eax
c0006945:	83 c0 2c             	add    $0x2c,%eax
c0006948:	83 ec 0c             	sub    $0xc,%esp
c000694b:	50                   	push   %eax
c000694c:	e8 04 e4 ff ff       	call   c0004d55 <sema_down>
c0006951:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:258

	/* 醒来后开始执行下面代码*/
	if (!busy_wait(hd)) {     //  若失败
c0006954:	83 ec 0c             	sub    $0xc,%esp
c0006957:	ff 75 08             	pushl  0x8(%ebp)
c000695a:	e8 06 fc ff ff       	call   c0006565 <busy_wait>
c000695f:	83 c4 10             	add    $0x10,%esp
c0006962:	85 c0                	test   %eax,%eax
c0006964:	75 39                	jne    c000699f <identify_disk+0x88>
/work/x86_os_my/device/ide.c:260
		char error[64];
		sprintf(error, "%s identify failed!!!!!!\n", hd->name);
c0006966:	8b 45 08             	mov    0x8(%ebp),%eax
c0006969:	83 ec 04             	sub    $0x4,%esp
c000696c:	50                   	push   %eax
c000696d:	68 99 e9 00 c0       	push   $0xc000e999
c0006972:	8d 85 70 fd ff ff    	lea    -0x290(%ebp),%eax
c0006978:	50                   	push   %eax
c0006979:	e8 a7 f8 ff ff       	call   c0006225 <sprintf>
c000697e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:261
		PANIC(error);
c0006981:	8d 85 70 fd ff ff    	lea    -0x290(%ebp),%eax
c0006987:	50                   	push   %eax
c0006988:	68 f0 ea 00 c0       	push   $0xc000eaf0
c000698d:	68 05 01 00 00       	push   $0x105
c0006992:	68 3f e9 00 c0       	push   $0xc000e93f
c0006997:	e8 c5 bb ff ff       	call   c0002561 <panic_spin>
c000699c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:263
	}
	read_from_sector(hd, id_info, 1);
c000699f:	83 ec 04             	sub    $0x4,%esp
c00069a2:	6a 01                	push   $0x1
c00069a4:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c00069aa:	50                   	push   %eax
c00069ab:	ff 75 08             	pushl  0x8(%ebp)
c00069ae:	e8 20 fb ff ff       	call   c00064d3 <read_from_sector>
c00069b3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:266

	char buf[64];
	uint8_t sn_start = 10 * 2, sn_len = 20, md_start = 27 * 2, md_len = 40;
c00069b6:	c6 45 f7 14          	movb   $0x14,-0x9(%ebp)
c00069ba:	c6 45 f6 14          	movb   $0x14,-0xa(%ebp)
c00069be:	c6 45 f5 36          	movb   $0x36,-0xb(%ebp)
c00069c2:	c6 45 f4 28          	movb   $0x28,-0xc(%ebp)
/work/x86_os_my/device/ide.c:267
	swap_pairs_bytes(&id_info[sn_start], buf, sn_len);
c00069c6:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c00069ca:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c00069ce:	8d 8d f0 fd ff ff    	lea    -0x210(%ebp),%ecx
c00069d4:	01 ca                	add    %ecx,%edx
c00069d6:	83 ec 04             	sub    $0x4,%esp
c00069d9:	50                   	push   %eax
c00069da:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c00069e0:	50                   	push   %eax
c00069e1:	52                   	push   %edx
c00069e2:	e8 d5 fe ff ff       	call   c00068bc <swap_pairs_bytes>
c00069e7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:268
	printk("   disk %s info:\n      SN: %s\n", hd->name, buf);
c00069ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00069ed:	83 ec 04             	sub    $0x4,%esp
c00069f0:	8d 95 b0 fd ff ff    	lea    -0x250(%ebp),%edx
c00069f6:	52                   	push   %edx
c00069f7:	50                   	push   %eax
c00069f8:	68 b4 e9 00 c0       	push   $0xc000e9b4
c00069fd:	e8 4b 06 00 00       	call   c000704d <printk>
c0006a02:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:269
	memset(buf, 0, sizeof(buf));
c0006a05:	83 ec 04             	sub    $0x4,%esp
c0006a08:	6a 40                	push   $0x40
c0006a0a:	6a 00                	push   $0x0
c0006a0c:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c0006a12:	50                   	push   %eax
c0006a13:	e8 4d d0 ff ff       	call   c0003a65 <memset>
c0006a18:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:270
	swap_pairs_bytes(&id_info[md_start], buf, md_len);
c0006a1b:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0006a1f:	0f b6 55 f5          	movzbl -0xb(%ebp),%edx
c0006a23:	8d 8d f0 fd ff ff    	lea    -0x210(%ebp),%ecx
c0006a29:	01 ca                	add    %ecx,%edx
c0006a2b:	83 ec 04             	sub    $0x4,%esp
c0006a2e:	50                   	push   %eax
c0006a2f:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c0006a35:	50                   	push   %eax
c0006a36:	52                   	push   %edx
c0006a37:	e8 80 fe ff ff       	call   c00068bc <swap_pairs_bytes>
c0006a3c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:271
	printk("      MODULE: %s\n", buf);
c0006a3f:	83 ec 08             	sub    $0x8,%esp
c0006a42:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c0006a48:	50                   	push   %eax
c0006a49:	68 d3 e9 00 c0       	push   $0xc000e9d3
c0006a4e:	e8 fa 05 00 00       	call   c000704d <printk>
c0006a53:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:272
	uint32_t sectors = *(uint32_t*)&id_info[60 * 2];
c0006a56:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c0006a5c:	83 c0 78             	add    $0x78,%eax
c0006a5f:	8b 00                	mov    (%eax),%eax
c0006a61:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:273
	printk("      SECTORS: %d\n", sectors);
c0006a64:	83 ec 08             	sub    $0x8,%esp
c0006a67:	ff 75 f0             	pushl  -0x10(%ebp)
c0006a6a:	68 e5 e9 00 c0       	push   $0xc000e9e5
c0006a6f:	e8 d9 05 00 00       	call   c000704d <printk>
c0006a74:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:274
	printk("      CAPACITY: %dMB\n", sectors * 512 / 1024 / 1024);
c0006a77:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006a7a:	c1 e0 09             	shl    $0x9,%eax
c0006a7d:	c1 e8 14             	shr    $0x14,%eax
c0006a80:	83 ec 08             	sub    $0x8,%esp
c0006a83:	50                   	push   %eax
c0006a84:	68 f8 e9 00 c0       	push   $0xc000e9f8
c0006a89:	e8 bf 05 00 00       	call   c000704d <printk>
c0006a8e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:275
}
c0006a91:	90                   	nop
c0006a92:	c9                   	leave  
c0006a93:	c3                   	ret    

c0006a94 <partition_scan>:
partition_scan():
/work/x86_os_my/device/ide.c:278

/* 扫描硬盘hd中地址为ext_lba的扇区中的所有分区 */
static void partition_scan(struct disk* hd, uint32_t ext_lba) {
c0006a94:	55                   	push   %ebp
c0006a95:	89 e5                	mov    %esp,%ebp
c0006a97:	53                   	push   %ebx
c0006a98:	83 ec 14             	sub    $0x14,%esp
/work/x86_os_my/device/ide.c:279
	struct boot_sector* bs = sys_malloc(sizeof(struct boot_sector));
c0006a9b:	83 ec 0c             	sub    $0xc,%esp
c0006a9e:	68 00 02 00 00       	push   $0x200
c0006aa3:	e8 64 c4 ff ff       	call   c0002f0c <sys_malloc>
c0006aa8:	83 c4 10             	add    $0x10,%esp
c0006aab:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/device/ide.c:280
	ide_read(hd, ext_lba, bs, 1);
c0006aae:	6a 01                	push   $0x1
c0006ab0:	ff 75 ec             	pushl  -0x14(%ebp)
c0006ab3:	ff 75 0c             	pushl  0xc(%ebp)
c0006ab6:	ff 75 08             	pushl  0x8(%ebp)
c0006ab9:	e8 16 fb ff ff       	call   c00065d4 <ide_read>
c0006abe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:281
	uint8_t part_idx = 0;
c0006ac1:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/device/ide.c:282
	struct partition_table_entry* p = bs->partition_table;
c0006ac5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0006ac8:	05 be 01 00 00       	add    $0x1be,%eax
c0006acd:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:285

	/* 遍历分区表4个分区表项 */
	while (part_idx++ < 4) {
c0006ad0:	e9 53 02 00 00       	jmp    c0006d28 <partition_scan+0x294>
/work/x86_os_my/device/ide.c:286
		if (p->fs_type == 0x5) {	// 若为扩展分区
c0006ad5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006ad8:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0006adc:	3c 05                	cmp    $0x5,%al
c0006ade:	75 50                	jne    c0006b30 <partition_scan+0x9c>
/work/x86_os_my/device/ide.c:287
			if (ext_lba_base != 0) {
c0006ae0:	a1 ac 36 01 c0       	mov    0xc00136ac,%eax
c0006ae5:	85 c0                	test   %eax,%eax
c0006ae7:	74 22                	je     c0006b0b <partition_scan+0x77>
/work/x86_os_my/device/ide.c:289
				/* 子扩展分区的start_lba是相对于主引导扇区中的总扩展分区地址 */
				partition_scan(hd, p->start_lba + ext_lba_base);
c0006ae9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006aec:	8b 40 08             	mov    0x8(%eax),%eax
c0006aef:	8b 15 ac 36 01 c0    	mov    0xc00136ac,%edx
c0006af5:	01 d0                	add    %edx,%eax
c0006af7:	83 ec 08             	sub    $0x8,%esp
c0006afa:	50                   	push   %eax
c0006afb:	ff 75 08             	pushl  0x8(%ebp)
c0006afe:	e8 91 ff ff ff       	call   c0006a94 <partition_scan>
c0006b03:	83 c4 10             	add    $0x10,%esp
c0006b06:	e9 19 02 00 00       	jmp    c0006d24 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:292
			} else {	// ext_lba_base为0表示是第一次读取引导块,也就是主引导记录所在的扇区
				/* 记录下扩展分区的起始lba地址,后面所有的扩展分区地址都相对于此 */
				ext_lba_base = p->start_lba;
c0006b0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006b0e:	8b 40 08             	mov    0x8(%eax),%eax
c0006b11:	a3 ac 36 01 c0       	mov    %eax,0xc00136ac
/work/x86_os_my/device/ide.c:293
				partition_scan(hd, p->start_lba);
c0006b16:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006b19:	8b 40 08             	mov    0x8(%eax),%eax
c0006b1c:	83 ec 08             	sub    $0x8,%esp
c0006b1f:	50                   	push   %eax
c0006b20:	ff 75 08             	pushl  0x8(%ebp)
c0006b23:	e8 6c ff ff ff       	call   c0006a94 <partition_scan>
c0006b28:	83 c4 10             	add    $0x10,%esp
c0006b2b:	e9 f4 01 00 00       	jmp    c0006d24 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:295
			}
		} else if (p->fs_type != 0) {	// 若是有效的分区类型
c0006b30:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006b33:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0006b37:	84 c0                	test   %al,%al
c0006b39:	0f 84 e5 01 00 00    	je     c0006d24 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:296
			if (ext_lba == 0) {	// 此时全是主分区
c0006b3f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0006b43:	0f 85 f9 00 00 00    	jne    c0006c42 <partition_scan+0x1ae>
/work/x86_os_my/device/ide.c:297
				hd->prim_parts[p_no].start_lba = ext_lba + p->start_lba;
c0006b49:	0f b6 05 b0 36 01 c0 	movzbl 0xc00136b0,%eax
c0006b50:	0f b6 c8             	movzbl %al,%ecx
c0006b53:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006b56:	8b 50 08             	mov    0x8(%eax),%edx
c0006b59:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006b5c:	01 c2                	add    %eax,%edx
c0006b5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0006b61:	c1 e1 06             	shl    $0x6,%ecx
c0006b64:	01 c8                	add    %ecx,%eax
c0006b66:	83 c0 10             	add    $0x10,%eax
c0006b69:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ide.c:298
				hd->prim_parts[p_no].sec_cnt = p->sec_cnt;
c0006b6b:	0f b6 05 b0 36 01 c0 	movzbl 0xc00136b0,%eax
c0006b72:	0f b6 c8             	movzbl %al,%ecx
c0006b75:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006b78:	8b 40 0c             	mov    0xc(%eax),%eax
c0006b7b:	8b 55 08             	mov    0x8(%ebp),%edx
c0006b7e:	c1 e1 06             	shl    $0x6,%ecx
c0006b81:	01 ca                	add    %ecx,%edx
c0006b83:	83 c2 14             	add    $0x14,%edx
c0006b86:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:299
				hd->prim_parts[p_no].my_disk = hd;
c0006b88:	0f b6 05 b0 36 01 c0 	movzbl 0xc00136b0,%eax
c0006b8f:	0f b6 d0             	movzbl %al,%edx
c0006b92:	8b 45 08             	mov    0x8(%ebp),%eax
c0006b95:	c1 e2 06             	shl    $0x6,%edx
c0006b98:	01 d0                	add    %edx,%eax
c0006b9a:	8d 50 18             	lea    0x18(%eax),%edx
c0006b9d:	8b 45 08             	mov    0x8(%ebp),%eax
c0006ba0:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:300
				list_append(&partition_list, &hd->prim_parts[p_no].part_tag);
c0006ba2:	0f b6 05 b0 36 01 c0 	movzbl 0xc00136b0,%eax
c0006ba9:	0f b6 c0             	movzbl %al,%eax
c0006bac:	c1 e0 06             	shl    $0x6,%eax
c0006baf:	8d 50 10             	lea    0x10(%eax),%edx
c0006bb2:	8b 45 08             	mov    0x8(%ebp),%eax
c0006bb5:	01 d0                	add    %edx,%eax
c0006bb7:	83 c0 0c             	add    $0xc,%eax
c0006bba:	83 ec 08             	sub    $0x8,%esp
c0006bbd:	50                   	push   %eax
c0006bbe:	68 80 58 01 c0       	push   $0xc0015880
c0006bc3:	e8 02 df ff ff       	call   c0004aca <list_append>
c0006bc8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:301
				sprintf(hd->prim_parts[p_no].name, "%s%d", hd->name, p_no + 1);
c0006bcb:	0f b6 05 b0 36 01 c0 	movzbl 0xc00136b0,%eax
c0006bd2:	0f b6 c0             	movzbl %al,%eax
c0006bd5:	8d 48 01             	lea    0x1(%eax),%ecx
c0006bd8:	8b 45 08             	mov    0x8(%ebp),%eax
c0006bdb:	0f b6 15 b0 36 01 c0 	movzbl 0xc00136b0,%edx
c0006be2:	0f b6 d2             	movzbl %dl,%edx
c0006be5:	c1 e2 06             	shl    $0x6,%edx
c0006be8:	8d 5a 20             	lea    0x20(%edx),%ebx
c0006beb:	8b 55 08             	mov    0x8(%ebp),%edx
c0006bee:	01 da                	add    %ebx,%edx
c0006bf0:	83 c2 04             	add    $0x4,%edx
c0006bf3:	51                   	push   %ecx
c0006bf4:	50                   	push   %eax
c0006bf5:	68 0e ea 00 c0       	push   $0xc000ea0e
c0006bfa:	52                   	push   %edx
c0006bfb:	e8 25 f6 ff ff       	call   c0006225 <sprintf>
c0006c00:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:302
				p_no++;
c0006c03:	0f b6 05 b0 36 01 c0 	movzbl 0xc00136b0,%eax
c0006c0a:	83 c0 01             	add    $0x1,%eax
c0006c0d:	a2 b0 36 01 c0       	mov    %al,0xc00136b0
/work/x86_os_my/device/ide.c:303
				ASSERT(p_no < 4);	// 0,1,2,3
c0006c12:	0f b6 05 b0 36 01 c0 	movzbl 0xc00136b0,%eax
c0006c19:	3c 03                	cmp    $0x3,%al
c0006c1b:	0f 86 03 01 00 00    	jbe    c0006d24 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:303 (discriminator 1)
c0006c21:	68 13 ea 00 c0       	push   $0xc000ea13
c0006c26:	68 00 eb 00 c0       	push   $0xc000eb00
c0006c2b:	68 2f 01 00 00       	push   $0x12f
c0006c30:	68 3f e9 00 c0       	push   $0xc000e93f
c0006c35:	e8 27 b9 ff ff       	call   c0002561 <panic_spin>
c0006c3a:	83 c4 10             	add    $0x10,%esp
c0006c3d:	e9 e2 00 00 00       	jmp    c0006d24 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:305
			} else {
				hd->logic_parts[l_no].start_lba = ext_lba + p->start_lba;
c0006c42:	0f b6 05 b1 36 01 c0 	movzbl 0xc00136b1,%eax
c0006c49:	0f b6 c8             	movzbl %al,%ecx
c0006c4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006c4f:	8b 50 08             	mov    0x8(%eax),%edx
c0006c52:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006c55:	01 c2                	add    %eax,%edx
c0006c57:	8b 45 08             	mov    0x8(%ebp),%eax
c0006c5a:	c1 e1 06             	shl    $0x6,%ecx
c0006c5d:	01 c8                	add    %ecx,%eax
c0006c5f:	05 10 01 00 00       	add    $0x110,%eax
c0006c64:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ide.c:306
				hd->logic_parts[l_no].sec_cnt = p->sec_cnt;
c0006c66:	0f b6 05 b1 36 01 c0 	movzbl 0xc00136b1,%eax
c0006c6d:	0f b6 c8             	movzbl %al,%ecx
c0006c70:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006c73:	8b 40 0c             	mov    0xc(%eax),%eax
c0006c76:	8b 55 08             	mov    0x8(%ebp),%edx
c0006c79:	c1 e1 06             	shl    $0x6,%ecx
c0006c7c:	01 ca                	add    %ecx,%edx
c0006c7e:	81 c2 14 01 00 00    	add    $0x114,%edx
c0006c84:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:307
				hd->logic_parts[l_no].my_disk = hd;
c0006c86:	0f b6 05 b1 36 01 c0 	movzbl 0xc00136b1,%eax
c0006c8d:	0f b6 d0             	movzbl %al,%edx
c0006c90:	8b 45 08             	mov    0x8(%ebp),%eax
c0006c93:	c1 e2 06             	shl    $0x6,%edx
c0006c96:	01 d0                	add    %edx,%eax
c0006c98:	8d 90 18 01 00 00    	lea    0x118(%eax),%edx
c0006c9e:	8b 45 08             	mov    0x8(%ebp),%eax
c0006ca1:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:308
				list_append(&partition_list, &hd->logic_parts[l_no].part_tag);
c0006ca3:	0f b6 05 b1 36 01 c0 	movzbl 0xc00136b1,%eax
c0006caa:	0f b6 c0             	movzbl %al,%eax
c0006cad:	c1 e0 06             	shl    $0x6,%eax
c0006cb0:	8d 90 10 01 00 00    	lea    0x110(%eax),%edx
c0006cb6:	8b 45 08             	mov    0x8(%ebp),%eax
c0006cb9:	01 d0                	add    %edx,%eax
c0006cbb:	83 c0 0c             	add    $0xc,%eax
c0006cbe:	83 ec 08             	sub    $0x8,%esp
c0006cc1:	50                   	push   %eax
c0006cc2:	68 80 58 01 c0       	push   $0xc0015880
c0006cc7:	e8 fe dd ff ff       	call   c0004aca <list_append>
c0006ccc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:309
				sprintf(hd->logic_parts[l_no].name, "%s%d", hd->name, l_no + 5);	// 逻辑分区数字是从5开始,主分区是1～4.
c0006ccf:	0f b6 05 b1 36 01 c0 	movzbl 0xc00136b1,%eax
c0006cd6:	0f b6 c0             	movzbl %al,%eax
c0006cd9:	8d 48 05             	lea    0x5(%eax),%ecx
c0006cdc:	8b 45 08             	mov    0x8(%ebp),%eax
c0006cdf:	0f b6 15 b1 36 01 c0 	movzbl 0xc00136b1,%edx
c0006ce6:	0f b6 d2             	movzbl %dl,%edx
c0006ce9:	c1 e2 06             	shl    $0x6,%edx
c0006cec:	8d 9a 20 01 00 00    	lea    0x120(%edx),%ebx
c0006cf2:	8b 55 08             	mov    0x8(%ebp),%edx
c0006cf5:	01 da                	add    %ebx,%edx
c0006cf7:	83 c2 04             	add    $0x4,%edx
c0006cfa:	51                   	push   %ecx
c0006cfb:	50                   	push   %eax
c0006cfc:	68 0e ea 00 c0       	push   $0xc000ea0e
c0006d01:	52                   	push   %edx
c0006d02:	e8 1e f5 ff ff       	call   c0006225 <sprintf>
c0006d07:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:310
				l_no++;
c0006d0a:	0f b6 05 b1 36 01 c0 	movzbl 0xc00136b1,%eax
c0006d11:	83 c0 01             	add    $0x1,%eax
c0006d14:	a2 b1 36 01 c0       	mov    %al,0xc00136b1
/work/x86_os_my/device/ide.c:311
				if (l_no >= 8)	// 只支持8个逻辑分区,避免数组越界
c0006d19:	0f b6 05 b1 36 01 c0 	movzbl 0xc00136b1,%eax
c0006d20:	3c 07                	cmp    $0x7,%al
c0006d22:	77 26                	ja     c0006d4a <partition_scan+0x2b6>
/work/x86_os_my/device/ide.c:315
					return;
			}
		}
		p++;
c0006d24:	83 45 f0 10          	addl   $0x10,-0x10(%ebp)
/work/x86_os_my/device/ide.c:285
	ide_read(hd, ext_lba, bs, 1);
	uint8_t part_idx = 0;
	struct partition_table_entry* p = bs->partition_table;

	/* 遍历分区表4个分区表项 */
	while (part_idx++ < 4) {
c0006d28:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0006d2c:	8d 50 01             	lea    0x1(%eax),%edx
c0006d2f:	88 55 f7             	mov    %dl,-0x9(%ebp)
c0006d32:	3c 03                	cmp    $0x3,%al
c0006d34:	0f 86 9b fd ff ff    	jbe    c0006ad5 <partition_scan+0x41>
/work/x86_os_my/device/ide.c:317
					return;
			}
		}
		p++;
	}
	sys_free(bs);
c0006d3a:	83 ec 0c             	sub    $0xc,%esp
c0006d3d:	ff 75 ec             	pushl  -0x14(%ebp)
c0006d40:	e8 f4 c7 ff ff       	call   c0003539 <sys_free>
c0006d45:	83 c4 10             	add    $0x10,%esp
c0006d48:	eb 01                	jmp    c0006d4b <partition_scan+0x2b7>
/work/x86_os_my/device/ide.c:312
				hd->logic_parts[l_no].my_disk = hd;
				list_append(&partition_list, &hd->logic_parts[l_no].part_tag);
				sprintf(hd->logic_parts[l_no].name, "%s%d", hd->name, l_no + 5);	// 逻辑分区数字是从5开始,主分区是1～4.
				l_no++;
				if (l_no >= 8)	// 只支持8个逻辑分区,避免数组越界
					return;
c0006d4a:	90                   	nop
/work/x86_os_my/device/ide.c:318
			}
		}
		p++;
	}
	sys_free(bs);
}
c0006d4b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0006d4e:	c9                   	leave  
c0006d4f:	c3                   	ret    

c0006d50 <partition_info>:
partition_info():
/work/x86_os_my/device/ide.c:321

/* 打印分区信息 */
static bool partition_info(struct list_elem* pelem, int arg UNUSED) {
c0006d50:	55                   	push   %ebp
c0006d51:	89 e5                	mov    %esp,%ebp
c0006d53:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ide.c:322
	struct partition* part = elem2entry(struct partition, part_tag, pelem);
c0006d56:	8b 45 08             	mov    0x8(%ebp),%eax
c0006d59:	83 e8 0c             	sub    $0xc,%eax
c0006d5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:323
	printk("   %s start_lba:0x%x, sec_cnt:0x%x\n",part->name, part->start_lba, part->sec_cnt);
c0006d5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0006d62:	8b 50 04             	mov    0x4(%eax),%edx
c0006d65:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0006d68:	8b 00                	mov    (%eax),%eax
c0006d6a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0006d6d:	83 c1 14             	add    $0x14,%ecx
c0006d70:	52                   	push   %edx
c0006d71:	50                   	push   %eax
c0006d72:	51                   	push   %ecx
c0006d73:	68 1c ea 00 c0       	push   $0xc000ea1c
c0006d78:	e8 d0 02 00 00       	call   c000704d <printk>
c0006d7d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:327

	/* 在此处return false与函数本身功能无关,
	 * 只是为了让主调函数list_traversal继续向下遍历元素 */
	return false;
c0006d80:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/device/ide.c:328
}
c0006d85:	c9                   	leave  
c0006d86:	c3                   	ret    

c0006d87 <intr_hd_handler>:
intr_hd_handler():
/work/x86_os_my/device/ide.c:331

/* 硬盘中断处理程序 */
void intr_hd_handler(uint8_t irq_no) {
c0006d87:	55                   	push   %ebp
c0006d88:	89 e5                	mov    %esp,%ebp
c0006d8a:	83 ec 28             	sub    $0x28,%esp
c0006d8d:	8b 45 08             	mov    0x8(%ebp),%eax
c0006d90:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/device/ide.c:332
	ASSERT(irq_no == 0x2e || irq_no == 0x2f);
c0006d93:	80 7d e4 2e          	cmpb   $0x2e,-0x1c(%ebp)
c0006d97:	74 22                	je     c0006dbb <intr_hd_handler+0x34>
/work/x86_os_my/device/ide.c:332 (discriminator 1)
c0006d99:	80 7d e4 2f          	cmpb   $0x2f,-0x1c(%ebp)
c0006d9d:	74 1c                	je     c0006dbb <intr_hd_handler+0x34>
/work/x86_os_my/device/ide.c:332 (discriminator 2)
c0006d9f:	68 40 ea 00 c0       	push   $0xc000ea40
c0006da4:	68 10 eb 00 c0       	push   $0xc000eb10
c0006da9:	68 4c 01 00 00       	push   $0x14c
c0006dae:	68 3f e9 00 c0       	push   $0xc000e93f
c0006db3:	e8 a9 b7 ff ff       	call   c0002561 <panic_spin>
c0006db8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:333
	uint8_t ch_no = irq_no - 0x2e;
c0006dbb:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0006dbf:	83 e8 2e             	sub    $0x2e,%eax
c0006dc2:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ide.c:334
	struct ide_channel* channel = &channels[ch_no];
c0006dc5:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0006dc9:	69 c0 60 06 00 00    	imul   $0x660,%eax,%eax
c0006dcf:	05 c0 4b 01 c0       	add    $0xc0014bc0,%eax
c0006dd4:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:335
	ASSERT(channel->irq_no == irq_no);
c0006dd7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006dda:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c0006dde:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c0006de1:	74 1c                	je     c0006dff <intr_hd_handler+0x78>
/work/x86_os_my/device/ide.c:335 (discriminator 1)
c0006de3:	68 61 ea 00 c0       	push   $0xc000ea61
c0006de8:	68 10 eb 00 c0       	push   $0xc000eb10
c0006ded:	68 4f 01 00 00       	push   $0x14f
c0006df2:	68 3f e9 00 c0       	push   $0xc000e93f
c0006df7:	e8 65 b7 ff ff       	call   c0002561 <panic_spin>
c0006dfc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:338
	/* 不必担心此中断是否对应的是这一次的expecting_intr,
	* 每次读写硬盘时会申请锁,从而保证了同步一致性 */
	if (channel->expecting_intr) {
c0006dff:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006e02:	8b 40 28             	mov    0x28(%eax),%eax
c0006e05:	85 c0                	test   %eax,%eax
c0006e07:	74 35                	je     c0006e3e <intr_hd_handler+0xb7>
/work/x86_os_my/device/ide.c:339
		channel->expecting_intr = false;
c0006e09:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006e0c:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
/work/x86_os_my/device/ide.c:340
		sema_up(&channel->disk_done);
c0006e13:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006e16:	83 c0 2c             	add    $0x2c,%eax
c0006e19:	83 ec 0c             	sub    $0xc,%esp
c0006e1c:	50                   	push   %eax
c0006e1d:	e8 2e e0 ff ff       	call   c0004e50 <sema_up>
c0006e22:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:343

		/* 读取状态寄存器使硬盘控制器认为此次的中断已被处理,从而硬盘可以继续执行新的读写 */
		inb(reg_status(channel));
c0006e25:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006e28:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0006e2c:	83 c0 07             	add    $0x7,%eax
c0006e2f:	0f b7 c0             	movzwl %ax,%eax
c0006e32:	83 ec 0c             	sub    $0xc,%esp
c0006e35:	50                   	push   %eax
c0006e36:	e8 de f4 ff ff       	call   c0006319 <inb>
c0006e3b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:345
	}
}
c0006e3e:	90                   	nop
c0006e3f:	c9                   	leave  
c0006e40:	c3                   	ret    

c0006e41 <ide_init>:
ide_init():
/work/x86_os_my/device/ide.c:348

/* 硬盘数据结构初始化 */
void ide_init() {
c0006e41:	55                   	push   %ebp
c0006e42:	89 e5                	mov    %esp,%ebp
c0006e44:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ide.c:349
	printk("ide_init start\n");
c0006e47:	83 ec 0c             	sub    $0xc,%esp
c0006e4a:	68 7b ea 00 c0       	push   $0xc000ea7b
c0006e4f:	e8 f9 01 00 00       	call   c000704d <printk>
c0006e54:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:350
	uint8_t hd_cnt = *((uint8_t*)(0x475));	// 获取硬盘的数量
c0006e57:	b8 75 04 00 00       	mov    $0x475,%eax
c0006e5c:	0f b6 00             	movzbl (%eax),%eax
c0006e5f:	88 45 f5             	mov    %al,-0xb(%ebp)
/work/x86_os_my/device/ide.c:351
	ASSERT(hd_cnt > 0);
c0006e62:	80 7d f5 00          	cmpb   $0x0,-0xb(%ebp)
c0006e66:	75 1c                	jne    c0006e84 <ide_init+0x43>
/work/x86_os_my/device/ide.c:351 (discriminator 1)
c0006e68:	68 8b ea 00 c0       	push   $0xc000ea8b
c0006e6d:	68 20 eb 00 c0       	push   $0xc000eb20
c0006e72:	68 5f 01 00 00       	push   $0x15f
c0006e77:	68 3f e9 00 c0       	push   $0xc000e93f
c0006e7c:	e8 e0 b6 ff ff       	call   c0002561 <panic_spin>
c0006e81:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:352
	list_init(&partition_list);
c0006e84:	83 ec 0c             	sub    $0xc,%esp
c0006e87:	68 80 58 01 c0       	push   $0xc0015880
c0006e8c:	e8 a8 db ff ff       	call   c0004a39 <list_init>
c0006e91:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:353
	channel_cnt = DIV_ROUND_UP(hd_cnt, 2);	// 一个ide通道上有两个硬盘,根据硬盘数量反推有几个ide通道
c0006e94:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
c0006e98:	83 c0 01             	add    $0x1,%eax
c0006e9b:	89 c2                	mov    %eax,%edx
c0006e9d:	c1 ea 1f             	shr    $0x1f,%edx
c0006ea0:	01 d0                	add    %edx,%eax
c0006ea2:	d1 f8                	sar    %eax
c0006ea4:	a2 a0 4b 01 c0       	mov    %al,0xc0014ba0
/work/x86_os_my/device/ide.c:355
	struct ide_channel* channel;
	uint8_t channel_no = 0, dev_no = 0;
c0006ea9:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
c0006ead:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
/work/x86_os_my/device/ide.c:358

	/* 处理每个通道上的硬盘 */
	while (channel_no < channel_cnt) {
c0006eb1:	e9 4d 01 00 00       	jmp    c0007003 <ide_init+0x1c2>
/work/x86_os_my/device/ide.c:359
		channel = &channels[channel_no];
c0006eb6:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0006eba:	69 c0 60 06 00 00    	imul   $0x660,%eax,%eax
c0006ec0:	05 c0 4b 01 c0       	add    $0xc0014bc0,%eax
c0006ec5:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:360
		sprintf(channel->name, "ide%d", channel_no);
c0006ec8:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0006ecc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006ecf:	83 ec 04             	sub    $0x4,%esp
c0006ed2:	52                   	push   %edx
c0006ed3:	68 96 ea 00 c0       	push   $0xc000ea96
c0006ed8:	50                   	push   %eax
c0006ed9:	e8 47 f3 ff ff       	call   c0006225 <sprintf>
c0006ede:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:363

		/* 为每个ide通道初始化端口基址及中断向量 */
		switch (channel_no) {
c0006ee1:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0006ee5:	85 c0                	test   %eax,%eax
c0006ee7:	74 07                	je     c0006ef0 <ide_init+0xaf>
c0006ee9:	83 f8 01             	cmp    $0x1,%eax
c0006eec:	74 14                	je     c0006f02 <ide_init+0xc1>
c0006eee:	eb 23                	jmp    c0006f13 <ide_init+0xd2>
/work/x86_os_my/device/ide.c:365
			case 0:
			channel->port_base	 = 0x1f0;	// ide0通道的起始端口号是0x1f0
c0006ef0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006ef3:	66 c7 40 08 f0 01    	movw   $0x1f0,0x8(%eax)
/work/x86_os_my/device/ide.c:366
			channel->irq_no	 = 0x20 + 14;	// 从片8259a上倒数第二的中断引脚,温盘,也就是ide0通道的的中断向量号
c0006ef9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006efc:	c6 40 0a 2e          	movb   $0x2e,0xa(%eax)
/work/x86_os_my/device/ide.c:367
			break;
c0006f00:	eb 11                	jmp    c0006f13 <ide_init+0xd2>
/work/x86_os_my/device/ide.c:370
			
			case 1:
			channel->port_base	 = 0x170;	// ide1通道的起始端口号是0x170
c0006f02:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006f05:	66 c7 40 08 70 01    	movw   $0x170,0x8(%eax)
/work/x86_os_my/device/ide.c:371
			channel->irq_no	 = 0x20 + 15;	// 从8259A上的最后一个中断引脚,我们用来响应ide1通道上的硬盘中断
c0006f0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006f0e:	c6 40 0a 2f          	movb   $0x2f,0xa(%eax)
/work/x86_os_my/device/ide.c:372
			break;
c0006f12:	90                   	nop
/work/x86_os_my/device/ide.c:375
		}

		channel->expecting_intr = false;	// 未向硬盘写入指令时不期待硬盘的中断
c0006f13:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006f16:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
/work/x86_os_my/device/ide.c:376
		lock_init(&channel->lock);
c0006f1d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006f20:	83 c0 0c             	add    $0xc,%eax
c0006f23:	83 ec 0c             	sub    $0xc,%esp
c0006f26:	50                   	push   %eax
c0006f27:	e8 f9 dd ff ff       	call   c0004d25 <lock_init>
c0006f2c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:380

		/* 初始化为0,目的是向硬盘控制器请求数据后,硬盘驱动sema_down此信号量会阻塞线程,
		直到硬盘完成后通过发中断,由中断处理程序将此信号量sema_up,唤醒线程. */
		sema_init(&channel->disk_done, 0);
c0006f2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006f32:	83 c0 2c             	add    $0x2c,%eax
c0006f35:	83 ec 08             	sub    $0x8,%esp
c0006f38:	6a 00                	push   $0x0
c0006f3a:	50                   	push   %eax
c0006f3b:	e8 bb dd ff ff       	call   c0004cfb <sema_init>
c0006f40:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:381
		register_handler(channel->irq_no, intr_hd_handler);
c0006f43:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006f46:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c0006f4a:	0f b6 c0             	movzbl %al,%eax
c0006f4d:	83 ec 08             	sub    $0x8,%esp
c0006f50:	68 87 6d 00 c0       	push   $0xc0006d87
c0006f55:	50                   	push   %eax
c0006f56:	e8 95 ac ff ff       	call   c0001bf0 <register_handler>
c0006f5b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:384

		/* 分别获取两个硬盘的参数及分区信息 */
		while (dev_no < 2) {
c0006f5e:	e9 88 00 00 00       	jmp    c0006feb <ide_init+0x1aa>
/work/x86_os_my/device/ide.c:385
			struct disk* hd = &channel->devices[dev_no];
c0006f63:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0006f67:	69 c0 10 03 00 00    	imul   $0x310,%eax,%eax
c0006f6d:	8d 50 40             	lea    0x40(%eax),%edx
c0006f70:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006f73:	01 d0                	add    %edx,%eax
c0006f75:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/device/ide.c:386
			hd->my_channel = channel;
c0006f78:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0006f7b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0006f7e:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/device/ide.c:387
			hd->dev_no = dev_no;
c0006f81:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0006f84:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
c0006f88:	88 50 0c             	mov    %dl,0xc(%eax)
/work/x86_os_my/device/ide.c:388
			sprintf(hd->name, "sd%c", 'a' + channel_no * 2 + dev_no);
c0006f8b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0006f8f:	01 c0                	add    %eax,%eax
c0006f91:	8d 50 61             	lea    0x61(%eax),%edx
c0006f94:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0006f98:	01 c2                	add    %eax,%edx
c0006f9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0006f9d:	83 ec 04             	sub    $0x4,%esp
c0006fa0:	52                   	push   %edx
c0006fa1:	68 9c ea 00 c0       	push   $0xc000ea9c
c0006fa6:	50                   	push   %eax
c0006fa7:	e8 79 f2 ff ff       	call   c0006225 <sprintf>
c0006fac:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:389
			identify_disk(hd);		// 获取硬盘参数
c0006faf:	83 ec 0c             	sub    $0xc,%esp
c0006fb2:	ff 75 ec             	pushl  -0x14(%ebp)
c0006fb5:	e8 5d f9 ff ff       	call   c0006917 <identify_disk>
c0006fba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:390
			if (dev_no != 0) {		// 内核本身的裸硬盘(hd60M.img)不处理
c0006fbd:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c0006fc1:	74 10                	je     c0006fd3 <ide_init+0x192>
/work/x86_os_my/device/ide.c:391
				partition_scan(hd, 0);	// 扫描该硬盘上的分区
c0006fc3:	83 ec 08             	sub    $0x8,%esp
c0006fc6:	6a 00                	push   $0x0
c0006fc8:	ff 75 ec             	pushl  -0x14(%ebp)
c0006fcb:	e8 c4 fa ff ff       	call   c0006a94 <partition_scan>
c0006fd0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:393
			}
			p_no = 0, l_no = 0;
c0006fd3:	c6 05 b0 36 01 c0 00 	movb   $0x0,0xc00136b0
c0006fda:	c6 05 b1 36 01 c0 00 	movb   $0x0,0xc00136b1
/work/x86_os_my/device/ide.c:394
			dev_no++;
c0006fe1:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0006fe5:	83 c0 01             	add    $0x1,%eax
c0006fe8:	88 45 f6             	mov    %al,-0xa(%ebp)
/work/x86_os_my/device/ide.c:384
		直到硬盘完成后通过发中断,由中断处理程序将此信号量sema_up,唤醒线程. */
		sema_init(&channel->disk_done, 0);
		register_handler(channel->irq_no, intr_hd_handler);

		/* 分别获取两个硬盘的参数及分区信息 */
		while (dev_no < 2) {
c0006feb:	80 7d f6 01          	cmpb   $0x1,-0xa(%ebp)
c0006fef:	0f 86 6e ff ff ff    	jbe    c0006f63 <ide_init+0x122>
/work/x86_os_my/device/ide.c:396
				partition_scan(hd, 0);	// 扫描该硬盘上的分区
			}
			p_no = 0, l_no = 0;
			dev_no++;
		}
		dev_no = 0;		// 将硬盘驱动器号置0,为下一个channel的两个硬盘初始化。
c0006ff5:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
/work/x86_os_my/device/ide.c:397
		channel_no++;	// 下一个channel
c0006ff9:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0006ffd:	83 c0 01             	add    $0x1,%eax
c0007000:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ide.c:358
	channel_cnt = DIV_ROUND_UP(hd_cnt, 2);	// 一个ide通道上有两个硬盘,根据硬盘数量反推有几个ide通道
	struct ide_channel* channel;
	uint8_t channel_no = 0, dev_no = 0;

	/* 处理每个通道上的硬盘 */
	while (channel_no < channel_cnt) {
c0007003:	0f b6 05 a0 4b 01 c0 	movzbl 0xc0014ba0,%eax
c000700a:	38 45 f7             	cmp    %al,-0x9(%ebp)
c000700d:	0f 82 a3 fe ff ff    	jb     c0006eb6 <ide_init+0x75>
/work/x86_os_my/device/ide.c:400
		}
		dev_no = 0;		// 将硬盘驱动器号置0,为下一个channel的两个硬盘初始化。
		channel_no++;	// 下一个channel
	}

	printk("\n   all partition info\n");
c0007013:	83 ec 0c             	sub    $0xc,%esp
c0007016:	68 a1 ea 00 c0       	push   $0xc000eaa1
c000701b:	e8 2d 00 00 00       	call   c000704d <printk>
c0007020:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:402
	/* 打印所有分区信息 */
	list_traversal(&partition_list, partition_info, (int)NULL);
c0007023:	83 ec 04             	sub    $0x4,%esp
c0007026:	6a 00                	push   $0x0
c0007028:	68 50 6d 00 c0       	push   $0xc0006d50
c000702d:	68 80 58 01 c0       	push   $0xc0015880
c0007032:	e8 48 db ff ff       	call   c0004b7f <list_traversal>
c0007037:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:403
	printk("ide_init done\n");
c000703a:	83 ec 0c             	sub    $0xc,%esp
c000703d:	68 b9 ea 00 c0       	push   $0xc000eab9
c0007042:	e8 06 00 00 00       	call   c000704d <printk>
c0007047:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:404
}
c000704a:	90                   	nop
c000704b:	c9                   	leave  
c000704c:	c3                   	ret    

c000704d <printk>:
printk():
/work/x86_os_my/lib/kernel/stdio-kernel.c:11

#define va_start(args, first_fix) args = (va_list)&first_fix
#define va_end(args) args = NULL

/* 供内核使用的格式化输出函数 */
void printk(const char* format, ...) {
c000704d:	55                   	push   %ebp
c000704e:	89 e5                	mov    %esp,%ebp
c0007050:	57                   	push   %edi
c0007051:	81 ec 14 04 00 00    	sub    $0x414,%esp
/work/x86_os_my/lib/kernel/stdio-kernel.c:13
	va_list args;
	va_start(args, format);
c0007057:	8d 45 08             	lea    0x8(%ebp),%eax
c000705a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/stdio-kernel.c:14
	char buf[1024] = {0};
c000705d:	8d 95 f4 fb ff ff    	lea    -0x40c(%ebp),%edx
c0007063:	b8 00 00 00 00       	mov    $0x0,%eax
c0007068:	b9 00 01 00 00       	mov    $0x100,%ecx
c000706d:	89 d7                	mov    %edx,%edi
c000706f:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/lib/kernel/stdio-kernel.c:15
	vsprintf(buf, format, args);
c0007071:	8b 45 08             	mov    0x8(%ebp),%eax
c0007074:	83 ec 04             	sub    $0x4,%esp
c0007077:	ff 75 f4             	pushl  -0xc(%ebp)
c000707a:	50                   	push   %eax
c000707b:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c0007081:	50                   	push   %eax
c0007082:	e8 21 f0 ff ff       	call   c00060a8 <vsprintf>
c0007087:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/stdio-kernel.c:16
	va_end(args);
c000708a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/kernel/stdio-kernel.c:17
	console_put_str(buf);
c0007091:	83 ec 0c             	sub    $0xc,%esp
c0007094:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c000709a:	50                   	push   %eax
c000709b:	e8 f0 db ff ff       	call   c0004c90 <console_put_str>
c00070a0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/stdio-kernel.c:18
}
c00070a3:	90                   	nop
c00070a4:	8b 7d fc             	mov    -0x4(%ebp),%edi
c00070a7:	c9                   	leave  
c00070a8:	c3                   	ret    

c00070a9 <mount_partition>:
mount_partition():
/work/x86_os_my/fs/fs.c:28
把该分区文件系统的元信息从硬盘上读出来加载到内存中，
这样硬盘资源的变化都用内存中元信息来跟踪，
如果有写操作，及时将内存中的元信息同步写入到硬盘以持久化。
*/
//sb_buf没释放！
static bool mount_partition(struct list_elem* pelem, int arg) {
c00070a9:	55                   	push   %ebp
c00070aa:	89 e5                	mov    %esp,%ebp
c00070ac:	53                   	push   %ebx
c00070ad:	83 ec 14             	sub    $0x14,%esp
/work/x86_os_my/fs/fs.c:29
	char* part_name = (char*)arg;	// sdb1
c00070b0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00070b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:30
	struct partition* part = elem2entry(struct partition, part_tag, pelem);	// 根据pelem找到partition
c00070b6:	8b 45 08             	mov    0x8(%ebp),%eax
c00070b9:	83 e8 0c             	sub    $0xc,%eax
c00070bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:31
	if (!strcmp(part->name, part_name)) {	//名字一致
c00070bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00070c2:	83 c0 14             	add    $0x14,%eax
c00070c5:	83 ec 08             	sub    $0x8,%esp
c00070c8:	ff 75 f4             	pushl  -0xc(%ebp)
c00070cb:	50                   	push   %eax
c00070cc:	e8 69 cb ff ff       	call   c0003c3a <strcmp>
c00070d1:	83 c4 10             	add    $0x10,%esp
c00070d4:	84 c0                	test   %al,%al
c00070d6:	0f 85 ce 01 00 00    	jne    c00072aa <mount_partition+0x201>
/work/x86_os_my/fs/fs.c:32
		cur_part = part;
c00070dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00070df:	a3 90 58 01 c0       	mov    %eax,0xc0015890
/work/x86_os_my/fs/fs.c:33
		struct disk* hd = cur_part->my_disk;
c00070e4:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c00070e9:	8b 40 08             	mov    0x8(%eax),%eax
c00070ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:34
		struct super_block* sb_buf = (struct super_block*)sys_malloc(SECTOR_SIZE);
c00070ef:	83 ec 0c             	sub    $0xc,%esp
c00070f2:	68 00 02 00 00       	push   $0x200
c00070f7:	e8 10 be ff ff       	call   c0002f0c <sys_malloc>
c00070fc:	83 c4 10             	add    $0x10,%esp
c00070ff:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:38

		/* 在内存中创建分区cur_part的超级块 */
		// super_block 占用了1个扇区，但是它后边有很多数据是pad只做填充用
		cur_part->sb = (struct super_block*)sys_malloc(sizeof(struct super_block));
c0007102:	8b 1d 90 58 01 c0    	mov    0xc0015890,%ebx
c0007108:	83 ec 0c             	sub    $0xc,%esp
c000710b:	68 00 02 00 00       	push   $0x200
c0007110:	e8 f7 bd ff ff       	call   c0002f0c <sys_malloc>
c0007115:	83 c4 10             	add    $0x10,%esp
c0007118:	89 43 1c             	mov    %eax,0x1c(%ebx)
/work/x86_os_my/fs/fs.c:39
		if (cur_part->sb == NULL) {
c000711b:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0007120:	8b 40 1c             	mov    0x1c(%eax),%eax
c0007123:	85 c0                	test   %eax,%eax
c0007125:	75 19                	jne    c0007140 <mount_partition+0x97>
/work/x86_os_my/fs/fs.c:40
			PANIC("alloc memory failed!");
c0007127:	68 2c eb 00 c0       	push   $0xc000eb2c
c000712c:	68 54 f4 00 c0       	push   $0xc000f454
c0007131:	6a 28                	push   $0x28
c0007133:	68 41 eb 00 c0       	push   $0xc000eb41
c0007138:	e8 24 b4 ff ff       	call   c0002561 <panic_spin>
c000713d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:44
		}

		/* 读入超级块 */
		memset(sb_buf, 0, SECTOR_SIZE);
c0007140:	83 ec 04             	sub    $0x4,%esp
c0007143:	68 00 02 00 00       	push   $0x200
c0007148:	6a 00                	push   $0x0
c000714a:	ff 75 e8             	pushl  -0x18(%ebp)
c000714d:	e8 13 c9 ff ff       	call   c0003a65 <memset>
c0007152:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:45
		ide_read(hd, cur_part->start_lba + 1, sb_buf, 1);
c0007155:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000715a:	8b 00                	mov    (%eax),%eax
c000715c:	83 c0 01             	add    $0x1,%eax
c000715f:	6a 01                	push   $0x1
c0007161:	ff 75 e8             	pushl  -0x18(%ebp)
c0007164:	50                   	push   %eax
c0007165:	ff 75 ec             	pushl  -0x14(%ebp)
c0007168:	e8 67 f4 ff ff       	call   c00065d4 <ide_read>
c000716d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:47
		// 拷贝给 cur_part->sb
		memcpy(cur_part->sb, sb_buf, sizeof(struct super_block));
c0007170:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0007175:	8b 40 1c             	mov    0x1c(%eax),%eax
c0007178:	83 ec 04             	sub    $0x4,%esp
c000717b:	68 00 02 00 00       	push   $0x200
c0007180:	ff 75 e8             	pushl  -0x18(%ebp)
c0007183:	50                   	push   %eax
c0007184:	e8 2e c9 ff ff       	call   c0003ab7 <memcpy>
c0007189:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:50

		/* 读入块位图 */
		cur_part->block_bitmap.bits = (uint8_t*)sys_malloc(sb_buf->block_bitmap_sects * SECTOR_SIZE);
c000718c:	8b 1d 90 58 01 c0    	mov    0xc0015890,%ebx
c0007192:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0007195:	8b 40 14             	mov    0x14(%eax),%eax
c0007198:	c1 e0 09             	shl    $0x9,%eax
c000719b:	83 ec 0c             	sub    $0xc,%esp
c000719e:	50                   	push   %eax
c000719f:	e8 68 bd ff ff       	call   c0002f0c <sys_malloc>
c00071a4:	83 c4 10             	add    $0x10,%esp
c00071a7:	89 43 24             	mov    %eax,0x24(%ebx)
/work/x86_os_my/fs/fs.c:51
		if (cur_part->block_bitmap.bits == NULL) {
c00071aa:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c00071af:	8b 40 24             	mov    0x24(%eax),%eax
c00071b2:	85 c0                	test   %eax,%eax
c00071b4:	75 19                	jne    c00071cf <mount_partition+0x126>
/work/x86_os_my/fs/fs.c:52
			PANIC("alloc memory failed!");
c00071b6:	68 2c eb 00 c0       	push   $0xc000eb2c
c00071bb:	68 54 f4 00 c0       	push   $0xc000f454
c00071c0:	6a 34                	push   $0x34
c00071c2:	68 41 eb 00 c0       	push   $0xc000eb41
c00071c7:	e8 95 b3 ff ff       	call   c0002561 <panic_spin>
c00071cc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:54
		}
		cur_part->block_bitmap.btmp_bytes_len = sb_buf->block_bitmap_sects * SECTOR_SIZE;
c00071cf:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c00071d4:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00071d7:	8b 52 14             	mov    0x14(%edx),%edx
c00071da:	c1 e2 09             	shl    $0x9,%edx
c00071dd:	89 50 20             	mov    %edx,0x20(%eax)
/work/x86_os_my/fs/fs.c:55
		ide_read(hd, sb_buf->block_bitmap_lba, cur_part->block_bitmap.bits, sb_buf->block_bitmap_sects);
c00071e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00071e3:	8b 48 14             	mov    0x14(%eax),%ecx
c00071e6:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c00071eb:	8b 50 24             	mov    0x24(%eax),%edx
c00071ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00071f1:	8b 40 10             	mov    0x10(%eax),%eax
c00071f4:	51                   	push   %ecx
c00071f5:	52                   	push   %edx
c00071f6:	50                   	push   %eax
c00071f7:	ff 75 ec             	pushl  -0x14(%ebp)
c00071fa:	e8 d5 f3 ff ff       	call   c00065d4 <ide_read>
c00071ff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:58

		/* 读入inode位图 */
		cur_part->inode_bitmap.bits = (uint8_t*)sys_malloc(sb_buf->inode_bitmap_sects * SECTOR_SIZE);
c0007202:	8b 1d 90 58 01 c0    	mov    0xc0015890,%ebx
c0007208:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000720b:	8b 40 1c             	mov    0x1c(%eax),%eax
c000720e:	c1 e0 09             	shl    $0x9,%eax
c0007211:	83 ec 0c             	sub    $0xc,%esp
c0007214:	50                   	push   %eax
c0007215:	e8 f2 bc ff ff       	call   c0002f0c <sys_malloc>
c000721a:	83 c4 10             	add    $0x10,%esp
c000721d:	89 43 2c             	mov    %eax,0x2c(%ebx)
/work/x86_os_my/fs/fs.c:59
		if (cur_part->inode_bitmap.bits == NULL) {
c0007220:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0007225:	8b 40 2c             	mov    0x2c(%eax),%eax
c0007228:	85 c0                	test   %eax,%eax
c000722a:	75 19                	jne    c0007245 <mount_partition+0x19c>
/work/x86_os_my/fs/fs.c:60
			PANIC("alloc memory failed!");
c000722c:	68 2c eb 00 c0       	push   $0xc000eb2c
c0007231:	68 54 f4 00 c0       	push   $0xc000f454
c0007236:	6a 3c                	push   $0x3c
c0007238:	68 41 eb 00 c0       	push   $0xc000eb41
c000723d:	e8 1f b3 ff ff       	call   c0002561 <panic_spin>
c0007242:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:62
		}
		cur_part->inode_bitmap.btmp_bytes_len = sb_buf->inode_bitmap_sects * SECTOR_SIZE;
c0007245:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000724a:	8b 55 e8             	mov    -0x18(%ebp),%edx
c000724d:	8b 52 1c             	mov    0x1c(%edx),%edx
c0007250:	c1 e2 09             	shl    $0x9,%edx
c0007253:	89 50 28             	mov    %edx,0x28(%eax)
/work/x86_os_my/fs/fs.c:63
		ide_read(hd, sb_buf->inode_bitmap_lba, cur_part->inode_bitmap.bits, sb_buf->inode_bitmap_sects);
c0007256:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0007259:	8b 48 1c             	mov    0x1c(%eax),%ecx
c000725c:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0007261:	8b 50 2c             	mov    0x2c(%eax),%edx
c0007264:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0007267:	8b 40 18             	mov    0x18(%eax),%eax
c000726a:	51                   	push   %ecx
c000726b:	52                   	push   %edx
c000726c:	50                   	push   %eax
c000726d:	ff 75 ec             	pushl  -0x14(%ebp)
c0007270:	e8 5f f3 ff ff       	call   c00065d4 <ide_read>
c0007275:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:66


		list_init(&cur_part->open_inodes);	// 本分区打开的inode队列！
c0007278:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000727d:	83 c0 30             	add    $0x30,%eax
c0007280:	83 ec 0c             	sub    $0xc,%esp
c0007283:	50                   	push   %eax
c0007284:	e8 b0 d7 ff ff       	call   c0004a39 <list_init>
c0007289:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:69


		printk("mount %s done!\n", part->name);
c000728c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000728f:	83 c0 14             	add    $0x14,%eax
c0007292:	83 ec 08             	sub    $0x8,%esp
c0007295:	50                   	push   %eax
c0007296:	68 49 eb 00 c0       	push   $0xc000eb49
c000729b:	e8 ad fd ff ff       	call   c000704d <printk>
c00072a0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:71
		/* 返回true时list_traversal才会停止遍历,减少了后面元素无意义的遍历. */
		return true;
c00072a3:	b8 01 00 00 00       	mov    $0x1,%eax
c00072a8:	eb 05                	jmp    c00072af <mount_partition+0x206>
/work/x86_os_my/fs/fs.c:73
	}//if (!strcmp(part->name, part_name))
	return false;	// list_traversal继续遍历
c00072aa:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/fs.c:74
}
c00072af:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00072b2:	c9                   	leave  
c00072b3:	c3                   	ret    

c00072b4 <partition_format>:
partition_format():
/work/x86_os_my/fs/fs.c:90
	| 操作系统引导块，超级块，空闲块位图，inode位图，inode数组，根目录，空闲块区域 |
	+------------------------------------------------------------------------------+
	partition结构见ide.h
	MAX_FILES_PER_PART == 4096
****************************************************************************************/
static void partition_format(struct partition* part) {
c00072b4:	55                   	push   %ebp
c00072b5:	89 e5                	mov    %esp,%ebp
c00072b7:	57                   	push   %edi
c00072b8:	56                   	push   %esi
c00072b9:	53                   	push   %ebx
c00072ba:	81 ec 7c 02 00 00    	sub    $0x27c,%esp
/work/x86_os_my/fs/fs.c:92
	/* 为方便实现，inode管理的数据块，一个块大小是一扇区 */
	uint32_t boot_sector_sects = 1;		//引导块
c00072c0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
/work/x86_os_my/fs/fs.c:93
	uint32_t super_block_sects = 1;		//超级块
c00072c7:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
/work/x86_os_my/fs/fs.c:94
	uint32_t inode_bitmap_sects = DIV_ROUND_UP(MAX_FILES_PER_PART, BITS_PER_SECTOR);	// inode位图占几个扇区.最多支持4096个文件
c00072ce:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
/work/x86_os_my/fs/fs.c:95
	uint32_t inode_table_sects = DIV_ROUND_UP((sizeof(struct inode) * MAX_FILES_PER_PART), SECTOR_SIZE);	//inode数组占几个扇区
c00072d5:	c7 45 d4 60 02 00 00 	movl   $0x260,-0x2c(%ebp)
/work/x86_os_my/fs/fs.c:96
	uint32_t used_sects = boot_sector_sects + super_block_sects + inode_bitmap_sects + inode_table_sects;
c00072dc:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00072df:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00072e2:	01 c2                	add    %eax,%edx
c00072e4:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00072e7:	01 c2                	add    %eax,%edx
c00072e9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00072ec:	01 d0                	add    %edx,%eax
c00072ee:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/fs/fs.c:97
	uint32_t free_sects = part->sec_cnt - used_sects;  
c00072f1:	8b 45 08             	mov    0x8(%ebp),%eax
c00072f4:	8b 40 04             	mov    0x4(%eax),%eax
c00072f7:	2b 45 d0             	sub    -0x30(%ebp),%eax
c00072fa:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/fs/fs.c:101

	/************** 简单处理块位图占据的扇区数 ***************/
	uint32_t block_bitmap_sects;	//空闲块位图占几个扇区
	block_bitmap_sects = DIV_ROUND_UP(free_sects, BITS_PER_SECTOR);		//free_sects空闲块位图要占几个扇区
c00072fd:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0007300:	05 ff 0f 00 00       	add    $0xfff,%eax
c0007305:	c1 e8 0c             	shr    $0xc,%eax
c0007308:	89 45 c8             	mov    %eax,-0x38(%ebp)
/work/x86_os_my/fs/fs.c:103
	/* 再算一次空闲块数量 */
	uint32_t block_bitmap_bit_len = free_sects - block_bitmap_sects;	//block_bitmap_bit_len 是位图长度，也是空闲块数量
c000730b:	8b 45 cc             	mov    -0x34(%ebp),%eax
c000730e:	2b 45 c8             	sub    -0x38(%ebp),%eax
c0007311:	89 45 c4             	mov    %eax,-0x3c(%ebp)
/work/x86_os_my/fs/fs.c:104
	block_bitmap_sects = DIV_ROUND_UP(block_bitmap_bit_len, BITS_PER_SECTOR); 
c0007314:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c0007317:	05 ff 0f 00 00       	add    $0xfff,%eax
c000731c:	c1 e8 0c             	shr    $0xc,%eax
c000731f:	89 45 c8             	mov    %eax,-0x38(%ebp)
/work/x86_os_my/fs/fs.c:109
	/*********************************************************/

	/* 超级块初始化 */
	struct super_block sb;		//局部变量在栈中512字节
	sb.magic = 0x19590318;
c0007322:	c7 85 a4 fd ff ff 18 	movl   $0x19590318,-0x25c(%ebp)
c0007329:	03 59 19 
/work/x86_os_my/fs/fs.c:110
	sb.sec_cnt = part->sec_cnt;
c000732c:	8b 45 08             	mov    0x8(%ebp),%eax
c000732f:	8b 40 04             	mov    0x4(%eax),%eax
c0007332:	89 85 a8 fd ff ff    	mov    %eax,-0x258(%ebp)
/work/x86_os_my/fs/fs.c:111
	sb.inode_cnt = MAX_FILES_PER_PART;
c0007338:	c7 85 ac fd ff ff 00 	movl   $0x1000,-0x254(%ebp)
c000733f:	10 00 00 
/work/x86_os_my/fs/fs.c:112
	sb.part_lba_base = part->start_lba;
c0007342:	8b 45 08             	mov    0x8(%ebp),%eax
c0007345:	8b 00                	mov    (%eax),%eax
c0007347:	89 85 b0 fd ff ff    	mov    %eax,-0x250(%ebp)
/work/x86_os_my/fs/fs.c:114

	sb.block_bitmap_lba = sb.part_lba_base + 2;	// 第0块是引导块,第1块是超级块
c000734d:	8b 85 b0 fd ff ff    	mov    -0x250(%ebp),%eax
c0007353:	83 c0 02             	add    $0x2,%eax
c0007356:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
/work/x86_os_my/fs/fs.c:115
	sb.block_bitmap_sects = block_bitmap_sects;	// 空闲块位图占几个扇区
c000735c:	8b 45 c8             	mov    -0x38(%ebp),%eax
c000735f:	89 85 b8 fd ff ff    	mov    %eax,-0x248(%ebp)
/work/x86_os_my/fs/fs.c:117

	sb.inode_bitmap_lba = sb.block_bitmap_lba + sb.block_bitmap_sects;
c0007365:	8b 95 b4 fd ff ff    	mov    -0x24c(%ebp),%edx
c000736b:	8b 85 b8 fd ff ff    	mov    -0x248(%ebp),%eax
c0007371:	01 d0                	add    %edx,%eax
c0007373:	89 85 bc fd ff ff    	mov    %eax,-0x244(%ebp)
/work/x86_os_my/fs/fs.c:118
	sb.inode_bitmap_sects = inode_bitmap_sects;	// inode位图占几个扇区
c0007379:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000737c:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
/work/x86_os_my/fs/fs.c:120

	sb.inode_table_lba = sb.inode_bitmap_lba + sb.inode_bitmap_sects;
c0007382:	8b 95 bc fd ff ff    	mov    -0x244(%ebp),%edx
c0007388:	8b 85 c0 fd ff ff    	mov    -0x240(%ebp),%eax
c000738e:	01 d0                	add    %edx,%eax
c0007390:	89 85 c4 fd ff ff    	mov    %eax,-0x23c(%ebp)
/work/x86_os_my/fs/fs.c:121
	sb.inode_table_sects = inode_table_sects;	// inode数组占几个扇区
c0007396:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0007399:	89 85 c8 fd ff ff    	mov    %eax,-0x238(%ebp)
/work/x86_os_my/fs/fs.c:123

	sb.data_start_lba = sb.inode_table_lba + sb.inode_table_sects;	// 数据区开始的第一个扇区号
c000739f:	8b 95 c4 fd ff ff    	mov    -0x23c(%ebp),%edx
c00073a5:	8b 85 c8 fd ff ff    	mov    -0x238(%ebp),%eax
c00073ab:	01 d0                	add    %edx,%eax
c00073ad:	89 85 cc fd ff ff    	mov    %eax,-0x234(%ebp)
/work/x86_os_my/fs/fs.c:125

	sb.root_inode_no = 0;	//根目录的inode号是0
c00073b3:	c7 85 d0 fd ff ff 00 	movl   $0x0,-0x230(%ebp)
c00073ba:	00 00 00 
/work/x86_os_my/fs/fs.c:126
	sb.dir_entry_size = sizeof(struct dir_entry);
c00073bd:	c7 85 d4 fd ff ff 18 	movl   $0x18,-0x22c(%ebp)
c00073c4:	00 00 00 
/work/x86_os_my/fs/fs.c:128

	printk("%s info:\n", part->name);
c00073c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00073ca:	83 c0 14             	add    $0x14,%eax
c00073cd:	83 ec 08             	sub    $0x8,%esp
c00073d0:	50                   	push   %eax
c00073d1:	68 59 eb 00 c0       	push   $0xc000eb59
c00073d6:	e8 72 fc ff ff       	call   c000704d <printk>
c00073db:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:129
	printk("   magic:0x%x\n   part_lba_base:0x%x\n   all_sectors:0x%x\n   inode_cnt:0x%x\n   block_bitmap_lba:0x%x\n   block_bitmap_sectors:0x%x\n   inode_bitmap_lba:0x%x\n   inode_bitmap_sectors:0x%x\n   inode_table_lba:0x%x\n   inode_table_sectors:0x%x\n   data_start_lba:0x%x\n", sb.magic, sb.part_lba_base, sb.sec_cnt, sb.inode_cnt, sb.block_bitmap_lba, sb.block_bitmap_sects, sb.inode_bitmap_lba, sb.inode_bitmap_sects, sb.inode_table_lba, sb.inode_table_sects, sb.data_start_lba);
c00073de:	8b 95 cc fd ff ff    	mov    -0x234(%ebp),%edx
c00073e4:	8b 9d c8 fd ff ff    	mov    -0x238(%ebp),%ebx
c00073ea:	8b bd c4 fd ff ff    	mov    -0x23c(%ebp),%edi
c00073f0:	8b 85 c0 fd ff ff    	mov    -0x240(%ebp),%eax
c00073f6:	89 85 94 fd ff ff    	mov    %eax,-0x26c(%ebp)
c00073fc:	8b b5 bc fd ff ff    	mov    -0x244(%ebp),%esi
c0007402:	89 b5 90 fd ff ff    	mov    %esi,-0x270(%ebp)
c0007408:	8b 8d b8 fd ff ff    	mov    -0x248(%ebp),%ecx
c000740e:	89 8d 8c fd ff ff    	mov    %ecx,-0x274(%ebp)
c0007414:	8b 85 b4 fd ff ff    	mov    -0x24c(%ebp),%eax
c000741a:	89 85 88 fd ff ff    	mov    %eax,-0x278(%ebp)
c0007420:	8b b5 ac fd ff ff    	mov    -0x254(%ebp),%esi
c0007426:	89 b5 84 fd ff ff    	mov    %esi,-0x27c(%ebp)
c000742c:	8b b5 a8 fd ff ff    	mov    -0x258(%ebp),%esi
c0007432:	8b 8d b0 fd ff ff    	mov    -0x250(%ebp),%ecx
c0007438:	8b 85 a4 fd ff ff    	mov    -0x25c(%ebp),%eax
c000743e:	52                   	push   %edx
c000743f:	53                   	push   %ebx
c0007440:	57                   	push   %edi
c0007441:	ff b5 94 fd ff ff    	pushl  -0x26c(%ebp)
c0007447:	ff b5 90 fd ff ff    	pushl  -0x270(%ebp)
c000744d:	ff b5 8c fd ff ff    	pushl  -0x274(%ebp)
c0007453:	ff b5 88 fd ff ff    	pushl  -0x278(%ebp)
c0007459:	ff b5 84 fd ff ff    	pushl  -0x27c(%ebp)
c000745f:	56                   	push   %esi
c0007460:	51                   	push   %ecx
c0007461:	50                   	push   %eax
c0007462:	68 64 eb 00 c0       	push   $0xc000eb64
c0007467:	e8 e1 fb ff ff       	call   c000704d <printk>
c000746c:	83 c4 30             	add    $0x30,%esp
/work/x86_os_my/fs/fs.c:133


	/***** 1 将超级块写入本分区的1号扇区 *****/
	struct disk* hd = part->my_disk;	// 分区所属的硬盘
c000746f:	8b 45 08             	mov    0x8(%ebp),%eax
c0007472:	8b 40 08             	mov    0x8(%eax),%eax
c0007475:	89 45 c0             	mov    %eax,-0x40(%ebp)
/work/x86_os_my/fs/fs.c:135
	// void ide_write(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt);
	ide_write(hd, part->start_lba + 1, &sb, 1);
c0007478:	8b 45 08             	mov    0x8(%ebp),%eax
c000747b:	8b 00                	mov    (%eax),%eax
c000747d:	8d 50 01             	lea    0x1(%eax),%edx
c0007480:	6a 01                	push   $0x1
c0007482:	8d 85 a4 fd ff ff    	lea    -0x25c(%ebp),%eax
c0007488:	50                   	push   %eax
c0007489:	52                   	push   %edx
c000748a:	ff 75 c0             	pushl  -0x40(%ebp)
c000748d:	e8 b6 f2 ff ff       	call   c0006748 <ide_write>
c0007492:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:136
	printk("   super_block_lba:0x%x\n", part->start_lba + 1);
c0007495:	8b 45 08             	mov    0x8(%ebp),%eax
c0007498:	8b 00                	mov    (%eax),%eax
c000749a:	83 c0 01             	add    $0x1,%eax
c000749d:	83 ec 08             	sub    $0x8,%esp
c00074a0:	50                   	push   %eax
c00074a1:	68 66 ec 00 c0       	push   $0xc000ec66
c00074a6:	e8 a2 fb ff ff       	call   c000704d <printk>
c00074ab:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:140


	/* 他们三个写到硬盘上：block_bitmap_sects/inode_bitmap_sects/inode_table_sects 缓冲区选三者最大的 */
	uint32_t buf_size = (sb.block_bitmap_sects >= sb.inode_bitmap_sects ? sb.block_bitmap_sects : sb.inode_bitmap_sects);
c00074ae:	8b 95 b8 fd ff ff    	mov    -0x248(%ebp),%edx
c00074b4:	8b 85 c0 fd ff ff    	mov    -0x240(%ebp),%eax
c00074ba:	39 c2                	cmp    %eax,%edx
c00074bc:	0f 43 c2             	cmovae %edx,%eax
c00074bf:	89 45 bc             	mov    %eax,-0x44(%ebp)
/work/x86_os_my/fs/fs.c:141
	buf_size = (buf_size >= sb.inode_table_sects ? buf_size : sb.inode_table_sects) * SECTOR_SIZE;
c00074c2:	8b 95 c8 fd ff ff    	mov    -0x238(%ebp),%edx
c00074c8:	8b 45 bc             	mov    -0x44(%ebp),%eax
c00074cb:	39 c2                	cmp    %eax,%edx
c00074cd:	0f 43 c2             	cmovae %edx,%eax
c00074d0:	c1 e0 09             	shl    $0x9,%eax
c00074d3:	89 45 bc             	mov    %eax,-0x44(%ebp)
/work/x86_os_my/fs/fs.c:142
	uint8_t* buf = (uint8_t*)sys_malloc(buf_size);	// 申请的内存由内存管理系统清0后返回
c00074d6:	83 ec 0c             	sub    $0xc,%esp
c00074d9:	ff 75 bc             	pushl  -0x44(%ebp)
c00074dc:	e8 2b ba ff ff       	call   c0002f0c <sys_malloc>
c00074e1:	83 c4 10             	add    $0x10,%esp
c00074e4:	89 45 b8             	mov    %eax,-0x48(%ebp)
/work/x86_os_my/fs/fs.c:147


	/***** 2 将块位图初始化并写入sb.block_bitmap_lba *****/
	/* 初始化块位图 block_bitmap */
	buf[0] |= 0x01;	// 第0个块预留给根目录,位图中先占位
c00074e7:	8b 45 b8             	mov    -0x48(%ebp),%eax
c00074ea:	0f b6 00             	movzbl (%eax),%eax
c00074ed:	83 c8 01             	or     $0x1,%eax
c00074f0:	89 c2                	mov    %eax,%edx
c00074f2:	8b 45 b8             	mov    -0x48(%ebp),%eax
c00074f5:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/fs/fs.c:148
	uint32_t block_bitmap_last_byte = block_bitmap_bit_len / 8;		//block_bitmap_bit_len 是位图长度，也是空闲块数量
c00074f7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c00074fa:	c1 e8 03             	shr    $0x3,%eax
c00074fd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
/work/x86_os_my/fs/fs.c:149
	uint8_t  block_bitmap_last_bit  = block_bitmap_bit_len % 8;
c0007500:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c0007503:	83 e0 07             	and    $0x7,%eax
c0007506:	88 45 b3             	mov    %al,-0x4d(%ebp)
/work/x86_os_my/fs/fs.c:150
	uint32_t last_size = SECTOR_SIZE - (block_bitmap_last_byte % SECTOR_SIZE);	// last_size是位图占用的最后一个扇区中，不足一扇区的空闲部分
c0007509:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c000750c:	25 ff 01 00 00       	and    $0x1ff,%eax
c0007511:	ba 00 02 00 00       	mov    $0x200,%edx
c0007516:	29 c2                	sub    %eax,%edx
c0007518:	89 d0                	mov    %edx,%eax
c000751a:	89 45 ac             	mov    %eax,-0x54(%ebp)
/work/x86_os_my/fs/fs.c:153

	// 1 空闲块位图最后一字节，到最后一字节所在扇区的末尾，全置为占用（空闲块位图所在扇区的空闲部分）
	memset(&buf[block_bitmap_last_byte], 0xff, last_size);
c000751d:	8b 55 b8             	mov    -0x48(%ebp),%edx
c0007520:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0007523:	01 d0                	add    %edx,%eax
c0007525:	83 ec 04             	sub    $0x4,%esp
c0007528:	ff 75 ac             	pushl  -0x54(%ebp)
c000752b:	68 ff 00 00 00       	push   $0xff
c0007530:	50                   	push   %eax
c0007531:	e8 2f c5 ff ff       	call   c0003a65 <memset>
c0007536:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:156

	// 2 上一步中最后一字节内，有效的位重新置0
	uint8_t bit_idx = 0;
c0007539:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
/work/x86_os_my/fs/fs.c:157
	while (bit_idx <= block_bitmap_last_bit) {
c000753d:	eb 37                	jmp    c0007576 <partition_format+0x2c2>
/work/x86_os_my/fs/fs.c:158
		buf[block_bitmap_last_byte] &= ~(1 << bit_idx++);
c000753f:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
c0007543:	8d 50 01             	lea    0x1(%eax),%edx
c0007546:	88 55 e7             	mov    %dl,-0x19(%ebp)
c0007549:	0f b6 c0             	movzbl %al,%eax
c000754c:	ba 01 00 00 00       	mov    $0x1,%edx
c0007551:	89 c1                	mov    %eax,%ecx
c0007553:	d3 e2                	shl    %cl,%edx
c0007555:	89 d0                	mov    %edx,%eax
c0007557:	f7 d0                	not    %eax
c0007559:	89 c3                	mov    %eax,%ebx
c000755b:	8b 55 b8             	mov    -0x48(%ebp),%edx
c000755e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0007561:	01 d0                	add    %edx,%eax
c0007563:	8b 4d b8             	mov    -0x48(%ebp),%ecx
c0007566:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0007569:	01 ca                	add    %ecx,%edx
c000756b:	0f b6 12             	movzbl (%edx),%edx
c000756e:	89 d1                	mov    %edx,%ecx
c0007570:	89 da                	mov    %ebx,%edx
c0007572:	21 ca                	and    %ecx,%edx
c0007574:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/fs/fs.c:157
	// 1 空闲块位图最后一字节，到最后一字节所在扇区的末尾，全置为占用（空闲块位图所在扇区的空闲部分）
	memset(&buf[block_bitmap_last_byte], 0xff, last_size);

	// 2 上一步中最后一字节内，有效的位重新置0
	uint8_t bit_idx = 0;
	while (bit_idx <= block_bitmap_last_bit) {
c0007576:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
c000757a:	3a 45 b3             	cmp    -0x4d(%ebp),%al
c000757d:	76 c0                	jbe    c000753f <partition_format+0x28b>
/work/x86_os_my/fs/fs.c:161
		buf[block_bitmap_last_byte] &= ~(1 << bit_idx++);
	}
	// 3 写回到硬盘 空闲块位图 区域
	ide_write(hd, sb.block_bitmap_lba, buf, sb.block_bitmap_sects);
c000757f:	8b 95 b8 fd ff ff    	mov    -0x248(%ebp),%edx
c0007585:	8b 85 b4 fd ff ff    	mov    -0x24c(%ebp),%eax
c000758b:	52                   	push   %edx
c000758c:	ff 75 b8             	pushl  -0x48(%ebp)
c000758f:	50                   	push   %eax
c0007590:	ff 75 c0             	pushl  -0x40(%ebp)
c0007593:	e8 b0 f1 ff ff       	call   c0006748 <ide_write>
c0007598:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:165


	/***** 3 将inode位图初始化并写入sb.inode_bitmap_lba *****/
	memset(buf, 0, buf_size);
c000759b:	83 ec 04             	sub    $0x4,%esp
c000759e:	ff 75 bc             	pushl  -0x44(%ebp)
c00075a1:	6a 00                	push   $0x0
c00075a3:	ff 75 b8             	pushl  -0x48(%ebp)
c00075a6:	e8 ba c4 ff ff       	call   c0003a65 <memset>
c00075ab:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:166
	buf[0] |= 0x1;	// 第0个inode分给了根目录
c00075ae:	8b 45 b8             	mov    -0x48(%ebp),%eax
c00075b1:	0f b6 00             	movzbl (%eax),%eax
c00075b4:	83 c8 01             	or     $0x1,%eax
c00075b7:	89 c2                	mov    %eax,%edx
c00075b9:	8b 45 b8             	mov    -0x48(%ebp),%eax
c00075bc:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/fs/fs.c:170
	/* 最多4096个文件，inode位图4096个bit，正好占用1扇区，inode_bitmap_sects等于1
	 * 不像block_bitmap，在inode_bitmap的扇区中，没有多余的空闲无效位 */
	// 写回到硬盘 inode位图 区域
	ide_write(hd, sb.inode_bitmap_lba, buf, sb.inode_bitmap_sects);
c00075be:	8b 95 c0 fd ff ff    	mov    -0x240(%ebp),%edx
c00075c4:	8b 85 bc fd ff ff    	mov    -0x244(%ebp),%eax
c00075ca:	52                   	push   %edx
c00075cb:	ff 75 b8             	pushl  -0x48(%ebp)
c00075ce:	50                   	push   %eax
c00075cf:	ff 75 c0             	pushl  -0x40(%ebp)
c00075d2:	e8 71 f1 ff ff       	call   c0006748 <ide_write>
c00075d7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:175


	/***** 4 将inode数组初始化并写入sb.inode_table_lba *****/
	/* 处理inode_table中的第0项，即根目录所在的inode */
	memset(buf, 0, buf_size);
c00075da:	83 ec 04             	sub    $0x4,%esp
c00075dd:	ff 75 bc             	pushl  -0x44(%ebp)
c00075e0:	6a 00                	push   $0x0
c00075e2:	ff 75 b8             	pushl  -0x48(%ebp)
c00075e5:	e8 7b c4 ff ff       	call   c0003a65 <memset>
c00075ea:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:176
	struct inode* i = (struct inode*)buf;
c00075ed:	8b 45 b8             	mov    -0x48(%ebp),%eax
c00075f0:	89 45 a8             	mov    %eax,-0x58(%ebp)
/work/x86_os_my/fs/fs.c:177
	i->i_size = sb.dir_entry_size * 2;		// .和..	// 所有目录项大小之和
c00075f3:	8b 85 d4 fd ff ff    	mov    -0x22c(%ebp),%eax
c00075f9:	8d 14 00             	lea    (%eax,%eax,1),%edx
c00075fc:	8b 45 a8             	mov    -0x58(%ebp),%eax
c00075ff:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/fs.c:178
	i->i_no = 0;   // 根目录占inode数组中第0个inode
c0007602:	8b 45 a8             	mov    -0x58(%ebp),%eax
c0007605:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:182
	// inode管理的是数据块（对于我们来说就是扇区）
	// 此处是指定根目录这个inode管理的数据块的位置
	// i_sectors数组后边的元素都是0 没用到
	i->i_sectors[0] = sb.data_start_lba;
c000760b:	8b 95 cc fd ff ff    	mov    -0x234(%ebp),%edx
c0007611:	8b 45 a8             	mov    -0x58(%ebp),%eax
c0007614:	89 50 10             	mov    %edx,0x10(%eax)
/work/x86_os_my/fs/fs.c:185
	// 写到硬盘 inode数组
	// 其实我们只处理了第0项
	ide_write(hd, sb.inode_table_lba, buf, sb.inode_table_sects);
c0007617:	8b 95 c8 fd ff ff    	mov    -0x238(%ebp),%edx
c000761d:	8b 85 c4 fd ff ff    	mov    -0x23c(%ebp),%eax
c0007623:	52                   	push   %edx
c0007624:	ff 75 b8             	pushl  -0x48(%ebp)
c0007627:	50                   	push   %eax
c0007628:	ff 75 c0             	pushl  -0x40(%ebp)
c000762b:	e8 18 f1 ff ff       	call   c0006748 <ide_write>
c0007630:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:191


	/***** 5 将根目录初始化并写入sb.data_start_lba *****/
	/* 写入根目录的两个目录项.和.. */
	// inode不知道数据块中是普通文件，还是目录。但是目录项知道。
	memset(buf, 0, buf_size);
c0007633:	83 ec 04             	sub    $0x4,%esp
c0007636:	ff 75 bc             	pushl  -0x44(%ebp)
c0007639:	6a 00                	push   $0x0
c000763b:	ff 75 b8             	pushl  -0x48(%ebp)
c000763e:	e8 22 c4 ff ff       	call   c0003a65 <memset>
c0007643:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:192
	struct dir_entry* p_de = (struct dir_entry*)buf;
c0007646:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0007649:	89 45 a4             	mov    %eax,-0x5c(%ebp)
/work/x86_os_my/fs/fs.c:195

	/* 初始化当前目录"." */
	memcpy(p_de->filename, ".", 1);
c000764c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c000764f:	83 ec 04             	sub    $0x4,%esp
c0007652:	6a 01                	push   $0x1
c0007654:	68 7f ec 00 c0       	push   $0xc000ec7f
c0007659:	50                   	push   %eax
c000765a:	e8 58 c4 ff ff       	call   c0003ab7 <memcpy>
c000765f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:196
	p_de->i_no = 0;	// 目录或文件对应的inode编号
c0007662:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c0007665:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
/work/x86_os_my/fs/fs.c:197
	p_de->f_type = FT_DIRECTORY;
c000766c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c000766f:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%eax)
/work/x86_os_my/fs/fs.c:199

	p_de++;
c0007676:	83 45 a4 18          	addl   $0x18,-0x5c(%ebp)
/work/x86_os_my/fs/fs.c:202

	/* 初始化当前目录父目录".." */
	memcpy(p_de->filename, "..", 2);
c000767a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c000767d:	83 ec 04             	sub    $0x4,%esp
c0007680:	6a 02                	push   $0x2
c0007682:	68 81 ec 00 c0       	push   $0xc000ec81
c0007687:	50                   	push   %eax
c0007688:	e8 2a c4 ff ff       	call   c0003ab7 <memcpy>
c000768d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:203
	p_de->i_no = 0;	// 根目录的父目录依然是根目录自己
c0007690:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c0007693:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
/work/x86_os_my/fs/fs.c:204
	p_de->f_type = FT_DIRECTORY;
c000769a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c000769d:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%eax)
/work/x86_os_my/fs/fs.c:207

	/* sb.data_start_lba已经分配给了根目录，我们把根目录的目录项放进去 */
	ide_write(hd, sb.data_start_lba, buf, 1);
c00076a4:	8b 85 cc fd ff ff    	mov    -0x234(%ebp),%eax
c00076aa:	6a 01                	push   $0x1
c00076ac:	ff 75 b8             	pushl  -0x48(%ebp)
c00076af:	50                   	push   %eax
c00076b0:	ff 75 c0             	pushl  -0x40(%ebp)
c00076b3:	e8 90 f0 ff ff       	call   c0006748 <ide_write>
c00076b8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:210


	printk("   root_dir_lba:0x%x\n", sb.data_start_lba);
c00076bb:	8b 85 cc fd ff ff    	mov    -0x234(%ebp),%eax
c00076c1:	83 ec 08             	sub    $0x8,%esp
c00076c4:	50                   	push   %eax
c00076c5:	68 84 ec 00 c0       	push   $0xc000ec84
c00076ca:	e8 7e f9 ff ff       	call   c000704d <printk>
c00076cf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:211
	printk("%s format done\n", part->name);
c00076d2:	8b 45 08             	mov    0x8(%ebp),%eax
c00076d5:	83 c0 14             	add    $0x14,%eax
c00076d8:	83 ec 08             	sub    $0x8,%esp
c00076db:	50                   	push   %eax
c00076dc:	68 9a ec 00 c0       	push   $0xc000ec9a
c00076e1:	e8 67 f9 ff ff       	call   c000704d <printk>
c00076e6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:212
	sys_free(buf);
c00076e9:	83 ec 0c             	sub    $0xc,%esp
c00076ec:	ff 75 b8             	pushl  -0x48(%ebp)
c00076ef:	e8 45 be ff ff       	call   c0003539 <sys_free>
c00076f4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:213
}
c00076f7:	90                   	nop
c00076f8:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00076fb:	5b                   	pop    %ebx
c00076fc:	5e                   	pop    %esi
c00076fd:	5f                   	pop    %edi
c00076fe:	5d                   	pop    %ebp
c00076ff:	c3                   	ret    

c0007700 <path_parse>:
path_parse():
/work/x86_os_my/fs/fs.c:218


/* 将最上层路径名称解析出来，比如pathname="a/b/c"得到name_store="a"
 * 返回剩下的目录 "b/c" */
char* path_parse(char* pathname, char* name_store) {
c0007700:	55                   	push   %ebp
c0007701:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/fs/fs.c:219
	if (pathname[0] == '/') {	// 根目录不需要单独解析
c0007703:	8b 45 08             	mov    0x8(%ebp),%eax
c0007706:	0f b6 00             	movzbl (%eax),%eax
c0007709:	3c 2f                	cmp    $0x2f,%al
c000770b:	75 27                	jne    c0007734 <path_parse+0x34>
/work/x86_os_my/fs/fs.c:221 (discriminator 1)
		/* 路径中出现1个或多个连续的字符'/',将这些'/'跳过,如"///a/b" */
		while(*(++pathname) == '/');
c000770d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0007711:	8b 45 08             	mov    0x8(%ebp),%eax
c0007714:	0f b6 00             	movzbl (%eax),%eax
c0007717:	3c 2f                	cmp    $0x2f,%al
c0007719:	74 f2                	je     c000770d <path_parse+0xd>
/work/x86_os_my/fs/fs.c:225
	}

	/* 开始一般的路径解析 */
	while (*pathname != '/' && *pathname != 0) {
c000771b:	eb 17                	jmp    c0007734 <path_parse+0x34>
/work/x86_os_my/fs/fs.c:226
		*name_store++ = *pathname++;
c000771d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007720:	8d 50 01             	lea    0x1(%eax),%edx
c0007723:	89 55 0c             	mov    %edx,0xc(%ebp)
c0007726:	8b 55 08             	mov    0x8(%ebp),%edx
c0007729:	8d 4a 01             	lea    0x1(%edx),%ecx
c000772c:	89 4d 08             	mov    %ecx,0x8(%ebp)
c000772f:	0f b6 12             	movzbl (%edx),%edx
c0007732:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/fs/fs.c:225
		/* 路径中出现1个或多个连续的字符'/',将这些'/'跳过,如"///a/b" */
		while(*(++pathname) == '/');
	}

	/* 开始一般的路径解析 */
	while (*pathname != '/' && *pathname != 0) {
c0007734:	8b 45 08             	mov    0x8(%ebp),%eax
c0007737:	0f b6 00             	movzbl (%eax),%eax
c000773a:	3c 2f                	cmp    $0x2f,%al
c000773c:	74 0a                	je     c0007748 <path_parse+0x48>
/work/x86_os_my/fs/fs.c:225 (discriminator 1)
c000773e:	8b 45 08             	mov    0x8(%ebp),%eax
c0007741:	0f b6 00             	movzbl (%eax),%eax
c0007744:	84 c0                	test   %al,%al
c0007746:	75 d5                	jne    c000771d <path_parse+0x1d>
/work/x86_os_my/fs/fs.c:229
		*name_store++ = *pathname++;
	}

	if (pathname[0] == 0) {   // 若路径字符串为空则返回NULL
c0007748:	8b 45 08             	mov    0x8(%ebp),%eax
c000774b:	0f b6 00             	movzbl (%eax),%eax
c000774e:	84 c0                	test   %al,%al
c0007750:	75 07                	jne    c0007759 <path_parse+0x59>
/work/x86_os_my/fs/fs.c:230
		return NULL;
c0007752:	b8 00 00 00 00       	mov    $0x0,%eax
c0007757:	eb 03                	jmp    c000775c <path_parse+0x5c>
/work/x86_os_my/fs/fs.c:232
	}
	return pathname;
c0007759:	8b 45 08             	mov    0x8(%ebp),%eax
/work/x86_os_my/fs/fs.c:233
}
c000775c:	5d                   	pop    %ebp
c000775d:	c3                   	ret    

c000775e <path_depth_cnt>:
path_depth_cnt():
/work/x86_os_my/fs/fs.c:236

/* 返回路径深度,比如/a/b/c,深度为3 */
int32_t path_depth_cnt(char* pathname) {
c000775e:	55                   	push   %ebp
c000775f:	89 e5                	mov    %esp,%ebp
c0007761:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/fs/fs.c:237
	ASSERT(pathname != NULL);
c0007764:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0007768:	75 1c                	jne    c0007786 <path_depth_cnt+0x28>
/work/x86_os_my/fs/fs.c:237 (discriminator 1)
c000776a:	68 aa ec 00 c0       	push   $0xc000ecaa
c000776f:	68 64 f4 00 c0       	push   $0xc000f464
c0007774:	68 ed 00 00 00       	push   $0xed
c0007779:	68 41 eb 00 c0       	push   $0xc000eb41
c000777e:	e8 de ad ff ff       	call   c0002561 <panic_spin>
c0007783:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:238
	char* p = pathname;
c0007786:	8b 45 08             	mov    0x8(%ebp),%eax
c0007789:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:240
	char name[MAX_FILE_NAME_LEN];	// 用于path_parse的参数做路径解析
	uint32_t depth = 0;
c000778c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:243

	/* 解析路径,从中拆分出各级名称 */
	p = path_parse(p, name);
c0007793:	83 ec 08             	sub    $0x8,%esp
c0007796:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0007799:	50                   	push   %eax
c000779a:	ff 75 f4             	pushl  -0xc(%ebp)
c000779d:	e8 5e ff ff ff       	call   c0007700 <path_parse>
c00077a2:	83 c4 10             	add    $0x10,%esp
c00077a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:244
	while (name[0]) {
c00077a8:	eb 32                	jmp    c00077dc <path_depth_cnt+0x7e>
/work/x86_os_my/fs/fs.c:245
		depth++;
c00077aa:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:246
		memset(name, 0, MAX_FILE_NAME_LEN);
c00077ae:	83 ec 04             	sub    $0x4,%esp
c00077b1:	6a 10                	push   $0x10
c00077b3:	6a 00                	push   $0x0
c00077b5:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00077b8:	50                   	push   %eax
c00077b9:	e8 a7 c2 ff ff       	call   c0003a65 <memset>
c00077be:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:247
		if (p) {	// 如果p不等于NULL,继续分析路径
c00077c1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00077c5:	74 15                	je     c00077dc <path_depth_cnt+0x7e>
/work/x86_os_my/fs/fs.c:248
			p  = path_parse(p, name);
c00077c7:	83 ec 08             	sub    $0x8,%esp
c00077ca:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00077cd:	50                   	push   %eax
c00077ce:	ff 75 f4             	pushl  -0xc(%ebp)
c00077d1:	e8 2a ff ff ff       	call   c0007700 <path_parse>
c00077d6:	83 c4 10             	add    $0x10,%esp
c00077d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:244
	char name[MAX_FILE_NAME_LEN];	// 用于path_parse的参数做路径解析
	uint32_t depth = 0;

	/* 解析路径,从中拆分出各级名称 */
	p = path_parse(p, name);
	while (name[0]) {
c00077dc:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
c00077e0:	84 c0                	test   %al,%al
c00077e2:	75 c6                	jne    c00077aa <path_depth_cnt+0x4c>
/work/x86_os_my/fs/fs.c:251
		memset(name, 0, MAX_FILE_NAME_LEN);
		if (p) {	// 如果p不等于NULL,继续分析路径
			p  = path_parse(p, name);
		}
	}
	return depth;
c00077e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/fs/fs.c:252
}
c00077e7:	c9                   	leave  
c00077e8:	c3                   	ret    

c00077e9 <search_file>:
search_file():
/work/x86_os_my/fs/fs.c:261
 * 全局变量 struct dir root_dir 定义在 dir.c
 * 也支持 /./a 或者 /../b 会把.和..当做一个目录项继续往下层找
 * /a/b/c若c不存在，那么 searched_record.searched_path 是 /a/b/c
 * 注意下边三种return的地方，是三种情况！
 */
static int search_file(const char* pathname, struct path_search_record* searched_record) {
c00077e9:	55                   	push   %ebp
c00077ea:	89 e5                	mov    %esp,%ebp
c00077ec:	83 ec 48             	sub    $0x48,%esp
/work/x86_os_my/fs/fs.c:263
	/* 如果待查找的是根目录,为避免下面无用的查找,直接返回已知根目录信息 */
	if (!strcmp(pathname, "/") || !strcmp(pathname, "/.") || !strcmp(pathname, "/..")) {
c00077ef:	83 ec 08             	sub    $0x8,%esp
c00077f2:	68 bb ec 00 c0       	push   $0xc000ecbb
c00077f7:	ff 75 08             	pushl  0x8(%ebp)
c00077fa:	e8 3b c4 ff ff       	call   c0003c3a <strcmp>
c00077ff:	83 c4 10             	add    $0x10,%esp
c0007802:	84 c0                	test   %al,%al
c0007804:	74 2e                	je     c0007834 <search_file+0x4b>
/work/x86_os_my/fs/fs.c:263 (discriminator 1)
c0007806:	83 ec 08             	sub    $0x8,%esp
c0007809:	68 bd ec 00 c0       	push   $0xc000ecbd
c000780e:	ff 75 08             	pushl  0x8(%ebp)
c0007811:	e8 24 c4 ff ff       	call   c0003c3a <strcmp>
c0007816:	83 c4 10             	add    $0x10,%esp
c0007819:	84 c0                	test   %al,%al
c000781b:	74 17                	je     c0007834 <search_file+0x4b>
/work/x86_os_my/fs/fs.c:263 (discriminator 2)
c000781d:	83 ec 08             	sub    $0x8,%esp
c0007820:	68 c0 ec 00 c0       	push   $0xc000ecc0
c0007825:	ff 75 08             	pushl  0x8(%ebp)
c0007828:	e8 0d c4 ff ff       	call   c0003c3a <strcmp>
c000782d:	83 c4 10             	add    $0x10,%esp
c0007830:	84 c0                	test   %al,%al
c0007832:	75 2a                	jne    c000785e <search_file+0x75>
/work/x86_os_my/fs/fs.c:264
		searched_record->parent_dir = &root_dir;	// 直接父目录
c0007834:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007837:	c7 80 00 02 00 00 20 	movl   $0xc0015a20,0x200(%eax)
c000783e:	5a 01 c0 
/work/x86_os_my/fs/fs.c:265
		searched_record->file_type = FT_DIRECTORY;	// FT_UNKNOWN代表没找到，找到才有类型是文件或目录
c0007841:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007844:	c7 80 04 02 00 00 02 	movl   $0x2,0x204(%eax)
c000784b:	00 00 00 
/work/x86_os_my/fs/fs.c:266
		searched_record->searched_path[0] = 0;		// 搜索过的路径置空
c000784e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007851:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:267
		return 0;
c0007854:	b8 00 00 00 00       	mov    $0x0,%eax
c0007859:	e9 08 02 00 00       	jmp    c0007a66 <search_file+0x27d>
/work/x86_os_my/fs/fs.c:270
	}

	uint32_t path_len = strlen(pathname);
c000785e:	83 ec 0c             	sub    $0xc,%esp
c0007861:	ff 75 08             	pushl  0x8(%ebp)
c0007864:	e8 86 c3 ff ff       	call   c0003bef <strlen>
c0007869:	83 c4 10             	add    $0x10,%esp
c000786c:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:272
	/* 保证pathname至少是这样的路径/x且小于最大长度 */
	ASSERT(pathname[0] == '/' && path_len > 1 && path_len < MAX_PATH_LEN);
c000786f:	8b 45 08             	mov    0x8(%ebp),%eax
c0007872:	0f b6 00             	movzbl (%eax),%eax
c0007875:	3c 2f                	cmp    $0x2f,%al
c0007877:	75 0f                	jne    c0007888 <search_file+0x9f>
/work/x86_os_my/fs/fs.c:272 (discriminator 1)
c0007879:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c000787d:	76 09                	jbe    c0007888 <search_file+0x9f>
/work/x86_os_my/fs/fs.c:272 (discriminator 3)
c000787f:	81 7d e8 ff 01 00 00 	cmpl   $0x1ff,-0x18(%ebp)
c0007886:	76 1c                	jbe    c00078a4 <search_file+0xbb>
/work/x86_os_my/fs/fs.c:272 (discriminator 5)
c0007888:	68 c4 ec 00 c0       	push   $0xc000ecc4
c000788d:	68 74 f4 00 c0       	push   $0xc000f474
c0007892:	68 10 01 00 00       	push   $0x110
c0007897:	68 41 eb 00 c0       	push   $0xc000eb41
c000789c:	e8 c0 ac ff ff       	call   c0002561 <panic_spin>
c00078a1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:273
	char* sub_path = (char*)pathname;
c00078a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00078a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:274
	struct dir* parent_dir = &root_dir;
c00078aa:	c7 45 f0 20 5a 01 c0 	movl   $0xc0015a20,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:278
	struct dir_entry dir_e;

	/* 数组name每次的值分别是各级目录的名字："a","b","c" */
	char name[MAX_FILE_NAME_LEN] = {0};
c00078b1:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
c00078b8:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
c00078bf:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
c00078c6:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
/work/x86_os_my/fs/fs.c:280

	searched_record->parent_dir = parent_dir;	// 直接父目录
c00078cd:	8b 45 0c             	mov    0xc(%ebp),%eax
c00078d0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00078d3:	89 90 00 02 00 00    	mov    %edx,0x200(%eax)
/work/x86_os_my/fs/fs.c:281
	searched_record->file_type = FT_UNKNOWN;	// 初始值代表没找到，找到才有类型是文件或目录
c00078d9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00078dc:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%eax)
c00078e3:	00 00 00 
/work/x86_os_my/fs/fs.c:282
	uint32_t parent_inode_no = 0;  // 备份各层解析出来的路径，的父目录，的inode号
c00078e6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:284

	sub_path = path_parse(sub_path, name);
c00078ed:	83 ec 08             	sub    $0x8,%esp
c00078f0:	8d 45 c0             	lea    -0x40(%ebp),%eax
c00078f3:	50                   	push   %eax
c00078f4:	ff 75 f4             	pushl  -0xc(%ebp)
c00078f7:	e8 04 fe ff ff       	call   c0007700 <path_parse>
c00078fc:	83 c4 10             	add    $0x10,%esp
c00078ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:285
	while (name[0]) {	   // 若第一个字符就是结束符,结束循环
c0007902:	e9 0f 01 00 00       	jmp    c0007a16 <search_file+0x22d>
/work/x86_os_my/fs/fs.c:287
		/* 记录查找过的路径,但不能超过searched_path的长度512字节 */
		ASSERT(strlen(searched_record->searched_path) < 512);
c0007907:	8b 45 0c             	mov    0xc(%ebp),%eax
c000790a:	83 ec 0c             	sub    $0xc,%esp
c000790d:	50                   	push   %eax
c000790e:	e8 dc c2 ff ff       	call   c0003bef <strlen>
c0007913:	83 c4 10             	add    $0x10,%esp
c0007916:	3d ff 01 00 00       	cmp    $0x1ff,%eax
c000791b:	76 1c                	jbe    c0007939 <search_file+0x150>
/work/x86_os_my/fs/fs.c:287 (discriminator 1)
c000791d:	68 04 ed 00 c0       	push   $0xc000ed04
c0007922:	68 74 f4 00 c0       	push   $0xc000f474
c0007927:	68 1f 01 00 00       	push   $0x11f
c000792c:	68 41 eb 00 c0       	push   $0xc000eb41
c0007931:	e8 2b ac ff ff       	call   c0002561 <panic_spin>
c0007936:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:290

		/* 追加到已存在的父目录 */
		strcat(searched_record->searched_path, "/");
c0007939:	8b 45 0c             	mov    0xc(%ebp),%eax
c000793c:	83 ec 08             	sub    $0x8,%esp
c000793f:	68 bb ec 00 c0       	push   $0xc000ecbb
c0007944:	50                   	push   %eax
c0007945:	e8 1f c4 ff ff       	call   c0003d69 <strcat>
c000794a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:291
		strcat(searched_record->searched_path, name);
c000794d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007950:	83 ec 08             	sub    $0x8,%esp
c0007953:	8d 55 c0             	lea    -0x40(%ebp),%edx
c0007956:	52                   	push   %edx
c0007957:	50                   	push   %eax
c0007958:	e8 0c c4 ff ff       	call   c0003d69 <strcat>
c000795d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:294

		/* 在所给的目录中查找目录项，找到后将目录项填入dir_e */
		if (false != search_dir_entry(cur_part, parent_dir, name, &dir_e)) {
c0007960:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0007965:	8d 55 d0             	lea    -0x30(%ebp),%edx
c0007968:	52                   	push   %edx
c0007969:	8d 55 c0             	lea    -0x40(%ebp),%edx
c000796c:	52                   	push   %edx
c000796d:	ff 75 f0             	pushl  -0x10(%ebp)
c0007970:	50                   	push   %eax
c0007971:	e8 e1 31 00 00       	call   c000ab57 <search_dir_entry>
c0007976:	83 c4 10             	add    $0x10,%esp
c0007979:	85 c0                	test   %eax,%eax
c000797b:	0f 84 8e 00 00 00    	je     c0007a0f <search_file+0x226>
/work/x86_os_my/fs/fs.c:295
			memset(name, 0, MAX_FILE_NAME_LEN);
c0007981:	83 ec 04             	sub    $0x4,%esp
c0007984:	6a 10                	push   $0x10
c0007986:	6a 00                	push   $0x0
c0007988:	8d 45 c0             	lea    -0x40(%ebp),%eax
c000798b:	50                   	push   %eax
c000798c:	e8 d4 c0 ff ff       	call   c0003a65 <memset>
c0007991:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:297
			/* 若sub_path不等于NULL，也就是搜索未结束，继续拆分路径 */
			if (sub_path) {
c0007994:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0007998:	74 15                	je     c00079af <search_file+0x1c6>
/work/x86_os_my/fs/fs.c:298
				sub_path = path_parse(sub_path, name);
c000799a:	83 ec 08             	sub    $0x8,%esp
c000799d:	8d 45 c0             	lea    -0x40(%ebp),%eax
c00079a0:	50                   	push   %eax
c00079a1:	ff 75 f4             	pushl  -0xc(%ebp)
c00079a4:	e8 57 fd ff ff       	call   c0007700 <path_parse>
c00079a9:	83 c4 10             	add    $0x10,%esp
c00079ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:301
			}

			if (FT_DIRECTORY == dir_e.f_type) {			// 如果被打开的是目录
c00079af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00079b2:	83 f8 02             	cmp    $0x2,%eax
c00079b5:	75 3e                	jne    c00079f5 <search_file+0x20c>
/work/x86_os_my/fs/fs.c:302
				parent_inode_no = parent_dir->inode->i_no;
c00079b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00079ba:	8b 00                	mov    (%eax),%eax
c00079bc:	8b 00                	mov    (%eax),%eax
c00079be:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:303
				dir_close(parent_dir);
c00079c1:	83 ec 0c             	sub    $0xc,%esp
c00079c4:	ff 75 f0             	pushl  -0x10(%ebp)
c00079c7:	e8 63 33 00 00       	call   c000ad2f <dir_close>
c00079cc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:305

				parent_dir = dir_open(cur_part, dir_e.i_no);
c00079cf:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00079d2:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c00079d7:	83 ec 08             	sub    $0x8,%esp
c00079da:	52                   	push   %edx
c00079db:	50                   	push   %eax
c00079dc:	e8 36 31 00 00       	call   c000ab17 <dir_open>
c00079e1:	83 c4 10             	add    $0x10,%esp
c00079e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:306
				searched_record->parent_dir = parent_dir;	// 更新直接父目录
c00079e7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00079ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00079ed:	89 90 00 02 00 00    	mov    %edx,0x200(%eax)
/work/x86_os_my/fs/fs.c:307
				continue;
c00079f3:	eb 21                	jmp    c0007a16 <search_file+0x22d>
/work/x86_os_my/fs/fs.c:308
			} else if (FT_REGULAR == dir_e.f_type) {	// 若是普通文件
c00079f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00079f8:	83 f8 01             	cmp    $0x1,%eax
c00079fb:	75 19                	jne    c0007a16 <search_file+0x22d>
/work/x86_os_my/fs/fs.c:313
				/* 如果搜索路径为 /a/b 但是目录下只有文件a 此时也会返回文件a的inode号【中间某个目录不存在】
				 * 由主调函数根据 searched_record.searched_path 判断："提供的 pathname 是否正确，是否处理完了"
				 * 【情况1】
				 */
				searched_record->file_type = FT_REGULAR;
c00079fd:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007a00:	c7 80 04 02 00 00 01 	movl   $0x1,0x204(%eax)
c0007a07:	00 00 00 
/work/x86_os_my/fs/fs.c:314
				return dir_e.i_no;
c0007a0a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0007a0d:	eb 57                	jmp    c0007a66 <search_file+0x27d>
/work/x86_os_my/fs/fs.c:322
			/* 找不到目录项时，要留着 parent_dir 不要关闭，
			 * 主调函数需要据此知道在哪个目录中创建文件，此时的 searched_record->parent_dir 指向父目录，主调函数负责关闭该目录
			 * 主调函数，创建新文件的话需要在 parent_dir 中创建
			 * 【情况2】
			 */
			return -1;
c0007a0f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007a14:	eb 50                	jmp    c0007a66 <search_file+0x27d>
/work/x86_os_my/fs/fs.c:285
	searched_record->parent_dir = parent_dir;	// 直接父目录
	searched_record->file_type = FT_UNKNOWN;	// 初始值代表没找到，找到才有类型是文件或目录
	uint32_t parent_inode_no = 0;  // 备份各层解析出来的路径，的父目录，的inode号

	sub_path = path_parse(sub_path, name);
	while (name[0]) {	   // 若第一个字符就是结束符,结束循环
c0007a16:	0f b6 45 c0          	movzbl -0x40(%ebp),%eax
c0007a1a:	84 c0                	test   %al,%al
c0007a1c:	0f 85 e5 fe ff ff    	jne    c0007907 <search_file+0x11e>
/work/x86_os_my/fs/fs.c:333
	 * 此时 searched_record-> parent_dir 是路径 pathname 中的最后一级目录 c，并不是倒数第二级的父目录 b
	 * 要保证，无论搜索目标是普通文件，还是目录，searched_record->parent_dir 中记录的都应该是父目录！
	 * 因此要关闭目录c，重新打开目录b
	 * 【情况3】
	 */
	dir_close(searched_record->parent_dir);
c0007a22:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007a25:	8b 80 00 02 00 00    	mov    0x200(%eax),%eax
c0007a2b:	83 ec 0c             	sub    $0xc,%esp
c0007a2e:	50                   	push   %eax
c0007a2f:	e8 fb 32 00 00       	call   c000ad2f <dir_close>
c0007a34:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:334
	searched_record->parent_dir = dir_open(cur_part, parent_inode_no);
c0007a37:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0007a3c:	83 ec 08             	sub    $0x8,%esp
c0007a3f:	ff 75 ec             	pushl  -0x14(%ebp)
c0007a42:	50                   	push   %eax
c0007a43:	e8 cf 30 00 00       	call   c000ab17 <dir_open>
c0007a48:	83 c4 10             	add    $0x10,%esp
c0007a4b:	89 c2                	mov    %eax,%edx
c0007a4d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007a50:	89 90 00 02 00 00    	mov    %edx,0x200(%eax)
/work/x86_os_my/fs/fs.c:335
	searched_record->file_type = FT_DIRECTORY;
c0007a56:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007a59:	c7 80 04 02 00 00 02 	movl   $0x2,0x204(%eax)
c0007a60:	00 00 00 
/work/x86_os_my/fs/fs.c:336
	return dir_e.i_no;	//目录c的inode号
c0007a63:	8b 45 e0             	mov    -0x20(%ebp),%eax
/work/x86_os_my/fs/fs.c:337 (discriminator 1)
}
c0007a66:	c9                   	leave  
c0007a67:	c3                   	ret    

c0007a68 <sys_open>:
sys_open():
/work/x86_os_my/fs/fs.c:344
/* 打开或创建文件成功后,返回文件描述符,否则返回-1
 * 对应 file.c 中的 file_create
 *
 * open(const char * pathname, (O_CREAT|O_WRONLY|O_TRUNC));
 */
int32_t sys_open(const char* pathname, uint8_t flags) {
c0007a68:	55                   	push   %ebp
c0007a69:	89 e5                	mov    %esp,%ebp
c0007a6b:	53                   	push   %ebx
c0007a6c:	81 ec 34 02 00 00    	sub    $0x234,%esp
c0007a72:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007a75:	88 85 d4 fd ff ff    	mov    %al,-0x22c(%ebp)
/work/x86_os_my/fs/fs.c:346
	/* 对目录要用dir_open,这里只有open文件 */
	if (pathname[strlen(pathname) - 1] == '/') {
c0007a7b:	83 ec 0c             	sub    $0xc,%esp
c0007a7e:	ff 75 08             	pushl  0x8(%ebp)
c0007a81:	e8 69 c1 ff ff       	call   c0003bef <strlen>
c0007a86:	83 c4 10             	add    $0x10,%esp
c0007a89:	8d 50 ff             	lea    -0x1(%eax),%edx
c0007a8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0007a8f:	01 d0                	add    %edx,%eax
c0007a91:	0f b6 00             	movzbl (%eax),%eax
c0007a94:	3c 2f                	cmp    $0x2f,%al
c0007a96:	75 1d                	jne    c0007ab5 <sys_open+0x4d>
/work/x86_os_my/fs/fs.c:347
		printk("can`t open a directory %s\n", pathname);
c0007a98:	83 ec 08             	sub    $0x8,%esp
c0007a9b:	ff 75 08             	pushl  0x8(%ebp)
c0007a9e:	68 31 ed 00 c0       	push   $0xc000ed31
c0007aa3:	e8 a5 f5 ff ff       	call   c000704d <printk>
c0007aa8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:348
		return -1;
c0007aab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007ab0:	e9 10 02 00 00       	jmp    c0007cc5 <sys_open+0x25d>
/work/x86_os_my/fs/fs.c:350
	}
	ASSERT(flags <= 7);
c0007ab5:	80 bd d4 fd ff ff 07 	cmpb   $0x7,-0x22c(%ebp)
c0007abc:	76 1c                	jbe    c0007ada <sys_open+0x72>
/work/x86_os_my/fs/fs.c:350 (discriminator 1)
c0007abe:	68 4c ed 00 c0       	push   $0xc000ed4c
c0007ac3:	68 80 f4 00 c0       	push   $0xc000f480
c0007ac8:	68 5e 01 00 00       	push   $0x15e
c0007acd:	68 41 eb 00 c0       	push   $0xc000eb41
c0007ad2:	e8 8a aa ff ff       	call   c0002561 <panic_spin>
c0007ad7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:351
	int32_t fd = -1;	// 默认为找不到
c0007ada:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:354

	struct path_search_record searched_record;
	memset(&searched_record, 0, sizeof(struct path_search_record));
c0007ae1:	83 ec 04             	sub    $0x4,%esp
c0007ae4:	68 08 02 00 00       	push   $0x208
c0007ae9:	6a 00                	push   $0x0
c0007aeb:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c0007af1:	50                   	push   %eax
c0007af2:	e8 6e bf ff ff       	call   c0003a65 <memset>
c0007af7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:357

	/* 记录目录深度.帮助判断中间某个目录不存在的情况 */
	uint32_t pathname_depth = path_depth_cnt((char*)pathname);
c0007afa:	83 ec 0c             	sub    $0xc,%esp
c0007afd:	ff 75 08             	pushl  0x8(%ebp)
c0007b00:	e8 59 fc ff ff       	call   c000775e <path_depth_cnt>
c0007b05:	83 c4 10             	add    $0x10,%esp
c0007b08:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:360

	/* 先检查文件是否存在 */
	int inode_no = search_file(pathname, &searched_record);
c0007b0b:	83 ec 08             	sub    $0x8,%esp
c0007b0e:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c0007b14:	50                   	push   %eax
c0007b15:	ff 75 08             	pushl  0x8(%ebp)
c0007b18:	e8 cc fc ff ff       	call   c00077e9 <search_file>
c0007b1d:	83 c4 10             	add    $0x10,%esp
c0007b20:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:361
	bool found = (inode_no != -1 ? true : false);
c0007b23:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c0007b27:	0f 95 c0             	setne  %al
c0007b2a:	0f b6 c0             	movzbl %al,%eax
c0007b2d:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:363

	if (searched_record.file_type == FT_DIRECTORY) {
c0007b30:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0007b33:	83 f8 02             	cmp    $0x2,%eax
c0007b36:	75 29                	jne    c0007b61 <sys_open+0xf9>
/work/x86_os_my/fs/fs.c:364
		printk("can`t open a direcotry with open(), use opendir() to instead\n");
c0007b38:	83 ec 0c             	sub    $0xc,%esp
c0007b3b:	68 58 ed 00 c0       	push   $0xc000ed58
c0007b40:	e8 08 f5 ff ff       	call   c000704d <printk>
c0007b45:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:365
		dir_close(searched_record.parent_dir);	//主调函数负责关闭该目录
c0007b48:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0007b4b:	83 ec 0c             	sub    $0xc,%esp
c0007b4e:	50                   	push   %eax
c0007b4f:	e8 db 31 00 00       	call   c000ad2f <dir_close>
c0007b54:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:366
		return -1;
c0007b57:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007b5c:	e9 64 01 00 00       	jmp    c0007cc5 <sys_open+0x25d>
/work/x86_os_my/fs/fs.c:369
	}

	uint32_t path_searched_depth = path_depth_cnt(searched_record.searched_path);
c0007b61:	83 ec 0c             	sub    $0xc,%esp
c0007b64:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c0007b6a:	50                   	push   %eax
c0007b6b:	e8 ee fb ff ff       	call   c000775e <path_depth_cnt>
c0007b70:	83 c4 10             	add    $0x10,%esp
c0007b73:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/fs.c:373

	/* 先判断是否把pathname的各层目录都访问到了 */
	// 【search_file情况1】说明并没有访问到全部的路径,某个中间目录是不存在的【是一个同名的普通文件】
	if (pathname_depth != path_searched_depth) {
c0007b76:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0007b79:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0007b7c:	74 33                	je     c0007bb1 <sys_open+0x149>
/work/x86_os_my/fs/fs.c:374
		printk("cannot access %s: Not a directory, subpath %s is`t exist\n",
c0007b7e:	83 ec 04             	sub    $0x4,%esp
c0007b81:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c0007b87:	50                   	push   %eax
c0007b88:	ff 75 08             	pushl  0x8(%ebp)
c0007b8b:	68 98 ed 00 c0       	push   $0xc000ed98
c0007b90:	e8 b8 f4 ff ff       	call   c000704d <printk>
c0007b95:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:376
			pathname, searched_record.searched_path);
		dir_close(searched_record.parent_dir);
c0007b98:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0007b9b:	83 ec 0c             	sub    $0xc,%esp
c0007b9e:	50                   	push   %eax
c0007b9f:	e8 8b 31 00 00       	call   c000ad2f <dir_close>
c0007ba4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:377
		return -1;
c0007ba7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007bac:	e9 14 01 00 00       	jmp    c0007cc5 <sys_open+0x25d>
/work/x86_os_my/fs/fs.c:382
	}

	// 【search_file情况2】若是在最后一个路径上没找到
	// 并且此时也不是要创建文件,直接返回-1 */
	if (!found && !(flags & O_CREAT)) {
c0007bb1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0007bb5:	75 56                	jne    c0007c0d <sys_open+0x1a5>
/work/x86_os_my/fs/fs.c:382 (discriminator 1)
c0007bb7:	0f b6 85 d4 fd ff ff 	movzbl -0x22c(%ebp),%eax
c0007bbe:	83 e0 04             	and    $0x4,%eax
c0007bc1:	85 c0                	test   %eax,%eax
c0007bc3:	75 48                	jne    c0007c0d <sys_open+0x1a5>
/work/x86_os_my/fs/fs.c:384
		printk("in path %s, file %s is`t exist\n",
			searched_record.searched_path, (strrchr(searched_record.searched_path, '/') + 1));
c0007bc5:	83 ec 08             	sub    $0x8,%esp
c0007bc8:	6a 2f                	push   $0x2f
c0007bca:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c0007bd0:	50                   	push   %eax
c0007bd1:	e8 35 c1 ff ff       	call   c0003d0b <strrchr>
c0007bd6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:383
	}

	// 【search_file情况2】若是在最后一个路径上没找到
	// 并且此时也不是要创建文件,直接返回-1 */
	if (!found && !(flags & O_CREAT)) {
		printk("in path %s, file %s is`t exist\n",
c0007bd9:	83 c0 01             	add    $0x1,%eax
c0007bdc:	83 ec 04             	sub    $0x4,%esp
c0007bdf:	50                   	push   %eax
c0007be0:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c0007be6:	50                   	push   %eax
c0007be7:	68 d4 ed 00 c0       	push   $0xc000edd4
c0007bec:	e8 5c f4 ff ff       	call   c000704d <printk>
c0007bf1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:385
			searched_record.searched_path, (strrchr(searched_record.searched_path, '/') + 1));
		dir_close(searched_record.parent_dir);
c0007bf4:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0007bf7:	83 ec 0c             	sub    $0xc,%esp
c0007bfa:	50                   	push   %eax
c0007bfb:	e8 2f 31 00 00       	call   c000ad2f <dir_close>
c0007c00:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:386
		return -1;
c0007c03:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007c08:	e9 b8 00 00 00       	jmp    c0007cc5 <sys_open+0x25d>
/work/x86_os_my/fs/fs.c:387
	} else if (found && flags & O_CREAT) {	// 若要创建的文件已存在，相同目录下不可以有同名文件，返回-1
c0007c0d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0007c11:	74 37                	je     c0007c4a <sys_open+0x1e2>
/work/x86_os_my/fs/fs.c:387 (discriminator 1)
c0007c13:	0f b6 85 d4 fd ff ff 	movzbl -0x22c(%ebp),%eax
c0007c1a:	83 e0 04             	and    $0x4,%eax
c0007c1d:	85 c0                	test   %eax,%eax
c0007c1f:	74 29                	je     c0007c4a <sys_open+0x1e2>
/work/x86_os_my/fs/fs.c:388
		printk("%s has already exist!\n", pathname);
c0007c21:	83 ec 08             	sub    $0x8,%esp
c0007c24:	ff 75 08             	pushl  0x8(%ebp)
c0007c27:	68 f4 ed 00 c0       	push   $0xc000edf4
c0007c2c:	e8 1c f4 ff ff       	call   c000704d <printk>
c0007c31:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:389
		dir_close(searched_record.parent_dir);
c0007c34:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0007c37:	83 ec 0c             	sub    $0xc,%esp
c0007c3a:	50                   	push   %eax
c0007c3b:	e8 ef 30 00 00       	call   c000ad2f <dir_close>
c0007c40:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:390
		return -1;
c0007c43:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007c48:	eb 7b                	jmp    c0007cc5 <sys_open+0x25d>
/work/x86_os_my/fs/fs.c:393
	}

	switch (flags & O_CREAT) {	// sys_open("xxx", O_CREAT|O_XXX)
c0007c4a:	0f b6 85 d4 fd ff ff 	movzbl -0x22c(%ebp),%eax
c0007c51:	83 e0 04             	and    $0x4,%eax
c0007c54:	83 f8 04             	cmp    $0x4,%eax
c0007c57:	75 4f                	jne    c0007ca8 <sys_open+0x240>
/work/x86_os_my/fs/fs.c:395
		case O_CREAT:
		printk("creating file\n");
c0007c59:	83 ec 0c             	sub    $0xc,%esp
c0007c5c:	68 0b ee 00 c0       	push   $0xc000ee0b
c0007c61:	e8 e7 f3 ff ff       	call   c000704d <printk>
c0007c66:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:397
		// 【search_file情况3】主调函数用到此目录，在该目录下创建文件
		fd = file_create(searched_record.parent_dir, (strrchr(pathname, '/') + 1), flags);
c0007c69:	0f b6 9d d4 fd ff ff 	movzbl -0x22c(%ebp),%ebx
c0007c70:	83 ec 08             	sub    $0x8,%esp
c0007c73:	6a 2f                	push   $0x2f
c0007c75:	ff 75 08             	pushl  0x8(%ebp)
c0007c78:	e8 8e c0 ff ff       	call   c0003d0b <strrchr>
c0007c7d:	83 c4 10             	add    $0x10,%esp
c0007c80:	8d 50 01             	lea    0x1(%eax),%edx
c0007c83:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0007c86:	83 ec 04             	sub    $0x4,%esp
c0007c89:	53                   	push   %ebx
c0007c8a:	52                   	push   %edx
c0007c8b:	50                   	push   %eax
c0007c8c:	e8 fb 1e 00 00       	call   c0009b8c <file_create>
c0007c91:	83 c4 10             	add    $0x10,%esp
c0007c94:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:398
		dir_close(searched_record.parent_dir);
c0007c97:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0007c9a:	83 ec 0c             	sub    $0xc,%esp
c0007c9d:	50                   	push   %eax
c0007c9e:	e8 8c 30 00 00       	call   c000ad2f <dir_close>
c0007ca3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:399
		break;
c0007ca6:	eb 1a                	jmp    c0007cc2 <sys_open+0x25a>
/work/x86_os_my/fs/fs.c:403

		default:
		/* 其余情况均为打开已存在文件: O_RDONLY,O_WRONLY,O_RDWR */
		fd = file_open(inode_no, flags);
c0007ca8:	0f b6 95 d4 fd ff ff 	movzbl -0x22c(%ebp),%edx
c0007caf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0007cb2:	83 ec 08             	sub    $0x8,%esp
c0007cb5:	52                   	push   %edx
c0007cb6:	50                   	push   %eax
c0007cb7:	e8 92 21 00 00       	call   c0009e4e <file_open>
c0007cbc:	83 c4 10             	add    $0x10,%esp
c0007cbf:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:408
	}

	/* 此fd是指任务pcb->fd_table数组中的元素下标,
	 * 并不是指全局file_table中的下标 */
	return fd;
c0007cc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:409 (discriminator 1)
}
c0007cc5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0007cc8:	c9                   	leave  
c0007cc9:	c3                   	ret    

c0007cca <fd_local2global>:
fd_local2global():
/work/x86_os_my/fs/fs.c:412

/* 将文件描述符转化为文件表的下标 */
uint32_t fd_local2global(uint32_t local_fd) {
c0007cca:	55                   	push   %ebp
c0007ccb:	89 e5                	mov    %esp,%ebp
c0007ccd:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/fs.c:413
	struct task_struct* cur = running_thread();
c0007cd0:	e8 77 c1 ff ff       	call   c0003e4c <running_thread>
c0007cd5:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:414
	int32_t global_fd = cur->fd_table[local_fd];
c0007cd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0007cdb:	8b 55 08             	mov    0x8(%ebp),%edx
c0007cde:	83 c2 08             	add    $0x8,%edx
c0007ce1:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
c0007ce5:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:415
	ASSERT(global_fd >= 0 && global_fd < MAX_FILE_OPEN);
c0007ce8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0007cec:	78 06                	js     c0007cf4 <fd_local2global+0x2a>
/work/x86_os_my/fs/fs.c:415 (discriminator 1)
c0007cee:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
c0007cf2:	7e 1c                	jle    c0007d10 <fd_local2global+0x46>
/work/x86_os_my/fs/fs.c:415 (discriminator 3)
c0007cf4:	68 1c ee 00 c0       	push   $0xc000ee1c
c0007cf9:	68 8c f4 00 c0       	push   $0xc000f48c
c0007cfe:	68 9f 01 00 00       	push   $0x19f
c0007d03:	68 41 eb 00 c0       	push   $0xc000eb41
c0007d08:	e8 54 a8 ff ff       	call   c0002561 <panic_spin>
c0007d0d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:416
	return (uint32_t)global_fd;
c0007d10:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/fs/fs.c:417
}
c0007d13:	c9                   	leave  
c0007d14:	c3                   	ret    

c0007d15 <sys_close>:
sys_close():
/work/x86_os_my/fs/fs.c:420

/* 关闭文件描述符fd指向的文件,成功返回0,否则返回-1 */
int32_t sys_close(int32_t fd) {
c0007d15:	55                   	push   %ebp
c0007d16:	89 e5                	mov    %esp,%ebp
c0007d18:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/fs.c:421
	int32_t ret = -1;   // 返回值默认为-1,即失败
c0007d1b:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:422
	if (fd > 2) {
c0007d22:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0007d26:	0f 8e e1 00 00 00    	jle    c0007e0d <sys_close+0xf8>
/work/x86_os_my/fs/fs.c:423
		uint32_t global_fd = fd_local2global(fd);
c0007d2c:	8b 45 08             	mov    0x8(%ebp),%eax
c0007d2f:	83 ec 0c             	sub    $0xc,%esp
c0007d32:	50                   	push   %eax
c0007d33:	e8 92 ff ff ff       	call   c0007cca <fd_local2global>
c0007d38:	83 c4 10             	add    $0x10,%esp
c0007d3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:424
		if (is_pipe(fd)) {
c0007d3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0007d41:	83 ec 0c             	sub    $0xc,%esp
c0007d44:	50                   	push   %eax
c0007d45:	e8 cf 58 00 00       	call   c000d619 <is_pipe>
c0007d4a:	83 c4 10             	add    $0x10,%esp
c0007d4d:	85 c0                	test   %eax,%eax
c0007d4f:	0f 84 83 00 00 00    	je     c0007dd8 <sys_close+0xc3>
/work/x86_os_my/fs/fs.c:426
			/* 如果此管道上的描述符都被关闭,释放管道的环形缓冲区 */
			if (--file_table[global_fd].fd_pos == 0) {
c0007d55:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007d58:	89 d0                	mov    %edx,%eax
c0007d5a:	01 c0                	add    %eax,%eax
c0007d5c:	01 d0                	add    %edx,%eax
c0007d5e:	c1 e0 02             	shl    $0x2,%eax
c0007d61:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c0007d66:	8b 00                	mov    (%eax),%eax
c0007d68:	8d 48 ff             	lea    -0x1(%eax),%ecx
c0007d6b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007d6e:	89 d0                	mov    %edx,%eax
c0007d70:	01 c0                	add    %eax,%eax
c0007d72:	01 d0                	add    %edx,%eax
c0007d74:	c1 e0 02             	shl    $0x2,%eax
c0007d77:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c0007d7c:	89 08                	mov    %ecx,(%eax)
c0007d7e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007d81:	89 d0                	mov    %edx,%eax
c0007d83:	01 c0                	add    %eax,%eax
c0007d85:	01 d0                	add    %edx,%eax
c0007d87:	c1 e0 02             	shl    $0x2,%eax
c0007d8a:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c0007d8f:	8b 00                	mov    (%eax),%eax
c0007d91:	85 c0                	test   %eax,%eax
c0007d93:	75 3a                	jne    c0007dcf <sys_close+0xba>
/work/x86_os_my/fs/fs.c:427
				mfree_page(PF_KERNEL, file_table[global_fd].fd_inode, 1);
c0007d95:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007d98:	89 d0                	mov    %edx,%eax
c0007d9a:	01 c0                	add    %eax,%eax
c0007d9c:	01 d0                	add    %edx,%eax
c0007d9e:	c1 e0 02             	shl    $0x2,%eax
c0007da1:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c0007da6:	8b 00                	mov    (%eax),%eax
c0007da8:	83 ec 04             	sub    $0x4,%esp
c0007dab:	6a 01                	push   $0x1
c0007dad:	50                   	push   %eax
c0007dae:	6a 01                	push   $0x1
c0007db0:	e8 c3 b5 ff ff       	call   c0003378 <mfree_page>
c0007db5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:428
				file_table[global_fd].fd_inode = NULL;
c0007db8:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007dbb:	89 d0                	mov    %edx,%eax
c0007dbd:	01 c0                	add    %eax,%eax
c0007dbf:	01 d0                	add    %edx,%eax
c0007dc1:	c1 e0 02             	shl    $0x2,%eax
c0007dc4:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c0007dc9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:430
			}
			ret = 0;
c0007dcf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0007dd6:	eb 20                	jmp    c0007df8 <sys_close+0xe3>
/work/x86_os_my/fs/fs.c:432
		} else {
			ret = file_close(&file_table[global_fd]);
c0007dd8:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007ddb:	89 d0                	mov    %edx,%eax
c0007ddd:	01 c0                	add    %eax,%eax
c0007ddf:	01 d0                	add    %edx,%eax
c0007de1:	c1 e0 02             	shl    $0x2,%eax
c0007de4:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c0007de9:	83 ec 0c             	sub    $0xc,%esp
c0007dec:	50                   	push   %eax
c0007ded:	e8 75 21 00 00       	call   c0009f67 <file_close>
c0007df2:	83 c4 10             	add    $0x10,%esp
c0007df5:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:434
		}
		running_thread()->fd_table[fd] = -1; // 使该文件描述符位可用
c0007df8:	e8 4f c0 ff ff       	call   c0003e4c <running_thread>
c0007dfd:	89 c2                	mov    %eax,%edx
c0007dff:	8b 45 08             	mov    0x8(%ebp),%eax
c0007e02:	83 c0 08             	add    $0x8,%eax
c0007e05:	c7 44 82 04 ff ff ff 	movl   $0xffffffff,0x4(%edx,%eax,4)
c0007e0c:	ff 
/work/x86_os_my/fs/fs.c:436
	}
	return ret;
c0007e0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:437
}
c0007e10:	c9                   	leave  
c0007e11:	c3                   	ret    

c0007e12 <sys_write>:
sys_write():
/work/x86_os_my/fs/fs.c:440

/* 将buf中连续count个字节写入文件描述符fd,成功则返回写入的字节数,失败返回-1 */
int32_t sys_write(int32_t fd, const void* buf, uint32_t count) {
c0007e12:	55                   	push   %ebp
c0007e13:	89 e5                	mov    %esp,%ebp
c0007e15:	57                   	push   %edi
c0007e16:	81 ec 14 04 00 00    	sub    $0x414,%esp
/work/x86_os_my/fs/fs.c:441
	if (fd < 0) {
c0007e1c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0007e20:	79 1a                	jns    c0007e3c <sys_write+0x2a>
/work/x86_os_my/fs/fs.c:442
	printk("sys_write: fd error\n");
c0007e22:	83 ec 0c             	sub    $0xc,%esp
c0007e25:	68 48 ee 00 c0       	push   $0xc000ee48
c0007e2a:	e8 1e f2 ff ff       	call   c000704d <printk>
c0007e2f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:443
	return -1;
c0007e32:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007e37:	e9 12 01 00 00       	jmp    c0007f4e <sys_write+0x13c>
/work/x86_os_my/fs/fs.c:445
	}
	if (fd == stdout_no) {
c0007e3c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0007e40:	75 72                	jne    c0007eb4 <sys_write+0xa2>
/work/x86_os_my/fs/fs.c:447
		/* 标准输出有可能被重定向为管道缓冲区, 因此要判断 */
		if (is_pipe(fd)) {
c0007e42:	8b 45 08             	mov    0x8(%ebp),%eax
c0007e45:	83 ec 0c             	sub    $0xc,%esp
c0007e48:	50                   	push   %eax
c0007e49:	e8 cb 57 00 00       	call   c000d619 <is_pipe>
c0007e4e:	83 c4 10             	add    $0x10,%esp
c0007e51:	85 c0                	test   %eax,%eax
c0007e53:	74 19                	je     c0007e6e <sys_write+0x5c>
/work/x86_os_my/fs/fs.c:448
			return pipe_write(fd, buf, count);
c0007e55:	83 ec 04             	sub    $0x4,%esp
c0007e58:	ff 75 10             	pushl  0x10(%ebp)
c0007e5b:	ff 75 0c             	pushl  0xc(%ebp)
c0007e5e:	ff 75 08             	pushl  0x8(%ebp)
c0007e61:	e8 40 59 00 00       	call   c000d7a6 <pipe_write>
c0007e66:	83 c4 10             	add    $0x10,%esp
c0007e69:	e9 e0 00 00 00       	jmp    c0007f4e <sys_write+0x13c>
/work/x86_os_my/fs/fs.c:451
		} else {
			/* 没有被重定向的处理 */
			char tmp_buf[1024] = {0};
c0007e6e:	8d 95 ec fb ff ff    	lea    -0x414(%ebp),%edx
c0007e74:	b8 00 00 00 00       	mov    $0x0,%eax
c0007e79:	b9 00 01 00 00       	mov    $0x100,%ecx
c0007e7e:	89 d7                	mov    %edx,%edi
c0007e80:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/fs/fs.c:452
			memcpy(tmp_buf, buf, count);
c0007e82:	83 ec 04             	sub    $0x4,%esp
c0007e85:	ff 75 10             	pushl  0x10(%ebp)
c0007e88:	ff 75 0c             	pushl  0xc(%ebp)
c0007e8b:	8d 85 ec fb ff ff    	lea    -0x414(%ebp),%eax
c0007e91:	50                   	push   %eax
c0007e92:	e8 20 bc ff ff       	call   c0003ab7 <memcpy>
c0007e97:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:453
			console_put_str(tmp_buf);
c0007e9a:	83 ec 0c             	sub    $0xc,%esp
c0007e9d:	8d 85 ec fb ff ff    	lea    -0x414(%ebp),%eax
c0007ea3:	50                   	push   %eax
c0007ea4:	e8 e7 cd ff ff       	call   c0004c90 <console_put_str>
c0007ea9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:454
			return count;
c0007eac:	8b 45 10             	mov    0x10(%ebp),%eax
c0007eaf:	e9 9a 00 00 00       	jmp    c0007f4e <sys_write+0x13c>
/work/x86_os_my/fs/fs.c:456
		}
	} else if (is_pipe(fd)){	/* 若是管道就调用管道的方法 */
c0007eb4:	8b 45 08             	mov    0x8(%ebp),%eax
c0007eb7:	83 ec 0c             	sub    $0xc,%esp
c0007eba:	50                   	push   %eax
c0007ebb:	e8 59 57 00 00       	call   c000d619 <is_pipe>
c0007ec0:	83 c4 10             	add    $0x10,%esp
c0007ec3:	85 c0                	test   %eax,%eax
c0007ec5:	74 16                	je     c0007edd <sys_write+0xcb>
/work/x86_os_my/fs/fs.c:457
		return pipe_write(fd, buf, count);
c0007ec7:	83 ec 04             	sub    $0x4,%esp
c0007eca:	ff 75 10             	pushl  0x10(%ebp)
c0007ecd:	ff 75 0c             	pushl  0xc(%ebp)
c0007ed0:	ff 75 08             	pushl  0x8(%ebp)
c0007ed3:	e8 ce 58 00 00       	call   c000d7a6 <pipe_write>
c0007ed8:	83 c4 10             	add    $0x10,%esp
c0007edb:	eb 71                	jmp    c0007f4e <sys_write+0x13c>
/work/x86_os_my/fs/fs.c:460
	} else {
		/* 普通文件的处理 */
		uint32_t _fd = fd_local2global(fd);
c0007edd:	8b 45 08             	mov    0x8(%ebp),%eax
c0007ee0:	83 ec 0c             	sub    $0xc,%esp
c0007ee3:	50                   	push   %eax
c0007ee4:	e8 e1 fd ff ff       	call   c0007cca <fd_local2global>
c0007ee9:	83 c4 10             	add    $0x10,%esp
c0007eec:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:461
		struct file* wr_file = &file_table[_fd];
c0007eef:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0007ef2:	89 d0                	mov    %edx,%eax
c0007ef4:	01 c0                	add    %eax,%eax
c0007ef6:	01 d0                	add    %edx,%eax
c0007ef8:	c1 e0 02             	shl    $0x2,%eax
c0007efb:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c0007f00:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:462
		if (wr_file->fd_flag & O_WRONLY || wr_file->fd_flag & O_RDWR) {
c0007f03:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0007f06:	8b 40 04             	mov    0x4(%eax),%eax
c0007f09:	83 e0 01             	and    $0x1,%eax
c0007f0c:	85 c0                	test   %eax,%eax
c0007f0e:	75 0d                	jne    c0007f1d <sys_write+0x10b>
/work/x86_os_my/fs/fs.c:462 (discriminator 1)
c0007f10:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0007f13:	8b 40 04             	mov    0x4(%eax),%eax
c0007f16:	83 e0 02             	and    $0x2,%eax
c0007f19:	85 c0                	test   %eax,%eax
c0007f1b:	74 1c                	je     c0007f39 <sys_write+0x127>
/work/x86_os_my/fs/fs.c:463
			uint32_t bytes_written  = file_write(wr_file, buf, count);
c0007f1d:	83 ec 04             	sub    $0x4,%esp
c0007f20:	ff 75 10             	pushl  0x10(%ebp)
c0007f23:	ff 75 0c             	pushl  0xc(%ebp)
c0007f26:	ff 75 f0             	pushl  -0x10(%ebp)
c0007f29:	e8 7c 20 00 00       	call   c0009faa <file_write>
c0007f2e:	83 c4 10             	add    $0x10,%esp
c0007f31:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:464
			return bytes_written;
c0007f34:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0007f37:	eb 15                	jmp    c0007f4e <sys_write+0x13c>
/work/x86_os_my/fs/fs.c:466
		} else {
			console_put_str("sys_write: not allowed to write file without flag O_RDWR or O_WRONLY\n");
c0007f39:	83 ec 0c             	sub    $0xc,%esp
c0007f3c:	68 60 ee 00 c0       	push   $0xc000ee60
c0007f41:	e8 4a cd ff ff       	call   c0004c90 <console_put_str>
c0007f46:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:467
			return -1;
c0007f49:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/fs/fs.c:470 (discriminator 1)
		}
	}
}
c0007f4e:	8b 7d fc             	mov    -0x4(%ebp),%edi
c0007f51:	c9                   	leave  
c0007f52:	c3                   	ret    

c0007f53 <sys_read>:
sys_read():
/work/x86_os_my/fs/fs.c:473

/* 从文件描述符fd指向的文件中读取count个字节到buf,若成功则返回读出的字节数,到文件尾则返回-1 */
int32_t sys_read(int32_t fd, void* buf, uint32_t count) {
c0007f53:	55                   	push   %ebp
c0007f54:	89 e5                	mov    %esp,%ebp
c0007f56:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/fs.c:474
	ASSERT(buf != NULL);
c0007f59:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0007f5d:	75 1c                	jne    c0007f7b <sys_read+0x28>
/work/x86_os_my/fs/fs.c:474 (discriminator 1)
c0007f5f:	68 a6 ee 00 c0       	push   $0xc000eea6
c0007f64:	68 9c f4 00 c0       	push   $0xc000f49c
c0007f69:	68 da 01 00 00       	push   $0x1da
c0007f6e:	68 41 eb 00 c0       	push   $0xc000eb41
c0007f73:	e8 e9 a5 ff ff       	call   c0002561 <panic_spin>
c0007f78:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:475
	int32_t ret = -1;
c0007f7b:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:476
	uint32_t global_fd = 0;
c0007f82:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:477
	if (fd < 0 || fd == stdout_no || fd == stderr_no) {
c0007f89:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0007f8d:	78 0c                	js     c0007f9b <sys_read+0x48>
/work/x86_os_my/fs/fs.c:477 (discriminator 1)
c0007f8f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0007f93:	74 06                	je     c0007f9b <sys_read+0x48>
/work/x86_os_my/fs/fs.c:477 (discriminator 2)
c0007f95:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0007f99:	75 15                	jne    c0007fb0 <sys_read+0x5d>
/work/x86_os_my/fs/fs.c:478
		printk("sys_read: fd error\n");
c0007f9b:	83 ec 0c             	sub    $0xc,%esp
c0007f9e:	68 b2 ee 00 c0       	push   $0xc000eeb2
c0007fa3:	e8 a5 f0 ff ff       	call   c000704d <printk>
c0007fa8:	83 c4 10             	add    $0x10,%esp
c0007fab:	e9 e4 00 00 00       	jmp    c0008094 <sys_read+0x141>
/work/x86_os_my/fs/fs.c:479
	} else if (fd == stdin_no) {
c0007fb0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0007fb4:	75 7a                	jne    c0008030 <sys_read+0xdd>
/work/x86_os_my/fs/fs.c:481
		/* 标准输入有可能被重定向为管道缓冲区, 因此要判断 */
		if (is_pipe(fd)) {
c0007fb6:	8b 45 08             	mov    0x8(%ebp),%eax
c0007fb9:	83 ec 0c             	sub    $0xc,%esp
c0007fbc:	50                   	push   %eax
c0007fbd:	e8 57 56 00 00       	call   c000d619 <is_pipe>
c0007fc2:	83 c4 10             	add    $0x10,%esp
c0007fc5:	85 c0                	test   %eax,%eax
c0007fc7:	74 1c                	je     c0007fe5 <sys_read+0x92>
/work/x86_os_my/fs/fs.c:482
			ret = pipe_read(fd, buf, count);
c0007fc9:	83 ec 04             	sub    $0x4,%esp
c0007fcc:	ff 75 10             	pushl  0x10(%ebp)
c0007fcf:	ff 75 0c             	pushl  0xc(%ebp)
c0007fd2:	ff 75 08             	pushl  0x8(%ebp)
c0007fd5:	e8 47 57 00 00       	call   c000d721 <pipe_read>
c0007fda:	83 c4 10             	add    $0x10,%esp
c0007fdd:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0007fe0:	e9 af 00 00 00       	jmp    c0008094 <sys_read+0x141>
/work/x86_os_my/fs/fs.c:485
		} else {
			/* 没有被重定向的处理 */
			char* buffer = buf;
c0007fe5:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007fe8:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:486
			uint32_t bytes_read = 0;
c0007feb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:487
			while (bytes_read < count) {
c0007ff2:	eb 1f                	jmp    c0008013 <sys_read+0xc0>
/work/x86_os_my/fs/fs.c:488
				*buffer = ioq_getchar(&kbd_buf);
c0007ff4:	83 ec 0c             	sub    $0xc,%esp
c0007ff7:	68 e0 42 01 c0       	push   $0xc00142e0
c0007ffc:	e8 9e d4 ff ff       	call   c000549f <ioq_getchar>
c0008001:	83 c4 10             	add    $0x10,%esp
c0008004:	89 c2                	mov    %eax,%edx
c0008006:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0008009:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/fs/fs.c:489
				bytes_read++;
c000800b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:490
				buffer++;
c000800f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:487
			ret = pipe_read(fd, buf, count);
		} else {
			/* 没有被重定向的处理 */
			char* buffer = buf;
			uint32_t bytes_read = 0;
			while (bytes_read < count) {
c0008013:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008016:	3b 45 10             	cmp    0x10(%ebp),%eax
c0008019:	72 d9                	jb     c0007ff4 <sys_read+0xa1>
/work/x86_os_my/fs/fs.c:492
				*buffer = ioq_getchar(&kbd_buf);
				bytes_read++;
				buffer++;
			}
			ret = (bytes_read == 0 ? -1 : (int32_t)bytes_read);
c000801b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c000801f:	74 05                	je     c0008026 <sys_read+0xd3>
/work/x86_os_my/fs/fs.c:492 (discriminator 1)
c0008021:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008024:	eb 05                	jmp    c000802b <sys_read+0xd8>
/work/x86_os_my/fs/fs.c:492 (discriminator 2)
c0008026:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/fs/fs.c:492 (discriminator 4)
c000802b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c000802e:	eb 64                	jmp    c0008094 <sys_read+0x141>
/work/x86_os_my/fs/fs.c:494
		}
	} else if (is_pipe(fd)) {	/* 若是管道就调用管道的方法 */
c0008030:	8b 45 08             	mov    0x8(%ebp),%eax
c0008033:	83 ec 0c             	sub    $0xc,%esp
c0008036:	50                   	push   %eax
c0008037:	e8 dd 55 00 00       	call   c000d619 <is_pipe>
c000803c:	83 c4 10             	add    $0x10,%esp
c000803f:	85 c0                	test   %eax,%eax
c0008041:	74 19                	je     c000805c <sys_read+0x109>
/work/x86_os_my/fs/fs.c:495
		ret = pipe_read(fd, buf, count);
c0008043:	83 ec 04             	sub    $0x4,%esp
c0008046:	ff 75 10             	pushl  0x10(%ebp)
c0008049:	ff 75 0c             	pushl  0xc(%ebp)
c000804c:	ff 75 08             	pushl  0x8(%ebp)
c000804f:	e8 cd 56 00 00       	call   c000d721 <pipe_read>
c0008054:	83 c4 10             	add    $0x10,%esp
c0008057:	89 45 f4             	mov    %eax,-0xc(%ebp)
c000805a:	eb 38                	jmp    c0008094 <sys_read+0x141>
/work/x86_os_my/fs/fs.c:498
	} else {
		/* 普通文件的处理 */
		global_fd = fd_local2global(fd);
c000805c:	8b 45 08             	mov    0x8(%ebp),%eax
c000805f:	83 ec 0c             	sub    $0xc,%esp
c0008062:	50                   	push   %eax
c0008063:	e8 62 fc ff ff       	call   c0007cca <fd_local2global>
c0008068:	83 c4 10             	add    $0x10,%esp
c000806b:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:499
		ret = file_read(&file_table[global_fd], buf, count);
c000806e:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0008071:	89 d0                	mov    %edx,%eax
c0008073:	01 c0                	add    %eax,%eax
c0008075:	01 d0                	add    %edx,%eax
c0008077:	c1 e0 02             	shl    $0x2,%eax
c000807a:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c000807f:	83 ec 04             	sub    $0x4,%esp
c0008082:	ff 75 10             	pushl  0x10(%ebp)
c0008085:	ff 75 0c             	pushl  0xc(%ebp)
c0008088:	50                   	push   %eax
c0008089:	e8 b0 26 00 00       	call   c000a73e <file_read>
c000808e:	83 c4 10             	add    $0x10,%esp
c0008091:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:501
	}
	return ret;
c0008094:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:502
}
c0008097:	c9                   	leave  
c0008098:	c3                   	ret    

c0008099 <sys_lseek>:
sys_lseek():
/work/x86_os_my/fs/fs.c:506


/* 重置用于文件读写指针,成功时返回新的偏移量,出错时返回-1 */
int32_t sys_lseek(int32_t fd, int32_t offset, uint8_t whence) {
c0008099:	55                   	push   %ebp
c000809a:	89 e5                	mov    %esp,%ebp
c000809c:	83 ec 28             	sub    $0x28,%esp
c000809f:	8b 45 10             	mov    0x10(%ebp),%eax
c00080a2:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/fs/fs.c:507
	if (fd < 0) {
c00080a5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00080a9:	79 1a                	jns    c00080c5 <sys_lseek+0x2c>
/work/x86_os_my/fs/fs.c:508
		printk("sys_lseek: fd error\n");
c00080ab:	83 ec 0c             	sub    $0xc,%esp
c00080ae:	68 c6 ee 00 c0       	push   $0xc000eec6
c00080b3:	e8 95 ef ff ff       	call   c000704d <printk>
c00080b8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:509
		return -1;
c00080bb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00080c0:	e9 bd 00 00 00       	jmp    c0008182 <sys_lseek+0xe9>
/work/x86_os_my/fs/fs.c:511
	}
	ASSERT(whence > 0 && whence < 4);
c00080c5:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c00080c9:	74 06                	je     c00080d1 <sys_lseek+0x38>
/work/x86_os_my/fs/fs.c:511 (discriminator 1)
c00080cb:	80 7d e4 03          	cmpb   $0x3,-0x1c(%ebp)
c00080cf:	76 1c                	jbe    c00080ed <sys_lseek+0x54>
/work/x86_os_my/fs/fs.c:511 (discriminator 3)
c00080d1:	68 db ee 00 c0       	push   $0xc000eedb
c00080d6:	68 a8 f4 00 c0       	push   $0xc000f4a8
c00080db:	68 ff 01 00 00       	push   $0x1ff
c00080e0:	68 41 eb 00 c0       	push   $0xc000eb41
c00080e5:	e8 77 a4 ff ff       	call   c0002561 <panic_spin>
c00080ea:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:512
	uint32_t _fd = fd_local2global(fd);
c00080ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00080f0:	83 ec 0c             	sub    $0xc,%esp
c00080f3:	50                   	push   %eax
c00080f4:	e8 d1 fb ff ff       	call   c0007cca <fd_local2global>
c00080f9:	83 c4 10             	add    $0x10,%esp
c00080fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:513
	struct file* pf = &file_table[_fd];
c00080ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008102:	89 d0                	mov    %edx,%eax
c0008104:	01 c0                	add    %eax,%eax
c0008106:	01 d0                	add    %edx,%eax
c0008108:	c1 e0 02             	shl    $0x2,%eax
c000810b:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c0008110:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:514
	int32_t new_pos = 0;	//新的偏移量必须位于文件大小之内
c0008113:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:515
	int32_t file_size = (int32_t)pf->fd_inode->i_size;
c000811a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000811d:	8b 40 08             	mov    0x8(%eax),%eax
c0008120:	8b 40 04             	mov    0x4(%eax),%eax
c0008123:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:516
	switch (whence) {
c0008126:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c000812a:	83 f8 02             	cmp    $0x2,%eax
c000812d:	74 12                	je     c0008141 <sys_lseek+0xa8>
c000812f:	83 f8 03             	cmp    $0x3,%eax
c0008132:	74 1e                	je     c0008152 <sys_lseek+0xb9>
c0008134:	83 f8 01             	cmp    $0x1,%eax
c0008137:	75 24                	jne    c000815d <sys_lseek+0xc4>
/work/x86_os_my/fs/fs.c:519
		/* SEEK_SET 新的读写位置是相对于文件开头再增加offset个位移量 */
		case SEEK_SET:
		new_pos = offset;
c0008139:	8b 45 0c             	mov    0xc(%ebp),%eax
c000813c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:520
		break;
c000813f:	eb 1c                	jmp    c000815d <sys_lseek+0xc4>
/work/x86_os_my/fs/fs.c:524

		/* SEEK_CUR 新的读写位置是相对于当前的位置增加offset个位移量 */
		case SEEK_CUR:	// offse可正可负
		new_pos = (int32_t)pf->fd_pos + offset;
c0008141:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008144:	8b 00                	mov    (%eax),%eax
c0008146:	89 c2                	mov    %eax,%edx
c0008148:	8b 45 0c             	mov    0xc(%ebp),%eax
c000814b:	01 d0                	add    %edx,%eax
c000814d:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:525
		break;
c0008150:	eb 0b                	jmp    c000815d <sys_lseek+0xc4>
/work/x86_os_my/fs/fs.c:529

		/* SEEK_END 新的读写位置是相对于文件尺寸再增加offset个位移量 */
		case SEEK_END:	// 此情况下,offset应该为负值
		new_pos = file_size + offset;
c0008152:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0008155:	8b 45 0c             	mov    0xc(%ebp),%eax
c0008158:	01 d0                	add    %edx,%eax
c000815a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:531
	}
	if (new_pos < 0 || new_pos > (file_size - 1)) {
c000815d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0008161:	78 0b                	js     c000816e <sys_lseek+0xd5>
/work/x86_os_my/fs/fs.c:531 (discriminator 1)
c0008163:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0008166:	83 e8 01             	sub    $0x1,%eax
c0008169:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c000816c:	7d 07                	jge    c0008175 <sys_lseek+0xdc>
/work/x86_os_my/fs/fs.c:532
		return -1;
c000816e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0008173:	eb 0d                	jmp    c0008182 <sys_lseek+0xe9>
/work/x86_os_my/fs/fs.c:534
	}
	pf->fd_pos = new_pos;
c0008175:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0008178:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000817b:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/fs.c:535
	return pf->fd_pos;
c000817d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008180:	8b 00                	mov    (%eax),%eax
/work/x86_os_my/fs/fs.c:536
}
c0008182:	c9                   	leave  
c0008183:	c3                   	ret    

c0008184 <sys_unlink>:
sys_unlink():
/work/x86_os_my/fs/fs.c:540

/* 删除文件(非目录),成功返回0,失败返回-1 */
// 全局变量 file_table 定义在 file.h
int32_t sys_unlink(const char* pathname) {
c0008184:	55                   	push   %ebp
c0008185:	89 e5                	mov    %esp,%ebp
c0008187:	81 ec 28 02 00 00    	sub    $0x228,%esp
/work/x86_os_my/fs/fs.c:541
	ASSERT(strlen(pathname) < MAX_PATH_LEN);
c000818d:	83 ec 0c             	sub    $0xc,%esp
c0008190:	ff 75 08             	pushl  0x8(%ebp)
c0008193:	e8 57 ba ff ff       	call   c0003bef <strlen>
c0008198:	83 c4 10             	add    $0x10,%esp
c000819b:	3d ff 01 00 00       	cmp    $0x1ff,%eax
c00081a0:	76 1c                	jbe    c00081be <sys_unlink+0x3a>
/work/x86_os_my/fs/fs.c:541 (discriminator 1)
c00081a2:	68 f4 ee 00 c0       	push   $0xc000eef4
c00081a7:	68 b4 f4 00 c0       	push   $0xc000f4b4
c00081ac:	68 1d 02 00 00       	push   $0x21d
c00081b1:	68 41 eb 00 c0       	push   $0xc000eb41
c00081b6:	e8 a6 a3 ff ff       	call   c0002561 <panic_spin>
c00081bb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:545

	/* 先检查待删除的文件是否存在 */
	struct path_search_record searched_record;
	memset(&searched_record, 0, sizeof(struct path_search_record));
c00081be:	83 ec 04             	sub    $0x4,%esp
c00081c1:	68 08 02 00 00       	push   $0x208
c00081c6:	6a 00                	push   $0x0
c00081c8:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
c00081ce:	50                   	push   %eax
c00081cf:	e8 91 b8 ff ff       	call   c0003a65 <memset>
c00081d4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:546
	int inode_no = search_file(pathname, &searched_record);
c00081d7:	83 ec 08             	sub    $0x8,%esp
c00081da:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
c00081e0:	50                   	push   %eax
c00081e1:	ff 75 08             	pushl  0x8(%ebp)
c00081e4:	e8 00 f6 ff ff       	call   c00077e9 <search_file>
c00081e9:	83 c4 10             	add    $0x10,%esp
c00081ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:547
	ASSERT(inode_no != 0);
c00081ef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00081f3:	75 1c                	jne    c0008211 <sys_unlink+0x8d>
/work/x86_os_my/fs/fs.c:547 (discriminator 1)
c00081f5:	68 14 ef 00 c0       	push   $0xc000ef14
c00081fa:	68 b4 f4 00 c0       	push   $0xc000f4b4
c00081ff:	68 23 02 00 00       	push   $0x223
c0008204:	68 41 eb 00 c0       	push   $0xc000eb41
c0008209:	e8 53 a3 ff ff       	call   c0002561 <panic_spin>
c000820e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:548
	if (inode_no == -1) {
c0008211:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0008215:	75 2c                	jne    c0008243 <sys_unlink+0xbf>
/work/x86_os_my/fs/fs.c:549
		printk("file %s not found!\n", pathname);
c0008217:	83 ec 08             	sub    $0x8,%esp
c000821a:	ff 75 08             	pushl  0x8(%ebp)
c000821d:	68 22 ef 00 c0       	push   $0xc000ef22
c0008222:	e8 26 ee ff ff       	call   c000704d <printk>
c0008227:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:550
		dir_close(searched_record.parent_dir);
c000822a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000822d:	83 ec 0c             	sub    $0xc,%esp
c0008230:	50                   	push   %eax
c0008231:	e8 f9 2a 00 00       	call   c000ad2f <dir_close>
c0008236:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:551
		return -1;
c0008239:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000823e:	e9 62 01 00 00       	jmp    c00083a5 <sys_unlink+0x221>
/work/x86_os_my/fs/fs.c:553
	}
	if (searched_record.file_type == FT_DIRECTORY) {	//存在同名的目录，而不是文件
c0008243:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0008246:	83 f8 02             	cmp    $0x2,%eax
c0008249:	75 29                	jne    c0008274 <sys_unlink+0xf0>
/work/x86_os_my/fs/fs.c:554
		printk("can`t delete a direcotry with unlink(), use rmdir() to instead\n");
c000824b:	83 ec 0c             	sub    $0xc,%esp
c000824e:	68 38 ef 00 c0       	push   $0xc000ef38
c0008253:	e8 f5 ed ff ff       	call   c000704d <printk>
c0008258:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:555
		dir_close(searched_record.parent_dir);
c000825b:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000825e:	83 ec 0c             	sub    $0xc,%esp
c0008261:	50                   	push   %eax
c0008262:	e8 c8 2a 00 00       	call   c000ad2f <dir_close>
c0008267:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:556
		return -1;
c000826a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000826f:	e9 31 01 00 00       	jmp    c00083a5 <sys_unlink+0x221>
/work/x86_os_my/fs/fs.c:560
	}

	/* 检查是否在已打开文件列表(文件表)中 */
	uint32_t file_idx = 0;
c0008274:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:561
	while (file_idx < MAX_FILE_OPEN) {
c000827b:	eb 37                	jmp    c00082b4 <sys_unlink+0x130>
/work/x86_os_my/fs/fs.c:562
		if (file_table[file_idx].fd_inode != NULL && (uint32_t)inode_no == file_table[file_idx].fd_inode->i_no) {
c000827d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0008280:	89 d0                	mov    %edx,%eax
c0008282:	01 c0                	add    %eax,%eax
c0008284:	01 d0                	add    %edx,%eax
c0008286:	c1 e0 02             	shl    $0x2,%eax
c0008289:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c000828e:	8b 00                	mov    (%eax),%eax
c0008290:	85 c0                	test   %eax,%eax
c0008292:	74 1c                	je     c00082b0 <sys_unlink+0x12c>
/work/x86_os_my/fs/fs.c:562 (discriminator 1)
c0008294:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0008297:	89 d0                	mov    %edx,%eax
c0008299:	01 c0                	add    %eax,%eax
c000829b:	01 d0                	add    %edx,%eax
c000829d:	c1 e0 02             	shl    $0x2,%eax
c00082a0:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c00082a5:	8b 00                	mov    (%eax),%eax
c00082a7:	8b 10                	mov    (%eax),%edx
c00082a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00082ac:	39 c2                	cmp    %eax,%edx
c00082ae:	74 0c                	je     c00082bc <sys_unlink+0x138>
/work/x86_os_my/fs/fs.c:565
			break;
		}
		file_idx++;
c00082b0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:561
		return -1;
	}

	/* 检查是否在已打开文件列表(文件表)中 */
	uint32_t file_idx = 0;
	while (file_idx < MAX_FILE_OPEN) {
c00082b4:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
c00082b8:	76 c3                	jbe    c000827d <sys_unlink+0xf9>
c00082ba:	eb 01                	jmp    c00082bd <sys_unlink+0x139>
/work/x86_os_my/fs/fs.c:563
		if (file_table[file_idx].fd_inode != NULL && (uint32_t)inode_no == file_table[file_idx].fd_inode->i_no) {
			break;
c00082bc:	90                   	nop
/work/x86_os_my/fs/fs.c:567
		}
		file_idx++;
	}
	if (file_idx < MAX_FILE_OPEN) {
c00082bd:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
c00082c1:	77 2c                	ja     c00082ef <sys_unlink+0x16b>
/work/x86_os_my/fs/fs.c:568
		dir_close(searched_record.parent_dir);
c00082c3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00082c6:	83 ec 0c             	sub    $0xc,%esp
c00082c9:	50                   	push   %eax
c00082ca:	e8 60 2a 00 00       	call   c000ad2f <dir_close>
c00082cf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:569
		printk("file %s is in use, not allow to delete!\n", pathname);
c00082d2:	83 ec 08             	sub    $0x8,%esp
c00082d5:	ff 75 08             	pushl  0x8(%ebp)
c00082d8:	68 78 ef 00 c0       	push   $0xc000ef78
c00082dd:	e8 6b ed ff ff       	call   c000704d <printk>
c00082e2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:570
		return -1;
c00082e5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00082ea:	e9 b6 00 00 00       	jmp    c00083a5 <sys_unlink+0x221>
/work/x86_os_my/fs/fs.c:572
	}
	ASSERT(file_idx == MAX_FILE_OPEN);
c00082ef:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
c00082f3:	74 1c                	je     c0008311 <sys_unlink+0x18d>
/work/x86_os_my/fs/fs.c:572 (discriminator 1)
c00082f5:	68 a1 ef 00 c0       	push   $0xc000efa1
c00082fa:	68 b4 f4 00 c0       	push   $0xc000f4b4
c00082ff:	68 3c 02 00 00       	push   $0x23c
c0008304:	68 41 eb 00 c0       	push   $0xc000eb41
c0008309:	e8 53 a2 ff ff       	call   c0002561 <panic_spin>
c000830e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:575

	/* 为delete_dir_entry申请缓冲区 */
	void* io_buf = sys_malloc(SECTOR_SIZE + SECTOR_SIZE);
c0008311:	83 ec 0c             	sub    $0xc,%esp
c0008314:	68 00 04 00 00       	push   $0x400
c0008319:	e8 ee ab ff ff       	call   c0002f0c <sys_malloc>
c000831e:	83 c4 10             	add    $0x10,%esp
c0008321:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:576
	if (io_buf == NULL) {
c0008324:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0008328:	75 26                	jne    c0008350 <sys_unlink+0x1cc>
/work/x86_os_my/fs/fs.c:577
		dir_close(searched_record.parent_dir);
c000832a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000832d:	83 ec 0c             	sub    $0xc,%esp
c0008330:	50                   	push   %eax
c0008331:	e8 f9 29 00 00       	call   c000ad2f <dir_close>
c0008336:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:578
		printk("sys_unlink: malloc for io_buf failed\n");
c0008339:	83 ec 0c             	sub    $0xc,%esp
c000833c:	68 bc ef 00 c0       	push   $0xc000efbc
c0008341:	e8 07 ed ff ff       	call   c000704d <printk>
c0008346:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:579
		return -1;
c0008349:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000834e:	eb 55                	jmp    c00083a5 <sys_unlink+0x221>
/work/x86_os_my/fs/fs.c:582
	}

	struct dir* parent_dir = searched_record.parent_dir;
c0008350:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0008353:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:583
	delete_dir_entry(cur_part, parent_dir, inode_no, io_buf);	// 删除目录项 dir.c
c0008356:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008359:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000835e:	ff 75 ec             	pushl  -0x14(%ebp)
c0008361:	52                   	push   %edx
c0008362:	ff 75 e8             	pushl  -0x18(%ebp)
c0008365:	50                   	push   %eax
c0008366:	e8 83 2e 00 00       	call   c000b1ee <delete_dir_entry>
c000836b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:584
	inode_release(cur_part, inode_no);							// 删除inode inode.c
c000836e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008371:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0008376:	83 ec 08             	sub    $0x8,%esp
c0008379:	52                   	push   %edx
c000837a:	50                   	push   %eax
c000837b:	e8 9a 13 00 00       	call   c000971a <inode_release>
c0008380:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:585
	sys_free(io_buf);
c0008383:	83 ec 0c             	sub    $0xc,%esp
c0008386:	ff 75 ec             	pushl  -0x14(%ebp)
c0008389:	e8 ab b1 ff ff       	call   c0003539 <sys_free>
c000838e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:586
	dir_close(searched_record.parent_dir);
c0008391:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0008394:	83 ec 0c             	sub    $0xc,%esp
c0008397:	50                   	push   %eax
c0008398:	e8 92 29 00 00       	call   c000ad2f <dir_close>
c000839d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:587
	return 0;	// 成功删除文件
c00083a0:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/fs.c:588 (discriminator 1)
}
c00083a5:	c9                   	leave  
c00083a6:	c3                   	ret    

c00083a7 <sys_mkdir>:
sys_mkdir():
/work/x86_os_my/fs/fs.c:599
（3）为新目录分配 1 个块存储该目录中的目录项。
（4）在新目录中创建两个目录项“.”和“..”，这是每个目录都必须存在的两个目录项。
（5）在新目录的父目录中添加新目录的目录项。
（6）将以上资源的变更同步到硬盘。
 */
int32_t sys_mkdir(const char* pathname) {
c00083a7:	55                   	push   %ebp
c00083a8:	89 e5                	mov    %esp,%ebp
c00083aa:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
/work/x86_os_my/fs/fs.c:600
	uint8_t rollback_step = 0;	       // 用于操作失败时回滚各资源状态
c00083b0:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:601
	void* io_buf = sys_malloc(SECTOR_SIZE * 2);
c00083b4:	83 ec 0c             	sub    $0xc,%esp
c00083b7:	68 00 04 00 00       	push   $0x400
c00083bc:	e8 4b ab ff ff       	call   c0002f0c <sys_malloc>
c00083c1:	83 c4 10             	add    $0x10,%esp
c00083c4:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:602
	if (io_buf == NULL) {
c00083c7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00083cb:	75 1a                	jne    c00083e7 <sys_mkdir+0x40>
/work/x86_os_my/fs/fs.c:603
		printk("sys_mkdir: sys_malloc for io_buf failed\n");
c00083cd:	83 ec 0c             	sub    $0xc,%esp
c00083d0:	68 e4 ef 00 c0       	push   $0xc000efe4
c00083d5:	e8 73 ec ff ff       	call   c000704d <printk>
c00083da:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:604
		return -1;
c00083dd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00083e2:	e9 ae 03 00 00       	jmp    c0008795 <sys_mkdir+0x3ee>
/work/x86_os_my/fs/fs.c:608
	}

	struct path_search_record searched_record;
	memset(&searched_record, 0, sizeof(struct path_search_record));
c00083e7:	83 ec 04             	sub    $0x4,%esp
c00083ea:	68 08 02 00 00       	push   $0x208
c00083ef:	6a 00                	push   $0x0
c00083f1:	8d 85 c8 fd ff ff    	lea    -0x238(%ebp),%eax
c00083f7:	50                   	push   %eax
c00083f8:	e8 68 b6 ff ff       	call   c0003a65 <memset>
c00083fd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:609
	int inode_no = -1;
c0008400:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:610
	inode_no = search_file(pathname, &searched_record);
c0008407:	83 ec 08             	sub    $0x8,%esp
c000840a:	8d 85 c8 fd ff ff    	lea    -0x238(%ebp),%eax
c0008410:	50                   	push   %eax
c0008411:	ff 75 08             	pushl  0x8(%ebp)
c0008414:	e8 d0 f3 ff ff       	call   c00077e9 <search_file>
c0008419:	83 c4 10             	add    $0x10,%esp
c000841c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:611
	if (inode_no != -1) {      // 如果找到了同名目录或文件,失败返回
c000841f:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0008423:	74 1c                	je     c0008441 <sys_mkdir+0x9a>
/work/x86_os_my/fs/fs.c:612
		printk("sys_mkdir: file or directory %s exist!\n", pathname);
c0008425:	83 ec 08             	sub    $0x8,%esp
c0008428:	ff 75 08             	pushl  0x8(%ebp)
c000842b:	68 10 f0 00 c0       	push   $0xc000f010
c0008430:	e8 18 ec ff ff       	call   c000704d <printk>
c0008435:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:613
		rollback_step = 1;
c0008438:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:614
		goto rollback;
c000843c:	e9 08 03 00 00       	jmp    c0008749 <sys_mkdir+0x3a2>
/work/x86_os_my/fs/fs.c:616
	} else {	     // 若未找到,也要判断是在最终目录没找到还是某个中间目录不存在
		uint32_t pathname_depth = path_depth_cnt((char*)pathname);
c0008441:	83 ec 0c             	sub    $0xc,%esp
c0008444:	ff 75 08             	pushl  0x8(%ebp)
c0008447:	e8 12 f3 ff ff       	call   c000775e <path_depth_cnt>
c000844c:	83 c4 10             	add    $0x10,%esp
c000844f:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:617
		uint32_t path_searched_depth = path_depth_cnt(searched_record.searched_path);
c0008452:	83 ec 0c             	sub    $0xc,%esp
c0008455:	8d 85 c8 fd ff ff    	lea    -0x238(%ebp),%eax
c000845b:	50                   	push   %eax
c000845c:	e8 fd f2 ff ff       	call   c000775e <path_depth_cnt>
c0008461:	83 c4 10             	add    $0x10,%esp
c0008464:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/fs.c:619
		/* 先判断是否把pathname的各层目录都访问到了,即是否在某个中间目录就失败了 */
		if (pathname_depth != path_searched_depth) {   // 说明并没有访问到全部的路径,某个中间目录是不存在的
c0008467:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000846a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c000846d:	74 23                	je     c0008492 <sys_mkdir+0xeb>
/work/x86_os_my/fs/fs.c:620
			printk("sys_mkdir: can`t access %s, subpath %s is`t exist\n", pathname, searched_record.searched_path);
c000846f:	83 ec 04             	sub    $0x4,%esp
c0008472:	8d 85 c8 fd ff ff    	lea    -0x238(%ebp),%eax
c0008478:	50                   	push   %eax
c0008479:	ff 75 08             	pushl  0x8(%ebp)
c000847c:	68 38 f0 00 c0       	push   $0xc000f038
c0008481:	e8 c7 eb ff ff       	call   c000704d <printk>
c0008486:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:621
			rollback_step = 1;
c0008489:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:622
			goto rollback;
c000848d:	e9 b7 02 00 00       	jmp    c0008749 <sys_mkdir+0x3a2>
/work/x86_os_my/fs/fs.c:626
		}
	}

	struct dir* parent_dir = searched_record.parent_dir;	//被创建目录所在的父目录
c0008492:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0008495:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/fs.c:628
	/* 目录名称后可能会有字符'/',所以最好直接用searched_record.searched_path,无'/' */
	char* dirname = strrchr(searched_record.searched_path, '/') + 1;	//获取 pathname 的最后一级目录名
c0008498:	83 ec 08             	sub    $0x8,%esp
c000849b:	6a 2f                	push   $0x2f
c000849d:	8d 85 c8 fd ff ff    	lea    -0x238(%ebp),%eax
c00084a3:	50                   	push   %eax
c00084a4:	e8 62 b8 ff ff       	call   c0003d0b <strrchr>
c00084a9:	83 c4 10             	add    $0x10,%esp
c00084ac:	83 c0 01             	add    $0x1,%eax
c00084af:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/fs.c:630

	inode_no = inode_bitmap_alloc(cur_part);
c00084b2:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c00084b7:	83 ec 0c             	sub    $0xc,%esp
c00084ba:	50                   	push   %eax
c00084bb:	e8 ab 15 00 00       	call   c0009a6b <inode_bitmap_alloc>
c00084c0:	83 c4 10             	add    $0x10,%esp
c00084c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:631
	if (inode_no == -1) {
c00084c6:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c00084ca:	75 19                	jne    c00084e5 <sys_mkdir+0x13e>
/work/x86_os_my/fs/fs.c:632
		printk("sys_mkdir: allocate inode failed\n");
c00084cc:	83 ec 0c             	sub    $0xc,%esp
c00084cf:	68 6c f0 00 c0       	push   $0xc000f06c
c00084d4:	e8 74 eb ff ff       	call   c000704d <printk>
c00084d9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:633
		rollback_step = 1;
c00084dc:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:634
		goto rollback;
c00084e0:	e9 64 02 00 00       	jmp    c0008749 <sys_mkdir+0x3a2>
/work/x86_os_my/fs/fs.c:638
	}

	struct inode new_dir_inode;
	inode_init(inode_no, &new_dir_inode);	    // 初始化i结点
c00084e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00084e8:	83 ec 08             	sub    $0x8,%esp
c00084eb:	8d 95 7c fd ff ff    	lea    -0x284(%ebp),%edx
c00084f1:	52                   	push   %edx
c00084f2:	50                   	push   %eax
c00084f3:	e8 5b 14 00 00       	call   c0009953 <inode_init>
c00084f8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:640

	uint32_t block_bitmap_idx = 0;     // 用来记录block对应于block_bitmap中的索引
c00084fb:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
/work/x86_os_my/fs/fs.c:641
	int32_t block_lba = -1;
c0008502:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
/work/x86_os_my/fs/fs.c:643
	/* 为目录分配一个块,用来写入目录.和.. */
	block_lba = block_bitmap_alloc(cur_part);
c0008509:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000850e:	83 ec 0c             	sub    $0xc,%esp
c0008511:	50                   	push   %eax
c0008512:	e8 9b 15 00 00       	call   c0009ab2 <block_bitmap_alloc>
c0008517:	83 c4 10             	add    $0x10,%esp
c000851a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/fs/fs.c:644
	if (block_lba == -1) {
c000851d:	83 7d d4 ff          	cmpl   $0xffffffff,-0x2c(%ebp)
c0008521:	75 19                	jne    c000853c <sys_mkdir+0x195>
/work/x86_os_my/fs/fs.c:645
		printk("sys_mkdir: block_bitmap_alloc for create directory failed\n");
c0008523:	83 ec 0c             	sub    $0xc,%esp
c0008526:	68 90 f0 00 c0       	push   $0xc000f090
c000852b:	e8 1d eb ff ff       	call   c000704d <printk>
c0008530:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:646
		rollback_step = 2;
c0008533:	c6 45 f7 02          	movb   $0x2,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:647
		goto rollback;
c0008537:	e9 0d 02 00 00       	jmp    c0008749 <sys_mkdir+0x3a2>
/work/x86_os_my/fs/fs.c:649
	}
	new_dir_inode.i_sectors[0] = block_lba;
c000853c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000853f:	89 85 8c fd ff ff    	mov    %eax,-0x274(%ebp)
/work/x86_os_my/fs/fs.c:651
	/* 每分配一个块就将位图同步到硬盘 */
	block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c0008545:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0008548:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000854d:	8b 40 1c             	mov    0x1c(%eax),%eax
c0008550:	8b 40 28             	mov    0x28(%eax),%eax
c0008553:	29 c2                	sub    %eax,%edx
c0008555:	89 d0                	mov    %edx,%eax
c0008557:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/fs.c:652
	ASSERT(block_bitmap_idx != 0);
c000855a:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c000855e:	75 1c                	jne    c000857c <sys_mkdir+0x1d5>
/work/x86_os_my/fs/fs.c:652 (discriminator 1)
c0008560:	68 cb f0 00 c0       	push   $0xc000f0cb
c0008565:	68 c0 f4 00 c0       	push   $0xc000f4c0
c000856a:	68 8c 02 00 00       	push   $0x28c
c000856f:	68 41 eb 00 c0       	push   $0xc000eb41
c0008574:	e8 e8 9f ff ff       	call   c0002561 <panic_spin>
c0008579:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:653
	bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c000857c:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0008581:	83 ec 04             	sub    $0x4,%esp
c0008584:	6a 01                	push   $0x1
c0008586:	ff 75 d8             	pushl  -0x28(%ebp)
c0008589:	50                   	push   %eax
c000858a:	e8 75 15 00 00       	call   c0009b04 <bitmap_sync>
c000858f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:656

	/* 将当前目录的目录项'.'和'..'写入目录 */
	memset(io_buf, 0, SECTOR_SIZE * 2);	 // 清空io_buf
c0008592:	83 ec 04             	sub    $0x4,%esp
c0008595:	68 00 04 00 00       	push   $0x400
c000859a:	6a 00                	push   $0x0
c000859c:	ff 75 ec             	pushl  -0x14(%ebp)
c000859f:	e8 c1 b4 ff ff       	call   c0003a65 <memset>
c00085a4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:657
	struct dir_entry* p_de = (struct dir_entry*)io_buf;
c00085a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00085aa:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/fs/fs.c:660

	/* 初始化当前目录"." */
	memcpy(p_de->filename, ".", 1);
c00085ad:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00085b0:	83 ec 04             	sub    $0x4,%esp
c00085b3:	6a 01                	push   $0x1
c00085b5:	68 7f ec 00 c0       	push   $0xc000ec7f
c00085ba:	50                   	push   %eax
c00085bb:	e8 f7 b4 ff ff       	call   c0003ab7 <memcpy>
c00085c0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:661
	p_de->i_no = inode_no ;
c00085c3:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00085c6:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00085c9:	89 50 10             	mov    %edx,0x10(%eax)
/work/x86_os_my/fs/fs.c:662
	p_de->f_type = FT_DIRECTORY;
c00085cc:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00085cf:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%eax)
/work/x86_os_my/fs/fs.c:664

	p_de++;
c00085d6:	83 45 d0 18          	addl   $0x18,-0x30(%ebp)
/work/x86_os_my/fs/fs.c:666
	/* 初始化当前目录".." */
	memcpy(p_de->filename, "..", 2);
c00085da:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00085dd:	83 ec 04             	sub    $0x4,%esp
c00085e0:	6a 02                	push   $0x2
c00085e2:	68 81 ec 00 c0       	push   $0xc000ec81
c00085e7:	50                   	push   %eax
c00085e8:	e8 ca b4 ff ff       	call   c0003ab7 <memcpy>
c00085ed:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:667
	p_de->i_no = parent_dir->inode->i_no;
c00085f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00085f3:	8b 00                	mov    (%eax),%eax
c00085f5:	8b 10                	mov    (%eax),%edx
c00085f7:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00085fa:	89 50 10             	mov    %edx,0x10(%eax)
/work/x86_os_my/fs/fs.c:668
	p_de->f_type = FT_DIRECTORY;
c00085fd:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0008600:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%eax)
/work/x86_os_my/fs/fs.c:669
	ide_write(cur_part->my_disk, new_dir_inode.i_sectors[0], io_buf, 1);
c0008607:	8b 95 8c fd ff ff    	mov    -0x274(%ebp),%edx
c000860d:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0008612:	8b 40 08             	mov    0x8(%eax),%eax
c0008615:	6a 01                	push   $0x1
c0008617:	ff 75 ec             	pushl  -0x14(%ebp)
c000861a:	52                   	push   %edx
c000861b:	50                   	push   %eax
c000861c:	e8 27 e1 ff ff       	call   c0006748 <ide_write>
c0008621:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:671

	new_dir_inode.i_size = 2 * cur_part->sb->dir_entry_size;
c0008624:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0008629:	8b 40 1c             	mov    0x1c(%eax),%eax
c000862c:	8b 40 30             	mov    0x30(%eax),%eax
c000862f:	01 c0                	add    %eax,%eax
c0008631:	89 85 80 fd ff ff    	mov    %eax,-0x280(%ebp)
/work/x86_os_my/fs/fs.c:675

	/* 在父目录中添加自己的目录项 */
	struct dir_entry new_dir_entry;
	memset(&new_dir_entry, 0, sizeof(struct dir_entry));
c0008637:	83 ec 04             	sub    $0x4,%esp
c000863a:	6a 18                	push   $0x18
c000863c:	6a 00                	push   $0x0
c000863e:	8d 85 64 fd ff ff    	lea    -0x29c(%ebp),%eax
c0008644:	50                   	push   %eax
c0008645:	e8 1b b4 ff ff       	call   c0003a65 <memset>
c000864a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:676
	create_dir_entry(dirname, inode_no, FT_DIRECTORY, &new_dir_entry);
c000864d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0008650:	8d 95 64 fd ff ff    	lea    -0x29c(%ebp),%edx
c0008656:	52                   	push   %edx
c0008657:	6a 02                	push   $0x2
c0008659:	50                   	push   %eax
c000865a:	ff 75 dc             	pushl  -0x24(%ebp)
c000865d:	e8 00 27 00 00       	call   c000ad62 <create_dir_entry>
c0008662:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:677
	memset(io_buf, 0, SECTOR_SIZE * 2);	 // 清空io_buf
c0008665:	83 ec 04             	sub    $0x4,%esp
c0008668:	68 00 04 00 00       	push   $0x400
c000866d:	6a 00                	push   $0x0
c000866f:	ff 75 ec             	pushl  -0x14(%ebp)
c0008672:	e8 ee b3 ff ff       	call   c0003a65 <memset>
c0008677:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:678
	if (!sync_dir_entry(parent_dir, &new_dir_entry, io_buf)) {	  // sync_dir_entry中将block_bitmap通过bitmap_sync同步到硬盘
c000867a:	83 ec 04             	sub    $0x4,%esp
c000867d:	ff 75 ec             	pushl  -0x14(%ebp)
c0008680:	8d 85 64 fd ff ff    	lea    -0x29c(%ebp),%eax
c0008686:	50                   	push   %eax
c0008687:	ff 75 e0             	pushl  -0x20(%ebp)
c000868a:	e8 44 27 00 00       	call   c000add3 <sync_dir_entry>
c000868f:	83 c4 10             	add    $0x10,%esp
c0008692:	85 c0                	test   %eax,%eax
c0008694:	75 19                	jne    c00086af <sys_mkdir+0x308>
/work/x86_os_my/fs/fs.c:679
		printk("sys_mkdir: sync_dir_entry to disk failed!\n");
c0008696:	83 ec 0c             	sub    $0xc,%esp
c0008699:	68 e4 f0 00 c0       	push   $0xc000f0e4
c000869e:	e8 aa e9 ff ff       	call   c000704d <printk>
c00086a3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:680
		rollback_step = 2;
c00086a6:	c6 45 f7 02          	movb   $0x2,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:681
		goto rollback;
c00086aa:	e9 9a 00 00 00       	jmp    c0008749 <sys_mkdir+0x3a2>
/work/x86_os_my/fs/fs.c:685
	}

	/* 父目录的inode同步到硬盘 */
	memset(io_buf, 0, SECTOR_SIZE * 2);
c00086af:	83 ec 04             	sub    $0x4,%esp
c00086b2:	68 00 04 00 00       	push   $0x400
c00086b7:	6a 00                	push   $0x0
c00086b9:	ff 75 ec             	pushl  -0x14(%ebp)
c00086bc:	e8 a4 b3 ff ff       	call   c0003a65 <memset>
c00086c1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:686
	inode_sync(cur_part, parent_dir->inode, io_buf);
c00086c4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00086c7:	8b 10                	mov    (%eax),%edx
c00086c9:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c00086ce:	83 ec 04             	sub    $0x4,%esp
c00086d1:	ff 75 ec             	pushl  -0x14(%ebp)
c00086d4:	52                   	push   %edx
c00086d5:	50                   	push   %eax
c00086d6:	e8 44 0c 00 00       	call   c000931f <inode_sync>
c00086db:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:689

	/* 将新创建目录的inode同步到硬盘 */
	memset(io_buf, 0, SECTOR_SIZE * 2);
c00086de:	83 ec 04             	sub    $0x4,%esp
c00086e1:	68 00 04 00 00       	push   $0x400
c00086e6:	6a 00                	push   $0x0
c00086e8:	ff 75 ec             	pushl  -0x14(%ebp)
c00086eb:	e8 75 b3 ff ff       	call   c0003a65 <memset>
c00086f0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:690
	inode_sync(cur_part, &new_dir_inode, io_buf);
c00086f3:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c00086f8:	83 ec 04             	sub    $0x4,%esp
c00086fb:	ff 75 ec             	pushl  -0x14(%ebp)
c00086fe:	8d 95 7c fd ff ff    	lea    -0x284(%ebp),%edx
c0008704:	52                   	push   %edx
c0008705:	50                   	push   %eax
c0008706:	e8 14 0c 00 00       	call   c000931f <inode_sync>
c000870b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:693

	/* 将inode位图同步到硬盘 */
	bitmap_sync(cur_part, inode_no, INODE_BITMAP);
c000870e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008711:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0008716:	83 ec 04             	sub    $0x4,%esp
c0008719:	6a 00                	push   $0x0
c000871b:	52                   	push   %edx
c000871c:	50                   	push   %eax
c000871d:	e8 e2 13 00 00       	call   c0009b04 <bitmap_sync>
c0008722:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:695

	sys_free(io_buf);
c0008725:	83 ec 0c             	sub    $0xc,%esp
c0008728:	ff 75 ec             	pushl  -0x14(%ebp)
c000872b:	e8 09 ae ff ff       	call   c0003539 <sys_free>
c0008730:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:698

	/* 关闭所创建目录的父目录 */
	dir_close(searched_record.parent_dir);
c0008733:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0008736:	83 ec 0c             	sub    $0xc,%esp
c0008739:	50                   	push   %eax
c000873a:	e8 f0 25 00 00       	call   c000ad2f <dir_close>
c000873f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:699
	return 0;
c0008742:	b8 00 00 00 00       	mov    $0x0,%eax
c0008747:	eb 4c                	jmp    c0008795 <sys_mkdir+0x3ee>
/work/x86_os_my/fs/fs.c:703

	/*创建文件或目录需要创建相关的多个资源,若某步失败则会执行到下面的回滚步骤 */
rollback:	     // 因为某步骤操作失败而回滚
	switch (rollback_step) {
c0008749:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000874d:	83 f8 01             	cmp    $0x1,%eax
c0008750:	74 20                	je     c0008772 <sys_mkdir+0x3cb>
c0008752:	83 f8 02             	cmp    $0x2,%eax
c0008755:	75 2b                	jne    c0008782 <sys_mkdir+0x3db>
/work/x86_os_my/fs/fs.c:705
		case 2:
		bitmap_set(&cur_part->inode_bitmap, inode_no, 0);	 // 如果新文件的inode创建失败,之前位图中分配的inode_no也要恢复
c0008757:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000875a:	8b 15 90 58 01 c0    	mov    0xc0015890,%edx
c0008760:	83 c2 28             	add    $0x28,%edx
c0008763:	83 ec 04             	sub    $0x4,%esp
c0008766:	6a 00                	push   $0x0
c0008768:	50                   	push   %eax
c0008769:	52                   	push   %edx
c000876a:	e8 60 a0 ff ff       	call   c00027cf <bitmap_set>
c000876f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:708
		case 1:
		/* 关闭所创建目录的父目录 */
		dir_close(searched_record.parent_dir);
c0008772:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0008775:	83 ec 0c             	sub    $0xc,%esp
c0008778:	50                   	push   %eax
c0008779:	e8 b1 25 00 00       	call   c000ad2f <dir_close>
c000877e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:709
		break;
c0008781:	90                   	nop
/work/x86_os_my/fs/fs.c:711
	}
	sys_free(io_buf);
c0008782:	83 ec 0c             	sub    $0xc,%esp
c0008785:	ff 75 ec             	pushl  -0x14(%ebp)
c0008788:	e8 ac ad ff ff       	call   c0003539 <sys_free>
c000878d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:712
	return -1;
c0008790:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/fs/fs.c:713 (discriminator 1)
}
c0008795:	c9                   	leave  
c0008796:	c3                   	ret    

c0008797 <sys_opendir>:
sys_opendir():
/work/x86_os_my/fs/fs.c:716

/* 目录打开成功后返回目录指针,失败返回NULL */
struct dir* sys_opendir(const char* name) {
c0008797:	55                   	push   %ebp
c0008798:	89 e5                	mov    %esp,%ebp
c000879a:	81 ec 18 02 00 00    	sub    $0x218,%esp
/work/x86_os_my/fs/fs.c:717
	ASSERT(strlen(name) < MAX_PATH_LEN);
c00087a0:	83 ec 0c             	sub    $0xc,%esp
c00087a3:	ff 75 08             	pushl  0x8(%ebp)
c00087a6:	e8 44 b4 ff ff       	call   c0003bef <strlen>
c00087ab:	83 c4 10             	add    $0x10,%esp
c00087ae:	3d ff 01 00 00       	cmp    $0x1ff,%eax
c00087b3:	76 1c                	jbe    c00087d1 <sys_opendir+0x3a>
/work/x86_os_my/fs/fs.c:717 (discriminator 1)
c00087b5:	68 0f f1 00 c0       	push   $0xc000f10f
c00087ba:	68 cc f4 00 c0       	push   $0xc000f4cc
c00087bf:	68 cd 02 00 00       	push   $0x2cd
c00087c4:	68 41 eb 00 c0       	push   $0xc000eb41
c00087c9:	e8 93 9d ff ff       	call   c0002561 <panic_spin>
c00087ce:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:719
	/* 如果是根目录'/',直接返回&root_dir */
	if (name[0] == '/' && (name[1] == 0 || name[0] == '.')) {
c00087d1:	8b 45 08             	mov    0x8(%ebp),%eax
c00087d4:	0f b6 00             	movzbl (%eax),%eax
c00087d7:	3c 2f                	cmp    $0x2f,%al
c00087d9:	75 21                	jne    c00087fc <sys_opendir+0x65>
/work/x86_os_my/fs/fs.c:719 (discriminator 1)
c00087db:	8b 45 08             	mov    0x8(%ebp),%eax
c00087de:	83 c0 01             	add    $0x1,%eax
c00087e1:	0f b6 00             	movzbl (%eax),%eax
c00087e4:	84 c0                	test   %al,%al
c00087e6:	74 0a                	je     c00087f2 <sys_opendir+0x5b>
/work/x86_os_my/fs/fs.c:719 (discriminator 2)
c00087e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00087eb:	0f b6 00             	movzbl (%eax),%eax
c00087ee:	3c 2e                	cmp    $0x2e,%al
c00087f0:	75 0a                	jne    c00087fc <sys_opendir+0x65>
/work/x86_os_my/fs/fs.c:720
		return &root_dir;
c00087f2:	b8 20 5a 01 c0       	mov    $0xc0015a20,%eax
c00087f7:	e9 a9 00 00 00       	jmp    c00088a5 <sys_opendir+0x10e>
/work/x86_os_my/fs/fs.c:725
	}

	/* 先检查待打开的目录是否存在 */
	struct path_search_record searched_record;
	memset(&searched_record, 0, sizeof(struct path_search_record));
c00087fc:	83 ec 04             	sub    $0x4,%esp
c00087ff:	68 08 02 00 00       	push   $0x208
c0008804:	6a 00                	push   $0x0
c0008806:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c000880c:	50                   	push   %eax
c000880d:	e8 53 b2 ff ff       	call   c0003a65 <memset>
c0008812:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:726
	int inode_no = search_file(name, &searched_record);
c0008815:	83 ec 08             	sub    $0x8,%esp
c0008818:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c000881e:	50                   	push   %eax
c000881f:	ff 75 08             	pushl  0x8(%ebp)
c0008822:	e8 c2 ef ff ff       	call   c00077e9 <search_file>
c0008827:	83 c4 10             	add    $0x10,%esp
c000882a:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:727
	struct dir* ret = NULL;
c000882d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:728
	if (inode_no == -1) {	 // 如果找不到目录,提示不存在的路径
c0008834:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0008838:	75 1c                	jne    c0008856 <sys_opendir+0xbf>
/work/x86_os_my/fs/fs.c:729
		printk("In %s, sub path %s not exist\n", name, searched_record.searched_path);
c000883a:	83 ec 04             	sub    $0x4,%esp
c000883d:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c0008843:	50                   	push   %eax
c0008844:	ff 75 08             	pushl  0x8(%ebp)
c0008847:	68 2b f1 00 c0       	push   $0xc000f12b
c000884c:	e8 fc e7 ff ff       	call   c000704d <printk>
c0008851:	83 c4 10             	add    $0x10,%esp
c0008854:	eb 3d                	jmp    c0008893 <sys_opendir+0xfc>
/work/x86_os_my/fs/fs.c:731
	} else {
		if (searched_record.file_type == FT_REGULAR) {
c0008856:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008859:	83 f8 01             	cmp    $0x1,%eax
c000885c:	75 15                	jne    c0008873 <sys_opendir+0xdc>
/work/x86_os_my/fs/fs.c:732
			printk("%s is regular file!\n", name);
c000885e:	83 ec 08             	sub    $0x8,%esp
c0008861:	ff 75 08             	pushl  0x8(%ebp)
c0008864:	68 49 f1 00 c0       	push   $0xc000f149
c0008869:	e8 df e7 ff ff       	call   c000704d <printk>
c000886e:	83 c4 10             	add    $0x10,%esp
c0008871:	eb 20                	jmp    c0008893 <sys_opendir+0xfc>
/work/x86_os_my/fs/fs.c:733
		} else if (searched_record.file_type == FT_DIRECTORY) {
c0008873:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008876:	83 f8 02             	cmp    $0x2,%eax
c0008879:	75 18                	jne    c0008893 <sys_opendir+0xfc>
/work/x86_os_my/fs/fs.c:734
			ret = dir_open(cur_part, inode_no);
c000887b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000887e:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0008883:	83 ec 08             	sub    $0x8,%esp
c0008886:	52                   	push   %edx
c0008887:	50                   	push   %eax
c0008888:	e8 8a 22 00 00       	call   c000ab17 <dir_open>
c000888d:	83 c4 10             	add    $0x10,%esp
c0008890:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:737
		}
	}
	dir_close(searched_record.parent_dir);
c0008893:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0008896:	83 ec 0c             	sub    $0xc,%esp
c0008899:	50                   	push   %eax
c000889a:	e8 90 24 00 00       	call   c000ad2f <dir_close>
c000889f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:738
	return ret;
c00088a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:739 (discriminator 1)
}
c00088a5:	c9                   	leave  
c00088a6:	c3                   	ret    

c00088a7 <sys_closedir>:
sys_closedir():
/work/x86_os_my/fs/fs.c:742

/* 成功关闭目录dir返回0,失败返回-1 */
int32_t sys_closedir(struct dir* dir) {
c00088a7:	55                   	push   %ebp
c00088a8:	89 e5                	mov    %esp,%ebp
c00088aa:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/fs.c:743
	int32_t ret = -1;
c00088ad:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:744
	if (dir != NULL) {
c00088b4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00088b8:	74 15                	je     c00088cf <sys_closedir+0x28>
/work/x86_os_my/fs/fs.c:745
		dir_close(dir);
c00088ba:	83 ec 0c             	sub    $0xc,%esp
c00088bd:	ff 75 08             	pushl  0x8(%ebp)
c00088c0:	e8 6a 24 00 00       	call   c000ad2f <dir_close>
c00088c5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:746
		ret = 0;
c00088c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:748
	}
	return ret;
c00088cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:749
}
c00088d2:	c9                   	leave  
c00088d3:	c3                   	ret    

c00088d4 <sys_readdir>:
sys_readdir():
/work/x86_os_my/fs/fs.c:752

/* 读取目录dir的1个目录项,成功后返回其目录项地址,到目录尾时或出错时返回NULL */
struct dir_entry* sys_readdir(struct dir* dir) {
c00088d4:	55                   	push   %ebp
c00088d5:	89 e5                	mov    %esp,%ebp
c00088d7:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/fs/fs.c:753
	ASSERT(dir != NULL);
c00088da:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00088de:	75 1c                	jne    c00088fc <sys_readdir+0x28>
/work/x86_os_my/fs/fs.c:753 (discriminator 1)
c00088e0:	68 5e f1 00 c0       	push   $0xc000f15e
c00088e5:	68 d8 f4 00 c0       	push   $0xc000f4d8
c00088ea:	68 f1 02 00 00       	push   $0x2f1
c00088ef:	68 41 eb 00 c0       	push   $0xc000eb41
c00088f4:	e8 68 9c ff ff       	call   c0002561 <panic_spin>
c00088f9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:754
	return dir_read(dir);
c00088fc:	83 ec 0c             	sub    $0xc,%esp
c00088ff:	ff 75 08             	pushl  0x8(%ebp)
c0008902:	e8 4f 2d 00 00       	call   c000b656 <dir_read>
c0008907:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:755
}
c000890a:	c9                   	leave  
c000890b:	c3                   	ret    

c000890c <sys_rewinddir>:
sys_rewinddir():
/work/x86_os_my/fs/fs.c:758

/* 把目录dir的指针dir_pos置0 */
void sys_rewinddir(struct dir* dir) {
c000890c:	55                   	push   %ebp
c000890d:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/fs/fs.c:759
	dir->dir_pos = 0;
c000890f:	8b 45 08             	mov    0x8(%ebp),%eax
c0008912:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
/work/x86_os_my/fs/fs.c:760
}
c0008919:	90                   	nop
c000891a:	5d                   	pop    %ebp
c000891b:	c3                   	ret    

c000891c <sys_rmdir>:
sys_rmdir():
/work/x86_os_my/fs/fs.c:763

/* 删除空目录,成功时返回0,失败时返回-1*/
int32_t sys_rmdir(const char* pathname) {
c000891c:	55                   	push   %ebp
c000891d:	89 e5                	mov    %esp,%ebp
c000891f:	81 ec 28 02 00 00    	sub    $0x228,%esp
/work/x86_os_my/fs/fs.c:766
	/* 先检查待删除的文件是否存在 */
	struct path_search_record searched_record;
	memset(&searched_record, 0, sizeof(struct path_search_record));
c0008925:	83 ec 04             	sub    $0x4,%esp
c0008928:	68 08 02 00 00       	push   $0x208
c000892d:	6a 00                	push   $0x0
c000892f:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0008935:	50                   	push   %eax
c0008936:	e8 2a b1 ff ff       	call   c0003a65 <memset>
c000893b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:767
	int32_t inode_no = search_file(pathname, &searched_record);
c000893e:	83 ec 08             	sub    $0x8,%esp
c0008941:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0008947:	50                   	push   %eax
c0008948:	ff 75 08             	pushl  0x8(%ebp)
c000894b:	e8 99 ee ff ff       	call   c00077e9 <search_file>
c0008950:	83 c4 10             	add    $0x10,%esp
c0008953:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:768
	ASSERT(inode_no != 0);
c0008956:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000895a:	75 1c                	jne    c0008978 <sys_rmdir+0x5c>
/work/x86_os_my/fs/fs.c:768 (discriminator 1)
c000895c:	68 14 ef 00 c0       	push   $0xc000ef14
c0008961:	68 e4 f4 00 c0       	push   $0xc000f4e4
c0008966:	68 00 03 00 00       	push   $0x300
c000896b:	68 41 eb 00 c0       	push   $0xc000eb41
c0008970:	e8 ec 9b ff ff       	call   c0002561 <panic_spin>
c0008975:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:769
	int32_t retval = -1;	// 默认返回值
c0008978:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:770
	if (inode_no == -1) {
c000897f:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0008983:	75 1f                	jne    c00089a4 <sys_rmdir+0x88>
/work/x86_os_my/fs/fs.c:771
		printk("In %s, sub path %s not exist\n", pathname, searched_record.searched_path);
c0008985:	83 ec 04             	sub    $0x4,%esp
c0008988:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c000898e:	50                   	push   %eax
c000898f:	ff 75 08             	pushl  0x8(%ebp)
c0008992:	68 2b f1 00 c0       	push   $0xc000f12b
c0008997:	e8 b1 e6 ff ff       	call   c000704d <printk>
c000899c:	83 c4 10             	add    $0x10,%esp
c000899f:	e9 87 00 00 00       	jmp    c0008a2b <sys_rmdir+0x10f>
/work/x86_os_my/fs/fs.c:773
	} else {
		if (searched_record.file_type == FT_REGULAR) {
c00089a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00089a7:	83 f8 01             	cmp    $0x1,%eax
c00089aa:	75 15                	jne    c00089c1 <sys_rmdir+0xa5>
/work/x86_os_my/fs/fs.c:774
			printk("%s is regular file!\n", pathname);
c00089ac:	83 ec 08             	sub    $0x8,%esp
c00089af:	ff 75 08             	pushl  0x8(%ebp)
c00089b2:	68 49 f1 00 c0       	push   $0xc000f149
c00089b7:	e8 91 e6 ff ff       	call   c000704d <printk>
c00089bc:	83 c4 10             	add    $0x10,%esp
c00089bf:	eb 6a                	jmp    c0008a2b <sys_rmdir+0x10f>
/work/x86_os_my/fs/fs.c:776
		} else {
			struct dir* dir = dir_open(cur_part, inode_no);
c00089c1:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00089c4:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c00089c9:	83 ec 08             	sub    $0x8,%esp
c00089cc:	52                   	push   %edx
c00089cd:	50                   	push   %eax
c00089ce:	e8 44 21 00 00       	call   c000ab17 <dir_open>
c00089d3:	83 c4 10             	add    $0x10,%esp
c00089d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:777
			if (!dir_is_empty(dir)) {	 // 非空目录不可删除
c00089d9:	83 ec 0c             	sub    $0xc,%esp
c00089dc:	ff 75 ec             	pushl  -0x14(%ebp)
c00089df:	e8 5a 2e 00 00       	call   c000b83e <dir_is_empty>
c00089e4:	83 c4 10             	add    $0x10,%esp
c00089e7:	85 c0                	test   %eax,%eax
c00089e9:	75 15                	jne    c0008a00 <sys_rmdir+0xe4>
/work/x86_os_my/fs/fs.c:778
				printk("dir %s is not empty, it is not allowed to delete a nonempty directory!\n", pathname);
c00089eb:	83 ec 08             	sub    $0x8,%esp
c00089ee:	ff 75 08             	pushl  0x8(%ebp)
c00089f1:	68 6c f1 00 c0       	push   $0xc000f16c
c00089f6:	e8 52 e6 ff ff       	call   c000704d <printk>
c00089fb:	83 c4 10             	add    $0x10,%esp
c00089fe:	eb 1d                	jmp    c0008a1d <sys_rmdir+0x101>
/work/x86_os_my/fs/fs.c:780
			} else {
				if (!dir_remove(searched_record.parent_dir, dir)) {
c0008a00:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0008a03:	83 ec 08             	sub    $0x8,%esp
c0008a06:	ff 75 ec             	pushl  -0x14(%ebp)
c0008a09:	50                   	push   %eax
c0008a0a:	e8 5a 2e 00 00       	call   c000b869 <dir_remove>
c0008a0f:	83 c4 10             	add    $0x10,%esp
c0008a12:	85 c0                	test   %eax,%eax
c0008a14:	75 07                	jne    c0008a1d <sys_rmdir+0x101>
/work/x86_os_my/fs/fs.c:781
					retval = 0;
c0008a16:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:784
				}
			}
			dir_close(dir);
c0008a1d:	83 ec 0c             	sub    $0xc,%esp
c0008a20:	ff 75 ec             	pushl  -0x14(%ebp)
c0008a23:	e8 07 23 00 00       	call   c000ad2f <dir_close>
c0008a28:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:787
		}
	}
	dir_close(searched_record.parent_dir);
c0008a2b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0008a2e:	83 ec 0c             	sub    $0xc,%esp
c0008a31:	50                   	push   %eax
c0008a32:	e8 f8 22 00 00       	call   c000ad2f <dir_close>
c0008a37:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:788
	return retval;
c0008a3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:789
}
c0008a3d:	c9                   	leave  
c0008a3e:	c3                   	ret    

c0008a3f <get_parent_dir_inode_nr>:
get_parent_dir_inode_nr():
/work/x86_os_my/fs/fs.c:792

/* 获得父目录的inode编号 */
static uint32_t get_parent_dir_inode_nr(uint32_t child_inode_nr, void* io_buf) {
c0008a3f:	55                   	push   %ebp
c0008a40:	89 e5                	mov    %esp,%ebp
c0008a42:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/fs.c:793
   struct inode* child_dir_inode = inode_open(cur_part, child_inode_nr);
c0008a45:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0008a4a:	83 ec 08             	sub    $0x8,%esp
c0008a4d:	ff 75 08             	pushl  0x8(%ebp)
c0008a50:	50                   	push   %eax
c0008a51:	e8 f0 09 00 00       	call   c0009446 <inode_open>
c0008a56:	83 c4 10             	add    $0x10,%esp
c0008a59:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:795
   /* 目录中的目录项".."中包括父目录inode编号,".."位于目录的第0块 */
   uint32_t block_lba = child_dir_inode->i_sectors[0];
c0008a5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0008a5f:	8b 40 10             	mov    0x10(%eax),%eax
c0008a62:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:796
   ASSERT(block_lba >= cur_part->sb->data_start_lba);
c0008a65:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0008a6a:	8b 40 1c             	mov    0x1c(%eax),%eax
c0008a6d:	8b 40 28             	mov    0x28(%eax),%eax
c0008a70:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0008a73:	76 1c                	jbe    c0008a91 <get_parent_dir_inode_nr+0x52>
/work/x86_os_my/fs/fs.c:796 (discriminator 1)
c0008a75:	68 b4 f1 00 c0       	push   $0xc000f1b4
c0008a7a:	68 f0 f4 00 c0       	push   $0xc000f4f0
c0008a7f:	68 1c 03 00 00       	push   $0x31c
c0008a84:	68 41 eb 00 c0       	push   $0xc000eb41
c0008a89:	e8 d3 9a ff ff       	call   c0002561 <panic_spin>
c0008a8e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:797
   inode_close(child_dir_inode);
c0008a91:	83 ec 0c             	sub    $0xc,%esp
c0008a94:	ff 75 f4             	pushl  -0xc(%ebp)
c0008a97:	e8 f0 0a 00 00       	call   c000958c <inode_close>
c0008a9c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:798
   ide_read(cur_part->my_disk, block_lba, io_buf, 1);
c0008a9f:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0008aa4:	8b 40 08             	mov    0x8(%eax),%eax
c0008aa7:	6a 01                	push   $0x1
c0008aa9:	ff 75 0c             	pushl  0xc(%ebp)
c0008aac:	ff 75 f0             	pushl  -0x10(%ebp)
c0008aaf:	50                   	push   %eax
c0008ab0:	e8 1f db ff ff       	call   c00065d4 <ide_read>
c0008ab5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:799
   struct dir_entry* dir_e = (struct dir_entry*)io_buf;
c0008ab8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0008abb:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:801
   /* 第0个目录项是".",第1个目录项是".." */
   ASSERT(dir_e[1].i_no < 4096 && dir_e[1].f_type == FT_DIRECTORY);
c0008abe:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008ac1:	83 c0 18             	add    $0x18,%eax
c0008ac4:	8b 40 10             	mov    0x10(%eax),%eax
c0008ac7:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c0008acc:	77 0e                	ja     c0008adc <get_parent_dir_inode_nr+0x9d>
/work/x86_os_my/fs/fs.c:801 (discriminator 1)
c0008ace:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008ad1:	83 c0 18             	add    $0x18,%eax
c0008ad4:	8b 40 14             	mov    0x14(%eax),%eax
c0008ad7:	83 f8 02             	cmp    $0x2,%eax
c0008ada:	74 1c                	je     c0008af8 <get_parent_dir_inode_nr+0xb9>
/work/x86_os_my/fs/fs.c:801 (discriminator 3)
c0008adc:	68 e0 f1 00 c0       	push   $0xc000f1e0
c0008ae1:	68 f0 f4 00 c0       	push   $0xc000f4f0
c0008ae6:	68 21 03 00 00       	push   $0x321
c0008aeb:	68 41 eb 00 c0       	push   $0xc000eb41
c0008af0:	e8 6c 9a ff ff       	call   c0002561 <panic_spin>
c0008af5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:802
   return dir_e[1].i_no;	// 返回..即父目录的inode编号
c0008af8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008afb:	83 c0 18             	add    $0x18,%eax
c0008afe:	8b 40 10             	mov    0x10(%eax),%eax
/work/x86_os_my/fs/fs.c:803
}
c0008b01:	c9                   	leave  
c0008b02:	c3                   	ret    

c0008b03 <get_child_dir_name>:
get_child_dir_name():
/work/x86_os_my/fs/fs.c:807

/* 在inode编号为p_inode_nr的目录中查找inode编号为c_inode_nr的子目录的名字,
 * 将名字存入缓冲区path.成功返回0,失败返-1 */
static int get_child_dir_name(uint32_t p_inode_nr, uint32_t c_inode_nr, char* path, void* io_buf) {
c0008b03:	55                   	push   %ebp
c0008b04:	89 e5                	mov    %esp,%ebp
c0008b06:	57                   	push   %edi
c0008b07:	81 ec 54 02 00 00    	sub    $0x254,%esp
/work/x86_os_my/fs/fs.c:808
	struct inode* parent_dir_inode = inode_open(cur_part, p_inode_nr);
c0008b0d:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0008b12:	83 ec 08             	sub    $0x8,%esp
c0008b15:	ff 75 08             	pushl  0x8(%ebp)
c0008b18:	50                   	push   %eax
c0008b19:	e8 28 09 00 00       	call   c0009446 <inode_open>
c0008b1e:	83 c4 10             	add    $0x10,%esp
c0008b21:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:810
	/* 填充all_blocks,将该目录的所占扇区地址全部写入all_blocks */
	uint8_t block_idx = 0;
c0008b24:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:811
	uint32_t all_blocks[140] = {0}, block_cnt = 12;
c0008b28:	8d 95 ac fd ff ff    	lea    -0x254(%ebp),%edx
c0008b2e:	b8 00 00 00 00       	mov    $0x0,%eax
c0008b33:	b9 8c 00 00 00       	mov    $0x8c,%ecx
c0008b38:	89 d7                	mov    %edx,%edi
c0008b3a:	f3 ab                	rep stos %eax,%es:(%edi)
c0008b3c:	c7 45 f0 0c 00 00 00 	movl   $0xc,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:812
	while (block_idx < 12) {
c0008b43:	eb 22                	jmp    c0008b67 <get_child_dir_name+0x64>
/work/x86_os_my/fs/fs.c:813
		all_blocks[block_idx] = parent_dir_inode->i_sectors[block_idx];
c0008b45:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008b49:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
c0008b4d:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0008b50:	83 c1 04             	add    $0x4,%ecx
c0008b53:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
c0008b56:	89 94 85 ac fd ff ff 	mov    %edx,-0x254(%ebp,%eax,4)
/work/x86_os_my/fs/fs.c:814
		block_idx++;
c0008b5d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008b61:	83 c0 01             	add    $0x1,%eax
c0008b64:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:812
static int get_child_dir_name(uint32_t p_inode_nr, uint32_t c_inode_nr, char* path, void* io_buf) {
	struct inode* parent_dir_inode = inode_open(cur_part, p_inode_nr);
	/* 填充all_blocks,将该目录的所占扇区地址全部写入all_blocks */
	uint8_t block_idx = 0;
	uint32_t all_blocks[140] = {0}, block_cnt = 12;
	while (block_idx < 12) {
c0008b67:	80 7d f7 0b          	cmpb   $0xb,-0x9(%ebp)
c0008b6b:	76 d8                	jbe    c0008b45 <get_child_dir_name+0x42>
/work/x86_os_my/fs/fs.c:816
		all_blocks[block_idx] = parent_dir_inode->i_sectors[block_idx];
		block_idx++;
	}
	if (parent_dir_inode->i_sectors[12]) {	// 若包含了一级间接块表,将共读入all_blocks.
c0008b6d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0008b70:	8b 40 40             	mov    0x40(%eax),%eax
c0008b73:	85 c0                	test   %eax,%eax
c0008b75:	74 2c                	je     c0008ba3 <get_child_dir_name+0xa0>
/work/x86_os_my/fs/fs.c:817
		ide_read(cur_part->my_disk, parent_dir_inode->i_sectors[12], all_blocks + 12, 1);
c0008b77:	8d 85 ac fd ff ff    	lea    -0x254(%ebp),%eax
c0008b7d:	83 c0 30             	add    $0x30,%eax
c0008b80:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0008b83:	8b 4a 40             	mov    0x40(%edx),%ecx
c0008b86:	8b 15 90 58 01 c0    	mov    0xc0015890,%edx
c0008b8c:	8b 52 08             	mov    0x8(%edx),%edx
c0008b8f:	6a 01                	push   $0x1
c0008b91:	50                   	push   %eax
c0008b92:	51                   	push   %ecx
c0008b93:	52                   	push   %edx
c0008b94:	e8 3b da ff ff       	call   c00065d4 <ide_read>
c0008b99:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:818
		block_cnt = 140;
c0008b9c:	c7 45 f0 8c 00 00 00 	movl   $0x8c,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:820
	}
	inode_close(parent_dir_inode);
c0008ba3:	83 ec 0c             	sub    $0xc,%esp
c0008ba6:	ff 75 e8             	pushl  -0x18(%ebp)
c0008ba9:	e8 de 09 00 00       	call   c000958c <inode_close>
c0008bae:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:822

	struct dir_entry* dir_e = (struct dir_entry*)io_buf;
c0008bb1:	8b 45 14             	mov    0x14(%ebp),%eax
c0008bb4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/fs.c:823
	uint32_t dir_entry_size = cur_part->sb->dir_entry_size;
c0008bb7:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0008bbc:	8b 40 1c             	mov    0x1c(%eax),%eax
c0008bbf:	8b 40 30             	mov    0x30(%eax),%eax
c0008bc2:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/fs.c:824
	uint32_t dir_entrys_per_sec = (512 / dir_entry_size);
c0008bc5:	b8 00 02 00 00       	mov    $0x200,%eax
c0008bca:	ba 00 00 00 00       	mov    $0x0,%edx
c0008bcf:	f7 75 e0             	divl   -0x20(%ebp)
c0008bd2:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/fs.c:825
	block_idx = 0;
c0008bd5:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:827
	/* 遍历所有块 */
	while(block_idx < block_cnt) {
c0008bd9:	e9 b1 00 00 00       	jmp    c0008c8f <get_child_dir_name+0x18c>
/work/x86_os_my/fs/fs.c:828
		if(all_blocks[block_idx]) {      // 如果相应块不为空则读入相应块
c0008bde:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008be2:	8b 84 85 ac fd ff ff 	mov    -0x254(%ebp,%eax,4),%eax
c0008be9:	85 c0                	test   %eax,%eax
c0008beb:	0f 84 94 00 00 00    	je     c0008c85 <get_child_dir_name+0x182>
/work/x86_os_my/fs/fs.c:829
			ide_read(cur_part->my_disk, all_blocks[block_idx], io_buf, 1);
c0008bf1:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008bf5:	8b 94 85 ac fd ff ff 	mov    -0x254(%ebp,%eax,4),%edx
c0008bfc:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0008c01:	8b 40 08             	mov    0x8(%eax),%eax
c0008c04:	6a 01                	push   $0x1
c0008c06:	ff 75 14             	pushl  0x14(%ebp)
c0008c09:	52                   	push   %edx
c0008c0a:	50                   	push   %eax
c0008c0b:	e8 c4 d9 ff ff       	call   c00065d4 <ide_read>
c0008c10:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:830
			uint8_t dir_e_idx = 0;
c0008c13:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
/work/x86_os_my/fs/fs.c:832
			/* 遍历每个目录项 */
			while(dir_e_idx < dir_entrys_per_sec) {
c0008c17:	eb 63                	jmp    c0008c7c <get_child_dir_name+0x179>
/work/x86_os_my/fs/fs.c:833
				if ((dir_e + dir_e_idx)->i_no == c_inode_nr) {
c0008c19:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c0008c1d:	89 d0                	mov    %edx,%eax
c0008c1f:	01 c0                	add    %eax,%eax
c0008c21:	01 d0                	add    %edx,%eax
c0008c23:	c1 e0 03             	shl    $0x3,%eax
c0008c26:	89 c2                	mov    %eax,%edx
c0008c28:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0008c2b:	01 d0                	add    %edx,%eax
c0008c2d:	8b 40 10             	mov    0x10(%eax),%eax
c0008c30:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0008c33:	75 3d                	jne    c0008c72 <get_child_dir_name+0x16f>
/work/x86_os_my/fs/fs.c:834
					strcat(path, "/");
c0008c35:	83 ec 08             	sub    $0x8,%esp
c0008c38:	68 bb ec 00 c0       	push   $0xc000ecbb
c0008c3d:	ff 75 10             	pushl  0x10(%ebp)
c0008c40:	e8 24 b1 ff ff       	call   c0003d69 <strcat>
c0008c45:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:835
					strcat(path, (dir_e + dir_e_idx)->filename);
c0008c48:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c0008c4c:	89 d0                	mov    %edx,%eax
c0008c4e:	01 c0                	add    %eax,%eax
c0008c50:	01 d0                	add    %edx,%eax
c0008c52:	c1 e0 03             	shl    $0x3,%eax
c0008c55:	89 c2                	mov    %eax,%edx
c0008c57:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0008c5a:	01 d0                	add    %edx,%eax
c0008c5c:	83 ec 08             	sub    $0x8,%esp
c0008c5f:	50                   	push   %eax
c0008c60:	ff 75 10             	pushl  0x10(%ebp)
c0008c63:	e8 01 b1 ff ff       	call   c0003d69 <strcat>
c0008c68:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:836
					return 0;
c0008c6b:	b8 00 00 00 00       	mov    $0x0,%eax
c0008c70:	eb 2f                	jmp    c0008ca1 <get_child_dir_name+0x19e>
/work/x86_os_my/fs/fs.c:838
				}
				dir_e_idx++;
c0008c72:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c0008c76:	83 c0 01             	add    $0x1,%eax
c0008c79:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/fs/fs.c:832
	while(block_idx < block_cnt) {
		if(all_blocks[block_idx]) {      // 如果相应块不为空则读入相应块
			ide_read(cur_part->my_disk, all_blocks[block_idx], io_buf, 1);
			uint8_t dir_e_idx = 0;
			/* 遍历每个目录项 */
			while(dir_e_idx < dir_entrys_per_sec) {
c0008c7c:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c0008c80:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c0008c83:	72 94                	jb     c0008c19 <get_child_dir_name+0x116>
/work/x86_os_my/fs/fs.c:841
					return 0;
				}
				dir_e_idx++;
			}
		}
		block_idx++;
c0008c85:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008c89:	83 c0 01             	add    $0x1,%eax
c0008c8c:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:827
	struct dir_entry* dir_e = (struct dir_entry*)io_buf;
	uint32_t dir_entry_size = cur_part->sb->dir_entry_size;
	uint32_t dir_entrys_per_sec = (512 / dir_entry_size);
	block_idx = 0;
	/* 遍历所有块 */
	while(block_idx < block_cnt) {
c0008c8f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008c93:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0008c96:	0f 82 42 ff ff ff    	jb     c0008bde <get_child_dir_name+0xdb>
/work/x86_os_my/fs/fs.c:843
				dir_e_idx++;
			}
		}
		block_idx++;
	}
	return -1;
c0008c9c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/fs/fs.c:844 (discriminator 1)
}
c0008ca1:	8b 7d fc             	mov    -0x4(%ebp),%edi
c0008ca4:	c9                   	leave  
c0008ca5:	c3                   	ret    

c0008ca6 <sys_getcwd>:
sys_getcwd():
/work/x86_os_my/fs/fs.c:849

/* 把当前工作目录绝对路径写入buf, size是buf的大小.
 当buf为NULL时,由操作系统分配存储工作路径的空间并返回地址
 失败则返回NULL */
char* sys_getcwd(char* buf, uint32_t size) {
c0008ca6:	55                   	push   %ebp
c0008ca7:	89 e5                	mov    %esp,%ebp
c0008ca9:	57                   	push   %edi
c0008caa:	53                   	push   %ebx
c0008cab:	81 ec 20 02 00 00    	sub    $0x220,%esp
/work/x86_os_my/fs/fs.c:852
	/* 确保buf不为空,若用户进程提供的buf为NULL,
	系统调用getcwd中要为用户进程通过malloc分配内存 */
	ASSERT(buf != NULL);
c0008cb1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0008cb5:	75 1c                	jne    c0008cd3 <sys_getcwd+0x2d>
/work/x86_os_my/fs/fs.c:852 (discriminator 1)
c0008cb7:	68 a6 ee 00 c0       	push   $0xc000eea6
c0008cbc:	68 08 f5 00 c0       	push   $0xc000f508
c0008cc1:	68 54 03 00 00       	push   $0x354
c0008cc6:	68 41 eb 00 c0       	push   $0xc000eb41
c0008ccb:	e8 91 98 ff ff       	call   c0002561 <panic_spin>
c0008cd0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:853
	void* io_buf = sys_malloc(SECTOR_SIZE);
c0008cd3:	83 ec 0c             	sub    $0xc,%esp
c0008cd6:	68 00 02 00 00       	push   $0x200
c0008cdb:	e8 2c a2 ff ff       	call   c0002f0c <sys_malloc>
c0008ce0:	83 c4 10             	add    $0x10,%esp
c0008ce3:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:854
	if (io_buf == NULL) {
c0008ce6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0008cea:	75 0a                	jne    c0008cf6 <sys_getcwd+0x50>
/work/x86_os_my/fs/fs.c:855
		return NULL;
c0008cec:	b8 00 00 00 00       	mov    $0x0,%eax
c0008cf1:	e9 9d 01 00 00       	jmp    c0008e93 <sys_getcwd+0x1ed>
/work/x86_os_my/fs/fs.c:858
	}

	struct task_struct* cur_thread = running_thread();
c0008cf6:	e8 51 b1 ff ff       	call   c0003e4c <running_thread>
c0008cfb:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:859
	int32_t parent_inode_nr = 0;
c0008cfe:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:860
	int32_t child_inode_nr = cur_thread->cwd_inode_nr;
c0008d05:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008d08:	8b 80 0c 01 00 00    	mov    0x10c(%eax),%eax
c0008d0e:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:861
	ASSERT(child_inode_nr >= 0 && child_inode_nr < 4096);	// inode位图，最大支持4096个inode
c0008d11:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0008d15:	78 09                	js     c0008d20 <sys_getcwd+0x7a>
/work/x86_os_my/fs/fs.c:861 (discriminator 1)
c0008d17:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%ebp)
c0008d1e:	7e 1c                	jle    c0008d3c <sys_getcwd+0x96>
/work/x86_os_my/fs/fs.c:861 (discriminator 3)
c0008d20:	68 18 f2 00 c0       	push   $0xc000f218
c0008d25:	68 08 f5 00 c0       	push   $0xc000f508
c0008d2a:	68 5d 03 00 00       	push   $0x35d
c0008d2f:	68 41 eb 00 c0       	push   $0xc000eb41
c0008d34:	e8 28 98 ff ff       	call   c0002561 <panic_spin>
c0008d39:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:863
	/* 若当前目录是根目录,直接返回'/' */
	if (child_inode_nr == 0) {
c0008d3c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0008d40:	75 25                	jne    c0008d67 <sys_getcwd+0xc1>
/work/x86_os_my/fs/fs.c:864
		buf[0] = '/';
c0008d42:	8b 45 08             	mov    0x8(%ebp),%eax
c0008d45:	c6 00 2f             	movb   $0x2f,(%eax)
/work/x86_os_my/fs/fs.c:865
		buf[1] = 0;
c0008d48:	8b 45 08             	mov    0x8(%ebp),%eax
c0008d4b:	83 c0 01             	add    $0x1,%eax
c0008d4e:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:866
		sys_free(io_buf);
c0008d51:	83 ec 0c             	sub    $0xc,%esp
c0008d54:	ff 75 f0             	pushl  -0x10(%ebp)
c0008d57:	e8 dd a7 ff ff       	call   c0003539 <sys_free>
c0008d5c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:867
		return buf;
c0008d5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0008d62:	e9 2c 01 00 00       	jmp    c0008e93 <sys_getcwd+0x1ed>
/work/x86_os_my/fs/fs.c:870
	}

	memset(buf, 0, size);
c0008d67:	83 ec 04             	sub    $0x4,%esp
c0008d6a:	ff 75 0c             	pushl  0xc(%ebp)
c0008d6d:	6a 00                	push   $0x0
c0008d6f:	ff 75 08             	pushl  0x8(%ebp)
c0008d72:	e8 ee ac ff ff       	call   c0003a65 <memset>
c0008d77:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:871
	char full_path_reverse[MAX_PATH_LEN] = {0};	// 用来做全路径缓冲区
c0008d7a:	8d 85 e2 fd ff ff    	lea    -0x21e(%ebp),%eax
c0008d80:	b9 00 02 00 00       	mov    $0x200,%ecx
c0008d85:	bb 00 00 00 00       	mov    $0x0,%ebx
c0008d8a:	89 18                	mov    %ebx,(%eax)
c0008d8c:	89 5c 08 fc          	mov    %ebx,-0x4(%eax,%ecx,1)
c0008d90:	8d 50 04             	lea    0x4(%eax),%edx
c0008d93:	83 e2 fc             	and    $0xfffffffc,%edx
c0008d96:	29 d0                	sub    %edx,%eax
c0008d98:	01 c1                	add    %eax,%ecx
c0008d9a:	83 e1 fc             	and    $0xfffffffc,%ecx
c0008d9d:	c1 e9 02             	shr    $0x2,%ecx
c0008da0:	89 d7                	mov    %edx,%edi
c0008da2:	89 d8                	mov    %ebx,%eax
c0008da4:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/fs/fs.c:876

	/* 从下往上逐层找父目录,直到找到根目录为止.
	 * 当child_inode_nr为根目录的inode编号(0)时停止,
	 * 即已经查看完根目录中的目录项 */
	while ((child_inode_nr)) {
c0008da6:	eb 52                	jmp    c0008dfa <sys_getcwd+0x154>
/work/x86_os_my/fs/fs.c:877
		parent_inode_nr = get_parent_dir_inode_nr(child_inode_nr, io_buf);
c0008da8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0008dab:	83 ec 08             	sub    $0x8,%esp
c0008dae:	ff 75 f0             	pushl  -0x10(%ebp)
c0008db1:	50                   	push   %eax
c0008db2:	e8 88 fc ff ff       	call   c0008a3f <get_parent_dir_inode_nr>
c0008db7:	83 c4 10             	add    $0x10,%esp
c0008dba:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:878
		if (get_child_dir_name(parent_inode_nr, child_inode_nr, full_path_reverse, io_buf) == -1) {	// 或未找到名字,失败退出
c0008dbd:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0008dc0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0008dc3:	ff 75 f0             	pushl  -0x10(%ebp)
c0008dc6:	8d 8d e2 fd ff ff    	lea    -0x21e(%ebp),%ecx
c0008dcc:	51                   	push   %ecx
c0008dcd:	52                   	push   %edx
c0008dce:	50                   	push   %eax
c0008dcf:	e8 2f fd ff ff       	call   c0008b03 <get_child_dir_name>
c0008dd4:	83 c4 10             	add    $0x10,%esp
c0008dd7:	83 f8 ff             	cmp    $0xffffffff,%eax
c0008dda:	75 18                	jne    c0008df4 <sys_getcwd+0x14e>
/work/x86_os_my/fs/fs.c:879
			sys_free(io_buf);
c0008ddc:	83 ec 0c             	sub    $0xc,%esp
c0008ddf:	ff 75 f0             	pushl  -0x10(%ebp)
c0008de2:	e8 52 a7 ff ff       	call   c0003539 <sys_free>
c0008de7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:880
			return NULL;
c0008dea:	b8 00 00 00 00       	mov    $0x0,%eax
c0008def:	e9 9f 00 00 00       	jmp    c0008e93 <sys_getcwd+0x1ed>
/work/x86_os_my/fs/fs.c:882
		}
		child_inode_nr = parent_inode_nr;
c0008df4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0008df7:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:876
	char full_path_reverse[MAX_PATH_LEN] = {0};	// 用来做全路径缓冲区

	/* 从下往上逐层找父目录,直到找到根目录为止.
	 * 当child_inode_nr为根目录的inode编号(0)时停止,
	 * 即已经查看完根目录中的目录项 */
	while ((child_inode_nr)) {
c0008dfa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0008dfe:	75 a8                	jne    c0008da8 <sys_getcwd+0x102>
/work/x86_os_my/fs/fs.c:884
			sys_free(io_buf);
			return NULL;
		}
		child_inode_nr = parent_inode_nr;
	}
	ASSERT(strlen(full_path_reverse) <= size);
c0008e00:	83 ec 0c             	sub    $0xc,%esp
c0008e03:	8d 85 e2 fd ff ff    	lea    -0x21e(%ebp),%eax
c0008e09:	50                   	push   %eax
c0008e0a:	e8 e0 ad ff ff       	call   c0003bef <strlen>
c0008e0f:	83 c4 10             	add    $0x10,%esp
c0008e12:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0008e15:	76 4e                	jbe    c0008e65 <sys_getcwd+0x1bf>
/work/x86_os_my/fs/fs.c:884 (discriminator 1)
c0008e17:	68 48 f2 00 c0       	push   $0xc000f248
c0008e1c:	68 08 f5 00 c0       	push   $0xc000f508
c0008e21:	68 74 03 00 00       	push   $0x374
c0008e26:	68 41 eb 00 c0       	push   $0xc000eb41
c0008e2b:	e8 31 97 ff ff       	call   c0002561 <panic_spin>
c0008e30:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:889 (discriminator 1)
	/* 至此 full_path_reverse 中的路径是反着的,
	 * 即子目录在前(左),父目录在后(右) ,
	 * 现将full_path_reverse中的路径反置 */
	char* last_slash;	// 用于记录字符串中最后一个斜杠地址
	while ((last_slash = strrchr(full_path_reverse, '/'))) {
c0008e33:	eb 30                	jmp    c0008e65 <sys_getcwd+0x1bf>
/work/x86_os_my/fs/fs.c:890
		uint16_t len = strlen(buf);
c0008e35:	83 ec 0c             	sub    $0xc,%esp
c0008e38:	ff 75 08             	pushl  0x8(%ebp)
c0008e3b:	e8 af ad ff ff       	call   c0003bef <strlen>
c0008e40:	83 c4 10             	add    $0x10,%esp
c0008e43:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
/work/x86_os_my/fs/fs.c:891
		strcpy(buf + len, last_slash);
c0008e47:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
c0008e4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0008e4e:	01 d0                	add    %edx,%eax
c0008e50:	83 ec 08             	sub    $0x8,%esp
c0008e53:	ff 75 e4             	pushl  -0x1c(%ebp)
c0008e56:	50                   	push   %eax
c0008e57:	e8 3e ad ff ff       	call   c0003b9a <strcpy>
c0008e5c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:893
		/* 在full_path_reverse中添加结束字符,做为下一次执行strcpy中last_slash的边界 */
		*last_slash = 0;
c0008e5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0008e62:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:889
	ASSERT(strlen(full_path_reverse) <= size);
	/* 至此 full_path_reverse 中的路径是反着的,
	 * 即子目录在前(左),父目录在后(右) ,
	 * 现将full_path_reverse中的路径反置 */
	char* last_slash;	// 用于记录字符串中最后一个斜杠地址
	while ((last_slash = strrchr(full_path_reverse, '/'))) {
c0008e65:	83 ec 08             	sub    $0x8,%esp
c0008e68:	6a 2f                	push   $0x2f
c0008e6a:	8d 85 e2 fd ff ff    	lea    -0x21e(%ebp),%eax
c0008e70:	50                   	push   %eax
c0008e71:	e8 95 ae ff ff       	call   c0003d0b <strrchr>
c0008e76:	83 c4 10             	add    $0x10,%esp
c0008e79:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0008e7c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0008e80:	75 b3                	jne    c0008e35 <sys_getcwd+0x18f>
/work/x86_os_my/fs/fs.c:895
		uint16_t len = strlen(buf);
		strcpy(buf + len, last_slash);
		/* 在full_path_reverse中添加结束字符,做为下一次执行strcpy中last_slash的边界 */
		*last_slash = 0;
	}
	sys_free(io_buf);
c0008e82:	83 ec 0c             	sub    $0xc,%esp
c0008e85:	ff 75 f0             	pushl  -0x10(%ebp)
c0008e88:	e8 ac a6 ff ff       	call   c0003539 <sys_free>
c0008e8d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:896
	return buf;
c0008e90:	8b 45 08             	mov    0x8(%ebp),%eax
/work/x86_os_my/fs/fs.c:897 (discriminator 2)
}
c0008e93:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0008e96:	5b                   	pop    %ebx
c0008e97:	5f                   	pop    %edi
c0008e98:	5d                   	pop    %ebp
c0008e99:	c3                   	ret    

c0008e9a <sys_chdir>:
sys_chdir():
/work/x86_os_my/fs/fs.c:900

/* 更改当前工作目录为绝对路径path,成功则返回0,失败返回-1 */
int32_t sys_chdir(const char* path) {
c0008e9a:	55                   	push   %ebp
c0008e9b:	89 e5                	mov    %esp,%ebp
c0008e9d:	81 ec 18 02 00 00    	sub    $0x218,%esp
/work/x86_os_my/fs/fs.c:901
	int32_t ret = -1;
c0008ea3:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:903
	struct path_search_record searched_record;
	memset(&searched_record, 0, sizeof(struct path_search_record));
c0008eaa:	83 ec 04             	sub    $0x4,%esp
c0008ead:	68 08 02 00 00       	push   $0x208
c0008eb2:	6a 00                	push   $0x0
c0008eb4:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c0008eba:	50                   	push   %eax
c0008ebb:	e8 a5 ab ff ff       	call   c0003a65 <memset>
c0008ec0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:904
	int inode_no = search_file(path, &searched_record);
c0008ec3:	83 ec 08             	sub    $0x8,%esp
c0008ec6:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c0008ecc:	50                   	push   %eax
c0008ecd:	ff 75 08             	pushl  0x8(%ebp)
c0008ed0:	e8 14 e9 ff ff       	call   c00077e9 <search_file>
c0008ed5:	83 c4 10             	add    $0x10,%esp
c0008ed8:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:905
	if (inode_no != -1) {
c0008edb:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0008edf:	74 34                	je     c0008f15 <sys_chdir+0x7b>
/work/x86_os_my/fs/fs.c:906
		if (searched_record.file_type == FT_DIRECTORY) {
c0008ee1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008ee4:	83 f8 02             	cmp    $0x2,%eax
c0008ee7:	75 19                	jne    c0008f02 <sys_chdir+0x68>
/work/x86_os_my/fs/fs.c:907
			running_thread()->cwd_inode_nr = inode_no;
c0008ee9:	e8 5e af ff ff       	call   c0003e4c <running_thread>
c0008eee:	89 c2                	mov    %eax,%edx
c0008ef0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0008ef3:	89 82 0c 01 00 00    	mov    %eax,0x10c(%edx)
/work/x86_os_my/fs/fs.c:908
			ret = 0;
c0008ef9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0008f00:	eb 13                	jmp    c0008f15 <sys_chdir+0x7b>
/work/x86_os_my/fs/fs.c:910
		} else {
			printk("sys_chdir: %s is regular file or other!\n", path);
c0008f02:	83 ec 08             	sub    $0x8,%esp
c0008f05:	ff 75 08             	pushl  0x8(%ebp)
c0008f08:	68 6c f2 00 c0       	push   $0xc000f26c
c0008f0d:	e8 3b e1 ff ff       	call   c000704d <printk>
c0008f12:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:913
		}
	}
	dir_close(searched_record.parent_dir);
c0008f15:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0008f18:	83 ec 0c             	sub    $0xc,%esp
c0008f1b:	50                   	push   %eax
c0008f1c:	e8 0e 1e 00 00       	call   c000ad2f <dir_close>
c0008f21:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:914
	return ret;
c0008f24:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:915
}
c0008f27:	c9                   	leave  
c0008f28:	c3                   	ret    

c0008f29 <sys_stat>:
sys_stat():
/work/x86_os_my/fs/fs.c:918

/* 在buf中填充文件结构相关信息,成功时返回0,失败返回-1 */
int32_t sys_stat(const char* path, struct stat* buf) {
c0008f29:	55                   	push   %ebp
c0008f2a:	89 e5                	mov    %esp,%ebp
c0008f2c:	81 ec 28 02 00 00    	sub    $0x228,%esp
/work/x86_os_my/fs/fs.c:920
	/* 若直接查看根目录'/' */
	if (!strcmp(path, "/") || !strcmp(path, "/.") || !strcmp(path, "/..")) {
c0008f32:	83 ec 08             	sub    $0x8,%esp
c0008f35:	68 bb ec 00 c0       	push   $0xc000ecbb
c0008f3a:	ff 75 08             	pushl  0x8(%ebp)
c0008f3d:	e8 f8 ac ff ff       	call   c0003c3a <strcmp>
c0008f42:	83 c4 10             	add    $0x10,%esp
c0008f45:	84 c0                	test   %al,%al
c0008f47:	74 2e                	je     c0008f77 <sys_stat+0x4e>
/work/x86_os_my/fs/fs.c:920 (discriminator 1)
c0008f49:	83 ec 08             	sub    $0x8,%esp
c0008f4c:	68 bd ec 00 c0       	push   $0xc000ecbd
c0008f51:	ff 75 08             	pushl  0x8(%ebp)
c0008f54:	e8 e1 ac ff ff       	call   c0003c3a <strcmp>
c0008f59:	83 c4 10             	add    $0x10,%esp
c0008f5c:	84 c0                	test   %al,%al
c0008f5e:	74 17                	je     c0008f77 <sys_stat+0x4e>
/work/x86_os_my/fs/fs.c:920 (discriminator 2)
c0008f60:	83 ec 08             	sub    $0x8,%esp
c0008f63:	68 c0 ec 00 c0       	push   $0xc000ecc0
c0008f68:	ff 75 08             	pushl  0x8(%ebp)
c0008f6b:	e8 ca ac ff ff       	call   c0003c3a <strcmp>
c0008f70:	83 c4 10             	add    $0x10,%esp
c0008f73:	84 c0                	test   %al,%al
c0008f75:	75 2b                	jne    c0008fa2 <sys_stat+0x79>
/work/x86_os_my/fs/fs.c:921
		buf->st_filetype = FT_DIRECTORY;
c0008f77:	8b 45 0c             	mov    0xc(%ebp),%eax
c0008f7a:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
/work/x86_os_my/fs/fs.c:922
		buf->st_ino = 0;
c0008f81:	8b 45 0c             	mov    0xc(%ebp),%eax
c0008f84:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:923
		buf->st_size = root_dir.inode->i_size;
c0008f8a:	a1 20 5a 01 c0       	mov    0xc0015a20,%eax
c0008f8f:	8b 50 04             	mov    0x4(%eax),%edx
c0008f92:	8b 45 0c             	mov    0xc(%ebp),%eax
c0008f95:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/fs.c:924
		return 0;
c0008f98:	b8 00 00 00 00       	mov    $0x0,%eax
c0008f9d:	e9 af 00 00 00       	jmp    c0009051 <sys_stat+0x128>
/work/x86_os_my/fs/fs.c:927
	}

	int32_t ret = -1;	// 默认返回值
c0008fa2:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:929
	struct path_search_record searched_record;
	memset(&searched_record, 0, sizeof(struct path_search_record));   // 记得初始化或清0,否则栈中信息不知道是什么
c0008fa9:	83 ec 04             	sub    $0x4,%esp
c0008fac:	68 08 02 00 00       	push   $0x208
c0008fb1:	6a 00                	push   $0x0
c0008fb3:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0008fb9:	50                   	push   %eax
c0008fba:	e8 a6 aa ff ff       	call   c0003a65 <memset>
c0008fbf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:930
	int inode_no = search_file(path, &searched_record);
c0008fc2:	83 ec 08             	sub    $0x8,%esp
c0008fc5:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0008fcb:	50                   	push   %eax
c0008fcc:	ff 75 08             	pushl  0x8(%ebp)
c0008fcf:	e8 15 e8 ff ff       	call   c00077e9 <search_file>
c0008fd4:	83 c4 10             	add    $0x10,%esp
c0008fd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:931
	if (inode_no != -1) {
c0008fda:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0008fde:	74 4c                	je     c000902c <sys_stat+0x103>
/work/x86_os_my/fs/fs.c:932
		struct inode* obj_inode = inode_open(cur_part, inode_no);   // 只为获得文件大小
c0008fe0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008fe3:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0008fe8:	83 ec 08             	sub    $0x8,%esp
c0008feb:	52                   	push   %edx
c0008fec:	50                   	push   %eax
c0008fed:	e8 54 04 00 00       	call   c0009446 <inode_open>
c0008ff2:	83 c4 10             	add    $0x10,%esp
c0008ff5:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:933
		buf->st_size = obj_inode->i_size;
c0008ff8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008ffb:	8b 50 04             	mov    0x4(%eax),%edx
c0008ffe:	8b 45 0c             	mov    0xc(%ebp),%eax
c0009001:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/fs.c:934
		inode_close(obj_inode);
c0009004:	83 ec 0c             	sub    $0xc,%esp
c0009007:	ff 75 ec             	pushl  -0x14(%ebp)
c000900a:	e8 7d 05 00 00       	call   c000958c <inode_close>
c000900f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:935
		buf->st_filetype = searched_record.file_type;
c0009012:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0009015:	8b 45 0c             	mov    0xc(%ebp),%eax
c0009018:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/fs/fs.c:936
		buf->st_ino = inode_no;
c000901b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000901e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0009021:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/fs.c:937
		ret = 0;
c0009023:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000902a:	eb 13                	jmp    c000903f <sys_stat+0x116>
/work/x86_os_my/fs/fs.c:939
	} else {
		printk("sys_stat: %s not found\n", path);
c000902c:	83 ec 08             	sub    $0x8,%esp
c000902f:	ff 75 08             	pushl  0x8(%ebp)
c0009032:	68 95 f2 00 c0       	push   $0xc000f295
c0009037:	e8 11 e0 ff ff       	call   c000704d <printk>
c000903c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:941
	}
	dir_close(searched_record.parent_dir);
c000903f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0009042:	83 ec 0c             	sub    $0xc,%esp
c0009045:	50                   	push   %eax
c0009046:	e8 e4 1c 00 00       	call   c000ad2f <dir_close>
c000904b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:942
	return ret;
c000904e:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:943 (discriminator 1)
}
c0009051:	c9                   	leave  
c0009052:	c3                   	ret    

c0009053 <sys_putchar>:
sys_putchar():
/work/x86_os_my/fs/fs.c:946

/* 向屏幕输出一个字符 */
void sys_putchar(char char_asci) {
c0009053:	55                   	push   %ebp
c0009054:	89 e5                	mov    %esp,%ebp
c0009056:	83 ec 18             	sub    $0x18,%esp
c0009059:	8b 45 08             	mov    0x8(%ebp),%eax
c000905c:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:947
	console_put_char(char_asci);
c000905f:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0009063:	0f b6 c0             	movzbl %al,%eax
c0009066:	83 ec 0c             	sub    $0xc,%esp
c0009069:	50                   	push   %eax
c000906a:	e8 42 bc ff ff       	call   c0004cb1 <console_put_char>
c000906f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:948
}
c0009072:	90                   	nop
c0009073:	c9                   	leave  
c0009074:	c3                   	ret    

c0009075 <sys_help>:
sys_help():
/work/x86_os_my/fs/fs.c:951

/* 显示系统支持的内部命令 */
void sys_help(void) {
c0009075:	55                   	push   %ebp
c0009076:	89 e5                	mov    %esp,%ebp
c0009078:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/fs/fs.c:952
   printk("\
c000907b:	83 ec 0c             	sub    $0xc,%esp
c000907e:	68 b0 f2 00 c0       	push   $0xc000f2b0
c0009083:	e8 c5 df ff ff       	call   c000704d <printk>
c0009088:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:965
		ps: show process information\n\
	clear: clear screen\n\
		shortcut key:\n\
		ctrl+l: clear screen\n\
		ctrl+u: clear input\n\n");
}
c000908b:	90                   	nop
c000908c:	c9                   	leave  
c000908d:	c3                   	ret    

c000908e <filesys_init>:
filesys_init():
/work/x86_os_my/fs/fs.c:977
 * 只支持 partition_format 函数创建的文件系统，其魔数等于 0x19590318
 * 三层循环：遍历通道，遍历通道中的硬盘，遍历硬盘上的分区
 * 全局变量 channel_cnt 通道数，定义在 ide.c
 * 全局变量 channels 结构体，定义在 ide.c
 */
void filesys_init() {
c000908e:	55                   	push   %ebp
c000908f:	89 e5                	mov    %esp,%ebp
c0009091:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/fs/fs.c:978
	uint8_t channel_no = 0, dev_no, part_idx = 0;
c0009094:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
c0009098:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
/work/x86_os_my/fs/fs.c:981

	/* sb_buf用来存储从硬盘上读入的超级块 */
	struct super_block* sb_buf = (struct super_block*)sys_malloc(SECTOR_SIZE);
c000909c:	83 ec 0c             	sub    $0xc,%esp
c000909f:	68 00 02 00 00       	push   $0x200
c00090a4:	e8 63 9e ff ff       	call   c0002f0c <sys_malloc>
c00090a9:	83 c4 10             	add    $0x10,%esp
c00090ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:982
	if (sb_buf == NULL) {
c00090af:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c00090b3:	75 1c                	jne    c00090d1 <filesys_init+0x43>
/work/x86_os_my/fs/fs.c:983
		PANIC("alloc memory failed!");
c00090b5:	68 2c eb 00 c0       	push   $0xc000eb2c
c00090ba:	68 14 f5 00 c0       	push   $0xc000f514
c00090bf:	68 d7 03 00 00       	push   $0x3d7
c00090c4:	68 41 eb 00 c0       	push   $0xc000eb41
c00090c9:	e8 93 94 ff ff       	call   c0002561 <panic_spin>
c00090ce:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:986
	}

	printk("searching filesystem......\n");
c00090d1:	83 ec 0c             	sub    $0xc,%esp
c00090d4:	68 00 f4 00 c0       	push   $0xc000f400
c00090d9:	e8 6f df ff ff       	call   c000704d <printk>
c00090de:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:988
	/* 遍历通道 */
	while (channel_no < channel_cnt) {
c00090e1:	e9 1a 01 00 00       	jmp    c0009200 <filesys_init+0x172>
/work/x86_os_my/fs/fs.c:989
		dev_no = 0;
c00090e6:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
/work/x86_os_my/fs/fs.c:991
		/* 遍历通道里的硬盘 */
		while(dev_no < 2) {
c00090ea:	e9 fd 00 00 00       	jmp    c00091ec <filesys_init+0x15e>
/work/x86_os_my/fs/fs.c:992
			if (dev_no == 0) {		// 跨过裸盘hd60M.img
c00090ef:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c00090f3:	75 0f                	jne    c0009104 <filesys_init+0x76>
/work/x86_os_my/fs/fs.c:993
				dev_no++;
c00090f5:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c00090f9:	83 c0 01             	add    $0x1,%eax
c00090fc:	88 45 f6             	mov    %al,-0xa(%ebp)
/work/x86_os_my/fs/fs.c:994
				continue;
c00090ff:	e9 e8 00 00 00       	jmp    c00091ec <filesys_init+0x15e>
/work/x86_os_my/fs/fs.c:996
			}
			struct disk* hd = &channels[channel_no].devices[dev_no];
c0009104:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0009108:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
c000910c:	69 d2 10 03 00 00    	imul   $0x310,%edx,%edx
c0009112:	69 c0 60 06 00 00    	imul   $0x660,%eax,%eax
c0009118:	01 d0                	add    %edx,%eax
c000911a:	83 c0 40             	add    $0x40,%eax
c000911d:	05 c0 4b 01 c0       	add    $0xc0014bc0,%eax
c0009122:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/fs.c:997
			struct partition* part = hd->prim_parts;	// 主分区数组
c0009125:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0009128:	83 c0 10             	add    $0x10,%eax
c000912b:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:999
			/* 遍历硬盘里的分区 */
			while(part_idx < 12) {						// 4个主分区+8个逻辑
c000912e:	e9 a5 00 00 00       	jmp    c00091d8 <filesys_init+0x14a>
/work/x86_os_my/fs/fs.c:1000
				if (part_idx == 4) {
c0009133:	80 7d f5 04          	cmpb   $0x4,-0xb(%ebp)
c0009137:	75 0b                	jne    c0009144 <filesys_init+0xb6>
/work/x86_os_my/fs/fs.c:1001
					part = hd->logic_parts;				// 逻辑分区数组
c0009139:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000913c:	05 10 01 00 00       	add    $0x110,%eax
c0009141:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:1006
				}

				/* channels数组是全局变量,默认值为0
				 * 固 channels.disk.partition.sec_cnt 在未初始化时，也为0 */
				if (part->sec_cnt != 0) {	// 如果分区存在，以sec_cnt是否为0当判断依据
c0009144:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0009147:	8b 40 04             	mov    0x4(%eax),%eax
c000914a:	85 c0                	test   %eax,%eax
c000914c:	74 7c                	je     c00091ca <filesys_init+0x13c>
/work/x86_os_my/fs/fs.c:1007
					memset(sb_buf, 0, SECTOR_SIZE);
c000914e:	83 ec 04             	sub    $0x4,%esp
c0009151:	68 00 02 00 00       	push   $0x200
c0009156:	6a 00                	push   $0x0
c0009158:	ff 75 e8             	pushl  -0x18(%ebp)
c000915b:	e8 05 a9 ff ff       	call   c0003a65 <memset>
c0009160:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:1010

					/* 读出分区的超级块，根据魔数判断是否存在我们定义的文件系统  */
					ide_read(hd, part->start_lba + 1, sb_buf, 1);
c0009163:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0009166:	8b 00                	mov    (%eax),%eax
c0009168:	83 c0 01             	add    $0x1,%eax
c000916b:	6a 01                	push   $0x1
c000916d:	ff 75 e8             	pushl  -0x18(%ebp)
c0009170:	50                   	push   %eax
c0009171:	ff 75 e4             	pushl  -0x1c(%ebp)
c0009174:	e8 5b d4 ff ff       	call   c00065d4 <ide_read>
c0009179:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:1011
					if (sb_buf->magic == 0x19590318) {
c000917c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000917f:	8b 00                	mov    (%eax),%eax
c0009181:	3d 18 03 59 19       	cmp    $0x19590318,%eax
c0009186:	75 19                	jne    c00091a1 <filesys_init+0x113>
/work/x86_os_my/fs/fs.c:1012
						printk("%s has filesystem\n", part->name);
c0009188:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000918b:	83 c0 14             	add    $0x14,%eax
c000918e:	83 ec 08             	sub    $0x8,%esp
c0009191:	50                   	push   %eax
c0009192:	68 1c f4 00 c0       	push   $0xc000f41c
c0009197:	e8 b1 de ff ff       	call   c000704d <printk>
c000919c:	83 c4 10             	add    $0x10,%esp
c000919f:	eb 29                	jmp    c00091ca <filesys_init+0x13c>
/work/x86_os_my/fs/fs.c:1015
					} else {
						// 不存在我们的文件系统，则进行格式化
						printk("formatting %s`s partition %s......\n", hd->name, part->name);
c00091a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00091a4:	8d 50 14             	lea    0x14(%eax),%edx
c00091a7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00091aa:	83 ec 04             	sub    $0x4,%esp
c00091ad:	52                   	push   %edx
c00091ae:	50                   	push   %eax
c00091af:	68 30 f4 00 c0       	push   $0xc000f430
c00091b4:	e8 94 de ff ff       	call   c000704d <printk>
c00091b9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:1016
						partition_format(part);
c00091bc:	83 ec 0c             	sub    $0xc,%esp
c00091bf:	ff 75 f0             	pushl  -0x10(%ebp)
c00091c2:	e8 ed e0 ff ff       	call   c00072b4 <partition_format>
c00091c7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:1019
					}
				}
				part_idx++;
c00091ca:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
c00091ce:	83 c0 01             	add    $0x1,%eax
c00091d1:	88 45 f5             	mov    %al,-0xb(%ebp)
/work/x86_os_my/fs/fs.c:1020
				part++;
c00091d4:	83 45 f0 40          	addl   $0x40,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:999
				continue;
			}
			struct disk* hd = &channels[channel_no].devices[dev_no];
			struct partition* part = hd->prim_parts;	// 主分区数组
			/* 遍历硬盘里的分区 */
			while(part_idx < 12) {						// 4个主分区+8个逻辑
c00091d8:	80 7d f5 0b          	cmpb   $0xb,-0xb(%ebp)
c00091dc:	0f 86 51 ff ff ff    	jbe    c0009133 <filesys_init+0xa5>
/work/x86_os_my/fs/fs.c:1022
					}
				}
				part_idx++;
				part++;
			}	/* end of 遍历分区 */
			dev_no++;
c00091e2:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c00091e6:	83 c0 01             	add    $0x1,%eax
c00091e9:	88 45 f6             	mov    %al,-0xa(%ebp)
/work/x86_os_my/fs/fs.c:991
	printk("searching filesystem......\n");
	/* 遍历通道 */
	while (channel_no < channel_cnt) {
		dev_no = 0;
		/* 遍历通道里的硬盘 */
		while(dev_no < 2) {
c00091ec:	80 7d f6 01          	cmpb   $0x1,-0xa(%ebp)
c00091f0:	0f 86 f9 fe ff ff    	jbe    c00090ef <filesys_init+0x61>
/work/x86_os_my/fs/fs.c:1024
				part_idx++;
				part++;
			}	/* end of 遍历分区 */
			dev_no++;
		}	/* end of 遍历硬盘 */
		channel_no++;
c00091f6:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00091fa:	83 c0 01             	add    $0x1,%eax
c00091fd:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:988
		PANIC("alloc memory failed!");
	}

	printk("searching filesystem......\n");
	/* 遍历通道 */
	while (channel_no < channel_cnt) {
c0009200:	0f b6 05 a0 4b 01 c0 	movzbl 0xc0014ba0,%eax
c0009207:	38 45 f7             	cmp    %al,-0x9(%ebp)
c000920a:	0f 82 d6 fe ff ff    	jb     c00090e6 <filesys_init+0x58>
/work/x86_os_my/fs/fs.c:1026
			}	/* end of 遍历分区 */
			dev_no++;
		}	/* end of 遍历硬盘 */
		channel_no++;
	}	/* end of 遍历通道 */
	sys_free(sb_buf);
c0009210:	83 ec 0c             	sub    $0xc,%esp
c0009213:	ff 75 e8             	pushl  -0x18(%ebp)
c0009216:	e8 1e a3 ff ff       	call   c0003539 <sys_free>
c000921b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:1031


	/* 挂载分区 */
	/* 默认操作的分区 */
	char default_part[8] = "sdb1";
c000921e:	c7 45 dc 73 64 62 31 	movl   $0x31626473,-0x24(%ebp)
c0009225:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
/work/x86_os_my/fs/fs.c:1042
	参数：
	partition_list 是所有分区的链表
	mount_partition 是挂载分区的函数
	(int)default_part 将数组地址转换成整型作为 mount_partition 的参数
	*/
	list_traversal(&partition_list, mount_partition, (int)default_part);
c000922c:	8d 45 dc             	lea    -0x24(%ebp),%eax
c000922f:	83 ec 04             	sub    $0x4,%esp
c0009232:	50                   	push   %eax
c0009233:	68 a9 70 00 c0       	push   $0xc00070a9
c0009238:	68 80 58 01 c0       	push   $0xc0015880
c000923d:	e8 3d b9 ff ff       	call   c0004b7f <list_traversal>
c0009242:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:1046


	/* 将当前分区的根目录打开 + 初始化文件表 */
	open_root_dir(cur_part);
c0009245:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000924a:	83 ec 0c             	sub    $0xc,%esp
c000924d:	50                   	push   %eax
c000924e:	e8 94 18 00 00       	call   c000aae7 <open_root_dir>
c0009253:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:1047
	uint32_t fd_idx = 0;
c0009256:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:1048
	while (fd_idx < MAX_FILE_OPEN) {
c000925d:	eb 1d                	jmp    c000927c <filesys_init+0x1ee>
/work/x86_os_my/fs/fs.c:1049
		file_table[fd_idx++].fd_inode = NULL;
c000925f:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0009262:	8d 42 01             	lea    0x1(%edx),%eax
c0009265:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0009268:	89 d0                	mov    %edx,%eax
c000926a:	01 c0                	add    %eax,%eax
c000926c:	01 d0                	add    %edx,%eax
c000926e:	c1 e0 02             	shl    $0x2,%eax
c0009271:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c0009276:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:1048


	/* 将当前分区的根目录打开 + 初始化文件表 */
	open_root_dir(cur_part);
	uint32_t fd_idx = 0;
	while (fd_idx < MAX_FILE_OPEN) {
c000927c:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
c0009280:	76 dd                	jbe    c000925f <filesys_init+0x1d1>
/work/x86_os_my/fs/fs.c:1051
		file_table[fd_idx++].fd_inode = NULL;
	}
}
c0009282:	90                   	nop
c0009283:	c9                   	leave  
c0009284:	c3                   	ret    

c0009285 <inode_locate>:
inode_locate():
/work/x86_os_my/fs/inode.c:23
};

/* 获取inode所在的扇区和扇区内的偏移量
 * out: inode_pos
 */
static void inode_locate(struct partition* part, uint32_t inode_no, struct inode_position* inode_pos) {
c0009285:	55                   	push   %ebp
c0009286:	89 e5                	mov    %esp,%ebp
c0009288:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/fs/inode.c:25
	/* inode_table在硬盘上是连续的 */
	ASSERT(inode_no < 4096);
c000928b:	81 7d 0c ff 0f 00 00 	cmpl   $0xfff,0xc(%ebp)
c0009292:	76 19                	jbe    c00092ad <inode_locate+0x28>
/work/x86_os_my/fs/inode.c:25 (discriminator 1)
c0009294:	68 24 f5 00 c0       	push   $0xc000f524
c0009299:	68 ac f5 00 c0       	push   $0xc000f5ac
c000929e:	6a 19                	push   $0x19
c00092a0:	68 34 f5 00 c0       	push   $0xc000f534
c00092a5:	e8 b7 92 ff ff       	call   c0002561 <panic_spin>
c00092aa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:26
	uint32_t inode_table_lba = part->sb->inode_table_lba;
c00092ad:	8b 45 08             	mov    0x8(%ebp),%eax
c00092b0:	8b 40 1c             	mov    0x1c(%eax),%eax
c00092b3:	8b 40 20             	mov    0x20(%eax),%eax
c00092b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/inode.c:28

	uint32_t inode_size = sizeof(struct inode);
c00092b9:	c7 45 f0 4c 00 00 00 	movl   $0x4c,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:29
	uint32_t off_size = inode_no * inode_size;	// 第inode_no号inode相对于inode_table_lba的字节偏移量
c00092c0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00092c3:	0f af 45 f0          	imul   -0x10(%ebp),%eax
c00092c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:30
	uint32_t off_sec  = off_size / 512;			// 第inode_no号inode相对于inode_table_lba的扇区偏移量
c00092ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00092cd:	c1 e8 09             	shr    $0x9,%eax
c00092d0:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/inode.c:31
	uint32_t off_size_in_sec = off_size % 512;	// 待查找的inode所在扇区中的起始地址
c00092d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00092d6:	25 ff 01 00 00       	and    $0x1ff,%eax
c00092db:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/inode.c:34

	/* 判断此inode是否跨越2个扇区 */
	uint32_t left_in_sec = 512 - off_size_in_sec;
c00092de:	b8 00 02 00 00       	mov    $0x200,%eax
c00092e3:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c00092e6:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/inode.c:36
	// 若扇区内剩下的空间不足以容纳一个inode,必然是inode跨越了2个扇区
	if (left_in_sec < inode_size ) {
c00092e9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00092ec:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00092ef:	73 0b                	jae    c00092fc <inode_locate+0x77>
/work/x86_os_my/fs/inode.c:37
		inode_pos->two_sec = true;	//跨越了
c00092f1:	8b 45 10             	mov    0x10(%ebp),%eax
c00092f4:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
c00092fa:	eb 09                	jmp    c0009305 <inode_locate+0x80>
/work/x86_os_my/fs/inode.c:39
	} else {
		inode_pos->two_sec = false;
c00092fc:	8b 45 10             	mov    0x10(%ebp),%eax
c00092ff:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/inode.c:41
	}
	inode_pos->sec_lba = inode_table_lba + off_sec;
c0009305:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0009308:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000930b:	01 c2                	add    %eax,%edx
c000930d:	8b 45 10             	mov    0x10(%ebp),%eax
c0009310:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/inode.c:42
	inode_pos->off_size = off_size_in_sec;
c0009313:	8b 45 10             	mov    0x10(%ebp),%eax
c0009316:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0009319:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/fs/inode.c:43
}
c000931c:	90                   	nop
c000931d:	c9                   	leave  
c000931e:	c3                   	ret    

c000931f <inode_sync>:
inode_sync():
/work/x86_os_my/fs/inode.c:51
io_buf是用于硬盘io的缓冲区，它由主调函数提供！
原因是
一般情况下把内存中的数据同步到硬盘都是最后的操作，其前已经做了大量工作，
若到这最后一步时才申请内存失败，前面的所有操作都白费了，还要回滚到之前的旧状态，代价太大
*/
void inode_sync(struct partition* part, struct inode* inode, void* io_buf) {
c000931f:	55                   	push   %ebp
c0009320:	89 e5                	mov    %esp,%ebp
c0009322:	83 ec 68             	sub    $0x68,%esp
/work/x86_os_my/fs/inode.c:52
	uint8_t inode_no = inode->i_no;
c0009325:	8b 45 0c             	mov    0xc(%ebp),%eax
c0009328:	8b 00                	mov    (%eax),%eax
c000932a:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/inode.c:54
	struct inode_position inode_pos;
	inode_locate(part, inode_no, &inode_pos);	// inode位置信息会存入inode_pos
c000932d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0009331:	83 ec 04             	sub    $0x4,%esp
c0009334:	8d 55 e4             	lea    -0x1c(%ebp),%edx
c0009337:	52                   	push   %edx
c0009338:	50                   	push   %eax
c0009339:	ff 75 08             	pushl  0x8(%ebp)
c000933c:	e8 44 ff ff ff       	call   c0009285 <inode_locate>
c0009341:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:55
	ASSERT(inode_pos.sec_lba <= (part->start_lba + part->sec_cnt));
c0009344:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0009347:	8b 45 08             	mov    0x8(%ebp),%eax
c000934a:	8b 08                	mov    (%eax),%ecx
c000934c:	8b 45 08             	mov    0x8(%ebp),%eax
c000934f:	8b 40 04             	mov    0x4(%eax),%eax
c0009352:	01 c8                	add    %ecx,%eax
c0009354:	39 c2                	cmp    %eax,%edx
c0009356:	76 19                	jbe    c0009371 <inode_sync+0x52>
/work/x86_os_my/fs/inode.c:55 (discriminator 1)
c0009358:	68 40 f5 00 c0       	push   $0xc000f540
c000935d:	68 bc f5 00 c0       	push   $0xc000f5bc
c0009362:	6a 37                	push   $0x37
c0009364:	68 34 f5 00 c0       	push   $0xc000f534
c0009369:	e8 f3 91 ff ff       	call   c0002561 <panic_spin>
c000936e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:62
	/* 硬盘中的inode中的成员inode_tag和i_open_cnts是不需要的，
	* 它们只在内存中有效，记录链表位置和被多少进程共享，
	* 将inode同步到硬盘时,清掉这三项即可。
	*/
	struct inode pure_inode;
	memcpy(&pure_inode, inode, sizeof(struct inode));
c0009371:	83 ec 04             	sub    $0x4,%esp
c0009374:	6a 4c                	push   $0x4c
c0009376:	ff 75 0c             	pushl  0xc(%ebp)
c0009379:	8d 45 98             	lea    -0x68(%ebp),%eax
c000937c:	50                   	push   %eax
c000937d:	e8 35 a7 ff ff       	call   c0003ab7 <memcpy>
c0009382:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:63
	pure_inode.i_open_cnts = 0;
c0009385:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
/work/x86_os_my/fs/inode.c:64
	pure_inode.write_deny = false;	// 置为false,以保证在硬盘中读出时为可写
c000938c:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
/work/x86_os_my/fs/inode.c:65
	pure_inode.inode_tag.prev = pure_inode.inode_tag.next = NULL;
c0009393:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c000939a:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000939d:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/inode.c:67

	char* inode_buf = (char*)io_buf;
c00093a0:	8b 45 10             	mov    0x10(%ebp),%eax
c00093a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:69
	// 若inode结构，跨了两个扇区,就要读出两个扇区再写入两个扇区
	if (inode_pos.two_sec) {
c00093a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00093a9:	85 c0                	test   %eax,%eax
c00093ab:	74 4c                	je     c00093f9 <inode_sync+0xda>
/work/x86_os_my/fs/inode.c:72
		/* 读写硬盘是以扇区为单位的
		所以需要将待写入的inode结构拼入到这2个扇区的中间位置 */
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 2);	// inode_table在格式化时，写入硬盘是连续写入的，所以读入2块扇区
c00093ad:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00093b0:	8b 45 08             	mov    0x8(%ebp),%eax
c00093b3:	8b 40 08             	mov    0x8(%eax),%eax
c00093b6:	6a 02                	push   $0x2
c00093b8:	ff 75 f0             	pushl  -0x10(%ebp)
c00093bb:	52                   	push   %edx
c00093bc:	50                   	push   %eax
c00093bd:	e8 12 d2 ff ff       	call   c00065d4 <ide_read>
c00093c2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:73
		memcpy((inode_buf + inode_pos.off_size), &pure_inode, sizeof(struct inode));	// inode_buf+inode在扇区中的偏移
c00093c5:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00093c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00093cb:	01 c2                	add    %eax,%edx
c00093cd:	83 ec 04             	sub    $0x4,%esp
c00093d0:	6a 4c                	push   $0x4c
c00093d2:	8d 45 98             	lea    -0x68(%ebp),%eax
c00093d5:	50                   	push   %eax
c00093d6:	52                   	push   %edx
c00093d7:	e8 db a6 ff ff       	call   c0003ab7 <memcpy>
c00093dc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:74
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
c00093df:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00093e2:	8b 45 08             	mov    0x8(%ebp),%eax
c00093e5:	8b 40 08             	mov    0x8(%eax),%eax
c00093e8:	6a 02                	push   $0x2
c00093ea:	ff 75 f0             	pushl  -0x10(%ebp)
c00093ed:	52                   	push   %edx
c00093ee:	50                   	push   %eax
c00093ef:	e8 54 d3 ff ff       	call   c0006748 <ide_write>
c00093f4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:81
		// 若inode结构，只在一个扇区中
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
		memcpy((inode_buf + inode_pos.off_size), &pure_inode, sizeof(struct inode));	// inode_buf+inode在扇区中的偏移
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
	}
}
c00093f7:	eb 4a                	jmp    c0009443 <inode_sync+0x124>
/work/x86_os_my/fs/inode.c:77
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 2);	// inode_table在格式化时，写入硬盘是连续写入的，所以读入2块扇区
		memcpy((inode_buf + inode_pos.off_size), &pure_inode, sizeof(struct inode));	// inode_buf+inode在扇区中的偏移
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
	} else {
		// 若inode结构，只在一个扇区中
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
c00093f9:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00093fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00093ff:	8b 40 08             	mov    0x8(%eax),%eax
c0009402:	6a 01                	push   $0x1
c0009404:	ff 75 f0             	pushl  -0x10(%ebp)
c0009407:	52                   	push   %edx
c0009408:	50                   	push   %eax
c0009409:	e8 c6 d1 ff ff       	call   c00065d4 <ide_read>
c000940e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:78
		memcpy((inode_buf + inode_pos.off_size), &pure_inode, sizeof(struct inode));	// inode_buf+inode在扇区中的偏移
c0009411:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0009414:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0009417:	01 c2                	add    %eax,%edx
c0009419:	83 ec 04             	sub    $0x4,%esp
c000941c:	6a 4c                	push   $0x4c
c000941e:	8d 45 98             	lea    -0x68(%ebp),%eax
c0009421:	50                   	push   %eax
c0009422:	52                   	push   %edx
c0009423:	e8 8f a6 ff ff       	call   c0003ab7 <memcpy>
c0009428:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:79
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
c000942b:	8b 55 e8             	mov    -0x18(%ebp),%edx
c000942e:	8b 45 08             	mov    0x8(%ebp),%eax
c0009431:	8b 40 08             	mov    0x8(%eax),%eax
c0009434:	6a 01                	push   $0x1
c0009436:	ff 75 f0             	pushl  -0x10(%ebp)
c0009439:	52                   	push   %edx
c000943a:	50                   	push   %eax
c000943b:	e8 08 d3 ff ff       	call   c0006748 <ide_write>
c0009440:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:81
	}
}
c0009443:	90                   	nop
c0009444:	c9                   	leave  
c0009445:	c3                   	ret    

c0009446 <inode_open>:
inode_open():
/work/x86_os_my/fs/inode.c:84

/* 根据i结点号，获取到相应的inode结构，插入到inode缓存队列，并返回它 */
struct inode* inode_open(struct partition* part, uint32_t inode_no) {
c0009446:	55                   	push   %ebp
c0009447:	89 e5                	mov    %esp,%ebp
c0009449:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/fs/inode.c:86
	/* 1.先在已打开inode链表中找inode，此链表作用是提速 */
	struct list_elem* elem = part->open_inodes.head.next;
c000944c:	8b 45 08             	mov    0x8(%ebp),%eax
c000944f:	8b 40 34             	mov    0x34(%eax),%eax
c0009452:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/inode.c:88
	struct inode* inode_found;
	while (elem != &part->open_inodes.tail) {
c0009455:	eb 33                	jmp    c000948a <inode_open+0x44>
/work/x86_os_my/fs/inode.c:89
		inode_found = elem2entry(struct inode, inode_tag, elem);
c0009457:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000945a:	83 e8 44             	sub    $0x44,%eax
c000945d:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:90
		if (inode_found->i_no == inode_no) {
c0009460:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0009463:	8b 00                	mov    (%eax),%eax
c0009465:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0009468:	75 17                	jne    c0009481 <inode_open+0x3b>
/work/x86_os_my/fs/inode.c:91
			inode_found->i_open_cnts++;
c000946a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000946d:	8b 40 08             	mov    0x8(%eax),%eax
c0009470:	8d 50 01             	lea    0x1(%eax),%edx
c0009473:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0009476:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/fs/inode.c:92
			return inode_found;
c0009479:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000947c:	e9 09 01 00 00       	jmp    c000958a <inode_open+0x144>
/work/x86_os_my/fs/inode.c:94
		}
		elem = elem->next;
c0009481:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0009484:	8b 40 04             	mov    0x4(%eax),%eax
c0009487:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/inode.c:88
/* 根据i结点号，获取到相应的inode结构，插入到inode缓存队列，并返回它 */
struct inode* inode_open(struct partition* part, uint32_t inode_no) {
	/* 1.先在已打开inode链表中找inode，此链表作用是提速 */
	struct list_elem* elem = part->open_inodes.head.next;
	struct inode* inode_found;
	while (elem != &part->open_inodes.tail) {
c000948a:	8b 45 08             	mov    0x8(%ebp),%eax
c000948d:	83 c0 38             	add    $0x38,%eax
c0009490:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0009493:	75 c2                	jne    c0009457 <inode_open+0x11>
/work/x86_os_my/fs/inode.c:100
	}

	
	/* 2.open_inodes链表中找不到，从硬盘上读入此inode并加入到inode缓存链表 */
	struct inode_position inode_pos;	// 记录inode位置的结构
	inode_locate(part, inode_no, &inode_pos);
c0009495:	83 ec 04             	sub    $0x4,%esp
c0009498:	8d 45 d8             	lea    -0x28(%ebp),%eax
c000949b:	50                   	push   %eax
c000949c:	ff 75 0c             	pushl  0xc(%ebp)
c000949f:	ff 75 08             	pushl  0x8(%ebp)
c00094a2:	e8 de fd ff ff       	call   c0009285 <inode_locate>
c00094a7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:104

	/* 为使通过sys_malloc创建的新inode被所有任务共享，需要将inode置于内核空间
	故临时将cur_pbc->pgdir置为NULL，sys_malloc就会以为是从内核空间分配 */
	struct task_struct* cur = running_thread();
c00094aa:	e8 9d a9 ff ff       	call   c0003e4c <running_thread>
c00094af:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/inode.c:105
	uint32_t* cur_pagedir_bak = cur->pgdir;
c00094b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00094b5:	8b 40 54             	mov    0x54(%eax),%eax
c00094b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/inode.c:106
	cur->pgdir = NULL;
c00094bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00094be:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
/work/x86_os_my/fs/inode.c:107
	inode_found = (struct inode*)sys_malloc(sizeof(struct inode));
c00094c5:	83 ec 0c             	sub    $0xc,%esp
c00094c8:	6a 4c                	push   $0x4c
c00094ca:	e8 3d 9a ff ff       	call   c0002f0c <sys_malloc>
c00094cf:	83 c4 10             	add    $0x10,%esp
c00094d2:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:108
	cur->pgdir = cur_pagedir_bak;	// 恢复pgdir
c00094d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00094d8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00094db:	89 50 54             	mov    %edx,0x54(%eax)
/work/x86_os_my/fs/inode.c:111

	char* inode_buf;
	if (inode_pos.two_sec) {	// inode结构跨扇区了
c00094de:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00094e1:	85 c0                	test   %eax,%eax
c00094e3:	74 2d                	je     c0009512 <inode_open+0xcc>
/work/x86_os_my/fs/inode.c:112
		inode_buf = (char*)sys_malloc(1024);
c00094e5:	83 ec 0c             	sub    $0xc,%esp
c00094e8:	68 00 04 00 00       	push   $0x400
c00094ed:	e8 1a 9a ff ff       	call   c0002f0c <sys_malloc>
c00094f2:	83 c4 10             	add    $0x10,%esp
c00094f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:114
		// inode_table在格式化时，写入硬盘是连续写入的，所以可以连续读入2块扇区
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
c00094f8:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00094fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00094fe:	8b 40 08             	mov    0x8(%eax),%eax
c0009501:	6a 02                	push   $0x2
c0009503:	ff 75 f0             	pushl  -0x10(%ebp)
c0009506:	52                   	push   %edx
c0009507:	50                   	push   %eax
c0009508:	e8 c7 d0 ff ff       	call   c00065d4 <ide_read>
c000950d:	83 c4 10             	add    $0x10,%esp
c0009510:	eb 2b                	jmp    c000953d <inode_open+0xf7>
/work/x86_os_my/fs/inode.c:116
	} else {
		inode_buf = (char*)sys_malloc(512);
c0009512:	83 ec 0c             	sub    $0xc,%esp
c0009515:	68 00 02 00 00       	push   $0x200
c000951a:	e8 ed 99 ff ff       	call   c0002f0c <sys_malloc>
c000951f:	83 c4 10             	add    $0x10,%esp
c0009522:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:117
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
c0009525:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0009528:	8b 45 08             	mov    0x8(%ebp),%eax
c000952b:	8b 40 08             	mov    0x8(%eax),%eax
c000952e:	6a 01                	push   $0x1
c0009530:	ff 75 f0             	pushl  -0x10(%ebp)
c0009533:	52                   	push   %edx
c0009534:	50                   	push   %eax
c0009535:	e8 9a d0 ff ff       	call   c00065d4 <ide_read>
c000953a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:119
	}
	memcpy(inode_found, inode_buf + inode_pos.off_size, sizeof(struct inode));	// inode_buf+inode在扇区中的偏移
c000953d:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0009540:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0009543:	01 d0                	add    %edx,%eax
c0009545:	83 ec 04             	sub    $0x4,%esp
c0009548:	6a 4c                	push   $0x4c
c000954a:	50                   	push   %eax
c000954b:	ff 75 ec             	pushl  -0x14(%ebp)
c000954e:	e8 64 a5 ff ff       	call   c0003ab7 <memcpy>
c0009553:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:123

	
	/* 3.马上要用这个inode，固插入到队首 */
	list_push(&part->open_inodes, &inode_found->inode_tag);
c0009556:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0009559:	8d 50 44             	lea    0x44(%eax),%edx
c000955c:	8b 45 08             	mov    0x8(%ebp),%eax
c000955f:	83 c0 30             	add    $0x30,%eax
c0009562:	83 ec 08             	sub    $0x8,%esp
c0009565:	52                   	push   %edx
c0009566:	50                   	push   %eax
c0009567:	e8 40 b5 ff ff       	call   c0004aac <list_push>
c000956c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:124
	inode_found->i_open_cnts = 1;
c000956f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0009572:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/fs/inode.c:126

	sys_free(inode_buf);
c0009579:	83 ec 0c             	sub    $0xc,%esp
c000957c:	ff 75 f0             	pushl  -0x10(%ebp)
c000957f:	e8 b5 9f ff ff       	call   c0003539 <sys_free>
c0009584:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:127
	return inode_found;
c0009587:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/fs/inode.c:128 (discriminator 1)
}
c000958a:	c9                   	leave  
c000958b:	c3                   	ret    

c000958c <inode_close>:
inode_close():
/work/x86_os_my/fs/inode.c:132

/* 关闭inode或减少inode的打开数 */
//1.从inode队列踢掉 2.释放内核内存池中的这个inode内存
void inode_close(struct inode* inode) {
c000958c:	55                   	push   %ebp
c000958d:	89 e5                	mov    %esp,%ebp
c000958f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/inode.c:134
	/* 若没有进程再打开此文件,将此inode去掉并释放空间 */
	enum intr_status old_status = intr_disable();
c0009592:	e8 ee 85 ff ff       	call   c0001b85 <intr_disable>
c0009597:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/inode.c:135
	if (--inode->i_open_cnts == 0) {
c000959a:	8b 45 08             	mov    0x8(%ebp),%eax
c000959d:	8b 40 08             	mov    0x8(%eax),%eax
c00095a0:	8d 50 ff             	lea    -0x1(%eax),%edx
c00095a3:	8b 45 08             	mov    0x8(%ebp),%eax
c00095a6:	89 50 08             	mov    %edx,0x8(%eax)
c00095a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00095ac:	8b 40 08             	mov    0x8(%eax),%eax
c00095af:	85 c0                	test   %eax,%eax
c00095b1:	75 44                	jne    c00095f7 <inode_close+0x6b>
/work/x86_os_my/fs/inode.c:136
		list_remove(&inode->inode_tag);
c00095b3:	8b 45 08             	mov    0x8(%ebp),%eax
c00095b6:	83 c0 44             	add    $0x44,%eax
c00095b9:	83 ec 0c             	sub    $0xc,%esp
c00095bc:	50                   	push   %eax
c00095bd:	e8 26 b5 ff ff       	call   c0004ae8 <list_remove>
c00095c2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:139
		/* inode结构在内核空间，释放时要释放到内核内存池。
		pgdir为NULL时，sys_free认为是内核空间 */
		struct task_struct* cur = running_thread();
c00095c5:	e8 82 a8 ff ff       	call   c0003e4c <running_thread>
c00095ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:140
		uint32_t* cur_pagedir_bak = cur->pgdir;	// 进程自己页目录表的虚拟地址，加载到cr3时需转成物理地址
c00095cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00095d0:	8b 40 54             	mov    0x54(%eax),%eax
c00095d3:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:141
		cur->pgdir = NULL;
c00095d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00095d9:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
/work/x86_os_my/fs/inode.c:142
		sys_free(inode);
c00095e0:	83 ec 0c             	sub    $0xc,%esp
c00095e3:	ff 75 08             	pushl  0x8(%ebp)
c00095e6:	e8 4e 9f ff ff       	call   c0003539 <sys_free>
c00095eb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:143
		cur->pgdir = cur_pagedir_bak;
c00095ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00095f1:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00095f4:	89 50 54             	mov    %edx,0x54(%eax)
/work/x86_os_my/fs/inode.c:145
	}
	intr_set_status(old_status);
c00095f7:	83 ec 0c             	sub    $0xc,%esp
c00095fa:	ff 75 f4             	pushl  -0xc(%ebp)
c00095fd:	e8 ac 85 ff ff       	call   c0001bae <intr_set_status>
c0009602:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:146
}
c0009605:	90                   	nop
c0009606:	c9                   	leave  
c0009607:	c3                   	ret    

c0009608 <inode_delete>:
inode_delete():
/work/x86_os_my/fs/inode.c:149

/* 将硬盘分区part上，inode管理的数据块清空 */
void inode_delete(struct partition* part, uint32_t inode_no, void* io_buf) {
c0009608:	55                   	push   %ebp
c0009609:	89 e5                	mov    %esp,%ebp
c000960b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/inode.c:150
	ASSERT(inode_no < 4096);
c000960e:	81 7d 0c ff 0f 00 00 	cmpl   $0xfff,0xc(%ebp)
c0009615:	76 1c                	jbe    c0009633 <inode_delete+0x2b>
/work/x86_os_my/fs/inode.c:150 (discriminator 1)
c0009617:	68 24 f5 00 c0       	push   $0xc000f524
c000961c:	68 c8 f5 00 c0       	push   $0xc000f5c8
c0009621:	68 96 00 00 00       	push   $0x96
c0009626:	68 34 f5 00 c0       	push   $0xc000f534
c000962b:	e8 31 8f ff ff       	call   c0002561 <panic_spin>
c0009630:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:152
	struct inode_position inode_pos;
	inode_locate(part, inode_no, &inode_pos);	// 获取inode所在的扇区和扇区内的偏移量【这里是 inode_table 的空间】
c0009633:	83 ec 04             	sub    $0x4,%esp
c0009636:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0009639:	50                   	push   %eax
c000963a:	ff 75 0c             	pushl  0xc(%ebp)
c000963d:	ff 75 08             	pushl  0x8(%ebp)
c0009640:	e8 40 fc ff ff       	call   c0009285 <inode_locate>
c0009645:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:153
	ASSERT(inode_pos.sec_lba <= (part->start_lba + part->sec_cnt));
c0009648:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000964b:	8b 45 08             	mov    0x8(%ebp),%eax
c000964e:	8b 08                	mov    (%eax),%ecx
c0009650:	8b 45 08             	mov    0x8(%ebp),%eax
c0009653:	8b 40 04             	mov    0x4(%eax),%eax
c0009656:	01 c8                	add    %ecx,%eax
c0009658:	39 c2                	cmp    %eax,%edx
c000965a:	76 1c                	jbe    c0009678 <inode_delete+0x70>
/work/x86_os_my/fs/inode.c:153 (discriminator 1)
c000965c:	68 40 f5 00 c0       	push   $0xc000f540
c0009661:	68 c8 f5 00 c0       	push   $0xc000f5c8
c0009666:	68 99 00 00 00       	push   $0x99
c000966b:	68 34 f5 00 c0       	push   $0xc000f534
c0009670:	e8 ec 8e ff ff       	call   c0002561 <panic_spin>
c0009675:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:155

	char* inode_buf = (char*)io_buf;
c0009678:	8b 45 10             	mov    0x10(%ebp),%eax
c000967b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/inode.c:156
	if (inode_pos.two_sec) {	// inode跨扇区,读入2个扇区
c000967e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0009681:	85 c0                	test   %eax,%eax
c0009683:	74 4a                	je     c00096cf <inode_delete+0xc7>
/work/x86_os_my/fs/inode.c:158
		/* 将原硬盘上的内容先读出来 */
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
c0009685:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0009688:	8b 45 08             	mov    0x8(%ebp),%eax
c000968b:	8b 40 08             	mov    0x8(%eax),%eax
c000968e:	6a 02                	push   $0x2
c0009690:	ff 75 f4             	pushl  -0xc(%ebp)
c0009693:	52                   	push   %edx
c0009694:	50                   	push   %eax
c0009695:	e8 3a cf ff ff       	call   c00065d4 <ide_read>
c000969a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:160
		/* 将inode_buf清0 */
		memset((inode_buf + inode_pos.off_size), 0, sizeof(struct inode));	//清零 inode_table 中的一个 inode 结构
c000969d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00096a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00096a3:	01 d0                	add    %edx,%eax
c00096a5:	83 ec 04             	sub    $0x4,%esp
c00096a8:	6a 4c                	push   $0x4c
c00096aa:	6a 00                	push   $0x0
c00096ac:	50                   	push   %eax
c00096ad:	e8 b3 a3 ff ff       	call   c0003a65 <memset>
c00096b2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:162
		/* 用清0的内存数据覆盖磁盘 */
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
c00096b5:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00096b8:	8b 45 08             	mov    0x8(%ebp),%eax
c00096bb:	8b 40 08             	mov    0x8(%eax),%eax
c00096be:	6a 02                	push   $0x2
c00096c0:	ff 75 f4             	pushl  -0xc(%ebp)
c00096c3:	52                   	push   %edx
c00096c4:	50                   	push   %eax
c00096c5:	e8 7e d0 ff ff       	call   c0006748 <ide_write>
c00096ca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:171
		/* 将inode_buf清0 */
		memset((inode_buf + inode_pos.off_size), 0, sizeof(struct inode));
		/* 用清0的内存数据覆盖磁盘 */
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
	}
}
c00096cd:	eb 48                	jmp    c0009717 <inode_delete+0x10f>
/work/x86_os_my/fs/inode.c:165
		memset((inode_buf + inode_pos.off_size), 0, sizeof(struct inode));	//清零 inode_table 中的一个 inode 结构
		/* 用清0的内存数据覆盖磁盘 */
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
	} else {	// 未跨扇区,只读入1个扇区就好
		/* 将原硬盘上的内容先读出来 */
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
c00096cf:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00096d2:	8b 45 08             	mov    0x8(%ebp),%eax
c00096d5:	8b 40 08             	mov    0x8(%eax),%eax
c00096d8:	6a 01                	push   $0x1
c00096da:	ff 75 f4             	pushl  -0xc(%ebp)
c00096dd:	52                   	push   %edx
c00096de:	50                   	push   %eax
c00096df:	e8 f0 ce ff ff       	call   c00065d4 <ide_read>
c00096e4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:167
		/* 将inode_buf清0 */
		memset((inode_buf + inode_pos.off_size), 0, sizeof(struct inode));
c00096e7:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00096ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00096ed:	01 d0                	add    %edx,%eax
c00096ef:	83 ec 04             	sub    $0x4,%esp
c00096f2:	6a 4c                	push   $0x4c
c00096f4:	6a 00                	push   $0x0
c00096f6:	50                   	push   %eax
c00096f7:	e8 69 a3 ff ff       	call   c0003a65 <memset>
c00096fc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:169
		/* 用清0的内存数据覆盖磁盘 */
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
c00096ff:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0009702:	8b 45 08             	mov    0x8(%ebp),%eax
c0009705:	8b 40 08             	mov    0x8(%eax),%eax
c0009708:	6a 01                	push   $0x1
c000970a:	ff 75 f4             	pushl  -0xc(%ebp)
c000970d:	52                   	push   %edx
c000970e:	50                   	push   %eax
c000970f:	e8 34 d0 ff ff       	call   c0006748 <ide_write>
c0009714:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:171
	}
}
c0009717:	90                   	nop
c0009718:	c9                   	leave  
c0009719:	c3                   	ret    

c000971a <inode_release>:
inode_release():
/work/x86_os_my/fs/inode.c:179
（1）inode 位图
（2）inode_table
（3）inode 中 i_sectors[0～11]中的直接块和一级间接索引块表 i_sectors[12]中的间接块
（4）一级间接索引块表本身的扇区地址
 */
void inode_release(struct partition* part, uint32_t inode_no) {
c000971a:	55                   	push   %ebp
c000971b:	89 e5                	mov    %esp,%ebp
c000971d:	57                   	push   %edi
c000971e:	81 ec 44 02 00 00    	sub    $0x244,%esp
/work/x86_os_my/fs/inode.c:180
	struct inode* inode_to_del = inode_open(part, inode_no);
c0009724:	83 ec 08             	sub    $0x8,%esp
c0009727:	ff 75 0c             	pushl  0xc(%ebp)
c000972a:	ff 75 08             	pushl  0x8(%ebp)
c000972d:	e8 14 fd ff ff       	call   c0009446 <inode_open>
c0009732:	83 c4 10             	add    $0x10,%esp
c0009735:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:181
	ASSERT(inode_to_del->i_no == inode_no);
c0009738:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000973b:	8b 00                	mov    (%eax),%eax
c000973d:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0009740:	74 1c                	je     c000975e <inode_release+0x44>
/work/x86_os_my/fs/inode.c:181 (discriminator 1)
c0009742:	68 78 f5 00 c0       	push   $0xc000f578
c0009747:	68 d8 f5 00 c0       	push   $0xc000f5d8
c000974c:	68 b5 00 00 00       	push   $0xb5
c0009751:	68 34 f5 00 c0       	push   $0xc000f534
c0009756:	e8 06 8e ff ff       	call   c0002561 <panic_spin>
c000975b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:184

	/* 1 回收inode占用的所有块 */
	uint8_t block_idx = 0, block_cnt = 12;
c000975e:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
c0009762:	c6 45 f6 0c          	movb   $0xc,-0xa(%ebp)
/work/x86_os_my/fs/inode.c:186
	uint32_t block_bitmap_idx;
	uint32_t all_blocks[140] = {0};	  //12个直接块+128个间接块
c0009766:	8d 95 b8 fd ff ff    	lea    -0x248(%ebp),%edx
c000976c:	b8 00 00 00 00       	mov    $0x0,%eax
c0009771:	b9 8c 00 00 00       	mov    $0x8c,%ecx
c0009776:	89 d7                	mov    %edx,%edi
c0009778:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/fs/inode.c:189

	/* a 先将前12个直接块存入all_blocks */
	while (block_idx < 12) {
c000977a:	eb 22                	jmp    c000979e <inode_release+0x84>
/work/x86_os_my/fs/inode.c:190
		all_blocks[block_idx] = inode_to_del->i_sectors[block_idx];
c000977c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0009780:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
c0009784:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0009787:	83 c1 04             	add    $0x4,%ecx
c000978a:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
c000978d:	89 94 85 b8 fd ff ff 	mov    %edx,-0x248(%ebp,%eax,4)
/work/x86_os_my/fs/inode.c:191
		block_idx++;
c0009794:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0009798:	83 c0 01             	add    $0x1,%eax
c000979b:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/inode.c:189
	uint8_t block_idx = 0, block_cnt = 12;
	uint32_t block_bitmap_idx;
	uint32_t all_blocks[140] = {0};	  //12个直接块+128个间接块

	/* a 先将前12个直接块存入all_blocks */
	while (block_idx < 12) {
c000979e:	80 7d f7 0b          	cmpb   $0xb,-0x9(%ebp)
c00097a2:	76 d8                	jbe    c000977c <inode_release+0x62>
/work/x86_os_my/fs/inode.c:194
		all_blocks[block_idx] = inode_to_del->i_sectors[block_idx];
		block_idx++;
	}
	/* b 如果一级间接块表存在，将其128个间接块读到all_blocks[12~]，并释放一级间接块表所占的扇区 */
	if (inode_to_del->i_sectors[12] != 0) {
c00097a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00097a7:	8b 40 40             	mov    0x40(%eax),%eax
c00097aa:	85 c0                	test   %eax,%eax
c00097ac:	0f 84 8b 00 00 00    	je     c000983d <inode_release+0x123>
/work/x86_os_my/fs/inode.c:195
		ide_read(part->my_disk, inode_to_del->i_sectors[12], all_blocks + 12, 1);
c00097b2:	8d 85 b8 fd ff ff    	lea    -0x248(%ebp),%eax
c00097b8:	83 c0 30             	add    $0x30,%eax
c00097bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00097be:	8b 4a 40             	mov    0x40(%edx),%ecx
c00097c1:	8b 55 08             	mov    0x8(%ebp),%edx
c00097c4:	8b 52 08             	mov    0x8(%edx),%edx
c00097c7:	6a 01                	push   $0x1
c00097c9:	50                   	push   %eax
c00097ca:	51                   	push   %ecx
c00097cb:	52                   	push   %edx
c00097cc:	e8 03 ce ff ff       	call   c00065d4 <ide_read>
c00097d1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:196
		block_cnt = 140;
c00097d4:	c6 45 f6 8c          	movb   $0x8c,-0xa(%ebp)
/work/x86_os_my/fs/inode.c:199

		/* 回收一级间接块表占用的扇区 */
		block_bitmap_idx = inode_to_del->i_sectors[12] - part->sb->data_start_lba;
c00097d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00097db:	8b 50 40             	mov    0x40(%eax),%edx
c00097de:	8b 45 08             	mov    0x8(%ebp),%eax
c00097e1:	8b 40 1c             	mov    0x1c(%eax),%eax
c00097e4:	8b 40 28             	mov    0x28(%eax),%eax
c00097e7:	29 c2                	sub    %eax,%edx
c00097e9:	89 d0                	mov    %edx,%eax
c00097eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:200
		ASSERT(block_bitmap_idx > 0);
c00097ee:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00097f2:	75 1c                	jne    c0009810 <inode_release+0xf6>
/work/x86_os_my/fs/inode.c:200 (discriminator 1)
c00097f4:	68 97 f5 00 c0       	push   $0xc000f597
c00097f9:	68 d8 f5 00 c0       	push   $0xc000f5d8
c00097fe:	68 c8 00 00 00       	push   $0xc8
c0009803:	68 34 f5 00 c0       	push   $0xc000f534
c0009808:	e8 54 8d ff ff       	call   c0002561 <panic_spin>
c000980d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:201
		bitmap_set(&part->block_bitmap, block_bitmap_idx, 0);
c0009810:	8b 45 08             	mov    0x8(%ebp),%eax
c0009813:	83 c0 20             	add    $0x20,%eax
c0009816:	83 ec 04             	sub    $0x4,%esp
c0009819:	6a 00                	push   $0x0
c000981b:	ff 75 ec             	pushl  -0x14(%ebp)
c000981e:	50                   	push   %eax
c000981f:	e8 ab 8f ff ff       	call   c00027cf <bitmap_set>
c0009824:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:202
		bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c0009827:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000982c:	83 ec 04             	sub    $0x4,%esp
c000982f:	6a 01                	push   $0x1
c0009831:	ff 75 ec             	pushl  -0x14(%ebp)
c0009834:	50                   	push   %eax
c0009835:	e8 ca 02 00 00       	call   c0009b04 <bitmap_sync>
c000983a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:205
	}
	/* c inode所有的块地址已经收集到all_blocks中，下面逐个回收 */
	block_idx = 0;
c000983d:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/inode.c:206
	while (block_idx < block_cnt) {
c0009841:	e9 8a 00 00 00       	jmp    c00098d0 <inode_release+0x1b6>
/work/x86_os_my/fs/inode.c:207
		if (all_blocks[block_idx] != 0) {
c0009846:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000984a:	8b 84 85 b8 fd ff ff 	mov    -0x248(%ebp,%eax,4),%eax
c0009851:	85 c0                	test   %eax,%eax
c0009853:	74 71                	je     c00098c6 <inode_release+0x1ac>
/work/x86_os_my/fs/inode.c:208
			block_bitmap_idx = 0;
c0009855:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:209
			block_bitmap_idx = all_blocks[block_idx] - part->sb->data_start_lba;
c000985c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0009860:	8b 94 85 b8 fd ff ff 	mov    -0x248(%ebp,%eax,4),%edx
c0009867:	8b 45 08             	mov    0x8(%ebp),%eax
c000986a:	8b 40 1c             	mov    0x1c(%eax),%eax
c000986d:	8b 40 28             	mov    0x28(%eax),%eax
c0009870:	29 c2                	sub    %eax,%edx
c0009872:	89 d0                	mov    %edx,%eax
c0009874:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:210
			ASSERT(block_bitmap_idx > 0);
c0009877:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c000987b:	75 1c                	jne    c0009899 <inode_release+0x17f>
/work/x86_os_my/fs/inode.c:210 (discriminator 1)
c000987d:	68 97 f5 00 c0       	push   $0xc000f597
c0009882:	68 d8 f5 00 c0       	push   $0xc000f5d8
c0009887:	68 d2 00 00 00       	push   $0xd2
c000988c:	68 34 f5 00 c0       	push   $0xc000f534
c0009891:	e8 cb 8c ff ff       	call   c0002561 <panic_spin>
c0009896:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:211
			bitmap_set(&part->block_bitmap, block_bitmap_idx, 0);
c0009899:	8b 45 08             	mov    0x8(%ebp),%eax
c000989c:	83 c0 20             	add    $0x20,%eax
c000989f:	83 ec 04             	sub    $0x4,%esp
c00098a2:	6a 00                	push   $0x0
c00098a4:	ff 75 ec             	pushl  -0x14(%ebp)
c00098a7:	50                   	push   %eax
c00098a8:	e8 22 8f ff ff       	call   c00027cf <bitmap_set>
c00098ad:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:212
			bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c00098b0:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c00098b5:	83 ec 04             	sub    $0x4,%esp
c00098b8:	6a 01                	push   $0x1
c00098ba:	ff 75 ec             	pushl  -0x14(%ebp)
c00098bd:	50                   	push   %eax
c00098be:	e8 41 02 00 00       	call   c0009b04 <bitmap_sync>
c00098c3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:214
		}
		block_idx++;
c00098c6:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00098ca:	83 c0 01             	add    $0x1,%eax
c00098cd:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/inode.c:206
		bitmap_set(&part->block_bitmap, block_bitmap_idx, 0);
		bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
	}
	/* c inode所有的块地址已经收集到all_blocks中，下面逐个回收 */
	block_idx = 0;
	while (block_idx < block_cnt) {
c00098d0:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00098d4:	3a 45 f6             	cmp    -0xa(%ebp),%al
c00098d7:	0f 82 69 ff ff ff    	jb     c0009846 <inode_release+0x12c>
/work/x86_os_my/fs/inode.c:218
		}
		block_idx++;
	}

	/*2 回收该inode所占用的inode */
	bitmap_set(&part->inode_bitmap, inode_no, 0);
c00098dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00098e0:	83 c0 28             	add    $0x28,%eax
c00098e3:	83 ec 04             	sub    $0x4,%esp
c00098e6:	6a 00                	push   $0x0
c00098e8:	ff 75 0c             	pushl  0xc(%ebp)
c00098eb:	50                   	push   %eax
c00098ec:	e8 de 8e ff ff       	call   c00027cf <bitmap_set>
c00098f1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:219
	bitmap_sync(cur_part, inode_no, INODE_BITMAP);
c00098f4:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c00098f9:	83 ec 04             	sub    $0x4,%esp
c00098fc:	6a 00                	push   $0x0
c00098fe:	ff 75 0c             	pushl  0xc(%ebp)
c0009901:	50                   	push   %eax
c0009902:	e8 fd 01 00 00       	call   c0009b04 <bitmap_sync>
c0009907:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:225

	/******     以下inode_delete是调试用的    ******
	 * 此函数会在 inode_table 中将此inode清0，
	 * 但实际上只需要在inode位图中清零相应位即可。
	 * 硬盘上的数据更不需要清0，可以直接覆盖 */
	void* io_buf = sys_malloc(1024);
c000990a:	83 ec 0c             	sub    $0xc,%esp
c000990d:	68 00 04 00 00       	push   $0x400
c0009912:	e8 f5 95 ff ff       	call   c0002f0c <sys_malloc>
c0009917:	83 c4 10             	add    $0x10,%esp
c000991a:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/inode.c:226
	inode_delete(part, inode_no, io_buf);
c000991d:	83 ec 04             	sub    $0x4,%esp
c0009920:	ff 75 e8             	pushl  -0x18(%ebp)
c0009923:	ff 75 0c             	pushl  0xc(%ebp)
c0009926:	ff 75 08             	pushl  0x8(%ebp)
c0009929:	e8 da fc ff ff       	call   c0009608 <inode_delete>
c000992e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:227
	sys_free(io_buf);
c0009931:	83 ec 0c             	sub    $0xc,%esp
c0009934:	ff 75 e8             	pushl  -0x18(%ebp)
c0009937:	e8 fd 9b ff ff       	call   c0003539 <sys_free>
c000993c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:230
	/***********************************************/

	inode_close(inode_to_del);
c000993f:	83 ec 0c             	sub    $0xc,%esp
c0009942:	ff 75 f0             	pushl  -0x10(%ebp)
c0009945:	e8 42 fc ff ff       	call   c000958c <inode_close>
c000994a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:231
}
c000994d:	90                   	nop
c000994e:	8b 7d fc             	mov    -0x4(%ebp),%edi
c0009951:	c9                   	leave  
c0009952:	c3                   	ret    

c0009953 <inode_init>:
inode_init():
/work/x86_os_my/fs/inode.c:234

/* 初始化一个inode结构，inode号是inode_no */
void inode_init(uint32_t inode_no, struct inode* new_inode) {
c0009953:	55                   	push   %ebp
c0009954:	89 e5                	mov    %esp,%ebp
c0009956:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/fs/inode.c:235
	new_inode->i_no = inode_no;
c0009959:	8b 45 0c             	mov    0xc(%ebp),%eax
c000995c:	8b 55 08             	mov    0x8(%ebp),%edx
c000995f:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/inode.c:236
	new_inode->i_size = 0;
c0009961:	8b 45 0c             	mov    0xc(%ebp),%eax
c0009964:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
/work/x86_os_my/fs/inode.c:237
	new_inode->i_open_cnts = 0;
c000996b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000996e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/fs/inode.c:238
	new_inode->write_deny = false;
c0009975:	8b 45 0c             	mov    0xc(%ebp),%eax
c0009978:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/fs/inode.c:241

	/* 初始化块索引数组i_sector */
	uint8_t sec_idx = 0;
c000997f:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
/work/x86_os_my/fs/inode.c:242
	while (sec_idx < 13) {
c0009983:	eb 1b                	jmp    c00099a0 <inode_init+0x4d>
/work/x86_os_my/fs/inode.c:244
		/* i_sectors[12]为一级间接块地址 */
		new_inode->i_sectors[sec_idx] = 0;
c0009985:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c0009989:	8b 45 0c             	mov    0xc(%ebp),%eax
c000998c:	83 c2 04             	add    $0x4,%edx
c000998f:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
/work/x86_os_my/fs/inode.c:245
		sec_idx++;
c0009996:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c000999a:	83 c0 01             	add    $0x1,%eax
c000999d:	88 45 ff             	mov    %al,-0x1(%ebp)
/work/x86_os_my/fs/inode.c:242
	new_inode->i_open_cnts = 0;
	new_inode->write_deny = false;

	/* 初始化块索引数组i_sector */
	uint8_t sec_idx = 0;
	while (sec_idx < 13) {
c00099a0:	80 7d ff 0c          	cmpb   $0xc,-0x1(%ebp)
c00099a4:	76 df                	jbe    c0009985 <inode_init+0x32>
/work/x86_os_my/fs/inode.c:250
		sec_idx++;
	}
	/*为什么不提前分配inode管理的数据块（对我们来说是块=扇区）
	1.不知道文件大小，因此不知道分配多少个扇区合适
	2.文件创建后未必马上会写数据*/
}
c00099a6:	90                   	nop
c00099a7:	c9                   	leave  
c00099a8:	c3                   	ret    

c00099a9 <get_free_slot_in_global>:
get_free_slot_in_global():
/work/x86_os_my/fs/file.c:20

/* 文件表 */
struct file file_table[MAX_FILE_OPEN];

/* 从文件表 file_table 中获取一个空闲位,成功返回下标,失败返回-1 */
int32_t get_free_slot_in_global(void) {
c00099a9:	55                   	push   %ebp
c00099aa:	89 e5                	mov    %esp,%ebp
c00099ac:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/file.c:21
	uint32_t fd_idx = 3;
c00099af:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
/work/x86_os_my/fs/file.c:22
	while (fd_idx < MAX_FILE_OPEN) {
c00099b6:	eb 1b                	jmp    c00099d3 <get_free_slot_in_global+0x2a>
/work/x86_os_my/fs/file.c:23
		if (file_table[fd_idx].fd_inode == NULL) {
c00099b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00099bb:	89 d0                	mov    %edx,%eax
c00099bd:	01 c0                	add    %eax,%eax
c00099bf:	01 d0                	add    %edx,%eax
c00099c1:	c1 e0 02             	shl    $0x2,%eax
c00099c4:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c00099c9:	8b 00                	mov    (%eax),%eax
c00099cb:	85 c0                	test   %eax,%eax
c00099cd:	74 0c                	je     c00099db <get_free_slot_in_global+0x32>
/work/x86_os_my/fs/file.c:26
			break;
		}
		fd_idx++;
c00099cf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/file.c:22
struct file file_table[MAX_FILE_OPEN];

/* 从文件表 file_table 中获取一个空闲位,成功返回下标,失败返回-1 */
int32_t get_free_slot_in_global(void) {
	uint32_t fd_idx = 3;
	while (fd_idx < MAX_FILE_OPEN) {
c00099d3:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
c00099d7:	76 df                	jbe    c00099b8 <get_free_slot_in_global+0xf>
c00099d9:	eb 01                	jmp    c00099dc <get_free_slot_in_global+0x33>
/work/x86_os_my/fs/file.c:24
		if (file_table[fd_idx].fd_inode == NULL) {
			break;
c00099db:	90                   	nop
/work/x86_os_my/fs/file.c:28
		}
		fd_idx++;
	}
	if (fd_idx == MAX_FILE_OPEN) {
c00099dc:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
c00099e0:	75 17                	jne    c00099f9 <get_free_slot_in_global+0x50>
/work/x86_os_my/fs/file.c:29
		printk("exceed max open files\n");
c00099e2:	83 ec 0c             	sub    $0xc,%esp
c00099e5:	68 e8 f5 00 c0       	push   $0xc000f5e8
c00099ea:	e8 5e d6 ff ff       	call   c000704d <printk>
c00099ef:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:30
		return -1;
c00099f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00099f7:	eb 03                	jmp    c00099fc <get_free_slot_in_global+0x53>
/work/x86_os_my/fs/file.c:32
	}
	return fd_idx;
c00099f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/file.c:33
}
c00099fc:	c9                   	leave  
c00099fd:	c3                   	ret    

c00099fe <pcb_fd_install>:
pcb_fd_install():
/work/x86_os_my/fs/file.c:37

/* 将 file_table 的下标，安装到，线程PCB中文件描述符数组 fd_table
 * 成功返回 fd_table 的下标（即文件描述符）,失败返回-1 */
int32_t pcb_fd_install(int32_t globa_fd_idx) {
c00099fe:	55                   	push   %ebp
c00099ff:	89 e5                	mov    %esp,%ebp
c0009a01:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/file.c:38
	struct task_struct* cur = running_thread();
c0009a04:	e8 43 a4 ff ff       	call   c0003e4c <running_thread>
c0009a09:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:39
	uint8_t local_fd_idx = 3;	// 跨过stdin,stdout,stderr
c0009a0c:	c6 45 f7 03          	movb   $0x3,-0x9(%ebp)
/work/x86_os_my/fs/file.c:40
	while (local_fd_idx < MAX_FILES_OPEN_PER_PROC) {
c0009a10:	eb 30                	jmp    c0009a42 <pcb_fd_install+0x44>
/work/x86_os_my/fs/file.c:41
		if (cur->fd_table[local_fd_idx] == -1) {	// -1表示free_slot,可用
c0009a12:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0009a16:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0009a19:	83 c2 08             	add    $0x8,%edx
c0009a1c:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
c0009a20:	83 f8 ff             	cmp    $0xffffffff,%eax
c0009a23:	75 13                	jne    c0009a38 <pcb_fd_install+0x3a>
/work/x86_os_my/fs/file.c:42
			cur->fd_table[local_fd_idx] = globa_fd_idx;
c0009a25:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0009a29:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0009a2c:	8d 4a 08             	lea    0x8(%edx),%ecx
c0009a2f:	8b 55 08             	mov    0x8(%ebp),%edx
c0009a32:	89 54 88 04          	mov    %edx,0x4(%eax,%ecx,4)
/work/x86_os_my/fs/file.c:43
			break;
c0009a36:	eb 10                	jmp    c0009a48 <pcb_fd_install+0x4a>
/work/x86_os_my/fs/file.c:45
		}
		local_fd_idx++;
c0009a38:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0009a3c:	83 c0 01             	add    $0x1,%eax
c0009a3f:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/file.c:40
/* 将 file_table 的下标，安装到，线程PCB中文件描述符数组 fd_table
 * 成功返回 fd_table 的下标（即文件描述符）,失败返回-1 */
int32_t pcb_fd_install(int32_t globa_fd_idx) {
	struct task_struct* cur = running_thread();
	uint8_t local_fd_idx = 3;	// 跨过stdin,stdout,stderr
	while (local_fd_idx < MAX_FILES_OPEN_PER_PROC) {
c0009a42:	80 7d f7 07          	cmpb   $0x7,-0x9(%ebp)
c0009a46:	76 ca                	jbe    c0009a12 <pcb_fd_install+0x14>
/work/x86_os_my/fs/file.c:47
			cur->fd_table[local_fd_idx] = globa_fd_idx;
			break;
		}
		local_fd_idx++;
	}
	if (local_fd_idx == MAX_FILES_OPEN_PER_PROC) {
c0009a48:	80 7d f7 08          	cmpb   $0x8,-0x9(%ebp)
c0009a4c:	75 17                	jne    c0009a65 <pcb_fd_install+0x67>
/work/x86_os_my/fs/file.c:48
		printk("exceed max open files_per_proc\n");
c0009a4e:	83 ec 0c             	sub    $0xc,%esp
c0009a51:	68 00 f6 00 c0       	push   $0xc000f600
c0009a56:	e8 f2 d5 ff ff       	call   c000704d <printk>
c0009a5b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:49
		return -1;
c0009a5e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009a63:	eb 04                	jmp    c0009a69 <pcb_fd_install+0x6b>
/work/x86_os_my/fs/file.c:51
	}
	return local_fd_idx;
c0009a65:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
/work/x86_os_my/fs/file.c:52
}
c0009a69:	c9                   	leave  
c0009a6a:	c3                   	ret    

c0009a6b <inode_bitmap_alloc>:
inode_bitmap_alloc():
/work/x86_os_my/fs/file.c:55

/* 从分区的inode位图中，分配一个i结点，返回"inode号" */
int32_t inode_bitmap_alloc(struct partition* part) {
c0009a6b:	55                   	push   %ebp
c0009a6c:	89 e5                	mov    %esp,%ebp
c0009a6e:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/file.c:56
	int32_t bit_idx = bitmap_scan(&part->inode_bitmap, 1);
c0009a71:	8b 45 08             	mov    0x8(%ebp),%eax
c0009a74:	83 c0 28             	add    $0x28,%eax
c0009a77:	83 ec 08             	sub    $0x8,%esp
c0009a7a:	6a 01                	push   $0x1
c0009a7c:	50                   	push   %eax
c0009a7d:	e8 18 8c ff ff       	call   c000269a <bitmap_scan>
c0009a82:	83 c4 10             	add    $0x10,%esp
c0009a85:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:57
	if (bit_idx == -1) {
c0009a88:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0009a8c:	75 07                	jne    c0009a95 <inode_bitmap_alloc+0x2a>
/work/x86_os_my/fs/file.c:58
		return -1;
c0009a8e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009a93:	eb 1b                	jmp    c0009ab0 <inode_bitmap_alloc+0x45>
/work/x86_os_my/fs/file.c:60
	}
	bitmap_set(&part->inode_bitmap, bit_idx, 1);
c0009a95:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0009a98:	8b 55 08             	mov    0x8(%ebp),%edx
c0009a9b:	83 c2 28             	add    $0x28,%edx
c0009a9e:	83 ec 04             	sub    $0x4,%esp
c0009aa1:	6a 01                	push   $0x1
c0009aa3:	50                   	push   %eax
c0009aa4:	52                   	push   %edx
c0009aa5:	e8 25 8d ff ff       	call   c00027cf <bitmap_set>
c0009aaa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:61
	return bit_idx;
c0009aad:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/file.c:62
}
c0009ab0:	c9                   	leave  
c0009ab1:	c3                   	ret    

c0009ab2 <block_bitmap_alloc>:
block_bitmap_alloc():
/work/x86_os_my/fs/file.c:65
   
/* 从分区的block位图中，分配1个扇区，返回"扇区地址" 【操作的是 空闲块区域 】*/
int32_t block_bitmap_alloc(struct partition* part) {
c0009ab2:	55                   	push   %ebp
c0009ab3:	89 e5                	mov    %esp,%ebp
c0009ab5:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/file.c:66
	int32_t bit_idx = bitmap_scan(&part->block_bitmap, 1);
c0009ab8:	8b 45 08             	mov    0x8(%ebp),%eax
c0009abb:	83 c0 20             	add    $0x20,%eax
c0009abe:	83 ec 08             	sub    $0x8,%esp
c0009ac1:	6a 01                	push   $0x1
c0009ac3:	50                   	push   %eax
c0009ac4:	e8 d1 8b ff ff       	call   c000269a <bitmap_scan>
c0009ac9:	83 c4 10             	add    $0x10,%esp
c0009acc:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:67
	if (bit_idx == -1) {
c0009acf:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0009ad3:	75 07                	jne    c0009adc <block_bitmap_alloc+0x2a>
/work/x86_os_my/fs/file.c:68
		return -1;
c0009ad5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009ada:	eb 26                	jmp    c0009b02 <block_bitmap_alloc+0x50>
/work/x86_os_my/fs/file.c:70
	}
	bitmap_set(&part->block_bitmap, bit_idx, 1);
c0009adc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0009adf:	8b 55 08             	mov    0x8(%ebp),%edx
c0009ae2:	83 c2 20             	add    $0x20,%edx
c0009ae5:	83 ec 04             	sub    $0x4,%esp
c0009ae8:	6a 01                	push   $0x1
c0009aea:	50                   	push   %eax
c0009aeb:	52                   	push   %edx
c0009aec:	e8 de 8c ff ff       	call   c00027cf <bitmap_set>
c0009af1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:72
	/* 和inode_bitmap_malloc不同,此处返回的不是位图索引,而是具体可用的扇区地址 */
	return (part->sb->data_start_lba + bit_idx);
c0009af4:	8b 45 08             	mov    0x8(%ebp),%eax
c0009af7:	8b 40 1c             	mov    0x1c(%eax),%eax
c0009afa:	8b 50 28             	mov    0x28(%eax),%edx
c0009afd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0009b00:	01 d0                	add    %edx,%eax
/work/x86_os_my/fs/file.c:73
} 
c0009b02:	c9                   	leave  
c0009b03:	c3                   	ret    

c0009b04 <bitmap_sync>:
bitmap_sync():
/work/x86_os_my/fs/file.c:77

/* 将内存中bitmap第bit_idx位所在的那个512字节，同步到硬盘中bitmap第bit_idx位所在的扇区 */
// 硬盘以扇区为读写单位
void bitmap_sync(struct partition* part, uint32_t bit_idx, uint8_t btmp_type) {
c0009b04:	55                   	push   %ebp
c0009b05:	89 e5                	mov    %esp,%ebp
c0009b07:	83 ec 28             	sub    $0x28,%esp
c0009b0a:	8b 45 10             	mov    0x10(%ebp),%eax
c0009b0d:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:78
	uint32_t off_sec = bit_idx / 4096;			// dst(硬盘中): bit_idx 相对于位图起始lba，在后边的第几个扇区(512*8=4096)
c0009b10:	8b 45 0c             	mov    0xc(%ebp),%eax
c0009b13:	c1 e8 0c             	shr    $0xc,%eax
c0009b16:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:79
	uint32_t off_size = off_sec * BLOCK_SIZE;	// src(内存中): bit_idx 相对于位图数组bits，以512字节为单位，在后边的第几个单位处
c0009b19:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0009b1c:	c1 e0 09             	shl    $0x9,%eax
c0009b1f:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:85
												// off_size是，第 bit_idx位所在位图中以 512 字节为单位的起始地址。BLOCK_SIZE=512
	uint32_t sec_lba;
	uint8_t* bitmap_off;

	/* 需要被同步到硬盘的位图只有inode_bitmap和block_bitmap */
	switch (btmp_type) {
c0009b22:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0009b26:	85 c0                	test   %eax,%eax
c0009b28:	74 07                	je     c0009b31 <bitmap_sync+0x2d>
c0009b2a:	83 f8 01             	cmp    $0x1,%eax
c0009b2d:	74 23                	je     c0009b52 <bitmap_sync+0x4e>
c0009b2f:	eb 41                	jmp    c0009b72 <bitmap_sync+0x6e>
/work/x86_os_my/fs/file.c:87
		case INODE_BITMAP:
		sec_lba = part->sb->inode_bitmap_lba + off_sec;
c0009b31:	8b 45 08             	mov    0x8(%ebp),%eax
c0009b34:	8b 40 1c             	mov    0x1c(%eax),%eax
c0009b37:	8b 50 18             	mov    0x18(%eax),%edx
c0009b3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0009b3d:	01 d0                	add    %edx,%eax
c0009b3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:88
		bitmap_off = part->inode_bitmap.bits + off_size;
c0009b42:	8b 45 08             	mov    0x8(%ebp),%eax
c0009b45:	8b 50 2c             	mov    0x2c(%eax),%edx
c0009b48:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0009b4b:	01 d0                	add    %edx,%eax
c0009b4d:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:89
		break;
c0009b50:	eb 20                	jmp    c0009b72 <bitmap_sync+0x6e>
/work/x86_os_my/fs/file.c:92

		case BLOCK_BITMAP: 
		sec_lba = part->sb->block_bitmap_lba + off_sec;
c0009b52:	8b 45 08             	mov    0x8(%ebp),%eax
c0009b55:	8b 40 1c             	mov    0x1c(%eax),%eax
c0009b58:	8b 50 10             	mov    0x10(%eax),%edx
c0009b5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0009b5e:	01 d0                	add    %edx,%eax
c0009b60:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:93
		bitmap_off = part->block_bitmap.bits + off_size;
c0009b63:	8b 45 08             	mov    0x8(%ebp),%eax
c0009b66:	8b 50 24             	mov    0x24(%eax),%edx
c0009b69:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0009b6c:	01 d0                	add    %edx,%eax
c0009b6e:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:94
		break;
c0009b71:	90                   	nop
/work/x86_os_my/fs/file.c:96
	}
	ide_write(part->my_disk, sec_lba, bitmap_off, 1);	// 将bitmap_off中1个扇区的数据写入硬盘sec_lba处
c0009b72:	8b 45 08             	mov    0x8(%ebp),%eax
c0009b75:	8b 40 08             	mov    0x8(%eax),%eax
c0009b78:	6a 01                	push   $0x1
c0009b7a:	ff 75 f0             	pushl  -0x10(%ebp)
c0009b7d:	ff 75 f4             	pushl  -0xc(%ebp)
c0009b80:	50                   	push   %eax
c0009b81:	e8 c2 cb ff ff       	call   c0006748 <ide_write>
c0009b86:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:97
}
c0009b89:	90                   	nop
c0009b8a:	c9                   	leave  
c0009b8b:	c3                   	ret    

c0009b8c <file_create>:
file_create():
/work/x86_os_my/fs/file.c:115
此新增加的文件对应的目录项，需要写入该目录的 inode->i_sectors[]中的某个扇区，
原有扇区可能已满，所以有可能要申请新扇区来存储目录项。【sync_dir_entry】
4. 若其中某步操作失败，需要回滚之前已成功的操作。
5. inode_bitmap、 block_bitmap、新文件的 inode 及文件所在目录的 inode，这些位于内存中已经被改变的数据要同步到硬盘。
*/
int32_t file_create(struct dir* parent_dir, char* filename, uint8_t flag) {
c0009b8c:	55                   	push   %ebp
c0009b8d:	89 e5                	mov    %esp,%ebp
c0009b8f:	83 ec 48             	sub    $0x48,%esp
c0009b92:	8b 45 10             	mov    0x10(%ebp),%eax
c0009b95:	88 45 c4             	mov    %al,-0x3c(%ebp)
/work/x86_os_my/fs/file.c:117
	/* 后续操作的公共缓冲区 */
	void* io_buf = sys_malloc(1024);	//跨扇区的数据，会操作2个扇区
c0009b98:	83 ec 0c             	sub    $0xc,%esp
c0009b9b:	68 00 04 00 00       	push   $0x400
c0009ba0:	e8 67 93 ff ff       	call   c0002f0c <sys_malloc>
c0009ba5:	83 c4 10             	add    $0x10,%esp
c0009ba8:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:118
	if (io_buf == NULL) {
c0009bab:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0009baf:	75 1a                	jne    c0009bcb <file_create+0x3f>
/work/x86_os_my/fs/file.c:119
		printk("in file_creat: sys_malloc for io_buf failed\n");
c0009bb1:	83 ec 0c             	sub    $0xc,%esp
c0009bb4:	68 20 f6 00 c0       	push   $0xc000f620
c0009bb9:	e8 8f d4 ff ff       	call   c000704d <printk>
c0009bbe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:120
		return -1;
c0009bc1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009bc6:	e9 81 02 00 00       	jmp    c0009e4c <file_create+0x2c0>
/work/x86_os_my/fs/file.c:123
	}

	uint8_t rollback_step = 0;	// 用于操作失败时回滚各资源状态
c0009bcb:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/file.c:126

	/* 1.为新文件从分区inode位图中，分配inode号 */
	int32_t inode_no = inode_bitmap_alloc(cur_part); 
c0009bcf:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0009bd4:	83 ec 0c             	sub    $0xc,%esp
c0009bd7:	50                   	push   %eax
c0009bd8:	e8 8e fe ff ff       	call   c0009a6b <inode_bitmap_alloc>
c0009bdd:	83 c4 10             	add    $0x10,%esp
c0009be0:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:127
	if (inode_no == -1) {
c0009be3:	83 7d e8 ff          	cmpl   $0xffffffff,-0x18(%ebp)
c0009be7:	75 1a                	jne    c0009c03 <file_create+0x77>
/work/x86_os_my/fs/file.c:128
		printk("in file_creat: allocate inode failed\n");
c0009be9:	83 ec 0c             	sub    $0xc,%esp
c0009bec:	68 50 f6 00 c0       	push   $0xc000f650
c0009bf1:	e8 57 d4 ff ff       	call   c000704d <printk>
c0009bf6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:129
		return -1;
c0009bf9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009bfe:	e9 49 02 00 00       	jmp    c0009e4c <file_create+0x2c0>
/work/x86_os_my/fs/file.c:134
	}

	/* 2.堆中分配inode节点，不可以是栈中的局部变量！
	 * 因为 file_table 中的 fd_inode 指针要指向它. */
	struct inode* new_file_inode = (struct inode*)sys_malloc(sizeof(struct inode)); 
c0009c03:	83 ec 0c             	sub    $0xc,%esp
c0009c06:	6a 4c                	push   $0x4c
c0009c08:	e8 ff 92 ff ff       	call   c0002f0c <sys_malloc>
c0009c0d:	83 c4 10             	add    $0x10,%esp
c0009c10:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:135
	if (new_file_inode == NULL) {
c0009c13:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0009c17:	75 19                	jne    c0009c32 <file_create+0xa6>
/work/x86_os_my/fs/file.c:136
		printk("file_create: sys_malloc for inode failded\n");
c0009c19:	83 ec 0c             	sub    $0xc,%esp
c0009c1c:	68 78 f6 00 c0       	push   $0xc000f678
c0009c21:	e8 27 d4 ff ff       	call   c000704d <printk>
c0009c26:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:137
		rollback_step = 1;
c0009c29:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
/work/x86_os_my/fs/file.c:138
		goto rollback;
c0009c2d:	e9 a7 01 00 00       	jmp    c0009dd9 <file_create+0x24d>
/work/x86_os_my/fs/file.c:140
	}
	inode_init(inode_no, new_file_inode);	    // 初始化inode
c0009c32:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0009c35:	83 ec 08             	sub    $0x8,%esp
c0009c38:	ff 75 e4             	pushl  -0x1c(%ebp)
c0009c3b:	50                   	push   %eax
c0009c3c:	e8 12 fd ff ff       	call   c0009953 <inode_init>
c0009c41:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:143

	/* 3.申请一个file_table数组的下标 */
	int fd_idx = get_free_slot_in_global();
c0009c44:	e8 60 fd ff ff       	call   c00099a9 <get_free_slot_in_global>
c0009c49:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:144
	if (fd_idx == -1) {
c0009c4c:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0009c50:	75 19                	jne    c0009c6b <file_create+0xdf>
/work/x86_os_my/fs/file.c:145
		printk("exceed max open files\n");
c0009c52:	83 ec 0c             	sub    $0xc,%esp
c0009c55:	68 e8 f5 00 c0       	push   $0xc000f5e8
c0009c5a:	e8 ee d3 ff ff       	call   c000704d <printk>
c0009c5f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:146
		rollback_step = 2;
c0009c62:	c6 45 f7 02          	movb   $0x2,-0x9(%ebp)
/work/x86_os_my/fs/file.c:147
		goto rollback;
c0009c66:	e9 6e 01 00 00       	jmp    c0009dd9 <file_create+0x24d>
/work/x86_os_my/fs/file.c:151
	}

	// 4.填充文件表中的文件结构
	file_table[fd_idx].fd_inode = new_file_inode;
c0009c6b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0009c6e:	89 d0                	mov    %edx,%eax
c0009c70:	01 c0                	add    %eax,%eax
c0009c72:	01 d0                	add    %edx,%eax
c0009c74:	c1 e0 02             	shl    $0x2,%eax
c0009c77:	8d 90 a8 58 01 c0    	lea    -0x3ffea758(%eax),%edx
c0009c7d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0009c80:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/file.c:152
	file_table[fd_idx].fd_pos = 0;
c0009c82:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0009c85:	89 d0                	mov    %edx,%eax
c0009c87:	01 c0                	add    %eax,%eax
c0009c89:	01 d0                	add    %edx,%eax
c0009c8b:	c1 e0 02             	shl    $0x2,%eax
c0009c8e:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c0009c93:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/file.c:153
	file_table[fd_idx].fd_flag = flag;
c0009c99:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
c0009c9d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0009ca0:	89 d0                	mov    %edx,%eax
c0009ca2:	01 c0                	add    %eax,%eax
c0009ca4:	01 d0                	add    %edx,%eax
c0009ca6:	c1 e0 02             	shl    $0x2,%eax
c0009ca9:	05 a4 58 01 c0       	add    $0xc00158a4,%eax
c0009cae:	89 08                	mov    %ecx,(%eax)
/work/x86_os_my/fs/file.c:154
	file_table[fd_idx].fd_inode->write_deny = false;
c0009cb0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0009cb3:	89 d0                	mov    %edx,%eax
c0009cb5:	01 c0                	add    %eax,%eax
c0009cb7:	01 d0                	add    %edx,%eax
c0009cb9:	c1 e0 02             	shl    $0x2,%eax
c0009cbc:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c0009cc1:	8b 00                	mov    (%eax),%eax
c0009cc3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/fs/file.c:157

	struct dir_entry new_dir_entry;
	memset(&new_dir_entry, 0, sizeof(struct dir_entry));
c0009cca:	83 ec 04             	sub    $0x4,%esp
c0009ccd:	6a 18                	push   $0x18
c0009ccf:	6a 00                	push   $0x0
c0009cd1:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0009cd4:	50                   	push   %eax
c0009cd5:	e8 8b 9d ff ff       	call   c0003a65 <memset>
c0009cda:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:160

	// create_dir_entry在内存中初始化目录项p_de，只是内存操作不会返回失败
	create_dir_entry(filename, inode_no, FT_REGULAR, &new_dir_entry);
c0009cdd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0009ce0:	8d 55 cc             	lea    -0x34(%ebp),%edx
c0009ce3:	52                   	push   %edx
c0009ce4:	6a 01                	push   $0x1
c0009ce6:	50                   	push   %eax
c0009ce7:	ff 75 0c             	pushl  0xc(%ebp)
c0009cea:	e8 73 10 00 00       	call   c000ad62 <create_dir_entry>
c0009cef:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:165


	/* 同步内存数据到硬盘 */
	/* a 在目录parent_dir下安装目录项new_dir_entry, 写入硬盘后返回true, 否则false【dir.c】 */
	if (!sync_dir_entry(parent_dir, &new_dir_entry, io_buf)) {
c0009cf2:	83 ec 04             	sub    $0x4,%esp
c0009cf5:	ff 75 ec             	pushl  -0x14(%ebp)
c0009cf8:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0009cfb:	50                   	push   %eax
c0009cfc:	ff 75 08             	pushl  0x8(%ebp)
c0009cff:	e8 cf 10 00 00       	call   c000add3 <sync_dir_entry>
c0009d04:	83 c4 10             	add    $0x10,%esp
c0009d07:	85 c0                	test   %eax,%eax
c0009d09:	75 19                	jne    c0009d24 <file_create+0x198>
/work/x86_os_my/fs/file.c:166
		printk("sync dir_entry to disk failed\n");
c0009d0b:	83 ec 0c             	sub    $0xc,%esp
c0009d0e:	68 a4 f6 00 c0       	push   $0xc000f6a4
c0009d13:	e8 35 d3 ff ff       	call   c000704d <printk>
c0009d18:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:167
		rollback_step = 3;
c0009d1b:	c6 45 f7 03          	movb   $0x3,-0x9(%ebp)
/work/x86_os_my/fs/file.c:168
		goto rollback;
c0009d1f:	e9 b5 00 00 00       	jmp    c0009dd9 <file_create+0x24d>
/work/x86_os_my/fs/file.c:172
	}

	/* b sync_dir_entry 会改变父目录 inode 中的信息，因此，将父目录inode的内容同步到硬盘【inode.c】 */
	memset(io_buf, 0, 1024);
c0009d24:	83 ec 04             	sub    $0x4,%esp
c0009d27:	68 00 04 00 00       	push   $0x400
c0009d2c:	6a 00                	push   $0x0
c0009d2e:	ff 75 ec             	pushl  -0x14(%ebp)
c0009d31:	e8 2f 9d ff ff       	call   c0003a65 <memset>
c0009d36:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:173
	inode_sync(cur_part, parent_dir->inode, io_buf);
c0009d39:	8b 45 08             	mov    0x8(%ebp),%eax
c0009d3c:	8b 10                	mov    (%eax),%edx
c0009d3e:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0009d43:	83 ec 04             	sub    $0x4,%esp
c0009d46:	ff 75 ec             	pushl  -0x14(%ebp)
c0009d49:	52                   	push   %edx
c0009d4a:	50                   	push   %eax
c0009d4b:	e8 cf f5 ff ff       	call   c000931f <inode_sync>
c0009d50:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:176

	/* c 将新创建文件的inode内容同步到硬盘 */
	memset(io_buf, 0, 1024);
c0009d53:	83 ec 04             	sub    $0x4,%esp
c0009d56:	68 00 04 00 00       	push   $0x400
c0009d5b:	6a 00                	push   $0x0
c0009d5d:	ff 75 ec             	pushl  -0x14(%ebp)
c0009d60:	e8 00 9d ff ff       	call   c0003a65 <memset>
c0009d65:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:177
	inode_sync(cur_part, new_file_inode, io_buf);
c0009d68:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0009d6d:	83 ec 04             	sub    $0x4,%esp
c0009d70:	ff 75 ec             	pushl  -0x14(%ebp)
c0009d73:	ff 75 e4             	pushl  -0x1c(%ebp)
c0009d76:	50                   	push   %eax
c0009d77:	e8 a3 f5 ff ff       	call   c000931f <inode_sync>
c0009d7c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:180

	/* d 将inode_bitmap位图同步到硬盘【file.c】 */
	bitmap_sync(cur_part, inode_no, INODE_BITMAP);
c0009d7f:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0009d82:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0009d87:	83 ec 04             	sub    $0x4,%esp
c0009d8a:	6a 00                	push   $0x0
c0009d8c:	52                   	push   %edx
c0009d8d:	50                   	push   %eax
c0009d8e:	e8 71 fd ff ff       	call   c0009b04 <bitmap_sync>
c0009d93:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:183

	/* e 将创建的文件i结点添加到open_inodes链表 */
	list_push(&cur_part->open_inodes, &new_file_inode->inode_tag);
c0009d96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0009d99:	8d 50 44             	lea    0x44(%eax),%edx
c0009d9c:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0009da1:	83 c0 30             	add    $0x30,%eax
c0009da4:	83 ec 08             	sub    $0x8,%esp
c0009da7:	52                   	push   %edx
c0009da8:	50                   	push   %eax
c0009da9:	e8 fe ac ff ff       	call   c0004aac <list_push>
c0009dae:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:184
	new_file_inode->i_open_cnts = 1;
c0009db1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0009db4:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/fs/file.c:187


	sys_free(io_buf);
c0009dbb:	83 ec 0c             	sub    $0xc,%esp
c0009dbe:	ff 75 ec             	pushl  -0x14(%ebp)
c0009dc1:	e8 73 97 ff ff       	call   c0003539 <sys_free>
c0009dc6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:188
	return pcb_fd_install(fd_idx);	// 将 file_table 的下标，安装到，线程PCB中文件描述符数组 fd_table【file.c】
c0009dc9:	83 ec 0c             	sub    $0xc,%esp
c0009dcc:	ff 75 f0             	pushl  -0x10(%ebp)
c0009dcf:	e8 2a fc ff ff       	call   c00099fe <pcb_fd_install>
c0009dd4:	83 c4 10             	add    $0x10,%esp
c0009dd7:	eb 73                	jmp    c0009e4c <file_create+0x2c0>
/work/x86_os_my/fs/file.c:192


rollback:
	switch (rollback_step) {
c0009dd9:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0009ddd:	83 f8 02             	cmp    $0x2,%eax
c0009de0:	74 2d                	je     c0009e0f <file_create+0x283>
c0009de2:	83 f8 03             	cmp    $0x3,%eax
c0009de5:	74 07                	je     c0009dee <file_create+0x262>
c0009de7:	83 f8 01             	cmp    $0x1,%eax
c0009dea:	74 31                	je     c0009e1d <file_create+0x291>
c0009dec:	eb 4b                	jmp    c0009e39 <file_create+0x2ad>
/work/x86_os_my/fs/file.c:195
		case 3:
		/* file_table 相应位清空 */
		memset(&file_table[fd_idx], 0, sizeof(struct file)); 
c0009dee:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0009df1:	89 d0                	mov    %edx,%eax
c0009df3:	01 c0                	add    %eax,%eax
c0009df5:	01 d0                	add    %edx,%eax
c0009df7:	c1 e0 02             	shl    $0x2,%eax
c0009dfa:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c0009dff:	83 ec 04             	sub    $0x4,%esp
c0009e02:	6a 0c                	push   $0xc
c0009e04:	6a 00                	push   $0x0
c0009e06:	50                   	push   %eax
c0009e07:	e8 59 9c ff ff       	call   c0003a65 <memset>
c0009e0c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:197
		case 2:
		sys_free(new_file_inode);
c0009e0f:	83 ec 0c             	sub    $0xc,%esp
c0009e12:	ff 75 e4             	pushl  -0x1c(%ebp)
c0009e15:	e8 1f 97 ff ff       	call   c0003539 <sys_free>
c0009e1a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:200
		case 1:
		/* inode位图 恢复 */
		bitmap_set(&cur_part->inode_bitmap, inode_no, 0);
c0009e1d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0009e20:	8b 15 90 58 01 c0    	mov    0xc0015890,%edx
c0009e26:	83 c2 28             	add    $0x28,%edx
c0009e29:	83 ec 04             	sub    $0x4,%esp
c0009e2c:	6a 00                	push   $0x0
c0009e2e:	50                   	push   %eax
c0009e2f:	52                   	push   %edx
c0009e30:	e8 9a 89 ff ff       	call   c00027cf <bitmap_set>
c0009e35:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:201
		break;
c0009e38:	90                   	nop
/work/x86_os_my/fs/file.c:203
	}
	sys_free(io_buf);
c0009e39:	83 ec 0c             	sub    $0xc,%esp
c0009e3c:	ff 75 ec             	pushl  -0x14(%ebp)
c0009e3f:	e8 f5 96 ff ff       	call   c0003539 <sys_free>
c0009e44:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:204
	return -1;
c0009e47:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/fs/file.c:205 (discriminator 1)
}
c0009e4c:	c9                   	leave  
c0009e4d:	c3                   	ret    

c0009e4e <file_open>:
file_open():
/work/x86_os_my/fs/file.c:208

/* 打开编号为inode_no的inode对应的文件,若成功则返回文件描述符,否则返回-1 */
int32_t file_open(uint32_t inode_no, uint8_t flag) {
c0009e4e:	55                   	push   %ebp
c0009e4f:	89 e5                	mov    %esp,%ebp
c0009e51:	83 ec 28             	sub    $0x28,%esp
c0009e54:	8b 45 0c             	mov    0xc(%ebp),%eax
c0009e57:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:209
	int fd_idx = get_free_slot_in_global();
c0009e5a:	e8 4a fb ff ff       	call   c00099a9 <get_free_slot_in_global>
c0009e5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:210
	if (fd_idx == -1) {
c0009e62:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0009e66:	75 1a                	jne    c0009e82 <file_open+0x34>
/work/x86_os_my/fs/file.c:211
		printk("exceed max open files\n");
c0009e68:	83 ec 0c             	sub    $0xc,%esp
c0009e6b:	68 e8 f5 00 c0       	push   $0xc000f5e8
c0009e70:	e8 d8 d1 ff ff       	call   c000704d <printk>
c0009e75:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:212
		return -1;
c0009e78:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009e7d:	e9 e3 00 00 00       	jmp    c0009f65 <file_open+0x117>
/work/x86_os_my/fs/file.c:214
	}
	file_table[fd_idx].fd_inode = inode_open(cur_part, inode_no);
c0009e82:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c0009e87:	83 ec 08             	sub    $0x8,%esp
c0009e8a:	ff 75 08             	pushl  0x8(%ebp)
c0009e8d:	50                   	push   %eax
c0009e8e:	e8 b3 f5 ff ff       	call   c0009446 <inode_open>
c0009e93:	83 c4 10             	add    $0x10,%esp
c0009e96:	89 c1                	mov    %eax,%ecx
c0009e98:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0009e9b:	89 d0                	mov    %edx,%eax
c0009e9d:	01 c0                	add    %eax,%eax
c0009e9f:	01 d0                	add    %edx,%eax
c0009ea1:	c1 e0 02             	shl    $0x2,%eax
c0009ea4:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c0009ea9:	89 08                	mov    %ecx,(%eax)
/work/x86_os_my/fs/file.c:215
	file_table[fd_idx].fd_pos = 0;		// 每次打开文件,要将fd_pos还原为0,即让文件内的指针指向开头
c0009eab:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0009eae:	89 d0                	mov    %edx,%eax
c0009eb0:	01 c0                	add    %eax,%eax
c0009eb2:	01 d0                	add    %edx,%eax
c0009eb4:	c1 e0 02             	shl    $0x2,%eax
c0009eb7:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c0009ebc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/file.c:216
	file_table[fd_idx].fd_flag = flag;
c0009ec2:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c0009ec6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0009ec9:	89 d0                	mov    %edx,%eax
c0009ecb:	01 c0                	add    %eax,%eax
c0009ecd:	01 d0                	add    %edx,%eax
c0009ecf:	c1 e0 02             	shl    $0x2,%eax
c0009ed2:	05 a4 58 01 c0       	add    $0xc00158a4,%eax
c0009ed7:	89 08                	mov    %ecx,(%eax)
/work/x86_os_my/fs/file.c:217
	bool* write_deny = &file_table[fd_idx].fd_inode->write_deny;
c0009ed9:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0009edc:	89 d0                	mov    %edx,%eax
c0009ede:	01 c0                	add    %eax,%eax
c0009ee0:	01 d0                	add    %edx,%eax
c0009ee2:	c1 e0 02             	shl    $0x2,%eax
c0009ee5:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c0009eea:	8b 00                	mov    (%eax),%eax
c0009eec:	83 c0 0c             	add    $0xc,%eax
c0009eef:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:219

	if (flag & O_WRONLY || flag & O_RDWR) {	// 要写文件,需要判断是否有其它进程正写此文件。创建文件、读文件不考虑write_deny。
c0009ef2:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0009ef6:	83 e0 01             	and    $0x1,%eax
c0009ef9:	85 c0                	test   %eax,%eax
c0009efb:	75 0b                	jne    c0009f08 <file_open+0xba>
/work/x86_os_my/fs/file.c:219 (discriminator 1)
c0009efd:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0009f01:	83 e0 02             	and    $0x2,%eax
c0009f04:	85 c0                	test   %eax,%eax
c0009f06:	74 4f                	je     c0009f57 <file_open+0x109>
/work/x86_os_my/fs/file.c:221
		/* 以下进入临界区前先关中断 */
		enum intr_status old_status = intr_disable();
c0009f08:	e8 78 7c ff ff       	call   c0001b85 <intr_disable>
c0009f0d:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:222
		if (!(*write_deny)) {	// 若当前没有其它进程写该文件,将其占用.
c0009f10:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0009f13:	8b 00                	mov    (%eax),%eax
c0009f15:	85 c0                	test   %eax,%eax
c0009f17:	75 19                	jne    c0009f32 <file_open+0xe4>
/work/x86_os_my/fs/file.c:223
			*write_deny = true;
c0009f19:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0009f1c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
/work/x86_os_my/fs/file.c:224
			intr_set_status(old_status);
c0009f22:	83 ec 0c             	sub    $0xc,%esp
c0009f25:	ff 75 ec             	pushl  -0x14(%ebp)
c0009f28:	e8 81 7c ff ff       	call   c0001bae <intr_set_status>
c0009f2d:	83 c4 10             	add    $0x10,%esp
c0009f30:	eb 25                	jmp    c0009f57 <file_open+0x109>
/work/x86_os_my/fs/file.c:226
		} else {
			intr_set_status(old_status);
c0009f32:	83 ec 0c             	sub    $0xc,%esp
c0009f35:	ff 75 ec             	pushl  -0x14(%ebp)
c0009f38:	e8 71 7c ff ff       	call   c0001bae <intr_set_status>
c0009f3d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:227
			printk("file can`t be write now, try again later\n");
c0009f40:	83 ec 0c             	sub    $0xc,%esp
c0009f43:	68 c4 f6 00 c0       	push   $0xc000f6c4
c0009f48:	e8 00 d1 ff ff       	call   c000704d <printk>
c0009f4d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:228
			return -1;
c0009f50:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009f55:	eb 0e                	jmp    c0009f65 <file_open+0x117>
/work/x86_os_my/fs/file.c:231
		}
	}
	return pcb_fd_install(fd_idx);
c0009f57:	83 ec 0c             	sub    $0xc,%esp
c0009f5a:	ff 75 f4             	pushl  -0xc(%ebp)
c0009f5d:	e8 9c fa ff ff       	call   c00099fe <pcb_fd_install>
c0009f62:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:232
}
c0009f65:	c9                   	leave  
c0009f66:	c3                   	ret    

c0009f67 <file_close>:
file_close():
/work/x86_os_my/fs/file.c:235

/* 关闭文件 */
int32_t file_close(struct file* file) {
c0009f67:	55                   	push   %ebp
c0009f68:	89 e5                	mov    %esp,%ebp
c0009f6a:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/fs/file.c:236
	if (file == NULL) {
c0009f6d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0009f71:	75 07                	jne    c0009f7a <file_close+0x13>
/work/x86_os_my/fs/file.c:237
		return -1;
c0009f73:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009f78:	eb 2e                	jmp    c0009fa8 <file_close+0x41>
/work/x86_os_my/fs/file.c:239
	}
	file->fd_inode->write_deny = false;
c0009f7a:	8b 45 08             	mov    0x8(%ebp),%eax
c0009f7d:	8b 40 08             	mov    0x8(%eax),%eax
c0009f80:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/fs/file.c:240
	inode_close(file->fd_inode);
c0009f87:	8b 45 08             	mov    0x8(%ebp),%eax
c0009f8a:	8b 40 08             	mov    0x8(%eax),%eax
c0009f8d:	83 ec 0c             	sub    $0xc,%esp
c0009f90:	50                   	push   %eax
c0009f91:	e8 f6 f5 ff ff       	call   c000958c <inode_close>
c0009f96:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:241
	file->fd_inode = NULL;   // 使文件结构可用
c0009f99:	8b 45 08             	mov    0x8(%ebp),%eax
c0009f9c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/fs/file.c:242
	return 0;
c0009fa3:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/file.c:243
}
c0009fa8:	c9                   	leave  
c0009fa9:	c3                   	ret    

c0009faa <file_write>:
file_write():
/work/x86_os_my/fs/file.c:246

/* 把buf中的count个字节写入file,成功则返回写入的字节数,失败则返回-1 */
int32_t file_write(struct file* file, const void* buf, uint32_t count) {
c0009faa:	55                   	push   %ebp
c0009fab:	89 e5                	mov    %esp,%ebp
c0009fad:	83 ec 58             	sub    $0x58,%esp
/work/x86_os_my/fs/file.c:247
	if ((file->fd_inode->i_size + count) > (BLOCK_SIZE * 140))	{	// 文件目前最大只支持512B*140块=71680字节【12直接块+128间接块】
c0009fb0:	8b 45 08             	mov    0x8(%ebp),%eax
c0009fb3:	8b 40 08             	mov    0x8(%eax),%eax
c0009fb6:	8b 50 04             	mov    0x4(%eax),%edx
c0009fb9:	8b 45 10             	mov    0x10(%ebp),%eax
c0009fbc:	01 d0                	add    %edx,%eax
c0009fbe:	3d 00 18 01 00       	cmp    $0x11800,%eax
c0009fc3:	76 1a                	jbe    c0009fdf <file_write+0x35>
/work/x86_os_my/fs/file.c:248
		printk("exceed max file_size 71680 bytes, write file failed\n");
c0009fc5:	83 ec 0c             	sub    $0xc,%esp
c0009fc8:	68 f0 f6 00 c0       	push   $0xc000f6f0
c0009fcd:	e8 7b d0 ff ff       	call   c000704d <printk>
c0009fd2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:249
		return -1;
c0009fd5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009fda:	e9 5d 07 00 00       	jmp    c000a73c <file_write+0x792>
/work/x86_os_my/fs/file.c:251
	}
	uint8_t* io_buf = sys_malloc(BLOCK_SIZE);
c0009fdf:	83 ec 0c             	sub    $0xc,%esp
c0009fe2:	68 00 02 00 00       	push   $0x200
c0009fe7:	e8 20 8f ff ff       	call   c0002f0c <sys_malloc>
c0009fec:	83 c4 10             	add    $0x10,%esp
c0009fef:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/file.c:252
	if (io_buf == NULL) {
c0009ff2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0009ff6:	75 1a                	jne    c000a012 <file_write+0x68>
/work/x86_os_my/fs/file.c:253
		printk("file_write: sys_malloc for io_buf failed\n");
c0009ff8:	83 ec 0c             	sub    $0xc,%esp
c0009ffb:	68 28 f7 00 c0       	push   $0xc000f728
c000a000:	e8 48 d0 ff ff       	call   c000704d <printk>
c000a005:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:254
		return -1;
c000a008:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000a00d:	e9 2a 07 00 00       	jmp    c000a73c <file_write+0x792>
/work/x86_os_my/fs/file.c:256
	}
	uint32_t* all_blocks = (uint32_t*)sys_malloc(BLOCK_SIZE + 48);	  // 用来记录文件所有的块地址【560/4=160】
c000a012:	83 ec 0c             	sub    $0xc,%esp
c000a015:	68 30 02 00 00       	push   $0x230
c000a01a:	e8 ed 8e ff ff       	call   c0002f0c <sys_malloc>
c000a01f:	83 c4 10             	add    $0x10,%esp
c000a022:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/file.c:257
	if (all_blocks == NULL) {
c000a025:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c000a029:	75 1a                	jne    c000a045 <file_write+0x9b>
/work/x86_os_my/fs/file.c:258
		printk("file_write: sys_malloc for all_blocks failed\n");
c000a02b:	83 ec 0c             	sub    $0xc,%esp
c000a02e:	68 54 f7 00 c0       	push   $0xc000f754
c000a033:	e8 15 d0 ff ff       	call   c000704d <printk>
c000a038:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:259
		return -1;
c000a03b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000a040:	e9 f7 06 00 00       	jmp    c000a73c <file_write+0x792>
/work/x86_os_my/fs/file.c:262
	}

	int32_t block_lba = -1;			// 块地址
c000a045:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
/work/x86_os_my/fs/file.c:263
	uint32_t block_bitmap_idx = 0;	// block_bitmap中的索引,做为参数传给bitmap_sync
c000a04c:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
/work/x86_os_my/fs/file.c:268
	int32_t indirect_block_table;	// 一级间接表地址
	uint32_t block_idx;				// 块索引

	/* 判断文件是否是第一次写，如果是，先为其分配一个块 */
	if (file->fd_inode->i_sectors[0] == 0) {
c000a053:	8b 45 08             	mov    0x8(%ebp),%eax
c000a056:	8b 40 08             	mov    0x8(%eax),%eax
c000a059:	8b 40 10             	mov    0x10(%eax),%eax
c000a05c:	85 c0                	test   %eax,%eax
c000a05e:	0f 85 8d 00 00 00    	jne    c000a0f1 <file_write+0x147>
/work/x86_os_my/fs/file.c:269
		block_lba = block_bitmap_alloc(cur_part);
c000a064:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a069:	83 ec 0c             	sub    $0xc,%esp
c000a06c:	50                   	push   %eax
c000a06d:	e8 40 fa ff ff       	call   c0009ab2 <block_bitmap_alloc>
c000a072:	83 c4 10             	add    $0x10,%esp
c000a075:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/file.c:270
		if (block_lba == -1) {
c000a078:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
c000a07c:	75 1a                	jne    c000a098 <file_write+0xee>
/work/x86_os_my/fs/file.c:271
			printk("file_write: block_bitmap_alloc failed\n");
c000a07e:	83 ec 0c             	sub    $0xc,%esp
c000a081:	68 84 f7 00 c0       	push   $0xc000f784
c000a086:	e8 c2 cf ff ff       	call   c000704d <printk>
c000a08b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:272
			return -1;
c000a08e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000a093:	e9 a4 06 00 00       	jmp    c000a73c <file_write+0x792>
/work/x86_os_my/fs/file.c:274
		}
		file->fd_inode->i_sectors[0] = block_lba;
c000a098:	8b 45 08             	mov    0x8(%ebp),%eax
c000a09b:	8b 40 08             	mov    0x8(%eax),%eax
c000a09e:	8b 55 d8             	mov    -0x28(%ebp),%edx
c000a0a1:	89 50 10             	mov    %edx,0x10(%eax)
/work/x86_os_my/fs/file.c:277

		/* 每分配一个块就将位图同步到硬盘 */
		block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c000a0a4:	8b 55 d8             	mov    -0x28(%ebp),%edx
c000a0a7:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a0ac:	8b 40 1c             	mov    0x1c(%eax),%eax
c000a0af:	8b 40 28             	mov    0x28(%eax),%eax
c000a0b2:	29 c2                	sub    %eax,%edx
c000a0b4:	89 d0                	mov    %edx,%eax
c000a0b6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/fs/file.c:278
		ASSERT(block_bitmap_idx != 0);
c000a0b9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c000a0bd:	75 1c                	jne    c000a0db <file_write+0x131>
/work/x86_os_my/fs/file.c:278 (discriminator 1)
c000a0bf:	68 ab f7 00 c0       	push   $0xc000f7ab
c000a0c4:	68 f0 f9 00 c0       	push   $0xc000f9f0
c000a0c9:	68 16 01 00 00       	push   $0x116
c000a0ce:	68 c1 f7 00 c0       	push   $0xc000f7c1
c000a0d3:	e8 89 84 ff ff       	call   c0002561 <panic_spin>
c000a0d8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:279
		bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c000a0db:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a0e0:	83 ec 04             	sub    $0x4,%esp
c000a0e3:	6a 01                	push   $0x1
c000a0e5:	ff 75 d4             	pushl  -0x2c(%ebp)
c000a0e8:	50                   	push   %eax
c000a0e9:	e8 16 fa ff ff       	call   c0009b04 <bitmap_sync>
c000a0ee:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:283
	}

	/* 写入count个字节前，该文件已占用的块数 */
	uint32_t file_has_used_blocks = file->fd_inode->i_size / BLOCK_SIZE + 1;
c000a0f1:	8b 45 08             	mov    0x8(%ebp),%eax
c000a0f4:	8b 40 08             	mov    0x8(%eax),%eax
c000a0f7:	8b 40 04             	mov    0x4(%eax),%eax
c000a0fa:	c1 e8 09             	shr    $0x9,%eax
c000a0fd:	83 c0 01             	add    $0x1,%eax
c000a100:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/fs/file.c:285
	/* 写入count个字节后，该文件将占用的块数 */
	uint32_t file_will_use_blocks = (file->fd_inode->i_size + count) / BLOCK_SIZE + 1;
c000a103:	8b 45 08             	mov    0x8(%ebp),%eax
c000a106:	8b 40 08             	mov    0x8(%eax),%eax
c000a109:	8b 50 04             	mov    0x4(%eax),%edx
c000a10c:	8b 45 10             	mov    0x10(%ebp),%eax
c000a10f:	01 d0                	add    %edx,%eax
c000a111:	c1 e8 09             	shr    $0x9,%eax
c000a114:	83 c0 01             	add    $0x1,%eax
c000a117:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/fs/file.c:286
	ASSERT(file_will_use_blocks <= 140);
c000a11a:	81 7d cc 8c 00 00 00 	cmpl   $0x8c,-0x34(%ebp)
c000a121:	76 1c                	jbe    c000a13f <file_write+0x195>
/work/x86_os_my/fs/file.c:286 (discriminator 1)
c000a123:	68 cb f7 00 c0       	push   $0xc000f7cb
c000a128:	68 f0 f9 00 c0       	push   $0xc000f9f0
c000a12d:	68 1e 01 00 00       	push   $0x11e
c000a132:	68 c1 f7 00 c0       	push   $0xc000f7c1
c000a137:	e8 25 84 ff ff       	call   c0002561 <panic_spin>
c000a13c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:288
	/* 通过此增量判断是否需要分配扇区，若增量为0，表示原扇区够用 */
	uint32_t add_blocks = file_will_use_blocks - file_has_used_blocks;
c000a13f:	8b 45 cc             	mov    -0x34(%ebp),%eax
c000a142:	2b 45 d0             	sub    -0x30(%ebp),%eax
c000a145:	89 45 c8             	mov    %eax,-0x38(%ebp)
/work/x86_os_my/fs/file.c:295
	/* 将文件所有块地址收集到all_blocks，后面都统一在all_blocks中获取要写入的扇区地址
	 * 没有新增的数据块时，只更新 all_blocks
	 * 需要新增数据块时，除了 all_blocks 还要更新 file->fd_inode->i_sectors[x]
	 */
	/* 在同一数据块（扇区）内写入数据，不涉及到分配新扇区 */
	if (add_blocks == 0) {
c000a148:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
c000a14c:	0f 85 8c 00 00 00    	jne    c000a1de <file_write+0x234>
/work/x86_os_my/fs/file.c:296
		if (file_has_used_blocks <= 12 ) {	// 文件数据量将在12块之内
c000a152:	83 7d d0 0c          	cmpl   $0xc,-0x30(%ebp)
c000a156:	77 2e                	ja     c000a186 <file_write+0x1dc>
/work/x86_os_my/fs/file.c:297
			block_idx = file_has_used_blocks - 1;	// 指向最后一个已占用的数据块（扇区）
c000a158:	8b 45 d0             	mov    -0x30(%ebp),%eax
c000a15b:	83 e8 01             	sub    $0x1,%eax
c000a15e:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:298
			all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
c000a161:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a164:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000a16b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a16e:	01 c2                	add    %eax,%edx
c000a170:	8b 45 08             	mov    0x8(%ebp),%eax
c000a173:	8b 40 08             	mov    0x8(%eax),%eax
c000a176:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c000a179:	83 c1 04             	add    $0x4,%ecx
c000a17c:	8b 04 88             	mov    (%eax,%ecx,4),%eax
c000a17f:	89 02                	mov    %eax,(%edx)
c000a181:	e9 4e 04 00 00       	jmp    c000a5d4 <file_write+0x62a>
/work/x86_os_my/fs/file.c:301
		} else {
			/* 未写入新数据之前已经占用了间接块,需要将间接块地址读进来 */
			ASSERT(file->fd_inode->i_sectors[12] != 0);	//一级间接表存在
c000a186:	8b 45 08             	mov    0x8(%ebp),%eax
c000a189:	8b 40 08             	mov    0x8(%eax),%eax
c000a18c:	8b 40 40             	mov    0x40(%eax),%eax
c000a18f:	85 c0                	test   %eax,%eax
c000a191:	75 1c                	jne    c000a1af <file_write+0x205>
/work/x86_os_my/fs/file.c:301 (discriminator 1)
c000a193:	68 e8 f7 00 c0       	push   $0xc000f7e8
c000a198:	68 f0 f9 00 c0       	push   $0xc000f9f0
c000a19d:	68 2d 01 00 00       	push   $0x12d
c000a1a2:	68 c1 f7 00 c0       	push   $0xc000f7c1
c000a1a7:	e8 b5 83 ff ff       	call   c0002561 <panic_spin>
c000a1ac:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:302
			indirect_block_table = file->fd_inode->i_sectors[12];
c000a1af:	8b 45 08             	mov    0x8(%ebp),%eax
c000a1b2:	8b 40 08             	mov    0x8(%eax),%eax
c000a1b5:	8b 40 40             	mov    0x40(%eax),%eax
c000a1b8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
/work/x86_os_my/fs/file.c:303
			ide_read(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);	//读出整个一级间接表512字节（128个间接块的地址）
c000a1bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a1be:	8d 48 30             	lea    0x30(%eax),%ecx
c000a1c1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
c000a1c4:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a1c9:	8b 40 08             	mov    0x8(%eax),%eax
c000a1cc:	6a 01                	push   $0x1
c000a1ce:	51                   	push   %ecx
c000a1cf:	52                   	push   %edx
c000a1d0:	50                   	push   %eax
c000a1d1:	e8 fe c3 ff ff       	call   c00065d4 <ide_read>
c000a1d6:	83 c4 10             	add    $0x10,%esp
c000a1d9:	e9 f6 03 00 00       	jmp    c000a5d4 <file_write+0x62a>
/work/x86_os_my/fs/file.c:309
		}
	} else {
	/* 若有增量，便涉及到分配新数据块（扇区），以及是否分配一级间接块表。
	 * 分三种情况处理： */
		/* 第一种情况：12个直接块够用*/
		if (file_will_use_blocks <= 12 ) {
c000a1de:	83 7d cc 0c          	cmpl   $0xc,-0x34(%ebp)
c000a1e2:	0f 87 2b 01 00 00    	ja     c000a313 <file_write+0x369>
/work/x86_os_my/fs/file.c:311
			/* 将有剩余空间的可继续用的数据块（扇区）地址写入all_blocks */
			block_idx = file_has_used_blocks - 1;	// 指向最后一个已占用的数据块（扇区）
c000a1e8:	8b 45 d0             	mov    -0x30(%ebp),%eax
c000a1eb:	83 e8 01             	sub    $0x1,%eax
c000a1ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:312
			ASSERT(file->fd_inode->i_sectors[block_idx] != 0);
c000a1f1:	8b 45 08             	mov    0x8(%ebp),%eax
c000a1f4:	8b 40 08             	mov    0x8(%eax),%eax
c000a1f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000a1fa:	83 c2 04             	add    $0x4,%edx
c000a1fd:	8b 04 90             	mov    (%eax,%edx,4),%eax
c000a200:	85 c0                	test   %eax,%eax
c000a202:	75 1c                	jne    c000a220 <file_write+0x276>
/work/x86_os_my/fs/file.c:312 (discriminator 1)
c000a204:	68 0c f8 00 c0       	push   $0xc000f80c
c000a209:	68 f0 f9 00 c0       	push   $0xc000f9f0
c000a20e:	68 38 01 00 00       	push   $0x138
c000a213:	68 c1 f7 00 c0       	push   $0xc000f7c1
c000a218:	e8 44 83 ff ff       	call   c0002561 <panic_spin>
c000a21d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:313
			all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
c000a220:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a223:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000a22a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a22d:	01 c2                	add    %eax,%edx
c000a22f:	8b 45 08             	mov    0x8(%ebp),%eax
c000a232:	8b 40 08             	mov    0x8(%eax),%eax
c000a235:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c000a238:	83 c1 04             	add    $0x4,%ecx
c000a23b:	8b 04 88             	mov    (%eax,%ecx,4),%eax
c000a23e:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/file.c:316

			/* 将未来要用的新数据块（扇区）分配好后写入all_blocks */
			block_idx = file_has_used_blocks;		// 指向第一个要分配的新数据块（扇区）
c000a240:	8b 45 d0             	mov    -0x30(%ebp),%eax
c000a243:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:317
			while (block_idx < file_will_use_blocks) {
c000a246:	e9 b7 00 00 00       	jmp    c000a302 <file_write+0x358>
/work/x86_os_my/fs/file.c:318
				block_lba = block_bitmap_alloc(cur_part);
c000a24b:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a250:	83 ec 0c             	sub    $0xc,%esp
c000a253:	50                   	push   %eax
c000a254:	e8 59 f8 ff ff       	call   c0009ab2 <block_bitmap_alloc>
c000a259:	83 c4 10             	add    $0x10,%esp
c000a25c:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/file.c:319
				if (block_lba == -1) {
c000a25f:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
c000a263:	75 1a                	jne    c000a27f <file_write+0x2d5>
/work/x86_os_my/fs/file.c:320
					printk("file_write: block_bitmap_alloc for situation 1 failed\n");
c000a265:	83 ec 0c             	sub    $0xc,%esp
c000a268:	68 38 f8 00 c0       	push   $0xc000f838
c000a26d:	e8 db cd ff ff       	call   c000704d <printk>
c000a272:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:321
					return -1;
c000a275:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000a27a:	e9 bd 04 00 00       	jmp    c000a73c <file_write+0x792>
/work/x86_os_my/fs/file.c:325
				}

				/* 写文件时，数据块未使用时肯定有 i_sectors[x]==0。因为文件删除时，会把i_sectors[x]里的数据块地址清0 */
				ASSERT(file->fd_inode->i_sectors[block_idx] == 0);	// 确保尚未分配扇区地址
c000a27f:	8b 45 08             	mov    0x8(%ebp),%eax
c000a282:	8b 40 08             	mov    0x8(%eax),%eax
c000a285:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000a288:	83 c2 04             	add    $0x4,%edx
c000a28b:	8b 04 90             	mov    (%eax,%edx,4),%eax
c000a28e:	85 c0                	test   %eax,%eax
c000a290:	74 1c                	je     c000a2ae <file_write+0x304>
/work/x86_os_my/fs/file.c:325 (discriminator 1)
c000a292:	68 70 f8 00 c0       	push   $0xc000f870
c000a297:	68 f0 f9 00 c0       	push   $0xc000f9f0
c000a29c:	68 45 01 00 00       	push   $0x145
c000a2a1:	68 c1 f7 00 c0       	push   $0xc000f7c1
c000a2a6:	e8 b6 82 ff ff       	call   c0002561 <panic_spin>
c000a2ab:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:326
				file->fd_inode->i_sectors[block_idx] = all_blocks[block_idx] = block_lba;		//处理直接块
c000a2ae:	8b 45 08             	mov    0x8(%ebp),%eax
c000a2b1:	8b 50 08             	mov    0x8(%eax),%edx
c000a2b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a2b7:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c000a2be:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a2c1:	01 c8                	add    %ecx,%eax
c000a2c3:	8b 4d d8             	mov    -0x28(%ebp),%ecx
c000a2c6:	89 08                	mov    %ecx,(%eax)
c000a2c8:	8b 00                	mov    (%eax),%eax
c000a2ca:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c000a2cd:	83 c1 04             	add    $0x4,%ecx
c000a2d0:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
/work/x86_os_my/fs/file.c:329

				/* 每分配一个块就将位图同步到硬盘 */
				block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c000a2d3:	8b 55 d8             	mov    -0x28(%ebp),%edx
c000a2d6:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a2db:	8b 40 1c             	mov    0x1c(%eax),%eax
c000a2de:	8b 40 28             	mov    0x28(%eax),%eax
c000a2e1:	29 c2                	sub    %eax,%edx
c000a2e3:	89 d0                	mov    %edx,%eax
c000a2e5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/fs/file.c:331
				// 这回怎么没有这句了：ASSERT(block_bitmap_idx != 0);
				bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c000a2e8:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a2ed:	83 ec 04             	sub    $0x4,%esp
c000a2f0:	6a 01                	push   $0x1
c000a2f2:	ff 75 d4             	pushl  -0x2c(%ebp)
c000a2f5:	50                   	push   %eax
c000a2f6:	e8 09 f8 ff ff       	call   c0009b04 <bitmap_sync>
c000a2fb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:333

				block_idx++;   // 下一个分配的新扇区
c000a2fe:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/file.c:317
			ASSERT(file->fd_inode->i_sectors[block_idx] != 0);
			all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];

			/* 将未来要用的新数据块（扇区）分配好后写入all_blocks */
			block_idx = file_has_used_blocks;		// 指向第一个要分配的新数据块（扇区）
			while (block_idx < file_will_use_blocks) {
c000a302:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a305:	3b 45 cc             	cmp    -0x34(%ebp),%eax
c000a308:	0f 82 3d ff ff ff    	jb     c000a24b <file_write+0x2a1>
c000a30e:	e9 c1 02 00 00       	jmp    c000a5d4 <file_write+0x62a>
/work/x86_os_my/fs/file.c:335
				// 这回怎么没有这句了：ASSERT(block_bitmap_idx != 0);
				bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);

				block_idx++;   // 下一个分配的新扇区
			}
		} else if (file_has_used_blocks <= 12 && file_will_use_blocks > 12) {
c000a313:	83 7d d0 0c          	cmpl   $0xc,-0x30(%ebp)
c000a317:	0f 87 af 01 00 00    	ja     c000a4cc <file_write+0x522>
/work/x86_os_my/fs/file.c:335 (discriminator 1)
c000a31d:	83 7d cc 0c          	cmpl   $0xc,-0x34(%ebp)
c000a321:	0f 86 a5 01 00 00    	jbe    c000a4cc <file_write+0x522>
/work/x86_os_my/fs/file.c:339
		/* 第二种情况：旧数据在12个直接块内，新数据将使用间接块【可能也使用一些直接块】 */

			/* 先将有剩余空间的可继续用的扇区地址收集到all_blocks */
			block_idx = file_has_used_blocks - 1;	// 指向最后一个已占用的数据块（扇区）
c000a327:	8b 45 d0             	mov    -0x30(%ebp),%eax
c000a32a:	83 e8 01             	sub    $0x1,%eax
c000a32d:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:340
			all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];						//处理直接块
c000a330:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a333:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000a33a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a33d:	01 c2                	add    %eax,%edx
c000a33f:	8b 45 08             	mov    0x8(%ebp),%eax
c000a342:	8b 40 08             	mov    0x8(%eax),%eax
c000a345:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c000a348:	83 c1 04             	add    $0x4,%ecx
c000a34b:	8b 04 88             	mov    (%eax,%ecx,4),%eax
c000a34e:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/file.c:343

			/* 创建一级间接块表 */
			block_lba = block_bitmap_alloc(cur_part);
c000a350:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a355:	83 ec 0c             	sub    $0xc,%esp
c000a358:	50                   	push   %eax
c000a359:	e8 54 f7 ff ff       	call   c0009ab2 <block_bitmap_alloc>
c000a35e:	83 c4 10             	add    $0x10,%esp
c000a361:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/file.c:344
			if (block_lba == -1) {
c000a364:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
c000a368:	75 1a                	jne    c000a384 <file_write+0x3da>
/work/x86_os_my/fs/file.c:345
				printk("file_write: block_bitmap_alloc for situation 2 failed\n");
c000a36a:	83 ec 0c             	sub    $0xc,%esp
c000a36d:	68 9c f8 00 c0       	push   $0xc000f89c
c000a372:	e8 d6 cc ff ff       	call   c000704d <printk>
c000a377:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:346
				return -1;
c000a37a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000a37f:	e9 b8 03 00 00       	jmp    c000a73c <file_write+0x792>
/work/x86_os_my/fs/file.c:348
			}
			ASSERT(file->fd_inode->i_sectors[12] == 0);  // 一级间接块表未建立
c000a384:	8b 45 08             	mov    0x8(%ebp),%eax
c000a387:	8b 40 08             	mov    0x8(%eax),%eax
c000a38a:	8b 40 40             	mov    0x40(%eax),%eax
c000a38d:	85 c0                	test   %eax,%eax
c000a38f:	74 1c                	je     c000a3ad <file_write+0x403>
/work/x86_os_my/fs/file.c:348 (discriminator 1)
c000a391:	68 d4 f8 00 c0       	push   $0xc000f8d4
c000a396:	68 f0 f9 00 c0       	push   $0xc000f9f0
c000a39b:	68 5c 01 00 00       	push   $0x15c
c000a3a0:	68 c1 f7 00 c0       	push   $0xc000f7c1
c000a3a5:	e8 b7 81 ff ff       	call   c0002561 <panic_spin>
c000a3aa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:349
			indirect_block_table = file->fd_inode->i_sectors[12] = block_lba;	// 一级间接块索引表建立了！
c000a3ad:	8b 45 08             	mov    0x8(%ebp),%eax
c000a3b0:	8b 40 08             	mov    0x8(%eax),%eax
c000a3b3:	8b 55 d8             	mov    -0x28(%ebp),%edx
c000a3b6:	89 50 40             	mov    %edx,0x40(%eax)
c000a3b9:	8b 40 40             	mov    0x40(%eax),%eax
c000a3bc:	89 45 c4             	mov    %eax,-0x3c(%ebp)
/work/x86_os_my/fs/file.c:352
			//这里怎么没有同步一级间接块表占用的数据块到硬盘？？不是：每分配一个块就将位图同步到硬盘 吗？

			block_idx = file_has_used_blocks;		// 指向第一个要分配的新数据块（扇区）
c000a3bf:	8b 45 d0             	mov    -0x30(%ebp),%eax
c000a3c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:353
			while (block_idx < file_will_use_blocks) {
c000a3c5:	e9 d3 00 00 00       	jmp    c000a49d <file_write+0x4f3>
/work/x86_os_my/fs/file.c:354
				block_lba = block_bitmap_alloc(cur_part);
c000a3ca:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a3cf:	83 ec 0c             	sub    $0xc,%esp
c000a3d2:	50                   	push   %eax
c000a3d3:	e8 da f6 ff ff       	call   c0009ab2 <block_bitmap_alloc>
c000a3d8:	83 c4 10             	add    $0x10,%esp
c000a3db:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/file.c:355
				if (block_lba == -1) {
c000a3de:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
c000a3e2:	75 1a                	jne    c000a3fe <file_write+0x454>
/work/x86_os_my/fs/file.c:356
					printk("file_write: block_bitmap_alloc for situation 2 failed\n");
c000a3e4:	83 ec 0c             	sub    $0xc,%esp
c000a3e7:	68 9c f8 00 c0       	push   $0xc000f89c
c000a3ec:	e8 5c cc ff ff       	call   c000704d <printk>
c000a3f1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:357
					return -1;
c000a3f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000a3f9:	e9 3e 03 00 00       	jmp    c000a73c <file_write+0x792>
/work/x86_os_my/fs/file.c:360
				}

				if (block_idx < 12) {	// 新创建的数据块仍然是直接块！
c000a3fe:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
c000a402:	77 56                	ja     c000a45a <file_write+0x4b0>
/work/x86_os_my/fs/file.c:361
					ASSERT(file->fd_inode->i_sectors[block_idx] == 0);
c000a404:	8b 45 08             	mov    0x8(%ebp),%eax
c000a407:	8b 40 08             	mov    0x8(%eax),%eax
c000a40a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000a40d:	83 c2 04             	add    $0x4,%edx
c000a410:	8b 04 90             	mov    (%eax,%edx,4),%eax
c000a413:	85 c0                	test   %eax,%eax
c000a415:	74 1c                	je     c000a433 <file_write+0x489>
/work/x86_os_my/fs/file.c:361 (discriminator 1)
c000a417:	68 70 f8 00 c0       	push   $0xc000f870
c000a41c:	68 f0 f9 00 c0       	push   $0xc000f9f0
c000a421:	68 69 01 00 00       	push   $0x169
c000a426:	68 c1 f7 00 c0       	push   $0xc000f7c1
c000a42b:	e8 31 81 ff ff       	call   c0002561 <panic_spin>
c000a430:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:362
					file->fd_inode->i_sectors[block_idx] = all_blocks[block_idx] = block_lba;	//处理直接块
c000a433:	8b 45 08             	mov    0x8(%ebp),%eax
c000a436:	8b 50 08             	mov    0x8(%eax),%edx
c000a439:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a43c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c000a443:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a446:	01 c8                	add    %ecx,%eax
c000a448:	8b 4d d8             	mov    -0x28(%ebp),%ecx
c000a44b:	89 08                	mov    %ecx,(%eax)
c000a44d:	8b 00                	mov    (%eax),%eax
c000a44f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c000a452:	83 c1 04             	add    $0x4,%ecx
c000a455:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
c000a458:	eb 14                	jmp    c000a46e <file_write+0x4c4>
/work/x86_os_my/fs/file.c:364
				} else {	// 新创建的数据块，是间接块。间接块只写入到all_block数组中,待全部分配完成后一次性同步到硬盘
					all_blocks[block_idx] = block_lba;											//处理间接块
c000a45a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a45d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000a464:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a467:	01 c2                	add    %eax,%edx
c000a469:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000a46c:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/file.c:368
				}

				/* 每分配一个块就将位图同步到硬盘 */
				block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c000a46e:	8b 55 d8             	mov    -0x28(%ebp),%edx
c000a471:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a476:	8b 40 1c             	mov    0x1c(%eax),%eax
c000a479:	8b 40 28             	mov    0x28(%eax),%eax
c000a47c:	29 c2                	sub    %eax,%edx
c000a47e:	89 d0                	mov    %edx,%eax
c000a480:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/fs/file.c:369
				bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c000a483:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a488:	83 ec 04             	sub    $0x4,%esp
c000a48b:	6a 01                	push   $0x1
c000a48d:	ff 75 d4             	pushl  -0x2c(%ebp)
c000a490:	50                   	push   %eax
c000a491:	e8 6e f6 ff ff       	call   c0009b04 <bitmap_sync>
c000a496:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:371

				block_idx++;   // 下一个新扇区
c000a499:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/file.c:353
			ASSERT(file->fd_inode->i_sectors[12] == 0);  // 一级间接块表未建立
			indirect_block_table = file->fd_inode->i_sectors[12] = block_lba;	// 一级间接块索引表建立了！
			//这里怎么没有同步一级间接块表占用的数据块到硬盘？？不是：每分配一个块就将位图同步到硬盘 吗？

			block_idx = file_has_used_blocks;		// 指向第一个要分配的新数据块（扇区）
			while (block_idx < file_will_use_blocks) {
c000a49d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a4a0:	3b 45 cc             	cmp    -0x34(%ebp),%eax
c000a4a3:	0f 82 21 ff ff ff    	jb     c000a3ca <file_write+0x420>
/work/x86_os_my/fs/file.c:373
				block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
				bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);

				block_idx++;   // 下一个新扇区
			}
			ide_write(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);	// 整个一级间接块表的内容，同步到硬盘
c000a4a9:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a4ac:	8d 48 30             	lea    0x30(%eax),%ecx
c000a4af:	8b 55 c4             	mov    -0x3c(%ebp),%edx
c000a4b2:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a4b7:	8b 40 08             	mov    0x8(%eax),%eax
c000a4ba:	6a 01                	push   $0x1
c000a4bc:	51                   	push   %ecx
c000a4bd:	52                   	push   %edx
c000a4be:	50                   	push   %eax
c000a4bf:	e8 84 c2 ff ff       	call   c0006748 <ide_write>
c000a4c4:	83 c4 10             	add    $0x10,%esp
c000a4c7:	e9 08 01 00 00       	jmp    c000a5d4 <file_write+0x62a>
/work/x86_os_my/fs/file.c:374
		} else if (file_has_used_blocks > 12) {
c000a4cc:	83 7d d0 0c          	cmpl   $0xc,-0x30(%ebp)
c000a4d0:	0f 86 fe 00 00 00    	jbe    c000a5d4 <file_write+0x62a>
/work/x86_os_my/fs/file.c:376
		/* 第三种情况：新数据使用间接块*/
			ASSERT(file->fd_inode->i_sectors[12] != 0);				// 一级间接块表已建立
c000a4d6:	8b 45 08             	mov    0x8(%ebp),%eax
c000a4d9:	8b 40 08             	mov    0x8(%eax),%eax
c000a4dc:	8b 40 40             	mov    0x40(%eax),%eax
c000a4df:	85 c0                	test   %eax,%eax
c000a4e1:	75 1c                	jne    c000a4ff <file_write+0x555>
/work/x86_os_my/fs/file.c:376 (discriminator 1)
c000a4e3:	68 e8 f7 00 c0       	push   $0xc000f7e8
c000a4e8:	68 f0 f9 00 c0       	push   $0xc000f9f0
c000a4ed:	68 78 01 00 00       	push   $0x178
c000a4f2:	68 c1 f7 00 c0       	push   $0xc000f7c1
c000a4f7:	e8 65 80 ff ff       	call   c0002561 <panic_spin>
c000a4fc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:377
			indirect_block_table = file->fd_inode->i_sectors[12];	// 一级间接表地址
c000a4ff:	8b 45 08             	mov    0x8(%ebp),%eax
c000a502:	8b 40 08             	mov    0x8(%eax),%eax
c000a505:	8b 40 40             	mov    0x40(%eax),%eax
c000a508:	89 45 c4             	mov    %eax,-0x3c(%ebp)
/work/x86_os_my/fs/file.c:380

			/* 已使用的间接块也将被读入all_blocks，无须单独收录 */
			ide_read(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);	// 获取所有间接块地址
c000a50b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a50e:	8d 48 30             	lea    0x30(%eax),%ecx
c000a511:	8b 55 c4             	mov    -0x3c(%ebp),%edx
c000a514:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a519:	8b 40 08             	mov    0x8(%eax),%eax
c000a51c:	6a 01                	push   $0x1
c000a51e:	51                   	push   %ecx
c000a51f:	52                   	push   %edx
c000a520:	50                   	push   %eax
c000a521:	e8 ae c0 ff ff       	call   c00065d4 <ide_read>
c000a526:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:382

			block_idx = file_has_used_blocks;		// 指向第一个要分配的新数据块（扇区）
c000a529:	8b 45 d0             	mov    -0x30(%ebp),%eax
c000a52c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:383
			while (block_idx < file_will_use_blocks) {
c000a52f:	eb 79                	jmp    c000a5aa <file_write+0x600>
/work/x86_os_my/fs/file.c:384
				block_lba = block_bitmap_alloc(cur_part);
c000a531:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a536:	83 ec 0c             	sub    $0xc,%esp
c000a539:	50                   	push   %eax
c000a53a:	e8 73 f5 ff ff       	call   c0009ab2 <block_bitmap_alloc>
c000a53f:	83 c4 10             	add    $0x10,%esp
c000a542:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/file.c:385
				if (block_lba == -1) {
c000a545:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
c000a549:	75 1a                	jne    c000a565 <file_write+0x5bb>
/work/x86_os_my/fs/file.c:386
					printk("file_write: block_bitmap_alloc for situation 3 failed\n");
c000a54b:	83 ec 0c             	sub    $0xc,%esp
c000a54e:	68 f8 f8 00 c0       	push   $0xc000f8f8
c000a553:	e8 f5 ca ff ff       	call   c000704d <printk>
c000a558:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:387
					return -1;
c000a55b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000a560:	e9 d7 01 00 00       	jmp    c000a73c <file_write+0x792>
/work/x86_os_my/fs/file.c:389
				}
				all_blocks[block_idx++] = block_lba;											//处理间接块
c000a565:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a568:	8d 50 01             	lea    0x1(%eax),%edx
c000a56b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000a56e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000a575:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a578:	01 c2                	add    %eax,%edx
c000a57a:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000a57d:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/file.c:392

				/* 每分配一个块就将位图同步到硬盘 */
				block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c000a57f:	8b 55 d8             	mov    -0x28(%ebp),%edx
c000a582:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a587:	8b 40 1c             	mov    0x1c(%eax),%eax
c000a58a:	8b 40 28             	mov    0x28(%eax),%eax
c000a58d:	29 c2                	sub    %eax,%edx
c000a58f:	89 d0                	mov    %edx,%eax
c000a591:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/fs/file.c:393
				bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c000a594:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a599:	83 ec 04             	sub    $0x4,%esp
c000a59c:	6a 01                	push   $0x1
c000a59e:	ff 75 d4             	pushl  -0x2c(%ebp)
c000a5a1:	50                   	push   %eax
c000a5a2:	e8 5d f5 ff ff       	call   c0009b04 <bitmap_sync>
c000a5a7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:383

			/* 已使用的间接块也将被读入all_blocks，无须单独收录 */
			ide_read(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);	// 获取所有间接块地址

			block_idx = file_has_used_blocks;		// 指向第一个要分配的新数据块（扇区）
			while (block_idx < file_will_use_blocks) {
c000a5aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a5ad:	3b 45 cc             	cmp    -0x34(%ebp),%eax
c000a5b0:	0f 82 7b ff ff ff    	jb     c000a531 <file_write+0x587>
/work/x86_os_my/fs/file.c:395

				/* 每分配一个块就将位图同步到硬盘 */
				block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
				bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
			}
			ide_write(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);	// 整个一级间接块表的内容，同步到硬盘
c000a5b6:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a5b9:	8d 48 30             	lea    0x30(%eax),%ecx
c000a5bc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
c000a5bf:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a5c4:	8b 40 08             	mov    0x8(%eax),%eax
c000a5c7:	6a 01                	push   $0x1
c000a5c9:	51                   	push   %ecx
c000a5ca:	52                   	push   %edx
c000a5cb:	50                   	push   %eax
c000a5cc:	e8 77 c1 ff ff       	call   c0006748 <ide_write>
c000a5d1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:401
		}
	}//块地址已经收集到all_blocks中


	/* 写数据 */
	const uint8_t* src = buf;		// 用src指向buf中待写入的数据
c000a5d4:	8b 45 0c             	mov    0xc(%ebp),%eax
c000a5d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:402
	uint32_t bytes_written = 0;		// 已写入数据的大小
c000a5da:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/file.c:408
	uint32_t sec_idx;				// 扇区索引
	uint32_t sec_lba;				// 扇区地址
	uint32_t sec_off_bytes;			// 扇区内字节偏移量
	uint32_t sec_left_bytes;		// 扇区内剩余字节量
	uint32_t chunk_size;			// 每次写入硬盘的数据块大小
	uint32_t size_left = count;		// 未写入数据的大小
c000a5e1:	8b 45 10             	mov    0x10(%ebp),%eax
c000a5e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:409
	bool first_write_block = true;	// 数据块（扇区）含有剩余空间的标识
c000a5e7:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:410
	file->fd_pos = file->fd_inode->i_size - 1;	// 文件读写指针fd_pos为"文件大小-1"
c000a5ee:	8b 45 08             	mov    0x8(%ebp),%eax
c000a5f1:	8b 40 08             	mov    0x8(%eax),%eax
c000a5f4:	8b 40 04             	mov    0x4(%eax),%eax
c000a5f7:	8d 50 ff             	lea    -0x1(%eax),%edx
c000a5fa:	8b 45 08             	mov    0x8(%ebp),%eax
c000a5fd:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/file.c:411
	while (bytes_written < count) {	// 直到写完所有数据
c000a5ff:	e9 f2 00 00 00       	jmp    c000a6f6 <file_write+0x74c>
/work/x86_os_my/fs/file.c:412
		memset(io_buf, 0, BLOCK_SIZE);
c000a604:	83 ec 04             	sub    $0x4,%esp
c000a607:	68 00 02 00 00       	push   $0x200
c000a60c:	6a 00                	push   $0x0
c000a60e:	ff 75 e0             	pushl  -0x20(%ebp)
c000a611:	e8 4f 94 ff ff       	call   c0003a65 <memset>
c000a616:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:413
		sec_idx = file->fd_inode->i_size / BLOCK_SIZE;	// 文件已占用的最后一个数据块
c000a619:	8b 45 08             	mov    0x8(%ebp),%eax
c000a61c:	8b 40 08             	mov    0x8(%eax),%eax
c000a61f:	8b 40 04             	mov    0x4(%eax),%eax
c000a622:	c1 e8 09             	shr    $0x9,%eax
c000a625:	89 45 c0             	mov    %eax,-0x40(%ebp)
/work/x86_os_my/fs/file.c:414
		sec_lba = all_blocks[sec_idx];
c000a628:	8b 45 c0             	mov    -0x40(%ebp),%eax
c000a62b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000a632:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a635:	01 d0                	add    %edx,%eax
c000a637:	8b 00                	mov    (%eax),%eax
c000a639:	89 45 bc             	mov    %eax,-0x44(%ebp)
/work/x86_os_my/fs/file.c:415
		sec_off_bytes = file->fd_inode->i_size % BLOCK_SIZE;
c000a63c:	8b 45 08             	mov    0x8(%ebp),%eax
c000a63f:	8b 40 08             	mov    0x8(%eax),%eax
c000a642:	8b 40 04             	mov    0x4(%eax),%eax
c000a645:	25 ff 01 00 00       	and    $0x1ff,%eax
c000a64a:	89 45 b8             	mov    %eax,-0x48(%ebp)
/work/x86_os_my/fs/file.c:416
		sec_left_bytes = BLOCK_SIZE - sec_off_bytes;
c000a64d:	b8 00 02 00 00       	mov    $0x200,%eax
c000a652:	2b 45 b8             	sub    -0x48(%ebp),%eax
c000a655:	89 45 b4             	mov    %eax,-0x4c(%ebp)
/work/x86_os_my/fs/file.c:419

		/* 判断此次写入硬盘的数据大小 */
		chunk_size = size_left < sec_left_bytes ? size_left : sec_left_bytes;
c000a658:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000a65b:	39 45 b4             	cmp    %eax,-0x4c(%ebp)
c000a65e:	0f 46 45 b4          	cmovbe -0x4c(%ebp),%eax
c000a662:	89 45 b0             	mov    %eax,-0x50(%ebp)
/work/x86_os_my/fs/file.c:420
		if (first_write_block) {
c000a665:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c000a669:	74 20                	je     c000a68b <file_write+0x6e1>
/work/x86_os_my/fs/file.c:421
			ide_read(cur_part->my_disk, sec_lba, io_buf, 1);	//先读出
c000a66b:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a670:	8b 40 08             	mov    0x8(%eax),%eax
c000a673:	6a 01                	push   $0x1
c000a675:	ff 75 e0             	pushl  -0x20(%ebp)
c000a678:	ff 75 bc             	pushl  -0x44(%ebp)
c000a67b:	50                   	push   %eax
c000a67c:	e8 53 bf ff ff       	call   c00065d4 <ide_read>
c000a681:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:422
			first_write_block = false;
c000a684:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:424
		}
		memcpy(io_buf + sec_off_bytes, src, chunk_size);		//再写入
c000a68b:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000a68e:	8b 45 b8             	mov    -0x48(%ebp),%eax
c000a691:	01 d0                	add    %edx,%eax
c000a693:	83 ec 04             	sub    $0x4,%esp
c000a696:	ff 75 b0             	pushl  -0x50(%ebp)
c000a699:	ff 75 f0             	pushl  -0x10(%ebp)
c000a69c:	50                   	push   %eax
c000a69d:	e8 15 94 ff ff       	call   c0003ab7 <memcpy>
c000a6a2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:425
		ide_write(cur_part->my_disk, sec_lba, io_buf, 1);
c000a6a5:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a6aa:	8b 40 08             	mov    0x8(%eax),%eax
c000a6ad:	6a 01                	push   $0x1
c000a6af:	ff 75 e0             	pushl  -0x20(%ebp)
c000a6b2:	ff 75 bc             	pushl  -0x44(%ebp)
c000a6b5:	50                   	push   %eax
c000a6b6:	e8 8d c0 ff ff       	call   c0006748 <ide_write>
c000a6bb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:428
		//printk("file write at lba 0x%x\n", sec_lba);

		src += chunk_size;
c000a6be:	8b 45 b0             	mov    -0x50(%ebp),%eax
c000a6c1:	01 45 f0             	add    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:429
		file->fd_inode->i_size += chunk_size;	// 文件大小
c000a6c4:	8b 45 08             	mov    0x8(%ebp),%eax
c000a6c7:	8b 40 08             	mov    0x8(%eax),%eax
c000a6ca:	8b 55 08             	mov    0x8(%ebp),%edx
c000a6cd:	8b 52 08             	mov    0x8(%edx),%edx
c000a6d0:	8b 4a 04             	mov    0x4(%edx),%ecx
c000a6d3:	8b 55 b0             	mov    -0x50(%ebp),%edx
c000a6d6:	01 ca                	add    %ecx,%edx
c000a6d8:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/file.c:430
		file->fd_pos += chunk_size;				// 文件指针位置
c000a6db:	8b 45 08             	mov    0x8(%ebp),%eax
c000a6de:	8b 10                	mov    (%eax),%edx
c000a6e0:	8b 45 b0             	mov    -0x50(%ebp),%eax
c000a6e3:	01 c2                	add    %eax,%edx
c000a6e5:	8b 45 08             	mov    0x8(%ebp),%eax
c000a6e8:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/file.c:431
		bytes_written += chunk_size;
c000a6ea:	8b 45 b0             	mov    -0x50(%ebp),%eax
c000a6ed:	01 45 ec             	add    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:432
		size_left -= chunk_size;
c000a6f0:	8b 45 b0             	mov    -0x50(%ebp),%eax
c000a6f3:	29 45 e8             	sub    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:411
	uint32_t sec_left_bytes;		// 扇区内剩余字节量
	uint32_t chunk_size;			// 每次写入硬盘的数据块大小
	uint32_t size_left = count;		// 未写入数据的大小
	bool first_write_block = true;	// 数据块（扇区）含有剩余空间的标识
	file->fd_pos = file->fd_inode->i_size - 1;	// 文件读写指针fd_pos为"文件大小-1"
	while (bytes_written < count) {	// 直到写完所有数据
c000a6f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000a6f9:	3b 45 10             	cmp    0x10(%ebp),%eax
c000a6fc:	0f 82 02 ff ff ff    	jb     c000a604 <file_write+0x65a>
/work/x86_os_my/fs/file.c:434
		file->fd_inode->i_size += chunk_size;	// 文件大小
		file->fd_pos += chunk_size;				// 文件指针位置
		bytes_written += chunk_size;
		size_left -= chunk_size;
	}
	inode_sync(cur_part, file->fd_inode, io_buf);	// 更新文件对应的inode结构，io_buf只是个缓冲区
c000a702:	8b 45 08             	mov    0x8(%ebp),%eax
c000a705:	8b 50 08             	mov    0x8(%eax),%edx
c000a708:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a70d:	83 ec 04             	sub    $0x4,%esp
c000a710:	ff 75 e0             	pushl  -0x20(%ebp)
c000a713:	52                   	push   %edx
c000a714:	50                   	push   %eax
c000a715:	e8 05 ec ff ff       	call   c000931f <inode_sync>
c000a71a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:435
	sys_free(all_blocks);
c000a71d:	83 ec 0c             	sub    $0xc,%esp
c000a720:	ff 75 dc             	pushl  -0x24(%ebp)
c000a723:	e8 11 8e ff ff       	call   c0003539 <sys_free>
c000a728:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:436
	sys_free(io_buf);
c000a72b:	83 ec 0c             	sub    $0xc,%esp
c000a72e:	ff 75 e0             	pushl  -0x20(%ebp)
c000a731:	e8 03 8e ff ff       	call   c0003539 <sys_free>
c000a736:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:437
	return bytes_written;
c000a739:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/fs/file.c:438
}
c000a73c:	c9                   	leave  
c000a73d:	c3                   	ret    

c000a73e <file_read>:
file_read():
/work/x86_os_my/fs/file.c:442


/* 从文件file中读取count个字节写入buf, 返回读出的字节数,若到文件尾则返回-1 */
int32_t file_read(struct file* file, void* buf, uint32_t count) {
c000a73e:	55                   	push   %ebp
c000a73f:	89 e5                	mov    %esp,%ebp
c000a741:	83 ec 48             	sub    $0x48,%esp
/work/x86_os_my/fs/file.c:443
	uint8_t* buf_dst = (uint8_t*)buf;
c000a744:	8b 45 0c             	mov    0xc(%ebp),%eax
c000a747:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:444
	uint32_t size = count, size_left = size;
c000a74a:	8b 45 10             	mov    0x10(%ebp),%eax
c000a74d:	89 45 f0             	mov    %eax,-0x10(%ebp)
c000a750:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000a753:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:447

	/* 若要读取的字节数超过了文件可读的剩余量, 就用剩余量做为待读取的字节数 */
	if ((file->fd_pos + count) > file->fd_inode->i_size) {
c000a756:	8b 45 08             	mov    0x8(%ebp),%eax
c000a759:	8b 10                	mov    (%eax),%edx
c000a75b:	8b 45 10             	mov    0x10(%ebp),%eax
c000a75e:	01 c2                	add    %eax,%edx
c000a760:	8b 45 08             	mov    0x8(%ebp),%eax
c000a763:	8b 40 08             	mov    0x8(%eax),%eax
c000a766:	8b 40 04             	mov    0x4(%eax),%eax
c000a769:	39 c2                	cmp    %eax,%edx
c000a76b:	76 2b                	jbe    c000a798 <file_read+0x5a>
/work/x86_os_my/fs/file.c:448
		size = file->fd_inode->i_size - file->fd_pos;
c000a76d:	8b 45 08             	mov    0x8(%ebp),%eax
c000a770:	8b 40 08             	mov    0x8(%eax),%eax
c000a773:	8b 50 04             	mov    0x4(%eax),%edx
c000a776:	8b 45 08             	mov    0x8(%ebp),%eax
c000a779:	8b 00                	mov    (%eax),%eax
c000a77b:	29 c2                	sub    %eax,%edx
c000a77d:	89 d0                	mov    %edx,%eax
c000a77f:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:449
		size_left = size;
c000a782:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000a785:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:450
		if (size == 0) {	// 若到文件尾则返回-1
c000a788:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000a78c:	75 0a                	jne    c000a798 <file_read+0x5a>
/work/x86_os_my/fs/file.c:451
			return -1;
c000a78e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000a793:	e9 4d 03 00 00       	jmp    c000aae5 <file_read+0x3a7>
/work/x86_os_my/fs/file.c:455
		}
	}

	uint8_t* io_buf = sys_malloc(BLOCK_SIZE);
c000a798:	83 ec 0c             	sub    $0xc,%esp
c000a79b:	68 00 02 00 00       	push   $0x200
c000a7a0:	e8 67 87 ff ff       	call   c0002f0c <sys_malloc>
c000a7a5:	83 c4 10             	add    $0x10,%esp
c000a7a8:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/file.c:456
	if (io_buf == NULL) {
c000a7ab:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c000a7af:	75 10                	jne    c000a7c1 <file_read+0x83>
/work/x86_os_my/fs/file.c:457
		printk("file_read: sys_malloc for io_buf failed\n");
c000a7b1:	83 ec 0c             	sub    $0xc,%esp
c000a7b4:	68 30 f9 00 c0       	push   $0xc000f930
c000a7b9:	e8 8f c8 ff ff       	call   c000704d <printk>
c000a7be:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:459
	}
	uint32_t* all_blocks = (uint32_t*)sys_malloc(BLOCK_SIZE + 48);		// 用来记录文件所有的块地址【140*4=560字节】
c000a7c1:	83 ec 0c             	sub    $0xc,%esp
c000a7c4:	68 30 02 00 00       	push   $0x230
c000a7c9:	e8 3e 87 ff ff       	call   c0002f0c <sys_malloc>
c000a7ce:	83 c4 10             	add    $0x10,%esp
c000a7d1:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/file.c:460
	if (all_blocks == NULL) {
c000a7d4:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c000a7d8:	75 1a                	jne    c000a7f4 <file_read+0xb6>
/work/x86_os_my/fs/file.c:461
		printk("file_read: sys_malloc for all_blocks failed\n");
c000a7da:	83 ec 0c             	sub    $0xc,%esp
c000a7dd:	68 5c f9 00 c0       	push   $0xc000f95c
c000a7e2:	e8 66 c8 ff ff       	call   c000704d <printk>
c000a7e7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:462
		return -1;
c000a7ea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000a7ef:	e9 f1 02 00 00       	jmp    c000aae5 <file_read+0x3a7>
/work/x86_os_my/fs/file.c:465
	}

	uint32_t block_read_start_idx = file->fd_pos / BLOCK_SIZE;			// 数据所在块的起始地址
c000a7f4:	8b 45 08             	mov    0x8(%ebp),%eax
c000a7f7:	8b 00                	mov    (%eax),%eax
c000a7f9:	c1 e8 09             	shr    $0x9,%eax
c000a7fc:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/file.c:466
	uint32_t block_read_end_idx = (file->fd_pos + size) / BLOCK_SIZE;	// 数据所在块的终止地址
c000a7ff:	8b 45 08             	mov    0x8(%ebp),%eax
c000a802:	8b 10                	mov    (%eax),%edx
c000a804:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000a807:	01 d0                	add    %edx,%eax
c000a809:	c1 e8 09             	shr    $0x9,%eax
c000a80c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/fs/file.c:467
	uint32_t read_blocks = block_read_start_idx - block_read_end_idx;	// 如增量为0,表示数据在同一扇区
c000a80f:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000a812:	2b 45 d4             	sub    -0x2c(%ebp),%eax
c000a815:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/fs/file.c:468
	ASSERT(block_read_start_idx < 139 && block_read_end_idx < 139);
c000a818:	81 7d d8 8a 00 00 00 	cmpl   $0x8a,-0x28(%ebp)
c000a81f:	77 09                	ja     c000a82a <file_read+0xec>
/work/x86_os_my/fs/file.c:468 (discriminator 1)
c000a821:	81 7d d4 8a 00 00 00 	cmpl   $0x8a,-0x2c(%ebp)
c000a828:	76 1c                	jbe    c000a846 <file_read+0x108>
/work/x86_os_my/fs/file.c:468 (discriminator 3)
c000a82a:	68 8c f9 00 c0       	push   $0xc000f98c
c000a82f:	68 fc f9 00 c0       	push   $0xc000f9fc
c000a834:	68 d4 01 00 00       	push   $0x1d4
c000a839:	68 c1 f7 00 c0       	push   $0xc000f7c1
c000a83e:	e8 1e 7d ff ff       	call   c0002561 <panic_spin>
c000a843:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:475
	int32_t indirect_block_table;	// 获取一级间接表地址
	uint32_t block_idx;				// 获取待读的块地址

	/* 以下开始构建all_blocks块地址数组，专门存储用到的块地址 */
	// 在同一扇区内读数据,不涉及到跨扇区读取
	if (read_blocks == 0) {
c000a846:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
c000a84a:	0f 85 84 00 00 00    	jne    c000a8d4 <file_read+0x196>
/work/x86_os_my/fs/file.c:476
		ASSERT(block_read_end_idx == block_read_start_idx);
c000a850:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000a853:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c000a856:	74 1c                	je     c000a874 <file_read+0x136>
/work/x86_os_my/fs/file.c:476 (discriminator 1)
c000a858:	68 c4 f9 00 c0       	push   $0xc000f9c4
c000a85d:	68 fc f9 00 c0       	push   $0xc000f9fc
c000a862:	68 dc 01 00 00       	push   $0x1dc
c000a867:	68 c1 f7 00 c0       	push   $0xc000f7c1
c000a86c:	e8 f0 7c ff ff       	call   c0002561 <panic_spin>
c000a871:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:477
		if (block_read_end_idx < 12 ) {	// 待读的数据在12个直接块之内
c000a874:	83 7d d4 0b          	cmpl   $0xb,-0x2c(%ebp)
c000a878:	77 2b                	ja     c000a8a5 <file_read+0x167>
/work/x86_os_my/fs/file.c:478
			block_idx = block_read_end_idx;
c000a87a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000a87d:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:479
			all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
c000a880:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000a883:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000a88a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a88d:	01 c2                	add    %eax,%edx
c000a88f:	8b 45 08             	mov    0x8(%ebp),%eax
c000a892:	8b 40 08             	mov    0x8(%eax),%eax
c000a895:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c000a898:	83 c1 04             	add    $0x4,%ecx
c000a89b:	8b 04 88             	mov    (%eax,%ecx,4),%eax
c000a89e:	89 02                	mov    %eax,(%edx)
c000a8a0:	e9 5c 01 00 00       	jmp    c000aa01 <file_read+0x2c3>
/work/x86_os_my/fs/file.c:481
		} else {	// 若用到了一级间接块表,需要将表中间接块读进来
			indirect_block_table = file->fd_inode->i_sectors[12];
c000a8a5:	8b 45 08             	mov    0x8(%ebp),%eax
c000a8a8:	8b 40 08             	mov    0x8(%eax),%eax
c000a8ab:	8b 40 40             	mov    0x40(%eax),%eax
c000a8ae:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/fs/file.c:482
			ide_read(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);
c000a8b1:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a8b4:	8d 48 30             	lea    0x30(%eax),%ecx
c000a8b7:	8b 55 cc             	mov    -0x34(%ebp),%edx
c000a8ba:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a8bf:	8b 40 08             	mov    0x8(%eax),%eax
c000a8c2:	6a 01                	push   $0x1
c000a8c4:	51                   	push   %ecx
c000a8c5:	52                   	push   %edx
c000a8c6:	50                   	push   %eax
c000a8c7:	e8 08 bd ff ff       	call   c00065d4 <ide_read>
c000a8cc:	83 c4 10             	add    $0x10,%esp
c000a8cf:	e9 2d 01 00 00       	jmp    c000aa01 <file_read+0x2c3>
/work/x86_os_my/fs/file.c:487
		}
	} else {
	// 若要读多个数据块（扇区）
		/* 第一种情况: 起始块和终止块属于直接块*/
		if (block_read_end_idx < 12 ) {	  // 数据结束所在的块属于直接块
c000a8d4:	83 7d d4 0b          	cmpl   $0xb,-0x2c(%ebp)
c000a8d8:	77 39                	ja     c000a913 <file_read+0x1d5>
/work/x86_os_my/fs/file.c:488
			block_idx = block_read_start_idx;
c000a8da:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000a8dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:489
			while (block_idx <= block_read_end_idx) {
c000a8e0:	eb 24                	jmp    c000a906 <file_read+0x1c8>
/work/x86_os_my/fs/file.c:490
				all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
c000a8e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000a8e5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000a8ec:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a8ef:	01 c2                	add    %eax,%edx
c000a8f1:	8b 45 08             	mov    0x8(%ebp),%eax
c000a8f4:	8b 40 08             	mov    0x8(%eax),%eax
c000a8f7:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c000a8fa:	83 c1 04             	add    $0x4,%ecx
c000a8fd:	8b 04 88             	mov    (%eax,%ecx,4),%eax
c000a900:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/file.c:491
				block_idx++;
c000a902:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
/work/x86_os_my/fs/file.c:489
	} else {
	// 若要读多个数据块（扇区）
		/* 第一种情况: 起始块和终止块属于直接块*/
		if (block_read_end_idx < 12 ) {	  // 数据结束所在的块属于直接块
			block_idx = block_read_start_idx;
			while (block_idx <= block_read_end_idx) {
c000a906:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000a909:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
c000a90c:	76 d4                	jbe    c000a8e2 <file_read+0x1a4>
c000a90e:	e9 ee 00 00 00       	jmp    c000aa01 <file_read+0x2c3>
/work/x86_os_my/fs/file.c:493
				all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
				block_idx++;
			}
		} else if (block_read_start_idx < 12 && block_read_end_idx >= 12) {
c000a913:	83 7d d8 0b          	cmpl   $0xb,-0x28(%ebp)
c000a917:	0f 87 91 00 00 00    	ja     c000a9ae <file_read+0x270>
/work/x86_os_my/fs/file.c:493 (discriminator 1)
c000a91d:	83 7d d4 0b          	cmpl   $0xb,-0x2c(%ebp)
c000a921:	0f 86 87 00 00 00    	jbe    c000a9ae <file_read+0x270>
/work/x86_os_my/fs/file.c:496
		/* 第二种情况: 待读入的数据跨越直接块和间接块两类*/
			/* 先将直接块地址写入all_blocks */
			block_idx = block_read_start_idx;
c000a927:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000a92a:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:497
			while (block_idx < 12) {
c000a92d:	eb 24                	jmp    c000a953 <file_read+0x215>
/work/x86_os_my/fs/file.c:498
				all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
c000a92f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000a932:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000a939:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a93c:	01 c2                	add    %eax,%edx
c000a93e:	8b 45 08             	mov    0x8(%ebp),%eax
c000a941:	8b 40 08             	mov    0x8(%eax),%eax
c000a944:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c000a947:	83 c1 04             	add    $0x4,%ecx
c000a94a:	8b 04 88             	mov    (%eax,%ecx,4),%eax
c000a94d:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/file.c:499
				block_idx++;
c000a94f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
/work/x86_os_my/fs/file.c:497
			}
		} else if (block_read_start_idx < 12 && block_read_end_idx >= 12) {
		/* 第二种情况: 待读入的数据跨越直接块和间接块两类*/
			/* 先将直接块地址写入all_blocks */
			block_idx = block_read_start_idx;
			while (block_idx < 12) {
c000a953:	83 7d e8 0b          	cmpl   $0xb,-0x18(%ebp)
c000a957:	76 d6                	jbe    c000a92f <file_read+0x1f1>
/work/x86_os_my/fs/file.c:501
				all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
				block_idx++;
			}
			ASSERT(file->fd_inode->i_sectors[12] != 0);	    // 确保已经分配了一级间接块表
c000a959:	8b 45 08             	mov    0x8(%ebp),%eax
c000a95c:	8b 40 08             	mov    0x8(%eax),%eax
c000a95f:	8b 40 40             	mov    0x40(%eax),%eax
c000a962:	85 c0                	test   %eax,%eax
c000a964:	75 1c                	jne    c000a982 <file_read+0x244>
/work/x86_os_my/fs/file.c:501 (discriminator 1)
c000a966:	68 e8 f7 00 c0       	push   $0xc000f7e8
c000a96b:	68 fc f9 00 c0       	push   $0xc000f9fc
c000a970:	68 f5 01 00 00       	push   $0x1f5
c000a975:	68 c1 f7 00 c0       	push   $0xc000f7c1
c000a97a:	e8 e2 7b ff ff       	call   c0002561 <panic_spin>
c000a97f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:504

			/* 再将间接块地址写入all_blocks */
			indirect_block_table = file->fd_inode->i_sectors[12];
c000a982:	8b 45 08             	mov    0x8(%ebp),%eax
c000a985:	8b 40 08             	mov    0x8(%eax),%eax
c000a988:	8b 40 40             	mov    0x40(%eax),%eax
c000a98b:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/fs/file.c:505
			ide_read(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);	      // 将一级间接块表读进来写入到第13个块的位置之后
c000a98e:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a991:	8d 48 30             	lea    0x30(%eax),%ecx
c000a994:	8b 55 cc             	mov    -0x34(%ebp),%edx
c000a997:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a99c:	8b 40 08             	mov    0x8(%eax),%eax
c000a99f:	6a 01                	push   $0x1
c000a9a1:	51                   	push   %ecx
c000a9a2:	52                   	push   %edx
c000a9a3:	50                   	push   %eax
c000a9a4:	e8 2b bc ff ff       	call   c00065d4 <ide_read>
c000a9a9:	83 c4 10             	add    $0x10,%esp
c000a9ac:	eb 53                	jmp    c000aa01 <file_read+0x2c3>
/work/x86_os_my/fs/file.c:508
		} else {
		/* 第三种情况: 数据在间接块中*/
			ASSERT(file->fd_inode->i_sectors[12] != 0);	    // 确保已经分配了一级间接块表
c000a9ae:	8b 45 08             	mov    0x8(%ebp),%eax
c000a9b1:	8b 40 08             	mov    0x8(%eax),%eax
c000a9b4:	8b 40 40             	mov    0x40(%eax),%eax
c000a9b7:	85 c0                	test   %eax,%eax
c000a9b9:	75 1c                	jne    c000a9d7 <file_read+0x299>
/work/x86_os_my/fs/file.c:508 (discriminator 1)
c000a9bb:	68 e8 f7 00 c0       	push   $0xc000f7e8
c000a9c0:	68 fc f9 00 c0       	push   $0xc000f9fc
c000a9c5:	68 fc 01 00 00       	push   $0x1fc
c000a9ca:	68 c1 f7 00 c0       	push   $0xc000f7c1
c000a9cf:	e8 8d 7b ff ff       	call   c0002561 <panic_spin>
c000a9d4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:509
			indirect_block_table = file->fd_inode->i_sectors[12];	      // 获取一级间接表地址
c000a9d7:	8b 45 08             	mov    0x8(%ebp),%eax
c000a9da:	8b 40 08             	mov    0x8(%eax),%eax
c000a9dd:	8b 40 40             	mov    0x40(%eax),%eax
c000a9e0:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/fs/file.c:510
			ide_read(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);	      // 将一级间接块表读进来写入到第13个块的位置之后
c000a9e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a9e6:	8d 48 30             	lea    0x30(%eax),%ecx
c000a9e9:	8b 55 cc             	mov    -0x34(%ebp),%edx
c000a9ec:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000a9f1:	8b 40 08             	mov    0x8(%eax),%eax
c000a9f4:	6a 01                	push   $0x1
c000a9f6:	51                   	push   %ecx
c000a9f7:	52                   	push   %edx
c000a9f8:	50                   	push   %eax
c000a9f9:	e8 d6 bb ff ff       	call   c00065d4 <ide_read>
c000a9fe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:517
	}//块地址已经收集到all_blocks中


	/* 读数据 */
	uint32_t sec_idx, sec_lba, sec_off_bytes, sec_left_bytes, chunk_size;
	uint32_t bytes_read = 0;
c000aa01:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:518
	while (bytes_read < size) {	// 直到读完为止
c000aa08:	e9 ad 00 00 00       	jmp    c000aaba <file_read+0x37c>
/work/x86_os_my/fs/file.c:519
		sec_idx = file->fd_pos / BLOCK_SIZE;
c000aa0d:	8b 45 08             	mov    0x8(%ebp),%eax
c000aa10:	8b 00                	mov    (%eax),%eax
c000aa12:	c1 e8 09             	shr    $0x9,%eax
c000aa15:	89 45 c8             	mov    %eax,-0x38(%ebp)
/work/x86_os_my/fs/file.c:520
		sec_lba = all_blocks[sec_idx];
c000aa18:	8b 45 c8             	mov    -0x38(%ebp),%eax
c000aa1b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000aa22:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000aa25:	01 d0                	add    %edx,%eax
c000aa27:	8b 00                	mov    (%eax),%eax
c000aa29:	89 45 c4             	mov    %eax,-0x3c(%ebp)
/work/x86_os_my/fs/file.c:521
		sec_off_bytes = file->fd_pos % BLOCK_SIZE;
c000aa2c:	8b 45 08             	mov    0x8(%ebp),%eax
c000aa2f:	8b 00                	mov    (%eax),%eax
c000aa31:	25 ff 01 00 00       	and    $0x1ff,%eax
c000aa36:	89 45 c0             	mov    %eax,-0x40(%ebp)
/work/x86_os_my/fs/file.c:522
		sec_left_bytes = BLOCK_SIZE - sec_off_bytes;
c000aa39:	b8 00 02 00 00       	mov    $0x200,%eax
c000aa3e:	2b 45 c0             	sub    -0x40(%ebp),%eax
c000aa41:	89 45 bc             	mov    %eax,-0x44(%ebp)
/work/x86_os_my/fs/file.c:523
		chunk_size = size_left < sec_left_bytes ? size_left : sec_left_bytes;	// 待读入的数据大小
c000aa44:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000aa47:	39 45 bc             	cmp    %eax,-0x44(%ebp)
c000aa4a:	0f 46 45 bc          	cmovbe -0x44(%ebp),%eax
c000aa4e:	89 45 b8             	mov    %eax,-0x48(%ebp)
/work/x86_os_my/fs/file.c:525

		memset(io_buf, 0, BLOCK_SIZE);
c000aa51:	83 ec 04             	sub    $0x4,%esp
c000aa54:	68 00 02 00 00       	push   $0x200
c000aa59:	6a 00                	push   $0x0
c000aa5b:	ff 75 e0             	pushl  -0x20(%ebp)
c000aa5e:	e8 02 90 ff ff       	call   c0003a65 <memset>
c000aa63:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:526
		ide_read(cur_part->my_disk, sec_lba, io_buf, 1);
c000aa66:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000aa6b:	8b 40 08             	mov    0x8(%eax),%eax
c000aa6e:	6a 01                	push   $0x1
c000aa70:	ff 75 e0             	pushl  -0x20(%ebp)
c000aa73:	ff 75 c4             	pushl  -0x3c(%ebp)
c000aa76:	50                   	push   %eax
c000aa77:	e8 58 bb ff ff       	call   c00065d4 <ide_read>
c000aa7c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:527
		memcpy(buf_dst, io_buf + sec_off_bytes, chunk_size);
c000aa7f:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000aa82:	8b 45 c0             	mov    -0x40(%ebp),%eax
c000aa85:	01 d0                	add    %edx,%eax
c000aa87:	83 ec 04             	sub    $0x4,%esp
c000aa8a:	ff 75 b8             	pushl  -0x48(%ebp)
c000aa8d:	50                   	push   %eax
c000aa8e:	ff 75 f4             	pushl  -0xc(%ebp)
c000aa91:	e8 21 90 ff ff       	call   c0003ab7 <memcpy>
c000aa96:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:529

		buf_dst += chunk_size;
c000aa99:	8b 45 b8             	mov    -0x48(%ebp),%eax
c000aa9c:	01 45 f4             	add    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:530
		file->fd_pos += chunk_size;
c000aa9f:	8b 45 08             	mov    0x8(%ebp),%eax
c000aaa2:	8b 10                	mov    (%eax),%edx
c000aaa4:	8b 45 b8             	mov    -0x48(%ebp),%eax
c000aaa7:	01 c2                	add    %eax,%edx
c000aaa9:	8b 45 08             	mov    0x8(%ebp),%eax
c000aaac:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/file.c:531
		bytes_read += chunk_size;
c000aaae:	8b 45 b8             	mov    -0x48(%ebp),%eax
c000aab1:	01 45 e4             	add    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:532
		size_left -= chunk_size;
c000aab4:	8b 45 b8             	mov    -0x48(%ebp),%eax
c000aab7:	29 45 ec             	sub    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:518


	/* 读数据 */
	uint32_t sec_idx, sec_lba, sec_off_bytes, sec_left_bytes, chunk_size;
	uint32_t bytes_read = 0;
	while (bytes_read < size) {	// 直到读完为止
c000aaba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000aabd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c000aac0:	0f 82 47 ff ff ff    	jb     c000aa0d <file_read+0x2cf>
/work/x86_os_my/fs/file.c:534
		buf_dst += chunk_size;
		file->fd_pos += chunk_size;
		bytes_read += chunk_size;
		size_left -= chunk_size;
	}
	sys_free(all_blocks);
c000aac6:	83 ec 0c             	sub    $0xc,%esp
c000aac9:	ff 75 dc             	pushl  -0x24(%ebp)
c000aacc:	e8 68 8a ff ff       	call   c0003539 <sys_free>
c000aad1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:535
	sys_free(io_buf);
c000aad4:	83 ec 0c             	sub    $0xc,%esp
c000aad7:	ff 75 e0             	pushl  -0x20(%ebp)
c000aada:	e8 5a 8a ff ff       	call   c0003539 <sys_free>
c000aadf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:536
	return bytes_read;
c000aae2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
/work/x86_os_my/fs/file.c:537
}
c000aae5:	c9                   	leave  
c000aae6:	c3                   	ret    

c000aae7 <open_root_dir>:
open_root_dir():
/work/x86_os_my/fs/dir.c:17
#include "super_block.h"

struct dir root_dir;	// 根目录

/* 打开根目录 */
void open_root_dir(struct partition* part) {
c000aae7:	55                   	push   %ebp
c000aae8:	89 e5                	mov    %esp,%ebp
c000aaea:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/fs/dir.c:18
	root_dir.inode = inode_open(part, part->sb->root_inode_no);
c000aaed:	8b 45 08             	mov    0x8(%ebp),%eax
c000aaf0:	8b 40 1c             	mov    0x1c(%eax),%eax
c000aaf3:	8b 40 2c             	mov    0x2c(%eax),%eax
c000aaf6:	83 ec 08             	sub    $0x8,%esp
c000aaf9:	50                   	push   %eax
c000aafa:	ff 75 08             	pushl  0x8(%ebp)
c000aafd:	e8 44 e9 ff ff       	call   c0009446 <inode_open>
c000ab02:	83 c4 10             	add    $0x10,%esp
c000ab05:	a3 20 5a 01 c0       	mov    %eax,0xc0015a20
/work/x86_os_my/fs/dir.c:19
	root_dir.dir_pos = 0;
c000ab0a:	c7 05 24 5a 01 c0 00 	movl   $0x0,0xc0015a24
c000ab11:	00 00 00 
/work/x86_os_my/fs/dir.c:20
}
c000ab14:	90                   	nop
c000ab15:	c9                   	leave  
c000ab16:	c3                   	ret    

c000ab17 <dir_open>:
dir_open():
/work/x86_os_my/fs/dir.c:23

/* 在分区part上打开i结点为inode_no的目录，并返回目录指针 */
struct dir* dir_open(struct partition* part, uint32_t inode_no) {
c000ab17:	55                   	push   %ebp
c000ab18:	89 e5                	mov    %esp,%ebp
c000ab1a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/dir.c:24
	struct dir* pdir = (struct dir*)sys_malloc(sizeof(struct dir));	//除根目录以外的其他目录，要分配内存
c000ab1d:	83 ec 0c             	sub    $0xc,%esp
c000ab20:	68 08 02 00 00       	push   $0x208
c000ab25:	e8 e2 83 ff ff       	call   c0002f0c <sys_malloc>
c000ab2a:	83 c4 10             	add    $0x10,%esp
c000ab2d:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:25
	pdir->inode = inode_open(part, inode_no);
c000ab30:	83 ec 08             	sub    $0x8,%esp
c000ab33:	ff 75 0c             	pushl  0xc(%ebp)
c000ab36:	ff 75 08             	pushl  0x8(%ebp)
c000ab39:	e8 08 e9 ff ff       	call   c0009446 <inode_open>
c000ab3e:	83 c4 10             	add    $0x10,%esp
c000ab41:	89 c2                	mov    %eax,%edx
c000ab43:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000ab46:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/dir.c:26
	pdir->dir_pos = 0;
c000ab48:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000ab4b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
/work/x86_os_my/fs/dir.c:27
	return pdir;
c000ab52:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/dir.c:28
}
c000ab55:	c9                   	leave  
c000ab56:	c3                   	ret    

c000ab57 <search_dir_entry>:
search_dir_entry():
/work/x86_os_my/fs/dir.c:32

/* 在part分区内的pdir目录内，寻找名为name的目录项，
 * 找到后返回true，并将其目录项存入dir_e；否则返回false */
bool search_dir_entry(struct partition* part, struct dir* pdir, const char* name, struct dir_entry* dir_e) {
c000ab57:	55                   	push   %ebp
c000ab58:	89 e5                	mov    %esp,%ebp
c000ab5a:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/fs/dir.c:34
	/* 1分配 */
	uint32_t block_cnt = 140;	 // 12个直接块+128个一级间接块 = 目录的inode管理的所有块 = 140块
c000ab5d:	c7 45 e8 8c 00 00 00 	movl   $0x8c,-0x18(%ebp)
/work/x86_os_my/fs/dir.c:39

	/* 12个直接块大小+128个间接块,共560字节（140个块，inode需要管理块的地址，每个4字节）
	注意: all_blocks 里面并没有一级间接表的地址，只有直接块+间接块的地址！
	用all_blocks检索inode管理的所有块地址 */
	uint32_t* all_blocks = (uint32_t*)sys_malloc(48 + 512);
c000ab64:	83 ec 0c             	sub    $0xc,%esp
c000ab67:	68 30 02 00 00       	push   $0x230
c000ab6c:	e8 9b 83 ff ff       	call   c0002f0c <sys_malloc>
c000ab71:	83 c4 10             	add    $0x10,%esp
c000ab74:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/dir.c:40
	if (all_blocks == NULL) {
c000ab77:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c000ab7b:	75 1a                	jne    c000ab97 <search_dir_entry+0x40>
/work/x86_os_my/fs/dir.c:41
		printk("search_dir_entry: sys_malloc for all_blocks failed");
c000ab7d:	83 ec 0c             	sub    $0xc,%esp
c000ab80:	68 08 fa 00 c0       	push   $0xc000fa08
c000ab85:	e8 c3 c4 ff ff       	call   c000704d <printk>
c000ab8a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:42
		return false;
c000ab8d:	b8 00 00 00 00       	mov    $0x0,%eax
c000ab92:	e9 96 01 00 00       	jmp    c000ad2d <search_dir_entry+0x1d6>
/work/x86_os_my/fs/dir.c:45
	}

	uint32_t block_idx = 0;
c000ab97:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:46
	while (block_idx < 12) {
c000ab9e:	eb 23                	jmp    c000abc3 <search_dir_entry+0x6c>
/work/x86_os_my/fs/dir.c:47
		all_blocks[block_idx] = pdir->inode->i_sectors[block_idx];
c000aba0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000aba3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000abaa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000abad:	01 c2                	add    %eax,%edx
c000abaf:	8b 45 0c             	mov    0xc(%ebp),%eax
c000abb2:	8b 00                	mov    (%eax),%eax
c000abb4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c000abb7:	83 c1 04             	add    $0x4,%ecx
c000abba:	8b 04 88             	mov    (%eax,%ecx,4),%eax
c000abbd:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/dir.c:48
		block_idx++;
c000abbf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:46
		printk("search_dir_entry: sys_malloc for all_blocks failed");
		return false;
	}

	uint32_t block_idx = 0;
	while (block_idx < 12) {
c000abc3:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
c000abc7:	76 d7                	jbe    c000aba0 <search_dir_entry+0x49>
/work/x86_os_my/fs/dir.c:50
		all_blocks[block_idx] = pdir->inode->i_sectors[block_idx];
		block_idx++;
	}
	block_idx = 0;
c000abc9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:52

	if (pdir->inode->i_sectors[12] != 0) {	// i_sectors[12] != 0代表含有一级间接块表
c000abd0:	8b 45 0c             	mov    0xc(%ebp),%eax
c000abd3:	8b 00                	mov    (%eax),%eax
c000abd5:	8b 40 40             	mov    0x40(%eax),%eax
c000abd8:	85 c0                	test   %eax,%eax
c000abda:	74 21                	je     c000abfd <search_dir_entry+0xa6>
/work/x86_os_my/fs/dir.c:54
		//从硬盘的扇区地址i_sectors[12]处获取 1 扇区数据，就是 128 个间接块的地址，将其复制到 all_blocks+12 处【复制的是整个一级间接表】
		ide_read(part->my_disk, pdir->inode->i_sectors[12], all_blocks + 12, 1);
c000abdc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000abdf:	8d 48 30             	lea    0x30(%eax),%ecx
c000abe2:	8b 45 0c             	mov    0xc(%ebp),%eax
c000abe5:	8b 00                	mov    (%eax),%eax
c000abe7:	8b 50 40             	mov    0x40(%eax),%edx
c000abea:	8b 45 08             	mov    0x8(%ebp),%eax
c000abed:	8b 40 08             	mov    0x8(%eax),%eax
c000abf0:	6a 01                	push   $0x1
c000abf2:	51                   	push   %ecx
c000abf3:	52                   	push   %edx
c000abf4:	50                   	push   %eax
c000abf5:	e8 da b9 ff ff       	call   c00065d4 <ide_read>
c000abfa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:62


	/* 2查找 */
	/* 写目录项的时候已保证目录项不跨扇区，这样读目录项时容易处理，只申请容纳1个扇区的内存
	 * 和处理inode_table不同，在往目录中写目录项的时候(sync_dir_entry)，避免了某个目录项 跨扇区的情况 */
	uint8_t* buf = (uint8_t*)sys_malloc(SECTOR_SIZE);
c000abfd:	83 ec 0c             	sub    $0xc,%esp
c000ac00:	68 00 02 00 00       	push   $0x200
c000ac05:	e8 02 83 ff ff       	call   c0002f0c <sys_malloc>
c000ac0a:	83 c4 10             	add    $0x10,%esp
c000ac0d:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:63
	struct dir_entry* p_de = (struct dir_entry*)buf;		// p_de为指向目录项的指针,值为buf起始地址
c000ac10:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000ac13:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:64
	uint32_t dir_entry_size = part->sb->dir_entry_size;
c000ac16:	8b 45 08             	mov    0x8(%ebp),%eax
c000ac19:	8b 40 1c             	mov    0x1c(%eax),%eax
c000ac1c:	8b 40 30             	mov    0x30(%eax),%eax
c000ac1f:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:65
	uint32_t dir_entry_cnt = SECTOR_SIZE / dir_entry_size;	// 1扇区内可容纳的目录项个数
c000ac22:	b8 00 02 00 00       	mov    $0x200,%eax
c000ac27:	ba 00 00 00 00       	mov    $0x0,%edx
c000ac2c:	f7 75 dc             	divl   -0x24(%ebp)
c000ac2f:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/dir.c:67
	/* 在所有块中查找目录项 */
	while (block_idx < block_cnt) {
c000ac32:	e9 c9 00 00 00       	jmp    c000ad00 <search_dir_entry+0x1a9>
/work/x86_os_my/fs/dir.c:69
		/* 块地址为0时表示该块中无数据,继续在其它块中找 */
		if (all_blocks[block_idx] == 0) {
c000ac37:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000ac3a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000ac41:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000ac44:	01 d0                	add    %edx,%eax
c000ac46:	8b 00                	mov    (%eax),%eax
c000ac48:	85 c0                	test   %eax,%eax
c000ac4a:	75 09                	jne    c000ac55 <search_dir_entry+0xfe>
/work/x86_os_my/fs/dir.c:70
			block_idx++;
c000ac4c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:71
			continue;
c000ac50:	e9 ab 00 00 00       	jmp    c000ad00 <search_dir_entry+0x1a9>
/work/x86_os_my/fs/dir.c:73
		}
		ide_read(part->my_disk, all_blocks[block_idx], buf, 1);
c000ac55:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000ac58:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000ac5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000ac62:	01 d0                	add    %edx,%eax
c000ac64:	8b 10                	mov    (%eax),%edx
c000ac66:	8b 45 08             	mov    0x8(%ebp),%eax
c000ac69:	8b 40 08             	mov    0x8(%eax),%eax
c000ac6c:	6a 01                	push   $0x1
c000ac6e:	ff 75 e0             	pushl  -0x20(%ebp)
c000ac71:	52                   	push   %edx
c000ac72:	50                   	push   %eax
c000ac73:	e8 5c b9 ff ff       	call   c00065d4 <ide_read>
c000ac78:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:75

		uint32_t dir_entry_idx = 0;
c000ac7b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:77
		/* 遍历扇区中所有目录项 */
		while (dir_entry_idx < dir_entry_cnt) {
c000ac82:	eb 55                	jmp    c000acd9 <search_dir_entry+0x182>
/work/x86_os_my/fs/dir.c:79
			/* 若找到了,就直接复制整个目录项 */
			if (!strcmp(p_de->filename, name)) {
c000ac84:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000ac87:	83 ec 08             	sub    $0x8,%esp
c000ac8a:	ff 75 10             	pushl  0x10(%ebp)
c000ac8d:	50                   	push   %eax
c000ac8e:	e8 a7 8f ff ff       	call   c0003c3a <strcmp>
c000ac93:	83 c4 10             	add    $0x10,%esp
c000ac96:	84 c0                	test   %al,%al
c000ac98:	75 37                	jne    c000acd1 <search_dir_entry+0x17a>
/work/x86_os_my/fs/dir.c:80
				memcpy(dir_e, p_de, dir_entry_size);
c000ac9a:	83 ec 04             	sub    $0x4,%esp
c000ac9d:	ff 75 dc             	pushl  -0x24(%ebp)
c000aca0:	ff 75 f0             	pushl  -0x10(%ebp)
c000aca3:	ff 75 14             	pushl  0x14(%ebp)
c000aca6:	e8 0c 8e ff ff       	call   c0003ab7 <memcpy>
c000acab:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:81
				sys_free(buf);
c000acae:	83 ec 0c             	sub    $0xc,%esp
c000acb1:	ff 75 e0             	pushl  -0x20(%ebp)
c000acb4:	e8 80 88 ff ff       	call   c0003539 <sys_free>
c000acb9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:82
				sys_free(all_blocks);
c000acbc:	83 ec 0c             	sub    $0xc,%esp
c000acbf:	ff 75 e4             	pushl  -0x1c(%ebp)
c000acc2:	e8 72 88 ff ff       	call   c0003539 <sys_free>
c000acc7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:83
				return true;
c000acca:	b8 01 00 00 00       	mov    $0x1,%eax
c000accf:	eb 5c                	jmp    c000ad2d <search_dir_entry+0x1d6>
/work/x86_os_my/fs/dir.c:85
			}
			dir_entry_idx++;
c000acd1:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:86
			p_de++;
c000acd5:	83 45 f0 18          	addl   $0x18,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:77
		}
		ide_read(part->my_disk, all_blocks[block_idx], buf, 1);

		uint32_t dir_entry_idx = 0;
		/* 遍历扇区中所有目录项 */
		while (dir_entry_idx < dir_entry_cnt) {
c000acd9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000acdc:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c000acdf:	72 a3                	jb     c000ac84 <search_dir_entry+0x12d>
/work/x86_os_my/fs/dir.c:89
			}
			dir_entry_idx++;
			p_de++;
		}

		block_idx++;					// 目录inode管理的下一个数据块（扇区）【目录里面是目录项，所以buf赋给p_de】
c000ace1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:90
		p_de = (struct dir_entry*)buf;	// p_de已经指向上一个扇区内，最后一个目录项，需要恢复p_de指向为buf
c000ace5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000ace8:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:91
		memset(buf, 0, SECTOR_SIZE);	// 将buf清0,下次再用
c000aceb:	83 ec 04             	sub    $0x4,%esp
c000acee:	68 00 02 00 00       	push   $0x200
c000acf3:	6a 00                	push   $0x0
c000acf5:	ff 75 e0             	pushl  -0x20(%ebp)
c000acf8:	e8 68 8d ff ff       	call   c0003a65 <memset>
c000acfd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:67
	uint8_t* buf = (uint8_t*)sys_malloc(SECTOR_SIZE);
	struct dir_entry* p_de = (struct dir_entry*)buf;		// p_de为指向目录项的指针,值为buf起始地址
	uint32_t dir_entry_size = part->sb->dir_entry_size;
	uint32_t dir_entry_cnt = SECTOR_SIZE / dir_entry_size;	// 1扇区内可容纳的目录项个数
	/* 在所有块中查找目录项 */
	while (block_idx < block_cnt) {
c000ad00:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000ad03:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c000ad06:	0f 82 2b ff ff ff    	jb     c000ac37 <search_dir_entry+0xe0>
/work/x86_os_my/fs/dir.c:93

		block_idx++;					// 目录inode管理的下一个数据块（扇区）【目录里面是目录项，所以buf赋给p_de】
		p_de = (struct dir_entry*)buf;	// p_de已经指向上一个扇区内，最后一个目录项，需要恢复p_de指向为buf
		memset(buf, 0, SECTOR_SIZE);	// 将buf清0,下次再用
	}
	sys_free(buf);
c000ad0c:	83 ec 0c             	sub    $0xc,%esp
c000ad0f:	ff 75 e0             	pushl  -0x20(%ebp)
c000ad12:	e8 22 88 ff ff       	call   c0003539 <sys_free>
c000ad17:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:94
	sys_free(all_blocks);
c000ad1a:	83 ec 0c             	sub    $0xc,%esp
c000ad1d:	ff 75 e4             	pushl  -0x1c(%ebp)
c000ad20:	e8 14 88 ff ff       	call   c0003539 <sys_free>
c000ad25:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:95
	return false;
c000ad28:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/dir.c:96
}
c000ad2d:	c9                   	leave  
c000ad2e:	c3                   	ret    

c000ad2f <dir_close>:
dir_close():
/work/x86_os_my/fs/dir.c:99

/* 关闭目录 */
void dir_close(struct dir* dir) {
c000ad2f:	55                   	push   %ebp
c000ad30:	89 e5                	mov    %esp,%ebp
c000ad32:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/fs/dir.c:103
	/*************      根目录不能关闭     ***************
	*1 根目录自打开后就不应该关闭,否则还需要再次open_root_dir();
	*2 root_dir所在的内存是低端1M之内,并非在堆中,free会出问题 */
	if (dir == &root_dir) {
c000ad35:	81 7d 08 20 5a 01 c0 	cmpl   $0xc0015a20,0x8(%ebp)
c000ad3c:	74 21                	je     c000ad5f <dir_close+0x30>
/work/x86_os_my/fs/dir.c:106
		return;
	}
	inode_close(dir->inode);
c000ad3e:	8b 45 08             	mov    0x8(%ebp),%eax
c000ad41:	8b 00                	mov    (%eax),%eax
c000ad43:	83 ec 0c             	sub    $0xc,%esp
c000ad46:	50                   	push   %eax
c000ad47:	e8 40 e8 ff ff       	call   c000958c <inode_close>
c000ad4c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:107
	sys_free(dir);
c000ad4f:	83 ec 0c             	sub    $0xc,%esp
c000ad52:	ff 75 08             	pushl  0x8(%ebp)
c000ad55:	e8 df 87 ff ff       	call   c0003539 <sys_free>
c000ad5a:	83 c4 10             	add    $0x10,%esp
c000ad5d:	eb 01                	jmp    c000ad60 <dir_close+0x31>
/work/x86_os_my/fs/dir.c:104
void dir_close(struct dir* dir) {
	/*************      根目录不能关闭     ***************
	*1 根目录自打开后就不应该关闭,否则还需要再次open_root_dir();
	*2 root_dir所在的内存是低端1M之内,并非在堆中,free会出问题 */
	if (dir == &root_dir) {
		return;
c000ad5f:	90                   	nop
/work/x86_os_my/fs/dir.c:108
	}
	inode_close(dir->inode);
	sys_free(dir);
}
c000ad60:	c9                   	leave  
c000ad61:	c3                   	ret    

c000ad62 <create_dir_entry>:
create_dir_entry():
/work/x86_os_my/fs/dir.c:111

/* 在内存中初始化目录项p_de */
void create_dir_entry(char* filename, uint32_t inode_no, uint8_t file_type, struct dir_entry* p_de) {
c000ad62:	55                   	push   %ebp
c000ad63:	89 e5                	mov    %esp,%ebp
c000ad65:	83 ec 18             	sub    $0x18,%esp
c000ad68:	8b 45 10             	mov    0x10(%ebp),%eax
c000ad6b:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:112
	ASSERT(strlen(filename) <=  MAX_FILE_NAME_LEN);
c000ad6e:	83 ec 0c             	sub    $0xc,%esp
c000ad71:	ff 75 08             	pushl  0x8(%ebp)
c000ad74:	e8 76 8e ff ff       	call   c0003bef <strlen>
c000ad79:	83 c4 10             	add    $0x10,%esp
c000ad7c:	83 f8 10             	cmp    $0x10,%eax
c000ad7f:	76 19                	jbe    c000ad9a <create_dir_entry+0x38>
/work/x86_os_my/fs/dir.c:112 (discriminator 1)
c000ad81:	68 3c fa 00 c0       	push   $0xc000fa3c
c000ad86:	68 c8 fb 00 c0       	push   $0xc000fbc8
c000ad8b:	6a 70                	push   $0x70
c000ad8d:	68 62 fa 00 c0       	push   $0xc000fa62
c000ad92:	e8 ca 77 ff ff       	call   c0002561 <panic_spin>
c000ad97:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:115

	/* 初始化目录项 */
	memcpy(p_de->filename, filename, strlen(filename));
c000ad9a:	83 ec 0c             	sub    $0xc,%esp
c000ad9d:	ff 75 08             	pushl  0x8(%ebp)
c000ada0:	e8 4a 8e ff ff       	call   c0003bef <strlen>
c000ada5:	83 c4 10             	add    $0x10,%esp
c000ada8:	89 c2                	mov    %eax,%edx
c000adaa:	8b 45 14             	mov    0x14(%ebp),%eax
c000adad:	83 ec 04             	sub    $0x4,%esp
c000adb0:	52                   	push   %edx
c000adb1:	ff 75 08             	pushl  0x8(%ebp)
c000adb4:	50                   	push   %eax
c000adb5:	e8 fd 8c ff ff       	call   c0003ab7 <memcpy>
c000adba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:116
	p_de->i_no = inode_no;
c000adbd:	8b 45 14             	mov    0x14(%ebp),%eax
c000adc0:	8b 55 0c             	mov    0xc(%ebp),%edx
c000adc3:	89 50 10             	mov    %edx,0x10(%eax)
/work/x86_os_my/fs/dir.c:117
	p_de->f_type = file_type;
c000adc6:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c000adca:	8b 45 14             	mov    0x14(%ebp),%eax
c000adcd:	89 50 14             	mov    %edx,0x14(%eax)
/work/x86_os_my/fs/dir.c:118
}
c000add0:	90                   	nop
c000add1:	c9                   	leave  
c000add2:	c3                   	ret    

c000add3 <sync_dir_entry>:
sync_dir_entry():
/work/x86_os_my/fs/dir.c:128
 * io_buf是由主调函数提供的，里面是一个一个的目录项
 */
// 全局变量 cur_part 定义在fs.c中
// 临时变量 all_blocks 保存目录中 所有数据块的地址【4*140=560字节，去掉前12个直接块的地址48字节，后边全是间接块，后边正好是512字节】
// 注意: all_blocks 里面并没有一级间接表的地址，只有直接块+间接块的地址！
bool sync_dir_entry(struct dir* parent_dir, struct dir_entry* p_de, void* io_buf) {
c000add3:	55                   	push   %ebp
c000add4:	89 e5                	mov    %esp,%ebp
c000add6:	57                   	push   %edi
c000add7:	81 ec 54 02 00 00    	sub    $0x254,%esp
/work/x86_os_my/fs/dir.c:129
	struct inode* dir_inode = parent_dir->inode;	//dir->inode：“已打开的 inode 队列”part->open_inodes 中的节点
c000addd:	8b 45 08             	mov    0x8(%ebp),%eax
c000ade0:	8b 00                	mov    (%eax),%eax
c000ade2:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:130
	uint32_t dir_size = dir_inode->i_size;			//inode->i_size：当inode是目录时，代表 目录下所有目录项大小之和
c000ade5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000ade8:	8b 40 04             	mov    0x4(%eax),%eax
c000adeb:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:131
	uint32_t dir_entry_size = cur_part->sb->dir_entry_size;
c000adee:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000adf3:	8b 40 1c             	mov    0x1c(%eax),%eax
c000adf6:	8b 40 30             	mov    0x30(%eax),%eax
c000adf9:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/dir.c:133

	ASSERT(dir_size % dir_entry_size == 0);	// dir_size应该是dir_entry_size的整数倍
c000adfc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000adff:	ba 00 00 00 00       	mov    $0x0,%edx
c000ae04:	f7 75 e8             	divl   -0x18(%ebp)
c000ae07:	89 d0                	mov    %edx,%eax
c000ae09:	85 c0                	test   %eax,%eax
c000ae0b:	74 1c                	je     c000ae29 <sync_dir_entry+0x56>
/work/x86_os_my/fs/dir.c:133 (discriminator 1)
c000ae0d:	68 6c fa 00 c0       	push   $0xc000fa6c
c000ae12:	68 dc fb 00 c0       	push   $0xc000fbdc
c000ae17:	68 85 00 00 00       	push   $0x85
c000ae1c:	68 62 fa 00 c0       	push   $0xc000fa62
c000ae21:	e8 3b 77 ff ff       	call   c0002561 <panic_spin>
c000ae26:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:135

	uint32_t dir_entrys_per_sec = (512 / dir_entry_size);	// 每扇区最多有几个目录项【保证了：写入目录项时不会跨扇区】
c000ae29:	b8 00 02 00 00       	mov    $0x200,%eax
c000ae2e:	ba 00 00 00 00       	mov    $0x0,%edx
c000ae33:	f7 75 e8             	divl   -0x18(%ebp)
c000ae36:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/dir.c:136
	int32_t block_lba = -1;
c000ae39:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:140


	/* 将该目录inode管理的所有块(扇区)地址(12个直接块+ 128个间接块)存入all_blocks */
	uint8_t block_idx = 0;
c000ae40:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/dir.c:143
	// all_blocks 保存目录中 所有数据块的地址【4*140=560字节，去掉前12个直接块的地址48字节，后边全是间接块，后边正好是512字节】
	// 注意: all_blocks 里面并没有一级间接表的地址，只有直接块+间接块的地址！
	uint32_t all_blocks[140] = {0};
c000ae44:	8d 95 a8 fd ff ff    	lea    -0x258(%ebp),%edx
c000ae4a:	b8 00 00 00 00       	mov    $0x0,%eax
c000ae4f:	b9 8c 00 00 00       	mov    $0x8c,%ecx
c000ae54:	89 d7                	mov    %edx,%edi
c000ae56:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/fs/dir.c:144
	while (block_idx < 12) {
c000ae58:	eb 22                	jmp    c000ae7c <sync_dir_entry+0xa9>
/work/x86_os_my/fs/dir.c:145
		all_blocks[block_idx] = dir_inode->i_sectors[block_idx];
c000ae5a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000ae5e:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
c000ae62:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000ae65:	83 c1 04             	add    $0x4,%ecx
c000ae68:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
c000ae6b:	89 94 85 a8 fd ff ff 	mov    %edx,-0x258(%ebp,%eax,4)
/work/x86_os_my/fs/dir.c:146
		block_idx++;
c000ae72:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000ae76:	83 c0 01             	add    $0x1,%eax
c000ae79:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/dir.c:144
	/* 将该目录inode管理的所有块(扇区)地址(12个直接块+ 128个间接块)存入all_blocks */
	uint8_t block_idx = 0;
	// all_blocks 保存目录中 所有数据块的地址【4*140=560字节，去掉前12个直接块的地址48字节，后边全是间接块，后边正好是512字节】
	// 注意: all_blocks 里面并没有一级间接表的地址，只有直接块+间接块的地址！
	uint32_t all_blocks[140] = {0};
	while (block_idx < 12) {
c000ae7c:	80 7d f7 0b          	cmpb   $0xb,-0x9(%ebp)
c000ae80:	76 d8                	jbe    c000ae5a <sync_dir_entry+0x87>
/work/x86_os_my/fs/dir.c:151
		block_idx++;
	}


	/* 开始遍历所有块以寻找目录项空位 */
	block_idx = 0;
c000ae82:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/dir.c:152
	while (block_idx < 140) {	// 文件(包括目录)最多管理140个块
c000ae86:	e9 3f 03 00 00       	jmp    c000b1ca <sync_dir_entry+0x3f7>
/work/x86_os_my/fs/dir.c:155
		/* 一、若inode管理的第block_idx块是不存在的，需要分配。
		   下边是需要分配块的三种情况 @1 @2 @3 */
		int32_t block_bitmap_idx = -1;
c000ae8b:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:156
		if (all_blocks[block_idx] == 0) {
c000ae92:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000ae96:	8b 84 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%eax
c000ae9d:	85 c0                	test   %eax,%eax
c000ae9f:	0f 85 58 02 00 00    	jne    c000b0fd <sync_dir_entry+0x32a>
/work/x86_os_my/fs/dir.c:157
			block_lba = block_bitmap_alloc(cur_part);	// #1 从分区的block位图中，分配1个扇区，返回"扇区地址"
c000aea5:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000aeaa:	83 ec 0c             	sub    $0xc,%esp
c000aead:	50                   	push   %eax
c000aeae:	e8 ff eb ff ff       	call   c0009ab2 <block_bitmap_alloc>
c000aeb3:	83 c4 10             	add    $0x10,%esp
c000aeb6:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:158
			if (block_lba == -1) {
c000aeb9:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
c000aebd:	75 1a                	jne    c000aed9 <sync_dir_entry+0x106>
/work/x86_os_my/fs/dir.c:159
				printk("alloc block bitmap for sync_dir_entry failed\n");
c000aebf:	83 ec 0c             	sub    $0xc,%esp
c000aec2:	68 8c fa 00 c0       	push   $0xc000fa8c
c000aec7:	e8 81 c1 ff ff       	call   c000704d <printk>
c000aecc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:160
				return false;
c000aecf:	b8 00 00 00 00       	mov    $0x0,%eax
c000aed4:	e9 10 03 00 00       	jmp    c000b1e9 <sync_dir_entry+0x416>
/work/x86_os_my/fs/dir.c:163
			}
			/* 每分配一个块就同步一次block_bitmap */
			block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c000aed9:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000aedc:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000aee1:	8b 40 1c             	mov    0x1c(%eax),%eax
c000aee4:	8b 40 28             	mov    0x28(%eax),%eax
c000aee7:	29 c2                	sub    %eax,%edx
c000aee9:	89 d0                	mov    %edx,%eax
c000aeeb:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:164
			ASSERT(block_bitmap_idx != -1);	//怎么可能是-1啊。。。？
c000aeee:	83 7d dc ff          	cmpl   $0xffffffff,-0x24(%ebp)
c000aef2:	75 1c                	jne    c000af10 <sync_dir_entry+0x13d>
/work/x86_os_my/fs/dir.c:164 (discriminator 1)
c000aef4:	68 ba fa 00 c0       	push   $0xc000faba
c000aef9:	68 dc fb 00 c0       	push   $0xc000fbdc
c000aefe:	68 a4 00 00 00       	push   $0xa4
c000af03:	68 62 fa 00 c0       	push   $0xc000fa62
c000af08:	e8 54 76 ff ff       	call   c0002561 <panic_spin>
c000af0d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:165
			bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c000af10:	8b 55 dc             	mov    -0x24(%ebp),%edx
c000af13:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000af18:	83 ec 04             	sub    $0x4,%esp
c000af1b:	6a 01                	push   $0x1
c000af1d:	52                   	push   %edx
c000af1e:	50                   	push   %eax
c000af1f:	e8 e0 eb ff ff       	call   c0009b04 <bitmap_sync>
c000af24:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:167

			block_bitmap_idx = -1;
c000af27:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:168
			if (block_idx < 12) {			// @1 若是直接块
c000af2e:	80 7d f7 0b          	cmpb   $0xb,-0x9(%ebp)
c000af32:	77 27                	ja     c000af5b <sync_dir_entry+0x188>
/work/x86_os_my/fs/dir.c:169
				dir_inode->i_sectors[block_idx] = all_blocks[block_idx] = block_lba;
c000af34:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
c000af38:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000af3c:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000af3f:	89 94 85 a8 fd ff ff 	mov    %edx,-0x258(%ebp,%eax,4)
c000af46:	8b 94 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%edx
c000af4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000af50:	83 c1 04             	add    $0x4,%ecx
c000af53:	89 14 88             	mov    %edx,(%eax,%ecx,4)
c000af56:	e9 3c 01 00 00       	jmp    c000b097 <sync_dir_entry+0x2c4>
/work/x86_os_my/fs/dir.c:170
			} else if (block_idx == 12) {	// @2 若是未分配 一级间接块表(block_idx==12表示第0个间接块)
c000af5b:	80 7d f7 0c          	cmpb   $0xc,-0x9(%ebp)
c000af5f:	0f 85 ff 00 00 00    	jne    c000b064 <sync_dir_entry+0x291>
/work/x86_os_my/fs/dir.c:171
				dir_inode->i_sectors[12] = block_lba;		// 将 #1 分配的块做为"一级间接块表"地址
c000af65:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000af68:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000af6b:	89 50 40             	mov    %edx,0x40(%eax)
/work/x86_os_my/fs/dir.c:173
				
				block_lba = -1;
c000af6e:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:174
				block_lba = block_bitmap_alloc(cur_part);	// #2 再分配一个块做为"第0个间接块"
c000af75:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000af7a:	83 ec 0c             	sub    $0xc,%esp
c000af7d:	50                   	push   %eax
c000af7e:	e8 2f eb ff ff       	call   c0009ab2 <block_bitmap_alloc>
c000af83:	83 c4 10             	add    $0x10,%esp
c000af86:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:175
				if (block_lba == -1) {
c000af89:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
c000af8d:	75 57                	jne    c000afe6 <sync_dir_entry+0x213>
/work/x86_os_my/fs/dir.c:177
					// 回滚block_bitmap
					block_bitmap_idx = dir_inode->i_sectors[12] - cur_part->sb->data_start_lba;
c000af8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000af92:	8b 50 40             	mov    0x40(%eax),%edx
c000af95:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000af9a:	8b 40 1c             	mov    0x1c(%eax),%eax
c000af9d:	8b 40 28             	mov    0x28(%eax),%eax
c000afa0:	29 c2                	sub    %eax,%edx
c000afa2:	89 d0                	mov    %edx,%eax
c000afa4:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:178
					bitmap_set(&cur_part->block_bitmap, block_bitmap_idx, 0);	//释放 #1
c000afa7:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000afaa:	8b 15 90 58 01 c0    	mov    0xc0015890,%edx
c000afb0:	83 c2 20             	add    $0x20,%edx
c000afb3:	83 ec 04             	sub    $0x4,%esp
c000afb6:	6a 00                	push   $0x0
c000afb8:	50                   	push   %eax
c000afb9:	52                   	push   %edx
c000afba:	e8 10 78 ff ff       	call   c00027cf <bitmap_set>
c000afbf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:180
					// 取消掉这个一级间接块表
					dir_inode->i_sectors[12] = 0;
c000afc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000afc5:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
/work/x86_os_my/fs/dir.c:181
					printk("alloc block bitmap for sync_dir_entry failed\n");
c000afcc:	83 ec 0c             	sub    $0xc,%esp
c000afcf:	68 8c fa 00 c0       	push   $0xc000fa8c
c000afd4:	e8 74 c0 ff ff       	call   c000704d <printk>
c000afd9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:182
					return false;
c000afdc:	b8 00 00 00 00       	mov    $0x0,%eax
c000afe1:	e9 03 02 00 00       	jmp    c000b1e9 <sync_dir_entry+0x416>
/work/x86_os_my/fs/dir.c:185
				}
				/* 每分配一个块就同步一次block_bitmap */
				block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c000afe6:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000afe9:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000afee:	8b 40 1c             	mov    0x1c(%eax),%eax
c000aff1:	8b 40 28             	mov    0x28(%eax),%eax
c000aff4:	29 c2                	sub    %eax,%edx
c000aff6:	89 d0                	mov    %edx,%eax
c000aff8:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:186
				ASSERT(block_bitmap_idx != -1);
c000affb:	83 7d dc ff          	cmpl   $0xffffffff,-0x24(%ebp)
c000afff:	75 1c                	jne    c000b01d <sync_dir_entry+0x24a>
/work/x86_os_my/fs/dir.c:186 (discriminator 1)
c000b001:	68 ba fa 00 c0       	push   $0xc000faba
c000b006:	68 dc fb 00 c0       	push   $0xc000fbdc
c000b00b:	68 ba 00 00 00       	push   $0xba
c000b010:	68 62 fa 00 c0       	push   $0xc000fa62
c000b015:	e8 47 75 ff ff       	call   c0002561 <panic_spin>
c000b01a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:187
				bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c000b01d:	8b 55 dc             	mov    -0x24(%ebp),%edx
c000b020:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000b025:	83 ec 04             	sub    $0x4,%esp
c000b028:	6a 01                	push   $0x1
c000b02a:	52                   	push   %edx
c000b02b:	50                   	push   %eax
c000b02c:	e8 d3 ea ff ff       	call   c0009b04 <bitmap_sync>
c000b031:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:190

				/* 把新分配的"第0个间接块地址"写入硬盘中"一级间接块表" */
				all_blocks[12] = block_lba;
c000b034:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000b037:	89 85 d8 fd ff ff    	mov    %eax,-0x228(%ebp)
/work/x86_os_my/fs/dir.c:194
				// all_blocks 共有4*140=560字节，去掉前12个直接块的地址48字节，后边全是间接块，后边正好是512字节】
				// 注意: all_blocks 里面并没有一级间接表的地址，只有直接块+间接块的地址！
				// 我们的一级间接表大小是和普通数据块大小一样的512字节，可以容纳128个数据块的地址！
				ide_write(cur_part->my_disk, dir_inode->i_sectors[12], all_blocks + 12, 1);
c000b03d:	8d 85 a8 fd ff ff    	lea    -0x258(%ebp),%eax
c000b043:	83 c0 30             	add    $0x30,%eax
c000b046:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000b049:	8b 4a 40             	mov    0x40(%edx),%ecx
c000b04c:	8b 15 90 58 01 c0    	mov    0xc0015890,%edx
c000b052:	8b 52 08             	mov    0x8(%edx),%edx
c000b055:	6a 01                	push   $0x1
c000b057:	50                   	push   %eax
c000b058:	51                   	push   %ecx
c000b059:	52                   	push   %edx
c000b05a:	e8 e9 b6 ff ff       	call   c0006748 <ide_write>
c000b05f:	83 c4 10             	add    $0x10,%esp
c000b062:	eb 33                	jmp    c000b097 <sync_dir_entry+0x2c4>
/work/x86_os_my/fs/dir.c:197
			} else {						// @3 若是未分配 间接块【父目录inode管理的只有前13个数据块需要特殊处理，后边的全是间接块】
				/* 把新分配的第(block_idx-12)个间接块地址"写入硬盘中"一级间接块表 */
				all_blocks[block_idx] = block_lba;
c000b064:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000b068:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000b06b:	89 94 85 a8 fd ff ff 	mov    %edx,-0x258(%ebp,%eax,4)
/work/x86_os_my/fs/dir.c:198
				ide_write(cur_part->my_disk, dir_inode->i_sectors[12], all_blocks + 12, 1);
c000b072:	8d 85 a8 fd ff ff    	lea    -0x258(%ebp),%eax
c000b078:	83 c0 30             	add    $0x30,%eax
c000b07b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000b07e:	8b 4a 40             	mov    0x40(%edx),%ecx
c000b081:	8b 15 90 58 01 c0    	mov    0xc0015890,%edx
c000b087:	8b 52 08             	mov    0x8(%edx),%edx
c000b08a:	6a 01                	push   $0x1
c000b08c:	50                   	push   %eax
c000b08d:	51                   	push   %ecx
c000b08e:	52                   	push   %edx
c000b08f:	e8 b4 b6 ff ff       	call   c0006748 <ide_write>
c000b094:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:204
			}


			/* 这里才是重点，前边只是处理，父目录indoe管理的某个数据块为空的情况，需要新分配数据块，包括一级间接块表、间接块 */
			/* 再将硬盘中，新目录项p_de写入新分配的间接块 */
			memset(io_buf, 0, 512);
c000b097:	83 ec 04             	sub    $0x4,%esp
c000b09a:	68 00 02 00 00       	push   $0x200
c000b09f:	6a 00                	push   $0x0
c000b0a1:	ff 75 10             	pushl  0x10(%ebp)
c000b0a4:	e8 bc 89 ff ff       	call   c0003a65 <memset>
c000b0a9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:205
			memcpy(io_buf, p_de, dir_entry_size);
c000b0ac:	83 ec 04             	sub    $0x4,%esp
c000b0af:	ff 75 e8             	pushl  -0x18(%ebp)
c000b0b2:	ff 75 0c             	pushl  0xc(%ebp)
c000b0b5:	ff 75 10             	pushl  0x10(%ebp)
c000b0b8:	e8 fa 89 ff ff       	call   c0003ab7 <memcpy>
c000b0bd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:206
			ide_write(cur_part->my_disk, all_blocks[block_idx], io_buf, 1);
c000b0c0:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000b0c4:	8b 94 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%edx
c000b0cb:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000b0d0:	8b 40 08             	mov    0x8(%eax),%eax
c000b0d3:	6a 01                	push   $0x1
c000b0d5:	ff 75 10             	pushl  0x10(%ebp)
c000b0d8:	52                   	push   %edx
c000b0d9:	50                   	push   %eax
c000b0da:	e8 69 b6 ff ff       	call   c0006748 <ide_write>
c000b0df:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:207
			dir_inode->i_size += dir_entry_size;	//struct inode* dir_inode = parent_dir->inode;更新的是父目录的inode结构
c000b0e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000b0e5:	8b 50 04             	mov    0x4(%eax),%edx
c000b0e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000b0eb:	01 c2                	add    %eax,%edx
c000b0ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000b0f0:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/dir.c:208
			return true;
c000b0f3:	b8 01 00 00 00       	mov    $0x1,%eax
c000b0f8:	e9 ec 00 00 00       	jmp    c000b1e9 <sync_dir_entry+0x416>
/work/x86_os_my/fs/dir.c:213
		}//if (all_blocks[block_idx] == 0)


		/* 二、若inode管理的第block_idx块是存在的，不需要分配，将其读进内存，然后在该块中查找空目录项，将p_de填入 */
		ide_read(cur_part->my_disk, all_blocks[block_idx], io_buf, 1); 
c000b0fd:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000b101:	8b 94 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%edx
c000b108:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000b10d:	8b 40 08             	mov    0x8(%eax),%eax
c000b110:	6a 01                	push   $0x1
c000b112:	ff 75 10             	pushl  0x10(%ebp)
c000b115:	52                   	push   %edx
c000b116:	50                   	push   %eax
c000b117:	e8 b8 b4 ff ff       	call   c00065d4 <ide_read>
c000b11c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:215
		/* 在扇区内查找空目录项 */
		uint8_t dir_entry_idx = 0;
c000b11f:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
/work/x86_os_my/fs/dir.c:216
		struct dir_entry* dir_e = (struct dir_entry*)io_buf;		// dir_e用来在io_buf中遍历目录项【io_buf里面是一个一个的目录项】
c000b123:	8b 45 10             	mov    0x10(%ebp),%eax
c000b126:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/dir.c:217
		while (dir_entry_idx < dir_entrys_per_sec) {
c000b129:	e9 85 00 00 00       	jmp    c000b1b3 <sync_dir_entry+0x3e0>
/work/x86_os_my/fs/dir.c:218
			if ((dir_e + dir_entry_idx)->f_type == FT_UNKNOWN) {	// 无论是初始化或是删除文件，都会将f_type置为FT_UNKNOWN.
c000b12e:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
c000b132:	89 d0                	mov    %edx,%eax
c000b134:	01 c0                	add    %eax,%eax
c000b136:	01 d0                	add    %edx,%eax
c000b138:	c1 e0 03             	shl    $0x3,%eax
c000b13b:	89 c2                	mov    %eax,%edx
c000b13d:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000b140:	01 d0                	add    %edx,%eax
c000b142:	8b 40 14             	mov    0x14(%eax),%eax
c000b145:	85 c0                	test   %eax,%eax
c000b147:	75 60                	jne    c000b1a9 <sync_dir_entry+0x3d6>
/work/x86_os_my/fs/dir.c:219
				memcpy(dir_e + dir_entry_idx, p_de, dir_entry_size);    
c000b149:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
c000b14d:	89 d0                	mov    %edx,%eax
c000b14f:	01 c0                	add    %eax,%eax
c000b151:	01 d0                	add    %edx,%eax
c000b153:	c1 e0 03             	shl    $0x3,%eax
c000b156:	89 c2                	mov    %eax,%edx
c000b158:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000b15b:	01 d0                	add    %edx,%eax
c000b15d:	83 ec 04             	sub    $0x4,%esp
c000b160:	ff 75 e8             	pushl  -0x18(%ebp)
c000b163:	ff 75 0c             	pushl  0xc(%ebp)
c000b166:	50                   	push   %eax
c000b167:	e8 4b 89 ff ff       	call   c0003ab7 <memcpy>
c000b16c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:220
				ide_write(cur_part->my_disk, all_blocks[block_idx], io_buf, 1);
c000b16f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000b173:	8b 94 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%edx
c000b17a:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000b17f:	8b 40 08             	mov    0x8(%eax),%eax
c000b182:	6a 01                	push   $0x1
c000b184:	ff 75 10             	pushl  0x10(%ebp)
c000b187:	52                   	push   %edx
c000b188:	50                   	push   %eax
c000b189:	e8 ba b5 ff ff       	call   c0006748 <ide_write>
c000b18e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:222

				dir_inode->i_size += dir_entry_size;
c000b191:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000b194:	8b 50 04             	mov    0x4(%eax),%edx
c000b197:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000b19a:	01 c2                	add    %eax,%edx
c000b19c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000b19f:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/dir.c:223
				return true;
c000b1a2:	b8 01 00 00 00       	mov    $0x1,%eax
c000b1a7:	eb 40                	jmp    c000b1e9 <sync_dir_entry+0x416>
/work/x86_os_my/fs/dir.c:225
			}
			dir_entry_idx++;
c000b1a9:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c000b1ad:	83 c0 01             	add    $0x1,%eax
c000b1b0:	88 45 f6             	mov    %al,-0xa(%ebp)
/work/x86_os_my/fs/dir.c:217
		/* 二、若inode管理的第block_idx块是存在的，不需要分配，将其读进内存，然后在该块中查找空目录项，将p_de填入 */
		ide_read(cur_part->my_disk, all_blocks[block_idx], io_buf, 1); 
		/* 在扇区内查找空目录项 */
		uint8_t dir_entry_idx = 0;
		struct dir_entry* dir_e = (struct dir_entry*)io_buf;		// dir_e用来在io_buf中遍历目录项【io_buf里面是一个一个的目录项】
		while (dir_entry_idx < dir_entrys_per_sec) {
c000b1b3:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c000b1b7:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c000b1ba:	0f 82 6e ff ff ff    	jb     c000b12e <sync_dir_entry+0x35b>
/work/x86_os_my/fs/dir.c:230
			dir_entry_idx++;
		}


		/* 三、若inode管理的第block_idx块是存在的，不需要分配，但是都不是空闲(FT_UNKNOWN)的 */
		block_idx++;	//下一个inode管理的block
c000b1c0:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000b1c4:	83 c0 01             	add    $0x1,%eax
c000b1c7:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/dir.c:152
	}


	/* 开始遍历所有块以寻找目录项空位 */
	block_idx = 0;
	while (block_idx < 140) {	// 文件(包括目录)最多管理140个块
c000b1ca:	80 7d f7 8b          	cmpb   $0x8b,-0x9(%ebp)
c000b1ce:	0f 86 b7 fc ff ff    	jbe    c000ae8b <sync_dir_entry+0xb8>
/work/x86_os_my/fs/dir.c:233

		/* 三、若inode管理的第block_idx块是存在的，不需要分配，但是都不是空闲(FT_UNKNOWN)的 */
		block_idx++;	//下一个inode管理的block
	}//while (block_idx < 140)

	printk("directory is full!\n");
c000b1d4:	83 ec 0c             	sub    $0xc,%esp
c000b1d7:	68 d1 fa 00 c0       	push   $0xc000fad1
c000b1dc:	e8 6c be ff ff       	call   c000704d <printk>
c000b1e1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:234
	return false;
c000b1e4:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/dir.c:235 (discriminator 1)
}
c000b1e9:	8b 7d fc             	mov    -0x4(%ebp),%edi
c000b1ec:	c9                   	leave  
c000b1ed:	c3                   	ret    

c000b1ee <delete_dir_entry>:
delete_dir_entry():
/work/x86_os_my/fs/dir.c:244
（2）根目录是必须存在的，它是文件读写的根基，不应该被清空，它至少要保留 1 个块。
	 如果目录项独占 1个块，并且该块不是根目录最后一个块的话，将其回收。
（3）目录 inode 的 i_size 是目录项大小的总和，因此还要将 i_size 减去一个目录项的单位大小。
（4）目录 inode 改变后，要同步到硬盘。
 */
bool delete_dir_entry(struct partition* part, struct dir* pdir, uint32_t inode_no, void* io_buf) {
c000b1ee:	55                   	push   %ebp
c000b1ef:	89 e5                	mov    %esp,%ebp
c000b1f1:	57                   	push   %edi
c000b1f2:	81 ec 64 02 00 00    	sub    $0x264,%esp
/work/x86_os_my/fs/dir.c:245
	struct inode* dir_inode = pdir->inode;
c000b1f8:	8b 45 0c             	mov    0xc(%ebp),%eax
c000b1fb:	8b 00                	mov    (%eax),%eax
c000b1fd:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:246
	uint32_t block_idx = 0, all_blocks[140] = {0};
c000b200:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000b207:	8d 95 9c fd ff ff    	lea    -0x264(%ebp),%edx
c000b20d:	b8 00 00 00 00       	mov    $0x0,%eax
c000b212:	b9 8c 00 00 00       	mov    $0x8c,%ecx
c000b217:	89 d7                	mov    %edx,%edi
c000b219:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/fs/dir.c:249

	/* 收集目录全部块地址，存到到 all_blocks */
	while (block_idx < 12) {
c000b21b:	eb 1a                	jmp    c000b237 <delete_dir_entry+0x49>
/work/x86_os_my/fs/dir.c:250
		all_blocks[block_idx] = dir_inode->i_sectors[block_idx];
c000b21d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000b220:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000b223:	83 c2 04             	add    $0x4,%edx
c000b226:	8b 14 90             	mov    (%eax,%edx,4),%edx
c000b229:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000b22c:	89 94 85 9c fd ff ff 	mov    %edx,-0x264(%ebp,%eax,4)
/work/x86_os_my/fs/dir.c:251
		block_idx++;
c000b233:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:249
bool delete_dir_entry(struct partition* part, struct dir* pdir, uint32_t inode_no, void* io_buf) {
	struct inode* dir_inode = pdir->inode;
	uint32_t block_idx = 0, all_blocks[140] = {0};

	/* 收集目录全部块地址，存到到 all_blocks */
	while (block_idx < 12) {
c000b237:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
c000b23b:	76 e0                	jbe    c000b21d <delete_dir_entry+0x2f>
/work/x86_os_my/fs/dir.c:253
		all_blocks[block_idx] = dir_inode->i_sectors[block_idx];
		block_idx++;
	}
	if (dir_inode->i_sectors[12]) {
c000b23d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000b240:	8b 40 40             	mov    0x40(%eax),%eax
c000b243:	85 c0                	test   %eax,%eax
c000b245:	74 22                	je     c000b269 <delete_dir_entry+0x7b>
/work/x86_os_my/fs/dir.c:254
		ide_read(part->my_disk, dir_inode->i_sectors[12], all_blocks + 12, 1);
c000b247:	8d 85 9c fd ff ff    	lea    -0x264(%ebp),%eax
c000b24d:	83 c0 30             	add    $0x30,%eax
c000b250:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000b253:	8b 4a 40             	mov    0x40(%edx),%ecx
c000b256:	8b 55 08             	mov    0x8(%ebp),%edx
c000b259:	8b 52 08             	mov    0x8(%edx),%edx
c000b25c:	6a 01                	push   $0x1
c000b25e:	50                   	push   %eax
c000b25f:	51                   	push   %ecx
c000b260:	52                   	push   %edx
c000b261:	e8 6e b3 ff ff       	call   c00065d4 <ide_read>
c000b266:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:258
	}

	/* 目录项在存储时保证不会跨扇区 */
	uint32_t dir_entry_size = part->sb->dir_entry_size;
c000b269:	8b 45 08             	mov    0x8(%ebp),%eax
c000b26c:	8b 40 1c             	mov    0x1c(%eax),%eax
c000b26f:	8b 40 30             	mov    0x30(%eax),%eax
c000b272:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:259
	uint32_t dir_entrys_per_sec = (SECTOR_SIZE / dir_entry_size);	// 每扇区最大的目录项数目
c000b275:	b8 00 02 00 00       	mov    $0x200,%eax
c000b27a:	ba 00 00 00 00       	mov    $0x0,%edx
c000b27f:	f7 75 dc             	divl   -0x24(%ebp)
c000b282:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/dir.c:260
	struct dir_entry* dir_e = (struct dir_entry*)io_buf;
c000b285:	8b 45 14             	mov    0x14(%ebp),%eax
c000b288:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/fs/dir.c:261
	struct dir_entry* dir_entry_found = NULL;
c000b28b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:263
	uint8_t dir_entry_idx, dir_entry_cnt;
	bool is_dir_first_block = false;	// 目录的第1个块
c000b292:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
/work/x86_os_my/fs/dir.c:266

	/* 遍历所有块，寻找目录项 */
	block_idx = 0;
c000b299:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:267
	while (block_idx < 140) {
c000b2a0:	e9 9a 03 00 00       	jmp    c000b63f <delete_dir_entry+0x451>
/work/x86_os_my/fs/dir.c:268
		is_dir_first_block = false;
c000b2a5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
/work/x86_os_my/fs/dir.c:269
		if (all_blocks[block_idx] == 0) {
c000b2ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000b2af:	8b 84 85 9c fd ff ff 	mov    -0x264(%ebp,%eax,4),%eax
c000b2b6:	85 c0                	test   %eax,%eax
c000b2b8:	75 09                	jne    c000b2c3 <delete_dir_entry+0xd5>
/work/x86_os_my/fs/dir.c:270
			block_idx++;
c000b2ba:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:271
			continue;
c000b2be:	e9 7c 03 00 00       	jmp    c000b63f <delete_dir_entry+0x451>
/work/x86_os_my/fs/dir.c:273
		}
		dir_entry_idx = dir_entry_cnt = 0;
c000b2c3:	c6 45 ee 00          	movb   $0x0,-0x12(%ebp)
c000b2c7:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
c000b2cb:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/fs/dir.c:274
		memset(io_buf, 0, SECTOR_SIZE);
c000b2ce:	83 ec 04             	sub    $0x4,%esp
c000b2d1:	68 00 02 00 00       	push   $0x200
c000b2d6:	6a 00                	push   $0x0
c000b2d8:	ff 75 14             	pushl  0x14(%ebp)
c000b2db:	e8 85 87 ff ff       	call   c0003a65 <memset>
c000b2e0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:276
		/* 读取目录inode管理的各个数据块（扇区），里面是目录项 */
		ide_read(part->my_disk, all_blocks[block_idx], io_buf, 1);	//dir_e = io_buf
c000b2e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000b2e6:	8b 94 85 9c fd ff ff 	mov    -0x264(%ebp,%eax,4),%edx
c000b2ed:	8b 45 08             	mov    0x8(%ebp),%eax
c000b2f0:	8b 40 08             	mov    0x8(%eax),%eax
c000b2f3:	6a 01                	push   $0x1
c000b2f5:	ff 75 14             	pushl  0x14(%ebp)
c000b2f8:	52                   	push   %edx
c000b2f9:	50                   	push   %eax
c000b2fa:	e8 d5 b2 ff ff       	call   c00065d4 <ide_read>
c000b2ff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:279

		/* 遍历所有的目录项，统计该扇区的目录项数量 + 是否找到要删除的目录项 */
		while (dir_entry_idx < dir_entrys_per_sec) {
c000b302:	e9 13 01 00 00       	jmp    c000b41a <delete_dir_entry+0x22c>
/work/x86_os_my/fs/dir.c:280
			if ((dir_e + dir_entry_idx)->f_type != FT_UNKNOWN) {	// 初始化或是删除文件，会将f_type置为FT_UNKNOWN.
c000b307:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c000b30b:	89 d0                	mov    %edx,%eax
c000b30d:	01 c0                	add    %eax,%eax
c000b30f:	01 d0                	add    %edx,%eax
c000b311:	c1 e0 03             	shl    $0x3,%eax
c000b314:	89 c2                	mov    %eax,%edx
c000b316:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000b319:	01 d0                	add    %edx,%eax
c000b31b:	8b 40 14             	mov    0x14(%eax),%eax
c000b31e:	85 c0                	test   %eax,%eax
c000b320:	0f 84 ea 00 00 00    	je     c000b410 <delete_dir_entry+0x222>
/work/x86_os_my/fs/dir.c:281
				if (!strcmp((dir_e + dir_entry_idx)->filename, ".")) {
c000b326:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c000b32a:	89 d0                	mov    %edx,%eax
c000b32c:	01 c0                	add    %eax,%eax
c000b32e:	01 d0                	add    %edx,%eax
c000b330:	c1 e0 03             	shl    $0x3,%eax
c000b333:	89 c2                	mov    %eax,%edx
c000b335:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000b338:	01 d0                	add    %edx,%eax
c000b33a:	83 ec 08             	sub    $0x8,%esp
c000b33d:	68 e5 fa 00 c0       	push   $0xc000fae5
c000b342:	50                   	push   %eax
c000b343:	e8 f2 88 ff ff       	call   c0003c3a <strcmp>
c000b348:	83 c4 10             	add    $0x10,%esp
c000b34b:	84 c0                	test   %al,%al
c000b34d:	75 0c                	jne    c000b35b <delete_dir_entry+0x16d>
/work/x86_os_my/fs/dir.c:282
					is_dir_first_block = true;
c000b34f:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
c000b356:	e9 b5 00 00 00       	jmp    c000b410 <delete_dir_entry+0x222>
/work/x86_os_my/fs/dir.c:283
				} else if (strcmp((dir_e + dir_entry_idx)->filename, ".") && strcmp((dir_e + dir_entry_idx)->filename, "..")) {	//不是.和..
c000b35b:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c000b35f:	89 d0                	mov    %edx,%eax
c000b361:	01 c0                	add    %eax,%eax
c000b363:	01 d0                	add    %edx,%eax
c000b365:	c1 e0 03             	shl    $0x3,%eax
c000b368:	89 c2                	mov    %eax,%edx
c000b36a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000b36d:	01 d0                	add    %edx,%eax
c000b36f:	83 ec 08             	sub    $0x8,%esp
c000b372:	68 e5 fa 00 c0       	push   $0xc000fae5
c000b377:	50                   	push   %eax
c000b378:	e8 bd 88 ff ff       	call   c0003c3a <strcmp>
c000b37d:	83 c4 10             	add    $0x10,%esp
c000b380:	84 c0                	test   %al,%al
c000b382:	0f 84 88 00 00 00    	je     c000b410 <delete_dir_entry+0x222>
/work/x86_os_my/fs/dir.c:283 (discriminator 1)
c000b388:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c000b38c:	89 d0                	mov    %edx,%eax
c000b38e:	01 c0                	add    %eax,%eax
c000b390:	01 d0                	add    %edx,%eax
c000b392:	c1 e0 03             	shl    $0x3,%eax
c000b395:	89 c2                	mov    %eax,%edx
c000b397:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000b39a:	01 d0                	add    %edx,%eax
c000b39c:	83 ec 08             	sub    $0x8,%esp
c000b39f:	68 e7 fa 00 c0       	push   $0xc000fae7
c000b3a4:	50                   	push   %eax
c000b3a5:	e8 90 88 ff ff       	call   c0003c3a <strcmp>
c000b3aa:	83 c4 10             	add    $0x10,%esp
c000b3ad:	84 c0                	test   %al,%al
c000b3af:	74 5f                	je     c000b410 <delete_dir_entry+0x222>
/work/x86_os_my/fs/dir.c:284
					dir_entry_cnt++;     // 统计此扇区内的目录项个数，用来判断删除目录项后是否回收该扇区
c000b3b1:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
c000b3b5:	83 c0 01             	add    $0x1,%eax
c000b3b8:	88 45 ee             	mov    %al,-0x12(%ebp)
/work/x86_os_my/fs/dir.c:286
					// 目录项的成员inode号和目标inode号一致，就将其记录在dir_entry_found！！！
					if ((dir_e + dir_entry_idx)->i_no == inode_no) {
c000b3bb:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c000b3bf:	89 d0                	mov    %edx,%eax
c000b3c1:	01 c0                	add    %eax,%eax
c000b3c3:	01 d0                	add    %edx,%eax
c000b3c5:	c1 e0 03             	shl    $0x3,%eax
c000b3c8:	89 c2                	mov    %eax,%edx
c000b3ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000b3cd:	01 d0                	add    %edx,%eax
c000b3cf:	8b 40 10             	mov    0x10(%eax),%eax
c000b3d2:	3b 45 10             	cmp    0x10(%ebp),%eax
c000b3d5:	75 39                	jne    c000b410 <delete_dir_entry+0x222>
/work/x86_os_my/fs/dir.c:287
						ASSERT(dir_entry_found == NULL);  // 确保目录中只有一个编号为inode_no的inode,找到一次后dir_entry_found就不再是NULL
c000b3d7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000b3db:	74 1c                	je     c000b3f9 <delete_dir_entry+0x20b>
/work/x86_os_my/fs/dir.c:287 (discriminator 1)
c000b3dd:	68 ea fa 00 c0       	push   $0xc000faea
c000b3e2:	68 ec fb 00 c0       	push   $0xc000fbec
c000b3e7:	68 1f 01 00 00       	push   $0x11f
c000b3ec:	68 62 fa 00 c0       	push   $0xc000fa62
c000b3f1:	e8 6b 71 ff ff       	call   c0002561 <panic_spin>
c000b3f6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:288
						dir_entry_found = dir_e + dir_entry_idx;
c000b3f9:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c000b3fd:	89 d0                	mov    %edx,%eax
c000b3ff:	01 c0                	add    %eax,%eax
c000b401:	01 d0                	add    %edx,%eax
c000b403:	c1 e0 03             	shl    $0x3,%eax
c000b406:	89 c2                	mov    %eax,%edx
c000b408:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000b40b:	01 d0                	add    %edx,%eax
c000b40d:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:293
						/* 找到后也继续遍历,统计总共的目录项数 */
					}
				}
			}
			dir_entry_idx++;
c000b410:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c000b414:	83 c0 01             	add    $0x1,%eax
c000b417:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/fs/dir.c:279
		memset(io_buf, 0, SECTOR_SIZE);
		/* 读取目录inode管理的各个数据块（扇区），里面是目录项 */
		ide_read(part->my_disk, all_blocks[block_idx], io_buf, 1);	//dir_e = io_buf

		/* 遍历所有的目录项，统计该扇区的目录项数量 + 是否找到要删除的目录项 */
		while (dir_entry_idx < dir_entrys_per_sec) {
c000b41a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c000b41e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c000b421:	0f 82 e0 fe ff ff    	jb     c000b307 <delete_dir_entry+0x119>
/work/x86_os_my/fs/dir.c:297
			}
			dir_entry_idx++;
		}

		/* 若此扇区未找到该目录项,继续在下个扇区中找 */
		if (dir_entry_found == NULL) {
c000b427:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000b42b:	75 09                	jne    c000b436 <delete_dir_entry+0x248>
/work/x86_os_my/fs/dir.c:298
			block_idx++;
c000b42d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:299
			continue;
c000b431:	e9 09 02 00 00       	jmp    c000b63f <delete_dir_entry+0x451>
/work/x86_os_my/fs/dir.c:303
		}

		/* 在此扇区中找到目录项后，清除该目录项并判断是否回收扇区，随后退出循环直接返回 */
		ASSERT(dir_entry_cnt >= 1);	//此扇区内的目录项个数
c000b436:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c000b43a:	75 1c                	jne    c000b458 <delete_dir_entry+0x26a>
/work/x86_os_my/fs/dir.c:303 (discriminator 1)
c000b43c:	68 02 fb 00 c0       	push   $0xc000fb02
c000b441:	68 ec fb 00 c0       	push   $0xc000fbec
c000b446:	68 2f 01 00 00       	push   $0x12f
c000b44b:	68 62 fa 00 c0       	push   $0xc000fa62
c000b450:	e8 0c 71 ff ff       	call   c0002561 <panic_spin>
c000b455:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:305
		/* 若该扇区上只有该目录项自己，则将整个扇区回收。如果目录只有第1个扇区，则不能回收 */
		if (dir_entry_cnt == 1 && !is_dir_first_block) {
c000b458:	80 7d ee 01          	cmpb   $0x1,-0x12(%ebp)
c000b45c:	0f 85 43 01 00 00    	jne    c000b5a5 <delete_dir_entry+0x3b7>
/work/x86_os_my/fs/dir.c:305 (discriminator 1)
c000b462:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c000b466:	0f 85 39 01 00 00    	jne    c000b5a5 <delete_dir_entry+0x3b7>
/work/x86_os_my/fs/dir.c:307
			/* a 在块位图中回收该块 */
			uint32_t block_bitmap_idx = all_blocks[block_idx] - part->sb->data_start_lba;
c000b46c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000b46f:	8b 94 85 9c fd ff ff 	mov    -0x264(%ebp,%eax,4),%edx
c000b476:	8b 45 08             	mov    0x8(%ebp),%eax
c000b479:	8b 40 1c             	mov    0x1c(%eax),%eax
c000b47c:	8b 40 28             	mov    0x28(%eax),%eax
c000b47f:	29 c2                	sub    %eax,%edx
c000b481:	89 d0                	mov    %edx,%eax
c000b483:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/fs/dir.c:308
			bitmap_set(&part->block_bitmap, block_bitmap_idx, 0);
c000b486:	8b 45 08             	mov    0x8(%ebp),%eax
c000b489:	83 c0 20             	add    $0x20,%eax
c000b48c:	83 ec 04             	sub    $0x4,%esp
c000b48f:	6a 00                	push   $0x0
c000b491:	ff 75 d0             	pushl  -0x30(%ebp)
c000b494:	50                   	push   %eax
c000b495:	e8 35 73 ff ff       	call   c00027cf <bitmap_set>
c000b49a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:309
			bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c000b49d:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000b4a2:	83 ec 04             	sub    $0x4,%esp
c000b4a5:	6a 01                	push   $0x1
c000b4a7:	ff 75 d0             	pushl  -0x30(%ebp)
c000b4aa:	50                   	push   %eax
c000b4ab:	e8 54 e6 ff ff       	call   c0009b04 <bitmap_sync>
c000b4b0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:312

			/* b 将块地址从数组 i_sectors 或 从一级间接索引表中去掉 */
			if (block_idx < 12) {	//直接块
c000b4b3:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
c000b4b7:	77 15                	ja     c000b4ce <delete_dir_entry+0x2e0>
/work/x86_os_my/fs/dir.c:313
				dir_inode->i_sectors[block_idx] = 0;
c000b4b9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000b4bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000b4bf:	83 c2 04             	add    $0x4,%edx
c000b4c2:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
/work/x86_os_my/fs/dir.c:305
		}

		/* 在此扇区中找到目录项后，清除该目录项并判断是否回收扇区，随后退出循环直接返回 */
		ASSERT(dir_entry_cnt >= 1);	//此扇区内的目录项个数
		/* 若该扇区上只有该目录项自己，则将整个扇区回收。如果目录只有第1个扇区，则不能回收 */
		if (dir_entry_cnt == 1 && !is_dir_first_block) {
c000b4c9:	e9 09 01 00 00       	jmp    c000b5d7 <delete_dir_entry+0x3e9>
/work/x86_os_my/fs/dir.c:316
			/* b 将块地址从数组 i_sectors 或 从一级间接索引表中去掉 */
			if (block_idx < 12) {	//直接块
				dir_inode->i_sectors[block_idx] = 0;
			} else {	// 在一级间接索引表中擦除该间接块地址
				/*先判断一级间接索引表中间接块的数量：如果仅有这1个间接块，连同间接索引表所在的块一同回收 */
				uint32_t indirect_blocks = 0;
c000b4ce:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
/work/x86_os_my/fs/dir.c:317
				uint32_t indirect_block_idx = 12;
c000b4d5:	c7 45 cc 0c 00 00 00 	movl   $0xc,-0x34(%ebp)
/work/x86_os_my/fs/dir.c:318
				while (indirect_block_idx < 140) {
c000b4dc:	eb 12                	jmp    c000b4f0 <delete_dir_entry+0x302>
/work/x86_os_my/fs/dir.c:319
					if (all_blocks[indirect_block_idx] != 0) {
c000b4de:	8b 45 cc             	mov    -0x34(%ebp),%eax
c000b4e1:	8b 84 85 9c fd ff ff 	mov    -0x264(%ebp,%eax,4),%eax
c000b4e8:	85 c0                	test   %eax,%eax
c000b4ea:	74 04                	je     c000b4f0 <delete_dir_entry+0x302>
/work/x86_os_my/fs/dir.c:320
						indirect_blocks++;	//间接块的数量
c000b4ec:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
/work/x86_os_my/fs/dir.c:318
				dir_inode->i_sectors[block_idx] = 0;
			} else {	// 在一级间接索引表中擦除该间接块地址
				/*先判断一级间接索引表中间接块的数量：如果仅有这1个间接块，连同间接索引表所在的块一同回收 */
				uint32_t indirect_blocks = 0;
				uint32_t indirect_block_idx = 12;
				while (indirect_block_idx < 140) {
c000b4f0:	81 7d cc 8b 00 00 00 	cmpl   $0x8b,-0x34(%ebp)
c000b4f7:	76 e5                	jbe    c000b4de <delete_dir_entry+0x2f0>
/work/x86_os_my/fs/dir.c:323
					if (all_blocks[indirect_block_idx] != 0) {
						indirect_blocks++;	//间接块的数量
					}
				}
				ASSERT(indirect_blocks >= 1);	// 包括当前间接块
c000b4f9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c000b4fd:	75 1c                	jne    c000b51b <delete_dir_entry+0x32d>
/work/x86_os_my/fs/dir.c:323 (discriminator 1)
c000b4ff:	68 15 fb 00 c0       	push   $0xc000fb15
c000b504:	68 ec fb 00 c0       	push   $0xc000fbec
c000b509:	68 43 01 00 00       	push   $0x143
c000b50e:	68 62 fa 00 c0       	push   $0xc000fa62
c000b513:	e8 49 70 ff ff       	call   c0002561 <panic_spin>
c000b518:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:325

				if (indirect_blocks > 1) {	  // 一级间接索引表中还包括其它间接块,仅在索引表中擦除当前间接块地址
c000b51b:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
c000b51f:	76 35                	jbe    c000b556 <delete_dir_entry+0x368>
/work/x86_os_my/fs/dir.c:326
					all_blocks[block_idx] = 0;
c000b521:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000b524:	c7 84 85 9c fd ff ff 	movl   $0x0,-0x264(%ebp,%eax,4)
c000b52b:	00 00 00 00 
/work/x86_os_my/fs/dir.c:327
					ide_write(part->my_disk, dir_inode->i_sectors[12], all_blocks + 12, 1);
c000b52f:	8d 85 9c fd ff ff    	lea    -0x264(%ebp),%eax
c000b535:	83 c0 30             	add    $0x30,%eax
c000b538:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000b53b:	8b 4a 40             	mov    0x40(%edx),%ecx
c000b53e:	8b 55 08             	mov    0x8(%ebp),%edx
c000b541:	8b 52 08             	mov    0x8(%edx),%edx
c000b544:	6a 01                	push   $0x1
c000b546:	50                   	push   %eax
c000b547:	51                   	push   %ecx
c000b548:	52                   	push   %edx
c000b549:	e8 fa b1 ff ff       	call   c0006748 <ide_write>
c000b54e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:305
		}

		/* 在此扇区中找到目录项后，清除该目录项并判断是否回收扇区，随后退出循环直接返回 */
		ASSERT(dir_entry_cnt >= 1);	//此扇区内的目录项个数
		/* 若该扇区上只有该目录项自己，则将整个扇区回收。如果目录只有第1个扇区，则不能回收 */
		if (dir_entry_cnt == 1 && !is_dir_first_block) {
c000b551:	e9 81 00 00 00       	jmp    c000b5d7 <delete_dir_entry+0x3e9>
/work/x86_os_my/fs/dir.c:330
				if (indirect_blocks > 1) {	  // 一级间接索引表中还包括其它间接块,仅在索引表中擦除当前间接块地址
					all_blocks[block_idx] = 0;
					ide_write(part->my_disk, dir_inode->i_sectors[12], all_blocks + 12, 1);
				} else {	// 间接索引表中就当前这1个间接块,直接把间接索引表所在的块回收,然后擦除间接索引表块地址
					/* 回收一级间接索引表所在的块 */
					block_bitmap_idx = dir_inode->i_sectors[12] - part->sb->data_start_lba;
c000b556:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000b559:	8b 50 40             	mov    0x40(%eax),%edx
c000b55c:	8b 45 08             	mov    0x8(%ebp),%eax
c000b55f:	8b 40 1c             	mov    0x1c(%eax),%eax
c000b562:	8b 40 28             	mov    0x28(%eax),%eax
c000b565:	29 c2                	sub    %eax,%edx
c000b567:	89 d0                	mov    %edx,%eax
c000b569:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/fs/dir.c:331
					bitmap_set(&part->block_bitmap, block_bitmap_idx, 0);
c000b56c:	8b 45 08             	mov    0x8(%ebp),%eax
c000b56f:	83 c0 20             	add    $0x20,%eax
c000b572:	83 ec 04             	sub    $0x4,%esp
c000b575:	6a 00                	push   $0x0
c000b577:	ff 75 d0             	pushl  -0x30(%ebp)
c000b57a:	50                   	push   %eax
c000b57b:	e8 4f 72 ff ff       	call   c00027cf <bitmap_set>
c000b580:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:332
					bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c000b583:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000b588:	83 ec 04             	sub    $0x4,%esp
c000b58b:	6a 01                	push   $0x1
c000b58d:	ff 75 d0             	pushl  -0x30(%ebp)
c000b590:	50                   	push   %eax
c000b591:	e8 6e e5 ff ff       	call   c0009b04 <bitmap_sync>
c000b596:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:335

					/* 将间接索引表地址清0 */
					dir_inode->i_sectors[12] = 0;
c000b599:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000b59c:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
/work/x86_os_my/fs/dir.c:305
		}

		/* 在此扇区中找到目录项后，清除该目录项并判断是否回收扇区，随后退出循环直接返回 */
		ASSERT(dir_entry_cnt >= 1);	//此扇区内的目录项个数
		/* 若该扇区上只有该目录项自己，则将整个扇区回收。如果目录只有第1个扇区，则不能回收 */
		if (dir_entry_cnt == 1 && !is_dir_first_block) {
c000b5a3:	eb 32                	jmp    c000b5d7 <delete_dir_entry+0x3e9>
/work/x86_os_my/fs/dir.c:340
					dir_inode->i_sectors[12] = 0;
				}
			}
		} else {
		/* 仅将该目录项清空 */
			memset(dir_entry_found, 0, dir_entry_size);	//要删除的目录项在 dir_entry_found 中
c000b5a5:	83 ec 04             	sub    $0x4,%esp
c000b5a8:	ff 75 dc             	pushl  -0x24(%ebp)
c000b5ab:	6a 00                	push   $0x0
c000b5ad:	ff 75 f0             	pushl  -0x10(%ebp)
c000b5b0:	e8 b0 84 ff ff       	call   c0003a65 <memset>
c000b5b5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:341
			ide_write(part->my_disk, all_blocks[block_idx], io_buf, 1);	//io_buf中是所有的目录项
c000b5b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000b5bb:	8b 94 85 9c fd ff ff 	mov    -0x264(%ebp,%eax,4),%edx
c000b5c2:	8b 45 08             	mov    0x8(%ebp),%eax
c000b5c5:	8b 40 08             	mov    0x8(%eax),%eax
c000b5c8:	6a 01                	push   $0x1
c000b5ca:	ff 75 14             	pushl  0x14(%ebp)
c000b5cd:	52                   	push   %edx
c000b5ce:	50                   	push   %eax
c000b5cf:	e8 74 b1 ff ff       	call   c0006748 <ide_write>
c000b5d4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:345
		}

		/* 更新inode信息并同步到硬盘 */
		ASSERT(dir_inode->i_size >= dir_entry_size);
c000b5d7:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000b5da:	8b 40 04             	mov    0x4(%eax),%eax
c000b5dd:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c000b5e0:	73 1c                	jae    c000b5fe <delete_dir_entry+0x410>
/work/x86_os_my/fs/dir.c:345 (discriminator 1)
c000b5e2:	68 2c fb 00 c0       	push   $0xc000fb2c
c000b5e7:	68 ec fb 00 c0       	push   $0xc000fbec
c000b5ec:	68 59 01 00 00       	push   $0x159
c000b5f1:	68 62 fa 00 c0       	push   $0xc000fa62
c000b5f6:	e8 66 6f ff ff       	call   c0002561 <panic_spin>
c000b5fb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:346
		dir_inode->i_size -= dir_entry_size;
c000b5fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000b601:	8b 40 04             	mov    0x4(%eax),%eax
c000b604:	2b 45 dc             	sub    -0x24(%ebp),%eax
c000b607:	89 c2                	mov    %eax,%edx
c000b609:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000b60c:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/dir.c:347
		memset(io_buf, 0, SECTOR_SIZE * 2);
c000b60f:	83 ec 04             	sub    $0x4,%esp
c000b612:	68 00 04 00 00       	push   $0x400
c000b617:	6a 00                	push   $0x0
c000b619:	ff 75 14             	pushl  0x14(%ebp)
c000b61c:	e8 44 84 ff ff       	call   c0003a65 <memset>
c000b621:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:349
		// 同步目录文件的inode到硬盘
		inode_sync(part, dir_inode, io_buf);
c000b624:	83 ec 04             	sub    $0x4,%esp
c000b627:	ff 75 14             	pushl  0x14(%ebp)
c000b62a:	ff 75 e0             	pushl  -0x20(%ebp)
c000b62d:	ff 75 08             	pushl  0x8(%ebp)
c000b630:	e8 ea dc ff ff       	call   c000931f <inode_sync>
c000b635:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:351

		return true;
c000b638:	b8 01 00 00 00       	mov    $0x1,%eax
c000b63d:	eb 12                	jmp    c000b651 <delete_dir_entry+0x463>
/work/x86_os_my/fs/dir.c:267
	uint8_t dir_entry_idx, dir_entry_cnt;
	bool is_dir_first_block = false;	// 目录的第1个块

	/* 遍历所有块，寻找目录项 */
	block_idx = 0;
	while (block_idx < 140) {
c000b63f:	81 7d f4 8b 00 00 00 	cmpl   $0x8b,-0xc(%ebp)
c000b646:	0f 86 59 fc ff ff    	jbe    c000b2a5 <delete_dir_entry+0xb7>
/work/x86_os_my/fs/dir.c:355

		return true;
	}//while (block_idx < 140)

	/* 所有块中未找到则返回false，若出现这种情况应该是 serarch_file 出错了 */
	return false;
c000b64c:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/dir.c:356 (discriminator 1)
}
c000b651:	8b 7d fc             	mov    -0x4(%ebp),%edi
c000b654:	c9                   	leave  
c000b655:	c3                   	ret    

c000b656 <dir_read>:
dir_read():
/work/x86_os_my/fs/dir.c:361


/* 读取目录,成功返回1个目录项,失败返回NULL */
// dir->dir_pos 记录遍历目录时，"游标"在目录内的偏移【以前读到的目录项】
struct dir_entry* dir_read(struct dir* dir) {
c000b656:	55                   	push   %ebp
c000b657:	89 e5                	mov    %esp,%ebp
c000b659:	57                   	push   %edi
c000b65a:	81 ec 54 02 00 00    	sub    $0x254,%esp
/work/x86_os_my/fs/dir.c:362
	struct dir_entry* dir_e = (struct dir_entry*)dir->dir_buf;
c000b660:	8b 45 08             	mov    0x8(%ebp),%eax
c000b663:	83 c0 08             	add    $0x8,%eax
c000b666:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/dir.c:363
	struct inode* dir_inode = dir->inode;
c000b669:	8b 45 08             	mov    0x8(%ebp),%eax
c000b66c:	8b 00                	mov    (%eax),%eax
c000b66e:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:364
	uint32_t all_blocks[140] = {0}, block_cnt = 12;
c000b671:	8d 95 a8 fd ff ff    	lea    -0x258(%ebp),%edx
c000b677:	b8 00 00 00 00       	mov    $0x0,%eax
c000b67c:	b9 8c 00 00 00       	mov    $0x8c,%ecx
c000b681:	89 d7                	mov    %edx,%edi
c000b683:	f3 ab                	rep stos %eax,%es:(%edi)
c000b685:	c7 45 f4 0c 00 00 00 	movl   $0xc,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:365
	uint32_t block_idx = 0, dir_entry_idx = 0;
c000b68c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c000b693:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:367
	// 所有数据块的地址，汇集到 all_blocks 中
	while (block_idx < 12) {
c000b69a:	eb 1a                	jmp    c000b6b6 <dir_read+0x60>
/work/x86_os_my/fs/dir.c:368
		all_blocks[block_idx] = dir_inode->i_sectors[block_idx];
c000b69c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000b69f:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000b6a2:	83 c2 04             	add    $0x4,%edx
c000b6a5:	8b 14 90             	mov    (%eax,%edx,4),%edx
c000b6a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000b6ab:	89 94 85 a8 fd ff ff 	mov    %edx,-0x258(%ebp,%eax,4)
/work/x86_os_my/fs/dir.c:369
		block_idx++;
c000b6b2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:367
	struct dir_entry* dir_e = (struct dir_entry*)dir->dir_buf;
	struct inode* dir_inode = dir->inode;
	uint32_t all_blocks[140] = {0}, block_cnt = 12;
	uint32_t block_idx = 0, dir_entry_idx = 0;
	// 所有数据块的地址，汇集到 all_blocks 中
	while (block_idx < 12) {
c000b6b6:	83 7d f0 0b          	cmpl   $0xb,-0x10(%ebp)
c000b6ba:	76 e0                	jbe    c000b69c <dir_read+0x46>
/work/x86_os_my/fs/dir.c:371
		all_blocks[block_idx] = dir_inode->i_sectors[block_idx];
		block_idx++;
	}
	if (dir_inode->i_sectors[12] != 0) {
c000b6bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000b6bf:	8b 40 40             	mov    0x40(%eax),%eax
c000b6c2:	85 c0                	test   %eax,%eax
c000b6c4:	74 2c                	je     c000b6f2 <dir_read+0x9c>
/work/x86_os_my/fs/dir.c:372
		ide_read(cur_part->my_disk, dir_inode->i_sectors[12], all_blocks + 12, 1);
c000b6c6:	8d 85 a8 fd ff ff    	lea    -0x258(%ebp),%eax
c000b6cc:	83 c0 30             	add    $0x30,%eax
c000b6cf:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000b6d2:	8b 4a 40             	mov    0x40(%edx),%ecx
c000b6d5:	8b 15 90 58 01 c0    	mov    0xc0015890,%edx
c000b6db:	8b 52 08             	mov    0x8(%edx),%edx
c000b6de:	6a 01                	push   $0x1
c000b6e0:	50                   	push   %eax
c000b6e1:	51                   	push   %ecx
c000b6e2:	52                   	push   %edx
c000b6e3:	e8 ec ae ff ff       	call   c00065d4 <ide_read>
c000b6e8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:373
		block_cnt = 140;
c000b6eb:	c7 45 f4 8c 00 00 00 	movl   $0x8c,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:375
	}
	block_idx = 0;
c000b6f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:377

	uint32_t cur_dir_entry_pos = 0;	// 当前目录项的偏移,此项用来判断是否是之前已经返回过的目录项
c000b6f9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
/work/x86_os_my/fs/dir.c:378
	uint32_t dir_entry_size = cur_part->sb->dir_entry_size;
c000b700:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000b705:	8b 40 1c             	mov    0x1c(%eax),%eax
c000b708:	8b 40 30             	mov    0x30(%eax),%eax
c000b70b:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:379
	uint32_t dir_entrys_per_sec = SECTOR_SIZE / dir_entry_size;	// 1扇区内可容纳的目录项个数
c000b70e:	b8 00 02 00 00       	mov    $0x200,%eax
c000b713:	ba 00 00 00 00       	mov    $0x0,%edx
c000b718:	f7 75 dc             	divl   -0x24(%ebp)
c000b71b:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/dir.c:381
	/* 因为此目录内可能删除了某些文件或子目录,所以要遍历所有块 */
	while (block_idx < block_cnt) {
c000b71e:	e9 05 01 00 00       	jmp    c000b828 <dir_read+0x1d2>
/work/x86_os_my/fs/dir.c:382
		if (dir->dir_pos >= dir_inode->i_size) {	//dir_pos 记录遍历目录时，"游标"在目录内的偏移
c000b723:	8b 45 08             	mov    0x8(%ebp),%eax
c000b726:	8b 50 04             	mov    0x4(%eax),%edx
c000b729:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000b72c:	8b 40 04             	mov    0x4(%eax),%eax
c000b72f:	39 c2                	cmp    %eax,%edx
c000b731:	72 0a                	jb     c000b73d <dir_read+0xe7>
/work/x86_os_my/fs/dir.c:383
			return NULL;
c000b733:	b8 00 00 00 00       	mov    $0x0,%eax
c000b738:	e9 fc 00 00 00       	jmp    c000b839 <dir_read+0x1e3>
/work/x86_os_my/fs/dir.c:385
		}
		if (all_blocks[block_idx] == 0) {	// 如果此块地址为0,即空块,继续读出下一块
c000b73d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000b740:	8b 84 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%eax
c000b747:	85 c0                	test   %eax,%eax
c000b749:	75 09                	jne    c000b754 <dir_read+0xfe>
/work/x86_os_my/fs/dir.c:386
			block_idx++;
c000b74b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:387
			continue;
c000b74f:	e9 d4 00 00 00       	jmp    c000b828 <dir_read+0x1d2>
/work/x86_os_my/fs/dir.c:389
		}
		memset(dir_e, 0, SECTOR_SIZE);
c000b754:	83 ec 04             	sub    $0x4,%esp
c000b757:	68 00 02 00 00       	push   $0x200
c000b75c:	6a 00                	push   $0x0
c000b75e:	ff 75 e4             	pushl  -0x1c(%ebp)
c000b761:	e8 ff 82 ff ff       	call   c0003a65 <memset>
c000b766:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:390
		ide_read(cur_part->my_disk, all_blocks[block_idx], dir_e, 1);
c000b769:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000b76c:	8b 94 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%edx
c000b773:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000b778:	8b 40 08             	mov    0x8(%eax),%eax
c000b77b:	6a 01                	push   $0x1
c000b77d:	ff 75 e4             	pushl  -0x1c(%ebp)
c000b780:	52                   	push   %edx
c000b781:	50                   	push   %eax
c000b782:	e8 4d ae ff ff       	call   c00065d4 <ide_read>
c000b787:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:391
		dir_entry_idx = 0;
c000b78a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:393
		/* 遍历扇区内所有目录项 */
		while (dir_entry_idx < dir_entrys_per_sec) {
c000b791:	e9 82 00 00 00       	jmp    c000b818 <dir_read+0x1c2>
/work/x86_os_my/fs/dir.c:394
			if ((dir_e + dir_entry_idx)->f_type) {	 // 如果f_type不等于0,即不等于FT_UNKNOWN
c000b796:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000b799:	89 d0                	mov    %edx,%eax
c000b79b:	01 c0                	add    %eax,%eax
c000b79d:	01 d0                	add    %edx,%eax
c000b79f:	c1 e0 03             	shl    $0x3,%eax
c000b7a2:	89 c2                	mov    %eax,%edx
c000b7a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000b7a7:	01 d0                	add    %edx,%eax
c000b7a9:	8b 40 14             	mov    0x14(%eax),%eax
c000b7ac:	85 c0                	test   %eax,%eax
c000b7ae:	74 64                	je     c000b814 <dir_read+0x1be>
/work/x86_os_my/fs/dir.c:396
				/* 判断是不是最新的目录项,避免返回曾经已经返回过的目录项 */
				if (cur_dir_entry_pos < dir->dir_pos) {
c000b7b0:	8b 45 08             	mov    0x8(%ebp),%eax
c000b7b3:	8b 40 04             	mov    0x4(%eax),%eax
c000b7b6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c000b7b9:	76 0c                	jbe    c000b7c7 <dir_read+0x171>
/work/x86_os_my/fs/dir.c:397
					cur_dir_entry_pos += dir_entry_size;
c000b7bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000b7be:	01 45 e8             	add    %eax,-0x18(%ebp)
/work/x86_os_my/fs/dir.c:398
					dir_entry_idx++;
c000b7c1:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:399
					continue;
c000b7c5:	eb 51                	jmp    c000b818 <dir_read+0x1c2>
/work/x86_os_my/fs/dir.c:401
				}
				ASSERT(cur_dir_entry_pos == dir->dir_pos);
c000b7c7:	8b 45 08             	mov    0x8(%ebp),%eax
c000b7ca:	8b 40 04             	mov    0x4(%eax),%eax
c000b7cd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c000b7d0:	74 1c                	je     c000b7ee <dir_read+0x198>
/work/x86_os_my/fs/dir.c:401 (discriminator 1)
c000b7d2:	68 50 fb 00 c0       	push   $0xc000fb50
c000b7d7:	68 00 fc 00 c0       	push   $0xc000fc00
c000b7dc:	68 91 01 00 00       	push   $0x191
c000b7e1:	68 62 fa 00 c0       	push   $0xc000fa62
c000b7e6:	e8 76 6d ff ff       	call   c0002561 <panic_spin>
c000b7eb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:402
				dir->dir_pos += dir_entry_size;	      // 更新为新位置,即下一个返回的目录项地址
c000b7ee:	8b 45 08             	mov    0x8(%ebp),%eax
c000b7f1:	8b 50 04             	mov    0x4(%eax),%edx
c000b7f4:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000b7f7:	01 c2                	add    %eax,%edx
c000b7f9:	8b 45 08             	mov    0x8(%ebp),%eax
c000b7fc:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/dir.c:403
				return dir_e + dir_entry_idx;
c000b7ff:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000b802:	89 d0                	mov    %edx,%eax
c000b804:	01 c0                	add    %eax,%eax
c000b806:	01 d0                	add    %edx,%eax
c000b808:	c1 e0 03             	shl    $0x3,%eax
c000b80b:	89 c2                	mov    %eax,%edx
c000b80d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000b810:	01 d0                	add    %edx,%eax
c000b812:	eb 25                	jmp    c000b839 <dir_read+0x1e3>
/work/x86_os_my/fs/dir.c:405
			}
			dir_entry_idx++;
c000b814:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:393
		}
		memset(dir_e, 0, SECTOR_SIZE);
		ide_read(cur_part->my_disk, all_blocks[block_idx], dir_e, 1);
		dir_entry_idx = 0;
		/* 遍历扇区内所有目录项 */
		while (dir_entry_idx < dir_entrys_per_sec) {
c000b818:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000b81b:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c000b81e:	0f 82 72 ff ff ff    	jb     c000b796 <dir_read+0x140>
/work/x86_os_my/fs/dir.c:407
				dir->dir_pos += dir_entry_size;	      // 更新为新位置,即下一个返回的目录项地址
				return dir_e + dir_entry_idx;
			}
			dir_entry_idx++;
		}
		block_idx++;
c000b824:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:381

	uint32_t cur_dir_entry_pos = 0;	// 当前目录项的偏移,此项用来判断是否是之前已经返回过的目录项
	uint32_t dir_entry_size = cur_part->sb->dir_entry_size;
	uint32_t dir_entrys_per_sec = SECTOR_SIZE / dir_entry_size;	// 1扇区内可容纳的目录项个数
	/* 因为此目录内可能删除了某些文件或子目录,所以要遍历所有块 */
	while (block_idx < block_cnt) {
c000b828:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000b82b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c000b82e:	0f 82 ef fe ff ff    	jb     c000b723 <dir_read+0xcd>
/work/x86_os_my/fs/dir.c:409
			}
			dir_entry_idx++;
		}
		block_idx++;
	}
	return NULL;
c000b834:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/dir.c:410 (discriminator 1)
}
c000b839:	8b 7d fc             	mov    -0x4(%ebp),%edi
c000b83c:	c9                   	leave  
c000b83d:	c3                   	ret    

c000b83e <dir_is_empty>:
dir_is_empty():
/work/x86_os_my/fs/dir.c:413

/* 判断目录是否为空 */
bool dir_is_empty(struct dir* dir) {
c000b83e:	55                   	push   %ebp
c000b83f:	89 e5                	mov    %esp,%ebp
c000b841:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/fs/dir.c:414
	struct inode* dir_inode = dir->inode;
c000b844:	8b 45 08             	mov    0x8(%ebp),%eax
c000b847:	8b 00                	mov    (%eax),%eax
c000b849:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/fs/dir.c:416
	/* 若目录下只有.和..这两个目录项则目录为空 */
	return (dir_inode->i_size == cur_part->sb->dir_entry_size * 2);
c000b84c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000b84f:	8b 50 04             	mov    0x4(%eax),%edx
c000b852:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000b857:	8b 40 1c             	mov    0x1c(%eax),%eax
c000b85a:	8b 40 30             	mov    0x30(%eax),%eax
c000b85d:	01 c0                	add    %eax,%eax
c000b85f:	39 c2                	cmp    %eax,%edx
c000b861:	0f 94 c0             	sete   %al
c000b864:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/fs/dir.c:417
}
c000b867:	c9                   	leave  
c000b868:	c3                   	ret    

c000b869 <dir_remove>:
dir_remove():
/work/x86_os_my/fs/dir.c:420

/* 在父目录parent_dir中删除child_dir */
int32_t dir_remove(struct dir* parent_dir, struct dir* child_dir) {
c000b869:	55                   	push   %ebp
c000b86a:	89 e5                	mov    %esp,%ebp
c000b86c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/dir.c:421
	struct inode* child_dir_inode  = child_dir->inode;
c000b86f:	8b 45 0c             	mov    0xc(%ebp),%eax
c000b872:	8b 00                	mov    (%eax),%eax
c000b874:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:423
	/* 空目录只在inode->i_sectors[0]中有扇区,其它扇区都应该为空 */
	int32_t block_idx = 1;
c000b877:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:424
	while (block_idx < 13) {
c000b87e:	eb 30                	jmp    c000b8b0 <dir_remove+0x47>
/work/x86_os_my/fs/dir.c:425
		ASSERT(child_dir_inode->i_sectors[block_idx] == 0);
c000b880:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000b883:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000b886:	83 c2 04             	add    $0x4,%edx
c000b889:	8b 04 90             	mov    (%eax,%edx,4),%eax
c000b88c:	85 c0                	test   %eax,%eax
c000b88e:	74 1c                	je     c000b8ac <dir_remove+0x43>
/work/x86_os_my/fs/dir.c:425 (discriminator 1)
c000b890:	68 74 fb 00 c0       	push   $0xc000fb74
c000b895:	68 0c fc 00 c0       	push   $0xc000fc0c
c000b89a:	68 a9 01 00 00       	push   $0x1a9
c000b89f:	68 62 fa 00 c0       	push   $0xc000fa62
c000b8a4:	e8 b8 6c ff ff       	call   c0002561 <panic_spin>
c000b8a9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:426
		block_idx++;
c000b8ac:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:424
/* 在父目录parent_dir中删除child_dir */
int32_t dir_remove(struct dir* parent_dir, struct dir* child_dir) {
	struct inode* child_dir_inode  = child_dir->inode;
	/* 空目录只在inode->i_sectors[0]中有扇区,其它扇区都应该为空 */
	int32_t block_idx = 1;
	while (block_idx < 13) {
c000b8b0:	83 7d f4 0c          	cmpl   $0xc,-0xc(%ebp)
c000b8b4:	7e ca                	jle    c000b880 <dir_remove+0x17>
/work/x86_os_my/fs/dir.c:428
		ASSERT(child_dir_inode->i_sectors[block_idx] == 0);
		block_idx++;
	}
	void* io_buf = sys_malloc(SECTOR_SIZE * 2);
c000b8b6:	83 ec 0c             	sub    $0xc,%esp
c000b8b9:	68 00 04 00 00       	push   $0x400
c000b8be:	e8 49 76 ff ff       	call   c0002f0c <sys_malloc>
c000b8c3:	83 c4 10             	add    $0x10,%esp
c000b8c6:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:429
	if (io_buf == NULL) {
c000b8c9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c000b8cd:	75 17                	jne    c000b8e6 <dir_remove+0x7d>
/work/x86_os_my/fs/dir.c:430
		printk("dir_remove: malloc for io_buf failed\n");
c000b8cf:	83 ec 0c             	sub    $0xc,%esp
c000b8d2:	68 a0 fb 00 c0       	push   $0xc000fba0
c000b8d7:	e8 71 b7 ff ff       	call   c000704d <printk>
c000b8dc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:431
		return -1;
c000b8df:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000b8e4:	eb 44                	jmp    c000b92a <dir_remove+0xc1>
/work/x86_os_my/fs/dir.c:435
	}

	/* 在父目录parent_dir中删除子目录child_dir对应的"目录项" */
	delete_dir_entry(cur_part, parent_dir, child_dir_inode->i_no, io_buf);
c000b8e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000b8e9:	8b 10                	mov    (%eax),%edx
c000b8eb:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000b8f0:	ff 75 ec             	pushl  -0x14(%ebp)
c000b8f3:	52                   	push   %edx
c000b8f4:	ff 75 08             	pushl  0x8(%ebp)
c000b8f7:	50                   	push   %eax
c000b8f8:	e8 f1 f8 ff ff       	call   c000b1ee <delete_dir_entry>
c000b8fd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:438

	/* 回收inode中i_secotrs中所占用的扇区,并同步inode_bitmap和block_bitmap */
	inode_release(cur_part, child_dir_inode->i_no);
c000b900:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000b903:	8b 10                	mov    (%eax),%edx
c000b905:	a1 90 58 01 c0       	mov    0xc0015890,%eax
c000b90a:	83 ec 08             	sub    $0x8,%esp
c000b90d:	52                   	push   %edx
c000b90e:	50                   	push   %eax
c000b90f:	e8 06 de ff ff       	call   c000971a <inode_release>
c000b914:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:439
	sys_free(io_buf);
c000b917:	83 ec 0c             	sub    $0xc,%esp
c000b91a:	ff 75 ec             	pushl  -0x14(%ebp)
c000b91d:	e8 17 7c ff ff       	call   c0003539 <sys_free>
c000b922:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:440
	return 0;
c000b925:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/dir.c:441
}
c000b92a:	c9                   	leave  
c000b92b:	c3                   	ret    

c000b92c <copy_pcb_vaddrbitmap_stack0>:
copy_pcb_vaddrbitmap_stack0():
/work/x86_os_my/userprog/fork.c:14
#include "pipe.h"

extern void intr_exit(void);

/* 将父进程的pcb、虚拟地址位图拷贝给子进程 */
static int32_t copy_pcb_vaddrbitmap_stack0(struct task_struct* child_thread, struct task_struct* parent_thread) {
c000b92c:	55                   	push   %ebp
c000b92d:	89 e5                	mov    %esp,%ebp
c000b92f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/fork.c:18
	/* a 复制pcb所在的整个页,里面包含进程pcb信息 + 0特权级的栈
	栈里面包含了返回地址
	然后再单独修改个别部分 */
	memcpy(child_thread, parent_thread, PG_SIZE);
c000b932:	83 ec 04             	sub    $0x4,%esp
c000b935:	68 00 10 00 00       	push   $0x1000
c000b93a:	ff 75 0c             	pushl  0xc(%ebp)
c000b93d:	ff 75 08             	pushl  0x8(%ebp)
c000b940:	e8 72 81 ff ff       	call   c0003ab7 <memcpy>
c000b945:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:20
	// 初始化PCB部分
	child_thread->pid = fork_pid();
c000b948:	e8 2c 86 ff ff       	call   c0003f79 <fork_pid>
c000b94d:	89 c2                	mov    %eax,%edx
c000b94f:	8b 45 08             	mov    0x8(%ebp),%eax
c000b952:	66 89 50 04          	mov    %dx,0x4(%eax)
/work/x86_os_my/userprog/fork.c:21
	child_thread->elapsed_ticks = 0;
c000b956:	8b 45 08             	mov    0x8(%ebp),%eax
c000b959:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
/work/x86_os_my/userprog/fork.c:22
	child_thread->status = TASK_READY;
c000b960:	8b 45 08             	mov    0x8(%ebp),%eax
c000b963:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/userprog/fork.c:23
	child_thread->ticks = child_thread->priority;   // 为新进程把时间片充满
c000b96a:	8b 45 08             	mov    0x8(%ebp),%eax
c000b96d:	0f b6 50 1c          	movzbl 0x1c(%eax),%edx
c000b971:	8b 45 08             	mov    0x8(%ebp),%eax
c000b974:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/userprog/fork.c:24
	child_thread->parent_pid = parent_thread->pid;
c000b977:	8b 45 0c             	mov    0xc(%ebp),%eax
c000b97a:	0f b7 50 04          	movzwl 0x4(%eax),%edx
c000b97e:	8b 45 08             	mov    0x8(%ebp),%eax
c000b981:	66 89 90 10 01 00 00 	mov    %dx,0x110(%eax)
/work/x86_os_my/userprog/fork.c:25
	child_thread->general_tag.prev = child_thread->general_tag.next = NULL;
c000b988:	8b 45 08             	mov    0x8(%ebp),%eax
c000b98b:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
c000b992:	8b 45 08             	mov    0x8(%ebp),%eax
c000b995:	8b 50 48             	mov    0x48(%eax),%edx
c000b998:	8b 45 08             	mov    0x8(%ebp),%eax
c000b99b:	89 50 44             	mov    %edx,0x44(%eax)
/work/x86_os_my/userprog/fork.c:26
	child_thread->all_list_tag.prev = child_thread->all_list_tag.next = NULL;
c000b99e:	8b 45 08             	mov    0x8(%ebp),%eax
c000b9a1:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
c000b9a8:	8b 45 08             	mov    0x8(%ebp),%eax
c000b9ab:	8b 50 50             	mov    0x50(%eax),%edx
c000b9ae:	8b 45 08             	mov    0x8(%ebp),%eax
c000b9b1:	89 50 4c             	mov    %edx,0x4c(%eax)
/work/x86_os_my/userprog/fork.c:28
	// 子进程内存块（堆内存）
	block_desc_init(child_thread->u_block_desc);
c000b9b4:	8b 45 08             	mov    0x8(%ebp),%eax
c000b9b7:	83 c0 64             	add    $0x64,%eax
c000b9ba:	83 ec 0c             	sub    $0xc,%esp
c000b9bd:	50                   	push   %eax
c000b9be:	e8 5c 7f ff ff       	call   c000391f <block_desc_init>
c000b9c3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:30
	/* b 复制父进程的虚拟地址池的位图  可执行程序入口地址：USER_VADDR_START==0x8048000 */
	uint32_t bitmap_pg_cnt = DIV_ROUND_UP((0xc0000000 - USER_VADDR_START) / PG_SIZE / 8 , PG_SIZE);
c000b9c6:	c7 45 f4 17 00 00 00 	movl   $0x17,-0xc(%ebp)
/work/x86_os_my/userprog/fork.c:31
	void* vaddr_btmp = get_kernel_pages(bitmap_pg_cnt);
c000b9cd:	83 ec 0c             	sub    $0xc,%esp
c000b9d0:	ff 75 f4             	pushl  -0xc(%ebp)
c000b9d3:	e8 31 72 ff ff       	call   c0002c09 <get_kernel_pages>
c000b9d8:	83 c4 10             	add    $0x10,%esp
c000b9db:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:32
	if (vaddr_btmp == NULL)
c000b9de:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000b9e2:	75 07                	jne    c000b9eb <copy_pcb_vaddrbitmap_stack0+0xbf>
/work/x86_os_my/userprog/fork.c:33
		return -1;
c000b9e4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000b9e9:	eb 2c                	jmp    c000ba17 <copy_pcb_vaddrbitmap_stack0+0xeb>
/work/x86_os_my/userprog/fork.c:36
	/* 此时child_thread->userprog_vaddr.vaddr_bitmap.bits还是指向父进程虚拟地址的位图地址
	 * 下面将child_thread->userprog_vaddr.vaddr_bitmap.bits指向自己的位图vaddr_btmp */
	memcpy(vaddr_btmp, child_thread->userprog_vaddr.vaddr_bitmap.bits, bitmap_pg_cnt * PG_SIZE);	//复制父进程的虚拟地址位图
c000b9eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000b9ee:	c1 e0 0c             	shl    $0xc,%eax
c000b9f1:	89 c2                	mov    %eax,%edx
c000b9f3:	8b 45 08             	mov    0x8(%ebp),%eax
c000b9f6:	8b 40 5c             	mov    0x5c(%eax),%eax
c000b9f9:	83 ec 04             	sub    $0x4,%esp
c000b9fc:	52                   	push   %edx
c000b9fd:	50                   	push   %eax
c000b9fe:	ff 75 f0             	pushl  -0x10(%ebp)
c000ba01:	e8 b1 80 ff ff       	call   c0003ab7 <memcpy>
c000ba06:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:37
	child_thread->userprog_vaddr.vaddr_bitmap.bits = vaddr_btmp;	//指向子进程自己的了
c000ba09:	8b 45 08             	mov    0x8(%ebp),%eax
c000ba0c:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000ba0f:	89 50 5c             	mov    %edx,0x5c(%eax)
/work/x86_os_my/userprog/fork.c:41
	/* 调试用 */
//	ASSERT(strlen(child_thread->name) < 11);	// pcb.name的长度是16,为避免下面strcat越界
//	strcat(child_thread->name,"_fork");
	return 0;
c000ba12:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/userprog/fork.c:42
}
c000ba17:	c9                   	leave  
c000ba18:	c3                   	ret    

c000ba19 <copy_body_stack3>:
copy_body_stack3():
/work/x86_os_my/userprog/fork.c:75
+----------------------+
|          text        |
+----------------------+ 0
    C程序内存布局
*/
static void copy_body_stack3(struct task_struct* child_thread, struct task_struct* parent_thread, void* buf_page) {
c000ba19:	55                   	push   %ebp
c000ba1a:	89 e5                	mov    %esp,%ebp
c000ba1c:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/userprog/fork.c:76
	uint8_t* vaddr_btmp = parent_thread->userprog_vaddr.vaddr_bitmap.bits;
c000ba1f:	8b 45 0c             	mov    0xc(%ebp),%eax
c000ba22:	8b 40 5c             	mov    0x5c(%eax),%eax
c000ba25:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/userprog/fork.c:77
	uint32_t btmp_bytes_len = parent_thread->userprog_vaddr.vaddr_bitmap.btmp_bytes_len;
c000ba28:	8b 45 0c             	mov    0xc(%ebp),%eax
c000ba2b:	8b 40 58             	mov    0x58(%eax),%eax
c000ba2e:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/userprog/fork.c:78
	uint32_t vaddr_start = parent_thread->userprog_vaddr.vaddr_start;
c000ba31:	8b 45 0c             	mov    0xc(%ebp),%eax
c000ba34:	8b 40 60             	mov    0x60(%eax),%eax
c000ba37:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/userprog/fork.c:79
	uint32_t idx_byte = 0;
c000ba3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/userprog/fork.c:80
	uint32_t idx_bit = 0;
c000ba41:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:81
	uint32_t prog_vaddr = 0;
c000ba48:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
/work/x86_os_my/userprog/fork.c:84

	/* 在父进程的用户空间中查找已有数据的页，按页一一拷贝给子进程 */
	while (idx_byte < btmp_bytes_len) {
c000ba4f:	e9 c5 00 00 00       	jmp    c000bb19 <copy_body_stack3+0x100>
/work/x86_os_my/userprog/fork.c:85
		if (vaddr_btmp[idx_byte]) {
c000ba54:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000ba57:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000ba5a:	01 d0                	add    %edx,%eax
c000ba5c:	0f b6 00             	movzbl (%eax),%eax
c000ba5f:	84 c0                	test   %al,%al
c000ba61:	0f 84 ae 00 00 00    	je     c000bb15 <copy_body_stack3+0xfc>
/work/x86_os_my/userprog/fork.c:86
			idx_bit = 0;
c000ba67:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:87
			while (idx_bit < 8) {
c000ba6e:	e9 98 00 00 00       	jmp    c000bb0b <copy_body_stack3+0xf2>
/work/x86_os_my/userprog/fork.c:88
				if ((BITMAP_MASK << idx_bit) & vaddr_btmp[idx_byte]) {	//BITMAP_MASK=1
c000ba73:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000ba76:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000ba79:	01 d0                	add    %edx,%eax
c000ba7b:	0f b6 00             	movzbl (%eax),%eax
c000ba7e:	0f b6 d0             	movzbl %al,%edx
c000ba81:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000ba84:	89 c1                	mov    %eax,%ecx
c000ba86:	d3 fa                	sar    %cl,%edx
c000ba88:	89 d0                	mov    %edx,%eax
c000ba8a:	83 e0 01             	and    $0x1,%eax
c000ba8d:	85 c0                	test   %eax,%eax
c000ba8f:	74 76                	je     c000bb07 <copy_body_stack3+0xee>
/work/x86_os_my/userprog/fork.c:89
					prog_vaddr = (idx_byte * 8 + idx_bit) * PG_SIZE + vaddr_start;
c000ba91:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000ba94:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c000ba9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000ba9e:	01 d0                	add    %edx,%eax
c000baa0:	c1 e0 0c             	shl    $0xc,%eax
c000baa3:	89 c2                	mov    %eax,%edx
c000baa5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000baa8:	01 d0                	add    %edx,%eax
c000baaa:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/userprog/fork.c:94
					/* 下面的操作是将父进程用户空间中的数据通过内核空间做中转,最终复制到子进程的用户空间 */

					/* a 将父进程在用户空间中的数据复制到"内核缓冲区buf_page"
					目的：下面切换到子进程的页表后,还能访问到父进程的数据*/
					memcpy(buf_page, (void*)prog_vaddr, PG_SIZE);
c000baad:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000bab0:	83 ec 04             	sub    $0x4,%esp
c000bab3:	68 00 10 00 00       	push   $0x1000
c000bab8:	50                   	push   %eax
c000bab9:	ff 75 10             	pushl  0x10(%ebp)
c000babc:	e8 f6 7f ff ff       	call   c0003ab7 <memcpy>
c000bac1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:97

					/* b 将页表切换到子进程，下面申请内存的函数，将pte及pde安装在子进程的页表中 */
					page_dir_activate(child_thread);
c000bac4:	83 ec 0c             	sub    $0xc,%esp
c000bac7:	ff 75 08             	pushl  0x8(%ebp)
c000baca:	e8 4d 9e ff ff       	call   c000591c <page_dir_activate>
c000bacf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:99
					/* c 申请虚拟地址prog_vaddr */
					get_a_page_without_opvaddrbitmap(PF_USER, prog_vaddr);	//位图已经拷贝过了，当然不用再操作了...
c000bad2:	83 ec 08             	sub    $0x8,%esp
c000bad5:	ff 75 e0             	pushl  -0x20(%ebp)
c000bad8:	6a 02                	push   $0x2
c000bada:	e8 50 73 ff ff       	call   c0002e2f <get_a_page_without_opvaddrbitmap>
c000badf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:102

					/* d 从内核缓冲区中将父进程数据复制到子进程的用户空间 */
					memcpy((void*)prog_vaddr, buf_page, PG_SIZE);
c000bae2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000bae5:	83 ec 04             	sub    $0x4,%esp
c000bae8:	68 00 10 00 00       	push   $0x1000
c000baed:	ff 75 10             	pushl  0x10(%ebp)
c000baf0:	50                   	push   %eax
c000baf1:	e8 c1 7f ff ff       	call   c0003ab7 <memcpy>
c000baf6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:105

					/* e 恢复父进程页表 */
					page_dir_activate(parent_thread);
c000baf9:	83 ec 0c             	sub    $0xc,%esp
c000bafc:	ff 75 0c             	pushl  0xc(%ebp)
c000baff:	e8 18 9e ff ff       	call   c000591c <page_dir_activate>
c000bb04:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:107
				}
				idx_bit++;
c000bb07:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:87

	/* 在父进程的用户空间中查找已有数据的页，按页一一拷贝给子进程 */
	while (idx_byte < btmp_bytes_len) {
		if (vaddr_btmp[idx_byte]) {
			idx_bit = 0;
			while (idx_bit < 8) {
c000bb0b:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
c000bb0f:	0f 86 5e ff ff ff    	jbe    c000ba73 <copy_body_stack3+0x5a>
/work/x86_os_my/userprog/fork.c:110
					page_dir_activate(parent_thread);
				}
				idx_bit++;
			}
		}
		idx_byte++;
c000bb15:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/userprog/fork.c:84
	uint32_t idx_byte = 0;
	uint32_t idx_bit = 0;
	uint32_t prog_vaddr = 0;

	/* 在父进程的用户空间中查找已有数据的页，按页一一拷贝给子进程 */
	while (idx_byte < btmp_bytes_len) {
c000bb19:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000bb1c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c000bb1f:	0f 82 2f ff ff ff    	jb     c000ba54 <copy_body_stack3+0x3b>
/work/x86_os_my/userprog/fork.c:112
				idx_bit++;
			}
		}
		idx_byte++;
	}
}
c000bb25:	90                   	nop
c000bb26:	c9                   	leave  
c000bb27:	c3                   	ret    

c000bb28 <build_child_stack>:
build_child_stack():
/work/x86_os_my/userprog/fork.c:175
为了让子进程也能继续 fork 之后的代码运行，必须让它同父进程一样，从中断退出，也就是要经过 intr_exit。

子进程是由调度器 schedule 调度执行的，它要用到 switch_to 函数，
而 switch_to 函数要从栈 thread_stack 中恢复上下文，因此我们要想办法构建出合适的 thread_stack
*/
static int32_t build_child_stack(struct task_struct* child_thread) {
c000bb28:	55                   	push   %ebp
c000bb29:	89 e5                	mov    %esp,%ebp
c000bb2b:	83 ec 20             	sub    $0x20,%esp
/work/x86_os_my/userprog/fork.c:178
	/* a 使子进程pid返回值为0 */
	/* 获取子进程0级栈栈顶 */
	struct intr_stack* intr_0_stack = (struct intr_stack*)((uint32_t)child_thread + PG_SIZE - sizeof(struct intr_stack));
c000bb2e:	8b 45 08             	mov    0x8(%ebp),%eax
c000bb31:	05 b4 0f 00 00       	add    $0xfb4,%eax
c000bb36:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/userprog/fork.c:180
	/* 修改子进程的返回值为0 */
	intr_0_stack->eax = 0;	//根据 abi 约定，eax 寄存器中是函数返回值!!!
c000bb39:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000bb3c:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
/work/x86_os_my/userprog/fork.c:183

	/* b 为 switch_to 构建线程栈 struct thread_stack,将其构建在紧临intr_stack之下的空间*/
	uint32_t* ret_addr_in_thread_stack  = (uint32_t*)intr_0_stack - 1;	// 任务切换后新任务的返回地址 eip
c000bb43:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000bb46:	83 e8 04             	sub    $0x4,%eax
c000bb49:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/userprog/fork.c:186

	/***   这三行不是必要的,只是为了梳理 thread_stack 中的关系 ***/
	uint32_t* esi_ptr_in_thread_stack = (uint32_t*)intr_0_stack - 2;
c000bb4c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000bb4f:	83 e8 08             	sub    $0x8,%eax
c000bb52:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/fork.c:187
	uint32_t* edi_ptr_in_thread_stack = (uint32_t*)intr_0_stack - 3;
c000bb55:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000bb58:	83 e8 0c             	sub    $0xc,%eax
c000bb5b:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:188
	uint32_t* ebx_ptr_in_thread_stack = (uint32_t*)intr_0_stack - 4;
c000bb5e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000bb61:	83 e8 10             	sub    $0x10,%eax
c000bb64:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/userprog/fork.c:195

	/* ebp 在 thread_stack 中的地址便是当时的esp(0级栈的栈顶)，即栈顶esp = (uint32_t*)intr_0_stack - 5 */
	/* 指针 ebp_ptr_in_thread_stack，它是 thread_stack 的栈顶，
	 * 必须把它的值存放在 pcb 中偏移为 0 的地方，即 task_struct 中的 self_kstack 处，
	 * 将来 switch_to 要用它作为栈顶，并且执行一系列的 pop 来恢复上下文。 */
	uint32_t* ebp_ptr_in_thread_stack = (uint32_t*)intr_0_stack - 5;
c000bb67:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000bb6a:	83 e8 14             	sub    $0x14,%eax
c000bb6d:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/userprog/fork.c:198

	/* switch_to的返回地址更新为intr_exit，直接从中断返回 */
	*ret_addr_in_thread_stack = (uint32_t)intr_exit;	// kernel.S
c000bb70:	ba 50 1e 00 c0       	mov    $0xc0001e50,%edx
c000bb75:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000bb78:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/fork.c:202

	/* 下面这个赋值只是为了使构建的 thread_stack 更加清晰,其实也不需要,
	 * 因为在进入intr_exit后一系列的pop会把寄存器中的数据覆盖 */
	*ebp_ptr_in_thread_stack = *ebx_ptr_in_thread_stack = *edi_ptr_in_thread_stack = *esi_ptr_in_thread_stack = 0;
c000bb7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000bb7d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c000bb83:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000bb86:	8b 10                	mov    (%eax),%edx
c000bb88:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000bb8b:	89 10                	mov    %edx,(%eax)
c000bb8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000bb90:	8b 10                	mov    (%eax),%edx
c000bb92:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000bb95:	89 10                	mov    %edx,(%eax)
c000bb97:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000bb9a:	8b 10                	mov    (%eax),%edx
c000bb9c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000bb9f:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/fork.c:206
	/*********************************************************/

	/* 把构建的 thread_stack 的栈顶做为 switch_to 恢复数据时的栈顶 */
	child_thread->self_kstack = ebp_ptr_in_thread_stack;	//线程内核栈栈顶 self_kstack 总是和 esp 来回赋值~
c000bba1:	8b 45 08             	mov    0x8(%ebp),%eax
c000bba4:	8b 55 e8             	mov    -0x18(%ebp),%edx
c000bba7:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/fork.c:213
	在被换下处理器前，我们会把线程的上下文信息保存在 0 特权级栈中，
	self_kstack 便用来记录 0 特权级栈在保存线程上下文后，新的栈顶，
	在下一次此线程又被调度到处理器上时，
	把 self_kstack 的值加载到 esp 寄存器，这样便从 0 特权级栈中获取了线程上下文，从而可以加载到处理器中运行。
	*/
	return 0;
c000bba9:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/userprog/fork.c:214
}
c000bbae:	c9                   	leave  
c000bbaf:	c3                   	ret    

c000bbb0 <update_inode_open_cnts>:
update_inode_open_cnts():
/work/x86_os_my/userprog/fork.c:217

/* 更新inode打开数 */
static void update_inode_open_cnts(struct task_struct* thread) {
c000bbb0:	55                   	push   %ebp
c000bbb1:	89 e5                	mov    %esp,%ebp
c000bbb3:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/fork.c:218
	int32_t local_fd = 3, global_fd = 0;
c000bbb6:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
c000bbbd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:219
	while (local_fd < MAX_FILES_OPEN_PER_PROC) {
c000bbc4:	e9 96 00 00 00       	jmp    c000bc5f <update_inode_open_cnts+0xaf>
/work/x86_os_my/userprog/fork.c:220
		global_fd = thread->fd_table[local_fd];
c000bbc9:	8b 45 08             	mov    0x8(%ebp),%eax
c000bbcc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000bbcf:	83 c2 08             	add    $0x8,%edx
c000bbd2:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
c000bbd6:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:221
		ASSERT(global_fd < MAX_FILE_OPEN);
c000bbd9:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
c000bbdd:	7e 1c                	jle    c000bbfb <update_inode_open_cnts+0x4b>
/work/x86_os_my/userprog/fork.c:221 (discriminator 1)
c000bbdf:	68 18 fc 00 c0       	push   $0xc000fc18
c000bbe4:	68 fc fc 00 c0       	push   $0xc000fcfc
c000bbe9:	68 dd 00 00 00       	push   $0xdd
c000bbee:	68 32 fc 00 c0       	push   $0xc000fc32
c000bbf3:	e8 69 69 ff ff       	call   c0002561 <panic_spin>
c000bbf8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:222
		if (global_fd != -1) {
c000bbfb:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c000bbff:	74 5a                	je     c000bc5b <update_inode_open_cnts+0xab>
/work/x86_os_my/userprog/fork.c:223
			if (is_pipe(local_fd)) {
c000bc01:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000bc04:	83 ec 0c             	sub    $0xc,%esp
c000bc07:	50                   	push   %eax
c000bc08:	e8 0c 1a 00 00       	call   c000d619 <is_pipe>
c000bc0d:	83 c4 10             	add    $0x10,%esp
c000bc10:	85 c0                	test   %eax,%eax
c000bc12:	74 2b                	je     c000bc3f <update_inode_open_cnts+0x8f>
/work/x86_os_my/userprog/fork.c:224
				file_table[global_fd].fd_pos++;
c000bc14:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000bc17:	89 d0                	mov    %edx,%eax
c000bc19:	01 c0                	add    %eax,%eax
c000bc1b:	01 d0                	add    %edx,%eax
c000bc1d:	c1 e0 02             	shl    $0x2,%eax
c000bc20:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c000bc25:	8b 00                	mov    (%eax),%eax
c000bc27:	8d 48 01             	lea    0x1(%eax),%ecx
c000bc2a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000bc2d:	89 d0                	mov    %edx,%eax
c000bc2f:	01 c0                	add    %eax,%eax
c000bc31:	01 d0                	add    %edx,%eax
c000bc33:	c1 e0 02             	shl    $0x2,%eax
c000bc36:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c000bc3b:	89 08                	mov    %ecx,(%eax)
c000bc3d:	eb 1c                	jmp    c000bc5b <update_inode_open_cnts+0xab>
/work/x86_os_my/userprog/fork.c:226
			} else {
				file_table[global_fd].fd_inode->i_open_cnts++;
c000bc3f:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000bc42:	89 d0                	mov    %edx,%eax
c000bc44:	01 c0                	add    %eax,%eax
c000bc46:	01 d0                	add    %edx,%eax
c000bc48:	c1 e0 02             	shl    $0x2,%eax
c000bc4b:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c000bc50:	8b 00                	mov    (%eax),%eax
c000bc52:	8b 50 08             	mov    0x8(%eax),%edx
c000bc55:	83 c2 01             	add    $0x1,%edx
c000bc58:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/userprog/fork.c:229
			}
		}
		local_fd++;
c000bc5b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/userprog/fork.c:219
}

/* 更新inode打开数 */
static void update_inode_open_cnts(struct task_struct* thread) {
	int32_t local_fd = 3, global_fd = 0;
	while (local_fd < MAX_FILES_OPEN_PER_PROC) {
c000bc5f:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
c000bc63:	0f 8e 60 ff ff ff    	jle    c000bbc9 <update_inode_open_cnts+0x19>
/work/x86_os_my/userprog/fork.c:231
				file_table[global_fd].fd_inode->i_open_cnts++;
			}
		}
		local_fd++;
	}
}
c000bc69:	90                   	nop
c000bc6a:	c9                   	leave  
c000bc6b:	c3                   	ret    

c000bc6c <copy_process>:
copy_process():
/work/x86_os_my/userprog/fork.c:234

/* 拷贝父进程本身所占资源给子进程 */
static int32_t copy_process(struct task_struct* child_thread, struct task_struct* parent_thread) {
c000bc6c:	55                   	push   %ebp
c000bc6d:	89 e5                	mov    %esp,%ebp
c000bc6f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/fork.c:236
	/* 内核缓冲区,作为父进程用户空间的数据，复制到子进程用户空间，的中转 */
	void* buf_page = get_kernel_pages(1);
c000bc72:	83 ec 0c             	sub    $0xc,%esp
c000bc75:	6a 01                	push   $0x1
c000bc77:	e8 8d 6f ff ff       	call   c0002c09 <get_kernel_pages>
c000bc7c:	83 c4 10             	add    $0x10,%esp
c000bc7f:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/fork.c:237
	if (buf_page == NULL) {
c000bc82:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000bc86:	75 0a                	jne    c000bc92 <copy_process+0x26>
/work/x86_os_my/userprog/fork.c:238
		return -1;
c000bc88:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000bc8d:	e9 82 00 00 00       	jmp    c000bd14 <copy_process+0xa8>
/work/x86_os_my/userprog/fork.c:242
	}

	/* a 复制父进程的pcb、虚拟地址位图、内核栈到子进程 */
	if (copy_pcb_vaddrbitmap_stack0(child_thread, parent_thread) == -1) {
c000bc92:	83 ec 08             	sub    $0x8,%esp
c000bc95:	ff 75 0c             	pushl  0xc(%ebp)
c000bc98:	ff 75 08             	pushl  0x8(%ebp)
c000bc9b:	e8 8c fc ff ff       	call   c000b92c <copy_pcb_vaddrbitmap_stack0>
c000bca0:	83 c4 10             	add    $0x10,%esp
c000bca3:	83 f8 ff             	cmp    $0xffffffff,%eax
c000bca6:	75 07                	jne    c000bcaf <copy_process+0x43>
/work/x86_os_my/userprog/fork.c:243
		return -1;
c000bca8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000bcad:	eb 65                	jmp    c000bd14 <copy_process+0xa8>
/work/x86_os_my/userprog/fork.c:247
	}

	/* b 为子进程创建页表,此页表仅包括内核空间 */
	child_thread->pgdir = create_page_dir();
c000bcaf:	e8 eb 9c ff ff       	call   c000599f <create_page_dir>
c000bcb4:	89 c2                	mov    %eax,%edx
c000bcb6:	8b 45 08             	mov    0x8(%ebp),%eax
c000bcb9:	89 50 54             	mov    %edx,0x54(%eax)
/work/x86_os_my/userprog/fork.c:248
	if(child_thread->pgdir == NULL) {
c000bcbc:	8b 45 08             	mov    0x8(%ebp),%eax
c000bcbf:	8b 40 54             	mov    0x54(%eax),%eax
c000bcc2:	85 c0                	test   %eax,%eax
c000bcc4:	75 07                	jne    c000bccd <copy_process+0x61>
/work/x86_os_my/userprog/fork.c:249
		return -1;
c000bcc6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000bccb:	eb 47                	jmp    c000bd14 <copy_process+0xa8>
/work/x86_os_my/userprog/fork.c:253
	}

	/* c 复制父进程进程体及用户栈给子进程 */
	copy_body_stack3(child_thread, parent_thread, buf_page);
c000bccd:	83 ec 04             	sub    $0x4,%esp
c000bcd0:	ff 75 f4             	pushl  -0xc(%ebp)
c000bcd3:	ff 75 0c             	pushl  0xc(%ebp)
c000bcd6:	ff 75 08             	pushl  0x8(%ebp)
c000bcd9:	e8 3b fd ff ff       	call   c000ba19 <copy_body_stack3>
c000bcde:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:256

	/* d 构建子进程 thread_stack 和修改返回值pid */
	build_child_stack(child_thread);
c000bce1:	83 ec 0c             	sub    $0xc,%esp
c000bce4:	ff 75 08             	pushl  0x8(%ebp)
c000bce7:	e8 3c fe ff ff       	call   c000bb28 <build_child_stack>
c000bcec:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:259

	/* e 更新文件inode的打开数 */
	update_inode_open_cnts(child_thread);
c000bcef:	83 ec 0c             	sub    $0xc,%esp
c000bcf2:	ff 75 08             	pushl  0x8(%ebp)
c000bcf5:	e8 b6 fe ff ff       	call   c000bbb0 <update_inode_open_cnts>
c000bcfa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:261

	mfree_page(PF_KERNEL, buf_page, 1);
c000bcfd:	83 ec 04             	sub    $0x4,%esp
c000bd00:	6a 01                	push   $0x1
c000bd02:	ff 75 f4             	pushl  -0xc(%ebp)
c000bd05:	6a 01                	push   $0x1
c000bd07:	e8 6c 76 ff ff       	call   c0003378 <mfree_page>
c000bd0c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:262
	return 0;
c000bd0f:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/userprog/fork.c:263
}
c000bd14:	c9                   	leave  
c000bd15:	c3                   	ret    

c000bd16 <sys_fork>:
sys_fork():
/work/x86_os_my/userprog/fork.c:266

/* fork子进程，内核线程不可直接调用 */
pid_t sys_fork(void) {
c000bd16:	55                   	push   %ebp
c000bd17:	89 e5                	mov    %esp,%ebp
c000bd19:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/fork.c:267
	struct task_struct* parent_thread = running_thread();
c000bd1c:	e8 2b 81 ff ff       	call   c0003e4c <running_thread>
c000bd21:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/fork.c:268
	struct task_struct* child_thread = get_kernel_pages(1);	// 为子进程创建pcb(task_struct结构)
c000bd24:	83 ec 0c             	sub    $0xc,%esp
c000bd27:	6a 01                	push   $0x1
c000bd29:	e8 db 6e ff ff       	call   c0002c09 <get_kernel_pages>
c000bd2e:	83 c4 10             	add    $0x10,%esp
c000bd31:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:269
	if (child_thread == NULL) {
c000bd34:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000bd38:	75 0a                	jne    c000bd44 <sys_fork+0x2e>
/work/x86_os_my/userprog/fork.c:270
		return -1;
c000bd3a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000bd3f:	e9 f2 00 00 00       	jmp    c000be36 <sys_fork+0x120>
/work/x86_os_my/userprog/fork.c:272
	}
	ASSERT(INTR_OFF == intr_get_status() && parent_thread->pgdir != NULL);	//中断关了，并且是用户线程
c000bd44:	e8 83 5e ff ff       	call   c0001bcc <intr_get_status>
c000bd49:	85 c0                	test   %eax,%eax
c000bd4b:	75 0a                	jne    c000bd57 <sys_fork+0x41>
/work/x86_os_my/userprog/fork.c:272 (discriminator 1)
c000bd4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000bd50:	8b 40 54             	mov    0x54(%eax),%eax
c000bd53:	85 c0                	test   %eax,%eax
c000bd55:	75 1c                	jne    c000bd73 <sys_fork+0x5d>
/work/x86_os_my/userprog/fork.c:272 (discriminator 3)
c000bd57:	68 44 fc 00 c0       	push   $0xc000fc44
c000bd5c:	68 14 fd 00 c0       	push   $0xc000fd14
c000bd61:	68 10 01 00 00       	push   $0x110
c000bd66:	68 32 fc 00 c0       	push   $0xc000fc32
c000bd6b:	e8 f1 67 ff ff       	call   c0002561 <panic_spin>
c000bd70:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:274

	if (copy_process(child_thread, parent_thread) == -1) {
c000bd73:	83 ec 08             	sub    $0x8,%esp
c000bd76:	ff 75 f4             	pushl  -0xc(%ebp)
c000bd79:	ff 75 f0             	pushl  -0x10(%ebp)
c000bd7c:	e8 eb fe ff ff       	call   c000bc6c <copy_process>
c000bd81:	83 c4 10             	add    $0x10,%esp
c000bd84:	83 f8 ff             	cmp    $0xffffffff,%eax
c000bd87:	75 0a                	jne    c000bd93 <sys_fork+0x7d>
/work/x86_os_my/userprog/fork.c:275
		return -1;
c000bd89:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000bd8e:	e9 a3 00 00 00       	jmp    c000be36 <sys_fork+0x120>
/work/x86_os_my/userprog/fork.c:279
	}

	/* 添加到就绪线程队列和所有线程队列，子进程由调度器安排运行 */
	ASSERT(!elem_find(&thread_ready_list, &child_thread->general_tag));
c000bd93:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000bd96:	83 c0 44             	add    $0x44,%eax
c000bd99:	83 ec 08             	sub    $0x8,%esp
c000bd9c:	50                   	push   %eax
c000bd9d:	68 a8 42 01 c0       	push   $0xc00142a8
c000bda2:	e8 9d 8d ff ff       	call   c0004b44 <elem_find>
c000bda7:	83 c4 10             	add    $0x10,%esp
c000bdaa:	85 c0                	test   %eax,%eax
c000bdac:	74 1c                	je     c000bdca <sys_fork+0xb4>
/work/x86_os_my/userprog/fork.c:279 (discriminator 1)
c000bdae:	68 84 fc 00 c0       	push   $0xc000fc84
c000bdb3:	68 14 fd 00 c0       	push   $0xc000fd14
c000bdb8:	68 17 01 00 00       	push   $0x117
c000bdbd:	68 32 fc 00 c0       	push   $0xc000fc32
c000bdc2:	e8 9a 67 ff ff       	call   c0002561 <panic_spin>
c000bdc7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:280
	list_append(&thread_ready_list, &child_thread->general_tag);
c000bdca:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000bdcd:	83 c0 44             	add    $0x44,%eax
c000bdd0:	83 ec 08             	sub    $0x8,%esp
c000bdd3:	50                   	push   %eax
c000bdd4:	68 a8 42 01 c0       	push   $0xc00142a8
c000bdd9:	e8 ec 8c ff ff       	call   c0004aca <list_append>
c000bdde:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:281
	ASSERT(!elem_find(&thread_all_list, &child_thread->all_list_tag));
c000bde1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000bde4:	83 c0 4c             	add    $0x4c,%eax
c000bde7:	83 ec 08             	sub    $0x8,%esp
c000bdea:	50                   	push   %eax
c000bdeb:	68 b8 42 01 c0       	push   $0xc00142b8
c000bdf0:	e8 4f 8d ff ff       	call   c0004b44 <elem_find>
c000bdf5:	83 c4 10             	add    $0x10,%esp
c000bdf8:	85 c0                	test   %eax,%eax
c000bdfa:	74 1c                	je     c000be18 <sys_fork+0x102>
/work/x86_os_my/userprog/fork.c:281 (discriminator 1)
c000bdfc:	68 c0 fc 00 c0       	push   $0xc000fcc0
c000be01:	68 14 fd 00 c0       	push   $0xc000fd14
c000be06:	68 19 01 00 00       	push   $0x119
c000be0b:	68 32 fc 00 c0       	push   $0xc000fc32
c000be10:	e8 4c 67 ff ff       	call   c0002561 <panic_spin>
c000be15:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:282
	list_append(&thread_all_list, &child_thread->all_list_tag);
c000be18:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000be1b:	83 c0 4c             	add    $0x4c,%eax
c000be1e:	83 ec 08             	sub    $0x8,%esp
c000be21:	50                   	push   %eax
c000be22:	68 b8 42 01 c0       	push   $0xc00142b8
c000be27:	e8 9e 8c ff ff       	call   c0004aca <list_append>
c000be2c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:284

	return child_thread->pid;	// 父进程返回子进程的pid
c000be2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000be32:	0f b7 40 04          	movzwl 0x4(%eax),%eax
/work/x86_os_my/userprog/fork.c:285
}
c000be36:	c9                   	leave  
c000be37:	c3                   	ret    

c000be38 <print_prompt>:
print_prompt():
/work/x86_os_my/shell/shell.c:22

/* 用来记录当前目录,是当前目录的缓存,每次执行cd命令时会更新此内容 */
char cwd_cache[MAX_PATH_LEN] = {0};

/* 输出提示符 */
void print_prompt(void) {
c000be38:	55                   	push   %ebp
c000be39:	89 e5                	mov    %esp,%ebp
c000be3b:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/shell/shell.c:23
	printf("[rabbit@localhost %s]$ ", cwd_cache);
c000be3e:	83 ec 08             	sub    $0x8,%esp
c000be41:	68 c0 38 01 c0       	push   $0xc00138c0
c000be46:	68 20 fd 00 c0       	push   $0xc000fd20
c000be4b:	e8 05 a4 ff ff       	call   c0006255 <printf>
c000be50:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:24
}
c000be53:	90                   	nop
c000be54:	c9                   	leave  
c000be55:	c3                   	ret    

c000be56 <readline>:
readline():
/work/x86_os_my/shell/shell.c:27

/* 从键盘缓冲区中最多读入count个字节到buf */
static void readline(char* buf, int32_t count) {
c000be56:	55                   	push   %ebp
c000be57:	89 e5                	mov    %esp,%ebp
c000be59:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/shell/shell.c:28
	assert(buf != NULL && count > 0);
c000be5c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000be60:	74 06                	je     c000be68 <readline+0x12>
/work/x86_os_my/shell/shell.c:28 (discriminator 2)
c000be62:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c000be66:	7f 19                	jg     c000be81 <readline+0x2b>
/work/x86_os_my/shell/shell.c:28 (discriminator 3)
c000be68:	68 38 fd 00 c0       	push   $0xc000fd38
c000be6d:	68 a0 fe 00 c0       	push   $0xc000fea0
c000be72:	6a 1c                	push   $0x1c
c000be74:	68 51 fd 00 c0       	push   $0xc000fd51
c000be79:	e8 24 07 00 00       	call   c000c5a2 <user_spin>
c000be7e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:29
	char* pos = buf;
c000be81:	8b 45 08             	mov    0x8(%ebp),%eax
c000be84:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/shell/shell.c:30
	while (read(stdin_no, pos, 1) != -1 && (pos - buf) < count) {	// 每次读1个字符。在不出错情况下,直到找到回车符才返回
c000be87:	e9 b5 00 00 00       	jmp    c000bf41 <readline+0xeb>
/work/x86_os_my/shell/shell.c:31
		switch (*pos) {
c000be8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000be8f:	0f b6 00             	movzbl (%eax),%eax
c000be92:	0f be c0             	movsbl %al,%eax
c000be95:	83 e8 08             	sub    $0x8,%eax
c000be98:	83 f8 0c             	cmp    $0xc,%eax
c000be9b:	0f 87 87 00 00 00    	ja     c000bf28 <readline+0xd2>
c000bea1:	8b 04 85 ac fd 00 c0 	mov    -0x3fff0254(,%eax,4),%eax
c000bea8:	ff e0                	jmp    *%eax
/work/x86_os_my/shell/shell.c:35
			/* 找到回车或换行符后认为键入的命令结束,直接返回 */
			case '\n':
			case '\r':
			*pos = 0;		// 添加cmd_line的终止字符0
c000beaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000bead:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/shell/shell.c:36
			putchar('\n');
c000beb0:	83 ec 0c             	sub    $0xc,%esp
c000beb3:	6a 0a                	push   $0xa
c000beb5:	e8 76 9d ff ff       	call   c0005c30 <putchar>
c000beba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:37
			return;
c000bebd:	e9 b9 00 00 00       	jmp    c000bf7b <readline+0x125>
/work/x86_os_my/shell/shell.c:40

			case '\b':
			if (cmd_line[0] != '\b') {	// 阻止删除非本次输入的信息
c000bec2:	0f b6 05 00 3b 01 c0 	movzbl 0xc0013b00,%eax
c000bec9:	3c 08                	cmp    $0x8,%al
c000becb:	74 74                	je     c000bf41 <readline+0xeb>
/work/x86_os_my/shell/shell.c:41
				--pos;				// 退回到缓冲区cmd_line中上一个字符
c000becd:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
/work/x86_os_my/shell/shell.c:42
				putchar('\b');		// 屏幕显示也删掉前一个字符
c000bed1:	83 ec 0c             	sub    $0xc,%esp
c000bed4:	6a 08                	push   $0x8
c000bed6:	e8 55 9d ff ff       	call   c0005c30 <putchar>
c000bedb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:44
			}
			break;
c000bede:	eb 61                	jmp    c000bf41 <readline+0xeb>
/work/x86_os_my/shell/shell.c:49

			/* ctrl+l 清屏 */
			case 'l' - 'a':
			/* 1 先将当前的字符'l'-'a'置为0 */
			*pos = 0;
c000bee0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000bee3:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/shell/shell.c:51
			/* 2 再将屏幕清空 */
			clear();
c000bee6:	e8 69 9d ff ff       	call   c0005c54 <clear>
/work/x86_os_my/shell/shell.c:53
			/* 3 打印提示符 */
			print_prompt();
c000beeb:	e8 48 ff ff ff       	call   c000be38 <print_prompt>
/work/x86_os_my/shell/shell.c:55
			/* 4 将之前键入的内容再次打印 */
			printf("%s", buf);
c000bef0:	83 ec 08             	sub    $0x8,%esp
c000bef3:	ff 75 08             	pushl  0x8(%ebp)
c000bef6:	68 5f fd 00 c0       	push   $0xc000fd5f
c000befb:	e8 55 a3 ff ff       	call   c0006255 <printf>
c000bf00:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:56
			break;
c000bf03:	eb 3c                	jmp    c000bf41 <readline+0xeb>
/work/x86_os_my/shell/shell.c:61

			/* ctrl+u 清掉输入 */
			case 'u' - 'a':
			while (buf != pos) {
				putchar('\b');
c000bf05:	83 ec 0c             	sub    $0xc,%esp
c000bf08:	6a 08                	push   $0x8
c000bf0a:	e8 21 9d ff ff       	call   c0005c30 <putchar>
c000bf0f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:62
				*(pos--) = 0;
c000bf12:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000bf15:	8d 50 ff             	lea    -0x1(%eax),%edx
c000bf18:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000bf1b:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/shell/shell.c:60
			printf("%s", buf);
			break;

			/* ctrl+u 清掉输入 */
			case 'u' - 'a':
			while (buf != pos) {
c000bf1e:	8b 45 08             	mov    0x8(%ebp),%eax
c000bf21:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c000bf24:	75 df                	jne    c000bf05 <readline+0xaf>
/work/x86_os_my/shell/shell.c:64
				putchar('\b');
				*(pos--) = 0;
			}
			break;
c000bf26:	eb 19                	jmp    c000bf41 <readline+0xeb>
/work/x86_os_my/shell/shell.c:68

			/* 非控制键则输出字符 */
			default:
			putchar(*pos);			// 屏幕显示
c000bf28:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000bf2b:	0f b6 00             	movzbl (%eax),%eax
c000bf2e:	0f be c0             	movsbl %al,%eax
c000bf31:	83 ec 0c             	sub    $0xc,%esp
c000bf34:	50                   	push   %eax
c000bf35:	e8 f6 9c ff ff       	call   c0005c30 <putchar>
c000bf3a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:69
			pos++;
c000bf3d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/shell/shell.c:30

/* 从键盘缓冲区中最多读入count个字节到buf */
static void readline(char* buf, int32_t count) {
	assert(buf != NULL && count > 0);
	char* pos = buf;
	while (read(stdin_no, pos, 1) != -1 && (pos - buf) < count) {	// 每次读1个字符。在不出错情况下,直到找到回车符才返回
c000bf41:	83 ec 04             	sub    $0x4,%esp
c000bf44:	6a 01                	push   $0x1
c000bf46:	ff 75 f4             	pushl  -0xc(%ebp)
c000bf49:	6a 00                	push   $0x0
c000bf4b:	e8 bd 9c ff ff       	call   c0005c0d <read>
c000bf50:	83 c4 10             	add    $0x10,%esp
c000bf53:	83 f8 ff             	cmp    $0xffffffff,%eax
c000bf56:	74 13                	je     c000bf6b <readline+0x115>
/work/x86_os_my/shell/shell.c:30 (discriminator 1)
c000bf58:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000bf5b:	8b 45 08             	mov    0x8(%ebp),%eax
c000bf5e:	29 c2                	sub    %eax,%edx
c000bf60:	89 d0                	mov    %edx,%eax
c000bf62:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000bf65:	0f 8c 21 ff ff ff    	jl     c000be8c <readline+0x36>
/work/x86_os_my/shell/shell.c:72
			default:
			putchar(*pos);			// 屏幕显示
			pos++;
		}
	}
	printf("readline: can`t find enter_key in the cmd_line, max num of char is 128\n");
c000bf6b:	83 ec 0c             	sub    $0xc,%esp
c000bf6e:	68 64 fd 00 c0       	push   $0xc000fd64
c000bf73:	e8 dd a2 ff ff       	call   c0006255 <printf>
c000bf78:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:73
}
c000bf7b:	c9                   	leave  
c000bf7c:	c3                   	ret    

c000bf7d <cmd_parse>:
cmd_parse():
/work/x86_os_my/shell/shell.c:76

/* 分析字符串cmd_str中以token为分隔符的单词,将各单词的指针存入argv数组 */
static int32_t cmd_parse(char* cmd_str, char** argv, char token) {
c000bf7d:	55                   	push   %ebp
c000bf7e:	89 e5                	mov    %esp,%ebp
c000bf80:	83 ec 28             	sub    $0x28,%esp
c000bf83:	8b 45 10             	mov    0x10(%ebp),%eax
c000bf86:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/shell/shell.c:77
	assert(cmd_str != NULL);
c000bf89:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000bf8d:	75 19                	jne    c000bfa8 <cmd_parse+0x2b>
/work/x86_os_my/shell/shell.c:77 (discriminator 1)
c000bf8f:	68 e0 fd 00 c0       	push   $0xc000fde0
c000bf94:	68 ac fe 00 c0       	push   $0xc000feac
c000bf99:	6a 4d                	push   $0x4d
c000bf9b:	68 51 fd 00 c0       	push   $0xc000fd51
c000bfa0:	e8 fd 05 00 00       	call   c000c5a2 <user_spin>
c000bfa5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:78
	int32_t arg_idx = 0;
c000bfa8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/shell/shell.c:79
	while(arg_idx < MAX_ARG_NR) {
c000bfaf:	eb 19                	jmp    c000bfca <cmd_parse+0x4d>
/work/x86_os_my/shell/shell.c:80
		argv[arg_idx] = NULL;
c000bfb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000bfb4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000bfbb:	8b 45 0c             	mov    0xc(%ebp),%eax
c000bfbe:	01 d0                	add    %edx,%eax
c000bfc0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/shell/shell.c:81
		arg_idx++;
c000bfc6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/shell/shell.c:79

/* 分析字符串cmd_str中以token为分隔符的单词,将各单词的指针存入argv数组 */
static int32_t cmd_parse(char* cmd_str, char** argv, char token) {
	assert(cmd_str != NULL);
	int32_t arg_idx = 0;
	while(arg_idx < MAX_ARG_NR) {
c000bfca:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
c000bfce:	7e e1                	jle    c000bfb1 <cmd_parse+0x34>
/work/x86_os_my/shell/shell.c:83
		argv[arg_idx] = NULL;
		arg_idx++;
	}
	char* next = cmd_str;
c000bfd0:	8b 45 08             	mov    0x8(%ebp),%eax
c000bfd3:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/shell/shell.c:84
	int32_t argc = 0;
c000bfd6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/shell/shell.c:86
	/* 外层循环处理整个命令行 */
	while(*next) {
c000bfdd:	eb 6f                	jmp    c000c04e <cmd_parse+0xd1>
/work/x86_os_my/shell/shell.c:89
		/* 去除命令字或参数之间的空格 */
		while(*next == token) {
			next++;
c000bfdf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/shell/shell.c:88
	char* next = cmd_str;
	int32_t argc = 0;
	/* 外层循环处理整个命令行 */
	while(*next) {
		/* 去除命令字或参数之间的空格 */
		while(*next == token) {
c000bfe3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000bfe6:	0f b6 00             	movzbl (%eax),%eax
c000bfe9:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c000bfec:	74 f1                	je     c000bfdf <cmd_parse+0x62>
/work/x86_os_my/shell/shell.c:92
			next++;
		}
		/* 处理最后一个参数后接空格的情况,如"ls dir2 " */
		if (*next == 0) {
c000bfee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000bff1:	0f b6 00             	movzbl (%eax),%eax
c000bff4:	84 c0                	test   %al,%al
c000bff6:	74 62                	je     c000c05a <cmd_parse+0xdd>
/work/x86_os_my/shell/shell.c:95
			break;
		}
		argv[argc] = next;
c000bff8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000bffb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000c002:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c005:	01 c2                	add    %eax,%edx
c000c007:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000c00a:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/shell/shell.c:98

		/* 内层循环处理命令行中的每个命令字及参数 */
		while (*next && *next != token) {	  // 在字符串结束前找单词分隔符
c000c00c:	eb 04                	jmp    c000c012 <cmd_parse+0x95>
/work/x86_os_my/shell/shell.c:99
			next++;
c000c00e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/shell/shell.c:98
			break;
		}
		argv[argc] = next;

		/* 内层循环处理命令行中的每个命令字及参数 */
		while (*next && *next != token) {	  // 在字符串结束前找单词分隔符
c000c012:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000c015:	0f b6 00             	movzbl (%eax),%eax
c000c018:	84 c0                	test   %al,%al
c000c01a:	74 0b                	je     c000c027 <cmd_parse+0xaa>
/work/x86_os_my/shell/shell.c:98 (discriminator 1)
c000c01c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000c01f:	0f b6 00             	movzbl (%eax),%eax
c000c022:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c000c025:	75 e7                	jne    c000c00e <cmd_parse+0x91>
/work/x86_os_my/shell/shell.c:103
			next++;
		}

		/* 如果未结束(是token字符),使tocken变成0 */
		if (*next) {
c000c027:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000c02a:	0f b6 00             	movzbl (%eax),%eax
c000c02d:	84 c0                	test   %al,%al
c000c02f:	74 0c                	je     c000c03d <cmd_parse+0xc0>
/work/x86_os_my/shell/shell.c:104
			*next++ = 0;	// 将token字符替换为字符串结束符0,做为一个单词的结束,并将字符指针next指向下一个字符
c000c031:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000c034:	8d 50 01             	lea    0x1(%eax),%edx
c000c037:	89 55 f0             	mov    %edx,-0x10(%ebp)
c000c03a:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/shell/shell.c:108
		}

		/* 避免argv数组访问越界,参数过多则返回0 */
		if (argc > MAX_ARG_NR) {
c000c03d:	83 7d ec 10          	cmpl   $0x10,-0x14(%ebp)
c000c041:	7e 07                	jle    c000c04a <cmd_parse+0xcd>
/work/x86_os_my/shell/shell.c:109
			return -1;
c000c043:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000c048:	eb 14                	jmp    c000c05e <cmd_parse+0xe1>
/work/x86_os_my/shell/shell.c:111
		}
		argc++;
c000c04a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
/work/x86_os_my/shell/shell.c:86
		arg_idx++;
	}
	char* next = cmd_str;
	int32_t argc = 0;
	/* 外层循环处理整个命令行 */
	while(*next) {
c000c04e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000c051:	0f b6 00             	movzbl (%eax),%eax
c000c054:	84 c0                	test   %al,%al
c000c056:	75 8b                	jne    c000bfe3 <cmd_parse+0x66>
c000c058:	eb 01                	jmp    c000c05b <cmd_parse+0xde>
/work/x86_os_my/shell/shell.c:93
		while(*next == token) {
			next++;
		}
		/* 处理最后一个参数后接空格的情况,如"ls dir2 " */
		if (*next == 0) {
			break;
c000c05a:	90                   	nop
/work/x86_os_my/shell/shell.c:113
		if (argc > MAX_ARG_NR) {
			return -1;
		}
		argc++;
	}
	return argc;
c000c05b:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/shell/shell.c:114
}
c000c05e:	c9                   	leave  
c000c05f:	c3                   	ret    

c000c060 <cmd_execute>:
cmd_execute():
/work/x86_os_my/shell/shell.c:117

/* 执行命令 */
static void cmd_execute(uint32_t argc, char** argv) {
c000c060:	55                   	push   %ebp
c000c061:	89 e5                	mov    %esp,%ebp
c000c063:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/shell/shell.c:118
	if (!strcmp("ls", argv[0])) {
c000c066:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c069:	8b 00                	mov    (%eax),%eax
c000c06b:	83 ec 08             	sub    $0x8,%esp
c000c06e:	50                   	push   %eax
c000c06f:	68 f0 fd 00 c0       	push   $0xc000fdf0
c000c074:	e8 c1 7b ff ff       	call   c0003c3a <strcmp>
c000c079:	83 c4 10             	add    $0x10,%esp
c000c07c:	84 c0                	test   %al,%al
c000c07e:	75 16                	jne    c000c096 <cmd_execute+0x36>
/work/x86_os_my/shell/shell.c:119
		buildin_ls(argc, argv);
c000c080:	83 ec 08             	sub    $0x8,%esp
c000c083:	ff 75 0c             	pushl  0xc(%ebp)
c000c086:	ff 75 08             	pushl  0x8(%ebp)
c000c089:	e8 4b 08 00 00       	call   c000c8d9 <buildin_ls>
c000c08e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:163
			} else {
				execv(argv[0], argv);
			}
		}
	}
}
c000c091:	e9 99 02 00 00       	jmp    c000c32f <cmd_execute+0x2cf>
/work/x86_os_my/shell/shell.c:120

/* 执行命令 */
static void cmd_execute(uint32_t argc, char** argv) {
	if (!strcmp("ls", argv[0])) {
		buildin_ls(argc, argv);
	} else if (!strcmp("cd", argv[0])) {
c000c096:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c099:	8b 00                	mov    (%eax),%eax
c000c09b:	83 ec 08             	sub    $0x8,%esp
c000c09e:	50                   	push   %eax
c000c09f:	68 f3 fd 00 c0       	push   $0xc000fdf3
c000c0a4:	e8 91 7b ff ff       	call   c0003c3a <strcmp>
c000c0a9:	83 c4 10             	add    $0x10,%esp
c000c0ac:	84 c0                	test   %al,%al
c000c0ae:	75 4a                	jne    c000c0fa <cmd_execute+0x9a>
/work/x86_os_my/shell/shell.c:121
		if (buildin_cd(argc, argv) != NULL) {
c000c0b0:	83 ec 08             	sub    $0x8,%esp
c000c0b3:	ff 75 0c             	pushl  0xc(%ebp)
c000c0b6:	ff 75 08             	pushl  0x8(%ebp)
c000c0b9:	e8 91 07 00 00       	call   c000c84f <buildin_cd>
c000c0be:	83 c4 10             	add    $0x10,%esp
c000c0c1:	85 c0                	test   %eax,%eax
c000c0c3:	0f 84 66 02 00 00    	je     c000c32f <cmd_execute+0x2cf>
/work/x86_os_my/shell/shell.c:122
			memset(cwd_cache, 0, MAX_PATH_LEN);
c000c0c9:	83 ec 04             	sub    $0x4,%esp
c000c0cc:	68 00 02 00 00       	push   $0x200
c000c0d1:	6a 00                	push   $0x0
c000c0d3:	68 c0 38 01 c0       	push   $0xc00138c0
c000c0d8:	e8 88 79 ff ff       	call   c0003a65 <memset>
c000c0dd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:123
			strcpy(cwd_cache, final_path);
c000c0e0:	83 ec 08             	sub    $0x8,%esp
c000c0e3:	68 c0 36 01 c0       	push   $0xc00136c0
c000c0e8:	68 c0 38 01 c0       	push   $0xc00138c0
c000c0ed:	e8 a8 7a ff ff       	call   c0003b9a <strcpy>
c000c0f2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:163
			} else {
				execv(argv[0], argv);
			}
		}
	}
}
c000c0f5:	e9 35 02 00 00       	jmp    c000c32f <cmd_execute+0x2cf>
/work/x86_os_my/shell/shell.c:125
	} else if (!strcmp("cd", argv[0])) {
		if (buildin_cd(argc, argv) != NULL) {
			memset(cwd_cache, 0, MAX_PATH_LEN);
			strcpy(cwd_cache, final_path);
		}
	} else if (!strcmp("pwd", argv[0])) {
c000c0fa:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c0fd:	8b 00                	mov    (%eax),%eax
c000c0ff:	83 ec 08             	sub    $0x8,%esp
c000c102:	50                   	push   %eax
c000c103:	68 f6 fd 00 c0       	push   $0xc000fdf6
c000c108:	e8 2d 7b ff ff       	call   c0003c3a <strcmp>
c000c10d:	83 c4 10             	add    $0x10,%esp
c000c110:	84 c0                	test   %al,%al
c000c112:	75 16                	jne    c000c12a <cmd_execute+0xca>
/work/x86_os_my/shell/shell.c:126
		buildin_pwd(argc, argv);
c000c114:	83 ec 08             	sub    $0x8,%esp
c000c117:	ff 75 0c             	pushl  0xc(%ebp)
c000c11a:	ff 75 08             	pushl  0x8(%ebp)
c000c11d:	e8 cd 06 00 00       	call   c000c7ef <buildin_pwd>
c000c122:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:163
			} else {
				execv(argv[0], argv);
			}
		}
	}
}
c000c125:	e9 05 02 00 00       	jmp    c000c32f <cmd_execute+0x2cf>
/work/x86_os_my/shell/shell.c:127
			memset(cwd_cache, 0, MAX_PATH_LEN);
			strcpy(cwd_cache, final_path);
		}
	} else if (!strcmp("pwd", argv[0])) {
		buildin_pwd(argc, argv);
	} else if (!strcmp("ps", argv[0])) {
c000c12a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c12d:	8b 00                	mov    (%eax),%eax
c000c12f:	83 ec 08             	sub    $0x8,%esp
c000c132:	50                   	push   %eax
c000c133:	68 fa fd 00 c0       	push   $0xc000fdfa
c000c138:	e8 fd 7a ff ff       	call   c0003c3a <strcmp>
c000c13d:	83 c4 10             	add    $0x10,%esp
c000c140:	84 c0                	test   %al,%al
c000c142:	75 16                	jne    c000c15a <cmd_execute+0xfa>
/work/x86_os_my/shell/shell.c:128
		buildin_ps(argc, argv);
c000c144:	83 ec 08             	sub    $0x8,%esp
c000c147:	ff 75 0c             	pushl  0xc(%ebp)
c000c14a:	ff 75 08             	pushl  0x8(%ebp)
c000c14d:	e8 48 0b 00 00       	call   c000cc9a <buildin_ps>
c000c152:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:163
			} else {
				execv(argv[0], argv);
			}
		}
	}
}
c000c155:	e9 d5 01 00 00       	jmp    c000c32f <cmd_execute+0x2cf>
/work/x86_os_my/shell/shell.c:129
		}
	} else if (!strcmp("pwd", argv[0])) {
		buildin_pwd(argc, argv);
	} else if (!strcmp("ps", argv[0])) {
		buildin_ps(argc, argv);
	} else if (!strcmp("clear", argv[0])) {
c000c15a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c15d:	8b 00                	mov    (%eax),%eax
c000c15f:	83 ec 08             	sub    $0x8,%esp
c000c162:	50                   	push   %eax
c000c163:	68 fd fd 00 c0       	push   $0xc000fdfd
c000c168:	e8 cd 7a ff ff       	call   c0003c3a <strcmp>
c000c16d:	83 c4 10             	add    $0x10,%esp
c000c170:	84 c0                	test   %al,%al
c000c172:	75 16                	jne    c000c18a <cmd_execute+0x12a>
/work/x86_os_my/shell/shell.c:130
		buildin_clear(argc, argv);
c000c174:	83 ec 08             	sub    $0x8,%esp
c000c177:	ff 75 0c             	pushl  0xc(%ebp)
c000c17a:	ff 75 08             	pushl  0x8(%ebp)
c000c17d:	e8 3d 0b 00 00       	call   c000ccbf <buildin_clear>
c000c182:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:163
			} else {
				execv(argv[0], argv);
			}
		}
	}
}
c000c185:	e9 a5 01 00 00       	jmp    c000c32f <cmd_execute+0x2cf>
/work/x86_os_my/shell/shell.c:131
		buildin_pwd(argc, argv);
	} else if (!strcmp("ps", argv[0])) {
		buildin_ps(argc, argv);
	} else if (!strcmp("clear", argv[0])) {
		buildin_clear(argc, argv);
	} else if (!strcmp("mkdir", argv[0])){
c000c18a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c18d:	8b 00                	mov    (%eax),%eax
c000c18f:	83 ec 08             	sub    $0x8,%esp
c000c192:	50                   	push   %eax
c000c193:	68 03 fe 00 c0       	push   $0xc000fe03
c000c198:	e8 9d 7a ff ff       	call   c0003c3a <strcmp>
c000c19d:	83 c4 10             	add    $0x10,%esp
c000c1a0:	84 c0                	test   %al,%al
c000c1a2:	75 16                	jne    c000c1ba <cmd_execute+0x15a>
/work/x86_os_my/shell/shell.c:132
		buildin_mkdir(argc, argv);
c000c1a4:	83 ec 08             	sub    $0x8,%esp
c000c1a7:	ff 75 0c             	pushl  0xc(%ebp)
c000c1aa:	ff 75 08             	pushl  0x8(%ebp)
c000c1ad:	e8 32 0b 00 00       	call   c000cce4 <buildin_mkdir>
c000c1b2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:163
			} else {
				execv(argv[0], argv);
			}
		}
	}
}
c000c1b5:	e9 75 01 00 00       	jmp    c000c32f <cmd_execute+0x2cf>
/work/x86_os_my/shell/shell.c:133
		buildin_ps(argc, argv);
	} else if (!strcmp("clear", argv[0])) {
		buildin_clear(argc, argv);
	} else if (!strcmp("mkdir", argv[0])){
		buildin_mkdir(argc, argv);
	} else if (!strcmp("rmdir", argv[0])){
c000c1ba:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c1bd:	8b 00                	mov    (%eax),%eax
c000c1bf:	83 ec 08             	sub    $0x8,%esp
c000c1c2:	50                   	push   %eax
c000c1c3:	68 09 fe 00 c0       	push   $0xc000fe09
c000c1c8:	e8 6d 7a ff ff       	call   c0003c3a <strcmp>
c000c1cd:	83 c4 10             	add    $0x10,%esp
c000c1d0:	84 c0                	test   %al,%al
c000c1d2:	75 16                	jne    c000c1ea <cmd_execute+0x18a>
/work/x86_os_my/shell/shell.c:134
		buildin_rmdir(argc, argv);
c000c1d4:	83 ec 08             	sub    $0x8,%esp
c000c1d7:	ff 75 0c             	pushl  0xc(%ebp)
c000c1da:	ff 75 08             	pushl  0x8(%ebp)
c000c1dd:	e8 94 0b 00 00       	call   c000cd76 <buildin_rmdir>
c000c1e2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:163
			} else {
				execv(argv[0], argv);
			}
		}
	}
}
c000c1e5:	e9 45 01 00 00       	jmp    c000c32f <cmd_execute+0x2cf>
/work/x86_os_my/shell/shell.c:135
		buildin_clear(argc, argv);
	} else if (!strcmp("mkdir", argv[0])){
		buildin_mkdir(argc, argv);
	} else if (!strcmp("rmdir", argv[0])){
		buildin_rmdir(argc, argv);
	} else if (!strcmp("rm", argv[0])) {
c000c1ea:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c1ed:	8b 00                	mov    (%eax),%eax
c000c1ef:	83 ec 08             	sub    $0x8,%esp
c000c1f2:	50                   	push   %eax
c000c1f3:	68 0f fe 00 c0       	push   $0xc000fe0f
c000c1f8:	e8 3d 7a ff ff       	call   c0003c3a <strcmp>
c000c1fd:	83 c4 10             	add    $0x10,%esp
c000c200:	84 c0                	test   %al,%al
c000c202:	75 16                	jne    c000c21a <cmd_execute+0x1ba>
/work/x86_os_my/shell/shell.c:136
		buildin_rm(argc, argv);
c000c204:	83 ec 08             	sub    $0x8,%esp
c000c207:	ff 75 0c             	pushl  0xc(%ebp)
c000c20a:	ff 75 08             	pushl  0x8(%ebp)
c000c20d:	e8 f6 0b 00 00       	call   c000ce08 <buildin_rm>
c000c212:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:163
			} else {
				execv(argv[0], argv);
			}
		}
	}
}
c000c215:	e9 15 01 00 00       	jmp    c000c32f <cmd_execute+0x2cf>
/work/x86_os_my/shell/shell.c:137
		buildin_mkdir(argc, argv);
	} else if (!strcmp("rmdir", argv[0])){
		buildin_rmdir(argc, argv);
	} else if (!strcmp("rm", argv[0])) {
		buildin_rm(argc, argv);
	} else if (!strcmp("help", argv[0])) {
c000c21a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c21d:	8b 00                	mov    (%eax),%eax
c000c21f:	83 ec 08             	sub    $0x8,%esp
c000c222:	50                   	push   %eax
c000c223:	68 12 fe 00 c0       	push   $0xc000fe12
c000c228:	e8 0d 7a ff ff       	call   c0003c3a <strcmp>
c000c22d:	83 c4 10             	add    $0x10,%esp
c000c230:	84 c0                	test   %al,%al
c000c232:	75 16                	jne    c000c24a <cmd_execute+0x1ea>
/work/x86_os_my/shell/shell.c:138
		buildin_help(argc, argv);
c000c234:	83 ec 08             	sub    $0x8,%esp
c000c237:	ff 75 0c             	pushl  0xc(%ebp)
c000c23a:	ff 75 08             	pushl  0x8(%ebp)
c000c23d:	e8 58 0c 00 00       	call   c000ce9a <buildin_help>
c000c242:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:163
			} else {
				execv(argv[0], argv);
			}
		}
	}
}
c000c245:	e9 e5 00 00 00       	jmp    c000c32f <cmd_execute+0x2cf>
/work/x86_os_my/shell/shell.c:140
	} else if (!strcmp("rm", argv[0])) {
		buildin_rm(argc, argv);
	} else if (!strcmp("help", argv[0])) {
		buildin_help(argc, argv);
	} else {	// 如果是外部命令,需要从磁盘上加载
		int32_t pid = fork();
c000c24a:	e8 a9 99 ff ff       	call   c0005bf8 <fork>
c000c24f:	98                   	cwtl   
c000c250:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/shell/shell.c:141
		if (pid) {		// 父进程
c000c253:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000c257:	74 51                	je     c000c2aa <cmd_execute+0x24a>
/work/x86_os_my/shell/shell.c:143
			int32_t status;
			int32_t child_pid = wait(&status);	// 此时子进程若没有执行exit,my_shell会被阻塞,不再响应键入的命令
c000c259:	83 ec 0c             	sub    $0xc,%esp
c000c25c:	8d 45 ec             	lea    -0x14(%ebp),%eax
c000c25f:	50                   	push   %eax
c000c260:	e8 00 9c ff ff       	call   c0005e65 <wait>
c000c265:	83 c4 10             	add    $0x10,%esp
c000c268:	98                   	cwtl   
c000c269:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/shell/shell.c:144
			if (child_pid == -1) {	// 按理说程序正确的话不会执行到这句,fork出的进程便是shell子进程
c000c26c:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c000c270:	75 1c                	jne    c000c28e <cmd_execute+0x22e>
/work/x86_os_my/shell/shell.c:145
				panic("my_shell: no child\n");
c000c272:	68 17 fe 00 c0       	push   $0xc000fe17
c000c277:	68 b8 fe 00 c0       	push   $0xc000feb8
c000c27c:	68 91 00 00 00       	push   $0x91
c000c281:	68 51 fd 00 c0       	push   $0xc000fd51
c000c286:	e8 17 03 00 00       	call   c000c5a2 <user_spin>
c000c28b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:147
			}
			printf("child_pid %d, it's status: %d\n", child_pid, status);
c000c28e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000c291:	83 ec 04             	sub    $0x4,%esp
c000c294:	50                   	push   %eax
c000c295:	ff 75 f0             	pushl  -0x10(%ebp)
c000c298:	68 2c fe 00 c0       	push   $0xc000fe2c
c000c29d:	e8 b3 9f ff ff       	call   c0006255 <printf>
c000c2a2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:163
			} else {
				execv(argv[0], argv);
			}
		}
	}
}
c000c2a5:	e9 85 00 00 00       	jmp    c000c32f <cmd_execute+0x2cf>
/work/x86_os_my/shell/shell.c:149
			if (child_pid == -1) {	// 按理说程序正确的话不会执行到这句,fork出的进程便是shell子进程
				panic("my_shell: no child\n");
			}
			printf("child_pid %d, it's status: %d\n", child_pid, status);
		} else {		// 子进程
			make_clear_abs_path(argv[0], final_path);
c000c2aa:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c2ad:	8b 00                	mov    (%eax),%eax
c000c2af:	83 ec 08             	sub    $0x8,%esp
c000c2b2:	68 c0 36 01 c0       	push   $0xc00136c0
c000c2b7:	50                   	push   %eax
c000c2b8:	e8 79 04 00 00       	call   c000c736 <make_clear_abs_path>
c000c2bd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:150
			argv[0] = final_path;
c000c2c0:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c2c3:	c7 00 c0 36 01 c0    	movl   $0xc00136c0,(%eax)
/work/x86_os_my/shell/shell.c:154

			/* 先判断下文件是否存在 */
			struct stat file_stat;
			memset(&file_stat, 0, sizeof(struct stat));
c000c2c9:	83 ec 04             	sub    $0x4,%esp
c000c2cc:	6a 0c                	push   $0xc
c000c2ce:	6a 00                	push   $0x0
c000c2d0:	8d 45 e0             	lea    -0x20(%ebp),%eax
c000c2d3:	50                   	push   %eax
c000c2d4:	e8 8c 77 ff ff       	call   c0003a65 <memset>
c000c2d9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:155
			if (stat(argv[0], &file_stat) == -1) {
c000c2dc:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c2df:	8b 00                	mov    (%eax),%eax
c000c2e1:	83 ec 08             	sub    $0x8,%esp
c000c2e4:	8d 55 e0             	lea    -0x20(%ebp),%edx
c000c2e7:	52                   	push   %edx
c000c2e8:	50                   	push   %eax
c000c2e9:	e8 e4 9a ff ff       	call   c0005dd2 <stat>
c000c2ee:	83 c4 10             	add    $0x10,%esp
c000c2f1:	83 f8 ff             	cmp    $0xffffffff,%eax
c000c2f4:	75 25                	jne    c000c31b <cmd_execute+0x2bb>
/work/x86_os_my/shell/shell.c:156
				printf("my_shell: cannot access %s: No such file or directory\n", argv[0]);
c000c2f6:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c2f9:	8b 00                	mov    (%eax),%eax
c000c2fb:	83 ec 08             	sub    $0x8,%esp
c000c2fe:	50                   	push   %eax
c000c2ff:	68 4c fe 00 c0       	push   $0xc000fe4c
c000c304:	e8 4c 9f ff ff       	call   c0006255 <printf>
c000c309:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:157
				exit(-1);
c000c30c:	83 ec 0c             	sub    $0xc,%esp
c000c30f:	6a ff                	push   $0xffffffff
c000c311:	e8 32 9b ff ff       	call   c0005e48 <exit>
c000c316:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:163
			} else {
				execv(argv[0], argv);
			}
		}
	}
}
c000c319:	eb 14                	jmp    c000c32f <cmd_execute+0x2cf>
/work/x86_os_my/shell/shell.c:159
			memset(&file_stat, 0, sizeof(struct stat));
			if (stat(argv[0], &file_stat) == -1) {
				printf("my_shell: cannot access %s: No such file or directory\n", argv[0]);
				exit(-1);
			} else {
				execv(argv[0], argv);
c000c31b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c31e:	8b 00                	mov    (%eax),%eax
c000c320:	83 ec 08             	sub    $0x8,%esp
c000c323:	ff 75 0c             	pushl  0xc(%ebp)
c000c326:	50                   	push   %eax
c000c327:	e8 fa 9a ff ff       	call   c0005e26 <execv>
c000c32c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:163
			}
		}
	}
}
c000c32f:	90                   	nop
c000c330:	c9                   	leave  
c000c331:	c3                   	ret    

c000c332 <my_shell>:
my_shell():
/work/x86_os_my/shell/shell.c:168

char* argv[MAX_ARG_NR] = {NULL};
int32_t argc = -1;
/* 简单的shell */
void my_shell(void) {
c000c332:	55                   	push   %ebp
c000c333:	89 e5                	mov    %esp,%ebp
c000c335:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/shell/shell.c:169
	cwd_cache[0] = '/';
c000c338:	c6 05 c0 38 01 c0 2f 	movb   $0x2f,0xc00138c0
/work/x86_os_my/shell/shell.c:171
	while (1) {
		print_prompt(); 
c000c33f:	e8 f4 fa ff ff       	call   c000be38 <print_prompt>
/work/x86_os_my/shell/shell.c:172
		memset(final_path, 0, MAX_PATH_LEN);
c000c344:	83 ec 04             	sub    $0x4,%esp
c000c347:	68 00 02 00 00       	push   $0x200
c000c34c:	6a 00                	push   $0x0
c000c34e:	68 c0 36 01 c0       	push   $0xc00136c0
c000c353:	e8 0d 77 ff ff       	call   c0003a65 <memset>
c000c358:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:173
		memset(cmd_line, 0, MAX_PATH_LEN);
c000c35b:	83 ec 04             	sub    $0x4,%esp
c000c35e:	68 00 02 00 00       	push   $0x200
c000c363:	6a 00                	push   $0x0
c000c365:	68 00 3b 01 c0       	push   $0xc0013b00
c000c36a:	e8 f6 76 ff ff       	call   c0003a65 <memset>
c000c36f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:174
		readline(cmd_line, MAX_PATH_LEN);
c000c372:	83 ec 08             	sub    $0x8,%esp
c000c375:	68 00 02 00 00       	push   $0x200
c000c37a:	68 00 3b 01 c0       	push   $0xc0013b00
c000c37f:	e8 d2 fa ff ff       	call   c000be56 <readline>
c000c384:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:175
		if (cmd_line[0] == 0) {	// 若只键入了一个回车
c000c387:	0f b6 05 00 3b 01 c0 	movzbl 0xc0013b00,%eax
c000c38e:	84 c0                	test   %al,%al
c000c390:	0f 84 06 02 00 00    	je     c000c59c <my_shell+0x26a>
/work/x86_os_my/shell/shell.c:180
			continue;
		}

		/* 针对管道的处理 */
		char* pipe_symbol = strchr(cmd_line, '|');
c000c396:	83 ec 08             	sub    $0x8,%esp
c000c399:	6a 7c                	push   $0x7c
c000c39b:	68 00 3b 01 c0       	push   $0xc0013b00
c000c3a0:	e8 0e 79 ff ff       	call   c0003cb3 <strchr>
c000c3a5:	83 c4 10             	add    $0x10,%esp
c000c3a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/shell/shell.c:181
		if (pipe_symbol) {
c000c3ab:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000c3af:	0f 84 88 01 00 00    	je     c000c53d <my_shell+0x20b>
/work/x86_os_my/shell/shell.c:186
			/* 支持多重管道操作,如cmd1|cmd2|..|cmdn,
			* cmd1的标准输出和cmdn的标准输入需要单独处理 */

			/*1 生成管道*/
			int32_t fd[2] = {-1};	    // fd[0]用于输入,fd[1]用于输出
c000c3b5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c000c3bc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c000c3c3:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)
/work/x86_os_my/shell/shell.c:187
			pipe(fd);
c000c3ca:	83 ec 0c             	sub    $0xc,%esp
c000c3cd:	8d 45 e8             	lea    -0x18(%ebp),%eax
c000c3d0:	50                   	push   %eax
c000c3d1:	e8 ae 9a ff ff       	call   c0005e84 <pipe>
c000c3d6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:189
			/* 将标准输出重定向到fd[1],使后面的输出信息重定向到内核环形缓冲区 */
			fd_redirect(1,fd[1]);
c000c3d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000c3dc:	83 ec 08             	sub    $0x8,%esp
c000c3df:	50                   	push   %eax
c000c3e0:	6a 01                	push   $0x1
c000c3e2:	e8 bc 9a ff ff       	call   c0005ea3 <fd_redirect>
c000c3e7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:192

			/*2 第一个命令 */
			char* each_cmd = cmd_line;
c000c3ea:	c7 45 f4 00 3b 01 c0 	movl   $0xc0013b00,-0xc(%ebp)
/work/x86_os_my/shell/shell.c:193
			pipe_symbol = strchr(each_cmd, '|');
c000c3f1:	83 ec 08             	sub    $0x8,%esp
c000c3f4:	6a 7c                	push   $0x7c
c000c3f6:	ff 75 f4             	pushl  -0xc(%ebp)
c000c3f9:	e8 b5 78 ff ff       	call   c0003cb3 <strchr>
c000c3fe:	83 c4 10             	add    $0x10,%esp
c000c401:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/shell/shell.c:194
			*pipe_symbol = 0;
c000c404:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000c407:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/shell/shell.c:197

			/* 执行第一个命令,命令的输出会写入环形缓冲区 */
			argc = -1;
c000c40a:	c7 05 58 31 01 c0 ff 	movl   $0xffffffff,0xc0013158
c000c411:	ff ff ff 
/work/x86_os_my/shell/shell.c:198
			argc = cmd_parse(each_cmd, argv, ' ');
c000c414:	83 ec 04             	sub    $0x4,%esp
c000c417:	6a 20                	push   $0x20
c000c419:	68 c0 3a 01 c0       	push   $0xc0013ac0
c000c41e:	ff 75 f4             	pushl  -0xc(%ebp)
c000c421:	e8 57 fb ff ff       	call   c000bf7d <cmd_parse>
c000c426:	83 c4 10             	add    $0x10,%esp
c000c429:	a3 58 31 01 c0       	mov    %eax,0xc0013158
/work/x86_os_my/shell/shell.c:199
			cmd_execute(argc, argv);
c000c42e:	a1 58 31 01 c0       	mov    0xc0013158,%eax
c000c433:	83 ec 08             	sub    $0x8,%esp
c000c436:	68 c0 3a 01 c0       	push   $0xc0013ac0
c000c43b:	50                   	push   %eax
c000c43c:	e8 1f fc ff ff       	call   c000c060 <cmd_execute>
c000c441:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:202

			/* 跨过'|',处理下一个命令 */
			each_cmd = pipe_symbol + 1;
c000c444:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000c447:	83 c0 01             	add    $0x1,%eax
c000c44a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/shell/shell.c:205

			/* 将标准输入重定向到fd[0],使之指向内核环形缓冲区*/
			fd_redirect(0,fd[0]);
c000c44d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000c450:	83 ec 08             	sub    $0x8,%esp
c000c453:	50                   	push   %eax
c000c454:	6a 00                	push   $0x0
c000c456:	e8 48 9a ff ff       	call   c0005ea3 <fd_redirect>
c000c45b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:207
			/*3 中间的命令,命令的输入和输出都是指向环形缓冲区 */
			while ((pipe_symbol = strchr(each_cmd, '|'))) { 
c000c45e:	eb 49                	jmp    c000c4a9 <my_shell+0x177>
/work/x86_os_my/shell/shell.c:208
				*pipe_symbol = 0;
c000c460:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000c463:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/shell/shell.c:209
				argc = -1;
c000c466:	c7 05 58 31 01 c0 ff 	movl   $0xffffffff,0xc0013158
c000c46d:	ff ff ff 
/work/x86_os_my/shell/shell.c:210
				argc = cmd_parse(each_cmd, argv, ' ');
c000c470:	83 ec 04             	sub    $0x4,%esp
c000c473:	6a 20                	push   $0x20
c000c475:	68 c0 3a 01 c0       	push   $0xc0013ac0
c000c47a:	ff 75 f4             	pushl  -0xc(%ebp)
c000c47d:	e8 fb fa ff ff       	call   c000bf7d <cmd_parse>
c000c482:	83 c4 10             	add    $0x10,%esp
c000c485:	a3 58 31 01 c0       	mov    %eax,0xc0013158
/work/x86_os_my/shell/shell.c:211
				cmd_execute(argc, argv);
c000c48a:	a1 58 31 01 c0       	mov    0xc0013158,%eax
c000c48f:	83 ec 08             	sub    $0x8,%esp
c000c492:	68 c0 3a 01 c0       	push   $0xc0013ac0
c000c497:	50                   	push   %eax
c000c498:	e8 c3 fb ff ff       	call   c000c060 <cmd_execute>
c000c49d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:212
				each_cmd = pipe_symbol + 1;
c000c4a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000c4a3:	83 c0 01             	add    $0x1,%eax
c000c4a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/shell/shell.c:207
			each_cmd = pipe_symbol + 1;

			/* 将标准输入重定向到fd[0],使之指向内核环形缓冲区*/
			fd_redirect(0,fd[0]);
			/*3 中间的命令,命令的输入和输出都是指向环形缓冲区 */
			while ((pipe_symbol = strchr(each_cmd, '|'))) { 
c000c4a9:	83 ec 08             	sub    $0x8,%esp
c000c4ac:	6a 7c                	push   $0x7c
c000c4ae:	ff 75 f4             	pushl  -0xc(%ebp)
c000c4b1:	e8 fd 77 ff ff       	call   c0003cb3 <strchr>
c000c4b6:	83 c4 10             	add    $0x10,%esp
c000c4b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
c000c4bc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000c4c0:	75 9e                	jne    c000c460 <my_shell+0x12e>
/work/x86_os_my/shell/shell.c:217
				each_cmd = pipe_symbol + 1;
			}

			/*4 处理管道中最后一个命令 */
			/* 将标准输出恢复屏幕 */
			fd_redirect(1,1);
c000c4c2:	83 ec 08             	sub    $0x8,%esp
c000c4c5:	6a 01                	push   $0x1
c000c4c7:	6a 01                	push   $0x1
c000c4c9:	e8 d5 99 ff ff       	call   c0005ea3 <fd_redirect>
c000c4ce:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:220

			/* 执行最后一个命令 */
			argc = -1;
c000c4d1:	c7 05 58 31 01 c0 ff 	movl   $0xffffffff,0xc0013158
c000c4d8:	ff ff ff 
/work/x86_os_my/shell/shell.c:221
			argc = cmd_parse(each_cmd, argv, ' ');
c000c4db:	83 ec 04             	sub    $0x4,%esp
c000c4de:	6a 20                	push   $0x20
c000c4e0:	68 c0 3a 01 c0       	push   $0xc0013ac0
c000c4e5:	ff 75 f4             	pushl  -0xc(%ebp)
c000c4e8:	e8 90 fa ff ff       	call   c000bf7d <cmd_parse>
c000c4ed:	83 c4 10             	add    $0x10,%esp
c000c4f0:	a3 58 31 01 c0       	mov    %eax,0xc0013158
/work/x86_os_my/shell/shell.c:222
			cmd_execute(argc, argv);
c000c4f5:	a1 58 31 01 c0       	mov    0xc0013158,%eax
c000c4fa:	83 ec 08             	sub    $0x8,%esp
c000c4fd:	68 c0 3a 01 c0       	push   $0xc0013ac0
c000c502:	50                   	push   %eax
c000c503:	e8 58 fb ff ff       	call   c000c060 <cmd_execute>
c000c508:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:225

			/*5 将标准输入恢复为键盘 */
			fd_redirect(0,0);
c000c50b:	83 ec 08             	sub    $0x8,%esp
c000c50e:	6a 00                	push   $0x0
c000c510:	6a 00                	push   $0x0
c000c512:	e8 8c 99 ff ff       	call   c0005ea3 <fd_redirect>
c000c517:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:228

			/*6 关闭管道 */
			close(fd[0]);
c000c51a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000c51d:	83 ec 0c             	sub    $0xc,%esp
c000c520:	50                   	push   %eax
c000c521:	e8 8c 97 ff ff       	call   c0005cb2 <close>
c000c526:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:229
			close(fd[1]);
c000c529:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000c52c:	83 ec 0c             	sub    $0xc,%esp
c000c52f:	50                   	push   %eax
c000c530:	e8 7d 97 ff ff       	call   c0005cb2 <close>
c000c535:	83 c4 10             	add    $0x10,%esp
c000c538:	e9 02 fe ff ff       	jmp    c000c33f <my_shell+0xd>
/work/x86_os_my/shell/shell.c:231
		} else {			// 没有管道操作的用户命令
			argc = -1;
c000c53d:	c7 05 58 31 01 c0 ff 	movl   $0xffffffff,0xc0013158
c000c544:	ff ff ff 
/work/x86_os_my/shell/shell.c:232
			argc = cmd_parse(cmd_line, argv, ' ');
c000c547:	83 ec 04             	sub    $0x4,%esp
c000c54a:	6a 20                	push   $0x20
c000c54c:	68 c0 3a 01 c0       	push   $0xc0013ac0
c000c551:	68 00 3b 01 c0       	push   $0xc0013b00
c000c556:	e8 22 fa ff ff       	call   c000bf7d <cmd_parse>
c000c55b:	83 c4 10             	add    $0x10,%esp
c000c55e:	a3 58 31 01 c0       	mov    %eax,0xc0013158
/work/x86_os_my/shell/shell.c:233
			if (argc == -1) {
c000c563:	a1 58 31 01 c0       	mov    0xc0013158,%eax
c000c568:	83 f8 ff             	cmp    $0xffffffff,%eax
c000c56b:	75 14                	jne    c000c581 <my_shell+0x24f>
/work/x86_os_my/shell/shell.c:234
				printf("num of arguments exceed %d\n", MAX_ARG_NR);
c000c56d:	83 ec 08             	sub    $0x8,%esp
c000c570:	6a 10                	push   $0x10
c000c572:	68 83 fe 00 c0       	push   $0xc000fe83
c000c577:	e8 d9 9c ff ff       	call   c0006255 <printf>
c000c57c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/shell.c:235
				continue;
c000c57f:	eb 1c                	jmp    c000c59d <my_shell+0x26b>
/work/x86_os_my/shell/shell.c:237
			}
			cmd_execute(argc, argv);
c000c581:	a1 58 31 01 c0       	mov    0xc0013158,%eax
c000c586:	83 ec 08             	sub    $0x8,%esp
c000c589:	68 c0 3a 01 c0       	push   $0xc0013ac0
c000c58e:	50                   	push   %eax
c000c58f:	e8 cc fa ff ff       	call   c000c060 <cmd_execute>
c000c594:	83 c4 10             	add    $0x10,%esp
c000c597:	e9 a3 fd ff ff       	jmp    c000c33f <my_shell+0xd>
/work/x86_os_my/shell/shell.c:176
		print_prompt(); 
		memset(final_path, 0, MAX_PATH_LEN);
		memset(cmd_line, 0, MAX_PATH_LEN);
		readline(cmd_line, MAX_PATH_LEN);
		if (cmd_line[0] == 0) {	// 若只键入了一个回车
			continue;
c000c59c:	90                   	nop
/work/x86_os_my/shell/shell.c:239 (discriminator 1)
				printf("num of arguments exceed %d\n", MAX_ARG_NR);
				continue;
			}
			cmd_execute(argc, argv);
		}
	}
c000c59d:	e9 9d fd ff ff       	jmp    c000c33f <my_shell+0xd>

c000c5a2 <user_spin>:
user_spin():
/work/x86_os_my/lib/user/assert.c:3
#include "assert.h"
#include "stdio.h"
void user_spin(char* filename, int line, const char* func, const char* condition) {
c000c5a2:	55                   	push   %ebp
c000c5a3:	89 e5                	mov    %esp,%ebp
c000c5a5:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/user/assert.c:4
	printf("\n\n\n\nfilename %s\nline %d\nfunction %s\ncondition %s\n", filename, line, func, condition);
c000c5a8:	83 ec 0c             	sub    $0xc,%esp
c000c5ab:	ff 75 14             	pushl  0x14(%ebp)
c000c5ae:	ff 75 10             	pushl  0x10(%ebp)
c000c5b1:	ff 75 0c             	pushl  0xc(%ebp)
c000c5b4:	ff 75 08             	pushl  0x8(%ebp)
c000c5b7:	68 c4 fe 00 c0       	push   $0xc000fec4
c000c5bc:	e8 94 9c ff ff       	call   c0006255 <printf>
c000c5c1:	83 c4 20             	add    $0x20,%esp
/work/x86_os_my/lib/user/assert.c:5 (discriminator 1)
	while(1);
c000c5c4:	eb fe                	jmp    c000c5c4 <user_spin+0x22>

c000c5c6 <wash_path>:
wash_path():
/work/x86_os_my/shell/buildin_cmd.c:16
/* 将路径old_abs_path中的..和.转换为实际路径后存入new_abs_path */
// 从左到右解析 old_abs_path 路径中的每一层，
// 若解析出来的目录名不是“..”，就将其连接到 new_abs_path
// 若是“ ..” , 就将 new_abs_path 的最后一层目录去掉。
// 若是“ . ” , 就什么都不做
static void wash_path(char* old_abs_path, char* new_abs_path) {
c000c5c6:	55                   	push   %ebp
c000c5c7:	89 e5                	mov    %esp,%ebp
c000c5c9:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/shell/buildin_cmd.c:17
	assert(old_abs_path[0] == '/');
c000c5cc:	8b 45 08             	mov    0x8(%ebp),%eax
c000c5cf:	0f b6 00             	movzbl (%eax),%eax
c000c5d2:	3c 2f                	cmp    $0x2f,%al
c000c5d4:	74 19                	je     c000c5ef <wash_path+0x29>
/work/x86_os_my/shell/buildin_cmd.c:17 (discriminator 1)
c000c5d6:	68 f8 fe 00 c0       	push   $0xc000fef8
c000c5db:	68 ec 01 01 c0       	push   $0xc00101ec
c000c5e0:	6a 11                	push   $0x11
c000c5e2:	68 0f ff 00 c0       	push   $0xc000ff0f
c000c5e7:	e8 b6 ff ff ff       	call   c000c5a2 <user_spin>
c000c5ec:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:18
	char name[MAX_FILE_NAME_LEN] = {0};    
c000c5ef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c000c5f6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
c000c5fd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c000c604:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:19
	char* sub_path = old_abs_path;
c000c60b:	8b 45 08             	mov    0x8(%ebp),%eax
c000c60e:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:20
	sub_path = path_parse(sub_path, name);
c000c611:	83 ec 08             	sub    $0x8,%esp
c000c614:	8d 45 e0             	lea    -0x20(%ebp),%eax
c000c617:	50                   	push   %eax
c000c618:	ff 75 f4             	pushl  -0xc(%ebp)
c000c61b:	e8 e0 b0 ff ff       	call   c0007700 <path_parse>
c000c620:	83 c4 10             	add    $0x10,%esp
c000c623:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:21
	if (name[0] == 0) {	// 若只键入了"/",直接将"/"存入new_abs_path后返回 
c000c626:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
c000c62a:	84 c0                	test   %al,%al
c000c62c:	75 14                	jne    c000c642 <wash_path+0x7c>
/work/x86_os_my/shell/buildin_cmd.c:22
		new_abs_path[0] = '/';
c000c62e:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c631:	c6 00 2f             	movb   $0x2f,(%eax)
/work/x86_os_my/shell/buildin_cmd.c:23
		new_abs_path[1] = 0;
c000c634:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c637:	83 c0 01             	add    $0x1,%eax
c000c63a:	c6 00 00             	movb   $0x0,(%eax)
c000c63d:	e9 f2 00 00 00       	jmp    c000c734 <wash_path+0x16e>
/work/x86_os_my/shell/buildin_cmd.c:26
		return;
	}
	new_abs_path[0] = 0;	// 避免传给new_abs_path的缓冲区不干净
c000c642:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c645:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/shell/buildin_cmd.c:27
	strcat(new_abs_path, "/");
c000c648:	83 ec 08             	sub    $0x8,%esp
c000c64b:	68 23 ff 00 c0       	push   $0xc000ff23
c000c650:	ff 75 0c             	pushl  0xc(%ebp)
c000c653:	e8 11 77 ff ff       	call   c0003d69 <strcat>
c000c658:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:28
	while (name[0]) {
c000c65b:	e9 c8 00 00 00       	jmp    c000c728 <wash_path+0x162>
/work/x86_os_my/shell/buildin_cmd.c:30
		/* 如果是上一级目录“..” */
		if (!strcmp("..", name)) {
c000c660:	83 ec 08             	sub    $0x8,%esp
c000c663:	8d 45 e0             	lea    -0x20(%ebp),%eax
c000c666:	50                   	push   %eax
c000c667:	68 25 ff 00 c0       	push   $0xc000ff25
c000c66c:	e8 c9 75 ff ff       	call   c0003c3a <strcmp>
c000c671:	83 c4 10             	add    $0x10,%esp
c000c674:	84 c0                	test   %al,%al
c000c676:	75 2e                	jne    c000c6a6 <wash_path+0xe0>
/work/x86_os_my/shell/buildin_cmd.c:31
			char* slash_ptr =  strrchr(new_abs_path, '/');
c000c678:	83 ec 08             	sub    $0x8,%esp
c000c67b:	6a 2f                	push   $0x2f
c000c67d:	ff 75 0c             	pushl  0xc(%ebp)
c000c680:	e8 86 76 ff ff       	call   c0003d0b <strrchr>
c000c685:	83 c4 10             	add    $0x10,%esp
c000c688:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:34
			/*如果未到new_abs_path中的顶层目录,就将最右边的'/'替换为0,
			这样便去除了new_abs_path中最后一层路径,相当于到了上一级目录 */
			if (slash_ptr != new_abs_path) {	// 如new_abs_path为“/a/b”,".."之后则变为“/a”
c000c68b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000c68e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000c691:	74 08                	je     c000c69b <wash_path+0xd5>
/work/x86_os_my/shell/buildin_cmd.c:35
				*slash_ptr = 0;
c000c693:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000c696:	c6 00 00             	movb   $0x0,(%eax)
c000c699:	eb 5f                	jmp    c000c6fa <wash_path+0x134>
/work/x86_os_my/shell/buildin_cmd.c:39
			} else {	// 如new_abs_path为"/a",".."之后则变为"/"
				/* 若new_abs_path中只有1个'/',即表示已经到了顶层目录,
				就将下一个字符置为结束符0. */
				*(slash_ptr + 1) = 0;
c000c69b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000c69e:	83 c0 01             	add    $0x1,%eax
c000c6a1:	c6 00 00             	movb   $0x0,(%eax)
c000c6a4:	eb 54                	jmp    c000c6fa <wash_path+0x134>
/work/x86_os_my/shell/buildin_cmd.c:41
			}
		} else if (strcmp(".", name)) {	// 如果路径不是‘.’,就将name拼接到new_abs_path
c000c6a6:	83 ec 08             	sub    $0x8,%esp
c000c6a9:	8d 45 e0             	lea    -0x20(%ebp),%eax
c000c6ac:	50                   	push   %eax
c000c6ad:	68 28 ff 00 c0       	push   $0xc000ff28
c000c6b2:	e8 83 75 ff ff       	call   c0003c3a <strcmp>
c000c6b7:	83 c4 10             	add    $0x10,%esp
c000c6ba:	84 c0                	test   %al,%al
c000c6bc:	74 3c                	je     c000c6fa <wash_path+0x134>
/work/x86_os_my/shell/buildin_cmd.c:42
			if (strcmp(new_abs_path, "/")) {	// 如果new_abs_path不是"/",就拼接一个"/",此处的判断是为了避免路径开头变成这样"//"
c000c6be:	83 ec 08             	sub    $0x8,%esp
c000c6c1:	68 23 ff 00 c0       	push   $0xc000ff23
c000c6c6:	ff 75 0c             	pushl  0xc(%ebp)
c000c6c9:	e8 6c 75 ff ff       	call   c0003c3a <strcmp>
c000c6ce:	83 c4 10             	add    $0x10,%esp
c000c6d1:	84 c0                	test   %al,%al
c000c6d3:	74 13                	je     c000c6e8 <wash_path+0x122>
/work/x86_os_my/shell/buildin_cmd.c:43
				strcat(new_abs_path, "/");
c000c6d5:	83 ec 08             	sub    $0x8,%esp
c000c6d8:	68 23 ff 00 c0       	push   $0xc000ff23
c000c6dd:	ff 75 0c             	pushl  0xc(%ebp)
c000c6e0:	e8 84 76 ff ff       	call   c0003d69 <strcat>
c000c6e5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:45
			}
			strcat(new_abs_path, name);
c000c6e8:	83 ec 08             	sub    $0x8,%esp
c000c6eb:	8d 45 e0             	lea    -0x20(%ebp),%eax
c000c6ee:	50                   	push   %eax
c000c6ef:	ff 75 0c             	pushl  0xc(%ebp)
c000c6f2:	e8 72 76 ff ff       	call   c0003d69 <strcat>
c000c6f7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:49
		}	// 若name为当前目录".",无须处理new_abs_path

		/* 继续遍历下一层路径 */
		memset(name, 0, MAX_FILE_NAME_LEN);
c000c6fa:	83 ec 04             	sub    $0x4,%esp
c000c6fd:	6a 10                	push   $0x10
c000c6ff:	6a 00                	push   $0x0
c000c701:	8d 45 e0             	lea    -0x20(%ebp),%eax
c000c704:	50                   	push   %eax
c000c705:	e8 5b 73 ff ff       	call   c0003a65 <memset>
c000c70a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:50
		if (sub_path) {
c000c70d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000c711:	74 15                	je     c000c728 <wash_path+0x162>
/work/x86_os_my/shell/buildin_cmd.c:51
			sub_path = path_parse(sub_path, name);
c000c713:	83 ec 08             	sub    $0x8,%esp
c000c716:	8d 45 e0             	lea    -0x20(%ebp),%eax
c000c719:	50                   	push   %eax
c000c71a:	ff 75 f4             	pushl  -0xc(%ebp)
c000c71d:	e8 de af ff ff       	call   c0007700 <path_parse>
c000c722:	83 c4 10             	add    $0x10,%esp
c000c725:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:28
		new_abs_path[1] = 0;
		return;
	}
	new_abs_path[0] = 0;	// 避免传给new_abs_path的缓冲区不干净
	strcat(new_abs_path, "/");
	while (name[0]) {
c000c728:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
c000c72c:	84 c0                	test   %al,%al
c000c72e:	0f 85 2c ff ff ff    	jne    c000c660 <wash_path+0x9a>
/work/x86_os_my/shell/buildin_cmd.c:54
		memset(name, 0, MAX_FILE_NAME_LEN);
		if (sub_path) {
			sub_path = path_parse(sub_path, name);
		}
	}
}
c000c734:	c9                   	leave  
c000c735:	c3                   	ret    

c000c736 <make_clear_abs_path>:
make_clear_abs_path():
/work/x86_os_my/shell/buildin_cmd.c:60

/* 相对路径，转换成绝对路径，应该给用户层做，陷入内核态之后的操作不应该过长。
 * 当前工作路径 + 相对路径 = 绝对路径
 */
/* 将path处理成不含..和.的绝对路径,存储在final_path */
void make_clear_abs_path(char* path, char* final_path) {
c000c736:	55                   	push   %ebp
c000c737:	89 e5                	mov    %esp,%ebp
c000c739:	57                   	push   %edi
c000c73a:	81 ec 04 02 00 00    	sub    $0x204,%esp
/work/x86_os_my/shell/buildin_cmd.c:61
	char abs_path[MAX_PATH_LEN] = {0};
c000c740:	8d 95 f8 fd ff ff    	lea    -0x208(%ebp),%edx
c000c746:	b8 00 00 00 00       	mov    $0x0,%eax
c000c74b:	b9 80 00 00 00       	mov    $0x80,%ecx
c000c750:	89 d7                	mov    %edx,%edi
c000c752:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/shell/buildin_cmd.c:63
	/* 先判断是否输入的是绝对路径 */
	if (path[0] != '/') {	// 若输入的不是绝对路径,就拼接成绝对路径
c000c754:	8b 45 08             	mov    0x8(%ebp),%eax
c000c757:	0f b6 00             	movzbl (%eax),%eax
c000c75a:	3c 2f                	cmp    $0x2f,%al
c000c75c:	74 61                	je     c000c7bf <make_clear_abs_path+0x89>
/work/x86_os_my/shell/buildin_cmd.c:64
		memset(abs_path, 0, MAX_PATH_LEN);
c000c75e:	83 ec 04             	sub    $0x4,%esp
c000c761:	68 00 02 00 00       	push   $0x200
c000c766:	6a 00                	push   $0x0
c000c768:	8d 85 f8 fd ff ff    	lea    -0x208(%ebp),%eax
c000c76e:	50                   	push   %eax
c000c76f:	e8 f1 72 ff ff       	call   c0003a65 <memset>
c000c774:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:65
		if (getcwd(abs_path, MAX_PATH_LEN) != NULL) {
c000c777:	83 ec 08             	sub    $0x8,%esp
c000c77a:	68 00 02 00 00       	push   $0x200
c000c77f:	8d 85 f8 fd ff ff    	lea    -0x208(%ebp),%eax
c000c785:	50                   	push   %eax
c000c786:	e8 dc 94 ff ff       	call   c0005c67 <getcwd>
c000c78b:	83 c4 10             	add    $0x10,%esp
c000c78e:	85 c0                	test   %eax,%eax
c000c790:	74 2d                	je     c000c7bf <make_clear_abs_path+0x89>
/work/x86_os_my/shell/buildin_cmd.c:66
			if (!((abs_path[0] == '/') && (abs_path[1] == 0))) {	// 若abs_path表示的当前目录不是根目录/
c000c792:	0f b6 85 f8 fd ff ff 	movzbl -0x208(%ebp),%eax
c000c799:	3c 2f                	cmp    $0x2f,%al
c000c79b:	75 0b                	jne    c000c7a8 <make_clear_abs_path+0x72>
/work/x86_os_my/shell/buildin_cmd.c:66 (discriminator 1)
c000c79d:	0f b6 85 f9 fd ff ff 	movzbl -0x207(%ebp),%eax
c000c7a4:	84 c0                	test   %al,%al
c000c7a6:	74 17                	je     c000c7bf <make_clear_abs_path+0x89>
/work/x86_os_my/shell/buildin_cmd.c:67
				strcat(abs_path, "/");
c000c7a8:	83 ec 08             	sub    $0x8,%esp
c000c7ab:	68 23 ff 00 c0       	push   $0xc000ff23
c000c7b0:	8d 85 f8 fd ff ff    	lea    -0x208(%ebp),%eax
c000c7b6:	50                   	push   %eax
c000c7b7:	e8 ad 75 ff ff       	call   c0003d69 <strcat>
c000c7bc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:71
			}
		}
	}
	strcat(abs_path, path);
c000c7bf:	83 ec 08             	sub    $0x8,%esp
c000c7c2:	ff 75 08             	pushl  0x8(%ebp)
c000c7c5:	8d 85 f8 fd ff ff    	lea    -0x208(%ebp),%eax
c000c7cb:	50                   	push   %eax
c000c7cc:	e8 98 75 ff ff       	call   c0003d69 <strcat>
c000c7d1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:72
	wash_path(abs_path, final_path);
c000c7d4:	83 ec 08             	sub    $0x8,%esp
c000c7d7:	ff 75 0c             	pushl  0xc(%ebp)
c000c7da:	8d 85 f8 fd ff ff    	lea    -0x208(%ebp),%eax
c000c7e0:	50                   	push   %eax
c000c7e1:	e8 e0 fd ff ff       	call   c000c5c6 <wash_path>
c000c7e6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:73
}
c000c7e9:	90                   	nop
c000c7ea:	8b 7d fc             	mov    -0x4(%ebp),%edi
c000c7ed:	c9                   	leave  
c000c7ee:	c3                   	ret    

c000c7ef <buildin_pwd>:
buildin_pwd():
/work/x86_os_my/shell/buildin_cmd.c:77


/* pwd命令的内建函数 */
void buildin_pwd(uint32_t argc, char** argv UNUSED) {
c000c7ef:	55                   	push   %ebp
c000c7f0:	89 e5                	mov    %esp,%ebp
c000c7f2:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/shell/buildin_cmd.c:78
	if (argc != 1) {
c000c7f5:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c000c7f9:	74 12                	je     c000c80d <buildin_pwd+0x1e>
/work/x86_os_my/shell/buildin_cmd.c:79
		printf("pwd: no argument support!\n");
c000c7fb:	83 ec 0c             	sub    $0xc,%esp
c000c7fe:	68 2a ff 00 c0       	push   $0xc000ff2a
c000c803:	e8 4d 9a ff ff       	call   c0006255 <printf>
c000c808:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:80
		return;
c000c80b:	eb 40                	jmp    c000c84d <buildin_pwd+0x5e>
/work/x86_os_my/shell/buildin_cmd.c:82
	} else {
		if (NULL != getcwd(final_path, MAX_PATH_LEN)) {
c000c80d:	83 ec 08             	sub    $0x8,%esp
c000c810:	68 00 02 00 00       	push   $0x200
c000c815:	68 c0 36 01 c0       	push   $0xc00136c0
c000c81a:	e8 48 94 ff ff       	call   c0005c67 <getcwd>
c000c81f:	83 c4 10             	add    $0x10,%esp
c000c822:	85 c0                	test   %eax,%eax
c000c824:	74 17                	je     c000c83d <buildin_pwd+0x4e>
/work/x86_os_my/shell/buildin_cmd.c:83
			printf("%s\n", final_path);
c000c826:	83 ec 08             	sub    $0x8,%esp
c000c829:	68 c0 36 01 c0       	push   $0xc00136c0
c000c82e:	68 45 ff 00 c0       	push   $0xc000ff45
c000c833:	e8 1d 9a ff ff       	call   c0006255 <printf>
c000c838:	83 c4 10             	add    $0x10,%esp
c000c83b:	eb 10                	jmp    c000c84d <buildin_pwd+0x5e>
/work/x86_os_my/shell/buildin_cmd.c:85
		} else {
			printf("pwd: get current work directory failed.\n");
c000c83d:	83 ec 0c             	sub    $0xc,%esp
c000c840:	68 4c ff 00 c0       	push   $0xc000ff4c
c000c845:	e8 0b 9a ff ff       	call   c0006255 <printf>
c000c84a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:88
		}
	}
}
c000c84d:	c9                   	leave  
c000c84e:	c3                   	ret    

c000c84f <buildin_cd>:
buildin_cd():
/work/x86_os_my/shell/buildin_cmd.c:91

/* cd命令的内建函数 */
char* buildin_cd(uint32_t argc, char** argv) {
c000c84f:	55                   	push   %ebp
c000c850:	89 e5                	mov    %esp,%ebp
c000c852:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/shell/buildin_cmd.c:92
	if (argc > 2) {
c000c855:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c000c859:	76 17                	jbe    c000c872 <buildin_cd+0x23>
/work/x86_os_my/shell/buildin_cmd.c:93
		printf("cd: only support 1 argument!\n");
c000c85b:	83 ec 0c             	sub    $0xc,%esp
c000c85e:	68 75 ff 00 c0       	push   $0xc000ff75
c000c863:	e8 ed 99 ff ff       	call   c0006255 <printf>
c000c868:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:94
		return NULL;
c000c86b:	b8 00 00 00 00       	mov    $0x0,%eax
c000c870:	eb 65                	jmp    c000c8d7 <buildin_cd+0x88>
/work/x86_os_my/shell/buildin_cmd.c:98
	}

	/* 若是只键入cd而无参数,直接返回到根目录. */
	if (argc == 1) {
c000c872:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c000c876:	75 10                	jne    c000c888 <buildin_cd+0x39>
/work/x86_os_my/shell/buildin_cmd.c:99
		final_path[0] = '/';
c000c878:	c6 05 c0 36 01 c0 2f 	movb   $0x2f,0xc00136c0
/work/x86_os_my/shell/buildin_cmd.c:100
		final_path[1] = 0;
c000c87f:	c6 05 c1 36 01 c0 00 	movb   $0x0,0xc00136c1
c000c886:	eb 19                	jmp    c000c8a1 <buildin_cd+0x52>
/work/x86_os_my/shell/buildin_cmd.c:102
	} else {
		make_clear_abs_path(argv[1], final_path);
c000c888:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c88b:	83 c0 04             	add    $0x4,%eax
c000c88e:	8b 00                	mov    (%eax),%eax
c000c890:	83 ec 08             	sub    $0x8,%esp
c000c893:	68 c0 36 01 c0       	push   $0xc00136c0
c000c898:	50                   	push   %eax
c000c899:	e8 98 fe ff ff       	call   c000c736 <make_clear_abs_path>
c000c89e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:105
	}

	if (chdir(final_path) == -1) {
c000c8a1:	83 ec 0c             	sub    $0xc,%esp
c000c8a4:	68 c0 36 01 c0       	push   $0xc00136c0
c000c8a9:	e8 46 95 ff ff       	call   c0005df4 <chdir>
c000c8ae:	83 c4 10             	add    $0x10,%esp
c000c8b1:	83 f8 ff             	cmp    $0xffffffff,%eax
c000c8b4:	75 1c                	jne    c000c8d2 <buildin_cd+0x83>
/work/x86_os_my/shell/buildin_cmd.c:106
		printf("cd: no such directory %s\n", final_path);
c000c8b6:	83 ec 08             	sub    $0x8,%esp
c000c8b9:	68 c0 36 01 c0       	push   $0xc00136c0
c000c8be:	68 93 ff 00 c0       	push   $0xc000ff93
c000c8c3:	e8 8d 99 ff ff       	call   c0006255 <printf>
c000c8c8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:107
		return NULL;
c000c8cb:	b8 00 00 00 00       	mov    $0x0,%eax
c000c8d0:	eb 05                	jmp    c000c8d7 <buildin_cd+0x88>
/work/x86_os_my/shell/buildin_cmd.c:109
	}
	return final_path;
c000c8d2:	b8 c0 36 01 c0       	mov    $0xc00136c0,%eax
/work/x86_os_my/shell/buildin_cmd.c:110
}
c000c8d7:	c9                   	leave  
c000c8d8:	c3                   	ret    

c000c8d9 <buildin_ls>:
buildin_ls():
/work/x86_os_my/shell/buildin_cmd.c:113

/* ls命令的内建函数 */
void buildin_ls(uint32_t argc, char** argv) {
c000c8d9:	55                   	push   %ebp
c000c8da:	89 e5                	mov    %esp,%ebp
c000c8dc:	57                   	push   %edi
c000c8dd:	53                   	push   %ebx
c000c8de:	81 ec 30 02 00 00    	sub    $0x230,%esp
/work/x86_os_my/shell/buildin_cmd.c:114
	char* pathname = NULL;
c000c8e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:116
	struct stat file_stat;
	memset(&file_stat, 0, sizeof(struct stat));
c000c8eb:	83 ec 04             	sub    $0x4,%esp
c000c8ee:	6a 0c                	push   $0xc
c000c8f0:	6a 00                	push   $0x0
c000c8f2:	8d 45 c8             	lea    -0x38(%ebp),%eax
c000c8f5:	50                   	push   %eax
c000c8f6:	e8 6a 71 ff ff       	call   c0003a65 <memset>
c000c8fb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:117
	bool long_info = false;
c000c8fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:118
	uint32_t arg_path_nr = 0;
c000c905:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:119
	uint32_t arg_idx = 1;   // 跨过argv[0],argv[0]是字符串“ls”
c000c90c:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:120
	while (arg_idx < argc) {
c000c913:	e9 ec 00 00 00       	jmp    c000ca04 <buildin_ls+0x12b>
/work/x86_os_my/shell/buildin_cmd.c:121
		if (argv[arg_idx][0] == '-') {	  // 如果是选项,单词的首字符是-
c000c918:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000c91b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000c922:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c925:	01 d0                	add    %edx,%eax
c000c927:	8b 00                	mov    (%eax),%eax
c000c929:	0f b6 00             	movzbl (%eax),%eax
c000c92c:	3c 2d                	cmp    $0x2d,%al
c000c92e:	0f 85 94 00 00 00    	jne    c000c9c8 <buildin_ls+0xef>
/work/x86_os_my/shell/buildin_cmd.c:122
			if (!strcmp("-l", argv[arg_idx])) {         // 如果是参数-l
c000c934:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000c937:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000c93e:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c941:	01 d0                	add    %edx,%eax
c000c943:	8b 00                	mov    (%eax),%eax
c000c945:	83 ec 08             	sub    $0x8,%esp
c000c948:	50                   	push   %eax
c000c949:	68 ad ff 00 c0       	push   $0xc000ffad
c000c94e:	e8 e7 72 ff ff       	call   c0003c3a <strcmp>
c000c953:	83 c4 10             	add    $0x10,%esp
c000c956:	84 c0                	test   %al,%al
c000c958:	75 0c                	jne    c000c966 <buildin_ls+0x8d>
/work/x86_os_my/shell/buildin_cmd.c:123
				long_info = true;
c000c95a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c000c961:	e9 9a 00 00 00       	jmp    c000ca00 <buildin_ls+0x127>
/work/x86_os_my/shell/buildin_cmd.c:124
			} else if (!strcmp("-h", argv[arg_idx])) {   // 参数-h
c000c966:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000c969:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000c970:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c973:	01 d0                	add    %edx,%eax
c000c975:	8b 00                	mov    (%eax),%eax
c000c977:	83 ec 08             	sub    $0x8,%esp
c000c97a:	50                   	push   %eax
c000c97b:	68 b0 ff 00 c0       	push   $0xc000ffb0
c000c980:	e8 b5 72 ff ff       	call   c0003c3a <strcmp>
c000c985:	83 c4 10             	add    $0x10,%esp
c000c988:	84 c0                	test   %al,%al
c000c98a:	75 15                	jne    c000c9a1 <buildin_ls+0xc8>
/work/x86_os_my/shell/buildin_cmd.c:125
				printf("usage: -l list all infomation about the file.\n-h for help\nlist all files in the current dirctory if no option\n");
c000c98c:	83 ec 0c             	sub    $0xc,%esp
c000c98f:	68 b4 ff 00 c0       	push   $0xc000ffb4
c000c994:	e8 bc 98 ff ff       	call   c0006255 <printf>
c000c999:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:126
				return;
c000c99c:	e9 f2 02 00 00       	jmp    c000cc93 <buildin_ls+0x3ba>
/work/x86_os_my/shell/buildin_cmd.c:128
			} else {	// 只支持-h -l两个选项
				printf("ls: invalid option %s\nTry `ls -h' for more information.\n", argv[arg_idx]);
c000c9a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000c9a4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000c9ab:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c9ae:	01 d0                	add    %edx,%eax
c000c9b0:	8b 00                	mov    (%eax),%eax
c000c9b2:	83 ec 08             	sub    $0x8,%esp
c000c9b5:	50                   	push   %eax
c000c9b6:	68 24 00 01 c0       	push   $0xc0010024
c000c9bb:	e8 95 98 ff ff       	call   c0006255 <printf>
c000c9c0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:129
				return;
c000c9c3:	e9 cb 02 00 00       	jmp    c000cc93 <buildin_ls+0x3ba>
/work/x86_os_my/shell/buildin_cmd.c:132
			}
		} else {	     // ls的路径参数
			if (arg_path_nr == 0) {
c000c9c8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c000c9cc:	75 1d                	jne    c000c9eb <buildin_ls+0x112>
/work/x86_os_my/shell/buildin_cmd.c:133
				pathname = argv[arg_idx];
c000c9ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000c9d1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000c9d8:	8b 45 0c             	mov    0xc(%ebp),%eax
c000c9db:	01 d0                	add    %edx,%eax
c000c9dd:	8b 00                	mov    (%eax),%eax
c000c9df:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:134
				arg_path_nr = 1;
c000c9e2:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
c000c9e9:	eb 15                	jmp    c000ca00 <buildin_ls+0x127>
/work/x86_os_my/shell/buildin_cmd.c:136
			} else {
				printf("ls: only support one path\n");
c000c9eb:	83 ec 0c             	sub    $0xc,%esp
c000c9ee:	68 5d 00 01 c0       	push   $0xc001005d
c000c9f3:	e8 5d 98 ff ff       	call   c0006255 <printf>
c000c9f8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:137
				return;
c000c9fb:	e9 93 02 00 00       	jmp    c000cc93 <buildin_ls+0x3ba>
/work/x86_os_my/shell/buildin_cmd.c:140
			}
		}
		arg_idx++;
c000ca00:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:120
	struct stat file_stat;
	memset(&file_stat, 0, sizeof(struct stat));
	bool long_info = false;
	uint32_t arg_path_nr = 0;
	uint32_t arg_idx = 1;   // 跨过argv[0],argv[0]是字符串“ls”
	while (arg_idx < argc) {
c000ca04:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000ca07:	3b 45 08             	cmp    0x8(%ebp),%eax
c000ca0a:	0f 82 08 ff ff ff    	jb     c000c918 <buildin_ls+0x3f>
/work/x86_os_my/shell/buildin_cmd.c:143
			}
		}
		arg_idx++;
	}

	if (pathname == NULL) {	 // 若只输入了ls 或 ls -l,没有输入操作路径,默认以当前路径的绝对路径为参数.
c000ca10:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000ca14:	75 37                	jne    c000ca4d <buildin_ls+0x174>
/work/x86_os_my/shell/buildin_cmd.c:144
		if (NULL != getcwd(final_path, MAX_PATH_LEN)) {
c000ca16:	83 ec 08             	sub    $0x8,%esp
c000ca19:	68 00 02 00 00       	push   $0x200
c000ca1e:	68 c0 36 01 c0       	push   $0xc00136c0
c000ca23:	e8 3f 92 ff ff       	call   c0005c67 <getcwd>
c000ca28:	83 c4 10             	add    $0x10,%esp
c000ca2b:	85 c0                	test   %eax,%eax
c000ca2d:	74 09                	je     c000ca38 <buildin_ls+0x15f>
/work/x86_os_my/shell/buildin_cmd.c:145
			pathname = final_path;
c000ca2f:	c7 45 f4 c0 36 01 c0 	movl   $0xc00136c0,-0xc(%ebp)
c000ca36:	eb 2f                	jmp    c000ca67 <buildin_ls+0x18e>
/work/x86_os_my/shell/buildin_cmd.c:147
		} else {
			printf("ls: getcwd for default path failed\n");
c000ca38:	83 ec 0c             	sub    $0xc,%esp
c000ca3b:	68 78 00 01 c0       	push   $0xc0010078
c000ca40:	e8 10 98 ff ff       	call   c0006255 <printf>
c000ca45:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:148
			return;
c000ca48:	e9 46 02 00 00       	jmp    c000cc93 <buildin_ls+0x3ba>
/work/x86_os_my/shell/buildin_cmd.c:151
		}
	} else {
		make_clear_abs_path(pathname, final_path);
c000ca4d:	83 ec 08             	sub    $0x8,%esp
c000ca50:	68 c0 36 01 c0       	push   $0xc00136c0
c000ca55:	ff 75 f4             	pushl  -0xc(%ebp)
c000ca58:	e8 d9 fc ff ff       	call   c000c736 <make_clear_abs_path>
c000ca5d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:152
		pathname = final_path;
c000ca60:	c7 45 f4 c0 36 01 c0 	movl   $0xc00136c0,-0xc(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:155
	}

	if (stat(pathname, &file_stat) == -1) {
c000ca67:	83 ec 08             	sub    $0x8,%esp
c000ca6a:	8d 45 c8             	lea    -0x38(%ebp),%eax
c000ca6d:	50                   	push   %eax
c000ca6e:	ff 75 f4             	pushl  -0xc(%ebp)
c000ca71:	e8 5c 93 ff ff       	call   c0005dd2 <stat>
c000ca76:	83 c4 10             	add    $0x10,%esp
c000ca79:	83 f8 ff             	cmp    $0xffffffff,%eax
c000ca7c:	75 18                	jne    c000ca96 <buildin_ls+0x1bd>
/work/x86_os_my/shell/buildin_cmd.c:156
		printf("ls: cannot access %s: No such file or directory\n", pathname);
c000ca7e:	83 ec 08             	sub    $0x8,%esp
c000ca81:	ff 75 f4             	pushl  -0xc(%ebp)
c000ca84:	68 9c 00 01 c0       	push   $0xc001009c
c000ca89:	e8 c7 97 ff ff       	call   c0006255 <printf>
c000ca8e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:157
		return;
c000ca91:	e9 fd 01 00 00       	jmp    c000cc93 <buildin_ls+0x3ba>
/work/x86_os_my/shell/buildin_cmd.c:159
	}
	if (file_stat.st_filetype == FT_DIRECTORY) {
c000ca96:	8b 45 d0             	mov    -0x30(%ebp),%eax
c000ca99:	83 f8 02             	cmp    $0x2,%eax
c000ca9c:	0f 85 be 01 00 00    	jne    c000cc60 <buildin_ls+0x387>
/work/x86_os_my/shell/buildin_cmd.c:160
		struct dir* dir = opendir(pathname);
c000caa2:	83 ec 0c             	sub    $0xc,%esp
c000caa5:	ff 75 f4             	pushl  -0xc(%ebp)
c000caa8:	e8 8c 92 ff ff       	call   c0005d39 <opendir>
c000caad:	83 c4 10             	add    $0x10,%esp
c000cab0:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:161
		struct dir_entry* dir_e = NULL;
c000cab3:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:162
		char sub_pathname[MAX_PATH_LEN] = {0};
c000caba:	8d 95 c8 fd ff ff    	lea    -0x238(%ebp),%edx
c000cac0:	b8 00 00 00 00       	mov    $0x0,%eax
c000cac5:	b9 80 00 00 00       	mov    $0x80,%ecx
c000caca:	89 d7                	mov    %edx,%edi
c000cacc:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/shell/buildin_cmd.c:163
		uint32_t pathname_len = strlen(pathname);
c000cace:	83 ec 0c             	sub    $0xc,%esp
c000cad1:	ff 75 f4             	pushl  -0xc(%ebp)
c000cad4:	e8 16 71 ff ff       	call   c0003bef <strlen>
c000cad9:	83 c4 10             	add    $0x10,%esp
c000cadc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:164
		uint32_t last_char_idx = pathname_len - 1;
c000cadf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000cae2:	83 e8 01             	sub    $0x1,%eax
c000cae5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:165
		memcpy(sub_pathname, pathname, pathname_len);
c000cae8:	83 ec 04             	sub    $0x4,%esp
c000caeb:	ff 75 e4             	pushl  -0x1c(%ebp)
c000caee:	ff 75 f4             	pushl  -0xc(%ebp)
c000caf1:	8d 85 c8 fd ff ff    	lea    -0x238(%ebp),%eax
c000caf7:	50                   	push   %eax
c000caf8:	e8 ba 6f ff ff       	call   c0003ab7 <memcpy>
c000cafd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:166
		if (sub_pathname[last_char_idx] != '/') {
c000cb00:	8d 95 c8 fd ff ff    	lea    -0x238(%ebp),%edx
c000cb06:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000cb09:	01 d0                	add    %edx,%eax
c000cb0b:	0f b6 00             	movzbl (%eax),%eax
c000cb0e:	3c 2f                	cmp    $0x2f,%al
c000cb10:	74 12                	je     c000cb24 <buildin_ls+0x24b>
/work/x86_os_my/shell/buildin_cmd.c:167
			sub_pathname[pathname_len] = '/';
c000cb12:	8d 95 c8 fd ff ff    	lea    -0x238(%ebp),%edx
c000cb18:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000cb1b:	01 d0                	add    %edx,%eax
c000cb1d:	c6 00 2f             	movb   $0x2f,(%eax)
/work/x86_os_my/shell/buildin_cmd.c:168
			pathname_len++;
c000cb20:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:170
		}
		rewinddir(dir);
c000cb24:	83 ec 0c             	sub    $0xc,%esp
c000cb27:	ff 75 dc             	pushl  -0x24(%ebp)
c000cb2a:	e8 86 92 ff ff       	call   c0005db5 <rewinddir>
c000cb2f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:171
		if (long_info) {
c000cb32:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000cb36:	0f 84 ed 00 00 00    	je     c000cc29 <buildin_ls+0x350>
/work/x86_os_my/shell/buildin_cmd.c:173
			char ftype;
			printf("total: %d\n", file_stat.st_size);
c000cb3c:	8b 45 cc             	mov    -0x34(%ebp),%eax
c000cb3f:	83 ec 08             	sub    $0x8,%esp
c000cb42:	50                   	push   %eax
c000cb43:	68 cd 00 01 c0       	push   $0xc00100cd
c000cb48:	e8 08 97 ff ff       	call   c0006255 <printf>
c000cb4d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:174
			while((dir_e = readdir(dir))) {
c000cb50:	e9 a3 00 00 00       	jmp    c000cbf8 <buildin_ls+0x31f>
/work/x86_os_my/shell/buildin_cmd.c:175
				ftype = 'd';
c000cb55:	c6 45 e3 64          	movb   $0x64,-0x1d(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:176
				if (dir_e->f_type == FT_REGULAR) {
c000cb59:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000cb5c:	8b 40 14             	mov    0x14(%eax),%eax
c000cb5f:	83 f8 01             	cmp    $0x1,%eax
c000cb62:	75 04                	jne    c000cb68 <buildin_ls+0x28f>
/work/x86_os_my/shell/buildin_cmd.c:177
					ftype = '-';
c000cb64:	c6 45 e3 2d          	movb   $0x2d,-0x1d(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:179
				}
				sub_pathname[pathname_len] = 0;
c000cb68:	8d 95 c8 fd ff ff    	lea    -0x238(%ebp),%edx
c000cb6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000cb71:	01 d0                	add    %edx,%eax
c000cb73:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/shell/buildin_cmd.c:180
				strcat(sub_pathname, dir_e->filename);
c000cb76:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000cb79:	83 ec 08             	sub    $0x8,%esp
c000cb7c:	50                   	push   %eax
c000cb7d:	8d 85 c8 fd ff ff    	lea    -0x238(%ebp),%eax
c000cb83:	50                   	push   %eax
c000cb84:	e8 e0 71 ff ff       	call   c0003d69 <strcat>
c000cb89:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:181
				memset(&file_stat, 0, sizeof(struct stat));
c000cb8c:	83 ec 04             	sub    $0x4,%esp
c000cb8f:	6a 0c                	push   $0xc
c000cb91:	6a 00                	push   $0x0
c000cb93:	8d 45 c8             	lea    -0x38(%ebp),%eax
c000cb96:	50                   	push   %eax
c000cb97:	e8 c9 6e ff ff       	call   c0003a65 <memset>
c000cb9c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:182
				if (stat(sub_pathname, &file_stat) == -1) {
c000cb9f:	83 ec 08             	sub    $0x8,%esp
c000cba2:	8d 45 c8             	lea    -0x38(%ebp),%eax
c000cba5:	50                   	push   %eax
c000cba6:	8d 85 c8 fd ff ff    	lea    -0x238(%ebp),%eax
c000cbac:	50                   	push   %eax
c000cbad:	e8 20 92 ff ff       	call   c0005dd2 <stat>
c000cbb2:	83 c4 10             	add    $0x10,%esp
c000cbb5:	83 f8 ff             	cmp    $0xffffffff,%eax
c000cbb8:	75 1a                	jne    c000cbd4 <buildin_ls+0x2fb>
/work/x86_os_my/shell/buildin_cmd.c:183
					printf("ls: cannot access %s: No such file or directory\n", dir_e->filename);
c000cbba:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000cbbd:	83 ec 08             	sub    $0x8,%esp
c000cbc0:	50                   	push   %eax
c000cbc1:	68 9c 00 01 c0       	push   $0xc001009c
c000cbc6:	e8 8a 96 ff ff       	call   c0006255 <printf>
c000cbcb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:184
					return;
c000cbce:	90                   	nop
c000cbcf:	e9 bf 00 00 00       	jmp    c000cc93 <buildin_ls+0x3ba>
/work/x86_os_my/shell/buildin_cmd.c:186
				}
				printf("%c  %d  %d  %s\n", ftype, dir_e->i_no, file_stat.st_size, dir_e->filename);
c000cbd4:	8b 5d d8             	mov    -0x28(%ebp),%ebx
c000cbd7:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c000cbda:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000cbdd:	8b 50 10             	mov    0x10(%eax),%edx
c000cbe0:	0f be 45 e3          	movsbl -0x1d(%ebp),%eax
c000cbe4:	83 ec 0c             	sub    $0xc,%esp
c000cbe7:	53                   	push   %ebx
c000cbe8:	51                   	push   %ecx
c000cbe9:	52                   	push   %edx
c000cbea:	50                   	push   %eax
c000cbeb:	68 d8 00 01 c0       	push   $0xc00100d8
c000cbf0:	e8 60 96 ff ff       	call   c0006255 <printf>
c000cbf5:	83 c4 20             	add    $0x20,%esp
/work/x86_os_my/shell/buildin_cmd.c:174
		}
		rewinddir(dir);
		if (long_info) {
			char ftype;
			printf("total: %d\n", file_stat.st_size);
			while((dir_e = readdir(dir))) {
c000cbf8:	83 ec 0c             	sub    $0xc,%esp
c000cbfb:	ff 75 dc             	pushl  -0x24(%ebp)
c000cbfe:	e8 93 91 ff ff       	call   c0005d96 <readdir>
c000cc03:	83 c4 10             	add    $0x10,%esp
c000cc06:	89 45 d8             	mov    %eax,-0x28(%ebp)
c000cc09:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c000cc0d:	0f 85 42 ff ff ff    	jne    c000cb55 <buildin_ls+0x27c>
c000cc13:	eb 3b                	jmp    c000cc50 <buildin_ls+0x377>
/work/x86_os_my/shell/buildin_cmd.c:190
				}
				printf("%c  %d  %d  %s\n", ftype, dir_e->i_no, file_stat.st_size, dir_e->filename);
			}
		} else {
			while((dir_e = readdir(dir))) {
				printf("%s ", dir_e->filename);
c000cc15:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000cc18:	83 ec 08             	sub    $0x8,%esp
c000cc1b:	50                   	push   %eax
c000cc1c:	68 e8 00 01 c0       	push   $0xc00100e8
c000cc21:	e8 2f 96 ff ff       	call   c0006255 <printf>
c000cc26:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:189
					return;
				}
				printf("%c  %d  %d  %s\n", ftype, dir_e->i_no, file_stat.st_size, dir_e->filename);
			}
		} else {
			while((dir_e = readdir(dir))) {
c000cc29:	83 ec 0c             	sub    $0xc,%esp
c000cc2c:	ff 75 dc             	pushl  -0x24(%ebp)
c000cc2f:	e8 62 91 ff ff       	call   c0005d96 <readdir>
c000cc34:	83 c4 10             	add    $0x10,%esp
c000cc37:	89 45 d8             	mov    %eax,-0x28(%ebp)
c000cc3a:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c000cc3e:	75 d5                	jne    c000cc15 <buildin_ls+0x33c>
/work/x86_os_my/shell/buildin_cmd.c:192
				printf("%s ", dir_e->filename);
			}
			printf("\n");
c000cc40:	83 ec 0c             	sub    $0xc,%esp
c000cc43:	68 ec 00 01 c0       	push   $0xc00100ec
c000cc48:	e8 08 96 ff ff       	call   c0006255 <printf>
c000cc4d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:194 (discriminator 1)
		}
		closedir(dir);
c000cc50:	83 ec 0c             	sub    $0xc,%esp
c000cc53:	ff 75 dc             	pushl  -0x24(%ebp)
c000cc56:	e8 fd 90 ff ff       	call   c0005d58 <closedir>
c000cc5b:	83 c4 10             	add    $0x10,%esp
c000cc5e:	eb 33                	jmp    c000cc93 <buildin_ls+0x3ba>
/work/x86_os_my/shell/buildin_cmd.c:196
	} else {
		if (long_info) {
c000cc60:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000cc64:	74 1a                	je     c000cc80 <buildin_ls+0x3a7>
/work/x86_os_my/shell/buildin_cmd.c:197
			printf("-  %d  %d  %s\n", file_stat.st_ino, file_stat.st_size, pathname);
c000cc66:	8b 55 cc             	mov    -0x34(%ebp),%edx
c000cc69:	8b 45 c8             	mov    -0x38(%ebp),%eax
c000cc6c:	ff 75 f4             	pushl  -0xc(%ebp)
c000cc6f:	52                   	push   %edx
c000cc70:	50                   	push   %eax
c000cc71:	68 ee 00 01 c0       	push   $0xc00100ee
c000cc76:	e8 da 95 ff ff       	call   c0006255 <printf>
c000cc7b:	83 c4 10             	add    $0x10,%esp
c000cc7e:	eb 13                	jmp    c000cc93 <buildin_ls+0x3ba>
/work/x86_os_my/shell/buildin_cmd.c:199
		} else {
			printf("%s\n", pathname);
c000cc80:	83 ec 08             	sub    $0x8,%esp
c000cc83:	ff 75 f4             	pushl  -0xc(%ebp)
c000cc86:	68 45 ff 00 c0       	push   $0xc000ff45
c000cc8b:	e8 c5 95 ff ff       	call   c0006255 <printf>
c000cc90:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:202
		}
	}
}
c000cc93:	8d 65 f8             	lea    -0x8(%ebp),%esp
c000cc96:	5b                   	pop    %ebx
c000cc97:	5f                   	pop    %edi
c000cc98:	5d                   	pop    %ebp
c000cc99:	c3                   	ret    

c000cc9a <buildin_ps>:
buildin_ps():
/work/x86_os_my/shell/buildin_cmd.c:205

/* ps命令内建函数 */
void buildin_ps(uint32_t argc, char** argv UNUSED) {
c000cc9a:	55                   	push   %ebp
c000cc9b:	89 e5                	mov    %esp,%ebp
c000cc9d:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/shell/buildin_cmd.c:206
	if (argc != 1) {
c000cca0:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c000cca4:	74 12                	je     c000ccb8 <buildin_ps+0x1e>
/work/x86_os_my/shell/buildin_cmd.c:207
		printf("ps: no argument support!\n");
c000cca6:	83 ec 0c             	sub    $0xc,%esp
c000cca9:	68 fd 00 01 c0       	push   $0xc00100fd
c000ccae:	e8 a2 95 ff ff       	call   c0006255 <printf>
c000ccb3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:208
		return;
c000ccb6:	eb 05                	jmp    c000ccbd <buildin_ps+0x23>
/work/x86_os_my/shell/buildin_cmd.c:210
	}
	ps();
c000ccb8:	e8 56 91 ff ff       	call   c0005e13 <ps>
/work/x86_os_my/shell/buildin_cmd.c:211
}
c000ccbd:	c9                   	leave  
c000ccbe:	c3                   	ret    

c000ccbf <buildin_clear>:
buildin_clear():
/work/x86_os_my/shell/buildin_cmd.c:214

/* clear命令内建函数 */
void buildin_clear(uint32_t argc, char** argv UNUSED) {
c000ccbf:	55                   	push   %ebp
c000ccc0:	89 e5                	mov    %esp,%ebp
c000ccc2:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/shell/buildin_cmd.c:215
	if (argc != 1) {
c000ccc5:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c000ccc9:	74 12                	je     c000ccdd <buildin_clear+0x1e>
/work/x86_os_my/shell/buildin_cmd.c:216
		printf("clear: no argument support!\n");
c000cccb:	83 ec 0c             	sub    $0xc,%esp
c000ccce:	68 17 01 01 c0       	push   $0xc0010117
c000ccd3:	e8 7d 95 ff ff       	call   c0006255 <printf>
c000ccd8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:217
		return;
c000ccdb:	eb 05                	jmp    c000cce2 <buildin_clear+0x23>
/work/x86_os_my/shell/buildin_cmd.c:219
	}
	clear();
c000ccdd:	e8 72 8f ff ff       	call   c0005c54 <clear>
/work/x86_os_my/shell/buildin_cmd.c:220
}
c000cce2:	c9                   	leave  
c000cce3:	c3                   	ret    

c000cce4 <buildin_mkdir>:
buildin_mkdir():
/work/x86_os_my/shell/buildin_cmd.c:223

/* mkdir命令内建函数 */
int32_t buildin_mkdir(uint32_t argc, char** argv) {
c000cce4:	55                   	push   %ebp
c000cce5:	89 e5                	mov    %esp,%ebp
c000cce7:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/shell/buildin_cmd.c:224
	int32_t ret = -1;
c000ccea:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:225
	if (argc != 2) {
c000ccf1:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c000ccf5:	74 12                	je     c000cd09 <buildin_mkdir+0x25>
/work/x86_os_my/shell/buildin_cmd.c:226
		printf("mkdir: only support 1 argument!\n");
c000ccf7:	83 ec 0c             	sub    $0xc,%esp
c000ccfa:	68 34 01 01 c0       	push   $0xc0010134
c000ccff:	e8 51 95 ff ff       	call   c0006255 <printf>
c000cd04:	83 c4 10             	add    $0x10,%esp
c000cd07:	eb 68                	jmp    c000cd71 <buildin_mkdir+0x8d>
/work/x86_os_my/shell/buildin_cmd.c:228
	} else {
		make_clear_abs_path(argv[1], final_path);
c000cd09:	8b 45 0c             	mov    0xc(%ebp),%eax
c000cd0c:	83 c0 04             	add    $0x4,%eax
c000cd0f:	8b 00                	mov    (%eax),%eax
c000cd11:	83 ec 08             	sub    $0x8,%esp
c000cd14:	68 c0 36 01 c0       	push   $0xc00136c0
c000cd19:	50                   	push   %eax
c000cd1a:	e8 17 fa ff ff       	call   c000c736 <make_clear_abs_path>
c000cd1f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:230
		/* 若创建的不是根目录 */
		if (strcmp("/", final_path)) {
c000cd22:	83 ec 08             	sub    $0x8,%esp
c000cd25:	68 c0 36 01 c0       	push   $0xc00136c0
c000cd2a:	68 23 ff 00 c0       	push   $0xc000ff23
c000cd2f:	e8 06 6f ff ff       	call   c0003c3a <strcmp>
c000cd34:	83 c4 10             	add    $0x10,%esp
c000cd37:	84 c0                	test   %al,%al
c000cd39:	74 36                	je     c000cd71 <buildin_mkdir+0x8d>
/work/x86_os_my/shell/buildin_cmd.c:231
			if (mkdir(final_path) == 0) {
c000cd3b:	83 ec 0c             	sub    $0xc,%esp
c000cd3e:	68 c0 36 01 c0       	push   $0xc00136c0
c000cd43:	e8 d2 8f ff ff       	call   c0005d1a <mkdir>
c000cd48:	83 c4 10             	add    $0x10,%esp
c000cd4b:	85 c0                	test   %eax,%eax
c000cd4d:	75 09                	jne    c000cd58 <buildin_mkdir+0x74>
/work/x86_os_my/shell/buildin_cmd.c:232
				ret = 0;
c000cd4f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000cd56:	eb 19                	jmp    c000cd71 <buildin_mkdir+0x8d>
/work/x86_os_my/shell/buildin_cmd.c:234
			} else {
				printf("mkdir: create directory %s failed.\n", argv[1]);
c000cd58:	8b 45 0c             	mov    0xc(%ebp),%eax
c000cd5b:	83 c0 04             	add    $0x4,%eax
c000cd5e:	8b 00                	mov    (%eax),%eax
c000cd60:	83 ec 08             	sub    $0x8,%esp
c000cd63:	50                   	push   %eax
c000cd64:	68 58 01 01 c0       	push   $0xc0010158
c000cd69:	e8 e7 94 ff ff       	call   c0006255 <printf>
c000cd6e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:238
			}
		}
	}
	return ret;
c000cd71:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/shell/buildin_cmd.c:239
}
c000cd74:	c9                   	leave  
c000cd75:	c3                   	ret    

c000cd76 <buildin_rmdir>:
buildin_rmdir():
/work/x86_os_my/shell/buildin_cmd.c:242

/* rmdir命令内建函数 */
int32_t buildin_rmdir(uint32_t argc, char** argv) {
c000cd76:	55                   	push   %ebp
c000cd77:	89 e5                	mov    %esp,%ebp
c000cd79:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/shell/buildin_cmd.c:243
	int32_t ret = -1;
c000cd7c:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:244
	if (argc != 2) {
c000cd83:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c000cd87:	74 12                	je     c000cd9b <buildin_rmdir+0x25>
/work/x86_os_my/shell/buildin_cmd.c:245
	printf("rmdir: only support 1 argument!\n");
c000cd89:	83 ec 0c             	sub    $0xc,%esp
c000cd8c:	68 7c 01 01 c0       	push   $0xc001017c
c000cd91:	e8 bf 94 ff ff       	call   c0006255 <printf>
c000cd96:	83 c4 10             	add    $0x10,%esp
c000cd99:	eb 68                	jmp    c000ce03 <buildin_rmdir+0x8d>
/work/x86_os_my/shell/buildin_cmd.c:247
	} else {
		make_clear_abs_path(argv[1], final_path);
c000cd9b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000cd9e:	83 c0 04             	add    $0x4,%eax
c000cda1:	8b 00                	mov    (%eax),%eax
c000cda3:	83 ec 08             	sub    $0x8,%esp
c000cda6:	68 c0 36 01 c0       	push   $0xc00136c0
c000cdab:	50                   	push   %eax
c000cdac:	e8 85 f9 ff ff       	call   c000c736 <make_clear_abs_path>
c000cdb1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:249
		/* 若删除的不是根目录 */
		if (strcmp("/", final_path)) {
c000cdb4:	83 ec 08             	sub    $0x8,%esp
c000cdb7:	68 c0 36 01 c0       	push   $0xc00136c0
c000cdbc:	68 23 ff 00 c0       	push   $0xc000ff23
c000cdc1:	e8 74 6e ff ff       	call   c0003c3a <strcmp>
c000cdc6:	83 c4 10             	add    $0x10,%esp
c000cdc9:	84 c0                	test   %al,%al
c000cdcb:	74 36                	je     c000ce03 <buildin_rmdir+0x8d>
/work/x86_os_my/shell/buildin_cmd.c:250
			if (rmdir(final_path) == 0) {
c000cdcd:	83 ec 0c             	sub    $0xc,%esp
c000cdd0:	68 c0 36 01 c0       	push   $0xc00136c0
c000cdd5:	e8 9d 8f ff ff       	call   c0005d77 <rmdir>
c000cdda:	83 c4 10             	add    $0x10,%esp
c000cddd:	85 c0                	test   %eax,%eax
c000cddf:	75 09                	jne    c000cdea <buildin_rmdir+0x74>
/work/x86_os_my/shell/buildin_cmd.c:251
				ret = 0;
c000cde1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000cde8:	eb 19                	jmp    c000ce03 <buildin_rmdir+0x8d>
/work/x86_os_my/shell/buildin_cmd.c:253
			} else {
				printf("rmdir: remove %s failed.\n", argv[1]);
c000cdea:	8b 45 0c             	mov    0xc(%ebp),%eax
c000cded:	83 c0 04             	add    $0x4,%eax
c000cdf0:	8b 00                	mov    (%eax),%eax
c000cdf2:	83 ec 08             	sub    $0x8,%esp
c000cdf5:	50                   	push   %eax
c000cdf6:	68 9d 01 01 c0       	push   $0xc001019d
c000cdfb:	e8 55 94 ff ff       	call   c0006255 <printf>
c000ce00:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:257
			}
		}
	}
	return ret;
c000ce03:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/shell/buildin_cmd.c:258
}
c000ce06:	c9                   	leave  
c000ce07:	c3                   	ret    

c000ce08 <buildin_rm>:
buildin_rm():
/work/x86_os_my/shell/buildin_cmd.c:261

/* rm命令内建函数 */
int32_t buildin_rm(uint32_t argc, char** argv) {
c000ce08:	55                   	push   %ebp
c000ce09:	89 e5                	mov    %esp,%ebp
c000ce0b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/shell/buildin_cmd.c:262
	int32_t ret = -1;
c000ce0e:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/shell/buildin_cmd.c:263
	if (argc != 2) {
c000ce15:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c000ce19:	74 12                	je     c000ce2d <buildin_rm+0x25>
/work/x86_os_my/shell/buildin_cmd.c:264
		printf("rm: only support 1 argument!\n");
c000ce1b:	83 ec 0c             	sub    $0xc,%esp
c000ce1e:	68 b7 01 01 c0       	push   $0xc00101b7
c000ce23:	e8 2d 94 ff ff       	call   c0006255 <printf>
c000ce28:	83 c4 10             	add    $0x10,%esp
c000ce2b:	eb 68                	jmp    c000ce95 <buildin_rm+0x8d>
/work/x86_os_my/shell/buildin_cmd.c:266
	} else {
		make_clear_abs_path(argv[1], final_path);
c000ce2d:	8b 45 0c             	mov    0xc(%ebp),%eax
c000ce30:	83 c0 04             	add    $0x4,%eax
c000ce33:	8b 00                	mov    (%eax),%eax
c000ce35:	83 ec 08             	sub    $0x8,%esp
c000ce38:	68 c0 36 01 c0       	push   $0xc00136c0
c000ce3d:	50                   	push   %eax
c000ce3e:	e8 f3 f8 ff ff       	call   c000c736 <make_clear_abs_path>
c000ce43:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:268
		/* 若删除的不是根目录 */
		if (strcmp("/", final_path)) {
c000ce46:	83 ec 08             	sub    $0x8,%esp
c000ce49:	68 c0 36 01 c0       	push   $0xc00136c0
c000ce4e:	68 23 ff 00 c0       	push   $0xc000ff23
c000ce53:	e8 e2 6d ff ff       	call   c0003c3a <strcmp>
c000ce58:	83 c4 10             	add    $0x10,%esp
c000ce5b:	84 c0                	test   %al,%al
c000ce5d:	74 36                	je     c000ce95 <buildin_rm+0x8d>
/work/x86_os_my/shell/buildin_cmd.c:269
			if (unlink(final_path) == 0) {
c000ce5f:	83 ec 0c             	sub    $0xc,%esp
c000ce62:	68 c0 36 01 c0       	push   $0xc00136c0
c000ce67:	e8 8f 8e ff ff       	call   c0005cfb <unlink>
c000ce6c:	83 c4 10             	add    $0x10,%esp
c000ce6f:	85 c0                	test   %eax,%eax
c000ce71:	75 09                	jne    c000ce7c <buildin_rm+0x74>
/work/x86_os_my/shell/buildin_cmd.c:270
				ret = 0;
c000ce73:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000ce7a:	eb 19                	jmp    c000ce95 <buildin_rm+0x8d>
/work/x86_os_my/shell/buildin_cmd.c:272
			} else {
				printf("rm: delete %s failed.\n", argv[1]);
c000ce7c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000ce7f:	83 c0 04             	add    $0x4,%eax
c000ce82:	8b 00                	mov    (%eax),%eax
c000ce84:	83 ec 08             	sub    $0x8,%esp
c000ce87:	50                   	push   %eax
c000ce88:	68 d5 01 01 c0       	push   $0xc00101d5
c000ce8d:	e8 c3 93 ff ff       	call   c0006255 <printf>
c000ce92:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/buildin_cmd.c:276
			}
		}
	}
	return ret;
c000ce95:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/shell/buildin_cmd.c:277
}
c000ce98:	c9                   	leave  
c000ce99:	c3                   	ret    

c000ce9a <buildin_help>:
buildin_help():
/work/x86_os_my/shell/buildin_cmd.c:280

/* 显示内建命令列表 */
void buildin_help(uint32_t argc UNUSED, char** argv UNUSED) {
c000ce9a:	55                   	push   %ebp
c000ce9b:	89 e5                	mov    %esp,%ebp
c000ce9d:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/shell/buildin_cmd.c:281
	help();
c000cea0:	e8 1e 90 ff ff       	call   c0005ec3 <help>
/work/x86_os_my/shell/buildin_cmd.c:282
c000cea5:	90                   	nop
c000cea6:	c9                   	leave  
c000cea7:	c3                   	ret    

c000cea8 <segment_load>:
segment_load():
/work/x86_os_my/userprog/exec.c:57
};

/*
参数：文件描述符 fd、段在文件中的字节偏移量 offset、段大小 filesz、段被加载到的虚拟地址 vaddr
功能：将文件描述符 fd 指向的文件中，偏移为 offset，大小为 filesz 的一个"段"，加载到虚拟地址为 vaddr 的内存空间。*/
static bool segment_load(int32_t fd, uint32_t offset, uint32_t filesz, uint32_t vaddr) {
c000cea8:	55                   	push   %ebp
c000cea9:	89 e5                	mov    %esp,%ebp
c000ceab:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/userprog/exec.c:59
	// vaddr地址所在的页的指针（指针的地址是虚拟空间的地址）（指向的空间包含:页的物理地址和属性）指针
	uint32_t vaddr_first_page = vaddr & 0xfffff000;
c000ceae:	8b 45 14             	mov    0x14(%ebp),%eax
c000ceb1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000ceb6:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/userprog/exec.c:60
	uint32_t size_in_first_page = PG_SIZE - (vaddr & 0x00000fff);	// 第一个页中可以用的空间
c000ceb9:	8b 45 14             	mov    0x14(%ebp),%eax
c000cebc:	25 ff 0f 00 00       	and    $0xfff,%eax
c000cec1:	ba 00 10 00 00       	mov    $0x1000,%edx
c000cec6:	29 c2                	sub    %eax,%edx
c000cec8:	89 d0                	mov    %edx,%eax
c000ceca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/userprog/exec.c:61
	uint32_t occupy_pages = 0;
c000cecd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/userprog/exec.c:63
	/* 若一个页框容不下该段 */
	if (filesz > size_in_first_page) {
c000ced4:	8b 45 10             	mov    0x10(%ebp),%eax
c000ced7:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c000ceda:	76 1c                	jbe    c000cef8 <segment_load+0x50>
/work/x86_os_my/userprog/exec.c:64
		uint32_t left_size = filesz - size_in_first_page;
c000cedc:	8b 45 10             	mov    0x10(%ebp),%eax
c000cedf:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c000cee2:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/userprog/exec.c:65
		occupy_pages = DIV_ROUND_UP(left_size, PG_SIZE) + 1;		// 1是指vaddr_first_page
c000cee5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000cee8:	05 ff 0f 00 00       	add    $0xfff,%eax
c000ceed:	c1 e8 0c             	shr    $0xc,%eax
c000cef0:	83 c0 01             	add    $0x1,%eax
c000cef3:	89 45 f4             	mov    %eax,-0xc(%ebp)
c000cef6:	eb 07                	jmp    c000ceff <segment_load+0x57>
/work/x86_os_my/userprog/exec.c:67
	} else {
		occupy_pages = 1;
c000cef8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/userprog/exec.c:71
	}

	/* 为进程分配内存 */
	uint32_t page_idx = 0;
c000ceff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/userprog/exec.c:72
	uint32_t vaddr_page = vaddr_first_page;
c000cf06:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000cf09:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/userprog/exec.c:73
	while (page_idx < occupy_pages) {
c000cf0c:	eb 60                	jmp    c000cf6e <segment_load+0xc6>
/work/x86_os_my/userprog/exec.c:74
		uint32_t* pde = pde_ptr(vaddr_page);	//虚拟地址，指向 页目录项 的指针，指向的空间含：地址和属性
c000cf0e:	83 ec 0c             	sub    $0xc,%esp
c000cf11:	ff 75 ec             	pushl  -0x14(%ebp)
c000cf14:	e8 ad 5a ff ff       	call   c00029c6 <pde_ptr>
c000cf19:	83 c4 10             	add    $0x10,%esp
c000cf1c:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/userprog/exec.c:75
		uint32_t* pte = pte_ptr(vaddr_page);	//虚拟地址，指向 页表项   的指针
c000cf1f:	83 ec 0c             	sub    $0xc,%esp
c000cf22:	ff 75 ec             	pushl  -0x14(%ebp)
c000cf25:	e8 6c 5a ff ff       	call   c0002996 <pte_ptr>
c000cf2a:	83 c4 10             	add    $0x10,%esp
c000cf2d:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/userprog/exec.c:80

		/* 如果pde不存在,或者pte不存在就分配内存.
		 * pde的判断要在pte之前,否则pde若不存在会导致
		 * 判断pte时缺页异常 */
		if (!(*pde & 0x00000001) || !(*pte & 0x00000001)) {	//页目录项或者页表项不存在
c000cf30:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000cf33:	8b 00                	mov    (%eax),%eax
c000cf35:	83 e0 01             	and    $0x1,%eax
c000cf38:	85 c0                	test   %eax,%eax
c000cf3a:	74 0c                	je     c000cf48 <segment_load+0xa0>
/work/x86_os_my/userprog/exec.c:80 (discriminator 1)
c000cf3c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000cf3f:	8b 00                	mov    (%eax),%eax
c000cf41:	83 e0 01             	and    $0x1,%eax
c000cf44:	85 c0                	test   %eax,%eax
c000cf46:	75 1b                	jne    c000cf63 <segment_load+0xbb>
/work/x86_os_my/userprog/exec.c:81
			if (get_a_page(PF_USER, vaddr_page) == NULL) {
c000cf48:	83 ec 08             	sub    $0x8,%esp
c000cf4b:	ff 75 ec             	pushl  -0x14(%ebp)
c000cf4e:	6a 02                	push   $0x2
c000cf50:	e8 6a 5d ff ff       	call   c0002cbf <get_a_page>
c000cf55:	83 c4 10             	add    $0x10,%esp
c000cf58:	85 c0                	test   %eax,%eax
c000cf5a:	75 07                	jne    c000cf63 <segment_load+0xbb>
/work/x86_os_my/userprog/exec.c:82
				return false;
c000cf5c:	b8 00 00 00 00       	mov    $0x0,%eax
c000cf61:	eb 41                	jmp    c000cfa4 <segment_load+0xfc>
/work/x86_os_my/userprog/exec.c:85
			}
		} // 如果原进程的页表已经分配了,利用现有的物理页,直接覆盖进程体
		vaddr_page += PG_SIZE;	//下一页
c000cf63:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
/work/x86_os_my/userprog/exec.c:86
		page_idx++;
c000cf6a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/userprog/exec.c:73
	}

	/* 为进程分配内存 */
	uint32_t page_idx = 0;
	uint32_t vaddr_page = vaddr_first_page;
	while (page_idx < occupy_pages) {
c000cf6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000cf71:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c000cf74:	72 98                	jb     c000cf0e <segment_load+0x66>
/work/x86_os_my/userprog/exec.c:88
			}
		} // 如果原进程的页表已经分配了,利用现有的物理页,直接覆盖进程体
		vaddr_page += PG_SIZE;	//下一页
		page_idx++;
	}
	sys_lseek(fd, offset, SEEK_SET);
c000cf76:	8b 45 0c             	mov    0xc(%ebp),%eax
c000cf79:	83 ec 04             	sub    $0x4,%esp
c000cf7c:	6a 01                	push   $0x1
c000cf7e:	50                   	push   %eax
c000cf7f:	ff 75 08             	pushl  0x8(%ebp)
c000cf82:	e8 12 b1 ff ff       	call   c0008099 <sys_lseek>
c000cf87:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/exec.c:89
	sys_read(fd, (void*)vaddr, filesz);	//读到vaddr处
c000cf8a:	8b 45 14             	mov    0x14(%ebp),%eax
c000cf8d:	83 ec 04             	sub    $0x4,%esp
c000cf90:	ff 75 10             	pushl  0x10(%ebp)
c000cf93:	50                   	push   %eax
c000cf94:	ff 75 08             	pushl  0x8(%ebp)
c000cf97:	e8 b7 af ff ff       	call   c0007f53 <sys_read>
c000cf9c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/exec.c:90
	return true;
c000cf9f:	b8 01 00 00 00       	mov    $0x1,%eax
/work/x86_os_my/userprog/exec.c:91
}
c000cfa4:	c9                   	leave  
c000cfa5:	c3                   	ret    

c000cfa6 <load>:
load():
/work/x86_os_my/userprog/exec.c:95

/* 从文件系统上加载用户程序pathname
 * 成功则返回程序的起始地址，否则返回-1 */
static int32_t load(const char* pathname) {
c000cfa6:	55                   	push   %ebp
c000cfa7:	89 e5                	mov    %esp,%ebp
c000cfa9:	83 ec 78             	sub    $0x78,%esp
/work/x86_os_my/userprog/exec.c:96
	int32_t ret = -1;
c000cfac:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/userprog/exec.c:99
	struct Elf32_Ehdr elf_header;
	struct Elf32_Phdr prog_header;
	memset(&elf_header, 0, sizeof(struct Elf32_Ehdr));
c000cfb3:	83 ec 04             	sub    $0x4,%esp
c000cfb6:	6a 34                	push   $0x34
c000cfb8:	6a 00                	push   $0x0
c000cfba:	8d 45 b0             	lea    -0x50(%ebp),%eax
c000cfbd:	50                   	push   %eax
c000cfbe:	e8 a2 6a ff ff       	call   c0003a65 <memset>
c000cfc3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/exec.c:101

	int32_t fd = sys_open(pathname, O_RDONLY);
c000cfc6:	83 ec 08             	sub    $0x8,%esp
c000cfc9:	6a 00                	push   $0x0
c000cfcb:	ff 75 08             	pushl  0x8(%ebp)
c000cfce:	e8 95 aa ff ff       	call   c0007a68 <sys_open>
c000cfd3:	83 c4 10             	add    $0x10,%esp
c000cfd6:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/userprog/exec.c:102
	if (fd == -1) {
c000cfd9:	83 7d e8 ff          	cmpl   $0xffffffff,-0x18(%ebp)
c000cfdd:	75 0a                	jne    c000cfe9 <load+0x43>
/work/x86_os_my/userprog/exec.c:103
		return -1;
c000cfdf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000cfe4:	e9 4a 01 00 00       	jmp    c000d133 <load+0x18d>
/work/x86_os_my/userprog/exec.c:106
	}

	if (sys_read(fd, &elf_header, sizeof(struct Elf32_Ehdr)) != sizeof(struct Elf32_Ehdr)) {
c000cfe9:	83 ec 04             	sub    $0x4,%esp
c000cfec:	6a 34                	push   $0x34
c000cfee:	8d 45 b0             	lea    -0x50(%ebp),%eax
c000cff1:	50                   	push   %eax
c000cff2:	ff 75 e8             	pushl  -0x18(%ebp)
c000cff5:	e8 59 af ff ff       	call   c0007f53 <sys_read>
c000cffa:	83 c4 10             	add    $0x10,%esp
c000cffd:	83 f8 34             	cmp    $0x34,%eax
c000d000:	74 0c                	je     c000d00e <load+0x68>
/work/x86_os_my/userprog/exec.c:107
		ret = -1;
c000d002:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/userprog/exec.c:108
		goto done;
c000d009:	e9 14 01 00 00       	jmp    c000d122 <load+0x17c>
/work/x86_os_my/userprog/exec.c:116
	/* 校验32位的elf头 */
	/* 
	e_phnum == 程序头表中条目的数量，也就是段的个数
	e_phentsize == 程序头表中每个条目的字节大小，即 描述段的数据结构的大小 == sizeof(struct Elf32_Phdr)
	细节见readme */
	if (memcmp(elf_header.e_ident, "\177ELF\1\1\1", 7) \
c000d00e:	83 ec 04             	sub    $0x4,%esp
c000d011:	6a 07                	push   $0x7
c000d013:	68 f6 01 01 c0       	push   $0xc00101f6
c000d018:	8d 45 b0             	lea    -0x50(%ebp),%eax
c000d01b:	50                   	push   %eax
c000d01c:	e8 f6 6a ff ff       	call   c0003b17 <memcmp>
c000d021:	83 c4 10             	add    $0x10,%esp
c000d024:	85 c0                	test   %eax,%eax
c000d026:	75 30                	jne    c000d058 <load+0xb2>
/work/x86_os_my/userprog/exec.c:117
			|| elf_header.e_type != 2 \
c000d028:	0f b7 45 c0          	movzwl -0x40(%ebp),%eax
c000d02c:	66 83 f8 02          	cmp    $0x2,%ax
c000d030:	75 26                	jne    c000d058 <load+0xb2>
/work/x86_os_my/userprog/exec.c:118
			|| elf_header.e_machine != 3 \
c000d032:	0f b7 45 c2          	movzwl -0x3e(%ebp),%eax
c000d036:	66 83 f8 03          	cmp    $0x3,%ax
c000d03a:	75 1c                	jne    c000d058 <load+0xb2>
/work/x86_os_my/userprog/exec.c:119
			|| elf_header.e_version != 1 \
c000d03c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c000d03f:	83 f8 01             	cmp    $0x1,%eax
c000d042:	75 14                	jne    c000d058 <load+0xb2>
/work/x86_os_my/userprog/exec.c:120
			|| elf_header.e_phnum > 1024 \
c000d044:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
c000d048:	66 3d 00 04          	cmp    $0x400,%ax
c000d04c:	77 0a                	ja     c000d058 <load+0xb2>
/work/x86_os_my/userprog/exec.c:121
			|| elf_header.e_phentsize != sizeof(struct Elf32_Phdr)) {
c000d04e:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
c000d052:	66 83 f8 20          	cmp    $0x20,%ax
c000d056:	74 0c                	je     c000d064 <load+0xbe>
/work/x86_os_my/userprog/exec.c:122
		ret = -1;
c000d058:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/userprog/exec.c:123
		goto done;
c000d05f:	e9 be 00 00 00       	jmp    c000d122 <load+0x17c>
/work/x86_os_my/userprog/exec.c:126
	}

	Elf32_Off prog_header_offset = elf_header.e_phoff;		// 程序头的起始地址
c000d064:	8b 45 cc             	mov    -0x34(%ebp),%eax
c000d067:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/exec.c:127
	Elf32_Half prog_header_size = elf_header.e_phentsize;	// 描述段的数据结构的大小 == sizeof(struct Elf32_Phdr)
c000d06a:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
c000d06e:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
/work/x86_os_my/userprog/exec.c:130

	/* 遍历所有程序头 */
	uint32_t prog_idx = 0;
c000d072:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/userprog/exec.c:131
	while (prog_idx < elf_header.e_phnum) {	//段的个数
c000d079:	e9 8e 00 00 00       	jmp    c000d10c <load+0x166>
/work/x86_os_my/userprog/exec.c:132
		memset(&prog_header, 0, prog_header_size);
c000d07e:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c000d082:	83 ec 04             	sub    $0x4,%esp
c000d085:	50                   	push   %eax
c000d086:	6a 00                	push   $0x0
c000d088:	8d 45 90             	lea    -0x70(%ebp),%eax
c000d08b:	50                   	push   %eax
c000d08c:	e8 d4 69 ff ff       	call   c0003a65 <memset>
c000d091:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/exec.c:135

		/* 将文件的指针定位到程序头 */
		sys_lseek(fd, prog_header_offset, SEEK_SET);
c000d094:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000d097:	83 ec 04             	sub    $0x4,%esp
c000d09a:	6a 01                	push   $0x1
c000d09c:	50                   	push   %eax
c000d09d:	ff 75 e8             	pushl  -0x18(%ebp)
c000d0a0:	e8 f4 af ff ff       	call   c0008099 <sys_lseek>
c000d0a5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/exec.c:138

		/* 只获取程序头 */
		if (sys_read(fd, &prog_header, prog_header_size) != prog_header_size) {
c000d0a8:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c000d0ac:	83 ec 04             	sub    $0x4,%esp
c000d0af:	50                   	push   %eax
c000d0b0:	8d 45 90             	lea    -0x70(%ebp),%eax
c000d0b3:	50                   	push   %eax
c000d0b4:	ff 75 e8             	pushl  -0x18(%ebp)
c000d0b7:	e8 97 ae ff ff       	call   c0007f53 <sys_read>
c000d0bc:	83 c4 10             	add    $0x10,%esp
c000d0bf:	89 c2                	mov    %eax,%edx
c000d0c1:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c000d0c5:	39 c2                	cmp    %eax,%edx
c000d0c7:	74 09                	je     c000d0d2 <load+0x12c>
/work/x86_os_my/userprog/exec.c:139
			ret = -1;
c000d0c9:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/userprog/exec.c:140
			goto done;
c000d0d0:	eb 50                	jmp    c000d122 <load+0x17c>
/work/x86_os_my/userprog/exec.c:144
		}

		/* 如果是可加载段就调用 segment_load 加载到内存 */
		if (PT_LOAD == prog_header.p_type) {
c000d0d2:	8b 45 90             	mov    -0x70(%ebp),%eax
c000d0d5:	83 f8 01             	cmp    $0x1,%eax
c000d0d8:	75 24                	jne    c000d0fe <load+0x158>
/work/x86_os_my/userprog/exec.c:145
			if (!segment_load(fd, prog_header.p_offset, prog_header.p_filesz, prog_header.p_vaddr)) {
c000d0da:	8b 4d 98             	mov    -0x68(%ebp),%ecx
c000d0dd:	8b 55 a0             	mov    -0x60(%ebp),%edx
c000d0e0:	8b 45 94             	mov    -0x6c(%ebp),%eax
c000d0e3:	51                   	push   %ecx
c000d0e4:	52                   	push   %edx
c000d0e5:	50                   	push   %eax
c000d0e6:	ff 75 e8             	pushl  -0x18(%ebp)
c000d0e9:	e8 ba fd ff ff       	call   c000cea8 <segment_load>
c000d0ee:	83 c4 10             	add    $0x10,%esp
c000d0f1:	85 c0                	test   %eax,%eax
c000d0f3:	75 09                	jne    c000d0fe <load+0x158>
/work/x86_os_my/userprog/exec.c:146
				ret = -1;
c000d0f5:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/userprog/exec.c:147
				goto done;
c000d0fc:	eb 24                	jmp    c000d122 <load+0x17c>
/work/x86_os_my/userprog/exec.c:152
			}
		}

		/* 更新下一个程序头的偏移 */
		prog_header_offset += elf_header.e_phentsize;
c000d0fe:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
c000d102:	0f b7 c0             	movzwl %ax,%eax
c000d105:	01 45 f0             	add    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/exec.c:153
		prog_idx++;
c000d108:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
/work/x86_os_my/userprog/exec.c:131
	Elf32_Off prog_header_offset = elf_header.e_phoff;		// 程序头的起始地址
	Elf32_Half prog_header_size = elf_header.e_phentsize;	// 描述段的数据结构的大小 == sizeof(struct Elf32_Phdr)

	/* 遍历所有程序头 */
	uint32_t prog_idx = 0;
	while (prog_idx < elf_header.e_phnum) {	//段的个数
c000d10c:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
c000d110:	0f b7 c0             	movzwl %ax,%eax
c000d113:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c000d116:	0f 87 62 ff ff ff    	ja     c000d07e <load+0xd8>
/work/x86_os_my/userprog/exec.c:155

		/* 更新下一个程序头的偏移 */
		prog_header_offset += elf_header.e_phentsize;
		prog_idx++;
	}
	ret = elf_header.e_entry;
c000d11c:	8b 45 c8             	mov    -0x38(%ebp),%eax
c000d11f:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/exec.c:157
done:
	sys_close(fd);
c000d122:	83 ec 0c             	sub    $0xc,%esp
c000d125:	ff 75 e8             	pushl  -0x18(%ebp)
c000d128:	e8 e8 ab ff ff       	call   c0007d15 <sys_close>
c000d12d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/exec.c:158
	return ret;
c000d130:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/userprog/exec.c:159 (discriminator 1)
}
c000d133:	c9                   	leave  
c000d134:	c3                   	ret    

c000d135 <sys_execv>:
sys_execv():
/work/x86_os_my/userprog/exec.c:162

/* 用path指向的程序替换当前进程 */
int32_t sys_execv(const char* path, const char* argv[]) {
c000d135:	55                   	push   %ebp
c000d136:	89 e5                	mov    %esp,%ebp
c000d138:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/exec.c:163
	uint32_t argc = 0;
c000d13b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/userprog/exec.c:164
	while (argv[argc]) {
c000d142:	eb 04                	jmp    c000d148 <sys_execv+0x13>
/work/x86_os_my/userprog/exec.c:165
		argc++;
c000d144:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/userprog/exec.c:164
}

/* 用path指向的程序替换当前进程 */
int32_t sys_execv(const char* path, const char* argv[]) {
	uint32_t argc = 0;
	while (argv[argc]) {
c000d148:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000d14b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000d152:	8b 45 0c             	mov    0xc(%ebp),%eax
c000d155:	01 d0                	add    %edx,%eax
c000d157:	8b 00                	mov    (%eax),%eax
c000d159:	85 c0                	test   %eax,%eax
c000d15b:	75 e7                	jne    c000d144 <sys_execv+0xf>
/work/x86_os_my/userprog/exec.c:168
		argc++;
	}
	// 以前是用汇编加载的elf格式的内核，现在使用C语言方式加载elf格式的应用程序。
	int32_t entry_point = load(path);     
c000d15d:	83 ec 0c             	sub    $0xc,%esp
c000d160:	ff 75 08             	pushl  0x8(%ebp)
c000d163:	e8 3e fe ff ff       	call   c000cfa6 <load>
c000d168:	83 c4 10             	add    $0x10,%esp
c000d16b:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/exec.c:169
	if (entry_point == -1) {	 // 若加载失败则返回-1
c000d16e:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c000d172:	75 07                	jne    c000d17b <sys_execv+0x46>
/work/x86_os_my/userprog/exec.c:170
		return -1;
c000d174:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000d179:	eb 63                	jmp    c000d1de <sys_execv+0xa9>
/work/x86_os_my/userprog/exec.c:173
	}

	struct task_struct* cur = running_thread();
c000d17b:	e8 cc 6c ff ff       	call   c0003e4c <running_thread>
c000d180:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/userprog/exec.c:175
	/* 修改进程名 */
	memcpy(cur->name, path, TASK_NAME_LEN);
c000d183:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000d186:	83 c0 0c             	add    $0xc,%eax
c000d189:	83 ec 04             	sub    $0x4,%esp
c000d18c:	6a 10                	push   $0x10
c000d18e:	ff 75 08             	pushl  0x8(%ebp)
c000d191:	50                   	push   %eax
c000d192:	e8 20 69 ff ff       	call   c0003ab7 <memcpy>
c000d197:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/exec.c:176
	cur->name[TASK_NAME_LEN-1] = 0;
c000d19a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000d19d:	c6 40 1b 00          	movb   $0x0,0x1b(%eax)
/work/x86_os_my/userprog/exec.c:179

	/* 修改栈中参数 */
	struct intr_stack* intr_0_stack = (struct intr_stack*)((uint32_t)cur + PG_SIZE - sizeof(struct intr_stack));
c000d1a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000d1a4:	05 b4 0f 00 00       	add    $0xfb4,%eax
c000d1a9:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/userprog/exec.c:188
	习惯用法：
	ebx 经常做基址寄存器，argv 本来就是所有参数的基地址，
	ecx 经常做循环控制次数寄存器，argc 本来就是 argv 的参数个数，也就是循环次数
	现在把参数放在哪个寄存器中，将来在获取参数时就从哪些寄存器中取，
	将来实现简易版 c 运行库，那会涉及到从寄存器中获取参数。*/
	intr_0_stack->ebx = (int32_t)argv;
c000d1ac:	8b 55 0c             	mov    0xc(%ebp),%edx
c000d1af:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000d1b2:	89 50 14             	mov    %edx,0x14(%eax)
/work/x86_os_my/userprog/exec.c:189
	intr_0_stack->ecx = argc;
c000d1b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000d1b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000d1bb:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/userprog/exec.c:190
	intr_0_stack->eip = (void*)entry_point;
c000d1be:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000d1c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000d1c4:	89 50 38             	mov    %edx,0x38(%eax)
/work/x86_os_my/userprog/exec.c:194
	/* 使新用户进程的栈地址为最高用户空间地址 */
	/* 1. 老进程用户栈中的数据只适用于老进程，对新进程没用，故新进程的用户栈应该从新开始。
	   2. 为了后续传入参数做准备：用户空间的最高处用于存储命令行参数。*/
	intr_0_stack->esp = (void*)0xc0000000;
c000d1c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000d1ca:	c7 40 44 00 00 00 c0 	movl   $0xc0000000,0x44(%eax)
/work/x86_os_my/userprog/exec.c:198

	/* exec不同于fork,为使新进程更快被执行,直接从中断返回 */
	/* 将新进程内核栈地址赋值给 esp 寄存器，然后跳转到 intr_exit，假装从中断返回，实现了新进程的运行。 */
	asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (intr_0_stack) : "memory");
c000d1d1:	8b 65 e8             	mov    -0x18(%ebp),%esp
c000d1d4:	e9 77 4c ff ff       	jmp    c0001e50 <intr_exit>
/work/x86_os_my/userprog/exec.c:201

	//并不会从这里返回
	return 0;
c000d1d9:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/userprog/exec.c:202
}
c000d1de:	c9                   	leave  
c000d1df:	c3                   	ret    

c000d1e0 <release_prog_resource>:
release_prog_resource():
/work/x86_os_my/userprog/wait_exit.c:17

/* 释放用户进程资源: 
 * 1 页表中对应的物理页
 * 2 虚拟内存池占物理页框
 * 3 关闭打开的文件 */
static void release_prog_resource(struct task_struct* release_thread) {
c000d1e0:	55                   	push   %ebp
c000d1e1:	89 e5                	mov    %esp,%ebp
c000d1e3:	83 ec 48             	sub    $0x48,%esp
/work/x86_os_my/userprog/wait_exit.c:18
	uint32_t* pgdir_vaddr = release_thread->pgdir;	// 进程自己页目录表的虚拟地址，加载到cr3时需转成物理地址
c000d1e6:	8b 45 08             	mov    0x8(%ebp),%eax
c000d1e9:	8b 40 54             	mov    0x54(%eax),%eax
c000d1ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/userprog/wait_exit.c:21
	// 前768个页目录项，表示用户空间的低端3G虚拟内存。
	// 剩下1024-768=256个页目录项，是内核使用的高端1G虚拟内存。
	uint16_t user_pde_nr = 768, pde_idx = 0;
c000d1ef:	66 c7 45 ea 00 03    	movw   $0x300,-0x16(%ebp)
c000d1f5:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
/work/x86_os_my/userprog/wait_exit.c:22
	uint32_t pde = 0;
c000d1fb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
/work/x86_os_my/userprog/wait_exit.c:23
	uint32_t* v_pde_ptr = NULL;		// v表示var,和函数pde_ptr区分
c000d202:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
/work/x86_os_my/userprog/wait_exit.c:25

	uint16_t user_pte_nr = 1024, pte_idx = 0;
c000d209:	66 c7 45 de 00 04    	movw   $0x400,-0x22(%ebp)
c000d20f:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%ebp)
/work/x86_os_my/userprog/wait_exit.c:26
	uint32_t pte = 0;
c000d215:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
/work/x86_os_my/userprog/wait_exit.c:27
	uint32_t* v_pte_ptr = NULL;		// 加个v表示var,和函数pte_ptr区分
c000d21c:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
/work/x86_os_my/userprog/wait_exit.c:29

	uint32_t* first_pte_vaddr_in_pde = NULL;	// 用来记录pde指向的页表中的，第0个pte的地址
c000d223:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
/work/x86_os_my/userprog/wait_exit.c:30
	uint32_t pg_phy_addr = 0;
c000d22a:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
/work/x86_os_my/userprog/wait_exit.c:37
	/* 回收页表中用户空间的页框 */
	/* 回收的方法有两种，一是按照虚拟内存池 pcb->userprog_vaddr 回收，检查位图中被置为 1 的 bit，计算出相应虚拟地址，逐位回收。
	另一种方法相对直接一点，直接遍历页表，如果页表的 p 位为 1，这说明已经分配了物理页框。
	第 1 种方法咱们已经在实现 fork 时为复制用户地址空间用过了，
	现在咱们尝试第二种方法。*/
	while (pde_idx < user_pde_nr) {
c000d231:	e9 be 00 00 00       	jmp    c000d2f4 <release_prog_resource+0x114>
/work/x86_os_my/userprog/wait_exit.c:38
		v_pde_ptr = pgdir_vaddr + pde_idx;	// pgdir_vaddr 类型是 u32* 指针步长是4字节，一个页目录项的大小
c000d236:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c000d23a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000d241:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000d244:	01 d0                	add    %edx,%eax
c000d246:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/userprog/wait_exit.c:39
		pde = *v_pde_ptr;			// 【取到页目录表中的页目录项，包含所指向的页表地址+属性】
c000d249:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000d24c:	8b 00                	mov    (%eax),%eax
c000d24e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/userprog/wait_exit.c:40
		if (pde & 0x00000001) {		// 如果页目录项p位为1,表示该页目录项下可能有页表项
c000d251:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000d254:	83 e0 01             	and    $0x1,%eax
c000d257:	85 c0                	test   %eax,%eax
c000d259:	0f 84 8a 00 00 00    	je     c000d2e9 <release_prog_resource+0x109>
/work/x86_os_my/userprog/wait_exit.c:45
			/* pte_ptr功能：得到虚拟地址vaddr对应的pte指针*/
			/* 取虚拟地址pde_idx*0x400000的pte指针，就限制了，取到的都是，所有页表中的第0个页表项的指针
			 * 因为限定了跨度是 一个页表能表示的虚拟地址范围。
			 */
			first_pte_vaddr_in_pde = pte_ptr(pde_idx * 0x400000);	// 一个pde指向的页表，表示的内存容量是4M(4k页大小*1024个页),即0x400000
c000d25f:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c000d263:	c1 e0 16             	shl    $0x16,%eax
c000d266:	83 ec 0c             	sub    $0xc,%esp
c000d269:	50                   	push   %eax
c000d26a:	e8 27 57 ff ff       	call   c0002996 <pte_ptr>
c000d26f:	83 c4 10             	add    $0x10,%esp
c000d272:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/userprog/wait_exit.c:46
			pte_idx = 0;
c000d275:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%ebp)
/work/x86_os_my/userprog/wait_exit.c:47
			while (pte_idx < user_pte_nr) {
c000d27b:	eb 49                	jmp    c000d2c6 <release_prog_resource+0xe6>
/work/x86_os_my/userprog/wait_exit.c:48
				v_pte_ptr = first_pte_vaddr_in_pde + pte_idx;	// first_pte_vaddr_in_pde 类型是 u32* 指针步长是4字节，一个页表项的大小
c000d27d:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c000d281:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000d288:	8b 45 d0             	mov    -0x30(%ebp),%eax
c000d28b:	01 d0                	add    %edx,%eax
c000d28d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/userprog/wait_exit.c:49
				pte = *v_pte_ptr;	// 【取到页表中的页表项，包含所指向的页地址+属性】
c000d290:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000d293:	8b 00                	mov    (%eax),%eax
c000d295:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/userprog/wait_exit.c:50
				if (pte & 0x00000001) {
c000d298:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000d29b:	83 e0 01             	and    $0x1,%eax
c000d29e:	85 c0                	test   %eax,%eax
c000d2a0:	74 19                	je     c000d2bb <release_prog_resource+0xdb>
/work/x86_os_my/userprog/wait_exit.c:52
					/* 将pte中记录的物理页框直接在相应内存池的位图中清0 */
					pg_phy_addr = pte & 0xfffff000;	// 【页地址】
c000d2a2:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000d2a5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000d2aa:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/userprog/wait_exit.c:53
					free_a_phy_page(pg_phy_addr);
c000d2ad:	83 ec 0c             	sub    $0xc,%esp
c000d2b0:	ff 75 cc             	pushl  -0x34(%ebp)
c000d2b3:	e8 fa 66 ff ff       	call   c00039b2 <free_a_phy_page>
c000d2b8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/wait_exit.c:55
				}
				pte_idx++;
c000d2bb:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c000d2bf:	83 c0 01             	add    $0x1,%eax
c000d2c2:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/userprog/wait_exit.c:47
			/* 取虚拟地址pde_idx*0x400000的pte指针，就限制了，取到的都是，所有页表中的第0个页表项的指针
			 * 因为限定了跨度是 一个页表能表示的虚拟地址范围。
			 */
			first_pte_vaddr_in_pde = pte_ptr(pde_idx * 0x400000);	// 一个pde指向的页表，表示的内存容量是4M(4k页大小*1024个页),即0x400000
			pte_idx = 0;
			while (pte_idx < user_pte_nr) {
c000d2c6:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c000d2ca:	66 3b 45 de          	cmp    -0x22(%ebp),%ax
c000d2ce:	72 ad                	jb     c000d27d <release_prog_resource+0x9d>
/work/x86_os_my/userprog/wait_exit.c:58
					free_a_phy_page(pg_phy_addr);
				}
				pte_idx++;
			}
			/* 将pde中记录的物理页框直接在相应内存池的位图中清0 */
			pg_phy_addr = pde & 0xfffff000;
c000d2d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000d2d3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000d2d8:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/userprog/wait_exit.c:59
			free_a_phy_page(pg_phy_addr);
c000d2db:	83 ec 0c             	sub    $0xc,%esp
c000d2de:	ff 75 cc             	pushl  -0x34(%ebp)
c000d2e1:	e8 cc 66 ff ff       	call   c00039b2 <free_a_phy_page>
c000d2e6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/wait_exit.c:61
		}
		pde_idx++;
c000d2e9:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c000d2ed:	83 c0 01             	add    $0x1,%eax
c000d2f0:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/userprog/wait_exit.c:37
	/* 回收页表中用户空间的页框 */
	/* 回收的方法有两种，一是按照虚拟内存池 pcb->userprog_vaddr 回收，检查位图中被置为 1 的 bit，计算出相应虚拟地址，逐位回收。
	另一种方法相对直接一点，直接遍历页表，如果页表的 p 位为 1，这说明已经分配了物理页框。
	第 1 种方法咱们已经在实现 fork 时为复制用户地址空间用过了，
	现在咱们尝试第二种方法。*/
	while (pde_idx < user_pde_nr) {
c000d2f4:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c000d2f8:	66 3b 45 ea          	cmp    -0x16(%ebp),%ax
c000d2fc:	0f 82 34 ff ff ff    	jb     c000d236 <release_prog_resource+0x56>
/work/x86_os_my/userprog/wait_exit.c:65
		}
		pde_idx++;
	}

	/* 回收用户虚拟地址池所占的物理内存*/
	uint32_t bitmap_pg_cnt = (release_thread->userprog_vaddr.vaddr_bitmap.btmp_bytes_len) / PG_SIZE;
c000d302:	8b 45 08             	mov    0x8(%ebp),%eax
c000d305:	8b 40 58             	mov    0x58(%eax),%eax
c000d308:	c1 e8 0c             	shr    $0xc,%eax
c000d30b:	89 45 c8             	mov    %eax,-0x38(%ebp)
/work/x86_os_my/userprog/wait_exit.c:66
	uint8_t* user_vaddr_pool_bitmap = release_thread->userprog_vaddr.vaddr_bitmap.bits;
c000d30e:	8b 45 08             	mov    0x8(%ebp),%eax
c000d311:	8b 40 5c             	mov    0x5c(%eax),%eax
c000d314:	89 45 c4             	mov    %eax,-0x3c(%ebp)
/work/x86_os_my/userprog/wait_exit.c:67
	mfree_page(PF_KERNEL, user_vaddr_pool_bitmap, bitmap_pg_cnt);
c000d317:	83 ec 04             	sub    $0x4,%esp
c000d31a:	ff 75 c8             	pushl  -0x38(%ebp)
c000d31d:	ff 75 c4             	pushl  -0x3c(%ebp)
c000d320:	6a 01                	push   $0x1
c000d322:	e8 51 60 ff ff       	call   c0003378 <mfree_page>
c000d327:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/wait_exit.c:70

	/* 关闭进程打开的文件 */
	uint8_t local_fd = 3;
c000d32a:	c6 45 f3 03          	movb   $0x3,-0xd(%ebp)
/work/x86_os_my/userprog/wait_exit.c:71
	while(local_fd < MAX_FILES_OPEN_PER_PROC) {
c000d32e:	e9 d8 00 00 00       	jmp    c000d40b <release_prog_resource+0x22b>
/work/x86_os_my/userprog/wait_exit.c:72
		if (release_thread->fd_table[local_fd] != -1) {
c000d333:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
c000d337:	8b 45 08             	mov    0x8(%ebp),%eax
c000d33a:	83 c2 08             	add    $0x8,%edx
c000d33d:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
c000d341:	83 f8 ff             	cmp    $0xffffffff,%eax
c000d344:	0f 84 b7 00 00 00    	je     c000d401 <release_prog_resource+0x221>
/work/x86_os_my/userprog/wait_exit.c:73
			if (is_pipe(local_fd)) {
c000d34a:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c000d34e:	83 ec 0c             	sub    $0xc,%esp
c000d351:	50                   	push   %eax
c000d352:	e8 c2 02 00 00       	call   c000d619 <is_pipe>
c000d357:	83 c4 10             	add    $0x10,%esp
c000d35a:	85 c0                	test   %eax,%eax
c000d35c:	0f 84 8f 00 00 00    	je     c000d3f1 <release_prog_resource+0x211>
/work/x86_os_my/userprog/wait_exit.c:74
				uint32_t global_fd = fd_local2global(local_fd);
c000d362:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c000d366:	83 ec 0c             	sub    $0xc,%esp
c000d369:	50                   	push   %eax
c000d36a:	e8 5b a9 ff ff       	call   c0007cca <fd_local2global>
c000d36f:	83 c4 10             	add    $0x10,%esp
c000d372:	89 45 c0             	mov    %eax,-0x40(%ebp)
/work/x86_os_my/userprog/wait_exit.c:75
				if (--file_table[global_fd].fd_pos == 0) {
c000d375:	8b 55 c0             	mov    -0x40(%ebp),%edx
c000d378:	89 d0                	mov    %edx,%eax
c000d37a:	01 c0                	add    %eax,%eax
c000d37c:	01 d0                	add    %edx,%eax
c000d37e:	c1 e0 02             	shl    $0x2,%eax
c000d381:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c000d386:	8b 00                	mov    (%eax),%eax
c000d388:	8d 48 ff             	lea    -0x1(%eax),%ecx
c000d38b:	8b 55 c0             	mov    -0x40(%ebp),%edx
c000d38e:	89 d0                	mov    %edx,%eax
c000d390:	01 c0                	add    %eax,%eax
c000d392:	01 d0                	add    %edx,%eax
c000d394:	c1 e0 02             	shl    $0x2,%eax
c000d397:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c000d39c:	89 08                	mov    %ecx,(%eax)
c000d39e:	8b 55 c0             	mov    -0x40(%ebp),%edx
c000d3a1:	89 d0                	mov    %edx,%eax
c000d3a3:	01 c0                	add    %eax,%eax
c000d3a5:	01 d0                	add    %edx,%eax
c000d3a7:	c1 e0 02             	shl    $0x2,%eax
c000d3aa:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c000d3af:	8b 00                	mov    (%eax),%eax
c000d3b1:	85 c0                	test   %eax,%eax
c000d3b3:	75 4c                	jne    c000d401 <release_prog_resource+0x221>
/work/x86_os_my/userprog/wait_exit.c:76
					mfree_page(PF_KERNEL, file_table[global_fd].fd_inode, 1);
c000d3b5:	8b 55 c0             	mov    -0x40(%ebp),%edx
c000d3b8:	89 d0                	mov    %edx,%eax
c000d3ba:	01 c0                	add    %eax,%eax
c000d3bc:	01 d0                	add    %edx,%eax
c000d3be:	c1 e0 02             	shl    $0x2,%eax
c000d3c1:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c000d3c6:	8b 00                	mov    (%eax),%eax
c000d3c8:	83 ec 04             	sub    $0x4,%esp
c000d3cb:	6a 01                	push   $0x1
c000d3cd:	50                   	push   %eax
c000d3ce:	6a 01                	push   $0x1
c000d3d0:	e8 a3 5f ff ff       	call   c0003378 <mfree_page>
c000d3d5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/wait_exit.c:77
					file_table[global_fd].fd_inode = NULL;
c000d3d8:	8b 55 c0             	mov    -0x40(%ebp),%edx
c000d3db:	89 d0                	mov    %edx,%eax
c000d3dd:	01 c0                	add    %eax,%eax
c000d3df:	01 d0                	add    %edx,%eax
c000d3e1:	c1 e0 02             	shl    $0x2,%eax
c000d3e4:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c000d3e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c000d3ef:	eb 10                	jmp    c000d401 <release_prog_resource+0x221>
/work/x86_os_my/userprog/wait_exit.c:80
				}
			} else {
				sys_close(local_fd);
c000d3f1:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c000d3f5:	83 ec 0c             	sub    $0xc,%esp
c000d3f8:	50                   	push   %eax
c000d3f9:	e8 17 a9 ff ff       	call   c0007d15 <sys_close>
c000d3fe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/wait_exit.c:83
			}
		}
		local_fd++;
c000d401:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c000d405:	83 c0 01             	add    $0x1,%eax
c000d408:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/userprog/wait_exit.c:71
	uint8_t* user_vaddr_pool_bitmap = release_thread->userprog_vaddr.vaddr_bitmap.bits;
	mfree_page(PF_KERNEL, user_vaddr_pool_bitmap, bitmap_pg_cnt);

	/* 关闭进程打开的文件 */
	uint8_t local_fd = 3;
	while(local_fd < MAX_FILES_OPEN_PER_PROC) {
c000d40b:	80 7d f3 07          	cmpb   $0x7,-0xd(%ebp)
c000d40f:	0f 86 1e ff ff ff    	jbe    c000d333 <release_prog_resource+0x153>
/work/x86_os_my/userprog/wait_exit.c:85
				sys_close(local_fd);
			}
		}
		local_fd++;
	}
}
c000d415:	90                   	nop
c000d416:	c9                   	leave  
c000d417:	c3                   	ret    

c000d418 <find_child>:
find_child():
/work/x86_os_my/userprog/wait_exit.c:89

/* list_traversal的回调函数：
 * 查找pelem的parent_pid是否是ppid,成功返回true,失败则返回false */
static bool find_child(struct list_elem* pelem, int32_t ppid) {
c000d418:	55                   	push   %ebp
c000d419:	89 e5                	mov    %esp,%ebp
c000d41b:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/userprog/wait_exit.c:91
	/* elem2entry中间的参数all_list_tag取决于pelem对应的变量名 */
	struct task_struct* pthread = elem2entry(struct task_struct, all_list_tag, pelem);
c000d41e:	8b 45 08             	mov    0x8(%ebp),%eax
c000d421:	83 e8 4c             	sub    $0x4c,%eax
c000d424:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/userprog/wait_exit.c:92
	if (pthread->parent_pid == ppid) {	// 若该任务的parent_pid为ppid,返回
c000d427:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000d42a:	0f b7 80 10 01 00 00 	movzwl 0x110(%eax),%eax
c000d431:	98                   	cwtl   
c000d432:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000d435:	75 07                	jne    c000d43e <find_child+0x26>
/work/x86_os_my/userprog/wait_exit.c:93
		return true;	// list_traversal只有在回调函数返回true时才会停止继续遍历,所以在此返回true
c000d437:	b8 01 00 00 00       	mov    $0x1,%eax
c000d43c:	eb 05                	jmp    c000d443 <find_child+0x2b>
/work/x86_os_my/userprog/wait_exit.c:95
	}
	return false;		// 让list_traversal继续传递下一个元素
c000d43e:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/userprog/wait_exit.c:96
}
c000d443:	c9                   	leave  
c000d444:	c3                   	ret    

c000d445 <find_hanging_child>:
find_hanging_child():
/work/x86_os_my/userprog/wait_exit.c:100

/* list_traversal的回调函数：
 * 查找状态为TASK_HANGING的任务 */
static bool find_hanging_child(struct list_elem* pelem, int32_t ppid) {
c000d445:	55                   	push   %ebp
c000d446:	89 e5                	mov    %esp,%ebp
c000d448:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/userprog/wait_exit.c:101
	struct task_struct* pthread = elem2entry(struct task_struct, all_list_tag, pelem);
c000d44b:	8b 45 08             	mov    0x8(%ebp),%eax
c000d44e:	83 e8 4c             	sub    $0x4c,%eax
c000d451:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/userprog/wait_exit.c:102
	if (pthread->parent_pid == ppid && pthread->status == TASK_HANGING) {
c000d454:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000d457:	0f b7 80 10 01 00 00 	movzwl 0x110(%eax),%eax
c000d45e:	98                   	cwtl   
c000d45f:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000d462:	75 12                	jne    c000d476 <find_hanging_child+0x31>
/work/x86_os_my/userprog/wait_exit.c:102 (discriminator 1)
c000d464:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000d467:	8b 40 08             	mov    0x8(%eax),%eax
c000d46a:	83 f8 04             	cmp    $0x4,%eax
c000d46d:	75 07                	jne    c000d476 <find_hanging_child+0x31>
/work/x86_os_my/userprog/wait_exit.c:103
		return true;
c000d46f:	b8 01 00 00 00       	mov    $0x1,%eax
c000d474:	eb 05                	jmp    c000d47b <find_hanging_child+0x36>
/work/x86_os_my/userprog/wait_exit.c:105
	}
	return false; 
c000d476:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/userprog/wait_exit.c:106
}
c000d47b:	c9                   	leave  
c000d47c:	c3                   	ret    

c000d47d <init_adopt_a_child>:
init_adopt_a_child():
/work/x86_os_my/userprog/wait_exit.c:110

/* list_traversal的回调函数：
 * 将一个子进程过继给init */
static bool init_adopt_a_child(struct list_elem* pelem, int32_t pid) {
c000d47d:	55                   	push   %ebp
c000d47e:	89 e5                	mov    %esp,%ebp
c000d480:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/userprog/wait_exit.c:111
	struct task_struct* pthread = elem2entry(struct task_struct, all_list_tag, pelem);
c000d483:	8b 45 08             	mov    0x8(%ebp),%eax
c000d486:	83 e8 4c             	sub    $0x4c,%eax
c000d489:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/userprog/wait_exit.c:112
	if (pthread->parent_pid == pid) {	// 若该进程的parent_pid为pid,返回
c000d48c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000d48f:	0f b7 80 10 01 00 00 	movzwl 0x110(%eax),%eax
c000d496:	98                   	cwtl   
c000d497:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000d49a:	75 0c                	jne    c000d4a8 <init_adopt_a_child+0x2b>
/work/x86_os_my/userprog/wait_exit.c:113
		pthread->parent_pid = 1;		// init进程pid是1
c000d49c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000d49f:	66 c7 80 10 01 00 00 	movw   $0x1,0x110(%eax)
c000d4a6:	01 00 
/work/x86_os_my/userprog/wait_exit.c:115
	}
	return false;	// 让list_traversal继续传递下一个元素
c000d4a8:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/userprog/wait_exit.c:116
}
c000d4ad:	c9                   	leave  
c000d4ae:	c3                   	ret    

c000d4af <sys_wait>:
sys_wait():
/work/x86_os_my/userprog/wait_exit.c:120

/* 父进程等待子进程调用exit,将子进程的退出状态保存到status指向的变量.
 * 成功则返回子进程的pid,失败则返回-1 */
pid_t sys_wait(int32_t* status) {
c000d4af:	55                   	push   %ebp
c000d4b0:	89 e5                	mov    %esp,%ebp
c000d4b2:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/wait_exit.c:121
	struct task_struct* parent_thread = running_thread();
c000d4b5:	e8 92 69 ff ff       	call   c0003e4c <running_thread>
c000d4ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/wait_exit.c:125

	while(1) {
		/* 优先处理已经是挂起hanging状态的任务 */
		struct list_elem* child_elem = list_traversal(&thread_all_list, find_hanging_child, parent_thread->pid);
c000d4bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000d4c0:	0f b7 40 04          	movzwl 0x4(%eax),%eax
c000d4c4:	98                   	cwtl   
c000d4c5:	83 ec 04             	sub    $0x4,%esp
c000d4c8:	50                   	push   %eax
c000d4c9:	68 45 d4 00 c0       	push   $0xc000d445
c000d4ce:	68 b8 42 01 c0       	push   $0xc00142b8
c000d4d3:	e8 a7 76 ff ff       	call   c0004b7f <list_traversal>
c000d4d8:	83 c4 10             	add    $0x10,%esp
c000d4db:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/wait_exit.c:127
		/* 若有挂起的子进程 */
		if (child_elem != NULL) {
c000d4de:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000d4e2:	74 3c                	je     c000d520 <sys_wait+0x71>
/work/x86_os_my/userprog/wait_exit.c:128
			struct task_struct* child_thread = elem2entry(struct task_struct, all_list_tag, child_elem);
c000d4e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000d4e7:	83 e8 4c             	sub    $0x4c,%eax
c000d4ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/userprog/wait_exit.c:129
			*status = child_thread->exit_status;
c000d4ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000d4f0:	0f b6 80 12 01 00 00 	movzbl 0x112(%eax),%eax
c000d4f7:	0f be d0             	movsbl %al,%edx
c000d4fa:	8b 45 08             	mov    0x8(%ebp),%eax
c000d4fd:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/wait_exit.c:132

			/* thread_exit之后,pcb会被回收,因此提前获取pid */
			uint16_t child_pid = child_thread->pid;
c000d4ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000d502:	0f b7 40 04          	movzwl 0x4(%eax),%eax
c000d506:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
/work/x86_os_my/userprog/wait_exit.c:135

			/* 2 从就绪队列和全部队列中删除进程表项*/
			thread_exit(child_thread, false);	// 传入的参数need_schedule=false,使thread_exit调用后回到此处
c000d50a:	83 ec 08             	sub    $0x8,%esp
c000d50d:	6a 00                	push   $0x0
c000d50f:	ff 75 ec             	pushl  -0x14(%ebp)
c000d512:	e8 6b 73 ff ff       	call   c0004882 <thread_exit>
c000d517:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/wait_exit.c:138
			/* 进程表项是进程或线程的最后保留的资源, 至此该进程彻底消失了 */

			return child_pid;
c000d51a:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c000d51e:	eb 40                	jmp    c000d560 <sys_wait+0xb1>
/work/x86_os_my/userprog/wait_exit.c:142
		}

		/* 判断是否有子进程 */
		child_elem = list_traversal(&thread_all_list, find_child, parent_thread->pid);
c000d520:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000d523:	0f b7 40 04          	movzwl 0x4(%eax),%eax
c000d527:	98                   	cwtl   
c000d528:	83 ec 04             	sub    $0x4,%esp
c000d52b:	50                   	push   %eax
c000d52c:	68 18 d4 00 c0       	push   $0xc000d418
c000d531:	68 b8 42 01 c0       	push   $0xc00142b8
c000d536:	e8 44 76 ff ff       	call   c0004b7f <list_traversal>
c000d53b:	83 c4 10             	add    $0x10,%esp
c000d53e:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/wait_exit.c:143
		if (child_elem == NULL) {	// 若没有子进程则出错返回
c000d541:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000d545:	75 07                	jne    c000d54e <sys_wait+0x9f>
/work/x86_os_my/userprog/wait_exit.c:144
			return -1;
c000d547:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000d54c:	eb 12                	jmp    c000d560 <sys_wait+0xb1>
/work/x86_os_my/userprog/wait_exit.c:147
		} else {
			/* 若子进程还未运行完,即还未调用exit,则将自己挂起,直到子进程在执行exit时将自己唤醒 */
			thread_block(TASK_WAITING); 
c000d54e:	83 ec 0c             	sub    $0xc,%esp
c000d551:	6a 03                	push   $0x3
c000d553:	e8 54 6e ff ff       	call   c00043ac <thread_block>
c000d558:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/wait_exit.c:149
		}
	}
c000d55b:	e9 5d ff ff ff       	jmp    c000d4bd <sys_wait+0xe>
/work/x86_os_my/userprog/wait_exit.c:150
}
c000d560:	c9                   	leave  
c000d561:	c3                   	ret    

c000d562 <sys_exit>:
sys_exit():
/work/x86_os_my/userprog/wait_exit.c:153

/* 子进程用来结束自己时调用 */
void sys_exit(int32_t status) {
c000d562:	55                   	push   %ebp
c000d563:	89 e5                	mov    %esp,%ebp
c000d565:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/wait_exit.c:154
	struct task_struct* child_thread = running_thread();
c000d568:	e8 df 68 ff ff       	call   c0003e4c <running_thread>
c000d56d:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/wait_exit.c:155
	child_thread->exit_status = status;		//返回值
c000d570:	8b 45 08             	mov    0x8(%ebp),%eax
c000d573:	89 c2                	mov    %eax,%edx
c000d575:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000d578:	88 90 12 01 00 00    	mov    %dl,0x112(%eax)
/work/x86_os_my/userprog/wait_exit.c:156
	if (child_thread->parent_pid == -1) {
c000d57e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000d581:	0f b7 80 10 01 00 00 	movzwl 0x110(%eax),%eax
c000d588:	66 83 f8 ff          	cmp    $0xffff,%ax
c000d58c:	75 1c                	jne    c000d5aa <sys_exit+0x48>
/work/x86_os_my/userprog/wait_exit.c:157
		PANIC("sys_exit: child_thread->parent_pid is -1\n");
c000d58e:	68 00 02 01 c0       	push   $0xc0010200
c000d593:	68 40 02 01 c0       	push   $0xc0010240
c000d598:	68 9d 00 00 00       	push   $0x9d
c000d59d:	68 2a 02 01 c0       	push   $0xc001022a
c000d5a2:	e8 ba 4f ff ff       	call   c0002561 <panic_spin>
c000d5a7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/wait_exit.c:161
	}

	/* 将进程child_thread的所有子进程都过继给init */
	list_traversal(&thread_all_list, init_adopt_a_child, child_thread->pid);
c000d5aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000d5ad:	0f b7 40 04          	movzwl 0x4(%eax),%eax
c000d5b1:	98                   	cwtl   
c000d5b2:	83 ec 04             	sub    $0x4,%esp
c000d5b5:	50                   	push   %eax
c000d5b6:	68 7d d4 00 c0       	push   $0xc000d47d
c000d5bb:	68 b8 42 01 c0       	push   $0xc00142b8
c000d5c0:	e8 ba 75 ff ff       	call   c0004b7f <list_traversal>
c000d5c5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/wait_exit.c:164

	/* 回收进程child_thread的资源 */
	release_prog_resource(child_thread); 
c000d5c8:	83 ec 0c             	sub    $0xc,%esp
c000d5cb:	ff 75 f4             	pushl  -0xc(%ebp)
c000d5ce:	e8 0d fc ff ff       	call   c000d1e0 <release_prog_resource>
c000d5d3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/wait_exit.c:167

	/* 如果父进程正在等待子进程退出,将父进程唤醒 */
	struct task_struct* parent_thread = pid2thread(child_thread->parent_pid);
c000d5d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000d5d9:	0f b7 80 10 01 00 00 	movzwl 0x110(%eax),%eax
c000d5e0:	98                   	cwtl   
c000d5e1:	83 ec 0c             	sub    $0xc,%esp
c000d5e4:	50                   	push   %eax
c000d5e5:	e8 90 73 ff ff       	call   c000497a <pid2thread>
c000d5ea:	83 c4 10             	add    $0x10,%esp
c000d5ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/wait_exit.c:168
	if (parent_thread->status == TASK_WAITING) {
c000d5f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000d5f3:	8b 40 08             	mov    0x8(%eax),%eax
c000d5f6:	83 f8 03             	cmp    $0x3,%eax
c000d5f9:	75 0e                	jne    c000d609 <sys_exit+0xa7>
/work/x86_os_my/userprog/wait_exit.c:169
		thread_unblock(parent_thread);
c000d5fb:	83 ec 0c             	sub    $0xc,%esp
c000d5fe:	ff 75 f0             	pushl  -0x10(%ebp)
c000d601:	e8 09 6e ff ff       	call   c000440f <thread_unblock>
c000d606:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/wait_exit.c:173
	}

	/* 将自己挂起,等待父进程获取其status,并回收其pcb */
	thread_block(TASK_HANGING);
c000d609:	83 ec 0c             	sub    $0xc,%esp
c000d60c:	6a 04                	push   $0x4
c000d60e:	e8 99 6d ff ff       	call   c00043ac <thread_block>
c000d613:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/wait_exit.c:174
}
c000d616:	90                   	nop
c000d617:	c9                   	leave  
c000d618:	c3                   	ret    

c000d619 <is_pipe>:
is_pipe():
/work/x86_os_my/shell/pipe.c:9
#include "file.h"
#include "ioqueue.h"
#include "thread.h"

/* 判断文件描述符local_fd是否是管道 */
bool is_pipe(uint32_t local_fd) {
c000d619:	55                   	push   %ebp
c000d61a:	89 e5                	mov    %esp,%ebp
c000d61c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/shell/pipe.c:10
	uint32_t global_fd = fd_local2global(local_fd); 
c000d61f:	83 ec 0c             	sub    $0xc,%esp
c000d622:	ff 75 08             	pushl  0x8(%ebp)
c000d625:	e8 a0 a6 ff ff       	call   c0007cca <fd_local2global>
c000d62a:	83 c4 10             	add    $0x10,%esp
c000d62d:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/shell/pipe.c:11
	return file_table[global_fd].fd_flag == PIPE_FLAG;
c000d630:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000d633:	89 d0                	mov    %edx,%eax
c000d635:	01 c0                	add    %eax,%eax
c000d637:	01 d0                	add    %edx,%eax
c000d639:	c1 e0 02             	shl    $0x2,%eax
c000d63c:	05 a4 58 01 c0       	add    $0xc00158a4,%eax
c000d641:	8b 00                	mov    (%eax),%eax
c000d643:	3d ff ff 00 00       	cmp    $0xffff,%eax
c000d648:	0f 94 c0             	sete   %al
c000d64b:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/shell/pipe.c:12
}
c000d64e:	c9                   	leave  
c000d64f:	c3                   	ret    

c000d650 <sys_pipe>:
sys_pipe():
/work/x86_os_my/shell/pipe.c:15

/* 创建管道,成功返回0,失败返回-1 */
int32_t sys_pipe(int32_t pipefd[2]) {
c000d650:	55                   	push   %ebp
c000d651:	89 e5                	mov    %esp,%ebp
c000d653:	53                   	push   %ebx
c000d654:	83 ec 14             	sub    $0x14,%esp
/work/x86_os_my/shell/pipe.c:16
	int32_t global_fd = get_free_slot_in_global();	//从file_table里面找空闲位置
c000d657:	e8 4d c3 ff ff       	call   c00099a9 <get_free_slot_in_global>
c000d65c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/shell/pipe.c:20

	/* 将fd_inode成员复用为管道的缓冲区 */
	/* 申请一页内核内存做环形缓冲区 */
	file_table[global_fd].fd_inode = get_kernel_pages(1); 
c000d65f:	83 ec 0c             	sub    $0xc,%esp
c000d662:	6a 01                	push   $0x1
c000d664:	e8 a0 55 ff ff       	call   c0002c09 <get_kernel_pages>
c000d669:	83 c4 10             	add    $0x10,%esp
c000d66c:	89 c1                	mov    %eax,%ecx
c000d66e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000d671:	89 d0                	mov    %edx,%eax
c000d673:	01 c0                	add    %eax,%eax
c000d675:	01 d0                	add    %edx,%eax
c000d677:	c1 e0 02             	shl    $0x2,%eax
c000d67a:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c000d67f:	89 08                	mov    %ecx,(%eax)
/work/x86_os_my/shell/pipe.c:23

	/* 初始化环形缓冲区 */
	ioqueue_init((struct ioqueue*)file_table[global_fd].fd_inode);
c000d681:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000d684:	89 d0                	mov    %edx,%eax
c000d686:	01 c0                	add    %eax,%eax
c000d688:	01 d0                	add    %edx,%eax
c000d68a:	c1 e0 02             	shl    $0x2,%eax
c000d68d:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c000d692:	8b 00                	mov    (%eax),%eax
c000d694:	83 ec 0c             	sub    $0xc,%esp
c000d697:	50                   	push   %eax
c000d698:	e8 71 7c ff ff       	call   c000530e <ioqueue_init>
c000d69d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/pipe.c:24
	if (file_table[global_fd].fd_inode == NULL) {
c000d6a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000d6a3:	89 d0                	mov    %edx,%eax
c000d6a5:	01 c0                	add    %eax,%eax
c000d6a7:	01 d0                	add    %edx,%eax
c000d6a9:	c1 e0 02             	shl    $0x2,%eax
c000d6ac:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c000d6b1:	8b 00                	mov    (%eax),%eax
c000d6b3:	85 c0                	test   %eax,%eax
c000d6b5:	75 07                	jne    c000d6be <sys_pipe+0x6e>
/work/x86_os_my/shell/pipe.c:25
		return -1;
c000d6b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000d6bc:	eb 5e                	jmp    c000d71c <sys_pipe+0xcc>
/work/x86_os_my/shell/pipe.c:29
	}

	/* 将fd_flag成员复用为管道标志 */
	file_table[global_fd].fd_flag = PIPE_FLAG;
c000d6be:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000d6c1:	89 d0                	mov    %edx,%eax
c000d6c3:	01 c0                	add    %eax,%eax
c000d6c5:	01 d0                	add    %edx,%eax
c000d6c7:	c1 e0 02             	shl    $0x2,%eax
c000d6ca:	05 a4 58 01 c0       	add    $0xc00158a4,%eax
c000d6cf:	c7 00 ff ff 00 00    	movl   $0xffff,(%eax)
/work/x86_os_my/shell/pipe.c:32

	/* 将fd_pos成员复用为管道打开数 */
	file_table[global_fd].fd_pos = 2;
c000d6d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000d6d8:	89 d0                	mov    %edx,%eax
c000d6da:	01 c0                	add    %eax,%eax
c000d6dc:	01 d0                	add    %edx,%eax
c000d6de:	c1 e0 02             	shl    $0x2,%eax
c000d6e1:	05 a0 58 01 c0       	add    $0xc00158a0,%eax
c000d6e6:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
/work/x86_os_my/shell/pipe.c:33
	pipefd[0] = pcb_fd_install(global_fd);	//global_fd安装到pcb中，返回文件描述符。
c000d6ec:	83 ec 0c             	sub    $0xc,%esp
c000d6ef:	ff 75 f4             	pushl  -0xc(%ebp)
c000d6f2:	e8 07 c3 ff ff       	call   c00099fe <pcb_fd_install>
c000d6f7:	83 c4 10             	add    $0x10,%esp
c000d6fa:	89 c2                	mov    %eax,%edx
c000d6fc:	8b 45 08             	mov    0x8(%ebp),%eax
c000d6ff:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/shell/pipe.c:34
	pipefd[1] = pcb_fd_install(global_fd);
c000d701:	8b 45 08             	mov    0x8(%ebp),%eax
c000d704:	8d 58 04             	lea    0x4(%eax),%ebx
c000d707:	83 ec 0c             	sub    $0xc,%esp
c000d70a:	ff 75 f4             	pushl  -0xc(%ebp)
c000d70d:	e8 ec c2 ff ff       	call   c00099fe <pcb_fd_install>
c000d712:	83 c4 10             	add    $0x10,%esp
c000d715:	89 03                	mov    %eax,(%ebx)
/work/x86_os_my/shell/pipe.c:35
	return 0;
c000d717:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/shell/pipe.c:36
}
c000d71c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000d71f:	c9                   	leave  
c000d720:	c3                   	ret    

c000d721 <pipe_read>:
pipe_read():
/work/x86_os_my/shell/pipe.c:39

/* 从管道中读数据 */
uint32_t pipe_read(int32_t fd, void* buf, uint32_t count) {
c000d721:	55                   	push   %ebp
c000d722:	89 e5                	mov    %esp,%ebp
c000d724:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/shell/pipe.c:40
	char* buffer = buf;
c000d727:	8b 45 0c             	mov    0xc(%ebp),%eax
c000d72a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/shell/pipe.c:41
	uint32_t bytes_read = 0;
c000d72d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/shell/pipe.c:42
	uint32_t global_fd = fd_local2global(fd);
c000d734:	8b 45 08             	mov    0x8(%ebp),%eax
c000d737:	83 ec 0c             	sub    $0xc,%esp
c000d73a:	50                   	push   %eax
c000d73b:	e8 8a a5 ff ff       	call   c0007cca <fd_local2global>
c000d740:	83 c4 10             	add    $0x10,%esp
c000d743:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/shell/pipe.c:45

	/* 获取管道的环形缓冲区 */
	struct ioqueue* ioq = (struct ioqueue*)file_table[global_fd].fd_inode;
c000d746:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000d749:	89 d0                	mov    %edx,%eax
c000d74b:	01 c0                	add    %eax,%eax
c000d74d:	01 d0                	add    %edx,%eax
c000d74f:	c1 e0 02             	shl    $0x2,%eax
c000d752:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c000d757:	8b 00                	mov    (%eax),%eax
c000d759:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/shell/pipe.c:48

	/* 选择较小的数据读取量,避免阻塞 */
	uint32_t ioq_len = ioq_length(ioq);
c000d75c:	83 ec 0c             	sub    $0xc,%esp
c000d75f:	ff 75 e8             	pushl  -0x18(%ebp)
c000d762:	e8 bf 7e ff ff       	call   c0005626 <ioq_length>
c000d767:	83 c4 10             	add    $0x10,%esp
c000d76a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/shell/pipe.c:49
	uint32_t size = ioq_len > count ? count : ioq_len;
c000d76d:	8b 45 10             	mov    0x10(%ebp),%eax
c000d770:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c000d773:	0f 46 45 e4          	cmovbe -0x1c(%ebp),%eax
c000d777:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/shell/pipe.c:50
	while (bytes_read < size) {
c000d77a:	eb 1d                	jmp    c000d799 <pipe_read+0x78>
/work/x86_os_my/shell/pipe.c:51
		*buffer = ioq_getchar(ioq);
c000d77c:	83 ec 0c             	sub    $0xc,%esp
c000d77f:	ff 75 e8             	pushl  -0x18(%ebp)
c000d782:	e8 18 7d ff ff       	call   c000549f <ioq_getchar>
c000d787:	83 c4 10             	add    $0x10,%esp
c000d78a:	89 c2                	mov    %eax,%edx
c000d78c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000d78f:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/shell/pipe.c:52
		bytes_read++;
c000d791:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/shell/pipe.c:53
		buffer++;
c000d795:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/shell/pipe.c:50
	struct ioqueue* ioq = (struct ioqueue*)file_table[global_fd].fd_inode;

	/* 选择较小的数据读取量,避免阻塞 */
	uint32_t ioq_len = ioq_length(ioq);
	uint32_t size = ioq_len > count ? count : ioq_len;
	while (bytes_read < size) {
c000d799:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000d79c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c000d79f:	72 db                	jb     c000d77c <pipe_read+0x5b>
/work/x86_os_my/shell/pipe.c:55
		*buffer = ioq_getchar(ioq);
		bytes_read++;
		buffer++;
	}
	return bytes_read;
c000d7a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/shell/pipe.c:56
}
c000d7a4:	c9                   	leave  
c000d7a5:	c3                   	ret    

c000d7a6 <pipe_write>:
pipe_write():
/work/x86_os_my/shell/pipe.c:59

/* 往管道中写数据 */
uint32_t pipe_write(int32_t fd, const void* buf, uint32_t count) {
c000d7a6:	55                   	push   %ebp
c000d7a7:	89 e5                	mov    %esp,%ebp
c000d7a9:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/shell/pipe.c:60
	uint32_t bytes_write = 0;
c000d7ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/shell/pipe.c:61
	uint32_t global_fd = fd_local2global(fd);
c000d7b3:	8b 45 08             	mov    0x8(%ebp),%eax
c000d7b6:	83 ec 0c             	sub    $0xc,%esp
c000d7b9:	50                   	push   %eax
c000d7ba:	e8 0b a5 ff ff       	call   c0007cca <fd_local2global>
c000d7bf:	83 c4 10             	add    $0x10,%esp
c000d7c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/shell/pipe.c:62
	struct ioqueue* ioq = (struct ioqueue*)file_table[global_fd].fd_inode;
c000d7c5:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000d7c8:	89 d0                	mov    %edx,%eax
c000d7ca:	01 c0                	add    %eax,%eax
c000d7cc:	01 d0                	add    %edx,%eax
c000d7ce:	c1 e0 02             	shl    $0x2,%eax
c000d7d1:	05 a8 58 01 c0       	add    $0xc00158a8,%eax
c000d7d6:	8b 00                	mov    (%eax),%eax
c000d7d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/shell/pipe.c:65

	/* 选择较小的数据写入量,避免阻塞 */
	uint32_t ioq_left = bufsize - ioq_length(ioq);
c000d7db:	83 ec 0c             	sub    $0xc,%esp
c000d7de:	ff 75 e8             	pushl  -0x18(%ebp)
c000d7e1:	e8 40 7e ff ff       	call   c0005626 <ioq_length>
c000d7e6:	83 c4 10             	add    $0x10,%esp
c000d7e9:	ba 00 08 00 00       	mov    $0x800,%edx
c000d7ee:	29 c2                	sub    %eax,%edx
c000d7f0:	89 d0                	mov    %edx,%eax
c000d7f2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/shell/pipe.c:66
	uint32_t size = ioq_left > count ? count : ioq_left;
c000d7f5:	8b 45 10             	mov    0x10(%ebp),%eax
c000d7f8:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c000d7fb:	0f 46 45 e4          	cmovbe -0x1c(%ebp),%eax
c000d7ff:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/shell/pipe.c:68

	const char* buffer = buf;
c000d802:	8b 45 0c             	mov    0xc(%ebp),%eax
c000d805:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/shell/pipe.c:69
	while (bytes_write < size) {
c000d808:	eb 20                	jmp    c000d82a <pipe_write+0x84>
/work/x86_os_my/shell/pipe.c:70
		ioq_putchar(ioq, *buffer);
c000d80a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000d80d:	0f b6 00             	movzbl (%eax),%eax
c000d810:	0f be c0             	movsbl %al,%eax
c000d813:	83 ec 08             	sub    $0x8,%esp
c000d816:	50                   	push   %eax
c000d817:	ff 75 e8             	pushl  -0x18(%ebp)
c000d81a:	e8 42 7d ff ff       	call   c0005561 <ioq_putchar>
c000d81f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/shell/pipe.c:71
		bytes_write++;
c000d822:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/shell/pipe.c:72
		buffer++;
c000d826:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/shell/pipe.c:69
	/* 选择较小的数据写入量,避免阻塞 */
	uint32_t ioq_left = bufsize - ioq_length(ioq);
	uint32_t size = ioq_left > count ? count : ioq_left;

	const char* buffer = buf;
	while (bytes_write < size) {
c000d82a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000d82d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c000d830:	72 d8                	jb     c000d80a <pipe_write+0x64>
/work/x86_os_my/shell/pipe.c:74
		ioq_putchar(ioq, *buffer);
		bytes_write++;
		buffer++;
	}
	return bytes_write;
c000d832:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/shell/pipe.c:75
}
c000d835:	c9                   	leave  
c000d836:	c3                   	ret    

c000d837 <sys_fd_redirect>:
sys_fd_redirect():
/work/x86_os_my/shell/pipe.c:78

/* 将文件描述符old_local_fd重定向为new_local_fd */
void sys_fd_redirect(uint32_t old_local_fd, uint32_t new_local_fd) {
c000d837:	55                   	push   %ebp
c000d838:	89 e5                	mov    %esp,%ebp
c000d83a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/shell/pipe.c:79
	struct task_struct* cur = running_thread();
c000d83d:	e8 0a 66 ff ff       	call   c0003e4c <running_thread>
c000d842:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/shell/pipe.c:81
	/* 针对恢复标准描述符 */
	if (new_local_fd < 3) {
c000d845:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
c000d849:	77 12                	ja     c000d85d <sys_fd_redirect+0x26>
/work/x86_os_my/shell/pipe.c:83
		//pcb 中文件描述符表 fd_table 和全局文件表 file_table 中的前 3 个元素都是预留的，可以通用~
		cur->fd_table[old_local_fd] = new_local_fd;
c000d84b:	8b 55 0c             	mov    0xc(%ebp),%edx
c000d84e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000d851:	8b 4d 08             	mov    0x8(%ebp),%ecx
c000d854:	83 c1 08             	add    $0x8,%ecx
c000d857:	89 54 88 04          	mov    %edx,0x4(%eax,%ecx,4)
/work/x86_os_my/shell/pipe.c:88
	} else {
		uint32_t new_global_fd = cur->fd_table[new_local_fd];
		cur->fd_table[old_local_fd] = new_global_fd;
	}
}
c000d85b:	eb 20                	jmp    c000d87d <sys_fd_redirect+0x46>
/work/x86_os_my/shell/pipe.c:85
	/* 针对恢复标准描述符 */
	if (new_local_fd < 3) {
		//pcb 中文件描述符表 fd_table 和全局文件表 file_table 中的前 3 个元素都是预留的，可以通用~
		cur->fd_table[old_local_fd] = new_local_fd;
	} else {
		uint32_t new_global_fd = cur->fd_table[new_local_fd];
c000d85d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000d860:	8b 55 0c             	mov    0xc(%ebp),%edx
c000d863:	83 c2 08             	add    $0x8,%edx
c000d866:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
c000d86a:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/shell/pipe.c:86
		cur->fd_table[old_local_fd] = new_global_fd;
c000d86d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000d870:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000d873:	8b 4d 08             	mov    0x8(%ebp),%ecx
c000d876:	83 c1 08             	add    $0x8,%ecx
c000d879:	89 54 88 04          	mov    %edx,0x4(%eax,%ecx,4)
/work/x86_os_my/shell/pipe.c:88
	}
}
c000d87d:	90                   	nop
c000d87e:	c9                   	leave  
c000d87f:	c3                   	ret    
