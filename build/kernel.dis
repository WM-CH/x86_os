
./build/kernel.bin:     file format elf32-i386


Disassembly of section .text:

c0001500 <main>:
main():
/work/x86_os_my/kernel/main.c:31
*/
/*
用户进程
u_prog_a 的地址是在 0xc0000000 以上，位于内核空间，但这并不表示它无法模拟用户进程。
*/
int main(void) {
c0001500:	8d 4c 24 04          	lea    0x4(%esp),%ecx
c0001504:	83 e4 f0             	and    $0xfffffff0,%esp
c0001507:	ff 71 fc             	pushl  -0x4(%ecx)
c000150a:	55                   	push   %ebp
c000150b:	89 e5                	mov    %esp,%ebp
c000150d:	51                   	push   %ecx
c000150e:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/kernel/main.c:32
   put_str("I am kernel\n");
c0001511:	83 ec 0c             	sub    $0xc,%esp
c0001514:	68 f4 4b 00 c0       	push   $0xc0004bf4
c0001519:	e8 d2 0c 00 00       	call   c00021f0 <put_str>
c000151e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:33
   init_all();
c0001521:	e8 57 01 00 00       	call   c000167d <init_all>
/work/x86_os_my/kernel/main.c:35

   process_execute(u_prog_a, "u_prog_a");
c0001526:	83 ec 08             	sub    $0x8,%esp
c0001529:	68 01 4c 00 c0       	push   $0xc0004c01
c000152e:	68 2f 16 00 c0       	push   $0xc000162f
c0001533:	e8 7c 32 00 00       	call   c00047b4 <process_execute>
c0001538:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:36
   process_execute(u_prog_b, "u_prog_b");
c000153b:	83 ec 08             	sub    $0x8,%esp
c000153e:	68 0a 4c 00 c0       	push   $0xc0004c0a
c0001543:	68 56 16 00 c0       	push   $0xc0001656
c0001548:	e8 67 32 00 00       	call   c00047b4 <process_execute>
c000154d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:38

   console_put_str(" I am main, my pid:0x");
c0001550:	83 ec 0c             	sub    $0xc,%esp
c0001553:	68 13 4c 00 c0       	push   $0xc0004c13
c0001558:	e8 13 25 00 00       	call   c0003a70 <console_put_str>
c000155d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:39
   console_put_int(sys_getpid());
c0001560:	e8 92 33 00 00       	call   c00048f7 <sys_getpid>
c0001565:	83 ec 0c             	sub    $0xc,%esp
c0001568:	50                   	push   %eax
c0001569:	e8 4c 25 00 00       	call   c0003aba <console_put_int>
c000156e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:40
   console_put_char('\n');
c0001571:	83 ec 0c             	sub    $0xc,%esp
c0001574:	6a 0a                	push   $0xa
c0001576:	e8 16 25 00 00       	call   c0003a91 <console_put_char>
c000157b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:41
   intr_enable();
c000157e:	e8 8d 04 00 00       	call   c0001a10 <intr_enable>
/work/x86_os_my/kernel/main.c:42
   thread_start("k_thread_a", 31, k_thread_a, "I am thread_a");
c0001583:	68 29 4c 00 c0       	push   $0xc0004c29
c0001588:	68 b7 15 00 c0       	push   $0xc00015b7
c000158d:	6a 1f                	push   $0x1f
c000158f:	68 37 4c 00 c0       	push   $0xc0004c37
c0001594:	e8 49 1e 00 00       	call   c00033e2 <thread_start>
c0001599:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:43
   thread_start("k_thread_b", 31, k_thread_b, "I am thread_b ");
c000159c:	68 42 4c 00 c0       	push   $0xc0004c42
c00015a1:	68 f3 15 00 c0       	push   $0xc00015f3
c00015a6:	6a 1f                	push   $0x1f
c00015a8:	68 51 4c 00 c0       	push   $0xc0004c51
c00015ad:	e8 30 1e 00 00       	call   c00033e2 <thread_start>
c00015b2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:44 (discriminator 1)
   while(1);
c00015b5:	eb fe                	jmp    c00015b5 <main+0xb5>

c00015b7 <k_thread_a>:
k_thread_a():
/work/x86_os_my/kernel/main.c:49
   return 0;
}

/* 在线程中运行的函数 */
void k_thread_a(void* arg) {     
c00015b7:	55                   	push   %ebp
c00015b8:	89 e5                	mov    %esp,%ebp
c00015ba:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:50
   char* para = arg;
c00015bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00015c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:51
   console_put_str(" I am thread_a, my pid:0x");
c00015c3:	83 ec 0c             	sub    $0xc,%esp
c00015c6:	68 5c 4c 00 c0       	push   $0xc0004c5c
c00015cb:	e8 a0 24 00 00       	call   c0003a70 <console_put_str>
c00015d0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:52
   console_put_int(sys_getpid());
c00015d3:	e8 1f 33 00 00       	call   c00048f7 <sys_getpid>
c00015d8:	83 ec 0c             	sub    $0xc,%esp
c00015db:	50                   	push   %eax
c00015dc:	e8 d9 24 00 00       	call   c0003aba <console_put_int>
c00015e1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:53
   console_put_char('\n');
c00015e4:	83 ec 0c             	sub    $0xc,%esp
c00015e7:	6a 0a                	push   $0xa
c00015e9:	e8 a3 24 00 00       	call   c0003a91 <console_put_char>
c00015ee:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:54 (discriminator 1)
   while(1);
c00015f1:	eb fe                	jmp    c00015f1 <k_thread_a+0x3a>

c00015f3 <k_thread_b>:
k_thread_b():
/work/x86_os_my/kernel/main.c:58
}

/* 在线程中运行的函数 */
void k_thread_b(void* arg) {     
c00015f3:	55                   	push   %ebp
c00015f4:	89 e5                	mov    %esp,%ebp
c00015f6:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:59
   char* para = arg;
c00015f9:	8b 45 08             	mov    0x8(%ebp),%eax
c00015fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:60
   console_put_str(" I am thread_b, my pid:0x");
c00015ff:	83 ec 0c             	sub    $0xc,%esp
c0001602:	68 76 4c 00 c0       	push   $0xc0004c76
c0001607:	e8 64 24 00 00       	call   c0003a70 <console_put_str>
c000160c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:61
   console_put_int(sys_getpid());
c000160f:	e8 e3 32 00 00       	call   c00048f7 <sys_getpid>
c0001614:	83 ec 0c             	sub    $0xc,%esp
c0001617:	50                   	push   %eax
c0001618:	e8 9d 24 00 00       	call   c0003aba <console_put_int>
c000161d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:62
   console_put_char('\n');
c0001620:	83 ec 0c             	sub    $0xc,%esp
c0001623:	6a 0a                	push   $0xa
c0001625:	e8 67 24 00 00       	call   c0003a91 <console_put_char>
c000162a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:63 (discriminator 1)
   while(1);
c000162d:	eb fe                	jmp    c000162d <k_thread_b+0x3a>

c000162f <u_prog_a>:
u_prog_a():
/work/x86_os_my/kernel/main.c:67
}

/* 测试用户进程 */
void u_prog_a(void) {
c000162f:	55                   	push   %ebp
c0001630:	89 e5                	mov    %esp,%ebp
c0001632:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:68
   char* name = "prog_a";
c0001635:	c7 45 f4 90 4c 00 c0 	movl   $0xc0004c90,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:69
   printf(" I am %s, my pid:%d%c", name, getpid(),'\n');
c000163c:	e8 82 32 00 00       	call   c00048c3 <getpid>
c0001641:	6a 0a                	push   $0xa
c0001643:	50                   	push   %eax
c0001644:	ff 75 f4             	pushl  -0xc(%ebp)
c0001647:	68 97 4c 00 c0       	push   $0xc0004c97
c000164c:	e8 45 35 00 00       	call   c0004b96 <printf>
c0001651:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:70 (discriminator 1)
   while(1);
c0001654:	eb fe                	jmp    c0001654 <u_prog_a+0x25>

c0001656 <u_prog_b>:
u_prog_b():
/work/x86_os_my/kernel/main.c:74
}

/* 测试用户进程 */
void u_prog_b(void) {
c0001656:	55                   	push   %ebp
c0001657:	89 e5                	mov    %esp,%ebp
c0001659:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:75
   char* name = "prog_b";
c000165c:	c7 45 f4 ad 4c 00 c0 	movl   $0xc0004cad,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:76
   printf(" I am %s, my pid:%d%c", name, getpid(), '\n');
c0001663:	e8 5b 32 00 00       	call   c00048c3 <getpid>
c0001668:	6a 0a                	push   $0xa
c000166a:	50                   	push   %eax
c000166b:	ff 75 f4             	pushl  -0xc(%ebp)
c000166e:	68 97 4c 00 c0       	push   $0xc0004c97
c0001673:	e8 1e 35 00 00       	call   c0004b96 <printf>
c0001678:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:77 (discriminator 1)
   while(1);
c000167b:	eb fe                	jmp    c000167b <u_prog_b+0x25>

c000167d <init_all>:
init_all():
/work/x86_os_my/kernel/init.c:13
#include "keyboard.h"
#include "tss.h"
#include "syscall-init.h"

/*负责初始化所有模块 */
void init_all() {
c000167d:	55                   	push   %ebp
c000167e:	89 e5                	mov    %esp,%ebp
c0001680:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/init.c:14
	put_str("init_all\n");
c0001683:	83 ec 0c             	sub    $0xc,%esp
c0001686:	68 b4 4c 00 c0       	push   $0xc0004cb4
c000168b:	e8 60 0b 00 00       	call   c00021f0 <put_str>
c0001690:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/init.c:15
	idt_init();			// 初始化中断
c0001693:	e8 29 04 00 00       	call   c0001ac1 <idt_init>
/work/x86_os_my/kernel/init.c:16
	mem_init();			// 初始化内存管理系统
c0001698:	e8 ac 17 00 00       	call   c0002e49 <mem_init>
/work/x86_os_my/kernel/init.c:17
	thread_init();		// 初始化线程相关结构
c000169d:	e8 1b 21 00 00       	call   c00037bd <thread_init>
/work/x86_os_my/kernel/init.c:18
	timer_init();		// 初始化PIT
c00016a2:	e8 94 05 00 00       	call   c0001c3b <timer_init>
/work/x86_os_my/kernel/init.c:19
	console_init();		// 控制台初始化最好放在开中断之前
c00016a7:	e8 79 23 00 00       	call   c0003a25 <console_init>
/work/x86_os_my/kernel/init.c:20
	keyboard_init();	// 键盘初始化
c00016ac:	e8 f2 29 00 00       	call   c00040a3 <keyboard_init>
/work/x86_os_my/kernel/init.c:21
	tss_init();			// tss初始化
c00016b1:	e8 a8 2d 00 00       	call   c000445e <tss_init>
/work/x86_os_my/kernel/init.c:22
	syscall_init();		// 初始化系统调用
c00016b6:	e8 72 32 00 00       	call   c000492d <syscall_init>
/work/x86_os_my/kernel/init.c:23
}
c00016bb:	90                   	nop
c00016bc:	c9                   	leave  
c00016bd:	c3                   	ret    

c00016be <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c00016be:	55                   	push   %ebp
c00016bf:	89 e5                	mov    %esp,%ebp
c00016c1:	83 ec 08             	sub    $0x8,%esp
c00016c4:	8b 55 08             	mov    0x8(%ebp),%edx
c00016c7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00016ca:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c00016ce:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c00016d1:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c00016d5:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c00016d9:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c00016da:	90                   	nop
c00016db:	c9                   	leave  
c00016dc:	c3                   	ret    

c00016dd <pic_init>:
pic_init():
/work/x86_os_my/kernel/interrupt.c:41
//自定义类型 intr_handler = void*
extern intr_handler intr_entry_table[IDT_DESC_CNT];	    // 声明引用汇编kernel.S中的中断处理函数入口数组

/* 初始化可编程中断控制器8259A */
// outb 来着 lib/kernel/io.h 内联汇编写法
static void pic_init(void) {
c00016dd:	55                   	push   %ebp
c00016de:	89 e5                	mov    %esp,%ebp
c00016e0:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:43
	/* 初始化主片 */
	outb (PIC_M_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c00016e3:	6a 11                	push   $0x11
c00016e5:	6a 20                	push   $0x20
c00016e7:	e8 d2 ff ff ff       	call   c00016be <outb>
c00016ec:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:44
	outb (PIC_M_DATA, 0x20);	// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.
c00016ef:	6a 20                	push   $0x20
c00016f1:	6a 21                	push   $0x21
c00016f3:	e8 c6 ff ff ff       	call   c00016be <outb>
c00016f8:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:45
	outb (PIC_M_DATA, 0x04);	// ICW3: IR2接从片. 
c00016fb:	6a 04                	push   $0x4
c00016fd:	6a 21                	push   $0x21
c00016ff:	e8 ba ff ff ff       	call   c00016be <outb>
c0001704:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:46
	outb (PIC_M_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c0001707:	6a 01                	push   $0x1
c0001709:	6a 21                	push   $0x21
c000170b:	e8 ae ff ff ff       	call   c00016be <outb>
c0001710:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:49

	/* 初始化从片 */
	outb (PIC_S_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c0001713:	6a 11                	push   $0x11
c0001715:	68 a0 00 00 00       	push   $0xa0
c000171a:	e8 9f ff ff ff       	call   c00016be <outb>
c000171f:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:50
	outb (PIC_S_DATA, 0x28);	// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.
c0001722:	6a 28                	push   $0x28
c0001724:	68 a1 00 00 00       	push   $0xa1
c0001729:	e8 90 ff ff ff       	call   c00016be <outb>
c000172e:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:51
	outb (PIC_S_DATA, 0x02);	// ICW3: 设置从片连接到主片的IR2引脚
c0001731:	6a 02                	push   $0x2
c0001733:	68 a1 00 00 00       	push   $0xa1
c0001738:	e8 81 ff ff ff       	call   c00016be <outb>
c000173d:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:52
	outb (PIC_S_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c0001740:	6a 01                	push   $0x1
c0001742:	68 a1 00 00 00       	push   $0xa1
c0001747:	e8 72 ff ff ff       	call   c00016be <outb>
c000174c:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:55

	/* 打开主片上IR0,也就是目前只接受 时钟0xfe、时钟和键盘0xfc 产生的中断 */
	outb (PIC_M_DATA, 0xfe);
c000174f:	68 fe 00 00 00       	push   $0xfe
c0001754:	6a 21                	push   $0x21
c0001756:	e8 63 ff ff ff       	call   c00016be <outb>
c000175b:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:56
	outb (PIC_S_DATA, 0xff);
c000175e:	68 ff 00 00 00       	push   $0xff
c0001763:	68 a1 00 00 00       	push   $0xa1
c0001768:	e8 51 ff ff ff       	call   c00016be <outb>
c000176d:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:58

	put_str("   pic_init done\n");
c0001770:	83 ec 0c             	sub    $0xc,%esp
c0001773:	68 c0 4c 00 c0       	push   $0xc0004cc0
c0001778:	e8 73 0a 00 00       	call   c00021f0 <put_str>
c000177d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:59
}
c0001780:	90                   	nop
c0001781:	c9                   	leave  
c0001782:	c3                   	ret    

c0001783 <make_idt_desc>:
make_idt_desc():
/work/x86_os_my/kernel/interrupt.c:62

/* 创建中断门描述符 */
static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function) { 
c0001783:	55                   	push   %ebp
c0001784:	89 e5                	mov    %esp,%ebp
c0001786:	83 ec 04             	sub    $0x4,%esp
c0001789:	8b 45 0c             	mov    0xc(%ebp),%eax
c000178c:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:63
	p_gdesc->func_offset_low_word = (uint32_t)function & 0x0000FFFF;
c000178f:	8b 45 10             	mov    0x10(%ebp),%eax
c0001792:	89 c2                	mov    %eax,%edx
c0001794:	8b 45 08             	mov    0x8(%ebp),%eax
c0001797:	66 89 10             	mov    %dx,(%eax)
/work/x86_os_my/kernel/interrupt.c:64
	p_gdesc->selector = SELECTOR_K_CODE;
c000179a:	8b 45 08             	mov    0x8(%ebp),%eax
c000179d:	66 c7 40 02 08 00    	movw   $0x8,0x2(%eax)
/work/x86_os_my/kernel/interrupt.c:65
	p_gdesc->dcount = 0;
c00017a3:	8b 45 08             	mov    0x8(%ebp),%eax
c00017a6:	c6 40 04 00          	movb   $0x0,0x4(%eax)
/work/x86_os_my/kernel/interrupt.c:66
	p_gdesc->attribute = attr;
c00017aa:	8b 45 08             	mov    0x8(%ebp),%eax
c00017ad:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c00017b1:	88 50 05             	mov    %dl,0x5(%eax)
/work/x86_os_my/kernel/interrupt.c:67
	p_gdesc->func_offset_high_word = ((uint32_t)function & 0xFFFF0000) >> 16;
c00017b4:	8b 45 10             	mov    0x10(%ebp),%eax
c00017b7:	c1 e8 10             	shr    $0x10,%eax
c00017ba:	89 c2                	mov    %eax,%edx
c00017bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00017bf:	66 89 50 06          	mov    %dx,0x6(%eax)
/work/x86_os_my/kernel/interrupt.c:68
}
c00017c3:	90                   	nop
c00017c4:	c9                   	leave  
c00017c5:	c3                   	ret    

c00017c6 <idt_desc_init>:
idt_desc_init():
/work/x86_os_my/kernel/interrupt.c:71

/*初始化中断描述符表*/
static void idt_desc_init(void) {
c00017c6:	55                   	push   %ebp
c00017c7:	89 e5                	mov    %esp,%ebp
c00017c9:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:73
	int i;
	int lastindex = IDT_DESC_CNT - 1;
c00017cc:	c7 45 f0 80 00 00 00 	movl   $0x80,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:74
	for (i = 0; i < IDT_DESC_CNT; i++) {
c00017d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00017da:	eb 29                	jmp    c0001805 <idt_desc_init+0x3f>
/work/x86_os_my/kernel/interrupt.c:75 (discriminator 3)
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
c00017dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00017df:	8b 04 85 00 70 00 c0 	mov    -0x3fff9000(,%eax,4),%eax
c00017e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00017e9:	c1 e2 03             	shl    $0x3,%edx
c00017ec:	81 c2 60 71 00 c0    	add    $0xc0007160,%edx
c00017f2:	50                   	push   %eax
c00017f3:	68 8e 00 00 00       	push   $0x8e
c00017f8:	52                   	push   %edx
c00017f9:	e8 85 ff ff ff       	call   c0001783 <make_idt_desc>
c00017fe:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/kernel/interrupt.c:74 (discriminator 3)

/*初始化中断描述符表*/
static void idt_desc_init(void) {
	int i;
	int lastindex = IDT_DESC_CNT - 1;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001801:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:74 (discriminator 1)
c0001805:	81 7d f4 80 00 00 00 	cmpl   $0x80,-0xc(%ebp)
c000180c:	7e ce                	jle    c00017dc <idt_desc_init+0x16>
/work/x86_os_my/kernel/interrupt.c:79
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
	}
	/* 系统调用对应的中断门dpl为3！
	 * 中断处理程序为单独的syscall_handler */
	make_idt_desc(&idt[lastindex], IDT_DESC_ATTR_DPL3, syscall_handler);
c000180e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001811:	c1 e0 03             	shl    $0x3,%eax
c0001814:	05 60 71 00 c0       	add    $0xc0007160,%eax
c0001819:	68 c7 21 00 c0       	push   $0xc00021c7
c000181e:	68 ee 00 00 00       	push   $0xee
c0001823:	50                   	push   %eax
c0001824:	e8 5a ff ff ff       	call   c0001783 <make_idt_desc>
c0001829:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/kernel/interrupt.c:80
	put_str("   idt_desc_init done\n");
c000182c:	83 ec 0c             	sub    $0xc,%esp
c000182f:	68 d2 4c 00 c0       	push   $0xc0004cd2
c0001834:	e8 b7 09 00 00       	call   c00021f0 <put_str>
c0001839:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:81
}
c000183c:	90                   	nop
c000183d:	c9                   	leave  
c000183e:	c3                   	ret    

c000183f <general_intr_handler>:
general_intr_handler():
/work/x86_os_my/kernel/interrupt.c:84

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
c000183f:	55                   	push   %ebp
c0001840:	89 e5                	mov    %esp,%ebp
c0001842:	83 ec 28             	sub    $0x28,%esp
c0001845:	8b 45 08             	mov    0x8(%ebp),%eax
c0001848:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/kernel/interrupt.c:85
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
c000184b:	80 7d e4 27          	cmpb   $0x27,-0x1c(%ebp)
c000184f:	0f 84 bf 00 00 00    	je     c0001914 <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:85 (discriminator 1)
c0001855:	80 7d e4 2f          	cmpb   $0x2f,-0x1c(%ebp)
c0001859:	0f 84 b5 00 00 00    	je     c0001914 <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:90
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
c000185f:	83 ec 0c             	sub    $0xc,%esp
c0001862:	6a 00                	push   $0x0
c0001864:	e8 d5 0a 00 00       	call   c000233e <set_cursor>
c0001869:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:91
	int cursor_pos = 0;
c000186c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:92
	while(cursor_pos < 320) {
c0001873:	eb 11                	jmp    c0001886 <general_intr_handler+0x47>
/work/x86_os_my/kernel/interrupt.c:93
		put_char(' ');
c0001875:	83 ec 0c             	sub    $0xc,%esp
c0001878:	6a 20                	push   $0x20
c000187a:	e8 8f 09 00 00       	call   c000220e <put_char>
c000187f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:94
		cursor_pos++;
c0001882:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:92
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
	int cursor_pos = 0;
	while(cursor_pos < 320) {
c0001886:	81 7d f4 3f 01 00 00 	cmpl   $0x13f,-0xc(%ebp)
c000188d:	7e e6                	jle    c0001875 <general_intr_handler+0x36>
/work/x86_os_my/kernel/interrupt.c:98
		put_char(' ');
		cursor_pos++;
	}

	/* 将光标置为左上角 打印信息 */
	set_cursor(0);
c000188f:	83 ec 0c             	sub    $0xc,%esp
c0001892:	6a 00                	push   $0x0
c0001894:	e8 a5 0a 00 00       	call   c000233e <set_cursor>
c0001899:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:99
	put_str("!!!!!!!      excetion message begin  !!!!!!!!\n");
c000189c:	83 ec 0c             	sub    $0xc,%esp
c000189f:	68 ec 4c 00 c0       	push   $0xc0004cec
c00018a4:	e8 47 09 00 00       	call   c00021f0 <put_str>
c00018a9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:100
	set_cursor(88);			// 第2行第8个字符
c00018ac:	83 ec 0c             	sub    $0xc,%esp
c00018af:	6a 58                	push   $0x58
c00018b1:	e8 88 0a 00 00       	call   c000233e <set_cursor>
c00018b6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:101
	put_str(intr_name[vec_nr]);
c00018b9:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c00018bd:	8b 04 85 20 76 00 c0 	mov    -0x3fff89e0(,%eax,4),%eax
c00018c4:	83 ec 0c             	sub    $0xc,%esp
c00018c7:	50                   	push   %eax
c00018c8:	e8 23 09 00 00       	call   c00021f0 <put_str>
c00018cd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:102
	if (vec_nr == 14) {		// 若为Pagefault,将缺失的地址打印出来并悬停
c00018d0:	80 7d e4 0e          	cmpb   $0xe,-0x1c(%ebp)
c00018d4:	75 2c                	jne    c0001902 <general_intr_handler+0xc3>
/work/x86_os_my/kernel/interrupt.c:103
		int page_fault_vaddr = 0; 
c00018d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:104
		asm ("movl %%cr2, %0" : "=r" (page_fault_vaddr));	  // cr2是存放造成page_fault的地址
c00018dd:	0f 20 d0             	mov    %cr2,%eax
c00018e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:105
		put_str("\npage fault addr is ");
c00018e3:	83 ec 0c             	sub    $0xc,%esp
c00018e6:	68 1b 4d 00 c0       	push   $0xc0004d1b
c00018eb:	e8 00 09 00 00       	call   c00021f0 <put_str>
c00018f0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:106
		put_int(page_fault_vaddr); 
c00018f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00018f6:	83 ec 0c             	sub    $0xc,%esp
c00018f9:	50                   	push   %eax
c00018fa:	e8 dc 09 00 00       	call   c00022db <put_int>
c00018ff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:108
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
c0001902:	83 ec 0c             	sub    $0xc,%esp
c0001905:	68 30 4d 00 c0       	push   $0xc0004d30
c000190a:	e8 e1 08 00 00       	call   c00021f0 <put_str>
c000190f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:111 (discriminator 1)
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
c0001912:	eb fe                	jmp    c0001912 <general_intr_handler+0xd3>
/work/x86_os_my/kernel/interrupt.c:86
}

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
c0001914:	90                   	nop
/work/x86_os_my/kernel/interrupt.c:112
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
}
c0001915:	c9                   	leave  
c0001916:	c3                   	ret    

c0001917 <exception_init>:
exception_init():
/work/x86_os_my/kernel/interrupt.c:115

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
c0001917:	55                   	push   %ebp
c0001918:	89 e5                	mov    %esp,%ebp
c000191a:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:117
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c000191d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0001924:	eb 20                	jmp    c0001946 <exception_init+0x2f>
/work/x86_os_my/kernel/interrupt.c:120 (discriminator 3)
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
c0001926:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001929:	c7 04 85 40 78 00 c0 	movl   $0xc000183f,-0x3fff87c0(,%eax,4)
c0001930:	3f 18 00 c0 
/work/x86_os_my/kernel/interrupt.c:121 (discriminator 3)
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
c0001934:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001937:	c7 04 85 20 76 00 c0 	movl   $0xc0004d60,-0x3fff89e0(,%eax,4)
c000193e:	60 4d 00 c0 
/work/x86_os_my/kernel/interrupt.c:117 (discriminator 3)
}

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001942:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:117 (discriminator 1)
c0001946:	81 7d fc 80 00 00 00 	cmpl   $0x80,-0x4(%ebp)
c000194d:	7e d7                	jle    c0001926 <exception_init+0xf>
/work/x86_os_my/kernel/interrupt.c:123
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
	}
	intr_name[0] = "#DE Divide Error";
c000194f:	c7 05 20 76 00 c0 68 	movl   $0xc0004d68,0xc0007620
c0001956:	4d 00 c0 
/work/x86_os_my/kernel/interrupt.c:124
	intr_name[1] = "#DB Debug Exception";
c0001959:	c7 05 24 76 00 c0 79 	movl   $0xc0004d79,0xc0007624
c0001960:	4d 00 c0 
/work/x86_os_my/kernel/interrupt.c:125
	intr_name[2] = "NMI Interrupt";
c0001963:	c7 05 28 76 00 c0 8d 	movl   $0xc0004d8d,0xc0007628
c000196a:	4d 00 c0 
/work/x86_os_my/kernel/interrupt.c:126
	intr_name[3] = "#BP Breakpoint Exception";
c000196d:	c7 05 2c 76 00 c0 9b 	movl   $0xc0004d9b,0xc000762c
c0001974:	4d 00 c0 
/work/x86_os_my/kernel/interrupt.c:127
	intr_name[4] = "#OF Overflow Exception";
c0001977:	c7 05 30 76 00 c0 b4 	movl   $0xc0004db4,0xc0007630
c000197e:	4d 00 c0 
/work/x86_os_my/kernel/interrupt.c:128
	intr_name[5] = "#BR BOUND Range Exceeded Exception";
c0001981:	c7 05 34 76 00 c0 cc 	movl   $0xc0004dcc,0xc0007634
c0001988:	4d 00 c0 
/work/x86_os_my/kernel/interrupt.c:129
	intr_name[6] = "#UD Invalid Opcode Exception";
c000198b:	c7 05 38 76 00 c0 ef 	movl   $0xc0004def,0xc0007638
c0001992:	4d 00 c0 
/work/x86_os_my/kernel/interrupt.c:130
	intr_name[7] = "#NM Device Not Available Exception";
c0001995:	c7 05 3c 76 00 c0 0c 	movl   $0xc0004e0c,0xc000763c
c000199c:	4e 00 c0 
/work/x86_os_my/kernel/interrupt.c:131
	intr_name[8] = "#DF Double Fault Exception";
c000199f:	c7 05 40 76 00 c0 2f 	movl   $0xc0004e2f,0xc0007640
c00019a6:	4e 00 c0 
/work/x86_os_my/kernel/interrupt.c:132
	intr_name[9] = "Coprocessor Segment Overrun";
c00019a9:	c7 05 44 76 00 c0 4a 	movl   $0xc0004e4a,0xc0007644
c00019b0:	4e 00 c0 
/work/x86_os_my/kernel/interrupt.c:133
	intr_name[10] = "#TS Invalid TSS Exception";
c00019b3:	c7 05 48 76 00 c0 66 	movl   $0xc0004e66,0xc0007648
c00019ba:	4e 00 c0 
/work/x86_os_my/kernel/interrupt.c:134
	intr_name[11] = "#NP Segment Not Present";
c00019bd:	c7 05 4c 76 00 c0 80 	movl   $0xc0004e80,0xc000764c
c00019c4:	4e 00 c0 
/work/x86_os_my/kernel/interrupt.c:135
	intr_name[12] = "#SS Stack Fault Exception";
c00019c7:	c7 05 50 76 00 c0 98 	movl   $0xc0004e98,0xc0007650
c00019ce:	4e 00 c0 
/work/x86_os_my/kernel/interrupt.c:136
	intr_name[13] = "#GP General Protection Exception";
c00019d1:	c7 05 54 76 00 c0 b4 	movl   $0xc0004eb4,0xc0007654
c00019d8:	4e 00 c0 
/work/x86_os_my/kernel/interrupt.c:137
	intr_name[14] = "#PF Page-Fault Exception";
c00019db:	c7 05 58 76 00 c0 d5 	movl   $0xc0004ed5,0xc0007658
c00019e2:	4e 00 c0 
/work/x86_os_my/kernel/interrupt.c:139
	// intr_name[15] 第15项是intel保留项，未使用
	intr_name[16] = "#MF x87 FPU Floating-Point Error";
c00019e5:	c7 05 60 76 00 c0 f0 	movl   $0xc0004ef0,0xc0007660
c00019ec:	4e 00 c0 
/work/x86_os_my/kernel/interrupt.c:140
	intr_name[17] = "#AC Alignment Check Exception";
c00019ef:	c7 05 64 76 00 c0 11 	movl   $0xc0004f11,0xc0007664
c00019f6:	4f 00 c0 
/work/x86_os_my/kernel/interrupt.c:141
	intr_name[18] = "#MC Machine-Check Exception";
c00019f9:	c7 05 68 76 00 c0 2f 	movl   $0xc0004f2f,0xc0007668
c0001a00:	4f 00 c0 
/work/x86_os_my/kernel/interrupt.c:142
	intr_name[19] = "#XF SIMD Floating-Point Exception";
c0001a03:	c7 05 6c 76 00 c0 4c 	movl   $0xc0004f4c,0xc000766c
c0001a0a:	4f 00 c0 
/work/x86_os_my/kernel/interrupt.c:143
}
c0001a0d:	90                   	nop
c0001a0e:	c9                   	leave  
c0001a0f:	c3                   	ret    

c0001a10 <intr_enable>:
intr_enable():
/work/x86_os_my/kernel/interrupt.c:146

/* 开中断并返回开中断前的状态*/
enum intr_status intr_enable() {
c0001a10:	55                   	push   %ebp
c0001a11:	89 e5                	mov    %esp,%ebp
c0001a13:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:148
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c0001a16:	e8 65 00 00 00       	call   c0001a80 <intr_get_status>
c0001a1b:	83 f8 01             	cmp    $0x1,%eax
c0001a1e:	75 0c                	jne    c0001a2c <intr_enable+0x1c>
/work/x86_os_my/kernel/interrupt.c:149
		old_status = INTR_ON;
c0001a20:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:150
		return old_status;
c0001a27:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001a2a:	eb 0b                	jmp    c0001a37 <intr_enable+0x27>
/work/x86_os_my/kernel/interrupt.c:152
	} else {
		old_status = INTR_OFF;
c0001a2c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:153
		asm volatile("sti");	 // 开中断,sti指令将IF位置1
c0001a33:	fb                   	sti    
/work/x86_os_my/kernel/interrupt.c:154
		return old_status;
c0001a34:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:156
	}
}
c0001a37:	c9                   	leave  
c0001a38:	c3                   	ret    

c0001a39 <intr_disable>:
intr_disable():
/work/x86_os_my/kernel/interrupt.c:159

/* 关中断,并且返回关中断前的状态 */
enum intr_status intr_disable() {     
c0001a39:	55                   	push   %ebp
c0001a3a:	89 e5                	mov    %esp,%ebp
c0001a3c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:161
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c0001a3f:	e8 3c 00 00 00       	call   c0001a80 <intr_get_status>
c0001a44:	83 f8 01             	cmp    $0x1,%eax
c0001a47:	75 0d                	jne    c0001a56 <intr_disable+0x1d>
/work/x86_os_my/kernel/interrupt.c:162
		old_status = INTR_ON;
c0001a49:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:163
		asm volatile("cli" : : : "memory"); // 关中断,cli指令将IF位置0
c0001a50:	fa                   	cli    
/work/x86_os_my/kernel/interrupt.c:164
		return old_status;
c0001a51:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001a54:	eb 0a                	jmp    c0001a60 <intr_disable+0x27>
/work/x86_os_my/kernel/interrupt.c:166
	} else {
		old_status = INTR_OFF;
c0001a56:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:167
		return old_status;
c0001a5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:169
	}
}
c0001a60:	c9                   	leave  
c0001a61:	c3                   	ret    

c0001a62 <intr_set_status>:
intr_set_status():
/work/x86_os_my/kernel/interrupt.c:172

/* 将中断状态设置为status */
enum intr_status intr_set_status(enum intr_status status) {
c0001a62:	55                   	push   %ebp
c0001a63:	89 e5                	mov    %esp,%ebp
c0001a65:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:173
	return status & INTR_ON ? intr_enable() : intr_disable();
c0001a68:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a6b:	83 e0 01             	and    $0x1,%eax
c0001a6e:	85 c0                	test   %eax,%eax
c0001a70:	74 07                	je     c0001a79 <intr_set_status+0x17>
/work/x86_os_my/kernel/interrupt.c:173 (discriminator 1)
c0001a72:	e8 99 ff ff ff       	call   c0001a10 <intr_enable>
c0001a77:	eb 05                	jmp    c0001a7e <intr_set_status+0x1c>
/work/x86_os_my/kernel/interrupt.c:173 (discriminator 2)
c0001a79:	e8 bb ff ff ff       	call   c0001a39 <intr_disable>
/work/x86_os_my/kernel/interrupt.c:174 (discriminator 5)
}
c0001a7e:	c9                   	leave  
c0001a7f:	c3                   	ret    

c0001a80 <intr_get_status>:
intr_get_status():
/work/x86_os_my/kernel/interrupt.c:177

/* 获取当前中断状态 */
enum intr_status intr_get_status() {
c0001a80:	55                   	push   %ebp
c0001a81:	89 e5                	mov    %esp,%ebp
c0001a83:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:178
	uint32_t eflags = 0; 
c0001a86:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:179
	GET_EFLAGS(eflags);
c0001a8d:	9c                   	pushf  
c0001a8e:	58                   	pop    %eax
c0001a8f:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:180
	return (EFLAGS_IF & eflags) ? INTR_ON : INTR_OFF;
c0001a92:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001a95:	25 00 02 00 00       	and    $0x200,%eax
c0001a9a:	85 c0                	test   %eax,%eax
c0001a9c:	0f 95 c0             	setne  %al
c0001a9f:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/kernel/interrupt.c:181
}
c0001aa2:	c9                   	leave  
c0001aa3:	c3                   	ret    

c0001aa4 <register_handler>:
register_handler():
/work/x86_os_my/kernel/interrupt.c:184

/* 在中断处理程序数组第vector_no个元素中注册安装中断处理程序function */
void register_handler(uint8_t vector_no, intr_handler function) {
c0001aa4:	55                   	push   %ebp
c0001aa5:	89 e5                	mov    %esp,%ebp
c0001aa7:	83 ec 04             	sub    $0x4,%esp
c0001aaa:	8b 45 08             	mov    0x8(%ebp),%eax
c0001aad:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:187
/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
 * 见kernel/kernel.S的call [idt_table + %1*4] */
   idt_table[vector_no] = function; 
c0001ab0:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0001ab4:	8b 55 0c             	mov    0xc(%ebp),%edx
c0001ab7:	89 14 85 40 78 00 c0 	mov    %edx,-0x3fff87c0(,%eax,4)
/work/x86_os_my/kernel/interrupt.c:188
}
c0001abe:	90                   	nop
c0001abf:	c9                   	leave  
c0001ac0:	c3                   	ret    

c0001ac1 <idt_init>:
idt_init():
/work/x86_os_my/kernel/interrupt.c:191

/*完成有关中断的所有初始化工作*/
void idt_init() {
c0001ac1:	55                   	push   %ebp
c0001ac2:	89 e5                	mov    %esp,%ebp
c0001ac4:	56                   	push   %esi
c0001ac5:	53                   	push   %ebx
c0001ac6:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:192
	put_str("idt_init start\n");
c0001ac9:	83 ec 0c             	sub    $0xc,%esp
c0001acc:	68 6e 4f 00 c0       	push   $0xc0004f6e
c0001ad1:	e8 1a 07 00 00       	call   c00021f0 <put_str>
c0001ad6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:193
	idt_desc_init();	// 初始化中断描述符表
c0001ad9:	e8 e8 fc ff ff       	call   c00017c6 <idt_desc_init>
/work/x86_os_my/kernel/interrupt.c:194
	exception_init();	// 异常名初始化并注册通常的中断处理函数
c0001ade:	e8 34 fe ff ff       	call   c0001917 <exception_init>
/work/x86_os_my/kernel/interrupt.c:195
	pic_init();			// 初始化8259A
c0001ae3:	e8 f5 fb ff ff       	call   c00016dd <pic_init>
/work/x86_os_my/kernel/interrupt.c:199

	/* 加载idt */
	// IDTR 是 48 位的寄存器，低 16 位是 IDT 的界限 = IDT 尺寸大小-1，高 32 位是 IDT 的线性基地址
	uint64_t idt_operand = ((sizeof(idt) - 1) | ((uint64_t)(uint32_t)idt << 16));
c0001ae8:	b8 60 71 00 c0       	mov    $0xc0007160,%eax
c0001aed:	ba 00 00 00 00       	mov    $0x0,%edx
c0001af2:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0001af6:	c1 e0 10             	shl    $0x10,%eax
c0001af9:	89 c1                	mov    %eax,%ecx
c0001afb:	81 c9 07 04 00 00    	or     $0x407,%ecx
c0001b01:	89 cb                	mov    %ecx,%ebx
c0001b03:	89 d0                	mov    %edx,%eax
c0001b05:	80 cc 00             	or     $0x0,%ah
c0001b08:	89 c6                	mov    %eax,%esi
c0001b0a:	89 5d f0             	mov    %ebx,-0x10(%ebp)
c0001b0d:	89 75 f4             	mov    %esi,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:200
	asm volatile("lidt %0" : : "m" (idt_operand));
c0001b10:	0f 01 5d f0          	lidtl  -0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:201
	put_str("idt_init done\n");
c0001b14:	83 ec 0c             	sub    $0xc,%esp
c0001b17:	68 7e 4f 00 c0       	push   $0xc0004f7e
c0001b1c:	e8 cf 06 00 00       	call   c00021f0 <put_str>
c0001b21:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:202
}
c0001b24:	90                   	nop
c0001b25:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001b28:	5b                   	pop    %ebx
c0001b29:	5e                   	pop    %esi
c0001b2a:	5d                   	pop    %ebp
c0001b2b:	c3                   	ret    

c0001b2c <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c0001b2c:	55                   	push   %ebp
c0001b2d:	89 e5                	mov    %esp,%ebp
c0001b2f:	83 ec 08             	sub    $0x8,%esp
c0001b32:	8b 55 08             	mov    0x8(%ebp),%edx
c0001b35:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001b38:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0001b3c:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c0001b3f:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0001b43:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0001b47:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c0001b48:	90                   	nop
c0001b49:	c9                   	leave  
c0001b4a:	c3                   	ret    

c0001b4b <frequency_set>:
frequency_set():
/work/x86_os_my/device/timer.c:25
/* 把操作的计数器counter_no、读写锁属性rwl、计数器模式counter_mode写入模式控制寄存器并赋予初始值counter_value */
static void frequency_set(uint8_t counter_port, \
		uint8_t counter_no, \
		uint8_t rwl, \
		uint8_t counter_mode, \
		uint16_t counter_value) {
c0001b4b:	55                   	push   %ebp
c0001b4c:	89 e5                	mov    %esp,%ebp
c0001b4e:	56                   	push   %esi
c0001b4f:	53                   	push   %ebx
c0001b50:	83 ec 14             	sub    $0x14,%esp
c0001b53:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b56:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c0001b59:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001b5c:	8b 55 14             	mov    0x14(%ebp),%edx
c0001b5f:	8b 75 18             	mov    0x18(%ebp),%esi
c0001b62:	88 45 f4             	mov    %al,-0xc(%ebp)
c0001b65:	88 5d f0             	mov    %bl,-0x10(%ebp)
c0001b68:	88 4d ec             	mov    %cl,-0x14(%ebp)
c0001b6b:	88 55 e8             	mov    %dl,-0x18(%ebp)
c0001b6e:	66 89 75 e4          	mov    %si,-0x1c(%ebp)
/work/x86_os_my/device/timer.c:27
	/* 往控制字寄存器端口0x43中写入控制字 */
	outb(PIT_CONTROL_PORT, (uint8_t)(counter_no << 6 | rwl << 4 | counter_mode << 1));
c0001b72:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0001b76:	c1 e0 06             	shl    $0x6,%eax
c0001b79:	89 c2                	mov    %eax,%edx
c0001b7b:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0001b7f:	c1 e0 04             	shl    $0x4,%eax
c0001b82:	09 c2                	or     %eax,%edx
c0001b84:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0001b88:	01 c0                	add    %eax,%eax
c0001b8a:	09 d0                	or     %edx,%eax
c0001b8c:	0f b6 c0             	movzbl %al,%eax
c0001b8f:	50                   	push   %eax
c0001b90:	6a 43                	push   $0x43
c0001b92:	e8 95 ff ff ff       	call   c0001b2c <outb>
c0001b97:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:29
	/* 先写入counter_value的低8位 */
	outb(counter_port, (uint8_t)counter_value);
c0001b9a:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0001b9e:	0f b6 d0             	movzbl %al,%edx
c0001ba1:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001ba5:	52                   	push   %edx
c0001ba6:	50                   	push   %eax
c0001ba7:	e8 80 ff ff ff       	call   c0001b2c <outb>
c0001bac:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:31
	/* 再写入counter_value的高8位 */
	outb(counter_port, (uint8_t)counter_value >> 8);
c0001baf:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001bb3:	6a 00                	push   $0x0
c0001bb5:	50                   	push   %eax
c0001bb6:	e8 71 ff ff ff       	call   c0001b2c <outb>
c0001bbb:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:32
}
c0001bbe:	90                   	nop
c0001bbf:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001bc2:	5b                   	pop    %ebx
c0001bc3:	5e                   	pop    %esi
c0001bc4:	5d                   	pop    %ebp
c0001bc5:	c3                   	ret    

c0001bc6 <intr_timer_handler>:
intr_timer_handler():
/work/x86_os_my/device/timer.c:35

/* 时钟的中断处理函数 */
static void intr_timer_handler(void) {
c0001bc6:	55                   	push   %ebp
c0001bc7:	89 e5                	mov    %esp,%ebp
c0001bc9:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/timer.c:36
	struct task_struct* cur_thread = running_thread();		// 返回线程PCB
c0001bcc:	e8 89 16 00 00       	call   c000325a <running_thread>
c0001bd1:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/timer.c:38

	ASSERT(cur_thread->stack_magic == 0x19870916);			// 检查栈是否溢出
c0001bd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001bd7:	8b 40 44             	mov    0x44(%eax),%eax
c0001bda:	3d 16 09 87 19       	cmp    $0x19870916,%eax
c0001bdf:	74 19                	je     c0001bfa <intr_timer_handler+0x34>
/work/x86_os_my/device/timer.c:38 (discriminator 1)
c0001be1:	68 90 4f 00 c0       	push   $0xc0004f90
c0001be6:	68 e8 4f 00 c0       	push   $0xc0004fe8
c0001beb:	6a 26                	push   $0x26
c0001bed:	68 b6 4f 00 c0       	push   $0xc0004fb6
c0001bf2:	e8 6b 07 00 00       	call   c0002362 <panic_spin>
c0001bf7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:40

	cur_thread->elapsed_ticks++;// 记录此线程占用的cpu时间
c0001bfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001bfd:	8b 40 20             	mov    0x20(%eax),%eax
c0001c00:	8d 50 01             	lea    0x1(%eax),%edx
c0001c03:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001c06:	89 50 20             	mov    %edx,0x20(%eax)
/work/x86_os_my/device/timer.c:41
	ticks++;	//从内核第一次处理时间中断开始,至今的滴哒数,是内核态和用户态总共的嘀哒数
c0001c09:	a1 44 7a 00 c0       	mov    0xc0007a44,%eax
c0001c0e:	83 c0 01             	add    $0x1,%eax
c0001c11:	a3 44 7a 00 c0       	mov    %eax,0xc0007a44
/work/x86_os_my/device/timer.c:43

	if (cur_thread->ticks == 0) {
c0001c16:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001c19:	0f b6 40 1d          	movzbl 0x1d(%eax),%eax
c0001c1d:	84 c0                	test   %al,%al
c0001c1f:	75 07                	jne    c0001c28 <intr_timer_handler+0x62>
/work/x86_os_my/device/timer.c:44
		schedule();				// 若进程时间片用完就开始调度新的进程上cpu
c0001c21:	e8 12 19 00 00       	call   c0003538 <schedule>
/work/x86_os_my/device/timer.c:48
	} else {
		cur_thread->ticks--;	// 将当前进程的时间片-1
	}
}
c0001c26:	eb 10                	jmp    c0001c38 <intr_timer_handler+0x72>
/work/x86_os_my/device/timer.c:46
	ticks++;	//从内核第一次处理时间中断开始,至今的滴哒数,是内核态和用户态总共的嘀哒数

	if (cur_thread->ticks == 0) {
		schedule();				// 若进程时间片用完就开始调度新的进程上cpu
	} else {
		cur_thread->ticks--;	// 将当前进程的时间片-1
c0001c28:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001c2b:	0f b6 40 1d          	movzbl 0x1d(%eax),%eax
c0001c2f:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001c32:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001c35:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/device/timer.c:48
	}
}
c0001c38:	90                   	nop
c0001c39:	c9                   	leave  
c0001c3a:	c3                   	ret    

c0001c3b <timer_init>:
timer_init():
/work/x86_os_my/device/timer.c:51

/* 初始化PIT8253 */
void timer_init() {
c0001c3b:	55                   	push   %ebp
c0001c3c:	89 e5                	mov    %esp,%ebp
c0001c3e:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/timer.c:52
	put_str("timer_init start\n");
c0001c41:	83 ec 0c             	sub    $0xc,%esp
c0001c44:	68 c5 4f 00 c0       	push   $0xc0004fc5
c0001c49:	e8 a2 05 00 00       	call   c00021f0 <put_str>
c0001c4e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:54
	/* 设置8253的定时周期,也就是发中断的周期 */
	frequency_set(CONTRER0_PORT, COUNTER0_NO, READ_WRITE_LATCH, COUNTER_MODE, COUNTER0_VALUE);
c0001c51:	83 ec 0c             	sub    $0xc,%esp
c0001c54:	68 9b 2e 00 00       	push   $0x2e9b
c0001c59:	6a 02                	push   $0x2
c0001c5b:	6a 03                	push   $0x3
c0001c5d:	6a 00                	push   $0x0
c0001c5f:	6a 40                	push   $0x40
c0001c61:	e8 e5 fe ff ff       	call   c0001b4b <frequency_set>
c0001c66:	83 c4 20             	add    $0x20,%esp
/work/x86_os_my/device/timer.c:55
	register_handler(0x20, intr_timer_handler);
c0001c69:	83 ec 08             	sub    $0x8,%esp
c0001c6c:	68 c6 1b 00 c0       	push   $0xc0001bc6
c0001c71:	6a 20                	push   $0x20
c0001c73:	e8 2c fe ff ff       	call   c0001aa4 <register_handler>
c0001c78:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:56
	put_str("timer_init done\n");
c0001c7b:	83 ec 0c             	sub    $0xc,%esp
c0001c7e:	68 d7 4f 00 c0       	push   $0xc0004fd7
c0001c83:	e8 68 05 00 00       	call   c00021f0 <put_str>
c0001c88:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:57
}
c0001c8b:	90                   	nop
c0001c8c:	c9                   	leave  
c0001c8d:	c3                   	ret    
c0001c8e:	66 90                	xchg   %ax,%ax

c0001c90 <intr_exit>:
intr_exit():
c0001c90:	83 c4 04             	add    $0x4,%esp
c0001c93:	61                   	popa   
c0001c94:	0f a9                	pop    %gs
c0001c96:	0f a1                	pop    %fs
c0001c98:	07                   	pop    %es
c0001c99:	1f                   	pop    %ds
c0001c9a:	83 c4 04             	add    $0x4,%esp
c0001c9d:	cf                   	iret   

c0001c9e <intr0x00entry>:
intr0x00entry():
c0001c9e:	6a 00                	push   $0x0
c0001ca0:	1e                   	push   %ds
c0001ca1:	06                   	push   %es
c0001ca2:	0f a0                	push   %fs
c0001ca4:	0f a8                	push   %gs
c0001ca6:	60                   	pusha  
c0001ca7:	b0 20                	mov    $0x20,%al
c0001ca9:	e6 a0                	out    %al,$0xa0
c0001cab:	e6 20                	out    %al,$0x20
c0001cad:	6a 00                	push   $0x0
c0001caf:	ff 15 40 78 00 c0    	call   *0xc0007840
c0001cb5:	eb d9                	jmp    c0001c90 <intr_exit>

c0001cb7 <intr0x01entry>:
intr0x01entry():
c0001cb7:	6a 00                	push   $0x0
c0001cb9:	1e                   	push   %ds
c0001cba:	06                   	push   %es
c0001cbb:	0f a0                	push   %fs
c0001cbd:	0f a8                	push   %gs
c0001cbf:	60                   	pusha  
c0001cc0:	b0 20                	mov    $0x20,%al
c0001cc2:	e6 a0                	out    %al,$0xa0
c0001cc4:	e6 20                	out    %al,$0x20
c0001cc6:	6a 01                	push   $0x1
c0001cc8:	ff 15 44 78 00 c0    	call   *0xc0007844
c0001cce:	eb c0                	jmp    c0001c90 <intr_exit>

c0001cd0 <intr0x02entry>:
intr0x02entry():
c0001cd0:	6a 00                	push   $0x0
c0001cd2:	1e                   	push   %ds
c0001cd3:	06                   	push   %es
c0001cd4:	0f a0                	push   %fs
c0001cd6:	0f a8                	push   %gs
c0001cd8:	60                   	pusha  
c0001cd9:	b0 20                	mov    $0x20,%al
c0001cdb:	e6 a0                	out    %al,$0xa0
c0001cdd:	e6 20                	out    %al,$0x20
c0001cdf:	6a 02                	push   $0x2
c0001ce1:	ff 15 48 78 00 c0    	call   *0xc0007848
c0001ce7:	eb a7                	jmp    c0001c90 <intr_exit>

c0001ce9 <intr0x03entry>:
intr0x03entry():
c0001ce9:	6a 00                	push   $0x0
c0001ceb:	1e                   	push   %ds
c0001cec:	06                   	push   %es
c0001ced:	0f a0                	push   %fs
c0001cef:	0f a8                	push   %gs
c0001cf1:	60                   	pusha  
c0001cf2:	b0 20                	mov    $0x20,%al
c0001cf4:	e6 a0                	out    %al,$0xa0
c0001cf6:	e6 20                	out    %al,$0x20
c0001cf8:	6a 03                	push   $0x3
c0001cfa:	ff 15 4c 78 00 c0    	call   *0xc000784c
c0001d00:	eb 8e                	jmp    c0001c90 <intr_exit>

c0001d02 <intr0x04entry>:
intr0x04entry():
c0001d02:	6a 00                	push   $0x0
c0001d04:	1e                   	push   %ds
c0001d05:	06                   	push   %es
c0001d06:	0f a0                	push   %fs
c0001d08:	0f a8                	push   %gs
c0001d0a:	60                   	pusha  
c0001d0b:	b0 20                	mov    $0x20,%al
c0001d0d:	e6 a0                	out    %al,$0xa0
c0001d0f:	e6 20                	out    %al,$0x20
c0001d11:	6a 04                	push   $0x4
c0001d13:	ff 15 50 78 00 c0    	call   *0xc0007850
c0001d19:	e9 72 ff ff ff       	jmp    c0001c90 <intr_exit>

c0001d1e <intr0x05entry>:
intr0x05entry():
c0001d1e:	6a 00                	push   $0x0
c0001d20:	1e                   	push   %ds
c0001d21:	06                   	push   %es
c0001d22:	0f a0                	push   %fs
c0001d24:	0f a8                	push   %gs
c0001d26:	60                   	pusha  
c0001d27:	b0 20                	mov    $0x20,%al
c0001d29:	e6 a0                	out    %al,$0xa0
c0001d2b:	e6 20                	out    %al,$0x20
c0001d2d:	6a 05                	push   $0x5
c0001d2f:	ff 15 54 78 00 c0    	call   *0xc0007854
c0001d35:	e9 56 ff ff ff       	jmp    c0001c90 <intr_exit>

c0001d3a <intr0x06entry>:
intr0x06entry():
c0001d3a:	6a 00                	push   $0x0
c0001d3c:	1e                   	push   %ds
c0001d3d:	06                   	push   %es
c0001d3e:	0f a0                	push   %fs
c0001d40:	0f a8                	push   %gs
c0001d42:	60                   	pusha  
c0001d43:	b0 20                	mov    $0x20,%al
c0001d45:	e6 a0                	out    %al,$0xa0
c0001d47:	e6 20                	out    %al,$0x20
c0001d49:	6a 06                	push   $0x6
c0001d4b:	ff 15 58 78 00 c0    	call   *0xc0007858
c0001d51:	e9 3a ff ff ff       	jmp    c0001c90 <intr_exit>

c0001d56 <intr0x07entry>:
intr0x07entry():
c0001d56:	6a 00                	push   $0x0
c0001d58:	1e                   	push   %ds
c0001d59:	06                   	push   %es
c0001d5a:	0f a0                	push   %fs
c0001d5c:	0f a8                	push   %gs
c0001d5e:	60                   	pusha  
c0001d5f:	b0 20                	mov    $0x20,%al
c0001d61:	e6 a0                	out    %al,$0xa0
c0001d63:	e6 20                	out    %al,$0x20
c0001d65:	6a 07                	push   $0x7
c0001d67:	ff 15 5c 78 00 c0    	call   *0xc000785c
c0001d6d:	e9 1e ff ff ff       	jmp    c0001c90 <intr_exit>

c0001d72 <intr0x08entry>:
intr0x08entry():
c0001d72:	90                   	nop
c0001d73:	1e                   	push   %ds
c0001d74:	06                   	push   %es
c0001d75:	0f a0                	push   %fs
c0001d77:	0f a8                	push   %gs
c0001d79:	60                   	pusha  
c0001d7a:	b0 20                	mov    $0x20,%al
c0001d7c:	e6 a0                	out    %al,$0xa0
c0001d7e:	e6 20                	out    %al,$0x20
c0001d80:	6a 08                	push   $0x8
c0001d82:	ff 15 60 78 00 c0    	call   *0xc0007860
c0001d88:	e9 03 ff ff ff       	jmp    c0001c90 <intr_exit>

c0001d8d <intr0x09entry>:
intr0x09entry():
c0001d8d:	6a 00                	push   $0x0
c0001d8f:	1e                   	push   %ds
c0001d90:	06                   	push   %es
c0001d91:	0f a0                	push   %fs
c0001d93:	0f a8                	push   %gs
c0001d95:	60                   	pusha  
c0001d96:	b0 20                	mov    $0x20,%al
c0001d98:	e6 a0                	out    %al,$0xa0
c0001d9a:	e6 20                	out    %al,$0x20
c0001d9c:	6a 09                	push   $0x9
c0001d9e:	ff 15 64 78 00 c0    	call   *0xc0007864
c0001da4:	e9 e7 fe ff ff       	jmp    c0001c90 <intr_exit>

c0001da9 <intr0x0aentry>:
intr0x0aentry():
c0001da9:	90                   	nop
c0001daa:	1e                   	push   %ds
c0001dab:	06                   	push   %es
c0001dac:	0f a0                	push   %fs
c0001dae:	0f a8                	push   %gs
c0001db0:	60                   	pusha  
c0001db1:	b0 20                	mov    $0x20,%al
c0001db3:	e6 a0                	out    %al,$0xa0
c0001db5:	e6 20                	out    %al,$0x20
c0001db7:	6a 0a                	push   $0xa
c0001db9:	ff 15 68 78 00 c0    	call   *0xc0007868
c0001dbf:	e9 cc fe ff ff       	jmp    c0001c90 <intr_exit>

c0001dc4 <intr0x0bentry>:
intr0x0bentry():
c0001dc4:	90                   	nop
c0001dc5:	1e                   	push   %ds
c0001dc6:	06                   	push   %es
c0001dc7:	0f a0                	push   %fs
c0001dc9:	0f a8                	push   %gs
c0001dcb:	60                   	pusha  
c0001dcc:	b0 20                	mov    $0x20,%al
c0001dce:	e6 a0                	out    %al,$0xa0
c0001dd0:	e6 20                	out    %al,$0x20
c0001dd2:	6a 0b                	push   $0xb
c0001dd4:	ff 15 6c 78 00 c0    	call   *0xc000786c
c0001dda:	e9 b1 fe ff ff       	jmp    c0001c90 <intr_exit>

c0001ddf <intr0x0centry>:
intr0x0centry():
c0001ddf:	6a 00                	push   $0x0
c0001de1:	1e                   	push   %ds
c0001de2:	06                   	push   %es
c0001de3:	0f a0                	push   %fs
c0001de5:	0f a8                	push   %gs
c0001de7:	60                   	pusha  
c0001de8:	b0 20                	mov    $0x20,%al
c0001dea:	e6 a0                	out    %al,$0xa0
c0001dec:	e6 20                	out    %al,$0x20
c0001dee:	6a 0c                	push   $0xc
c0001df0:	ff 15 70 78 00 c0    	call   *0xc0007870
c0001df6:	e9 95 fe ff ff       	jmp    c0001c90 <intr_exit>

c0001dfb <intr0x0dentry>:
intr0x0dentry():
c0001dfb:	90                   	nop
c0001dfc:	1e                   	push   %ds
c0001dfd:	06                   	push   %es
c0001dfe:	0f a0                	push   %fs
c0001e00:	0f a8                	push   %gs
c0001e02:	60                   	pusha  
c0001e03:	b0 20                	mov    $0x20,%al
c0001e05:	e6 a0                	out    %al,$0xa0
c0001e07:	e6 20                	out    %al,$0x20
c0001e09:	6a 0d                	push   $0xd
c0001e0b:	ff 15 74 78 00 c0    	call   *0xc0007874
c0001e11:	e9 7a fe ff ff       	jmp    c0001c90 <intr_exit>

c0001e16 <intr0x0eentry>:
intr0x0eentry():
c0001e16:	90                   	nop
c0001e17:	1e                   	push   %ds
c0001e18:	06                   	push   %es
c0001e19:	0f a0                	push   %fs
c0001e1b:	0f a8                	push   %gs
c0001e1d:	60                   	pusha  
c0001e1e:	b0 20                	mov    $0x20,%al
c0001e20:	e6 a0                	out    %al,$0xa0
c0001e22:	e6 20                	out    %al,$0x20
c0001e24:	6a 0e                	push   $0xe
c0001e26:	ff 15 78 78 00 c0    	call   *0xc0007878
c0001e2c:	e9 5f fe ff ff       	jmp    c0001c90 <intr_exit>

c0001e31 <intr0x0fentry>:
intr0x0fentry():
c0001e31:	6a 00                	push   $0x0
c0001e33:	1e                   	push   %ds
c0001e34:	06                   	push   %es
c0001e35:	0f a0                	push   %fs
c0001e37:	0f a8                	push   %gs
c0001e39:	60                   	pusha  
c0001e3a:	b0 20                	mov    $0x20,%al
c0001e3c:	e6 a0                	out    %al,$0xa0
c0001e3e:	e6 20                	out    %al,$0x20
c0001e40:	6a 0f                	push   $0xf
c0001e42:	ff 15 7c 78 00 c0    	call   *0xc000787c
c0001e48:	e9 43 fe ff ff       	jmp    c0001c90 <intr_exit>

c0001e4d <intr0x10entry>:
intr0x10entry():
c0001e4d:	6a 00                	push   $0x0
c0001e4f:	1e                   	push   %ds
c0001e50:	06                   	push   %es
c0001e51:	0f a0                	push   %fs
c0001e53:	0f a8                	push   %gs
c0001e55:	60                   	pusha  
c0001e56:	b0 20                	mov    $0x20,%al
c0001e58:	e6 a0                	out    %al,$0xa0
c0001e5a:	e6 20                	out    %al,$0x20
c0001e5c:	6a 10                	push   $0x10
c0001e5e:	ff 15 80 78 00 c0    	call   *0xc0007880
c0001e64:	e9 27 fe ff ff       	jmp    c0001c90 <intr_exit>

c0001e69 <intr0x11entry>:
intr0x11entry():
c0001e69:	90                   	nop
c0001e6a:	1e                   	push   %ds
c0001e6b:	06                   	push   %es
c0001e6c:	0f a0                	push   %fs
c0001e6e:	0f a8                	push   %gs
c0001e70:	60                   	pusha  
c0001e71:	b0 20                	mov    $0x20,%al
c0001e73:	e6 a0                	out    %al,$0xa0
c0001e75:	e6 20                	out    %al,$0x20
c0001e77:	6a 11                	push   $0x11
c0001e79:	ff 15 84 78 00 c0    	call   *0xc0007884
c0001e7f:	e9 0c fe ff ff       	jmp    c0001c90 <intr_exit>

c0001e84 <intr0x12entry>:
intr0x12entry():
c0001e84:	6a 00                	push   $0x0
c0001e86:	1e                   	push   %ds
c0001e87:	06                   	push   %es
c0001e88:	0f a0                	push   %fs
c0001e8a:	0f a8                	push   %gs
c0001e8c:	60                   	pusha  
c0001e8d:	b0 20                	mov    $0x20,%al
c0001e8f:	e6 a0                	out    %al,$0xa0
c0001e91:	e6 20                	out    %al,$0x20
c0001e93:	6a 12                	push   $0x12
c0001e95:	ff 15 88 78 00 c0    	call   *0xc0007888
c0001e9b:	e9 f0 fd ff ff       	jmp    c0001c90 <intr_exit>

c0001ea0 <intr0x13entry>:
intr0x13entry():
c0001ea0:	6a 00                	push   $0x0
c0001ea2:	1e                   	push   %ds
c0001ea3:	06                   	push   %es
c0001ea4:	0f a0                	push   %fs
c0001ea6:	0f a8                	push   %gs
c0001ea8:	60                   	pusha  
c0001ea9:	b0 20                	mov    $0x20,%al
c0001eab:	e6 a0                	out    %al,$0xa0
c0001ead:	e6 20                	out    %al,$0x20
c0001eaf:	6a 13                	push   $0x13
c0001eb1:	ff 15 8c 78 00 c0    	call   *0xc000788c
c0001eb7:	e9 d4 fd ff ff       	jmp    c0001c90 <intr_exit>

c0001ebc <intr0x14entry>:
intr0x14entry():
c0001ebc:	6a 00                	push   $0x0
c0001ebe:	1e                   	push   %ds
c0001ebf:	06                   	push   %es
c0001ec0:	0f a0                	push   %fs
c0001ec2:	0f a8                	push   %gs
c0001ec4:	60                   	pusha  
c0001ec5:	b0 20                	mov    $0x20,%al
c0001ec7:	e6 a0                	out    %al,$0xa0
c0001ec9:	e6 20                	out    %al,$0x20
c0001ecb:	6a 14                	push   $0x14
c0001ecd:	ff 15 90 78 00 c0    	call   *0xc0007890
c0001ed3:	e9 b8 fd ff ff       	jmp    c0001c90 <intr_exit>

c0001ed8 <intr0x15entry>:
intr0x15entry():
c0001ed8:	6a 00                	push   $0x0
c0001eda:	1e                   	push   %ds
c0001edb:	06                   	push   %es
c0001edc:	0f a0                	push   %fs
c0001ede:	0f a8                	push   %gs
c0001ee0:	60                   	pusha  
c0001ee1:	b0 20                	mov    $0x20,%al
c0001ee3:	e6 a0                	out    %al,$0xa0
c0001ee5:	e6 20                	out    %al,$0x20
c0001ee7:	6a 15                	push   $0x15
c0001ee9:	ff 15 94 78 00 c0    	call   *0xc0007894
c0001eef:	e9 9c fd ff ff       	jmp    c0001c90 <intr_exit>

c0001ef4 <intr0x16entry>:
intr0x16entry():
c0001ef4:	6a 00                	push   $0x0
c0001ef6:	1e                   	push   %ds
c0001ef7:	06                   	push   %es
c0001ef8:	0f a0                	push   %fs
c0001efa:	0f a8                	push   %gs
c0001efc:	60                   	pusha  
c0001efd:	b0 20                	mov    $0x20,%al
c0001eff:	e6 a0                	out    %al,$0xa0
c0001f01:	e6 20                	out    %al,$0x20
c0001f03:	6a 16                	push   $0x16
c0001f05:	ff 15 98 78 00 c0    	call   *0xc0007898
c0001f0b:	e9 80 fd ff ff       	jmp    c0001c90 <intr_exit>

c0001f10 <intr0x17entry>:
intr0x17entry():
c0001f10:	6a 00                	push   $0x0
c0001f12:	1e                   	push   %ds
c0001f13:	06                   	push   %es
c0001f14:	0f a0                	push   %fs
c0001f16:	0f a8                	push   %gs
c0001f18:	60                   	pusha  
c0001f19:	b0 20                	mov    $0x20,%al
c0001f1b:	e6 a0                	out    %al,$0xa0
c0001f1d:	e6 20                	out    %al,$0x20
c0001f1f:	6a 17                	push   $0x17
c0001f21:	ff 15 9c 78 00 c0    	call   *0xc000789c
c0001f27:	e9 64 fd ff ff       	jmp    c0001c90 <intr_exit>

c0001f2c <intr0x18entry>:
intr0x18entry():
c0001f2c:	90                   	nop
c0001f2d:	1e                   	push   %ds
c0001f2e:	06                   	push   %es
c0001f2f:	0f a0                	push   %fs
c0001f31:	0f a8                	push   %gs
c0001f33:	60                   	pusha  
c0001f34:	b0 20                	mov    $0x20,%al
c0001f36:	e6 a0                	out    %al,$0xa0
c0001f38:	e6 20                	out    %al,$0x20
c0001f3a:	6a 18                	push   $0x18
c0001f3c:	ff 15 a0 78 00 c0    	call   *0xc00078a0
c0001f42:	e9 49 fd ff ff       	jmp    c0001c90 <intr_exit>

c0001f47 <intr0x19entry>:
intr0x19entry():
c0001f47:	6a 00                	push   $0x0
c0001f49:	1e                   	push   %ds
c0001f4a:	06                   	push   %es
c0001f4b:	0f a0                	push   %fs
c0001f4d:	0f a8                	push   %gs
c0001f4f:	60                   	pusha  
c0001f50:	b0 20                	mov    $0x20,%al
c0001f52:	e6 a0                	out    %al,$0xa0
c0001f54:	e6 20                	out    %al,$0x20
c0001f56:	6a 19                	push   $0x19
c0001f58:	ff 15 a4 78 00 c0    	call   *0xc00078a4
c0001f5e:	e9 2d fd ff ff       	jmp    c0001c90 <intr_exit>

c0001f63 <intr0x1aentry>:
intr0x1aentry():
c0001f63:	90                   	nop
c0001f64:	1e                   	push   %ds
c0001f65:	06                   	push   %es
c0001f66:	0f a0                	push   %fs
c0001f68:	0f a8                	push   %gs
c0001f6a:	60                   	pusha  
c0001f6b:	b0 20                	mov    $0x20,%al
c0001f6d:	e6 a0                	out    %al,$0xa0
c0001f6f:	e6 20                	out    %al,$0x20
c0001f71:	6a 1a                	push   $0x1a
c0001f73:	ff 15 a8 78 00 c0    	call   *0xc00078a8
c0001f79:	e9 12 fd ff ff       	jmp    c0001c90 <intr_exit>

c0001f7e <intr0x1bentry>:
intr0x1bentry():
c0001f7e:	90                   	nop
c0001f7f:	1e                   	push   %ds
c0001f80:	06                   	push   %es
c0001f81:	0f a0                	push   %fs
c0001f83:	0f a8                	push   %gs
c0001f85:	60                   	pusha  
c0001f86:	b0 20                	mov    $0x20,%al
c0001f88:	e6 a0                	out    %al,$0xa0
c0001f8a:	e6 20                	out    %al,$0x20
c0001f8c:	6a 1b                	push   $0x1b
c0001f8e:	ff 15 ac 78 00 c0    	call   *0xc00078ac
c0001f94:	e9 f7 fc ff ff       	jmp    c0001c90 <intr_exit>

c0001f99 <intr0x1centry>:
intr0x1centry():
c0001f99:	6a 00                	push   $0x0
c0001f9b:	1e                   	push   %ds
c0001f9c:	06                   	push   %es
c0001f9d:	0f a0                	push   %fs
c0001f9f:	0f a8                	push   %gs
c0001fa1:	60                   	pusha  
c0001fa2:	b0 20                	mov    $0x20,%al
c0001fa4:	e6 a0                	out    %al,$0xa0
c0001fa6:	e6 20                	out    %al,$0x20
c0001fa8:	6a 1c                	push   $0x1c
c0001faa:	ff 15 b0 78 00 c0    	call   *0xc00078b0
c0001fb0:	e9 db fc ff ff       	jmp    c0001c90 <intr_exit>

c0001fb5 <intr0x1dentry>:
intr0x1dentry():
c0001fb5:	90                   	nop
c0001fb6:	1e                   	push   %ds
c0001fb7:	06                   	push   %es
c0001fb8:	0f a0                	push   %fs
c0001fba:	0f a8                	push   %gs
c0001fbc:	60                   	pusha  
c0001fbd:	b0 20                	mov    $0x20,%al
c0001fbf:	e6 a0                	out    %al,$0xa0
c0001fc1:	e6 20                	out    %al,$0x20
c0001fc3:	6a 1d                	push   $0x1d
c0001fc5:	ff 15 b4 78 00 c0    	call   *0xc00078b4
c0001fcb:	e9 c0 fc ff ff       	jmp    c0001c90 <intr_exit>

c0001fd0 <intr0x1eentry>:
intr0x1eentry():
c0001fd0:	90                   	nop
c0001fd1:	1e                   	push   %ds
c0001fd2:	06                   	push   %es
c0001fd3:	0f a0                	push   %fs
c0001fd5:	0f a8                	push   %gs
c0001fd7:	60                   	pusha  
c0001fd8:	b0 20                	mov    $0x20,%al
c0001fda:	e6 a0                	out    %al,$0xa0
c0001fdc:	e6 20                	out    %al,$0x20
c0001fde:	6a 1e                	push   $0x1e
c0001fe0:	ff 15 b8 78 00 c0    	call   *0xc00078b8
c0001fe6:	e9 a5 fc ff ff       	jmp    c0001c90 <intr_exit>

c0001feb <intr0x1fentry>:
intr0x1fentry():
c0001feb:	6a 00                	push   $0x0
c0001fed:	1e                   	push   %ds
c0001fee:	06                   	push   %es
c0001fef:	0f a0                	push   %fs
c0001ff1:	0f a8                	push   %gs
c0001ff3:	60                   	pusha  
c0001ff4:	b0 20                	mov    $0x20,%al
c0001ff6:	e6 a0                	out    %al,$0xa0
c0001ff8:	e6 20                	out    %al,$0x20
c0001ffa:	6a 1f                	push   $0x1f
c0001ffc:	ff 15 bc 78 00 c0    	call   *0xc00078bc
c0002002:	e9 89 fc ff ff       	jmp    c0001c90 <intr_exit>

c0002007 <intr0x20entry>:
intr0x20entry():
c0002007:	6a 00                	push   $0x0
c0002009:	1e                   	push   %ds
c000200a:	06                   	push   %es
c000200b:	0f a0                	push   %fs
c000200d:	0f a8                	push   %gs
c000200f:	60                   	pusha  
c0002010:	b0 20                	mov    $0x20,%al
c0002012:	e6 a0                	out    %al,$0xa0
c0002014:	e6 20                	out    %al,$0x20
c0002016:	6a 20                	push   $0x20
c0002018:	ff 15 c0 78 00 c0    	call   *0xc00078c0
c000201e:	e9 6d fc ff ff       	jmp    c0001c90 <intr_exit>

c0002023 <intr0x21entry>:
intr0x21entry():
c0002023:	6a 00                	push   $0x0
c0002025:	1e                   	push   %ds
c0002026:	06                   	push   %es
c0002027:	0f a0                	push   %fs
c0002029:	0f a8                	push   %gs
c000202b:	60                   	pusha  
c000202c:	b0 20                	mov    $0x20,%al
c000202e:	e6 a0                	out    %al,$0xa0
c0002030:	e6 20                	out    %al,$0x20
c0002032:	6a 21                	push   $0x21
c0002034:	ff 15 c4 78 00 c0    	call   *0xc00078c4
c000203a:	e9 51 fc ff ff       	jmp    c0001c90 <intr_exit>

c000203f <intr0x22entry>:
intr0x22entry():
c000203f:	6a 00                	push   $0x0
c0002041:	1e                   	push   %ds
c0002042:	06                   	push   %es
c0002043:	0f a0                	push   %fs
c0002045:	0f a8                	push   %gs
c0002047:	60                   	pusha  
c0002048:	b0 20                	mov    $0x20,%al
c000204a:	e6 a0                	out    %al,$0xa0
c000204c:	e6 20                	out    %al,$0x20
c000204e:	6a 22                	push   $0x22
c0002050:	ff 15 c8 78 00 c0    	call   *0xc00078c8
c0002056:	e9 35 fc ff ff       	jmp    c0001c90 <intr_exit>

c000205b <intr0x23entry>:
intr0x23entry():
c000205b:	6a 00                	push   $0x0
c000205d:	1e                   	push   %ds
c000205e:	06                   	push   %es
c000205f:	0f a0                	push   %fs
c0002061:	0f a8                	push   %gs
c0002063:	60                   	pusha  
c0002064:	b0 20                	mov    $0x20,%al
c0002066:	e6 a0                	out    %al,$0xa0
c0002068:	e6 20                	out    %al,$0x20
c000206a:	6a 23                	push   $0x23
c000206c:	ff 15 cc 78 00 c0    	call   *0xc00078cc
c0002072:	e9 19 fc ff ff       	jmp    c0001c90 <intr_exit>

c0002077 <intr0x24entry>:
intr0x24entry():
c0002077:	6a 00                	push   $0x0
c0002079:	1e                   	push   %ds
c000207a:	06                   	push   %es
c000207b:	0f a0                	push   %fs
c000207d:	0f a8                	push   %gs
c000207f:	60                   	pusha  
c0002080:	b0 20                	mov    $0x20,%al
c0002082:	e6 a0                	out    %al,$0xa0
c0002084:	e6 20                	out    %al,$0x20
c0002086:	6a 24                	push   $0x24
c0002088:	ff 15 d0 78 00 c0    	call   *0xc00078d0
c000208e:	e9 fd fb ff ff       	jmp    c0001c90 <intr_exit>

c0002093 <intr0x25entry>:
intr0x25entry():
c0002093:	6a 00                	push   $0x0
c0002095:	1e                   	push   %ds
c0002096:	06                   	push   %es
c0002097:	0f a0                	push   %fs
c0002099:	0f a8                	push   %gs
c000209b:	60                   	pusha  
c000209c:	b0 20                	mov    $0x20,%al
c000209e:	e6 a0                	out    %al,$0xa0
c00020a0:	e6 20                	out    %al,$0x20
c00020a2:	6a 25                	push   $0x25
c00020a4:	ff 15 d4 78 00 c0    	call   *0xc00078d4
c00020aa:	e9 e1 fb ff ff       	jmp    c0001c90 <intr_exit>

c00020af <intr0x26entry>:
intr0x26entry():
c00020af:	6a 00                	push   $0x0
c00020b1:	1e                   	push   %ds
c00020b2:	06                   	push   %es
c00020b3:	0f a0                	push   %fs
c00020b5:	0f a8                	push   %gs
c00020b7:	60                   	pusha  
c00020b8:	b0 20                	mov    $0x20,%al
c00020ba:	e6 a0                	out    %al,$0xa0
c00020bc:	e6 20                	out    %al,$0x20
c00020be:	6a 26                	push   $0x26
c00020c0:	ff 15 d8 78 00 c0    	call   *0xc00078d8
c00020c6:	e9 c5 fb ff ff       	jmp    c0001c90 <intr_exit>

c00020cb <intr0x27entry>:
intr0x27entry():
c00020cb:	6a 00                	push   $0x0
c00020cd:	1e                   	push   %ds
c00020ce:	06                   	push   %es
c00020cf:	0f a0                	push   %fs
c00020d1:	0f a8                	push   %gs
c00020d3:	60                   	pusha  
c00020d4:	b0 20                	mov    $0x20,%al
c00020d6:	e6 a0                	out    %al,$0xa0
c00020d8:	e6 20                	out    %al,$0x20
c00020da:	6a 27                	push   $0x27
c00020dc:	ff 15 dc 78 00 c0    	call   *0xc00078dc
c00020e2:	e9 a9 fb ff ff       	jmp    c0001c90 <intr_exit>

c00020e7 <intr0x28entry>:
intr0x28entry():
c00020e7:	6a 00                	push   $0x0
c00020e9:	1e                   	push   %ds
c00020ea:	06                   	push   %es
c00020eb:	0f a0                	push   %fs
c00020ed:	0f a8                	push   %gs
c00020ef:	60                   	pusha  
c00020f0:	b0 20                	mov    $0x20,%al
c00020f2:	e6 a0                	out    %al,$0xa0
c00020f4:	e6 20                	out    %al,$0x20
c00020f6:	6a 28                	push   $0x28
c00020f8:	ff 15 e0 78 00 c0    	call   *0xc00078e0
c00020fe:	e9 8d fb ff ff       	jmp    c0001c90 <intr_exit>

c0002103 <intr0x29entry>:
intr0x29entry():
c0002103:	6a 00                	push   $0x0
c0002105:	1e                   	push   %ds
c0002106:	06                   	push   %es
c0002107:	0f a0                	push   %fs
c0002109:	0f a8                	push   %gs
c000210b:	60                   	pusha  
c000210c:	b0 20                	mov    $0x20,%al
c000210e:	e6 a0                	out    %al,$0xa0
c0002110:	e6 20                	out    %al,$0x20
c0002112:	6a 29                	push   $0x29
c0002114:	ff 15 e4 78 00 c0    	call   *0xc00078e4
c000211a:	e9 71 fb ff ff       	jmp    c0001c90 <intr_exit>

c000211f <intr0x2aentry>:
intr0x2aentry():
c000211f:	6a 00                	push   $0x0
c0002121:	1e                   	push   %ds
c0002122:	06                   	push   %es
c0002123:	0f a0                	push   %fs
c0002125:	0f a8                	push   %gs
c0002127:	60                   	pusha  
c0002128:	b0 20                	mov    $0x20,%al
c000212a:	e6 a0                	out    %al,$0xa0
c000212c:	e6 20                	out    %al,$0x20
c000212e:	6a 2a                	push   $0x2a
c0002130:	ff 15 e8 78 00 c0    	call   *0xc00078e8
c0002136:	e9 55 fb ff ff       	jmp    c0001c90 <intr_exit>

c000213b <intr0x2bentry>:
intr0x2bentry():
c000213b:	6a 00                	push   $0x0
c000213d:	1e                   	push   %ds
c000213e:	06                   	push   %es
c000213f:	0f a0                	push   %fs
c0002141:	0f a8                	push   %gs
c0002143:	60                   	pusha  
c0002144:	b0 20                	mov    $0x20,%al
c0002146:	e6 a0                	out    %al,$0xa0
c0002148:	e6 20                	out    %al,$0x20
c000214a:	6a 2b                	push   $0x2b
c000214c:	ff 15 ec 78 00 c0    	call   *0xc00078ec
c0002152:	e9 39 fb ff ff       	jmp    c0001c90 <intr_exit>

c0002157 <intr0x2centry>:
intr0x2centry():
c0002157:	6a 00                	push   $0x0
c0002159:	1e                   	push   %ds
c000215a:	06                   	push   %es
c000215b:	0f a0                	push   %fs
c000215d:	0f a8                	push   %gs
c000215f:	60                   	pusha  
c0002160:	b0 20                	mov    $0x20,%al
c0002162:	e6 a0                	out    %al,$0xa0
c0002164:	e6 20                	out    %al,$0x20
c0002166:	6a 2c                	push   $0x2c
c0002168:	ff 15 f0 78 00 c0    	call   *0xc00078f0
c000216e:	e9 1d fb ff ff       	jmp    c0001c90 <intr_exit>

c0002173 <intr0x2dentry>:
intr0x2dentry():
c0002173:	6a 00                	push   $0x0
c0002175:	1e                   	push   %ds
c0002176:	06                   	push   %es
c0002177:	0f a0                	push   %fs
c0002179:	0f a8                	push   %gs
c000217b:	60                   	pusha  
c000217c:	b0 20                	mov    $0x20,%al
c000217e:	e6 a0                	out    %al,$0xa0
c0002180:	e6 20                	out    %al,$0x20
c0002182:	6a 2d                	push   $0x2d
c0002184:	ff 15 f4 78 00 c0    	call   *0xc00078f4
c000218a:	e9 01 fb ff ff       	jmp    c0001c90 <intr_exit>

c000218f <intr0x2eentry>:
intr0x2eentry():
c000218f:	6a 00                	push   $0x0
c0002191:	1e                   	push   %ds
c0002192:	06                   	push   %es
c0002193:	0f a0                	push   %fs
c0002195:	0f a8                	push   %gs
c0002197:	60                   	pusha  
c0002198:	b0 20                	mov    $0x20,%al
c000219a:	e6 a0                	out    %al,$0xa0
c000219c:	e6 20                	out    %al,$0x20
c000219e:	6a 2e                	push   $0x2e
c00021a0:	ff 15 f8 78 00 c0    	call   *0xc00078f8
c00021a6:	e9 e5 fa ff ff       	jmp    c0001c90 <intr_exit>

c00021ab <intr0x2fentry>:
intr0x2fentry():
c00021ab:	6a 00                	push   $0x0
c00021ad:	1e                   	push   %ds
c00021ae:	06                   	push   %es
c00021af:	0f a0                	push   %fs
c00021b1:	0f a8                	push   %gs
c00021b3:	60                   	pusha  
c00021b4:	b0 20                	mov    $0x20,%al
c00021b6:	e6 a0                	out    %al,$0xa0
c00021b8:	e6 20                	out    %al,$0x20
c00021ba:	6a 2f                	push   $0x2f
c00021bc:	ff 15 fc 78 00 c0    	call   *0xc00078fc
c00021c2:	e9 c9 fa ff ff       	jmp    c0001c90 <intr_exit>

c00021c7 <syscall_handler>:
syscall_handler():
c00021c7:	6a 00                	push   $0x0
c00021c9:	1e                   	push   %ds
c00021ca:	06                   	push   %es
c00021cb:	0f a0                	push   %fs
c00021cd:	0f a8                	push   %gs
c00021cf:	60                   	pusha  
c00021d0:	68 80 00 00 00       	push   $0x80
c00021d5:	52                   	push   %edx
c00021d6:	51                   	push   %ecx
c00021d7:	53                   	push   %ebx
c00021d8:	ff 14 85 a0 7b 00 c0 	call   *-0x3fff8460(,%eax,4)
c00021df:	83 c4 0c             	add    $0xc,%esp
c00021e2:	89 44 24 20          	mov    %eax,0x20(%esp)
c00021e6:	e9 a5 fa ff ff       	jmp    c0001c90 <intr_exit>
c00021eb:	66 90                	xchg   %ax,%ax
c00021ed:	66 90                	xchg   %ax,%ax
c00021ef:	90                   	nop

c00021f0 <put_str>:
put_str():
c00021f0:	53                   	push   %ebx
c00021f1:	51                   	push   %ecx
c00021f2:	31 c9                	xor    %ecx,%ecx
c00021f4:	8b 5c 24 0c          	mov    0xc(%esp),%ebx

c00021f8 <put_str.goon>:
put_str.goon():
c00021f8:	8a 0b                	mov    (%ebx),%cl
c00021fa:	80 f9 00             	cmp    $0x0,%cl
c00021fd:	74 0c                	je     c000220b <put_str.str_over>
c00021ff:	51                   	push   %ecx
c0002200:	e8 09 00 00 00       	call   c000220e <put_char>
c0002205:	83 c4 04             	add    $0x4,%esp
c0002208:	43                   	inc    %ebx
c0002209:	eb ed                	jmp    c00021f8 <put_str.goon>

c000220b <put_str.str_over>:
put_str.str_over():
c000220b:	59                   	pop    %ecx
c000220c:	5b                   	pop    %ebx
c000220d:	c3                   	ret    

c000220e <put_char>:
put_char():
c000220e:	60                   	pusha  
c000220f:	66 b8 18 00          	mov    $0x18,%ax
c0002213:	8e e8                	mov    %eax,%gs
c0002215:	66 ba d4 03          	mov    $0x3d4,%dx
c0002219:	b0 0e                	mov    $0xe,%al
c000221b:	ee                   	out    %al,(%dx)
c000221c:	66 ba d5 03          	mov    $0x3d5,%dx
c0002220:	ec                   	in     (%dx),%al
c0002221:	88 c4                	mov    %al,%ah
c0002223:	66 ba d4 03          	mov    $0x3d4,%dx
c0002227:	b0 0f                	mov    $0xf,%al
c0002229:	ee                   	out    %al,(%dx)
c000222a:	66 ba d5 03          	mov    $0x3d5,%dx
c000222e:	ec                   	in     (%dx),%al
c000222f:	66 89 c3             	mov    %ax,%bx
c0002232:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0002236:	80 f9 0d             	cmp    $0xd,%cl
c0002239:	74 3c                	je     c0002277 <put_char.is_carriage_return>
c000223b:	80 f9 0a             	cmp    $0xa,%cl
c000223e:	74 37                	je     c0002277 <put_char.is_carriage_return>
c0002240:	80 f9 08             	cmp    $0x8,%cl
c0002243:	74 02                	je     c0002247 <put_char.is_backspace>
c0002245:	eb 16                	jmp    c000225d <put_char.put_other>

c0002247 <put_char.is_backspace>:
put_char.is_backspace():
c0002247:	66 4b                	dec    %bx
c0002249:	66 d1 e3             	shl    %bx
c000224c:	65 67 c6 07 20       	movb   $0x20,%gs:(%bx)
c0002251:	66 43                	inc    %bx
c0002253:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c0002258:	66 d1 eb             	shr    %bx
c000225b:	eb 60                	jmp    c00022bd <put_char.set_cursor>

c000225d <put_char.put_other>:
put_char.put_other():
c000225d:	66 d1 e3             	shl    %bx
c0002260:	65 67 88 0f          	mov    %cl,%gs:(%bx)
c0002264:	66 43                	inc    %bx
c0002266:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c000226b:	66 d1 eb             	shr    %bx
c000226e:	66 43                	inc    %bx
c0002270:	66 81 fb d0 07       	cmp    $0x7d0,%bx
c0002275:	7c 46                	jl     c00022bd <put_char.set_cursor>

c0002277 <put_char.is_carriage_return>:
put_char.is_line_feed():
c0002277:	66 31 d2             	xor    %dx,%dx
c000227a:	66 89 d8             	mov    %bx,%ax
c000227d:	66 be 50 00          	mov    $0x50,%si
c0002281:	66 f7 f6             	div    %si
c0002284:	66 29 d3             	sub    %dx,%bx

c0002287 <put_char.is_carriage_return_end>:
put_char.is_carriage_return_end():
c0002287:	66 83 c3 50          	add    $0x50,%bx
c000228b:	66 81 fb d0 07       	cmp    $0x7d0,%bx

c0002290 <put_char.is_line_feed_end>:
put_char.is_line_feed_end():
c0002290:	7c 2b                	jl     c00022bd <put_char.set_cursor>

c0002292 <put_char.roll_screen>:
put_char.roll_screen():
c0002292:	fc                   	cld    
c0002293:	b9 c0 03 00 00       	mov    $0x3c0,%ecx
c0002298:	be a0 80 0b c0       	mov    $0xc00b80a0,%esi
c000229d:	bf 00 80 0b c0       	mov    $0xc00b8000,%edi
c00022a2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
c00022a4:	bb 00 0f 00 00       	mov    $0xf00,%ebx
c00022a9:	b9 50 00 00 00       	mov    $0x50,%ecx

c00022ae <put_char.cls>:
put_char.cls():
c00022ae:	65 66 c7 03 20 07    	movw   $0x720,%gs:(%ebx)
c00022b4:	83 c3 02             	add    $0x2,%ebx
c00022b7:	e2 f5                	loop   c00022ae <put_char.cls>
c00022b9:	66 bb 80 07          	mov    $0x780,%bx

c00022bd <put_char.set_cursor>:
put_char.set_cursor():
c00022bd:	66 ba d4 03          	mov    $0x3d4,%dx
c00022c1:	b0 0e                	mov    $0xe,%al
c00022c3:	ee                   	out    %al,(%dx)
c00022c4:	66 ba d5 03          	mov    $0x3d5,%dx
c00022c8:	88 f8                	mov    %bh,%al
c00022ca:	ee                   	out    %al,(%dx)
c00022cb:	66 ba d4 03          	mov    $0x3d4,%dx
c00022cf:	b0 0f                	mov    $0xf,%al
c00022d1:	ee                   	out    %al,(%dx)
c00022d2:	66 ba d5 03          	mov    $0x3d5,%dx
c00022d6:	88 d8                	mov    %bl,%al
c00022d8:	ee                   	out    %al,(%dx)

c00022d9 <put_char.put_char_done>:
put_char.put_char_done():
c00022d9:	61                   	popa   
c00022da:	c3                   	ret    

c00022db <put_int>:
put_int():
c00022db:	60                   	pusha  
c00022dc:	89 e5                	mov    %esp,%ebp
c00022de:	8b 45 24             	mov    0x24(%ebp),%eax
c00022e1:	89 c2                	mov    %eax,%edx
c00022e3:	bf 07 00 00 00       	mov    $0x7,%edi
c00022e8:	b9 08 00 00 00       	mov    $0x8,%ecx
c00022ed:	bb c0 70 00 c0       	mov    $0xc00070c0,%ebx

c00022f2 <put_int.16based_4bits>:
put_int.16based_4bits():
c00022f2:	83 e2 0f             	and    $0xf,%edx
c00022f5:	83 fa 09             	cmp    $0x9,%edx
c00022f8:	7f 05                	jg     c00022ff <put_int.is_A2F>
c00022fa:	83 c2 30             	add    $0x30,%edx
c00022fd:	eb 06                	jmp    c0002305 <put_int.store>

c00022ff <put_int.is_A2F>:
put_int.is_A2F():
c00022ff:	83 ea 0a             	sub    $0xa,%edx
c0002302:	83 c2 41             	add    $0x41,%edx

c0002305 <put_int.store>:
put_int.store():
c0002305:	88 14 3b             	mov    %dl,(%ebx,%edi,1)
c0002308:	4f                   	dec    %edi
c0002309:	c1 e8 04             	shr    $0x4,%eax
c000230c:	89 c2                	mov    %eax,%edx
c000230e:	e2 e2                	loop   c00022f2 <put_int.16based_4bits>

c0002310 <put_int.ready_to_print>:
put_int.ready_to_print():
c0002310:	47                   	inc    %edi

c0002311 <put_int.skip_prefix_0>:
put_int.skip_prefix_0():
c0002311:	83 ff 08             	cmp    $0x8,%edi
c0002314:	74 0f                	je     c0002325 <put_int.full0>

c0002316 <put_int.go_on_skip>:
put_int.go_on_skip():
c0002316:	8a 8f c0 70 00 c0    	mov    -0x3fff8f40(%edi),%cl
c000231c:	47                   	inc    %edi
c000231d:	80 f9 30             	cmp    $0x30,%cl
c0002320:	74 ef                	je     c0002311 <put_int.skip_prefix_0>
c0002322:	4f                   	dec    %edi
c0002323:	eb 02                	jmp    c0002327 <put_int.put_each_num>

c0002325 <put_int.full0>:
put_int.full0():
c0002325:	b1 30                	mov    $0x30,%cl

c0002327 <put_int.put_each_num>:
put_int.put_each_num():
c0002327:	51                   	push   %ecx
c0002328:	e8 e1 fe ff ff       	call   c000220e <put_char>
c000232d:	83 c4 04             	add    $0x4,%esp
c0002330:	47                   	inc    %edi
c0002331:	8a 8f c0 70 00 c0    	mov    -0x3fff8f40(%edi),%cl
c0002337:	83 ff 08             	cmp    $0x8,%edi
c000233a:	7c eb                	jl     c0002327 <put_int.put_each_num>
c000233c:	61                   	popa   
c000233d:	c3                   	ret    

c000233e <set_cursor>:
set_cursor():
c000233e:	60                   	pusha  
c000233f:	66 8b 5c 24 24       	mov    0x24(%esp),%bx
c0002344:	66 ba d4 03          	mov    $0x3d4,%dx
c0002348:	b0 0e                	mov    $0xe,%al
c000234a:	ee                   	out    %al,(%dx)
c000234b:	66 ba d5 03          	mov    $0x3d5,%dx
c000234f:	88 f8                	mov    %bh,%al
c0002351:	ee                   	out    %al,(%dx)
c0002352:	66 ba d4 03          	mov    $0x3d4,%dx
c0002356:	b0 0f                	mov    $0xf,%al
c0002358:	ee                   	out    %al,(%dx)
c0002359:	66 ba d5 03          	mov    $0x3d5,%dx
c000235d:	88 d8                	mov    %bl,%al
c000235f:	ee                   	out    %al,(%dx)
c0002360:	61                   	popa   
c0002361:	c3                   	ret    

c0002362 <panic_spin>:
panic_spin():
/work/x86_os_my/kernel/debug.c:10
/* 打印文件名,行号,函数名,条件并使程序悬停 */
void panic_spin(char* filename,	       \
	        int line,	       \
		const char* func,      \
		const char* condition) \
{
c0002362:	55                   	push   %ebp
c0002363:	89 e5                	mov    %esp,%ebp
c0002365:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/debug.c:11
   intr_disable();	// 因为有时候会单独调用panic_spin,所以在此处关中断。
c0002368:	e8 cc f6 ff ff       	call   c0001a39 <intr_disable>
/work/x86_os_my/kernel/debug.c:12
   put_str("\n\n\n!!!!! error !!!!!\n");
c000236d:	83 ec 0c             	sub    $0xc,%esp
c0002370:	68 fb 4f 00 c0       	push   $0xc0004ffb
c0002375:	e8 76 fe ff ff       	call   c00021f0 <put_str>
c000237a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:13
   put_str("filename:");put_str(filename);put_str("\n");
c000237d:	83 ec 0c             	sub    $0xc,%esp
c0002380:	68 11 50 00 c0       	push   $0xc0005011
c0002385:	e8 66 fe ff ff       	call   c00021f0 <put_str>
c000238a:	83 c4 10             	add    $0x10,%esp
c000238d:	83 ec 0c             	sub    $0xc,%esp
c0002390:	ff 75 08             	pushl  0x8(%ebp)
c0002393:	e8 58 fe ff ff       	call   c00021f0 <put_str>
c0002398:	83 c4 10             	add    $0x10,%esp
c000239b:	83 ec 0c             	sub    $0xc,%esp
c000239e:	68 1b 50 00 c0       	push   $0xc000501b
c00023a3:	e8 48 fe ff ff       	call   c00021f0 <put_str>
c00023a8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:14
   put_str("line:0x");put_int(line);put_str("\n");
c00023ab:	83 ec 0c             	sub    $0xc,%esp
c00023ae:	68 1d 50 00 c0       	push   $0xc000501d
c00023b3:	e8 38 fe ff ff       	call   c00021f0 <put_str>
c00023b8:	83 c4 10             	add    $0x10,%esp
c00023bb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00023be:	83 ec 0c             	sub    $0xc,%esp
c00023c1:	50                   	push   %eax
c00023c2:	e8 14 ff ff ff       	call   c00022db <put_int>
c00023c7:	83 c4 10             	add    $0x10,%esp
c00023ca:	83 ec 0c             	sub    $0xc,%esp
c00023cd:	68 1b 50 00 c0       	push   $0xc000501b
c00023d2:	e8 19 fe ff ff       	call   c00021f0 <put_str>
c00023d7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:15
   put_str("function:");put_str((char*)func);put_str("\n");
c00023da:	83 ec 0c             	sub    $0xc,%esp
c00023dd:	68 25 50 00 c0       	push   $0xc0005025
c00023e2:	e8 09 fe ff ff       	call   c00021f0 <put_str>
c00023e7:	83 c4 10             	add    $0x10,%esp
c00023ea:	83 ec 0c             	sub    $0xc,%esp
c00023ed:	ff 75 10             	pushl  0x10(%ebp)
c00023f0:	e8 fb fd ff ff       	call   c00021f0 <put_str>
c00023f5:	83 c4 10             	add    $0x10,%esp
c00023f8:	83 ec 0c             	sub    $0xc,%esp
c00023fb:	68 1b 50 00 c0       	push   $0xc000501b
c0002400:	e8 eb fd ff ff       	call   c00021f0 <put_str>
c0002405:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:16
   put_str("condition:");put_str((char*)condition);put_str("\n");
c0002408:	83 ec 0c             	sub    $0xc,%esp
c000240b:	68 2f 50 00 c0       	push   $0xc000502f
c0002410:	e8 db fd ff ff       	call   c00021f0 <put_str>
c0002415:	83 c4 10             	add    $0x10,%esp
c0002418:	83 ec 0c             	sub    $0xc,%esp
c000241b:	ff 75 14             	pushl  0x14(%ebp)
c000241e:	e8 cd fd ff ff       	call   c00021f0 <put_str>
c0002423:	83 c4 10             	add    $0x10,%esp
c0002426:	83 ec 0c             	sub    $0xc,%esp
c0002429:	68 1b 50 00 c0       	push   $0xc000501b
c000242e:	e8 bd fd ff ff       	call   c00021f0 <put_str>
c0002433:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:17 (discriminator 1)
   while(1);
c0002436:	eb fe                	jmp    c0002436 <panic_spin+0xd4>

c0002438 <bitmap_init>:
bitmap_init():
/work/x86_os_my/lib/kernel/bitmap.c:16
	uint8_t* bits;				位图空间
};
*/

/* 将位图btmp初始化 */
void bitmap_init(struct bitmap* btmp) {
c0002438:	55                   	push   %ebp
c0002439:	89 e5                	mov    %esp,%ebp
c000243b:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/bitmap.c:17
	memset(btmp->bits, 0, btmp->btmp_bytes_len);   
c000243e:	8b 45 08             	mov    0x8(%ebp),%eax
c0002441:	8b 10                	mov    (%eax),%edx
c0002443:	8b 45 08             	mov    0x8(%ebp),%eax
c0002446:	8b 40 04             	mov    0x4(%eax),%eax
c0002449:	83 ec 04             	sub    $0x4,%esp
c000244c:	52                   	push   %edx
c000244d:	6a 00                	push   $0x0
c000244f:	50                   	push   %eax
c0002450:	e8 35 0a 00 00       	call   c0002e8a <memset>
c0002455:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:18
}
c0002458:	90                   	nop
c0002459:	c9                   	leave  
c000245a:	c3                   	ret    

c000245b <bitmap_scan_test>:
bitmap_scan_test():
/work/x86_os_my/lib/kernel/bitmap.c:23

/* 判断bit_idx位是否为1
若为1则返回true
否则返回false */
bool bitmap_scan_test(struct bitmap* btmp, uint32_t bit_idx) {
c000245b:	55                   	push   %ebp
c000245c:	89 e5                	mov    %esp,%ebp
c000245e:	53                   	push   %ebx
c000245f:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:24
	uint32_t byte_idx = bit_idx / 8;    // 向下取整用于索引数组下标
c0002462:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002465:	c1 e8 03             	shr    $0x3,%eax
c0002468:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:25
	uint32_t bit_odd  = bit_idx % 8;    // 取余用于索引数组内的位
c000246b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000246e:	83 e0 07             	and    $0x7,%eax
c0002471:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:26
	return (btmp->bits[byte_idx] & (BITMAP_MASK << bit_odd));
c0002474:	8b 45 08             	mov    0x8(%ebp),%eax
c0002477:	8b 50 04             	mov    0x4(%eax),%edx
c000247a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000247d:	01 d0                	add    %edx,%eax
c000247f:	0f b6 00             	movzbl (%eax),%eax
c0002482:	0f b6 d0             	movzbl %al,%edx
c0002485:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002488:	bb 01 00 00 00       	mov    $0x1,%ebx
c000248d:	89 c1                	mov    %eax,%ecx
c000248f:	d3 e3                	shl    %cl,%ebx
c0002491:	89 d8                	mov    %ebx,%eax
c0002493:	21 d0                	and    %edx,%eax
/work/x86_os_my/lib/kernel/bitmap.c:27
}
c0002495:	83 c4 10             	add    $0x10,%esp
c0002498:	5b                   	pop    %ebx
c0002499:	5d                   	pop    %ebp
c000249a:	c3                   	ret    

c000249b <bitmap_scan>:
bitmap_scan():
/work/x86_os_my/lib/kernel/bitmap.c:32

/* 在位图中申请连续cnt个位
成功：返回其起始位下标
失败：返回-1 */
int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {
c000249b:	55                   	push   %ebp
c000249c:	89 e5                	mov    %esp,%ebp
c000249e:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/lib/kernel/bitmap.c:33
	uint32_t idx_byte = 0;	 // 用于记录空闲位所在的字节
c00024a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:35
	/* 先逐字节比较,蛮力法 */
	while (( 0xff == btmp->bits[idx_byte]) && (idx_byte < btmp->btmp_bytes_len)) {
c00024a8:	eb 04                	jmp    c00024ae <bitmap_scan+0x13>
/work/x86_os_my/lib/kernel/bitmap.c:37
		/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */
		idx_byte++;
c00024aa:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:35
成功：返回其起始位下标
失败：返回-1 */
int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {
	uint32_t idx_byte = 0;	 // 用于记录空闲位所在的字节
	/* 先逐字节比较,蛮力法 */
	while (( 0xff == btmp->bits[idx_byte]) && (idx_byte < btmp->btmp_bytes_len)) {
c00024ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00024b1:	8b 50 04             	mov    0x4(%eax),%edx
c00024b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00024b7:	01 d0                	add    %edx,%eax
c00024b9:	0f b6 00             	movzbl (%eax),%eax
c00024bc:	3c ff                	cmp    $0xff,%al
c00024be:	75 0a                	jne    c00024ca <bitmap_scan+0x2f>
/work/x86_os_my/lib/kernel/bitmap.c:35 (discriminator 1)
c00024c0:	8b 45 08             	mov    0x8(%ebp),%eax
c00024c3:	8b 00                	mov    (%eax),%eax
c00024c5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00024c8:	77 e0                	ja     c00024aa <bitmap_scan+0xf>
/work/x86_os_my/lib/kernel/bitmap.c:39
		/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */
		idx_byte++;
	}
	ASSERT(idx_byte < btmp->btmp_bytes_len);	//这里应该是"<="
c00024ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00024cd:	8b 00                	mov    (%eax),%eax
c00024cf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00024d2:	77 19                	ja     c00024ed <bitmap_scan+0x52>
/work/x86_os_my/lib/kernel/bitmap.c:39 (discriminator 1)
c00024d4:	68 3c 50 00 c0       	push   $0xc000503c
c00024d9:	68 90 50 00 c0       	push   $0xc0005090
c00024de:	6a 27                	push   $0x27
c00024e0:	68 5c 50 00 c0       	push   $0xc000505c
c00024e5:	e8 78 fe ff ff       	call   c0002362 <panic_spin>
c00024ea:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:40
	if (idx_byte == btmp->btmp_bytes_len) {		// 若该内存池找不到可用空间		
c00024ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00024f0:	8b 00                	mov    (%eax),%eax
c00024f2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00024f5:	75 0a                	jne    c0002501 <bitmap_scan+0x66>
/work/x86_os_my/lib/kernel/bitmap.c:41
		return -1;
c00024f7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00024fc:	e9 cd 00 00 00       	jmp    c00025ce <bitmap_scan+0x133>
/work/x86_os_my/lib/kernel/bitmap.c:46
	}

	/* 若在位图数组范围内的某字节内找到了空闲位，
	 * 在该字节内逐位比对,返回空闲位的索引。*/
	int idx_bit = 0;
c0002501:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:48
	/* 和btmp->bits[idx_byte]这个字节逐位对比 */
	while ((uint8_t)(BITMAP_MASK << idx_bit) & btmp->bits[idx_byte]) { 
c0002508:	eb 04                	jmp    c000250e <bitmap_scan+0x73>
/work/x86_os_my/lib/kernel/bitmap.c:49
		idx_bit++;
c000250a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:48

	/* 若在位图数组范围内的某字节内找到了空闲位，
	 * 在该字节内逐位比对,返回空闲位的索引。*/
	int idx_bit = 0;
	/* 和btmp->bits[idx_byte]这个字节逐位对比 */
	while ((uint8_t)(BITMAP_MASK << idx_bit) & btmp->bits[idx_byte]) { 
c000250e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002511:	ba 01 00 00 00       	mov    $0x1,%edx
c0002516:	89 c1                	mov    %eax,%ecx
c0002518:	d3 e2                	shl    %cl,%edx
c000251a:	89 d0                	mov    %edx,%eax
c000251c:	0f b6 d0             	movzbl %al,%edx
c000251f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002522:	8b 48 04             	mov    0x4(%eax),%ecx
c0002525:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002528:	01 c8                	add    %ecx,%eax
c000252a:	0f b6 00             	movzbl (%eax),%eax
c000252d:	0f b6 c0             	movzbl %al,%eax
c0002530:	21 d0                	and    %edx,%eax
c0002532:	85 c0                	test   %eax,%eax
c0002534:	75 d4                	jne    c000250a <bitmap_scan+0x6f>
/work/x86_os_my/lib/kernel/bitmap.c:52
		idx_bit++;
	}
	
	int bit_idx_start = idx_byte * 8 + idx_bit;		// 空闲位在位图内的下标
c0002536:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002539:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c0002540:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002543:	01 d0                	add    %edx,%eax
c0002545:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:53
	if (cnt == 1) {
c0002548:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
c000254c:	75 05                	jne    c0002553 <bitmap_scan+0xb8>
/work/x86_os_my/lib/kernel/bitmap.c:54
		return bit_idx_start;
c000254e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002551:	eb 7b                	jmp    c00025ce <bitmap_scan+0x133>
/work/x86_os_my/lib/kernel/bitmap.c:57
	}

	uint32_t bit_left = (btmp->btmp_bytes_len * 8 - bit_idx_start);	// 记录还有多少位可以判断
c0002553:	8b 45 08             	mov    0x8(%ebp),%eax
c0002556:	8b 00                	mov    (%eax),%eax
c0002558:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c000255f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002562:	29 c2                	sub    %eax,%edx
c0002564:	89 d0                	mov    %edx,%eax
c0002566:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:58
	uint32_t next_bit = bit_idx_start + 1;
c0002569:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000256c:	83 c0 01             	add    $0x1,%eax
c000256f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:59
	uint32_t count = 1;			// 用于记录找到的空闲位的个数
c0002572:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:61

	bit_idx_start = -1;			// 初始化为-1，若找不到连续的位就直接返回-1
c0002579:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:62
	while (bit_left-- > 0) {
c0002580:	eb 3c                	jmp    c00025be <bitmap_scan+0x123>
/work/x86_os_my/lib/kernel/bitmap.c:63
		if (!(bitmap_scan_test(btmp, next_bit))) {	// 判断next_bit位是否为1,=1返回true，=0返回false
c0002582:	83 ec 08             	sub    $0x8,%esp
c0002585:	ff 75 e4             	pushl  -0x1c(%ebp)
c0002588:	ff 75 08             	pushl  0x8(%ebp)
c000258b:	e8 cb fe ff ff       	call   c000245b <bitmap_scan_test>
c0002590:	83 c4 10             	add    $0x10,%esp
c0002593:	85 c0                	test   %eax,%eax
c0002595:	75 06                	jne    c000259d <bitmap_scan+0x102>
/work/x86_os_my/lib/kernel/bitmap.c:64
			count++;
c0002597:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
c000259b:	eb 07                	jmp    c00025a4 <bitmap_scan+0x109>
/work/x86_os_my/lib/kernel/bitmap.c:66
		} else {
			count = 0;			// 重新从0找cnt个连续的bit
c000259d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:69
		}
		
		if (count == cnt) {		// 已找到连续的cnt个空位
c00025a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00025a7:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00025aa:	75 0e                	jne    c00025ba <bitmap_scan+0x11f>
/work/x86_os_my/lib/kernel/bitmap.c:70
			bit_idx_start = next_bit - cnt + 1;
c00025ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00025af:	2b 45 0c             	sub    0xc(%ebp),%eax
c00025b2:	83 c0 01             	add    $0x1,%eax
c00025b5:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:71
			break;
c00025b8:	eb 11                	jmp    c00025cb <bitmap_scan+0x130>
/work/x86_os_my/lib/kernel/bitmap.c:73
		}
		next_bit++;
c00025ba:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:62
	uint32_t bit_left = (btmp->btmp_bytes_len * 8 - bit_idx_start);	// 记录还有多少位可以判断
	uint32_t next_bit = bit_idx_start + 1;
	uint32_t count = 1;			// 用于记录找到的空闲位的个数

	bit_idx_start = -1;			// 初始化为-1，若找不到连续的位就直接返回-1
	while (bit_left-- > 0) {
c00025be:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00025c1:	8d 50 ff             	lea    -0x1(%eax),%edx
c00025c4:	89 55 e8             	mov    %edx,-0x18(%ebp)
c00025c7:	85 c0                	test   %eax,%eax
c00025c9:	75 b7                	jne    c0002582 <bitmap_scan+0xe7>
/work/x86_os_my/lib/kernel/bitmap.c:75
			bit_idx_start = next_bit - cnt + 1;
			break;
		}
		next_bit++;
	}
	return bit_idx_start;
c00025cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/lib/kernel/bitmap.c:76
}
c00025ce:	c9                   	leave  
c00025cf:	c3                   	ret    

c00025d0 <bitmap_set>:
bitmap_set():
/work/x86_os_my/lib/kernel/bitmap.c:79

/* 将位图btmp的bit_idx位设置为value */
void bitmap_set(struct bitmap* btmp, uint32_t bit_idx, int8_t value) {
c00025d0:	55                   	push   %ebp
c00025d1:	89 e5                	mov    %esp,%ebp
c00025d3:	56                   	push   %esi
c00025d4:	53                   	push   %ebx
c00025d5:	83 ec 20             	sub    $0x20,%esp
c00025d8:	8b 45 10             	mov    0x10(%ebp),%eax
c00025db:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:80
	ASSERT((value == 0) || (value == 1));
c00025de:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c00025e2:	74 1f                	je     c0002603 <bitmap_set+0x33>
/work/x86_os_my/lib/kernel/bitmap.c:80 (discriminator 1)
c00025e4:	80 7d e4 01          	cmpb   $0x1,-0x1c(%ebp)
c00025e8:	74 19                	je     c0002603 <bitmap_set+0x33>
/work/x86_os_my/lib/kernel/bitmap.c:80 (discriminator 2)
c00025ea:	68 70 50 00 c0       	push   $0xc0005070
c00025ef:	68 9c 50 00 c0       	push   $0xc000509c
c00025f4:	6a 50                	push   $0x50
c00025f6:	68 5c 50 00 c0       	push   $0xc000505c
c00025fb:	e8 62 fd ff ff       	call   c0002362 <panic_spin>
c0002600:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:81
	uint32_t byte_idx = bit_idx / 8;    // 向下取整用于索引数组下标
c0002603:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002606:	c1 e8 03             	shr    $0x3,%eax
c0002609:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:82
	uint32_t bit_odd  = bit_idx % 8;    // 取余用于索引数组内的位
c000260c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000260f:	83 e0 07             	and    $0x7,%eax
c0002612:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:86

	/* 一般都会用个0x1这样的数对字节中的位操作,
	* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/
	if (value) {
c0002615:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c0002619:	74 2f                	je     c000264a <bitmap_set+0x7a>
/work/x86_os_my/lib/kernel/bitmap.c:87
		btmp->bits[byte_idx] |= (BITMAP_MASK << bit_odd);
c000261b:	8b 45 08             	mov    0x8(%ebp),%eax
c000261e:	8b 50 04             	mov    0x4(%eax),%edx
c0002621:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002624:	01 c2                	add    %eax,%edx
c0002626:	8b 45 08             	mov    0x8(%ebp),%eax
c0002629:	8b 48 04             	mov    0x4(%eax),%ecx
c000262c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000262f:	01 c8                	add    %ecx,%eax
c0002631:	0f b6 00             	movzbl (%eax),%eax
c0002634:	89 c6                	mov    %eax,%esi
c0002636:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002639:	bb 01 00 00 00       	mov    $0x1,%ebx
c000263e:	89 c1                	mov    %eax,%ecx
c0002640:	d3 e3                	shl    %cl,%ebx
c0002642:	89 d8                	mov    %ebx,%eax
c0002644:	09 f0                	or     %esi,%eax
c0002646:	88 02                	mov    %al,(%edx)
/work/x86_os_my/lib/kernel/bitmap.c:91
	} else {
		btmp->bits[byte_idx] &= ~(BITMAP_MASK << bit_odd);
	}
}
c0002648:	eb 2f                	jmp    c0002679 <bitmap_set+0xa9>
/work/x86_os_my/lib/kernel/bitmap.c:89
	/* 一般都会用个0x1这样的数对字节中的位操作,
	* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/
	if (value) {
		btmp->bits[byte_idx] |= (BITMAP_MASK << bit_odd);
	} else {
		btmp->bits[byte_idx] &= ~(BITMAP_MASK << bit_odd);
c000264a:	8b 45 08             	mov    0x8(%ebp),%eax
c000264d:	8b 50 04             	mov    0x4(%eax),%edx
c0002650:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002653:	01 c2                	add    %eax,%edx
c0002655:	8b 45 08             	mov    0x8(%ebp),%eax
c0002658:	8b 48 04             	mov    0x4(%eax),%ecx
c000265b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000265e:	01 c8                	add    %ecx,%eax
c0002660:	0f b6 00             	movzbl (%eax),%eax
c0002663:	89 c3                	mov    %eax,%ebx
c0002665:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002668:	be 01 00 00 00       	mov    $0x1,%esi
c000266d:	89 c1                	mov    %eax,%ecx
c000266f:	d3 e6                	shl    %cl,%esi
c0002671:	89 f0                	mov    %esi,%eax
c0002673:	f7 d0                	not    %eax
c0002675:	21 d8                	and    %ebx,%eax
c0002677:	88 02                	mov    %al,(%edx)
/work/x86_os_my/lib/kernel/bitmap.c:91
	}
}
c0002679:	90                   	nop
c000267a:	8d 65 f8             	lea    -0x8(%ebp),%esp
c000267d:	5b                   	pop    %ebx
c000267e:	5e                   	pop    %esi
c000267f:	5d                   	pop    %ebp
c0002680:	c3                   	ret    

c0002681 <vaddr_get>:
vaddr_get():
/work/x86_os_my/kernel/memory.c:55
struct pool kernel_pool, user_pool;		// 生成内核内存池和用户内存池
struct virtual_addr kernel_vaddr;		// 此结构是用来给内核分配虚拟地址

/* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页,
 * 成功则返回虚拟页的起始地址, 失败则返回NULL */
static void* vaddr_get(enum pool_flags pf, uint32_t pg_cnt) {
c0002681:	55                   	push   %ebp
c0002682:	89 e5                	mov    %esp,%ebp
c0002684:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:56
	int vaddr_start = 0, bit_idx_start = -1;
c0002687:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000268e:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:57
	uint32_t cnt = 0;
c0002695:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:58
	if (pf == PF_KERNEL) {
c000269c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c00026a0:	75 64                	jne    c0002706 <vaddr_get+0x85>
/work/x86_os_my/kernel/memory.c:60
		// 在位图中申请连续cnt个位 成功：返回其起始位下标
		bit_idx_start  = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
c00026a2:	83 ec 08             	sub    $0x8,%esp
c00026a5:	ff 75 0c             	pushl  0xc(%ebp)
c00026a8:	68 8c 7a 00 c0       	push   $0xc0007a8c
c00026ad:	e8 e9 fd ff ff       	call   c000249b <bitmap_scan>
c00026b2:	83 c4 10             	add    $0x10,%esp
c00026b5:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:61
		if (bit_idx_start == -1) {	//失败
c00026b8:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c00026bc:	75 2b                	jne    c00026e9 <vaddr_get+0x68>
/work/x86_os_my/kernel/memory.c:62
			return NULL;
c00026be:	b8 00 00 00 00       	mov    $0x0,%eax
c00026c3:	e9 cd 00 00 00       	jmp    c0002795 <vaddr_get+0x114>
/work/x86_os_my/kernel/memory.c:66
		}
		while(cnt < pg_cnt) {
			// 设置位图中的位，表示内存已被占用
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
c00026c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00026cb:	8d 50 01             	lea    0x1(%eax),%edx
c00026ce:	89 55 f0             	mov    %edx,-0x10(%ebp)
c00026d1:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00026d4:	01 d0                	add    %edx,%eax
c00026d6:	83 ec 04             	sub    $0x4,%esp
c00026d9:	6a 01                	push   $0x1
c00026db:	50                   	push   %eax
c00026dc:	68 8c 7a 00 c0       	push   $0xc0007a8c
c00026e1:	e8 ea fe ff ff       	call   c00025d0 <bitmap_set>
c00026e6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:64
		// 在位图中申请连续cnt个位 成功：返回其起始位下标
		bit_idx_start  = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
		if (bit_idx_start == -1) {	//失败
			return NULL;
		}
		while(cnt < pg_cnt) {
c00026e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00026ec:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00026ef:	72 d7                	jb     c00026c8 <vaddr_get+0x47>
/work/x86_os_my/kernel/memory.c:68
			// 设置位图中的位，表示内存已被占用
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
		}
		vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
c00026f1:	a1 94 7a 00 c0       	mov    0xc0007a94,%eax
c00026f6:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00026f9:	c1 e2 0c             	shl    $0xc,%edx
c00026fc:	01 d0                	add    %edx,%eax
c00026fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002701:	e9 8c 00 00 00       	jmp    c0002792 <vaddr_get+0x111>
/work/x86_os_my/kernel/memory.c:70
	} else {
		struct task_struct* cur = running_thread();
c0002706:	e8 4f 0b 00 00       	call   c000325a <running_thread>
c000270b:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:71
		bit_idx_start  = bitmap_scan(&cur->userprog_vaddr.vaddr_bitmap, pg_cnt);
c000270e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002711:	83 c0 38             	add    $0x38,%eax
c0002714:	83 ec 08             	sub    $0x8,%esp
c0002717:	ff 75 0c             	pushl  0xc(%ebp)
c000271a:	50                   	push   %eax
c000271b:	e8 7b fd ff ff       	call   c000249b <bitmap_scan>
c0002720:	83 c4 10             	add    $0x10,%esp
c0002723:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:72
		if (bit_idx_start == -1) {
c0002726:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c000272a:	75 2a                	jne    c0002756 <vaddr_get+0xd5>
/work/x86_os_my/kernel/memory.c:73
			return NULL;
c000272c:	b8 00 00 00 00       	mov    $0x0,%eax
c0002731:	eb 62                	jmp    c0002795 <vaddr_get+0x114>
/work/x86_os_my/kernel/memory.c:76
		}
		while(cnt < pg_cnt) {
			bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
c0002733:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002736:	8d 50 01             	lea    0x1(%eax),%edx
c0002739:	89 55 f0             	mov    %edx,-0x10(%ebp)
c000273c:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000273f:	01 c2                	add    %eax,%edx
c0002741:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002744:	83 c0 38             	add    $0x38,%eax
c0002747:	83 ec 04             	sub    $0x4,%esp
c000274a:	6a 01                	push   $0x1
c000274c:	52                   	push   %edx
c000274d:	50                   	push   %eax
c000274e:	e8 7d fe ff ff       	call   c00025d0 <bitmap_set>
c0002753:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:75
		struct task_struct* cur = running_thread();
		bit_idx_start  = bitmap_scan(&cur->userprog_vaddr.vaddr_bitmap, pg_cnt);
		if (bit_idx_start == -1) {
			return NULL;
		}
		while(cnt < pg_cnt) {
c0002756:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002759:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000275c:	72 d5                	jb     c0002733 <vaddr_get+0xb2>
/work/x86_os_my/kernel/memory.c:78
			bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
		}
		vaddr_start = cur->userprog_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
c000275e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002761:	8b 40 40             	mov    0x40(%eax),%eax
c0002764:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002767:	c1 e2 0c             	shl    $0xc,%edx
c000276a:	01 d0                	add    %edx,%eax
c000276c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:81

		/* (0xc0000000 - PG_SIZE)做为用户3级栈已经在start_process被分配 */
		ASSERT((uint32_t)vaddr_start < (0xc0000000 - PG_SIZE));
c000276f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002772:	3d ff ef ff bf       	cmp    $0xbfffefff,%eax
c0002777:	76 19                	jbe    c0002792 <vaddr_get+0x111>
/work/x86_os_my/kernel/memory.c:81 (discriminator 1)
c0002779:	68 a8 50 00 c0       	push   $0xc00050a8
c000277e:	68 4c 52 00 c0       	push   $0xc000524c
c0002783:	6a 51                	push   $0x51
c0002785:	68 d7 50 00 c0       	push   $0xc00050d7
c000278a:	e8 d3 fb ff ff       	call   c0002362 <panic_spin>
c000278f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:84
		
	}
	return (void*)vaddr_start;
c0002792:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:85
}
c0002795:	c9                   	leave  
c0002796:	c3                   	ret    

c0002797 <pte_ptr>:
pte_ptr():
/work/x86_os_my/kernel/memory.c:92
// 页表项 page table
/* 得到虚拟地址vaddr对应的pte指针*/
// 虚拟地址 vaddr 所在 pte 的"虚拟地址"!!!
// *pte 代表的是 pte 页表项的内容,
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页表项"属性
uint32_t* pte_ptr(uint32_t vaddr) {
c0002797:	55                   	push   %ebp
c0002798:	89 e5                	mov    %esp,%ebp
c000279a:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:97
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
					((vaddr & 0xffc00000) >> 10) + \
c000279d:	8b 45 08             	mov    0x8(%ebp),%eax
c00027a0:	25 00 00 c0 ff       	and    $0xffc00000,%eax
c00027a5:	c1 e8 0a             	shr    $0xa,%eax
c00027a8:	89 c2                	mov    %eax,%edx
/work/x86_os_my/kernel/memory.c:98
					PTE_IDX(vaddr) * 4);
c00027aa:	8b 45 08             	mov    0x8(%ebp),%eax
c00027ad:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c00027b2:	c1 e8 0c             	shr    $0xc,%eax
c00027b5:	c1 e0 02             	shl    $0x2,%eax
/work/x86_os_my/kernel/memory.c:97
uint32_t* pte_ptr(uint32_t vaddr) {
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
					((vaddr & 0xffc00000) >> 10) + \
c00027b8:	01 d0                	add    %edx,%eax
c00027ba:	2d 00 00 40 00       	sub    $0x400000,%eax
/work/x86_os_my/kernel/memory.c:96
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页表项"属性
uint32_t* pte_ptr(uint32_t vaddr) {
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
c00027bf:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:99
					((vaddr & 0xffc00000) >> 10) + \
					PTE_IDX(vaddr) * 4);
	return pte;
c00027c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/kernel/memory.c:100
}
c00027c5:	c9                   	leave  
c00027c6:	c3                   	ret    

c00027c7 <pde_ptr>:
pde_ptr():
/work/x86_os_my/kernel/memory.c:107
// 页目录表项 page Directory table entry
/* 得到虚拟地址vaddr对应的pde的指针 */
// 虚拟地址 vaddr 所在 pde 的"虚拟地址"!!!
// *pde 代表的是 pde 页目录项的内容
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页目录项"属性
uint32_t* pde_ptr(uint32_t vaddr) {
c00027c7:	55                   	push   %ebp
c00027c8:	89 e5                	mov    %esp,%ebp
c00027ca:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:109
	/* 0xfffff是用来访问到页目录表本身所在的地址 */
	uint32_t* pde = (uint32_t*)((0xfffff000) + PDE_IDX(vaddr) * 4);
c00027cd:	8b 45 08             	mov    0x8(%ebp),%eax
c00027d0:	c1 e8 16             	shr    $0x16,%eax
c00027d3:	05 00 fc ff 3f       	add    $0x3ffffc00,%eax
c00027d8:	c1 e0 02             	shl    $0x2,%eax
c00027db:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:110
	return pde;
c00027de:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/kernel/memory.c:111
}
c00027e1:	c9                   	leave  
c00027e2:	c3                   	ret    

c00027e3 <palloc>:
palloc():
/work/x86_os_my/kernel/memory.c:115

/* 在m_pool指向的物理内存池中分配1个物理页,
 * 成功则返回页框的物理地址,失败则返回NULL */
static void* palloc(struct pool* m_pool) {
c00027e3:	55                   	push   %ebp
c00027e4:	89 e5                	mov    %esp,%ebp
c00027e6:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:117
	/* 扫描或设置位图要保证原子操作 */
	int bit_idx = bitmap_scan(&m_pool->pool_bitmap, 1);    // 找一个物理页面
c00027e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00027ec:	83 ec 08             	sub    $0x8,%esp
c00027ef:	6a 01                	push   $0x1
c00027f1:	50                   	push   %eax
c00027f2:	e8 a4 fc ff ff       	call   c000249b <bitmap_scan>
c00027f7:	83 c4 10             	add    $0x10,%esp
c00027fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:118
	if (bit_idx == -1 ) {
c00027fd:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0002801:	75 07                	jne    c000280a <palloc+0x27>
/work/x86_os_my/kernel/memory.c:119
		return NULL;
c0002803:	b8 00 00 00 00       	mov    $0x0,%eax
c0002808:	eb 2b                	jmp    c0002835 <palloc+0x52>
/work/x86_os_my/kernel/memory.c:121
	}
	bitmap_set(&m_pool->pool_bitmap, bit_idx, 1);	// 将此位bit_idx置1
c000280a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000280d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002810:	83 ec 04             	sub    $0x4,%esp
c0002813:	6a 01                	push   $0x1
c0002815:	52                   	push   %edx
c0002816:	50                   	push   %eax
c0002817:	e8 b4 fd ff ff       	call   c00025d0 <bitmap_set>
c000281c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:122
	uint32_t page_phyaddr = ((bit_idx * PG_SIZE) + m_pool->phy_addr_start);
c000281f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002822:	c1 e0 0c             	shl    $0xc,%eax
c0002825:	89 c2                	mov    %eax,%edx
c0002827:	8b 45 08             	mov    0x8(%ebp),%eax
c000282a:	8b 40 08             	mov    0x8(%eax),%eax
c000282d:	01 d0                	add    %edx,%eax
c000282f:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:123
	return (void*)page_phyaddr;
c0002832:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/kernel/memory.c:124
}
c0002835:	c9                   	leave  
c0002836:	c3                   	ret    

c0002837 <page_table_add>:
page_table_add():
/work/x86_os_my/kernel/memory.c:127

/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */
static void page_table_add(void* _vaddr, void* _page_phyaddr) {
c0002837:	55                   	push   %ebp
c0002838:	89 e5                	mov    %esp,%ebp
c000283a:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:128
	uint32_t vaddr = (uint32_t)_vaddr, page_phyaddr = (uint32_t)_page_phyaddr;
c000283d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002840:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002843:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002846:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:129
	uint32_t* pde = pde_ptr(vaddr);	//变量pde是虚拟地址!!!
c0002849:	ff 75 f4             	pushl  -0xc(%ebp)
c000284c:	e8 76 ff ff ff       	call   c00027c7 <pde_ptr>
c0002851:	83 c4 04             	add    $0x4,%esp
c0002854:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:130
	uint32_t* pte = pte_ptr(vaddr);	//变量pte是虚拟地址!!!
c0002857:	ff 75 f4             	pushl  -0xc(%ebp)
c000285a:	e8 38 ff ff ff       	call   c0002797 <pte_ptr>
c000285f:	83 c4 04             	add    $0x4,%esp
c0002862:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:138
	* pde页目录项 pte页表项
	* 执行*pte可能会访问到空的pde。所以确保pde创建完成后才能执行*pte，否则会引发page_fault。
	* 因此在*pde为0时，*pte只能出现在下面else语句块中的*pde后面。
	* *********************************************************/
	/* 先在页目录内判断目录项的P位，若为1,则表示该表已存在 */
	if (*pde & 0x00000001) {			// 页目录项 存在
c0002865:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002868:	8b 00                	mov    (%eax),%eax
c000286a:	83 e0 01             	and    $0x1,%eax
c000286d:	85 c0                	test   %eax,%eax
c000286f:	74 64                	je     c00028d5 <page_table_add+0x9e>
/work/x86_os_my/kernel/memory.c:139
		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
c0002871:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002874:	8b 00                	mov    (%eax),%eax
c0002876:	83 e0 01             	and    $0x1,%eax
c0002879:	85 c0                	test   %eax,%eax
c000287b:	74 1c                	je     c0002899 <page_table_add+0x62>
/work/x86_os_my/kernel/memory.c:139 (discriminator 1)
c000287d:	68 e7 50 00 c0       	push   $0xc00050e7
c0002882:	68 58 52 00 c0       	push   $0xc0005258
c0002887:	68 8b 00 00 00       	push   $0x8b
c000288c:	68 d7 50 00 c0       	push   $0xc00050d7
c0002891:	e8 cc fa ff ff       	call   c0002362 <panic_spin>
c0002896:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:141

		if (!(*pte & 0x00000001)) {		// 页表项pte不存在，创建PTE
c0002899:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000289c:	8b 00                	mov    (%eax),%eax
c000289e:	83 e0 01             	and    $0x1,%eax
c00028a1:	85 c0                	test   %eax,%eax
c00028a3:	75 12                	jne    c00028b7 <page_table_add+0x80>
/work/x86_os_my/kernel/memory.c:142
			*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);		// 物理地址 | US=1,RW=1,P=1
c00028a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00028a8:	83 c8 07             	or     $0x7,%eax
c00028ab:	89 c2                	mov    %eax,%edx
c00028ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00028b0:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:162
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
	}
}
c00028b2:	e9 8e 00 00 00       	jmp    c0002945 <page_table_add+0x10e>
/work/x86_os_my/kernel/memory.c:144
		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic

		if (!(*pte & 0x00000001)) {		// 页表项pte不存在，创建PTE
			*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);		// 物理地址 | US=1,RW=1,P=1
		} else {						// 不会执行到这，因为上面的ASSERT
			PANIC("pte repeat");
c00028b7:	68 fc 50 00 c0       	push   $0xc00050fc
c00028bc:	68 58 52 00 c0       	push   $0xc0005258
c00028c1:	68 90 00 00 00       	push   $0x90
c00028c6:	68 d7 50 00 c0       	push   $0xc00050d7
c00028cb:	e8 92 fa ff ff       	call   c0002362 <panic_spin>
c00028d0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:162
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
	}
}
c00028d3:	eb 70                	jmp    c0002945 <page_table_add+0x10e>
/work/x86_os_my/kernel/memory.c:148
		} else {						// 不会执行到这，因为上面的ASSERT
			PANIC("pte repeat");
		}
	} else {							// 页目录项不存在，先创建页目录，再创建页表项
		/* 页表中用到的页一律从内核空间分配 */
		uint32_t pde_phyaddr = (uint32_t)palloc(&kernel_pool);
c00028d5:	83 ec 0c             	sub    $0xc,%esp
c00028d8:	68 a0 7a 00 c0       	push   $0xc0007aa0
c00028dd:	e8 01 ff ff ff       	call   c00027e3 <palloc>
c00028e2:	83 c4 10             	add    $0x10,%esp
c00028e5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:149
		*pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 注意这行是pde_phyaddr，不是page_phyaddr!!!
c00028e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00028eb:	83 c8 07             	or     $0x7,%eax
c00028ee:	89 c2                	mov    %eax,%edx
c00028f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00028f3:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:157
		 * 访问物理地址 pde_phyaddr，需要找到它的虚拟地址！
		 * 只要用_vaddr的 PTE 取高20位即可。
		   搞得这么难理解，其实就是0xffc00000找到页目录表，然后加上vaddr的PDE在页目录表中的索引
		   (uint32_t*)(0xffc00000 + ((vaddr & 0xffc00000) >> 10))
		 */
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);
c00028f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00028f8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00028fd:	83 ec 04             	sub    $0x4,%esp
c0002900:	68 00 10 00 00       	push   $0x1000
c0002905:	6a 00                	push   $0x0
c0002907:	50                   	push   %eax
c0002908:	e8 7d 05 00 00       	call   c0002e8a <memset>
c000290d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:159

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
c0002910:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002913:	8b 00                	mov    (%eax),%eax
c0002915:	83 e0 01             	and    $0x1,%eax
c0002918:	85 c0                	test   %eax,%eax
c000291a:	74 1c                	je     c0002938 <page_table_add+0x101>
/work/x86_os_my/kernel/memory.c:159 (discriminator 1)
c000291c:	68 e7 50 00 c0       	push   $0xc00050e7
c0002921:	68 58 52 00 c0       	push   $0xc0005258
c0002926:	68 9f 00 00 00       	push   $0x9f
c000292b:	68 d7 50 00 c0       	push   $0xc00050d7
c0002930:	e8 2d fa ff ff       	call   c0002362 <panic_spin>
c0002935:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:160
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
c0002938:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000293b:	83 c8 07             	or     $0x7,%eax
c000293e:	89 c2                	mov    %eax,%edx
c0002940:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002943:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:162
	}
}
c0002945:	90                   	nop
c0002946:	c9                   	leave  
c0002947:	c3                   	ret    

c0002948 <malloc_page>:
malloc_page():
/work/x86_os_my/kernel/memory.c:165

/* 分配pg_cnt个页空间,成功则返回起始虚拟地址,失败时返回NULL */
void* malloc_page(enum pool_flags pf, uint32_t pg_cnt) {
c0002948:	55                   	push   %ebp
c0002949:	89 e5                	mov    %esp,%ebp
c000294b:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:166
	ASSERT(pg_cnt > 0 && pg_cnt < 3840);
c000294e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002952:	74 09                	je     c000295d <malloc_page+0x15>
/work/x86_os_my/kernel/memory.c:166 (discriminator 1)
c0002954:	81 7d 0c ff 0e 00 00 	cmpl   $0xeff,0xc(%ebp)
c000295b:	76 1c                	jbe    c0002979 <malloc_page+0x31>
/work/x86_os_my/kernel/memory.c:166 (discriminator 3)
c000295d:	68 07 51 00 c0       	push   $0xc0005107
c0002962:	68 68 52 00 c0       	push   $0xc0005268
c0002967:	68 a6 00 00 00       	push   $0xa6
c000296c:	68 d7 50 00 c0       	push   $0xc00050d7
c0002971:	e8 ec f9 ff ff       	call   c0002362 <panic_spin>
c0002976:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:172
	/***********   malloc_page的原理是三个动作的合成:   ***********
		1 通过vaddr_get在虚拟内存池中申请虚拟地址
		2 通过palloc在物理内存池中申请物理页
		3 通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射
	***************************************************************/
	void* vaddr_start = vaddr_get(pf, pg_cnt);
c0002979:	83 ec 08             	sub    $0x8,%esp
c000297c:	ff 75 0c             	pushl  0xc(%ebp)
c000297f:	ff 75 08             	pushl  0x8(%ebp)
c0002982:	e8 fa fc ff ff       	call   c0002681 <vaddr_get>
c0002987:	83 c4 10             	add    $0x10,%esp
c000298a:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:173
	if (vaddr_start == NULL) {
c000298d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002991:	75 07                	jne    c000299a <malloc_page+0x52>
/work/x86_os_my/kernel/memory.c:174
		return NULL;
c0002993:	b8 00 00 00 00       	mov    $0x0,%eax
c0002998:	eb 6e                	jmp    c0002a08 <malloc_page+0xc0>
/work/x86_os_my/kernel/memory.c:177
	}

	uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
c000299a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000299d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00029a0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00029a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:178
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c00029a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00029a9:	83 e0 01             	and    $0x1,%eax
c00029ac:	85 c0                	test   %eax,%eax
c00029ae:	74 07                	je     c00029b7 <malloc_page+0x6f>
/work/x86_os_my/kernel/memory.c:178 (discriminator 1)
c00029b0:	b8 a0 7a 00 c0       	mov    $0xc0007aa0,%eax
c00029b5:	eb 05                	jmp    c00029bc <malloc_page+0x74>
/work/x86_os_my/kernel/memory.c:178 (discriminator 2)
c00029b7:	b8 60 7a 00 c0       	mov    $0xc0007a60,%eax
/work/x86_os_my/kernel/memory.c:178 (discriminator 4)
c00029bc:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:181 (discriminator 4)

	/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
	while (cnt-- > 0) {
c00029bf:	eb 37                	jmp    c00029f8 <malloc_page+0xb0>
/work/x86_os_my/kernel/memory.c:182
		void* page_phyaddr = palloc(mem_pool);
c00029c1:	83 ec 0c             	sub    $0xc,%esp
c00029c4:	ff 75 e8             	pushl  -0x18(%ebp)
c00029c7:	e8 17 fe ff ff       	call   c00027e3 <palloc>
c00029cc:	83 c4 10             	add    $0x10,%esp
c00029cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:183
		if (page_phyaddr == NULL) {  // 失败时要将曾经已申请的虚拟地址和物理页全部回滚，在将来完成内存回收时再补充
c00029d2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00029d6:	75 07                	jne    c00029df <malloc_page+0x97>
/work/x86_os_my/kernel/memory.c:184
			return NULL;
c00029d8:	b8 00 00 00 00       	mov    $0x0,%eax
c00029dd:	eb 29                	jmp    c0002a08 <malloc_page+0xc0>
/work/x86_os_my/kernel/memory.c:186
		}
		page_table_add((void*)vaddr, page_phyaddr); // 在页表中做映射 
c00029df:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00029e2:	83 ec 08             	sub    $0x8,%esp
c00029e5:	ff 75 e4             	pushl  -0x1c(%ebp)
c00029e8:	50                   	push   %eax
c00029e9:	e8 49 fe ff ff       	call   c0002837 <page_table_add>
c00029ee:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:187
		vaddr += PG_SIZE;		 // 下一个虚拟页
c00029f1:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:181

	uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;

	/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
	while (cnt-- > 0) {
c00029f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00029fb:	8d 50 ff             	lea    -0x1(%eax),%edx
c00029fe:	89 55 f0             	mov    %edx,-0x10(%ebp)
c0002a01:	85 c0                	test   %eax,%eax
c0002a03:	75 bc                	jne    c00029c1 <malloc_page+0x79>
/work/x86_os_my/kernel/memory.c:189
			return NULL;
		}
		page_table_add((void*)vaddr, page_phyaddr); // 在页表中做映射 
		vaddr += PG_SIZE;		 // 下一个虚拟页
	}
	return vaddr_start;
c0002a05:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/kernel/memory.c:190
}
c0002a08:	c9                   	leave  
c0002a09:	c3                   	ret    

c0002a0a <get_kernel_pages>:
get_kernel_pages():
/work/x86_os_my/kernel/memory.c:193

/* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */
void* get_kernel_pages(uint32_t pg_cnt) {
c0002a0a:	55                   	push   %ebp
c0002a0b:	89 e5                	mov    %esp,%ebp
c0002a0d:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:194
	lock_acquire(&kernel_pool.lock);
c0002a10:	83 ec 0c             	sub    $0xc,%esp
c0002a13:	68 b0 7a 00 c0       	push   $0xc0007ab0
c0002a18:	e8 c2 12 00 00       	call   c0003cdf <lock_acquire>
c0002a1d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:195
	void* vaddr =  malloc_page(PF_KERNEL, pg_cnt);
c0002a20:	83 ec 08             	sub    $0x8,%esp
c0002a23:	ff 75 08             	pushl  0x8(%ebp)
c0002a26:	6a 01                	push   $0x1
c0002a28:	e8 1b ff ff ff       	call   c0002948 <malloc_page>
c0002a2d:	83 c4 10             	add    $0x10,%esp
c0002a30:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:196
	if (vaddr != NULL) {
c0002a33:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002a37:	74 17                	je     c0002a50 <get_kernel_pages+0x46>
/work/x86_os_my/kernel/memory.c:197
		memset(vaddr, 0, pg_cnt * PG_SIZE);
c0002a39:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a3c:	c1 e0 0c             	shl    $0xc,%eax
c0002a3f:	83 ec 04             	sub    $0x4,%esp
c0002a42:	50                   	push   %eax
c0002a43:	6a 00                	push   $0x0
c0002a45:	ff 75 f4             	pushl  -0xc(%ebp)
c0002a48:	e8 3d 04 00 00       	call   c0002e8a <memset>
c0002a4d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:199
	}
	lock_release(&kernel_pool.lock);
c0002a50:	83 ec 0c             	sub    $0xc,%esp
c0002a53:	68 b0 7a 00 c0       	push   $0xc0007ab0
c0002a58:	e8 f9 12 00 00       	call   c0003d56 <lock_release>
c0002a5d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:200
	return vaddr;
c0002a60:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:201
}
c0002a63:	c9                   	leave  
c0002a64:	c3                   	ret    

c0002a65 <get_user_pages>:
get_user_pages():
/work/x86_os_my/kernel/memory.c:204

/* 在用户空间中申请4k内存,并返回其虚拟地址 */
void* get_user_pages(uint32_t pg_cnt) {
c0002a65:	55                   	push   %ebp
c0002a66:	89 e5                	mov    %esp,%ebp
c0002a68:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:205
	lock_acquire(&user_pool.lock);
c0002a6b:	83 ec 0c             	sub    $0xc,%esp
c0002a6e:	68 70 7a 00 c0       	push   $0xc0007a70
c0002a73:	e8 67 12 00 00       	call   c0003cdf <lock_acquire>
c0002a78:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:206
	void* vaddr = malloc_page(PF_USER, pg_cnt);
c0002a7b:	83 ec 08             	sub    $0x8,%esp
c0002a7e:	ff 75 08             	pushl  0x8(%ebp)
c0002a81:	6a 02                	push   $0x2
c0002a83:	e8 c0 fe ff ff       	call   c0002948 <malloc_page>
c0002a88:	83 c4 10             	add    $0x10,%esp
c0002a8b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:207
	if (vaddr != NULL) {
c0002a8e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002a92:	74 17                	je     c0002aab <get_user_pages+0x46>
/work/x86_os_my/kernel/memory.c:208
		memset(vaddr, 0, pg_cnt * PG_SIZE);
c0002a94:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a97:	c1 e0 0c             	shl    $0xc,%eax
c0002a9a:	83 ec 04             	sub    $0x4,%esp
c0002a9d:	50                   	push   %eax
c0002a9e:	6a 00                	push   $0x0
c0002aa0:	ff 75 f4             	pushl  -0xc(%ebp)
c0002aa3:	e8 e2 03 00 00       	call   c0002e8a <memset>
c0002aa8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:210
	}
	lock_release(&user_pool.lock);
c0002aab:	83 ec 0c             	sub    $0xc,%esp
c0002aae:	68 70 7a 00 c0       	push   $0xc0007a70
c0002ab3:	e8 9e 12 00 00       	call   c0003d56 <lock_release>
c0002ab8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:211
	return vaddr;
c0002abb:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:212
}
c0002abe:	c9                   	leave  
c0002abf:	c3                   	ret    

c0002ac0 <get_a_page>:
get_a_page():
/work/x86_os_my/kernel/memory.c:216

/* 将虚拟地址vaddr与pf池中的物理地址关联,仅支持一页空间分配
 * 功能是，可以指定虚拟地址的内存分配 */
void* get_a_page(enum pool_flags pf, uint32_t vaddr) {
c0002ac0:	55                   	push   %ebp
c0002ac1:	89 e5                	mov    %esp,%ebp
c0002ac3:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:217
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c0002ac6:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ac9:	83 e0 01             	and    $0x1,%eax
c0002acc:	85 c0                	test   %eax,%eax
c0002ace:	74 07                	je     c0002ad7 <get_a_page+0x17>
/work/x86_os_my/kernel/memory.c:217 (discriminator 1)
c0002ad0:	b8 a0 7a 00 c0       	mov    $0xc0007aa0,%eax
c0002ad5:	eb 05                	jmp    c0002adc <get_a_page+0x1c>
/work/x86_os_my/kernel/memory.c:217 (discriminator 2)
c0002ad7:	b8 60 7a 00 c0       	mov    $0xc0007a60,%eax
/work/x86_os_my/kernel/memory.c:217 (discriminator 4)
c0002adc:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:218 (discriminator 4)
	lock_acquire(&mem_pool->lock);
c0002adf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002ae2:	83 c0 10             	add    $0x10,%eax
c0002ae5:	83 ec 0c             	sub    $0xc,%esp
c0002ae8:	50                   	push   %eax
c0002ae9:	e8 f1 11 00 00       	call   c0003cdf <lock_acquire>
c0002aee:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:221 (discriminator 4)

	/* 先将虚拟地址对应的位图置1 */
	struct task_struct* cur = running_thread();
c0002af1:	e8 64 07 00 00       	call   c000325a <running_thread>
c0002af6:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:222 (discriminator 4)
	int32_t bit_idx = -1;
c0002af9:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:224 (discriminator 4)

	if (cur->pgdir != NULL && pf == PF_USER) {
c0002b00:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002b03:	8b 40 34             	mov    0x34(%eax),%eax
c0002b06:	85 c0                	test   %eax,%eax
c0002b08:	74 55                	je     c0002b5f <get_a_page+0x9f>
/work/x86_os_my/kernel/memory.c:224 (discriminator 1)
c0002b0a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0002b0e:	75 4f                	jne    c0002b5f <get_a_page+0x9f>
/work/x86_os_my/kernel/memory.c:226
		/* 若当前是用户进程申请用户内存,就修改用户进程自己的虚拟地址池的 位图 */
		bit_idx = (vaddr - cur->userprog_vaddr.vaddr_start) / PG_SIZE;
c0002b10:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002b13:	8b 40 40             	mov    0x40(%eax),%eax
c0002b16:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002b19:	29 c2                	sub    %eax,%edx
c0002b1b:	89 d0                	mov    %edx,%eax
c0002b1d:	c1 e8 0c             	shr    $0xc,%eax
c0002b20:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:227
		ASSERT(bit_idx > 0);
c0002b23:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002b27:	7f 1c                	jg     c0002b45 <get_a_page+0x85>
/work/x86_os_my/kernel/memory.c:227 (discriminator 1)
c0002b29:	68 23 51 00 c0       	push   $0xc0005123
c0002b2e:	68 74 52 00 c0       	push   $0xc0005274
c0002b33:	68 e3 00 00 00       	push   $0xe3
c0002b38:	68 d7 50 00 c0       	push   $0xc00050d7
c0002b3d:	e8 20 f8 ff ff       	call   c0002362 <panic_spin>
c0002b42:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:228
		bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx, 1);
c0002b45:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002b48:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002b4b:	83 c2 38             	add    $0x38,%edx
c0002b4e:	83 ec 04             	sub    $0x4,%esp
c0002b51:	6a 01                	push   $0x1
c0002b53:	50                   	push   %eax
c0002b54:	52                   	push   %edx
c0002b55:	e8 76 fa ff ff       	call   c00025d0 <bitmap_set>
c0002b5a:	83 c4 10             	add    $0x10,%esp
c0002b5d:	eb 78                	jmp    c0002bd7 <get_a_page+0x117>
/work/x86_os_my/kernel/memory.c:230

	} else if (cur->pgdir == NULL && pf == PF_KERNEL) {
c0002b5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002b62:	8b 40 34             	mov    0x34(%eax),%eax
c0002b65:	85 c0                	test   %eax,%eax
c0002b67:	75 52                	jne    c0002bbb <get_a_page+0xfb>
/work/x86_os_my/kernel/memory.c:230 (discriminator 1)
c0002b69:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0002b6d:	75 4c                	jne    c0002bbb <get_a_page+0xfb>
/work/x86_os_my/kernel/memory.c:232
		/* 如果是内核线程申请内核内存,就修改 kernel_vaddr */
		bit_idx = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
c0002b6f:	a1 94 7a 00 c0       	mov    0xc0007a94,%eax
c0002b74:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002b77:	29 c2                	sub    %eax,%edx
c0002b79:	89 d0                	mov    %edx,%eax
c0002b7b:	c1 e8 0c             	shr    $0xc,%eax
c0002b7e:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:233
		ASSERT(bit_idx > 0);
c0002b81:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002b85:	7f 1c                	jg     c0002ba3 <get_a_page+0xe3>
/work/x86_os_my/kernel/memory.c:233 (discriminator 1)
c0002b87:	68 23 51 00 c0       	push   $0xc0005123
c0002b8c:	68 74 52 00 c0       	push   $0xc0005274
c0002b91:	68 e9 00 00 00       	push   $0xe9
c0002b96:	68 d7 50 00 c0       	push   $0xc00050d7
c0002b9b:	e8 c2 f7 ff ff       	call   c0002362 <panic_spin>
c0002ba0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:234
		bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx, 1);
c0002ba3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002ba6:	83 ec 04             	sub    $0x4,%esp
c0002ba9:	6a 01                	push   $0x1
c0002bab:	50                   	push   %eax
c0002bac:	68 8c 7a 00 c0       	push   $0xc0007a8c
c0002bb1:	e8 1a fa ff ff       	call   c00025d0 <bitmap_set>
c0002bb6:	83 c4 10             	add    $0x10,%esp
c0002bb9:	eb 1c                	jmp    c0002bd7 <get_a_page+0x117>
/work/x86_os_my/kernel/memory.c:237

	} else {
		PANIC("get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page");
c0002bbb:	68 30 51 00 c0       	push   $0xc0005130
c0002bc0:	68 74 52 00 c0       	push   $0xc0005274
c0002bc5:	68 ed 00 00 00       	push   $0xed
c0002bca:	68 d7 50 00 c0       	push   $0xc00050d7
c0002bcf:	e8 8e f7 ff ff       	call   c0002362 <panic_spin>
c0002bd4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:240
	}

	void* page_phyaddr = palloc(mem_pool);
c0002bd7:	83 ec 0c             	sub    $0xc,%esp
c0002bda:	ff 75 f4             	pushl  -0xc(%ebp)
c0002bdd:	e8 01 fc ff ff       	call   c00027e3 <palloc>
c0002be2:	83 c4 10             	add    $0x10,%esp
c0002be5:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:241
	if (page_phyaddr == NULL) {
c0002be8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0002bec:	75 07                	jne    c0002bf5 <get_a_page+0x135>
/work/x86_os_my/kernel/memory.c:242
		return NULL;
c0002bee:	b8 00 00 00 00       	mov    $0x0,%eax
c0002bf3:	eb 27                	jmp    c0002c1c <get_a_page+0x15c>
/work/x86_os_my/kernel/memory.c:244
	}
	page_table_add((void*)vaddr, page_phyaddr);
c0002bf5:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002bf8:	83 ec 08             	sub    $0x8,%esp
c0002bfb:	ff 75 e8             	pushl  -0x18(%ebp)
c0002bfe:	50                   	push   %eax
c0002bff:	e8 33 fc ff ff       	call   c0002837 <page_table_add>
c0002c04:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:246
	
	lock_release(&mem_pool->lock);
c0002c07:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002c0a:	83 c0 10             	add    $0x10,%eax
c0002c0d:	83 ec 0c             	sub    $0xc,%esp
c0002c10:	50                   	push   %eax
c0002c11:	e8 40 11 00 00       	call   c0003d56 <lock_release>
c0002c16:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:247
	return (void*)vaddr;
c0002c19:	8b 45 0c             	mov    0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:248
}
c0002c1c:	c9                   	leave  
c0002c1d:	c3                   	ret    

c0002c1e <addr_v2p>:
addr_v2p():
/work/x86_os_my/kernel/memory.c:251

/* 得到虚拟地址映射到的物理地址 */
uint32_t addr_v2p(uint32_t vaddr) {
c0002c1e:	55                   	push   %ebp
c0002c1f:	89 e5                	mov    %esp,%ebp
c0002c21:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:252
	uint32_t* pte = pte_ptr(vaddr);
c0002c24:	ff 75 08             	pushl  0x8(%ebp)
c0002c27:	e8 6b fb ff ff       	call   c0002797 <pte_ptr>
c0002c2c:	83 c4 04             	add    $0x4,%esp
c0002c2f:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:256
	/* (*pte)的内容是 vaddr 所在 pte 的内容，也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的页表项属性，
	 * 因为页框都是自然页，低 12 位地址是 0，所以页表项 pte（和页目录项 pde）中只需要记录页框的高 20 位地址即可。
	 */
	return ((*pte & 0xfffff000) + (vaddr & 0x00000fff));
c0002c32:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002c35:	8b 00                	mov    (%eax),%eax
c0002c37:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002c3c:	89 c2                	mov    %eax,%edx
c0002c3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c41:	25 ff 0f 00 00       	and    $0xfff,%eax
c0002c46:	01 d0                	add    %edx,%eax
/work/x86_os_my/kernel/memory.c:257
}
c0002c48:	c9                   	leave  
c0002c49:	c3                   	ret    

c0002c4a <mem_pool_init>:
mem_pool_init():
/work/x86_os_my/kernel/memory.c:260

/* 初始化内存池 */
static void mem_pool_init(uint32_t all_mem) {
c0002c4a:	55                   	push   %ebp
c0002c4b:	89 e5                	mov    %esp,%ebp
c0002c4d:	83 ec 38             	sub    $0x38,%esp
/work/x86_os_my/kernel/memory.c:261
	put_str("   mem_pool_init start\n");
c0002c50:	83 ec 0c             	sub    $0xc,%esp
c0002c53:	68 84 51 00 c0       	push   $0xc0005184
c0002c58:	e8 93 f5 ff ff       	call   c00021f0 <put_str>
c0002c5d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:262
	uint32_t page_table_size = PG_SIZE * 256;		// 页表大小= 1页的页目录表+第0和第768个页目录项指向同一个页表+
c0002c60:	c7 45 f4 00 00 10 00 	movl   $0x100000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:264
													// 第769~1022个页目录项共指向254个页表,共256个页框
	uint32_t used_mem = page_table_size + 0x100000;	// 0x100000为低端1M内存
c0002c67:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002c6a:	05 00 00 10 00       	add    $0x100000,%eax
c0002c6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:265
	uint32_t free_mem = all_mem - used_mem;
c0002c72:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c75:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0002c78:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:266
	uint16_t all_free_pages = free_mem / PG_SIZE;	// 1页为4k,不管总内存是不是4k的倍数,
c0002c7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002c7e:	c1 e8 0c             	shr    $0xc,%eax
c0002c81:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
/work/x86_os_my/kernel/memory.c:268
													// 对于以页为单位的内存分配策略，不足1页的内存不用考虑了。
	uint16_t kernel_free_pages = all_free_pages / 2;
c0002c85:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c0002c89:	66 d1 e8             	shr    %ax
c0002c8c:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:269
	uint16_t user_free_pages = all_free_pages - kernel_free_pages;
c0002c90:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c0002c94:	66 2b 45 e8          	sub    -0x18(%ebp),%ax
c0002c98:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
/work/x86_os_my/kernel/memory.c:273

	/* 为简化位图操作，余数不处理，坏处是这样做会丢内存。
	好处是不用做内存的越界检查,因为位图表示的内存少于实际物理内存*/
	uint32_t kbm_length = kernel_free_pages / 8;	// Kernel BitMap的长度,位图中的一位表示一页,以字节为单位
c0002c9c:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0002ca0:	66 c1 e8 03          	shr    $0x3,%ax
c0002ca4:	0f b7 c0             	movzwl %ax,%eax
c0002ca7:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/kernel/memory.c:274
	uint32_t ubm_length = user_free_pages / 8;		// User BitMap的长度.
c0002caa:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c0002cae:	66 c1 e8 03          	shr    $0x3,%ax
c0002cb2:	0f b7 c0             	movzwl %ax,%eax
c0002cb5:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/kernel/memory.c:276

	uint32_t kp_start = used_mem;								// Kernel Pool start,内核内存池的起始地址
c0002cb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002cbb:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/kernel/memory.c:277
	uint32_t up_start = kp_start + kernel_free_pages * PG_SIZE;	// User Pool start,用户内存池的起始地址
c0002cbe:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0002cc2:	c1 e0 0c             	shl    $0xc,%eax
c0002cc5:	89 c2                	mov    %eax,%edx
c0002cc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0002cca:	01 d0                	add    %edx,%eax
c0002ccc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:279

	kernel_pool.phy_addr_start = kp_start;
c0002ccf:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0002cd2:	a3 a8 7a 00 c0       	mov    %eax,0xc0007aa8
/work/x86_os_my/kernel/memory.c:280
	user_pool.phy_addr_start   = up_start;
c0002cd7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002cda:	a3 68 7a 00 c0       	mov    %eax,0xc0007a68
/work/x86_os_my/kernel/memory.c:282

	kernel_pool.pool_size = kernel_free_pages * PG_SIZE;
c0002cdf:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0002ce3:	c1 e0 0c             	shl    $0xc,%eax
c0002ce6:	a3 ac 7a 00 c0       	mov    %eax,0xc0007aac
/work/x86_os_my/kernel/memory.c:283
	user_pool.pool_size	 = user_free_pages * PG_SIZE;
c0002ceb:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c0002cef:	c1 e0 0c             	shl    $0xc,%eax
c0002cf2:	a3 6c 7a 00 c0       	mov    %eax,0xc0007a6c
/work/x86_os_my/kernel/memory.c:285

	kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;
c0002cf7:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002cfa:	a3 a0 7a 00 c0       	mov    %eax,0xc0007aa0
/work/x86_os_my/kernel/memory.c:286
	user_pool.pool_bitmap.btmp_bytes_len	  = ubm_length;
c0002cff:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0002d02:	a3 60 7a 00 c0       	mov    %eax,0xc0007a60
/work/x86_os_my/kernel/memory.c:295
	*	而我们需要根据总内存大小在运行时，计算出位图的数组需要多少字节。
	*   所以改为指定一块内存来生成位图.
	*   ************************************************/
	// 内核使用的最高地址是0xc009f000,这是主线程的栈地址.(内核的大小预计为70K左右)
	// 32M内存占用的位图是2k.内核内存池的位图先定在MEM_BITMAP_BASE(0xc009a000)处.
	kernel_pool.pool_bitmap.bits = (void*)MEM_BITMAP_BASE;
c0002d07:	c7 05 a4 7a 00 c0 00 	movl   $0xc009a000,0xc0007aa4
c0002d0e:	a0 09 c0 
/work/x86_os_my/kernel/memory.c:297
	/* 用户内存池的位图紧跟在内核内存池位图之后 */
	user_pool.pool_bitmap.bits = (void*)(MEM_BITMAP_BASE + kbm_length);
c0002d11:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002d14:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c0002d19:	a3 64 7a 00 c0       	mov    %eax,0xc0007a64
/work/x86_os_my/kernel/memory.c:300
	
	/******************** 输出内存池信息 **********************/
	put_str("      kernel_pool_bitmap_start:");put_int((int)kernel_pool.pool_bitmap.bits);
c0002d1e:	83 ec 0c             	sub    $0xc,%esp
c0002d21:	68 9c 51 00 c0       	push   $0xc000519c
c0002d26:	e8 c5 f4 ff ff       	call   c00021f0 <put_str>
c0002d2b:	83 c4 10             	add    $0x10,%esp
c0002d2e:	a1 a4 7a 00 c0       	mov    0xc0007aa4,%eax
c0002d33:	83 ec 0c             	sub    $0xc,%esp
c0002d36:	50                   	push   %eax
c0002d37:	e8 9f f5 ff ff       	call   c00022db <put_int>
c0002d3c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:301
	put_str(" kernel_pool_phy_addr_start:");put_int(kernel_pool.phy_addr_start);
c0002d3f:	83 ec 0c             	sub    $0xc,%esp
c0002d42:	68 bc 51 00 c0       	push   $0xc00051bc
c0002d47:	e8 a4 f4 ff ff       	call   c00021f0 <put_str>
c0002d4c:	83 c4 10             	add    $0x10,%esp
c0002d4f:	a1 a8 7a 00 c0       	mov    0xc0007aa8,%eax
c0002d54:	83 ec 0c             	sub    $0xc,%esp
c0002d57:	50                   	push   %eax
c0002d58:	e8 7e f5 ff ff       	call   c00022db <put_int>
c0002d5d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:302
	put_str("\n");
c0002d60:	83 ec 0c             	sub    $0xc,%esp
c0002d63:	68 d9 51 00 c0       	push   $0xc00051d9
c0002d68:	e8 83 f4 ff ff       	call   c00021f0 <put_str>
c0002d6d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:303
	put_str("      user_pool_bitmap_start:");put_int((int)user_pool.pool_bitmap.bits);
c0002d70:	83 ec 0c             	sub    $0xc,%esp
c0002d73:	68 db 51 00 c0       	push   $0xc00051db
c0002d78:	e8 73 f4 ff ff       	call   c00021f0 <put_str>
c0002d7d:	83 c4 10             	add    $0x10,%esp
c0002d80:	a1 64 7a 00 c0       	mov    0xc0007a64,%eax
c0002d85:	83 ec 0c             	sub    $0xc,%esp
c0002d88:	50                   	push   %eax
c0002d89:	e8 4d f5 ff ff       	call   c00022db <put_int>
c0002d8e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:304
	put_str(" user_pool_phy_addr_start:");put_int(user_pool.phy_addr_start);
c0002d91:	83 ec 0c             	sub    $0xc,%esp
c0002d94:	68 f9 51 00 c0       	push   $0xc00051f9
c0002d99:	e8 52 f4 ff ff       	call   c00021f0 <put_str>
c0002d9e:	83 c4 10             	add    $0x10,%esp
c0002da1:	a1 68 7a 00 c0       	mov    0xc0007a68,%eax
c0002da6:	83 ec 0c             	sub    $0xc,%esp
c0002da9:	50                   	push   %eax
c0002daa:	e8 2c f5 ff ff       	call   c00022db <put_int>
c0002daf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:305
	put_str("\n");
c0002db2:	83 ec 0c             	sub    $0xc,%esp
c0002db5:	68 d9 51 00 c0       	push   $0xc00051d9
c0002dba:	e8 31 f4 ff ff       	call   c00021f0 <put_str>
c0002dbf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:308

	/* 将位图置0*/
	bitmap_init(&kernel_pool.pool_bitmap);
c0002dc2:	83 ec 0c             	sub    $0xc,%esp
c0002dc5:	68 a0 7a 00 c0       	push   $0xc0007aa0
c0002dca:	e8 69 f6 ff ff       	call   c0002438 <bitmap_init>
c0002dcf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:309
	bitmap_init(&user_pool.pool_bitmap);
c0002dd2:	83 ec 0c             	sub    $0xc,%esp
c0002dd5:	68 60 7a 00 c0       	push   $0xc0007a60
c0002dda:	e8 59 f6 ff ff       	call   c0002438 <bitmap_init>
c0002ddf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:311

	lock_init(&kernel_pool.lock);
c0002de2:	83 ec 0c             	sub    $0xc,%esp
c0002de5:	68 b0 7a 00 c0       	push   $0xc0007ab0
c0002dea:	e8 16 0d 00 00       	call   c0003b05 <lock_init>
c0002def:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:312
	lock_init(&user_pool.lock);
c0002df2:	83 ec 0c             	sub    $0xc,%esp
c0002df5:	68 70 7a 00 c0       	push   $0xc0007a70
c0002dfa:	e8 06 0d 00 00       	call   c0003b05 <lock_init>
c0002dff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:316
	
	/* 下面初始化内核虚拟地址的位图(bp_len + bits数组),按实际物理内存大小生成数组。*/
	// 用于维护内核堆的虚拟地址,所以要和内核内存池大小一致
	kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;
c0002e02:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002e05:	a3 8c 7a 00 c0       	mov    %eax,0xc0007a8c
/work/x86_os_my/kernel/memory.c:318
	/* 位图的数组指向一块未使用的内存,目前定位在内核内存池和用户内存池之外*/
	kernel_vaddr.vaddr_bitmap.bits = (void*)(MEM_BITMAP_BASE + kbm_length + ubm_length);
c0002e0a:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0002e0d:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0002e10:	01 d0                	add    %edx,%eax
c0002e12:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c0002e17:	a3 90 7a 00 c0       	mov    %eax,0xc0007a90
/work/x86_os_my/kernel/memory.c:320

	kernel_vaddr.vaddr_start = K_HEAP_START;
c0002e1c:	c7 05 94 7a 00 c0 00 	movl   $0xc0100000,0xc0007a94
c0002e23:	00 10 c0 
/work/x86_os_my/kernel/memory.c:321
	bitmap_init(&kernel_vaddr.vaddr_bitmap);
c0002e26:	83 ec 0c             	sub    $0xc,%esp
c0002e29:	68 8c 7a 00 c0       	push   $0xc0007a8c
c0002e2e:	e8 05 f6 ff ff       	call   c0002438 <bitmap_init>
c0002e33:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:322
	put_str("   mem_pool_init done\n");
c0002e36:	83 ec 0c             	sub    $0xc,%esp
c0002e39:	68 14 52 00 c0       	push   $0xc0005214
c0002e3e:	e8 ad f3 ff ff       	call   c00021f0 <put_str>
c0002e43:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:323
}
c0002e46:	90                   	nop
c0002e47:	c9                   	leave  
c0002e48:	c3                   	ret    

c0002e49 <mem_init>:
mem_init():
/work/x86_os_my/kernel/memory.c:326

/* 内存管理部分初始化入口 */
void mem_init() {
c0002e49:	55                   	push   %ebp
c0002e4a:	89 e5                	mov    %esp,%ebp
c0002e4c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:327
	put_str("mem_init start\n");
c0002e4f:	83 ec 0c             	sub    $0xc,%esp
c0002e52:	68 2b 52 00 c0       	push   $0xc000522b
c0002e57:	e8 94 f3 ff ff       	call   c00021f0 <put_str>
c0002e5c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:328
	uint32_t mem_bytes_total = (*(uint32_t*)(0xb00));	//内存总数在汇编中获取，放到了地址0xb00处。
c0002e5f:	b8 00 0b 00 00       	mov    $0xb00,%eax
c0002e64:	8b 00                	mov    (%eax),%eax
c0002e66:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:329
	mem_pool_init(mem_bytes_total);	  // 初始化内存池
c0002e69:	83 ec 0c             	sub    $0xc,%esp
c0002e6c:	ff 75 f4             	pushl  -0xc(%ebp)
c0002e6f:	e8 d6 fd ff ff       	call   c0002c4a <mem_pool_init>
c0002e74:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:330
	put_str("mem_init done\n");
c0002e77:	83 ec 0c             	sub    $0xc,%esp
c0002e7a:	68 3b 52 00 c0       	push   $0xc000523b
c0002e7f:	e8 6c f3 ff ff       	call   c00021f0 <put_str>
c0002e84:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:331
}
c0002e87:	90                   	nop
c0002e88:	c9                   	leave  
c0002e89:	c3                   	ret    

c0002e8a <memset>:
memset():
/work/x86_os_my/lib/string.c:6
#include "string.h"
#include "global.h"
#include "debug.h"

/* 将dst_起始的size个字节置为value */
void memset(void* dst_, uint8_t value, uint32_t size) {
c0002e8a:	55                   	push   %ebp
c0002e8b:	89 e5                	mov    %esp,%ebp
c0002e8d:	83 ec 28             	sub    $0x28,%esp
c0002e90:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002e93:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:7
   ASSERT(dst_ != NULL);
c0002e96:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002e9a:	75 19                	jne    c0002eb5 <memset+0x2b>
/work/x86_os_my/lib/string.c:7 (discriminator 1)
c0002e9c:	68 80 52 00 c0       	push   $0xc0005280
c0002ea1:	68 f4 52 00 c0       	push   $0xc00052f4
c0002ea6:	6a 07                	push   $0x7
c0002ea8:	68 8d 52 00 c0       	push   $0xc000528d
c0002ead:	e8 b0 f4 ff ff       	call   c0002362 <panic_spin>
c0002eb2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:8
   uint8_t* dst = (uint8_t*)dst_;
c0002eb5:	8b 45 08             	mov    0x8(%ebp),%eax
c0002eb8:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:9
   while (size-- > 0)
c0002ebb:	eb 0f                	jmp    c0002ecc <memset+0x42>
/work/x86_os_my/lib/string.c:10
      *dst++ = value;
c0002ebd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002ec0:	8d 50 01             	lea    0x1(%eax),%edx
c0002ec3:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0002ec6:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c0002eca:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/string.c:9

/* 将dst_起始的size个字节置为value */
void memset(void* dst_, uint8_t value, uint32_t size) {
   ASSERT(dst_ != NULL);
   uint8_t* dst = (uint8_t*)dst_;
   while (size-- > 0)
c0002ecc:	8b 45 10             	mov    0x10(%ebp),%eax
c0002ecf:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002ed2:	89 55 10             	mov    %edx,0x10(%ebp)
c0002ed5:	85 c0                	test   %eax,%eax
c0002ed7:	75 e4                	jne    c0002ebd <memset+0x33>
/work/x86_os_my/lib/string.c:11
      *dst++ = value;
}
c0002ed9:	90                   	nop
c0002eda:	c9                   	leave  
c0002edb:	c3                   	ret    

c0002edc <memcpy>:
memcpy():
/work/x86_os_my/lib/string.c:14

/* 将src_起始的size个字节复制到dst_ */
void memcpy(void* dst_, const void* src_, uint32_t size) {
c0002edc:	55                   	push   %ebp
c0002edd:	89 e5                	mov    %esp,%ebp
c0002edf:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:15
   ASSERT(dst_ != NULL && src_ != NULL);
c0002ee2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002ee6:	74 06                	je     c0002eee <memcpy+0x12>
/work/x86_os_my/lib/string.c:15 (discriminator 1)
c0002ee8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002eec:	75 19                	jne    c0002f07 <memcpy+0x2b>
/work/x86_os_my/lib/string.c:15 (discriminator 3)
c0002eee:	68 9a 52 00 c0       	push   $0xc000529a
c0002ef3:	68 fc 52 00 c0       	push   $0xc00052fc
c0002ef8:	6a 0f                	push   $0xf
c0002efa:	68 8d 52 00 c0       	push   $0xc000528d
c0002eff:	e8 5e f4 ff ff       	call   c0002362 <panic_spin>
c0002f04:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:16
   uint8_t* dst = dst_;
c0002f07:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:17
   const uint8_t* src = src_;
c0002f0d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002f10:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:18
   while (size-- > 0)
c0002f13:	eb 17                	jmp    c0002f2c <memcpy+0x50>
/work/x86_os_my/lib/string.c:19
      *dst++ = *src++;
c0002f15:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002f18:	8d 50 01             	lea    0x1(%eax),%edx
c0002f1b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0002f1e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002f21:	8d 4a 01             	lea    0x1(%edx),%ecx
c0002f24:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0002f27:	0f b6 12             	movzbl (%edx),%edx
c0002f2a:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/string.c:18
/* 将src_起始的size个字节复制到dst_ */
void memcpy(void* dst_, const void* src_, uint32_t size) {
   ASSERT(dst_ != NULL && src_ != NULL);
   uint8_t* dst = dst_;
   const uint8_t* src = src_;
   while (size-- > 0)
c0002f2c:	8b 45 10             	mov    0x10(%ebp),%eax
c0002f2f:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002f32:	89 55 10             	mov    %edx,0x10(%ebp)
c0002f35:	85 c0                	test   %eax,%eax
c0002f37:	75 dc                	jne    c0002f15 <memcpy+0x39>
/work/x86_os_my/lib/string.c:20
      *dst++ = *src++;
}
c0002f39:	90                   	nop
c0002f3a:	c9                   	leave  
c0002f3b:	c3                   	ret    

c0002f3c <memcmp>:
memcmp():
/work/x86_os_my/lib/string.c:23

/* 连续比较以地址a_和地址b_开头的size个字节,若相等则返回0,若a_大于b_返回+1,否则返回-1 */
int memcmp(const void* a_, const void* b_, uint32_t size) {
c0002f3c:	55                   	push   %ebp
c0002f3d:	89 e5                	mov    %esp,%ebp
c0002f3f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:24
   const char* a = a_;
c0002f42:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f45:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:25
   const char* b = b_;
c0002f48:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002f4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:26
   ASSERT(a != NULL || b != NULL);
c0002f4e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002f52:	75 57                	jne    c0002fab <memcmp+0x6f>
/work/x86_os_my/lib/string.c:26 (discriminator 1)
c0002f54:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0002f58:	75 51                	jne    c0002fab <memcmp+0x6f>
/work/x86_os_my/lib/string.c:26 (discriminator 2)
c0002f5a:	68 b7 52 00 c0       	push   $0xc00052b7
c0002f5f:	68 04 53 00 c0       	push   $0xc0005304
c0002f64:	6a 1a                	push   $0x1a
c0002f66:	68 8d 52 00 c0       	push   $0xc000528d
c0002f6b:	e8 f2 f3 ff ff       	call   c0002362 <panic_spin>
c0002f70:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:27 (discriminator 2)
   while (size-- > 0) {
c0002f73:	eb 36                	jmp    c0002fab <memcmp+0x6f>
/work/x86_os_my/lib/string.c:28
      if(*a != *b) {
c0002f75:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002f78:	0f b6 10             	movzbl (%eax),%edx
c0002f7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002f7e:	0f b6 00             	movzbl (%eax),%eax
c0002f81:	38 c2                	cmp    %al,%dl
c0002f83:	74 1e                	je     c0002fa3 <memcmp+0x67>
/work/x86_os_my/lib/string.c:29
	 return *a > *b ? 1 : -1; 
c0002f85:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002f88:	0f b6 10             	movzbl (%eax),%edx
c0002f8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002f8e:	0f b6 00             	movzbl (%eax),%eax
c0002f91:	38 c2                	cmp    %al,%dl
c0002f93:	7e 07                	jle    c0002f9c <memcmp+0x60>
/work/x86_os_my/lib/string.c:29 (discriminator 1)
c0002f95:	b8 01 00 00 00       	mov    $0x1,%eax
c0002f9a:	eb 21                	jmp    c0002fbd <memcmp+0x81>
/work/x86_os_my/lib/string.c:29 (discriminator 2)
c0002f9c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002fa1:	eb 1a                	jmp    c0002fbd <memcmp+0x81>
/work/x86_os_my/lib/string.c:31
      }
      a++;
c0002fa3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:32
      b++;
c0002fa7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/string.c:27
/* 连续比较以地址a_和地址b_开头的size个字节,若相等则返回0,若a_大于b_返回+1,否则返回-1 */
int memcmp(const void* a_, const void* b_, uint32_t size) {
   const char* a = a_;
   const char* b = b_;
   ASSERT(a != NULL || b != NULL);
   while (size-- > 0) {
c0002fab:	8b 45 10             	mov    0x10(%ebp),%eax
c0002fae:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002fb1:	89 55 10             	mov    %edx,0x10(%ebp)
c0002fb4:	85 c0                	test   %eax,%eax
c0002fb6:	75 bd                	jne    c0002f75 <memcmp+0x39>
/work/x86_os_my/lib/string.c:34
	 return *a > *b ? 1 : -1; 
      }
      a++;
      b++;
   }
   return 0;
c0002fb8:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/string.c:35
}
c0002fbd:	c9                   	leave  
c0002fbe:	c3                   	ret    

c0002fbf <strcpy>:
strcpy():
/work/x86_os_my/lib/string.c:38

/* 将字符串从src_复制到dst_ */
char* strcpy(char* dst_, const char* src_) {
c0002fbf:	55                   	push   %ebp
c0002fc0:	89 e5                	mov    %esp,%ebp
c0002fc2:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:39
   ASSERT(dst_ != NULL && src_ != NULL);
c0002fc5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002fc9:	74 06                	je     c0002fd1 <strcpy+0x12>
/work/x86_os_my/lib/string.c:39 (discriminator 1)
c0002fcb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002fcf:	75 19                	jne    c0002fea <strcpy+0x2b>
/work/x86_os_my/lib/string.c:39 (discriminator 3)
c0002fd1:	68 9a 52 00 c0       	push   $0xc000529a
c0002fd6:	68 0c 53 00 c0       	push   $0xc000530c
c0002fdb:	6a 27                	push   $0x27
c0002fdd:	68 8d 52 00 c0       	push   $0xc000528d
c0002fe2:	e8 7b f3 ff ff       	call   c0002362 <panic_spin>
c0002fe7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:40
   char* r = dst_;		       // 用来返回目的字符串起始地址
c0002fea:	8b 45 08             	mov    0x8(%ebp),%eax
c0002fed:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:41
   while((*dst_++ = *src_++));
c0002ff0:	90                   	nop
/work/x86_os_my/lib/string.c:41 (discriminator 1)
c0002ff1:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ff4:	8d 50 01             	lea    0x1(%eax),%edx
c0002ff7:	89 55 08             	mov    %edx,0x8(%ebp)
c0002ffa:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002ffd:	8d 4a 01             	lea    0x1(%edx),%ecx
c0003000:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c0003003:	0f b6 12             	movzbl (%edx),%edx
c0003006:	88 10                	mov    %dl,(%eax)
c0003008:	0f b6 00             	movzbl (%eax),%eax
c000300b:	84 c0                	test   %al,%al
c000300d:	75 e2                	jne    c0002ff1 <strcpy+0x32>
/work/x86_os_my/lib/string.c:42
   return r;
c000300f:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:43
}
c0003012:	c9                   	leave  
c0003013:	c3                   	ret    

c0003014 <strlen>:
strlen():
/work/x86_os_my/lib/string.c:46

/* 返回字符串长度 */
uint32_t strlen(const char* str) {
c0003014:	55                   	push   %ebp
c0003015:	89 e5                	mov    %esp,%ebp
c0003017:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:47
   ASSERT(str != NULL);
c000301a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000301e:	75 19                	jne    c0003039 <strlen+0x25>
/work/x86_os_my/lib/string.c:47 (discriminator 1)
c0003020:	68 ce 52 00 c0       	push   $0xc00052ce
c0003025:	68 14 53 00 c0       	push   $0xc0005314
c000302a:	6a 2f                	push   $0x2f
c000302c:	68 8d 52 00 c0       	push   $0xc000528d
c0003031:	e8 2c f3 ff ff       	call   c0002362 <panic_spin>
c0003036:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:48
   const char* p = str;
c0003039:	8b 45 08             	mov    0x8(%ebp),%eax
c000303c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:49
   while(*p++);
c000303f:	90                   	nop
/work/x86_os_my/lib/string.c:49 (discriminator 1)
c0003040:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003043:	8d 50 01             	lea    0x1(%eax),%edx
c0003046:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003049:	0f b6 00             	movzbl (%eax),%eax
c000304c:	84 c0                	test   %al,%al
c000304e:	75 f0                	jne    c0003040 <strlen+0x2c>
/work/x86_os_my/lib/string.c:50
   return (p - str - 1);
c0003050:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0003053:	8b 45 08             	mov    0x8(%ebp),%eax
c0003056:	29 c2                	sub    %eax,%edx
c0003058:	89 d0                	mov    %edx,%eax
c000305a:	83 e8 01             	sub    $0x1,%eax
/work/x86_os_my/lib/string.c:51
}
c000305d:	c9                   	leave  
c000305e:	c3                   	ret    

c000305f <strcmp>:
strcmp():
/work/x86_os_my/lib/string.c:54

/* 比较两个字符串,若a_中的字符大于b_中的字符返回1,相等时返回0,否则返回-1. */
int8_t strcmp (const char* a, const char* b) {
c000305f:	55                   	push   %ebp
c0003060:	89 e5                	mov    %esp,%ebp
c0003062:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/string.c:55
   ASSERT(a != NULL && b != NULL);
c0003065:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003069:	74 06                	je     c0003071 <strcmp+0x12>
/work/x86_os_my/lib/string.c:55 (discriminator 1)
c000306b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c000306f:	75 19                	jne    c000308a <strcmp+0x2b>
/work/x86_os_my/lib/string.c:55 (discriminator 3)
c0003071:	68 da 52 00 c0       	push   $0xc00052da
c0003076:	68 1c 53 00 c0       	push   $0xc000531c
c000307b:	6a 37                	push   $0x37
c000307d:	68 8d 52 00 c0       	push   $0xc000528d
c0003082:	e8 db f2 ff ff       	call   c0002362 <panic_spin>
c0003087:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:56 (discriminator 1)
   while (*a != 0 && *a == *b) {
c000308a:	eb 08                	jmp    c0003094 <strcmp+0x35>
/work/x86_os_my/lib/string.c:57
      a++;
c000308c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:58
      b++;
c0003090:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
/work/x86_os_my/lib/string.c:56
}

/* 比较两个字符串,若a_中的字符大于b_中的字符返回1,相等时返回0,否则返回-1. */
int8_t strcmp (const char* a, const char* b) {
   ASSERT(a != NULL && b != NULL);
   while (*a != 0 && *a == *b) {
c0003094:	8b 45 08             	mov    0x8(%ebp),%eax
c0003097:	0f b6 00             	movzbl (%eax),%eax
c000309a:	84 c0                	test   %al,%al
c000309c:	74 10                	je     c00030ae <strcmp+0x4f>
/work/x86_os_my/lib/string.c:56 (discriminator 1)
c000309e:	8b 45 08             	mov    0x8(%ebp),%eax
c00030a1:	0f b6 10             	movzbl (%eax),%edx
c00030a4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00030a7:	0f b6 00             	movzbl (%eax),%eax
c00030aa:	38 c2                	cmp    %al,%dl
c00030ac:	74 de                	je     c000308c <strcmp+0x2d>
/work/x86_os_my/lib/string.c:62
      a++;
      b++;
   }
/* 如果*a小于*b就返回-1,否则就属于*a大于等于*b的情况。在后面的布尔表达式"*a > *b"中,
 * 若*a大于*b,表达式就等于1,否则就表达式不成立,也就是布尔值为0,恰恰表示*a等于*b */
   return *a < *b ? -1 : *a > *b;
c00030ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00030b1:	0f b6 10             	movzbl (%eax),%edx
c00030b4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00030b7:	0f b6 00             	movzbl (%eax),%eax
c00030ba:	38 c2                	cmp    %al,%dl
c00030bc:	7c 13                	jl     c00030d1 <strcmp+0x72>
/work/x86_os_my/lib/string.c:62 (discriminator 1)
c00030be:	8b 45 08             	mov    0x8(%ebp),%eax
c00030c1:	0f b6 10             	movzbl (%eax),%edx
c00030c4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00030c7:	0f b6 00             	movzbl (%eax),%eax
c00030ca:	38 c2                	cmp    %al,%dl
c00030cc:	0f 9f c0             	setg   %al
c00030cf:	eb 05                	jmp    c00030d6 <strcmp+0x77>
/work/x86_os_my/lib/string.c:62 (discriminator 2)
c00030d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/lib/string.c:63 (discriminator 5)
}
c00030d6:	c9                   	leave  
c00030d7:	c3                   	ret    

c00030d8 <strchr>:
strchr():
/work/x86_os_my/lib/string.c:66

/* 从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strchr(const char* str, const uint8_t ch) {
c00030d8:	55                   	push   %ebp
c00030d9:	89 e5                	mov    %esp,%ebp
c00030db:	83 ec 18             	sub    $0x18,%esp
c00030de:	8b 45 0c             	mov    0xc(%ebp),%eax
c00030e1:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/lib/string.c:67
   ASSERT(str != NULL);
c00030e4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00030e8:	75 35                	jne    c000311f <strchr+0x47>
/work/x86_os_my/lib/string.c:67 (discriminator 1)
c00030ea:	68 ce 52 00 c0       	push   $0xc00052ce
c00030ef:	68 24 53 00 c0       	push   $0xc0005324
c00030f4:	6a 43                	push   $0x43
c00030f6:	68 8d 52 00 c0       	push   $0xc000528d
c00030fb:	e8 62 f2 ff ff       	call   c0002362 <panic_spin>
c0003100:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:68 (discriminator 1)
   while (*str != 0) {
c0003103:	eb 1a                	jmp    c000311f <strchr+0x47>
/work/x86_os_my/lib/string.c:69
      if (*str == ch) {
c0003105:	8b 45 08             	mov    0x8(%ebp),%eax
c0003108:	0f b6 00             	movzbl (%eax),%eax
c000310b:	0f be d0             	movsbl %al,%edx
c000310e:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0003112:	39 c2                	cmp    %eax,%edx
c0003114:	75 05                	jne    c000311b <strchr+0x43>
/work/x86_os_my/lib/string.c:70
	 return (char*)str;	    // 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.
c0003116:	8b 45 08             	mov    0x8(%ebp),%eax
c0003119:	eb 13                	jmp    c000312e <strchr+0x56>
/work/x86_os_my/lib/string.c:72
      }
      str++;
c000311b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:68
}

/* 从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strchr(const char* str, const uint8_t ch) {
   ASSERT(str != NULL);
   while (*str != 0) {
c000311f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003122:	0f b6 00             	movzbl (%eax),%eax
c0003125:	84 c0                	test   %al,%al
c0003127:	75 dc                	jne    c0003105 <strchr+0x2d>
/work/x86_os_my/lib/string.c:74
      if (*str == ch) {
	 return (char*)str;	    // 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.
      }
      str++;
   }
   return NULL;
c0003129:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/string.c:75
}
c000312e:	c9                   	leave  
c000312f:	c3                   	ret    

c0003130 <strrchr>:
strrchr():
/work/x86_os_my/lib/string.c:78

/* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strrchr(const char* str, const uint8_t ch) {
c0003130:	55                   	push   %ebp
c0003131:	89 e5                	mov    %esp,%ebp
c0003133:	83 ec 28             	sub    $0x28,%esp
c0003136:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003139:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:79
   ASSERT(str != NULL);
c000313c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003140:	75 19                	jne    c000315b <strrchr+0x2b>
/work/x86_os_my/lib/string.c:79 (discriminator 1)
c0003142:	68 ce 52 00 c0       	push   $0xc00052ce
c0003147:	68 2c 53 00 c0       	push   $0xc000532c
c000314c:	6a 4f                	push   $0x4f
c000314e:	68 8d 52 00 c0       	push   $0xc000528d
c0003153:	e8 0a f2 ff ff       	call   c0002362 <panic_spin>
c0003158:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:80
   const char* last_char = NULL;
c000315b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/string.c:82
   /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/
   while (*str != 0) {
c0003162:	eb 1b                	jmp    c000317f <strrchr+0x4f>
/work/x86_os_my/lib/string.c:83
      if (*str == ch) {
c0003164:	8b 45 08             	mov    0x8(%ebp),%eax
c0003167:	0f b6 00             	movzbl (%eax),%eax
c000316a:	0f be d0             	movsbl %al,%edx
c000316d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0003171:	39 c2                	cmp    %eax,%edx
c0003173:	75 06                	jne    c000317b <strrchr+0x4b>
/work/x86_os_my/lib/string.c:84
	 last_char = str;
c0003175:	8b 45 08             	mov    0x8(%ebp),%eax
c0003178:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:86
      }
      str++;
c000317b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:82
/* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strrchr(const char* str, const uint8_t ch) {
   ASSERT(str != NULL);
   const char* last_char = NULL;
   /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/
   while (*str != 0) {
c000317f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003182:	0f b6 00             	movzbl (%eax),%eax
c0003185:	84 c0                	test   %al,%al
c0003187:	75 db                	jne    c0003164 <strrchr+0x34>
/work/x86_os_my/lib/string.c:88
      if (*str == ch) {
	 last_char = str;
      }
      str++;
   }
   return (char*)last_char;
c0003189:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:89
}
c000318c:	c9                   	leave  
c000318d:	c3                   	ret    

c000318e <strcat>:
strcat():
/work/x86_os_my/lib/string.c:92

/* 将字符串src_拼接到dst_后,将回拼接的串地址 */
char* strcat(char* dst_, const char* src_) {
c000318e:	55                   	push   %ebp
c000318f:	89 e5                	mov    %esp,%ebp
c0003191:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:93
   ASSERT(dst_ != NULL && src_ != NULL);
c0003194:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003198:	74 06                	je     c00031a0 <strcat+0x12>
/work/x86_os_my/lib/string.c:93 (discriminator 1)
c000319a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c000319e:	75 19                	jne    c00031b9 <strcat+0x2b>
/work/x86_os_my/lib/string.c:93 (discriminator 3)
c00031a0:	68 9a 52 00 c0       	push   $0xc000529a
c00031a5:	68 34 53 00 c0       	push   $0xc0005334
c00031aa:	6a 5d                	push   $0x5d
c00031ac:	68 8d 52 00 c0       	push   $0xc000528d
c00031b1:	e8 ac f1 ff ff       	call   c0002362 <panic_spin>
c00031b6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:94
   char* str = dst_;
c00031b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00031bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:95
   while (*str++);
c00031bf:	90                   	nop
/work/x86_os_my/lib/string.c:95 (discriminator 1)
c00031c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00031c3:	8d 50 01             	lea    0x1(%eax),%edx
c00031c6:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00031c9:	0f b6 00             	movzbl (%eax),%eax
c00031cc:	84 c0                	test   %al,%al
c00031ce:	75 f0                	jne    c00031c0 <strcat+0x32>
/work/x86_os_my/lib/string.c:96
   --str;      // 别看错了，--str是独立的一句，并不是while的循环体
c00031d0:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:97
   while((*str++ = *src_++));	 // 当*str被赋值为0时,此时表达式不成立,正好添加了字符串结尾的0.
c00031d4:	90                   	nop
/work/x86_os_my/lib/string.c:97 (discriminator 1)
c00031d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00031d8:	8d 50 01             	lea    0x1(%eax),%edx
c00031db:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00031de:	8b 55 0c             	mov    0xc(%ebp),%edx
c00031e1:	8d 4a 01             	lea    0x1(%edx),%ecx
c00031e4:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c00031e7:	0f b6 12             	movzbl (%edx),%edx
c00031ea:	88 10                	mov    %dl,(%eax)
c00031ec:	0f b6 00             	movzbl (%eax),%eax
c00031ef:	84 c0                	test   %al,%al
c00031f1:	75 e2                	jne    c00031d5 <strcat+0x47>
/work/x86_os_my/lib/string.c:98
   return dst_;
c00031f3:	8b 45 08             	mov    0x8(%ebp),%eax
/work/x86_os_my/lib/string.c:99
}
c00031f6:	c9                   	leave  
c00031f7:	c3                   	ret    

c00031f8 <strchrs>:
strchrs():
/work/x86_os_my/lib/string.c:102

/* 在字符串str中查找指定字符ch出现的次数 */
uint32_t strchrs(const char* str, uint8_t ch) {
c00031f8:	55                   	push   %ebp
c00031f9:	89 e5                	mov    %esp,%ebp
c00031fb:	83 ec 28             	sub    $0x28,%esp
c00031fe:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003201:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:103
   ASSERT(str != NULL);
c0003204:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003208:	75 19                	jne    c0003223 <strchrs+0x2b>
/work/x86_os_my/lib/string.c:103 (discriminator 1)
c000320a:	68 ce 52 00 c0       	push   $0xc00052ce
c000320f:	68 3c 53 00 c0       	push   $0xc000533c
c0003214:	6a 67                	push   $0x67
c0003216:	68 8d 52 00 c0       	push   $0xc000528d
c000321b:	e8 42 f1 ff ff       	call   c0002362 <panic_spin>
c0003220:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:104
   uint32_t ch_cnt = 0;
c0003223:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/string.c:105
   const char* p = str;
c000322a:	8b 45 08             	mov    0x8(%ebp),%eax
c000322d:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:106
   while(*p != 0) {
c0003230:	eb 19                	jmp    c000324b <strchrs+0x53>
/work/x86_os_my/lib/string.c:107
      if (*p == ch) {
c0003232:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003235:	0f b6 00             	movzbl (%eax),%eax
c0003238:	0f be d0             	movsbl %al,%edx
c000323b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c000323f:	39 c2                	cmp    %eax,%edx
c0003241:	75 04                	jne    c0003247 <strchrs+0x4f>
/work/x86_os_my/lib/string.c:108
	 ch_cnt++;
c0003243:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:110
      }
      p++;
c0003247:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/string.c:106
/* 在字符串str中查找指定字符ch出现的次数 */
uint32_t strchrs(const char* str, uint8_t ch) {
   ASSERT(str != NULL);
   uint32_t ch_cnt = 0;
   const char* p = str;
   while(*p != 0) {
c000324b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000324e:	0f b6 00             	movzbl (%eax),%eax
c0003251:	84 c0                	test   %al,%al
c0003253:	75 dd                	jne    c0003232 <strchrs+0x3a>
/work/x86_os_my/lib/string.c:112
      if (*p == ch) {
	 ch_cnt++;
      }
      p++;
   }
   return ch_cnt;
c0003255:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:113
}
c0003258:	c9                   	leave  
c0003259:	c3                   	ret    

c000325a <running_thread>:
running_thread():
/work/x86_os_my/thread/thread.c:24

/* 返回线程 PCB 地址。
 * 各个线程所用的 0 级栈都是在自己的 PCB 当中，
 * 取当前栈指针的高 20 位，就是当前运行线程的 PCB（PCB是在自然页的起始地址！）
 */
struct task_struct* running_thread() {
c000325a:	55                   	push   %ebp
c000325b:	89 e5                	mov    %esp,%ebp
c000325d:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:26
	uint32_t esp;
	asm ("mov %%esp, %0" : "=g" (esp));	//esp寄存器的值，放入变量esp
c0003260:	89 e0                	mov    %esp,%eax
c0003262:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:27
	return (struct task_struct*)(esp & 0xfffff000);
c0003265:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003268:	25 00 f0 ff ff       	and    $0xfffff000,%eax
/work/x86_os_my/thread/thread.c:28
}
c000326d:	c9                   	leave  
c000326e:	c3                   	ret    

c000326f <kernel_thread>:
kernel_thread():
/work/x86_os_my/thread/thread.c:31

/* 由kernel_thread去执行function(func_arg) */
static void kernel_thread(thread_func* function, void* func_arg) {
c000326f:	55                   	push   %ebp
c0003270:	89 e5                	mov    %esp,%ebp
c0003272:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:37
	/* 线程的首次运行是由时钟中断处理函数调用任务调度器 schedule 完成的，
	 * 进入中断后处理器会自动关中断，
	 * 因此在执行 function 前要打开中断，否则 kernel_thread 中的 function 在关中断的情况下运行，
	 * 也就是时钟中断被屏蔽了，再也不会调度到新的线程，function 会独享处理器。
	 */
	intr_enable();
c0003275:	e8 96 e7 ff ff       	call   c0001a10 <intr_enable>
/work/x86_os_my/thread/thread.c:38
	function(func_arg); 
c000327a:	83 ec 0c             	sub    $0xc,%esp
c000327d:	ff 75 0c             	pushl  0xc(%ebp)
c0003280:	8b 45 08             	mov    0x8(%ebp),%eax
c0003283:	ff d0                	call   *%eax
c0003285:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:39
}
c0003288:	90                   	nop
c0003289:	c9                   	leave  
c000328a:	c3                   	ret    

c000328b <allocate_pid>:
allocate_pid():
/work/x86_os_my/thread/thread.c:42

/* 分配pid */
static pid_t allocate_pid(void) {
c000328b:	55                   	push   %ebp
c000328c:	89 e5                	mov    %esp,%ebp
c000328e:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:44
   static pid_t next_pid = 0;
   lock_acquire(&pid_lock);
c0003291:	83 ec 0c             	sub    $0xc,%esp
c0003294:	68 f0 7a 00 c0       	push   $0xc0007af0
c0003299:	e8 41 0a 00 00       	call   c0003cdf <lock_acquire>
c000329e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:45
   next_pid++;
c00032a1:	0f b7 05 6c 75 00 c0 	movzwl 0xc000756c,%eax
c00032a8:	83 c0 01             	add    $0x1,%eax
c00032ab:	66 a3 6c 75 00 c0    	mov    %ax,0xc000756c
/work/x86_os_my/thread/thread.c:46
   lock_release(&pid_lock);
c00032b1:	83 ec 0c             	sub    $0xc,%esp
c00032b4:	68 f0 7a 00 c0       	push   $0xc0007af0
c00032b9:	e8 98 0a 00 00       	call   c0003d56 <lock_release>
c00032be:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:47
   return next_pid;
c00032c1:	0f b7 05 6c 75 00 c0 	movzwl 0xc000756c,%eax
/work/x86_os_my/thread/thread.c:48
}
c00032c8:	c9                   	leave  
c00032c9:	c3                   	ret    

c00032ca <thread_create>:
thread_create():
/work/x86_os_my/thread/thread.c:51

/* 初始化线程栈结构体 struct thread_stack */
void thread_create(struct task_struct* pthread, thread_func function, void* func_arg) {
c00032ca:	55                   	push   %ebp
c00032cb:	89 e5                	mov    %esp,%ebp
c00032cd:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:55
	/* 先预留中断使用栈的空间 
	 *（1）将来线程进入中断后，位于 kernel.S 中的中断代码会通过此栈来保存上下文。
	 *（2）将来实现用户进程时，会将用户进程的初始信息放在中断栈中。*/
	pthread->self_kstack -= sizeof(struct intr_stack);
c00032d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00032d3:	8b 00                	mov    (%eax),%eax
c00032d5:	8d 90 d0 fe ff ff    	lea    -0x130(%eax),%edx
c00032db:	8b 45 08             	mov    0x8(%ebp),%eax
c00032de:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:58

	/* 再留出线程栈空间（unused_retaddr 所在的栈）*/
	pthread->self_kstack -= sizeof(struct thread_stack);
c00032e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00032e3:	8b 00                	mov    (%eax),%eax
c00032e5:	8d 50 80             	lea    -0x80(%eax),%edx
c00032e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00032eb:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:59
	struct thread_stack* kthread_stack = (struct thread_stack*)pthread->self_kstack;
c00032ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00032f0:	8b 00                	mov    (%eax),%eax
c00032f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:67
	 * kernel_thread 并不是通过 call 指令调用的，而是通过 ret 来执行的，
	 * 因此无法按照正常的函数调用形式传递 kernel_thread 所需要的参数，
	 * 这样调用是不行的： kernel_thread(function, func_arg)，
	 * 只能将参数放在 kernel_thread 所用的栈中，即处理器进入 kernel_thread 函数体时，
	 * 栈顶为返回地址，栈顶+4 为参数function，栈顶+8 为参数func_arg */
	kthread_stack->eip = kernel_thread;
c00032f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00032f8:	c7 40 10 6f 32 00 c0 	movl   $0xc000326f,0x10(%eax)
/work/x86_os_my/thread/thread.c:68
	kthread_stack->function = function;
c00032ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003302:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003305:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/thread.c:69
	kthread_stack->func_arg = func_arg;
c0003308:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000330b:	8b 55 10             	mov    0x10(%ebp),%edx
c000330e:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/thread/thread.c:70
	kthread_stack->ebp = kthread_stack->ebx = kthread_stack->esi = kthread_stack->edi = 0;
c0003311:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003314:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c000331b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000331e:	8b 50 08             	mov    0x8(%eax),%edx
c0003321:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003324:	89 50 0c             	mov    %edx,0xc(%eax)
c0003327:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000332a:	8b 50 0c             	mov    0xc(%eax),%edx
c000332d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003330:	89 50 04             	mov    %edx,0x4(%eax)
c0003333:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003336:	8b 50 04             	mov    0x4(%eax),%edx
c0003339:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000333c:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:71
}
c000333e:	90                   	nop
c000333f:	c9                   	leave  
c0003340:	c3                   	ret    

c0003341 <init_thread>:
init_thread():
/work/x86_os_my/thread/thread.c:74

/* 初始化线程PCB结构体 struct task_struct */
void init_thread(struct task_struct* pthread, char* name, int prio) {
c0003341:	55                   	push   %ebp
c0003342:	89 e5                	mov    %esp,%ebp
c0003344:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:75
	memset(pthread, 0, sizeof(*pthread));	//清空PCB
c0003347:	83 ec 04             	sub    $0x4,%esp
c000334a:	6a 48                	push   $0x48
c000334c:	6a 00                	push   $0x0
c000334e:	ff 75 08             	pushl  0x8(%ebp)
c0003351:	e8 34 fb ff ff       	call   c0002e8a <memset>
c0003356:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:76
	pthread->pid = allocate_pid();
c0003359:	e8 2d ff ff ff       	call   c000328b <allocate_pid>
c000335e:	89 c2                	mov    %eax,%edx
c0003360:	8b 45 08             	mov    0x8(%ebp),%eax
c0003363:	66 89 50 04          	mov    %dx,0x4(%eax)
/work/x86_os_my/thread/thread.c:77
	strcpy(pthread->name, name);
c0003367:	8b 45 08             	mov    0x8(%ebp),%eax
c000336a:	83 c0 0c             	add    $0xc,%eax
c000336d:	83 ec 08             	sub    $0x8,%esp
c0003370:	ff 75 0c             	pushl  0xc(%ebp)
c0003373:	50                   	push   %eax
c0003374:	e8 46 fc ff ff       	call   c0002fbf <strcpy>
c0003379:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:79

	if (pthread == g_main_thread) {
c000337c:	a1 ec 7a 00 c0       	mov    0xc0007aec,%eax
c0003381:	39 45 08             	cmp    %eax,0x8(%ebp)
c0003384:	75 0c                	jne    c0003392 <init_thread+0x51>
/work/x86_os_my/thread/thread.c:81
		/* 由于把main函数也封装成一个线程,并且它一直是运行的,故将其直接设为TASK_RUNNING */
		pthread->status = TASK_RUNNING;
c0003386:	8b 45 08             	mov    0x8(%ebp),%eax
c0003389:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c0003390:	eb 0a                	jmp    c000339c <init_thread+0x5b>
/work/x86_os_my/thread/thread.c:83
	} else {
		pthread->status = TASK_READY;
c0003392:	8b 45 08             	mov    0x8(%ebp),%eax
c0003395:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:89
	}

	/* self_kstack是线程自己在内核态下使用的栈顶地址 
	 * 线程自己在 0 特权级下所用的栈，在线程创建之初，
	 * 它被初始化为线程 PCB 的最顶端，即(uint32_t)pthread + PG_SIZE。*/
	pthread->self_kstack = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c000339c:	8b 45 08             	mov    0x8(%ebp),%eax
c000339f:	05 00 10 00 00       	add    $0x1000,%eax
c00033a4:	89 c2                	mov    %eax,%edx
c00033a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00033a9:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:90
	pthread->priority = prio;
c00033ab:	8b 45 10             	mov    0x10(%ebp),%eax
c00033ae:	89 c2                	mov    %eax,%edx
c00033b0:	8b 45 08             	mov    0x8(%ebp),%eax
c00033b3:	88 50 1c             	mov    %dl,0x1c(%eax)
/work/x86_os_my/thread/thread.c:91
	pthread->ticks = prio;
c00033b6:	8b 45 10             	mov    0x10(%ebp),%eax
c00033b9:	89 c2                	mov    %eax,%edx
c00033bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00033be:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/thread/thread.c:92
	pthread->elapsed_ticks = 0;
c00033c1:	8b 45 08             	mov    0x8(%ebp),%eax
c00033c4:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
/work/x86_os_my/thread/thread.c:93
	pthread->pgdir = NULL;
c00033cb:	8b 45 08             	mov    0x8(%ebp),%eax
c00033ce:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
/work/x86_os_my/thread/thread.c:94
	pthread->stack_magic = 0x19870916;	  // 自定义的魔数
c00033d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00033d8:	c7 40 44 16 09 87 19 	movl   $0x19870916,0x44(%eax)
/work/x86_os_my/thread/thread.c:95
}
c00033df:	90                   	nop
c00033e0:	c9                   	leave  
c00033e1:	c3                   	ret    

c00033e2 <thread_start>:
thread_start():
/work/x86_os_my/thread/thread.c:98

/* 创建线程 */
struct task_struct* thread_start(char* name, int prio, thread_func function, void* func_arg) {
c00033e2:	55                   	push   %ebp
c00033e3:	89 e5                	mov    %esp,%ebp
c00033e5:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:100
	/* pcb都位于内核空间,包括用户进程的pcb也是在内核空间 */
	struct task_struct* thread = get_kernel_pages(1);
c00033e8:	83 ec 0c             	sub    $0xc,%esp
c00033eb:	6a 01                	push   $0x1
c00033ed:	e8 18 f6 ff ff       	call   c0002a0a <get_kernel_pages>
c00033f2:	83 c4 10             	add    $0x10,%esp
c00033f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:102

	init_thread(thread, name, prio);			//初始化线程PCB
c00033f8:	83 ec 04             	sub    $0x4,%esp
c00033fb:	ff 75 0c             	pushl  0xc(%ebp)
c00033fe:	ff 75 08             	pushl  0x8(%ebp)
c0003401:	ff 75 f4             	pushl  -0xc(%ebp)
c0003404:	e8 38 ff ff ff       	call   c0003341 <init_thread>
c0003409:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:103
	thread_create(thread, function, func_arg);	//初始化线程栈结构体
c000340c:	83 ec 04             	sub    $0x4,%esp
c000340f:	ff 75 14             	pushl  0x14(%ebp)
c0003412:	ff 75 10             	pushl  0x10(%ebp)
c0003415:	ff 75 f4             	pushl  -0xc(%ebp)
c0003418:	e8 ad fe ff ff       	call   c00032ca <thread_create>
c000341d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:105
	
	ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));	// 确保之前不在队列中
c0003420:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003423:	83 c0 24             	add    $0x24,%eax
c0003426:	83 ec 08             	sub    $0x8,%esp
c0003429:	50                   	push   %eax
c000342a:	68 cc 7a 00 c0       	push   $0xc0007acc
c000342f:	e8 f2 04 00 00       	call   c0003926 <elem_find>
c0003434:	83 c4 10             	add    $0x10,%esp
c0003437:	85 c0                	test   %eax,%eax
c0003439:	74 19                	je     c0003454 <thread_start+0x72>
/work/x86_os_my/thread/thread.c:105 (discriminator 1)
c000343b:	68 44 53 00 c0       	push   $0xc0005344
c0003440:	68 c4 55 00 c0       	push   $0xc00055c4
c0003445:	6a 69                	push   $0x69
c0003447:	68 79 53 00 c0       	push   $0xc0005379
c000344c:	e8 11 ef ff ff       	call   c0002362 <panic_spin>
c0003451:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:106
	list_append(&thread_ready_list, &thread->general_tag);			// 加入就绪线程队列
c0003454:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003457:	83 c0 24             	add    $0x24,%eax
c000345a:	83 ec 08             	sub    $0x8,%esp
c000345d:	50                   	push   %eax
c000345e:	68 cc 7a 00 c0       	push   $0xc0007acc
c0003463:	e8 44 04 00 00       	call   c00038ac <list_append>
c0003468:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:108

	ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
c000346b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000346e:	83 c0 2c             	add    $0x2c,%eax
c0003471:	83 ec 08             	sub    $0x8,%esp
c0003474:	50                   	push   %eax
c0003475:	68 dc 7a 00 c0       	push   $0xc0007adc
c000347a:	e8 a7 04 00 00       	call   c0003926 <elem_find>
c000347f:	83 c4 10             	add    $0x10,%esp
c0003482:	85 c0                	test   %eax,%eax
c0003484:	74 19                	je     c000349f <thread_start+0xbd>
/work/x86_os_my/thread/thread.c:108 (discriminator 1)
c0003486:	68 8c 53 00 c0       	push   $0xc000538c
c000348b:	68 c4 55 00 c0       	push   $0xc00055c4
c0003490:	6a 6c                	push   $0x6c
c0003492:	68 79 53 00 c0       	push   $0xc0005379
c0003497:	e8 c6 ee ff ff       	call   c0002362 <panic_spin>
c000349c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:109
	list_append(&thread_all_list, &thread->all_list_tag);			// 加入全部线程队列
c000349f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00034a2:	83 c0 2c             	add    $0x2c,%eax
c00034a5:	83 ec 08             	sub    $0x8,%esp
c00034a8:	50                   	push   %eax
c00034a9:	68 dc 7a 00 c0       	push   $0xc0007adc
c00034ae:	e8 f9 03 00 00       	call   c00038ac <list_append>
c00034b3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:125
	 * 在执行 ret 后，esp 指向的数值被弹岀到 eip。
	 * 处理器会去执行 kernel_thread 函数。
	 * 在执行 kernel_thread 时，处理器以为栈顶是返回地址，其实只是一个假的占位置的变量 unused_retaddr！
	 * 接着会调用函数 function(func_arg) */
	//asm volatile ("movl %0, %%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret" : : "g" (thread->self_kstack) : "memory");
	return thread;
c00034b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/thread/thread.c:126
}
c00034b9:	c9                   	leave  
c00034ba:	c3                   	ret    

c00034bb <make_main_thread>:
make_main_thread():
/work/x86_os_my/thread/thread.c:130


/* 将kernel中的main函数完善为主线程 */
static void make_main_thread(void) {
c00034bb:	55                   	push   %ebp
c00034bc:	89 e5                	mov    %esp,%ebp
c00034be:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:135
	/* 因为main线程早已运行,咱们在loader.S中进入内核时的mov esp, 0xc009f000设置了栈顶，也预留了pcb, 地址为0xc009e000
	 * 主线程不需要再为PCB申请页，只需要通过 init_thread 填充PCB成员：名称和优先级等。
	 * 也不需要再通过 thread_create 构造它的线程栈。
	 */
	g_main_thread = running_thread();	//用栈指针的高20位，当做当前线程的PCB
c00034c1:	e8 94 fd ff ff       	call   c000325a <running_thread>
c00034c6:	a3 ec 7a 00 c0       	mov    %eax,0xc0007aec
/work/x86_os_my/thread/thread.c:136
	init_thread(g_main_thread, "main", 31);
c00034cb:	a1 ec 7a 00 c0       	mov    0xc0007aec,%eax
c00034d0:	83 ec 04             	sub    $0x4,%esp
c00034d3:	6a 1f                	push   $0x1f
c00034d5:	68 c0 53 00 c0       	push   $0xc00053c0
c00034da:	50                   	push   %eax
c00034db:	e8 61 fe ff ff       	call   c0003341 <init_thread>
c00034e0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:140

	/* main函数是当前线程,当前线程不在thread_ready_list中,
	 * 所以只将其加在thread_all_list中. */
	ASSERT(!elem_find(&thread_all_list, &g_main_thread->all_list_tag));
c00034e3:	a1 ec 7a 00 c0       	mov    0xc0007aec,%eax
c00034e8:	83 c0 2c             	add    $0x2c,%eax
c00034eb:	83 ec 08             	sub    $0x8,%esp
c00034ee:	50                   	push   %eax
c00034ef:	68 dc 7a 00 c0       	push   $0xc0007adc
c00034f4:	e8 2d 04 00 00       	call   c0003926 <elem_find>
c00034f9:	83 c4 10             	add    $0x10,%esp
c00034fc:	85 c0                	test   %eax,%eax
c00034fe:	74 1c                	je     c000351c <make_main_thread+0x61>
/work/x86_os_my/thread/thread.c:140 (discriminator 1)
c0003500:	68 c8 53 00 c0       	push   $0xc00053c8
c0003505:	68 d4 55 00 c0       	push   $0xc00055d4
c000350a:	68 8c 00 00 00       	push   $0x8c
c000350f:	68 79 53 00 c0       	push   $0xc0005379
c0003514:	e8 49 ee ff ff       	call   c0002362 <panic_spin>
c0003519:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:141
	list_append(&thread_all_list, &g_main_thread->all_list_tag);
c000351c:	a1 ec 7a 00 c0       	mov    0xc0007aec,%eax
c0003521:	83 c0 2c             	add    $0x2c,%eax
c0003524:	83 ec 08             	sub    $0x8,%esp
c0003527:	50                   	push   %eax
c0003528:	68 dc 7a 00 c0       	push   $0xc0007adc
c000352d:	e8 7a 03 00 00       	call   c00038ac <list_append>
c0003532:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:142
}
c0003535:	90                   	nop
c0003536:	c9                   	leave  
c0003537:	c3                   	ret    

c0003538 <schedule>:
schedule():
/work/x86_os_my/thread/thread.c:152
（2）调度器 schedule。
（3）任务切换函数 switch_to。
*/
/* 实现任务调度 */
void schedule()
{
c0003538:	55                   	push   %ebp
c0003539:	89 e5                	mov    %esp,%ebp
c000353b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:153
	ASSERT(intr_get_status() == INTR_OFF);
c000353e:	e8 3d e5 ff ff       	call   c0001a80 <intr_get_status>
c0003543:	85 c0                	test   %eax,%eax
c0003545:	74 1c                	je     c0003563 <schedule+0x2b>
/work/x86_os_my/thread/thread.c:153 (discriminator 1)
c0003547:	68 03 54 00 c0       	push   $0xc0005403
c000354c:	68 e8 55 00 c0       	push   $0xc00055e8
c0003551:	68 99 00 00 00       	push   $0x99
c0003556:	68 79 53 00 c0       	push   $0xc0005379
c000355b:	e8 02 ee ff ff       	call   c0002362 <panic_spin>
c0003560:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:156

	/* 换下 */
	struct task_struct* cur = running_thread(); 
c0003563:	e8 f2 fc ff ff       	call   c000325a <running_thread>
c0003568:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:157
	if (cur->status == TASK_RUNNING) { // 若此线程只是cpu时间片到了,将其加入到就绪队列尾
c000356b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000356e:	8b 40 08             	mov    0x8(%eax),%eax
c0003571:	85 c0                	test   %eax,%eax
c0003573:	75 65                	jne    c00035da <schedule+0xa2>
/work/x86_os_my/thread/thread.c:158
		ASSERT(!elem_find(&thread_ready_list, &cur->general_tag));
c0003575:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003578:	83 c0 24             	add    $0x24,%eax
c000357b:	83 ec 08             	sub    $0x8,%esp
c000357e:	50                   	push   %eax
c000357f:	68 cc 7a 00 c0       	push   $0xc0007acc
c0003584:	e8 9d 03 00 00       	call   c0003926 <elem_find>
c0003589:	83 c4 10             	add    $0x10,%esp
c000358c:	85 c0                	test   %eax,%eax
c000358e:	74 1c                	je     c00035ac <schedule+0x74>
/work/x86_os_my/thread/thread.c:158 (discriminator 1)
c0003590:	68 24 54 00 c0       	push   $0xc0005424
c0003595:	68 e8 55 00 c0       	push   $0xc00055e8
c000359a:	68 9e 00 00 00       	push   $0x9e
c000359f:	68 79 53 00 c0       	push   $0xc0005379
c00035a4:	e8 b9 ed ff ff       	call   c0002362 <panic_spin>
c00035a9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:159
		list_append(&thread_ready_list, &cur->general_tag);
c00035ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00035af:	83 c0 24             	add    $0x24,%eax
c00035b2:	83 ec 08             	sub    $0x8,%esp
c00035b5:	50                   	push   %eax
c00035b6:	68 cc 7a 00 c0       	push   $0xc0007acc
c00035bb:	e8 ec 02 00 00       	call   c00038ac <list_append>
c00035c0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:160
		cur->ticks = cur->priority;     // 重新将当前线程的ticks再重置为其priority;
c00035c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00035c6:	0f b6 50 1c          	movzbl 0x1c(%eax),%edx
c00035ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00035cd:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/thread/thread.c:161
		cur->status = TASK_READY;
c00035d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00035d3:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:168
		/* 若此线程需要某事件发生后才能继续上cpu运行,
		不需要将其加入队列,因为当前线程不在就绪队列中。*/
	}

	/* 换上 */
	ASSERT(!list_empty(&thread_ready_list));
c00035da:	83 ec 0c             	sub    $0xc,%esp
c00035dd:	68 cc 7a 00 c0       	push   $0xc0007acc
c00035e2:	e8 0c 04 00 00       	call   c00039f3 <list_empty>
c00035e7:	83 c4 10             	add    $0x10,%esp
c00035ea:	85 c0                	test   %eax,%eax
c00035ec:	74 1c                	je     c000360a <schedule+0xd2>
/work/x86_os_my/thread/thread.c:168 (discriminator 1)
c00035ee:	68 58 54 00 c0       	push   $0xc0005458
c00035f3:	68 e8 55 00 c0       	push   $0xc00055e8
c00035f8:	68 a8 00 00 00       	push   $0xa8
c00035fd:	68 79 53 00 c0       	push   $0xc0005379
c0003602:	e8 5b ed ff ff       	call   c0002362 <panic_spin>
c0003607:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:169
	g_thread_tag = NULL;	  // g_thread_tag清空
c000360a:	c7 05 68 75 00 c0 00 	movl   $0x0,0xc0007568
c0003611:	00 00 00 
/work/x86_os_my/thread/thread.c:171
	/* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */
	g_thread_tag = list_pop(&thread_ready_list);   
c0003614:	83 ec 0c             	sub    $0xc,%esp
c0003617:	68 cc 7a 00 c0       	push   $0xc0007acc
c000361c:	e8 e3 02 00 00       	call   c0003904 <list_pop>
c0003621:	83 c4 10             	add    $0x10,%esp
c0003624:	a3 68 75 00 c0       	mov    %eax,0xc0007568
/work/x86_os_my/thread/thread.c:172
	struct task_struct* next = elem2entry(struct task_struct, general_tag, g_thread_tag);
c0003629:	a1 68 75 00 c0       	mov    0xc0007568,%eax
c000362e:	83 e8 24             	sub    $0x24,%eax
c0003631:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:173
	next->status = TASK_RUNNING;
c0003634:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003637:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/thread/thread.c:177
	
	/* 1.激活线程或进程的页表,【更新CR3寄存器】
	 * 2.用户进程，更新tss中的esp0为进程的特权级0的栈 */
	process_activate(next);
c000363e:	83 ec 0c             	sub    $0xc,%esp
c0003641:	ff 75 f0             	pushl  -0x10(%ebp)
c0003644:	e8 59 10 00 00       	call   c00046a2 <process_activate>
c0003649:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:179

	switch_to(cur, next);
c000364c:	83 ec 08             	sub    $0x8,%esp
c000364f:	ff 75 f0             	pushl  -0x10(%ebp)
c0003652:	ff 75 f4             	pushl  -0xc(%ebp)
c0003655:	e8 b6 03 00 00       	call   c0003a10 <switch_to>
c000365a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:180
}
c000365d:	90                   	nop
c000365e:	c9                   	leave  
c000365f:	c3                   	ret    

c0003660 <thread_block>:
thread_block():
/work/x86_os_my/thread/thread.c:183

/* 当前线程将自己阻塞,标志其状态为stat. */
void thread_block(enum task_status stat) {
c0003660:	55                   	push   %ebp
c0003661:	89 e5                	mov    %esp,%ebp
c0003663:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:185
	/* stat取值为TASK_BLOCKED,TASK_WAITING,TASK_HANGING,也就是只有这三种状态才不会被调度*/
	ASSERT(((stat == TASK_BLOCKED) || (stat == TASK_WAITING) || (stat == TASK_HANGING)));
c0003666:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c000366a:	74 28                	je     c0003694 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:185 (discriminator 1)
c000366c:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c0003670:	74 22                	je     c0003694 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:185 (discriminator 2)
c0003672:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
c0003676:	74 1c                	je     c0003694 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:185 (discriminator 3)
c0003678:	68 78 54 00 c0       	push   $0xc0005478
c000367d:	68 f4 55 00 c0       	push   $0xc00055f4
c0003682:	68 b9 00 00 00       	push   $0xb9
c0003687:	68 79 53 00 c0       	push   $0xc0005379
c000368c:	e8 d1 ec ff ff       	call   c0002362 <panic_spin>
c0003691:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:186
	enum intr_status old_status = intr_disable();
c0003694:	e8 a0 e3 ff ff       	call   c0001a39 <intr_disable>
c0003699:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:188
	
	struct task_struct* cur_thread = running_thread();
c000369c:	e8 b9 fb ff ff       	call   c000325a <running_thread>
c00036a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:189
	cur_thread->status = stat;
c00036a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00036a7:	8b 55 08             	mov    0x8(%ebp),%edx
c00036aa:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/thread/thread.c:190
	schedule();
c00036ad:	e8 86 fe ff ff       	call   c0003538 <schedule>
/work/x86_os_my/thread/thread.c:193
	
	/* 待当前线程被解除阻塞后才继续运行下面的intr_set_status */
	intr_set_status(old_status);
c00036b2:	83 ec 0c             	sub    $0xc,%esp
c00036b5:	ff 75 f4             	pushl  -0xc(%ebp)
c00036b8:	e8 a5 e3 ff ff       	call   c0001a62 <intr_set_status>
c00036bd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:194
}
c00036c0:	90                   	nop
c00036c1:	c9                   	leave  
c00036c2:	c3                   	ret    

c00036c3 <thread_unblock>:
thread_unblock():
/work/x86_os_my/thread/thread.c:197

/* 将线程pthread解除阻塞 */
void thread_unblock(struct task_struct* pthread) {
c00036c3:	55                   	push   %ebp
c00036c4:	89 e5                	mov    %esp,%ebp
c00036c6:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:198
	enum intr_status old_status = intr_disable();
c00036c9:	e8 6b e3 ff ff       	call   c0001a39 <intr_disable>
c00036ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:199
	ASSERT(((pthread->status == TASK_BLOCKED) || (pthread->status == TASK_WAITING) || (pthread->status == TASK_HANGING)));
c00036d1:	8b 45 08             	mov    0x8(%ebp),%eax
c00036d4:	8b 40 08             	mov    0x8(%eax),%eax
c00036d7:	83 f8 02             	cmp    $0x2,%eax
c00036da:	74 32                	je     c000370e <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:199 (discriminator 1)
c00036dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00036df:	8b 40 08             	mov    0x8(%eax),%eax
c00036e2:	83 f8 03             	cmp    $0x3,%eax
c00036e5:	74 27                	je     c000370e <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:199 (discriminator 2)
c00036e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00036ea:	8b 40 08             	mov    0x8(%eax),%eax
c00036ed:	83 f8 04             	cmp    $0x4,%eax
c00036f0:	74 1c                	je     c000370e <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:199 (discriminator 3)
c00036f2:	68 c8 54 00 c0       	push   $0xc00054c8
c00036f7:	68 04 56 00 c0       	push   $0xc0005604
c00036fc:	68 c7 00 00 00       	push   $0xc7
c0003701:	68 79 53 00 c0       	push   $0xc0005379
c0003706:	e8 57 ec ff ff       	call   c0002362 <panic_spin>
c000370b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:201
	
	if (pthread->status != TASK_READY) {
c000370e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003711:	8b 40 08             	mov    0x8(%eax),%eax
c0003714:	83 f8 01             	cmp    $0x1,%eax
c0003717:	0f 84 8f 00 00 00    	je     c00037ac <thread_unblock+0xe9>
/work/x86_os_my/thread/thread.c:202
		ASSERT(!elem_find(&thread_ready_list, &pthread->general_tag));
c000371d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003720:	83 c0 24             	add    $0x24,%eax
c0003723:	83 ec 08             	sub    $0x8,%esp
c0003726:	50                   	push   %eax
c0003727:	68 cc 7a 00 c0       	push   $0xc0007acc
c000372c:	e8 f5 01 00 00       	call   c0003926 <elem_find>
c0003731:	83 c4 10             	add    $0x10,%esp
c0003734:	85 c0                	test   %eax,%eax
c0003736:	74 1c                	je     c0003754 <thread_unblock+0x91>
/work/x86_os_my/thread/thread.c:202 (discriminator 1)
c0003738:	68 38 55 00 c0       	push   $0xc0005538
c000373d:	68 04 56 00 c0       	push   $0xc0005604
c0003742:	68 ca 00 00 00       	push   $0xca
c0003747:	68 79 53 00 c0       	push   $0xc0005379
c000374c:	e8 11 ec ff ff       	call   c0002362 <panic_spin>
c0003751:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:203
		if (elem_find(&thread_ready_list, &pthread->general_tag)) {
c0003754:	8b 45 08             	mov    0x8(%ebp),%eax
c0003757:	83 c0 24             	add    $0x24,%eax
c000375a:	83 ec 08             	sub    $0x8,%esp
c000375d:	50                   	push   %eax
c000375e:	68 cc 7a 00 c0       	push   $0xc0007acc
c0003763:	e8 be 01 00 00       	call   c0003926 <elem_find>
c0003768:	83 c4 10             	add    $0x10,%esp
c000376b:	85 c0                	test   %eax,%eax
c000376d:	74 1c                	je     c000378b <thread_unblock+0xc8>
/work/x86_os_my/thread/thread.c:204
			PANIC("thread_unblock: blocked thread in ready_list\n");
c000376f:	68 70 55 00 c0       	push   $0xc0005570
c0003774:	68 04 56 00 c0       	push   $0xc0005604
c0003779:	68 cc 00 00 00       	push   $0xcc
c000377e:	68 79 53 00 c0       	push   $0xc0005379
c0003783:	e8 da eb ff ff       	call   c0002362 <panic_spin>
c0003788:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:206
		}
		list_push(&thread_ready_list, &pthread->general_tag);	// 放到队列的最前面,使其尽快得到调度
c000378b:	8b 45 08             	mov    0x8(%ebp),%eax
c000378e:	83 c0 24             	add    $0x24,%eax
c0003791:	83 ec 08             	sub    $0x8,%esp
c0003794:	50                   	push   %eax
c0003795:	68 cc 7a 00 c0       	push   $0xc0007acc
c000379a:	e8 ef 00 00 00       	call   c000388e <list_push>
c000379f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:207
		pthread->status = TASK_READY;
c00037a2:	8b 45 08             	mov    0x8(%ebp),%eax
c00037a5:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:210
	}
	
	intr_set_status(old_status);
c00037ac:	83 ec 0c             	sub    $0xc,%esp
c00037af:	ff 75 f4             	pushl  -0xc(%ebp)
c00037b2:	e8 ab e2 ff ff       	call   c0001a62 <intr_set_status>
c00037b7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:211
}
c00037ba:	90                   	nop
c00037bb:	c9                   	leave  
c00037bc:	c3                   	ret    

c00037bd <thread_init>:
thread_init():
/work/x86_os_my/thread/thread.c:214

/* 初始化线程环境 */
void thread_init(void) {
c00037bd:	55                   	push   %ebp
c00037be:	89 e5                	mov    %esp,%ebp
c00037c0:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:215
	put_str("thread_init start\n");
c00037c3:	83 ec 0c             	sub    $0xc,%esp
c00037c6:	68 9e 55 00 c0       	push   $0xc000559e
c00037cb:	e8 20 ea ff ff       	call   c00021f0 <put_str>
c00037d0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:216
	list_init(&thread_ready_list);
c00037d3:	83 ec 0c             	sub    $0xc,%esp
c00037d6:	68 cc 7a 00 c0       	push   $0xc0007acc
c00037db:	e8 3b 00 00 00       	call   c000381b <list_init>
c00037e0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:217
	list_init(&thread_all_list);
c00037e3:	83 ec 0c             	sub    $0xc,%esp
c00037e6:	68 dc 7a 00 c0       	push   $0xc0007adc
c00037eb:	e8 2b 00 00 00       	call   c000381b <list_init>
c00037f0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:218
	lock_init(&pid_lock);
c00037f3:	83 ec 0c             	sub    $0xc,%esp
c00037f6:	68 f0 7a 00 c0       	push   $0xc0007af0
c00037fb:	e8 05 03 00 00       	call   c0003b05 <lock_init>
c0003800:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:220
	/* 将当前main函数创建为线程 */
	make_main_thread();
c0003803:	e8 b3 fc ff ff       	call   c00034bb <make_main_thread>
/work/x86_os_my/thread/thread.c:221
	put_str("thread_init done\n");
c0003808:	83 ec 0c             	sub    $0xc,%esp
c000380b:	68 b1 55 00 c0       	push   $0xc00055b1
c0003810:	e8 db e9 ff ff       	call   c00021f0 <put_str>
c0003815:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:222
}
c0003818:	90                   	nop
c0003819:	c9                   	leave  
c000381a:	c3                   	ret    

c000381b <list_init>:
list_init():
/work/x86_os_my/lib/kernel/list.c:6
#include "list.h"
#include "interrupt.h"
/* 注意关中断的操作：临界区 */

/* 初始化双向链表list */
void list_init (struct list* list) {
c000381b:	55                   	push   %ebp
c000381c:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/lib/kernel/list.c:7
	list->head.prev = NULL;
c000381e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003821:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/lib/kernel/list.c:8
	list->head.next = &list->tail;
c0003827:	8b 45 08             	mov    0x8(%ebp),%eax
c000382a:	8d 50 08             	lea    0x8(%eax),%edx
c000382d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003830:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:9
	list->tail.prev = &list->head;
c0003833:	8b 55 08             	mov    0x8(%ebp),%edx
c0003836:	8b 45 08             	mov    0x8(%ebp),%eax
c0003839:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/lib/kernel/list.c:10
	list->tail.next = NULL;
c000383c:	8b 45 08             	mov    0x8(%ebp),%eax
c000383f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/lib/kernel/list.c:11
}
c0003846:	90                   	nop
c0003847:	5d                   	pop    %ebp
c0003848:	c3                   	ret    

c0003849 <list_insert_before>:
list_insert_before():
/work/x86_os_my/lib/kernel/list.c:14

/* 把链表元素elem插入在元素before之前 */
void list_insert_before(struct list_elem* before, struct list_elem* elem) { 
c0003849:	55                   	push   %ebp
c000384a:	89 e5                	mov    %esp,%ebp
c000384c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:15
	enum intr_status old_status = intr_disable();
c000384f:	e8 e5 e1 ff ff       	call   c0001a39 <intr_disable>
c0003854:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:18

	/* 将before前驱元素的后继元素更新为elem, 暂时使before脱离链表*/ 
	before->prev->next = elem; 
c0003857:	8b 45 08             	mov    0x8(%ebp),%eax
c000385a:	8b 00                	mov    (%eax),%eax
c000385c:	8b 55 0c             	mov    0xc(%ebp),%edx
c000385f:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:22

	/* 更新elem自己的前驱结点为before的前驱,
	* 更新elem自己的后继结点为before, 于是before又回到链表 */
	elem->prev = before->prev;
c0003862:	8b 45 08             	mov    0x8(%ebp),%eax
c0003865:	8b 10                	mov    (%eax),%edx
c0003867:	8b 45 0c             	mov    0xc(%ebp),%eax
c000386a:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:23
	elem->next = before;
c000386c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000386f:	8b 55 08             	mov    0x8(%ebp),%edx
c0003872:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:26

	/* 更新before的前驱结点为elem */
	before->prev = elem;
c0003875:	8b 45 08             	mov    0x8(%ebp),%eax
c0003878:	8b 55 0c             	mov    0xc(%ebp),%edx
c000387b:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:28

	intr_set_status(old_status);
c000387d:	83 ec 0c             	sub    $0xc,%esp
c0003880:	ff 75 f4             	pushl  -0xc(%ebp)
c0003883:	e8 da e1 ff ff       	call   c0001a62 <intr_set_status>
c0003888:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:29
}
c000388b:	90                   	nop
c000388c:	c9                   	leave  
c000388d:	c3                   	ret    

c000388e <list_push>:
list_push():
/work/x86_os_my/lib/kernel/list.c:32

/* 添加元素到列表队首,类似栈push操作 */
void list_push(struct list* plist, struct list_elem* elem) {
c000388e:	55                   	push   %ebp
c000388f:	89 e5                	mov    %esp,%ebp
c0003891:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/list.c:33
	list_insert_before(plist->head.next, elem); // 在队头插入elem
c0003894:	8b 45 08             	mov    0x8(%ebp),%eax
c0003897:	8b 40 04             	mov    0x4(%eax),%eax
c000389a:	83 ec 08             	sub    $0x8,%esp
c000389d:	ff 75 0c             	pushl  0xc(%ebp)
c00038a0:	50                   	push   %eax
c00038a1:	e8 a3 ff ff ff       	call   c0003849 <list_insert_before>
c00038a6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:34
}
c00038a9:	90                   	nop
c00038aa:	c9                   	leave  
c00038ab:	c3                   	ret    

c00038ac <list_append>:
list_append():
/work/x86_os_my/lib/kernel/list.c:37

/* 追加元素到链表队尾,类似队列的先进先出操作 */
void list_append(struct list* plist, struct list_elem* elem) {
c00038ac:	55                   	push   %ebp
c00038ad:	89 e5                	mov    %esp,%ebp
c00038af:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/list.c:38
	list_insert_before(&plist->tail, elem);     // 在队尾的前面插入
c00038b2:	8b 45 08             	mov    0x8(%ebp),%eax
c00038b5:	83 c0 08             	add    $0x8,%eax
c00038b8:	83 ec 08             	sub    $0x8,%esp
c00038bb:	ff 75 0c             	pushl  0xc(%ebp)
c00038be:	50                   	push   %eax
c00038bf:	e8 85 ff ff ff       	call   c0003849 <list_insert_before>
c00038c4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:39
}
c00038c7:	90                   	nop
c00038c8:	c9                   	leave  
c00038c9:	c3                   	ret    

c00038ca <list_remove>:
list_remove():
/work/x86_os_my/lib/kernel/list.c:42

/* 使元素pelem脱离链表 */
void list_remove(struct list_elem* pelem) {
c00038ca:	55                   	push   %ebp
c00038cb:	89 e5                	mov    %esp,%ebp
c00038cd:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:43
	enum intr_status old_status = intr_disable();
c00038d0:	e8 64 e1 ff ff       	call   c0001a39 <intr_disable>
c00038d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:45

	pelem->prev->next = pelem->next;
c00038d8:	8b 45 08             	mov    0x8(%ebp),%eax
c00038db:	8b 00                	mov    (%eax),%eax
c00038dd:	8b 55 08             	mov    0x8(%ebp),%edx
c00038e0:	8b 52 04             	mov    0x4(%edx),%edx
c00038e3:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:46
	pelem->next->prev = pelem->prev;
c00038e6:	8b 45 08             	mov    0x8(%ebp),%eax
c00038e9:	8b 40 04             	mov    0x4(%eax),%eax
c00038ec:	8b 55 08             	mov    0x8(%ebp),%edx
c00038ef:	8b 12                	mov    (%edx),%edx
c00038f1:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:48

	intr_set_status(old_status);
c00038f3:	83 ec 0c             	sub    $0xc,%esp
c00038f6:	ff 75 f4             	pushl  -0xc(%ebp)
c00038f9:	e8 64 e1 ff ff       	call   c0001a62 <intr_set_status>
c00038fe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:49
}
c0003901:	90                   	nop
c0003902:	c9                   	leave  
c0003903:	c3                   	ret    

c0003904 <list_pop>:
list_pop():
/work/x86_os_my/lib/kernel/list.c:52

/* 将链表第一个元素弹出并返回,类似栈的pop操作 */
struct list_elem* list_pop(struct list* plist) {
c0003904:	55                   	push   %ebp
c0003905:	89 e5                	mov    %esp,%ebp
c0003907:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:53
	struct list_elem* elem = plist->head.next;
c000390a:	8b 45 08             	mov    0x8(%ebp),%eax
c000390d:	8b 40 04             	mov    0x4(%eax),%eax
c0003910:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:54
	list_remove(elem);
c0003913:	83 ec 0c             	sub    $0xc,%esp
c0003916:	ff 75 f4             	pushl  -0xc(%ebp)
c0003919:	e8 ac ff ff ff       	call   c00038ca <list_remove>
c000391e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:55
	return elem;
c0003921:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/kernel/list.c:56
} 
c0003924:	c9                   	leave  
c0003925:	c3                   	ret    

c0003926 <elem_find>:
elem_find():
/work/x86_os_my/lib/kernel/list.c:59

/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */
bool elem_find(struct list* plist, struct list_elem* obj_elem) {
c0003926:	55                   	push   %ebp
c0003927:	89 e5                	mov    %esp,%ebp
c0003929:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:60
	struct list_elem* elem = plist->head.next;
c000392c:	8b 45 08             	mov    0x8(%ebp),%eax
c000392f:	8b 40 04             	mov    0x4(%eax),%eax
c0003932:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:61
	while (elem != &plist->tail) {
c0003935:	eb 18                	jmp    c000394f <elem_find+0x29>
/work/x86_os_my/lib/kernel/list.c:62
	if (elem == obj_elem) {
c0003937:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000393a:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000393d:	75 07                	jne    c0003946 <elem_find+0x20>
/work/x86_os_my/lib/kernel/list.c:63
		return true;
c000393f:	b8 01 00 00 00       	mov    $0x1,%eax
c0003944:	eb 19                	jmp    c000395f <elem_find+0x39>
/work/x86_os_my/lib/kernel/list.c:65
	}
		elem = elem->next;
c0003946:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003949:	8b 40 04             	mov    0x4(%eax),%eax
c000394c:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:61
} 

/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */
bool elem_find(struct list* plist, struct list_elem* obj_elem) {
	struct list_elem* elem = plist->head.next;
	while (elem != &plist->tail) {
c000394f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003952:	83 c0 08             	add    $0x8,%eax
c0003955:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c0003958:	75 dd                	jne    c0003937 <elem_find+0x11>
/work/x86_os_my/lib/kernel/list.c:67
	if (elem == obj_elem) {
		return true;
	}
		elem = elem->next;
	}
	return false;
c000395a:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/kernel/list.c:68
}
c000395f:	c9                   	leave  
c0003960:	c3                   	ret    

c0003961 <list_traversal>:
list_traversal():
/work/x86_os_my/lib/kernel/list.c:74

/* 把列表plist中的每个元素elem和arg传给回调函数func,
 * arg给func用来判断elem是否符合条件.
 * 本函数的功能是遍历列表内所有元素,逐个判断是否有符合条件的元素。
 * 找到符合条件的元素返回元素指针,否则返回NULL. */
struct list_elem* list_traversal(struct list* plist, function func, int arg) {
c0003961:	55                   	push   %ebp
c0003962:	89 e5                	mov    %esp,%ebp
c0003964:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:75
	struct list_elem* elem = plist->head.next;
c0003967:	8b 45 08             	mov    0x8(%ebp),%eax
c000396a:	8b 40 04             	mov    0x4(%eax),%eax
c000396d:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:77
	/* 如果队列为空,就必然没有符合条件的结点,故直接返回NULL */
	if (list_empty(plist)) { 
c0003970:	83 ec 0c             	sub    $0xc,%esp
c0003973:	ff 75 08             	pushl  0x8(%ebp)
c0003976:	e8 78 00 00 00       	call   c00039f3 <list_empty>
c000397b:	83 c4 10             	add    $0x10,%esp
c000397e:	85 c0                	test   %eax,%eax
c0003980:	74 2a                	je     c00039ac <list_traversal+0x4b>
/work/x86_os_my/lib/kernel/list.c:78
		return NULL;
c0003982:	b8 00 00 00 00       	mov    $0x0,%eax
c0003987:	eb 33                	jmp    c00039bc <list_traversal+0x5b>
/work/x86_os_my/lib/kernel/list.c:82
	}

	while (elem != &plist->tail) {
	if (func(elem, arg)) {		  // func返回ture则认为该元素在回调函数中符合条件,命中,故停止继续遍历
c0003989:	83 ec 08             	sub    $0x8,%esp
c000398c:	ff 75 10             	pushl  0x10(%ebp)
c000398f:	ff 75 f4             	pushl  -0xc(%ebp)
c0003992:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003995:	ff d0                	call   *%eax
c0003997:	83 c4 10             	add    $0x10,%esp
c000399a:	85 c0                	test   %eax,%eax
c000399c:	74 05                	je     c00039a3 <list_traversal+0x42>
/work/x86_os_my/lib/kernel/list.c:83
		return elem;
c000399e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00039a1:	eb 19                	jmp    c00039bc <list_traversal+0x5b>
/work/x86_os_my/lib/kernel/list.c:85
	}					  // 若回调函数func返回true,则继续遍历
		elem = elem->next;	       
c00039a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00039a6:	8b 40 04             	mov    0x4(%eax),%eax
c00039a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:81
	/* 如果队列为空,就必然没有符合条件的结点,故直接返回NULL */
	if (list_empty(plist)) { 
		return NULL;
	}

	while (elem != &plist->tail) {
c00039ac:	8b 45 08             	mov    0x8(%ebp),%eax
c00039af:	83 c0 08             	add    $0x8,%eax
c00039b2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00039b5:	75 d2                	jne    c0003989 <list_traversal+0x28>
/work/x86_os_my/lib/kernel/list.c:87
	if (func(elem, arg)) {		  // func返回ture则认为该元素在回调函数中符合条件,命中,故停止继续遍历
		return elem;
	}					  // 若回调函数func返回true,则继续遍历
		elem = elem->next;	       
	}
	return NULL;
c00039b7:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/kernel/list.c:88
}
c00039bc:	c9                   	leave  
c00039bd:	c3                   	ret    

c00039be <list_len>:
list_len():
/work/x86_os_my/lib/kernel/list.c:91

/* 返回链表长度 */
uint32_t list_len(struct list* plist) {
c00039be:	55                   	push   %ebp
c00039bf:	89 e5                	mov    %esp,%ebp
c00039c1:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:92
	struct list_elem* elem = plist->head.next;
c00039c4:	8b 45 08             	mov    0x8(%ebp),%eax
c00039c7:	8b 40 04             	mov    0x4(%eax),%eax
c00039ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:93
	uint32_t length = 0;
c00039cd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
/work/x86_os_my/lib/kernel/list.c:94
	while (elem != &plist->tail) {
c00039d4:	eb 0d                	jmp    c00039e3 <list_len+0x25>
/work/x86_os_my/lib/kernel/list.c:95
		length++; 
c00039d6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
/work/x86_os_my/lib/kernel/list.c:96
		elem = elem->next;
c00039da:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00039dd:	8b 40 04             	mov    0x4(%eax),%eax
c00039e0:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:94

/* 返回链表长度 */
uint32_t list_len(struct list* plist) {
	struct list_elem* elem = plist->head.next;
	uint32_t length = 0;
	while (elem != &plist->tail) {
c00039e3:	8b 45 08             	mov    0x8(%ebp),%eax
c00039e6:	83 c0 08             	add    $0x8,%eax
c00039e9:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c00039ec:	75 e8                	jne    c00039d6 <list_len+0x18>
/work/x86_os_my/lib/kernel/list.c:98
		length++; 
		elem = elem->next;
	}
	return length;
c00039ee:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/kernel/list.c:99
}
c00039f1:	c9                   	leave  
c00039f2:	c3                   	ret    

c00039f3 <list_empty>:
list_empty():
/work/x86_os_my/lib/kernel/list.c:102

/* 判断链表是否为空,空时返回true,否则返回false */
bool list_empty(struct list* plist) {		// 判断队列是否为空
c00039f3:	55                   	push   %ebp
c00039f4:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/lib/kernel/list.c:103
	return (plist->head.next == &plist->tail ? true : false);
c00039f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00039f9:	8b 40 04             	mov    0x4(%eax),%eax
c00039fc:	8b 55 08             	mov    0x8(%ebp),%edx
c00039ff:	83 c2 08             	add    $0x8,%edx
c0003a02:	39 d0                	cmp    %edx,%eax
c0003a04:	0f 94 c0             	sete   %al
c0003a07:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/lib/kernel/list.c:104
}
c0003a0a:	5d                   	pop    %ebp
c0003a0b:	c3                   	ret    
c0003a0c:	66 90                	xchg   %ax,%ax
c0003a0e:	66 90                	xchg   %ax,%ax

c0003a10 <switch_to>:
switch_to():
c0003a10:	56                   	push   %esi
c0003a11:	57                   	push   %edi
c0003a12:	53                   	push   %ebx
c0003a13:	55                   	push   %ebp
c0003a14:	8b 44 24 14          	mov    0x14(%esp),%eax
c0003a18:	89 20                	mov    %esp,(%eax)
c0003a1a:	8b 44 24 18          	mov    0x18(%esp),%eax
c0003a1e:	8b 20                	mov    (%eax),%esp
c0003a20:	5d                   	pop    %ebp
c0003a21:	5b                   	pop    %ebx
c0003a22:	5f                   	pop    %edi
c0003a23:	5e                   	pop    %esi
c0003a24:	c3                   	ret    

c0003a25 <console_init>:
console_init():
/work/x86_os_my/device/console.c:9
#include "sync.h"
#include "thread.h"
static struct lock console_lock;	// 控制台锁

/* 初始化终端 */
void console_init() {
c0003a25:	55                   	push   %ebp
c0003a26:	89 e5                	mov    %esp,%ebp
c0003a28:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:10
	lock_init(&console_lock);
c0003a2b:	83 ec 0c             	sub    $0xc,%esp
c0003a2e:	68 70 75 00 c0       	push   $0xc0007570
c0003a33:	e8 cd 00 00 00       	call   c0003b05 <lock_init>
c0003a38:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:11
}
c0003a3b:	90                   	nop
c0003a3c:	c9                   	leave  
c0003a3d:	c3                   	ret    

c0003a3e <console_acquire>:
console_acquire():
/work/x86_os_my/device/console.c:14

/* 获取终端 */
void console_acquire() {
c0003a3e:	55                   	push   %ebp
c0003a3f:	89 e5                	mov    %esp,%ebp
c0003a41:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:15
	lock_acquire(&console_lock);
c0003a44:	83 ec 0c             	sub    $0xc,%esp
c0003a47:	68 70 75 00 c0       	push   $0xc0007570
c0003a4c:	e8 8e 02 00 00       	call   c0003cdf <lock_acquire>
c0003a51:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:16
}
c0003a54:	90                   	nop
c0003a55:	c9                   	leave  
c0003a56:	c3                   	ret    

c0003a57 <console_release>:
console_release():
/work/x86_os_my/device/console.c:19

/* 释放终端 */
void console_release() {
c0003a57:	55                   	push   %ebp
c0003a58:	89 e5                	mov    %esp,%ebp
c0003a5a:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:20
	lock_release(&console_lock);
c0003a5d:	83 ec 0c             	sub    $0xc,%esp
c0003a60:	68 70 75 00 c0       	push   $0xc0007570
c0003a65:	e8 ec 02 00 00       	call   c0003d56 <lock_release>
c0003a6a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:21
}
c0003a6d:	90                   	nop
c0003a6e:	c9                   	leave  
c0003a6f:	c3                   	ret    

c0003a70 <console_put_str>:
console_put_str():
/work/x86_os_my/device/console.c:24

/* 终端中输出字符串 */
void console_put_str(char* str) {
c0003a70:	55                   	push   %ebp
c0003a71:	89 e5                	mov    %esp,%ebp
c0003a73:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:25
	console_acquire();
c0003a76:	e8 c3 ff ff ff       	call   c0003a3e <console_acquire>
/work/x86_os_my/device/console.c:26
	put_str(str);
c0003a7b:	83 ec 0c             	sub    $0xc,%esp
c0003a7e:	ff 75 08             	pushl  0x8(%ebp)
c0003a81:	e8 6a e7 ff ff       	call   c00021f0 <put_str>
c0003a86:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:27
	console_release();
c0003a89:	e8 c9 ff ff ff       	call   c0003a57 <console_release>
/work/x86_os_my/device/console.c:28
}
c0003a8e:	90                   	nop
c0003a8f:	c9                   	leave  
c0003a90:	c3                   	ret    

c0003a91 <console_put_char>:
console_put_char():
/work/x86_os_my/device/console.c:31

/* 终端中输出字符 */
void console_put_char(uint8_t char_asci) {
c0003a91:	55                   	push   %ebp
c0003a92:	89 e5                	mov    %esp,%ebp
c0003a94:	83 ec 18             	sub    $0x18,%esp
c0003a97:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a9a:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/console.c:32
	console_acquire();
c0003a9d:	e8 9c ff ff ff       	call   c0003a3e <console_acquire>
/work/x86_os_my/device/console.c:33
	put_char(char_asci);
c0003aa2:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0003aa6:	83 ec 0c             	sub    $0xc,%esp
c0003aa9:	50                   	push   %eax
c0003aaa:	e8 5f e7 ff ff       	call   c000220e <put_char>
c0003aaf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:34
	console_release();
c0003ab2:	e8 a0 ff ff ff       	call   c0003a57 <console_release>
/work/x86_os_my/device/console.c:35
}
c0003ab7:	90                   	nop
c0003ab8:	c9                   	leave  
c0003ab9:	c3                   	ret    

c0003aba <console_put_int>:
console_put_int():
/work/x86_os_my/device/console.c:38

/* 终端中输出16进制整数 */
void console_put_int(uint32_t num) {
c0003aba:	55                   	push   %ebp
c0003abb:	89 e5                	mov    %esp,%ebp
c0003abd:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:39
	console_acquire();
c0003ac0:	e8 79 ff ff ff       	call   c0003a3e <console_acquire>
/work/x86_os_my/device/console.c:40
	put_int(num);
c0003ac5:	83 ec 0c             	sub    $0xc,%esp
c0003ac8:	ff 75 08             	pushl  0x8(%ebp)
c0003acb:	e8 0b e8 ff ff       	call   c00022db <put_int>
c0003ad0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:41
	console_release();
c0003ad3:	e8 7f ff ff ff       	call   c0003a57 <console_release>
/work/x86_os_my/device/console.c:42
}
c0003ad8:	90                   	nop
c0003ad9:	c9                   	leave  
c0003ada:	c3                   	ret    

c0003adb <sema_init>:
sema_init():
/work/x86_os_my/thread/sync.c:8
#include "global.h"
#include "debug.h"
#include "interrupt.h"

/* 初始化信号量 */
void sema_init(struct semaphore* psema, uint8_t value) {
c0003adb:	55                   	push   %ebp
c0003adc:	89 e5                	mov    %esp,%ebp
c0003ade:	83 ec 18             	sub    $0x18,%esp
c0003ae1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003ae4:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:9
	psema->value = value;       // 为信号量赋初值
c0003ae7:	8b 45 08             	mov    0x8(%ebp),%eax
c0003aea:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0003aee:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:10
	list_init(&psema->waiters); //初始化信号量的等待队列
c0003af0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003af3:	83 c0 04             	add    $0x4,%eax
c0003af6:	83 ec 0c             	sub    $0xc,%esp
c0003af9:	50                   	push   %eax
c0003afa:	e8 1c fd ff ff       	call   c000381b <list_init>
c0003aff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:11
}
c0003b02:	90                   	nop
c0003b03:	c9                   	leave  
c0003b04:	c3                   	ret    

c0003b05 <lock_init>:
lock_init():
/work/x86_os_my/thread/sync.c:14

/* 初始化锁plock */
void lock_init(struct lock* plock) {
c0003b05:	55                   	push   %ebp
c0003b06:	89 e5                	mov    %esp,%ebp
c0003b08:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/sync.c:15
	plock->holder = NULL;
c0003b0b:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b0e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:16
	plock->holder_repeat_nr = 0;
c0003b14:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b17:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:17
	sema_init(&plock->semaphore, 1);  // 信号量初值为1
c0003b1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b21:	83 c0 04             	add    $0x4,%eax
c0003b24:	83 ec 08             	sub    $0x8,%esp
c0003b27:	6a 01                	push   $0x1
c0003b29:	50                   	push   %eax
c0003b2a:	e8 ac ff ff ff       	call   c0003adb <sema_init>
c0003b2f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:18
}
c0003b32:	90                   	nop
c0003b33:	c9                   	leave  
c0003b34:	c3                   	ret    

c0003b35 <sema_down>:
sema_down():
/work/x86_os_my/thread/sync.c:21

/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
c0003b35:	55                   	push   %ebp
c0003b36:	89 e5                	mov    %esp,%ebp
c0003b38:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:23
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
c0003b3b:	e8 f9 de ff ff       	call   c0001a39 <intr_disable>
c0003b40:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:25
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c0003b43:	e9 98 00 00 00       	jmp    c0003be0 <sema_down+0xab>
/work/x86_os_my/thread/sync.c:26
		ASSERT(!elem_find(&psema->waiters, &running_thread()->general_tag));
c0003b48:	e8 0d f7 ff ff       	call   c000325a <running_thread>
c0003b4d:	8d 50 24             	lea    0x24(%eax),%edx
c0003b50:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b53:	83 c0 04             	add    $0x4,%eax
c0003b56:	83 ec 08             	sub    $0x8,%esp
c0003b59:	52                   	push   %edx
c0003b5a:	50                   	push   %eax
c0003b5b:	e8 c6 fd ff ff       	call   c0003926 <elem_find>
c0003b60:	83 c4 10             	add    $0x10,%esp
c0003b63:	85 c0                	test   %eax,%eax
c0003b65:	74 19                	je     c0003b80 <sema_down+0x4b>
/work/x86_os_my/thread/sync.c:26 (discriminator 1)
c0003b67:	68 14 56 00 c0       	push   $0xc0005614
c0003b6c:	68 18 57 00 c0       	push   $0xc0005718
c0003b71:	6a 1a                	push   $0x1a
c0003b73:	68 50 56 00 c0       	push   $0xc0005650
c0003b78:	e8 e5 e7 ff ff       	call   c0002362 <panic_spin>
c0003b7d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:28
		/* 当前线程不应该已在信号量的waiters队列中 */
		if (elem_find(&psema->waiters, &running_thread()->general_tag)) {
c0003b80:	e8 d5 f6 ff ff       	call   c000325a <running_thread>
c0003b85:	8d 50 24             	lea    0x24(%eax),%edx
c0003b88:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b8b:	83 c0 04             	add    $0x4,%eax
c0003b8e:	83 ec 08             	sub    $0x8,%esp
c0003b91:	52                   	push   %edx
c0003b92:	50                   	push   %eax
c0003b93:	e8 8e fd ff ff       	call   c0003926 <elem_find>
c0003b98:	83 c4 10             	add    $0x10,%esp
c0003b9b:	85 c0                	test   %eax,%eax
c0003b9d:	74 19                	je     c0003bb8 <sema_down+0x83>
/work/x86_os_my/thread/sync.c:29
			PANIC("sema_down: thread blocked has been in waiters_list\n");
c0003b9f:	68 60 56 00 c0       	push   $0xc0005660
c0003ba4:	68 18 57 00 c0       	push   $0xc0005718
c0003ba9:	6a 1d                	push   $0x1d
c0003bab:	68 50 56 00 c0       	push   $0xc0005650
c0003bb0:	e8 ad e7 ff ff       	call   c0002362 <panic_spin>
c0003bb5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:32
		}
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
c0003bb8:	e8 9d f6 ff ff       	call   c000325a <running_thread>
c0003bbd:	8d 50 24             	lea    0x24(%eax),%edx
c0003bc0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bc3:	83 c0 04             	add    $0x4,%eax
c0003bc6:	83 ec 08             	sub    $0x8,%esp
c0003bc9:	52                   	push   %edx
c0003bca:	50                   	push   %eax
c0003bcb:	e8 dc fc ff ff       	call   c00038ac <list_append>
c0003bd0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:33
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
c0003bd3:	83 ec 0c             	sub    $0xc,%esp
c0003bd6:	6a 02                	push   $0x2
c0003bd8:	e8 83 fa ff ff       	call   c0003660 <thread_block>
c0003bdd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:25
/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c0003be0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003be3:	0f b6 00             	movzbl (%eax),%eax
c0003be6:	84 c0                	test   %al,%al
c0003be8:	0f 84 5a ff ff ff    	je     c0003b48 <sema_down+0x13>
/work/x86_os_my/thread/sync.c:36
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
	}
	/* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*/
	psema->value--;
c0003bee:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bf1:	0f b6 00             	movzbl (%eax),%eax
c0003bf4:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003bf7:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bfa:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:37
	ASSERT(psema->value == 0);
c0003bfc:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bff:	0f b6 00             	movzbl (%eax),%eax
c0003c02:	84 c0                	test   %al,%al
c0003c04:	74 19                	je     c0003c1f <sema_down+0xea>
/work/x86_os_my/thread/sync.c:37 (discriminator 1)
c0003c06:	68 94 56 00 c0       	push   $0xc0005694
c0003c0b:	68 18 57 00 c0       	push   $0xc0005718
c0003c10:	6a 25                	push   $0x25
c0003c12:	68 50 56 00 c0       	push   $0xc0005650
c0003c17:	e8 46 e7 ff ff       	call   c0002362 <panic_spin>
c0003c1c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:40
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c0003c1f:	83 ec 0c             	sub    $0xc,%esp
c0003c22:	ff 75 f4             	pushl  -0xc(%ebp)
c0003c25:	e8 38 de ff ff       	call   c0001a62 <intr_set_status>
c0003c2a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:41
}
c0003c2d:	90                   	nop
c0003c2e:	c9                   	leave  
c0003c2f:	c3                   	ret    

c0003c30 <sema_up>:
sema_up():
/work/x86_os_my/thread/sync.c:44

/* 信号量的up操作 */
void sema_up(struct semaphore* psema) {
c0003c30:	55                   	push   %ebp
c0003c31:	89 e5                	mov    %esp,%ebp
c0003c33:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:46
	/* 关中断,保证原子操作 */
	enum intr_status old_status = intr_disable();
c0003c36:	e8 fe dd ff ff       	call   c0001a39 <intr_disable>
c0003c3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:48
	
	ASSERT(psema->value == 0);
c0003c3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c41:	0f b6 00             	movzbl (%eax),%eax
c0003c44:	84 c0                	test   %al,%al
c0003c46:	74 19                	je     c0003c61 <sema_up+0x31>
/work/x86_os_my/thread/sync.c:48 (discriminator 1)
c0003c48:	68 94 56 00 c0       	push   $0xc0005694
c0003c4d:	68 24 57 00 c0       	push   $0xc0005724
c0003c52:	6a 30                	push   $0x30
c0003c54:	68 50 56 00 c0       	push   $0xc0005650
c0003c59:	e8 04 e7 ff ff       	call   c0002362 <panic_spin>
c0003c5e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:49
	if (!list_empty(&psema->waiters)) {
c0003c61:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c64:	83 c0 04             	add    $0x4,%eax
c0003c67:	83 ec 0c             	sub    $0xc,%esp
c0003c6a:	50                   	push   %eax
c0003c6b:	e8 83 fd ff ff       	call   c00039f3 <list_empty>
c0003c70:	83 c4 10             	add    $0x10,%esp
c0003c73:	85 c0                	test   %eax,%eax
c0003c75:	75 26                	jne    c0003c9d <sema_up+0x6d>
/work/x86_os_my/thread/sync.c:50
		struct task_struct* thread_blocked = elem2entry(struct task_struct, general_tag, list_pop(&psema->waiters));
c0003c77:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c7a:	83 c0 04             	add    $0x4,%eax
c0003c7d:	83 ec 0c             	sub    $0xc,%esp
c0003c80:	50                   	push   %eax
c0003c81:	e8 7e fc ff ff       	call   c0003904 <list_pop>
c0003c86:	83 c4 10             	add    $0x10,%esp
c0003c89:	83 e8 24             	sub    $0x24,%eax
c0003c8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/sync.c:51
		thread_unblock(thread_blocked);
c0003c8f:	83 ec 0c             	sub    $0xc,%esp
c0003c92:	ff 75 f0             	pushl  -0x10(%ebp)
c0003c95:	e8 29 fa ff ff       	call   c00036c3 <thread_unblock>
c0003c9a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:53
	}
	psema->value++;
c0003c9d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ca0:	0f b6 00             	movzbl (%eax),%eax
c0003ca3:	8d 50 01             	lea    0x1(%eax),%edx
c0003ca6:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ca9:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:54
	ASSERT(psema->value == 1);
c0003cab:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cae:	0f b6 00             	movzbl (%eax),%eax
c0003cb1:	3c 01                	cmp    $0x1,%al
c0003cb3:	74 19                	je     c0003cce <sema_up+0x9e>
/work/x86_os_my/thread/sync.c:54 (discriminator 1)
c0003cb5:	68 a6 56 00 c0       	push   $0xc00056a6
c0003cba:	68 24 57 00 c0       	push   $0xc0005724
c0003cbf:	6a 36                	push   $0x36
c0003cc1:	68 50 56 00 c0       	push   $0xc0005650
c0003cc6:	e8 97 e6 ff ff       	call   c0002362 <panic_spin>
c0003ccb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:57
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c0003cce:	83 ec 0c             	sub    $0xc,%esp
c0003cd1:	ff 75 f4             	pushl  -0xc(%ebp)
c0003cd4:	e8 89 dd ff ff       	call   c0001a62 <intr_set_status>
c0003cd9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:58
}
c0003cdc:	90                   	nop
c0003cdd:	c9                   	leave  
c0003cde:	c3                   	ret    

c0003cdf <lock_acquire>:
lock_acquire():
/work/x86_os_my/thread/sync.c:61

/* 获取锁plock */
void lock_acquire(struct lock* plock) {
c0003cdf:	55                   	push   %ebp
c0003ce0:	89 e5                	mov    %esp,%ebp
c0003ce2:	53                   	push   %ebx
c0003ce3:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:63
	/* 排除曾经自己已经持有锁但还未将其释放的情况。*/
	if (plock->holder != running_thread()) {
c0003ce6:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ce9:	8b 18                	mov    (%eax),%ebx
c0003ceb:	e8 6a f5 ff ff       	call   c000325a <running_thread>
c0003cf0:	39 c3                	cmp    %eax,%ebx
c0003cf2:	74 4d                	je     c0003d41 <lock_acquire+0x62>
/work/x86_os_my/thread/sync.c:64
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
c0003cf4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cf7:	83 c0 04             	add    $0x4,%eax
c0003cfa:	83 ec 0c             	sub    $0xc,%esp
c0003cfd:	50                   	push   %eax
c0003cfe:	e8 32 fe ff ff       	call   c0003b35 <sema_down>
c0003d03:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:65
		plock->holder = running_thread();
c0003d06:	e8 4f f5 ff ff       	call   c000325a <running_thread>
c0003d0b:	89 c2                	mov    %eax,%edx
c0003d0d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d10:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/sync.c:66
		ASSERT(plock->holder_repeat_nr == 0);
c0003d12:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d15:	8b 40 18             	mov    0x18(%eax),%eax
c0003d18:	85 c0                	test   %eax,%eax
c0003d1a:	74 19                	je     c0003d35 <lock_acquire+0x56>
/work/x86_os_my/thread/sync.c:66 (discriminator 1)
c0003d1c:	68 b8 56 00 c0       	push   $0xc00056b8
c0003d21:	68 2c 57 00 c0       	push   $0xc000572c
c0003d26:	6a 42                	push   $0x42
c0003d28:	68 50 56 00 c0       	push   $0xc0005650
c0003d2d:	e8 30 e6 ff ff       	call   c0002362 <panic_spin>
c0003d32:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:67
		plock->holder_repeat_nr = 1;
c0003d35:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d38:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	} else {
		plock->holder_repeat_nr++;
	}
}
c0003d3f:	eb 0f                	jmp    c0003d50 <lock_acquire+0x71>
/work/x86_os_my/thread/sync.c:69
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
		plock->holder = running_thread();
		ASSERT(plock->holder_repeat_nr == 0);
		plock->holder_repeat_nr = 1;
	} else {
		plock->holder_repeat_nr++;
c0003d41:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d44:	8b 40 18             	mov    0x18(%eax),%eax
c0003d47:	8d 50 01             	lea    0x1(%eax),%edx
c0003d4a:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d4d:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	}
}
c0003d50:	90                   	nop
c0003d51:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0003d54:	c9                   	leave  
c0003d55:	c3                   	ret    

c0003d56 <lock_release>:
lock_release():
/work/x86_os_my/thread/sync.c:74

/* 释放锁plock */
void lock_release(struct lock* plock) {
c0003d56:	55                   	push   %ebp
c0003d57:	89 e5                	mov    %esp,%ebp
c0003d59:	53                   	push   %ebx
c0003d5a:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:75
	ASSERT(plock->holder == running_thread());
c0003d5d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d60:	8b 18                	mov    (%eax),%ebx
c0003d62:	e8 f3 f4 ff ff       	call   c000325a <running_thread>
c0003d67:	39 c3                	cmp    %eax,%ebx
c0003d69:	74 19                	je     c0003d84 <lock_release+0x2e>
/work/x86_os_my/thread/sync.c:75 (discriminator 1)
c0003d6b:	68 d8 56 00 c0       	push   $0xc00056d8
c0003d70:	68 3c 57 00 c0       	push   $0xc000573c
c0003d75:	6a 4b                	push   $0x4b
c0003d77:	68 50 56 00 c0       	push   $0xc0005650
c0003d7c:	e8 e1 e5 ff ff       	call   c0002362 <panic_spin>
c0003d81:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:76
	if (plock->holder_repeat_nr > 1) {
c0003d84:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d87:	8b 40 18             	mov    0x18(%eax),%eax
c0003d8a:	83 f8 01             	cmp    $0x1,%eax
c0003d8d:	76 11                	jbe    c0003da0 <lock_release+0x4a>
/work/x86_os_my/thread/sync.c:77
		plock->holder_repeat_nr--;
c0003d8f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d92:	8b 40 18             	mov    0x18(%eax),%eax
c0003d95:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003d98:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d9b:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:78
		return;
c0003d9e:	eb 49                	jmp    c0003de9 <lock_release+0x93>
/work/x86_os_my/thread/sync.c:80
	}
	ASSERT(plock->holder_repeat_nr == 1);
c0003da0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003da3:	8b 40 18             	mov    0x18(%eax),%eax
c0003da6:	83 f8 01             	cmp    $0x1,%eax
c0003da9:	74 19                	je     c0003dc4 <lock_release+0x6e>
/work/x86_os_my/thread/sync.c:80 (discriminator 1)
c0003dab:	68 fa 56 00 c0       	push   $0xc00056fa
c0003db0:	68 3c 57 00 c0       	push   $0xc000573c
c0003db5:	6a 50                	push   $0x50
c0003db7:	68 50 56 00 c0       	push   $0xc0005650
c0003dbc:	e8 a1 e5 ff ff       	call   c0002362 <panic_spin>
c0003dc1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:82

	plock->holder = NULL;			// 把锁的持有者置空放在V操作之前
c0003dc4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003dc7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:83
	plock->holder_repeat_nr = 0;
c0003dcd:	8b 45 08             	mov    0x8(%ebp),%eax
c0003dd0:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:84
	sema_up(&plock->semaphore);		// 信号量的V操作,也是原子操作
c0003dd7:	8b 45 08             	mov    0x8(%ebp),%eax
c0003dda:	83 c0 04             	add    $0x4,%eax
c0003ddd:	83 ec 0c             	sub    $0xc,%esp
c0003de0:	50                   	push   %eax
c0003de1:	e8 4a fe ff ff       	call   c0003c30 <sema_up>
c0003de6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:85
}
c0003de9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0003dec:	c9                   	leave  
c0003ded:	c3                   	ret    

c0003dee <inb>:
inb():
/work/x86_os_my/lib/kernel/io.h:36
   asm volatile ("cld; rep outsw" : "+S" (addr), "+c" (word_cnt) : "d" (port));
/******************************************************/
}

/* 将从端口port读入的一个字节返回 */
static inline uint8_t inb(uint16_t port) {
c0003dee:	55                   	push   %ebp
c0003def:	89 e5                	mov    %esp,%ebp
c0003df1:	83 ec 14             	sub    $0x14,%esp
c0003df4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003df7:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/io.h:38
   uint8_t data;
   asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0003dfb:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0003dff:	89 c2                	mov    %eax,%edx
c0003e01:	ec                   	in     (%dx),%al
c0003e02:	88 45 ff             	mov    %al,-0x1(%ebp)
/work/x86_os_my/lib/kernel/io.h:39
   return data;
c0003e05:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
/work/x86_os_my/lib/kernel/io.h:40
}
c0003e09:	c9                   	leave  
c0003e0a:	c3                   	ret    

c0003e0b <intr_keyboard_handler>:
intr_keyboard_handler():
/work/x86_os_my/device/keyboard.c:111
/* 0x3A */	{caps_lock_char, caps_lock_char}
/*其它按键暂不处理*/
};

/* 键盘中断处理程序 */
static void intr_keyboard_handler(void) {
c0003e0b:	55                   	push   %ebp
c0003e0c:	89 e5                	mov    %esp,%ebp
c0003e0e:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/device/keyboard.c:114

/* 这次中断发生前的上一次中断,以下任意三个键是否有按下 */
   bool ctrl_down_last = ctrl_status;	  
c0003e11:	a1 8c 75 00 c0       	mov    0xc000758c,%eax
c0003e16:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/device/keyboard.c:115
   bool shift_down_last = shift_status;
c0003e19:	a1 90 75 00 c0       	mov    0xc0007590,%eax
c0003e1e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/device/keyboard.c:116
   bool caps_lock_last = caps_lock_status;
c0003e21:	a1 98 75 00 c0       	mov    0xc0007598,%eax
c0003e26:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/device/keyboard.c:119

   bool break_code;
   uint16_t scancode = inb(KBD_BUF_PORT);
c0003e29:	6a 60                	push   $0x60
c0003e2b:	e8 be ff ff ff       	call   c0003dee <inb>
c0003e30:	83 c4 04             	add    $0x4,%esp
c0003e33:	0f b6 c0             	movzbl %al,%eax
c0003e36:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:123

/* 若扫描码是e0开头的,表示此键的按下将产生多个扫描码,
 * 所以马上结束此次中断处理函数,等待下一个扫描码进来*/ 
   if (scancode == 0xe0) { 
c0003e3a:	66 81 7d f6 e0 00    	cmpw   $0xe0,-0xa(%ebp)
c0003e40:	75 0f                	jne    c0003e51 <intr_keyboard_handler+0x46>
/work/x86_os_my/device/keyboard.c:124
      ext_scancode = true;    // 打开e0标记
c0003e42:	c7 05 9c 75 00 c0 01 	movl   $0x1,0xc000759c
c0003e49:	00 00 00 
/work/x86_os_my/device/keyboard.c:125
      return;
c0003e4c:	e9 50 02 00 00       	jmp    c00040a1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:129
   }

/* 如果上次是以0xe0开头,将扫描码合并 */
   if (ext_scancode) {
c0003e51:	a1 9c 75 00 c0       	mov    0xc000759c,%eax
c0003e56:	85 c0                	test   %eax,%eax
c0003e58:	74 10                	je     c0003e6a <intr_keyboard_handler+0x5f>
/work/x86_os_my/device/keyboard.c:130
      scancode = ((0xe000) | scancode);
c0003e5a:	66 81 4d f6 00 e0    	orw    $0xe000,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:131
      ext_scancode = false;   // 关闭e0标记
c0003e60:	c7 05 9c 75 00 c0 00 	movl   $0x0,0xc000759c
c0003e67:	00 00 00 
/work/x86_os_my/device/keyboard.c:134
   }   

   break_code = ((scancode & 0x0080) != 0);   // 获取break_code
c0003e6a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0003e6e:	25 80 00 00 00       	and    $0x80,%eax
c0003e73:	85 c0                	test   %eax,%eax
c0003e75:	0f 95 c0             	setne  %al
c0003e78:	0f b6 c0             	movzbl %al,%eax
c0003e7b:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/device/keyboard.c:136
   
   if (break_code) {   // 若是断码break_code(按键弹起时产生的扫描码)
c0003e7e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0003e82:	74 6a                	je     c0003eee <intr_keyboard_handler+0xe3>
/work/x86_os_my/device/keyboard.c:140

   /* 由于ctrl_r 和alt_r的make_code和break_code都是两字节,
   所以可用下面的方法取make_code,多字节的扫描码暂不处理 */
      uint16_t make_code = (scancode &= 0xff7f);   // 得到其make_code(按键按下时产生的扫描码)
c0003e84:	66 81 65 f6 7f ff    	andw   $0xff7f,-0xa(%ebp)
c0003e8a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0003e8e:	66 89 45 da          	mov    %ax,-0x26(%ebp)
/work/x86_os_my/device/keyboard.c:143

   /* 若是任意以下三个键弹起了,将状态置为false */
      if (make_code == ctrl_l_make || make_code == ctrl_r_make) {
c0003e92:	66 83 7d da 1d       	cmpw   $0x1d,-0x26(%ebp)
c0003e97:	74 08                	je     c0003ea1 <intr_keyboard_handler+0x96>
/work/x86_os_my/device/keyboard.c:143 (discriminator 1)
c0003e99:	66 81 7d da 1d e0    	cmpw   $0xe01d,-0x26(%ebp)
c0003e9f:	75 0c                	jne    c0003ead <intr_keyboard_handler+0xa2>
/work/x86_os_my/device/keyboard.c:144
	 ctrl_status = false;
c0003ea1:	c7 05 8c 75 00 c0 00 	movl   $0x0,0xc000758c
c0003ea8:	00 00 00 
c0003eab:	eb 3c                	jmp    c0003ee9 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:145
      } else if (make_code == shift_l_make || make_code == shift_r_make) {
c0003ead:	66 83 7d da 2a       	cmpw   $0x2a,-0x26(%ebp)
c0003eb2:	74 07                	je     c0003ebb <intr_keyboard_handler+0xb0>
/work/x86_os_my/device/keyboard.c:145 (discriminator 1)
c0003eb4:	66 83 7d da 36       	cmpw   $0x36,-0x26(%ebp)
c0003eb9:	75 0c                	jne    c0003ec7 <intr_keyboard_handler+0xbc>
/work/x86_os_my/device/keyboard.c:146
	 shift_status = false;
c0003ebb:	c7 05 90 75 00 c0 00 	movl   $0x0,0xc0007590
c0003ec2:	00 00 00 
c0003ec5:	eb 22                	jmp    c0003ee9 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:147
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
c0003ec7:	66 83 7d da 38       	cmpw   $0x38,-0x26(%ebp)
c0003ecc:	74 0c                	je     c0003eda <intr_keyboard_handler+0xcf>
/work/x86_os_my/device/keyboard.c:147 (discriminator 1)
c0003ece:	66 81 7d da 38 e0    	cmpw   $0xe038,-0x26(%ebp)
c0003ed4:	0f 85 c0 01 00 00    	jne    c000409a <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:148
	 alt_status = false;
c0003eda:	c7 05 94 75 00 c0 00 	movl   $0x0,0xc0007594
c0003ee1:	00 00 00 
/work/x86_os_my/device/keyboard.c:151
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c0003ee4:	e9 b1 01 00 00       	jmp    c000409a <intr_keyboard_handler+0x28f>
c0003ee9:	e9 ac 01 00 00       	jmp    c000409a <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:155

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
c0003eee:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c0003ef3:	74 07                	je     c0003efc <intr_keyboard_handler+0xf1>
/work/x86_os_my/device/keyboard.c:155 (discriminator 1)
c0003ef5:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0003efa:	76 14                	jbe    c0003f10 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:155 (discriminator 3)
c0003efc:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c0003f02:	74 0c                	je     c0003f10 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:156
	       (scancode == alt_r_make) || \
c0003f04:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0003f0a:	0f 85 78 01 00 00    	jne    c0004088 <intr_keyboard_handler+0x27d>
/work/x86_os_my/device/keyboard.c:158
	       (scancode == ctrl_r_make)) {
      bool shift = false;  // 判断是否与shift组合,用来在一维数组中索引对应的字符
c0003f10:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:159
      if ((scancode < 0x0e) || (scancode == 0x29) || \
c0003f17:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%ebp)
c0003f1c:	76 3f                	jbe    c0003f5d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 1)
c0003f1e:	66 83 7d f6 29       	cmpw   $0x29,-0xa(%ebp)
c0003f23:	74 38                	je     c0003f5d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 2)
c0003f25:	66 83 7d f6 1a       	cmpw   $0x1a,-0xa(%ebp)
c0003f2a:	74 31                	je     c0003f5d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160
	 (scancode == 0x1a) || (scancode == 0x1b) || \
c0003f2c:	66 83 7d f6 1b       	cmpw   $0x1b,-0xa(%ebp)
c0003f31:	74 2a                	je     c0003f5d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160 (discriminator 1)
c0003f33:	66 83 7d f6 2b       	cmpw   $0x2b,-0xa(%ebp)
c0003f38:	74 23                	je     c0003f5d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161
	 (scancode == 0x2b) || (scancode == 0x27) || \
c0003f3a:	66 83 7d f6 27       	cmpw   $0x27,-0xa(%ebp)
c0003f3f:	74 1c                	je     c0003f5d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161 (discriminator 1)
c0003f41:	66 83 7d f6 28       	cmpw   $0x28,-0xa(%ebp)
c0003f46:	74 15                	je     c0003f5d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162
	 (scancode == 0x28) || (scancode == 0x33) || \
c0003f48:	66 83 7d f6 33       	cmpw   $0x33,-0xa(%ebp)
c0003f4d:	74 0e                	je     c0003f5d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162 (discriminator 1)
c0003f4f:	66 83 7d f6 34       	cmpw   $0x34,-0xa(%ebp)
c0003f54:	74 07                	je     c0003f5d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:163
	 (scancode == 0x34) || (scancode == 0x35)) {  
c0003f56:	66 83 7d f6 35       	cmpw   $0x35,-0xa(%ebp)
c0003f5b:	75 0f                	jne    c0003f6c <intr_keyboard_handler+0x161>
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c0003f5d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0003f61:	74 3a                	je     c0003f9d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:177
	    shift = true;
c0003f63:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c0003f6a:	eb 31                	jmp    c0003f9d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:180
	    shift = true;
	 }
      } else {	  // 默认为字母键
	 if (shift_down_last && caps_lock_last) {  // 如果shift和capslock同时按下
c0003f6c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0003f70:	74 0f                	je     c0003f81 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:180 (discriminator 1)
c0003f72:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0003f76:	74 09                	je     c0003f81 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:181
	    shift = false;
c0003f78:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0003f7f:	eb 1c                	jmp    c0003f9d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:182
	 } else if (shift_down_last || caps_lock_last) { // 如果shift和capslock任意被按下
c0003f81:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0003f85:	75 06                	jne    c0003f8d <intr_keyboard_handler+0x182>
/work/x86_os_my/device/keyboard.c:182 (discriminator 1)
c0003f87:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0003f8b:	74 09                	je     c0003f96 <intr_keyboard_handler+0x18b>
/work/x86_os_my/device/keyboard.c:183
	    shift = true;
c0003f8d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c0003f94:	eb 07                	jmp    c0003f9d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:185
	 } else {
	    shift = false;
c0003f96:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:189
	 }
      }

      uint8_t index = (scancode &= 0x00ff);  // 将扫描码的高字节置0,主要是针对高字节是e0的扫描码.
c0003f9d:	66 81 65 f6 ff 00    	andw   $0xff,-0xa(%ebp)
c0003fa3:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0003fa7:	88 45 d9             	mov    %al,-0x27(%ebp)
/work/x86_os_my/device/keyboard.c:190
      char cur_char = keymap[index][shift];  // 在数组中找到对应的字符
c0003faa:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
c0003fae:	8d 14 00             	lea    (%eax,%eax,1),%edx
c0003fb1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003fb4:	01 d0                	add    %edx,%eax
c0003fb6:	05 e0 70 00 c0       	add    $0xc00070e0,%eax
c0003fbb:	0f b6 00             	movzbl (%eax),%eax
c0003fbe:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:193

   /* 如果cur_char不为0,也就是ascii码为除'\0'外的字符就加入键盘缓冲区中 */
      if (cur_char) {
c0003fc1:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c0003fc5:	74 54                	je     c000401b <intr_keyboard_handler+0x210>
/work/x86_os_my/device/keyboard.c:200
     /*****************  快捷键ctrl+l和ctrl+u的处理 *********************
      * 下面是把ctrl+l和ctrl+u这两种组合键产生的字符置为:
      * cur_char的asc码-字符a的asc码, 此差值比较小,
      * 属于asc码表中不可见的字符部分.故不会产生可见字符.
      * 我们在shell中将ascii值为l-a和u-a的分别处理为清屏和删除输入的快捷键*/
	 if ((ctrl_down_last && cur_char == 'l') || (ctrl_down_last && cur_char == 'u')) {
c0003fc7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0003fcb:	74 06                	je     c0003fd3 <intr_keyboard_handler+0x1c8>
/work/x86_os_my/device/keyboard.c:200 (discriminator 1)
c0003fcd:	80 7d ef 6c          	cmpb   $0x6c,-0x11(%ebp)
c0003fd1:	74 0c                	je     c0003fdf <intr_keyboard_handler+0x1d4>
/work/x86_os_my/device/keyboard.c:200 (discriminator 3)
c0003fd3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0003fd7:	74 10                	je     c0003fe9 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:200 (discriminator 4)
c0003fd9:	80 7d ef 75          	cmpb   $0x75,-0x11(%ebp)
c0003fdd:	75 0a                	jne    c0003fe9 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:201
	    cur_char -= 'a';
c0003fdf:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c0003fe3:	83 e8 61             	sub    $0x61,%eax
c0003fe6:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:207
	 }
      /****************************************************************/
      
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
c0003fe9:	83 ec 0c             	sub    $0xc,%esp
c0003fec:	68 20 7b 00 c0       	push   $0xc0007b20
c0003ff1:	e8 58 01 00 00       	call   c000414e <ioq_full>
c0003ff6:	83 c4 10             	add    $0x10,%esp
c0003ff9:	85 c0                	test   %eax,%eax
c0003ffb:	0f 85 9c 00 00 00    	jne    c000409d <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:208
	    ioq_putchar(&kbd_buf, cur_char);
c0004001:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
c0004005:	83 ec 08             	sub    $0x8,%esp
c0004008:	50                   	push   %eax
c0004009:	68 20 7b 00 c0       	push   $0xc0007b20
c000400e:	e8 0d 03 00 00       	call   c0004320 <ioq_putchar>
c0004013:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:210
	 }
	 return;
c0004016:	e9 82 00 00 00       	jmp    c000409d <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:214
      }

      /* 记录本次是否按下了下面几类控制键之一,供下次键入时判断组合键 */
      if (scancode == ctrl_l_make || scancode == ctrl_r_make) {
c000401b:	66 83 7d f6 1d       	cmpw   $0x1d,-0xa(%ebp)
c0004020:	74 08                	je     c000402a <intr_keyboard_handler+0x21f>
/work/x86_os_my/device/keyboard.c:214 (discriminator 1)
c0004022:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0004028:	75 0c                	jne    c0004036 <intr_keyboard_handler+0x22b>
/work/x86_os_my/device/keyboard.c:215
	 ctrl_status = true;
c000402a:	c7 05 8c 75 00 c0 01 	movl   $0x1,0xc000758c
c0004031:	00 00 00 
c0004034:	eb 50                	jmp    c0004086 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:216
      } else if (scancode == shift_l_make || scancode == shift_r_make) {
c0004036:	66 83 7d f6 2a       	cmpw   $0x2a,-0xa(%ebp)
c000403b:	74 07                	je     c0004044 <intr_keyboard_handler+0x239>
/work/x86_os_my/device/keyboard.c:216 (discriminator 1)
c000403d:	66 83 7d f6 36       	cmpw   $0x36,-0xa(%ebp)
c0004042:	75 0c                	jne    c0004050 <intr_keyboard_handler+0x245>
/work/x86_os_my/device/keyboard.c:217
	 shift_status = true;
c0004044:	c7 05 90 75 00 c0 01 	movl   $0x1,0xc0007590
c000404b:	00 00 00 
c000404e:	eb 36                	jmp    c0004086 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:218
      } else if (scancode == alt_l_make || scancode == alt_r_make) {
c0004050:	66 83 7d f6 38       	cmpw   $0x38,-0xa(%ebp)
c0004055:	74 08                	je     c000405f <intr_keyboard_handler+0x254>
/work/x86_os_my/device/keyboard.c:218 (discriminator 1)
c0004057:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c000405d:	75 0c                	jne    c000406b <intr_keyboard_handler+0x260>
/work/x86_os_my/device/keyboard.c:219
	 alt_status = true;
c000405f:	c7 05 94 75 00 c0 01 	movl   $0x1,0xc0007594
c0004066:	00 00 00 
c0004069:	eb 1b                	jmp    c0004086 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:220
      } else if (scancode == caps_lock_make) {
c000406b:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0004070:	75 2e                	jne    c00040a0 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:223
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
c0004072:	a1 98 75 00 c0       	mov    0xc0007598,%eax
c0004077:	85 c0                	test   %eax,%eax
c0004079:	0f 94 c0             	sete   %al
c000407c:	0f b6 c0             	movzbl %al,%eax
c000407f:	a3 98 75 00 c0       	mov    %eax,0xc0007598
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c0004084:	eb 1a                	jmp    c00040a0 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:157 (discriminator 3)
c0004086:	eb 18                	jmp    c00040a0 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:226
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
c0004088:	83 ec 0c             	sub    $0xc,%esp
c000408b:	68 49 57 00 c0       	push   $0xc0005749
c0004090:	e8 5b e1 ff ff       	call   c00021f0 <put_str>
c0004095:	83 c4 10             	add    $0x10,%esp
c0004098:	eb 07                	jmp    c00040a1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:151
	 shift_status = false;
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
	 alt_status = false;
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c000409a:	90                   	nop
c000409b:	eb 04                	jmp    c00040a1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:210
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
	    ioq_putchar(&kbd_buf, cur_char);
	 }
	 return;
c000409d:	90                   	nop
c000409e:	eb 01                	jmp    c00040a1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c00040a0:	90                   	nop
/work/x86_os_my/device/keyboard.c:228
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
   }
}
c00040a1:	c9                   	leave  
c00040a2:	c3                   	ret    

c00040a3 <keyboard_init>:
keyboard_init():
/work/x86_os_my/device/keyboard.c:231

/* 键盘初始化 */
void keyboard_init() {
c00040a3:	55                   	push   %ebp
c00040a4:	89 e5                	mov    %esp,%ebp
c00040a6:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/keyboard.c:232
   put_str("keyboard init start\n");
c00040a9:	83 ec 0c             	sub    $0xc,%esp
c00040ac:	68 56 57 00 c0       	push   $0xc0005756
c00040b1:	e8 3a e1 ff ff       	call   c00021f0 <put_str>
c00040b6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:233
   ioqueue_init(&kbd_buf);
c00040b9:	83 ec 0c             	sub    $0xc,%esp
c00040bc:	68 20 7b 00 c0       	push   $0xc0007b20
c00040c1:	e8 28 00 00 00       	call   c00040ee <ioqueue_init>
c00040c6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:234
   register_handler(0x21, intr_keyboard_handler);
c00040c9:	83 ec 08             	sub    $0x8,%esp
c00040cc:	68 0b 3e 00 c0       	push   $0xc0003e0b
c00040d1:	6a 21                	push   $0x21
c00040d3:	e8 cc d9 ff ff       	call   c0001aa4 <register_handler>
c00040d8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:235
   put_str("keyboard init done\n");
c00040db:	83 ec 0c             	sub    $0xc,%esp
c00040de:	68 6b 57 00 c0       	push   $0xc000576b
c00040e3:	e8 08 e1 ff ff       	call   c00021f0 <put_str>
c00040e8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:236
}
c00040eb:	90                   	nop
c00040ec:	c9                   	leave  
c00040ed:	c3                   	ret    

c00040ee <ioqueue_init>:
ioqueue_init():
/work/x86_os_my/device/ioqueue.c:7
#include "interrupt.h"
#include "global.h"
#include "debug.h"

/* 初始化io队列ioq */
void ioqueue_init(struct ioqueue* ioq) {
c00040ee:	55                   	push   %ebp
c00040ef:	89 e5                	mov    %esp,%ebp
c00040f1:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:8
   lock_init(&ioq->lock);     // 初始化io队列的锁
c00040f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00040f7:	83 ec 0c             	sub    $0xc,%esp
c00040fa:	50                   	push   %eax
c00040fb:	e8 05 fa ff ff       	call   c0003b05 <lock_init>
c0004100:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:9
   ioq->producer = ioq->consumer = NULL;  // 生产者和消费者置空
c0004103:	8b 45 08             	mov    0x8(%ebp),%eax
c0004106:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c000410d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004110:	8b 50 20             	mov    0x20(%eax),%edx
c0004113:	8b 45 08             	mov    0x8(%ebp),%eax
c0004116:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/device/ioqueue.c:10
   ioq->head = ioq->tail = 0; // 队列的首尾指针指向缓冲区数组第0个位置
c0004119:	8b 45 08             	mov    0x8(%ebp),%eax
c000411c:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)
c0004123:	8b 45 08             	mov    0x8(%ebp),%eax
c0004126:	8b 50 68             	mov    0x68(%eax),%edx
c0004129:	8b 45 08             	mov    0x8(%ebp),%eax
c000412c:	89 50 64             	mov    %edx,0x64(%eax)
/work/x86_os_my/device/ioqueue.c:11
}
c000412f:	90                   	nop
c0004130:	c9                   	leave  
c0004131:	c3                   	ret    

c0004132 <next_pos>:
next_pos():
/work/x86_os_my/device/ioqueue.c:14

/* 返回pos在缓冲区中的下一个位置值 */
static int32_t next_pos(int32_t pos) {
c0004132:	55                   	push   %ebp
c0004133:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/device/ioqueue.c:15
   return (pos + 1) % bufsize; 
c0004135:	8b 45 08             	mov    0x8(%ebp),%eax
c0004138:	8d 50 01             	lea    0x1(%eax),%edx
c000413b:	89 d0                	mov    %edx,%eax
c000413d:	c1 f8 1f             	sar    $0x1f,%eax
c0004140:	c1 e8 1a             	shr    $0x1a,%eax
c0004143:	01 c2                	add    %eax,%edx
c0004145:	83 e2 3f             	and    $0x3f,%edx
c0004148:	29 c2                	sub    %eax,%edx
c000414a:	89 d0                	mov    %edx,%eax
/work/x86_os_my/device/ioqueue.c:16
}
c000414c:	5d                   	pop    %ebp
c000414d:	c3                   	ret    

c000414e <ioq_full>:
ioq_full():
/work/x86_os_my/device/ioqueue.c:19

/* 判断队列是否已满 */
bool ioq_full(struct ioqueue* ioq) {
c000414e:	55                   	push   %ebp
c000414f:	89 e5                	mov    %esp,%ebp
c0004151:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:20
   ASSERT(intr_get_status() == INTR_OFF);
c0004154:	e8 27 d9 ff ff       	call   c0001a80 <intr_get_status>
c0004159:	85 c0                	test   %eax,%eax
c000415b:	74 19                	je     c0004176 <ioq_full+0x28>
/work/x86_os_my/device/ioqueue.c:20 (discriminator 1)
c000415d:	68 80 57 00 c0       	push   $0xc0005780
c0004162:	68 e4 57 00 c0       	push   $0xc00057e4
c0004167:	6a 14                	push   $0x14
c0004169:	68 9e 57 00 c0       	push   $0xc000579e
c000416e:	e8 ef e1 ff ff       	call   c0002362 <panic_spin>
c0004173:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:21
   return next_pos(ioq->head) == ioq->tail;
c0004176:	8b 45 08             	mov    0x8(%ebp),%eax
c0004179:	8b 40 64             	mov    0x64(%eax),%eax
c000417c:	83 ec 0c             	sub    $0xc,%esp
c000417f:	50                   	push   %eax
c0004180:	e8 ad ff ff ff       	call   c0004132 <next_pos>
c0004185:	83 c4 10             	add    $0x10,%esp
c0004188:	89 c2                	mov    %eax,%edx
c000418a:	8b 45 08             	mov    0x8(%ebp),%eax
c000418d:	8b 40 68             	mov    0x68(%eax),%eax
c0004190:	39 c2                	cmp    %eax,%edx
c0004192:	0f 94 c0             	sete   %al
c0004195:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:22
}
c0004198:	c9                   	leave  
c0004199:	c3                   	ret    

c000419a <ioq_empty>:
ioq_empty():
/work/x86_os_my/device/ioqueue.c:25

/* 判断队列是否已空 */
static bool ioq_empty(struct ioqueue* ioq) {
c000419a:	55                   	push   %ebp
c000419b:	89 e5                	mov    %esp,%ebp
c000419d:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:26
   ASSERT(intr_get_status() == INTR_OFF);
c00041a0:	e8 db d8 ff ff       	call   c0001a80 <intr_get_status>
c00041a5:	85 c0                	test   %eax,%eax
c00041a7:	74 19                	je     c00041c2 <ioq_empty+0x28>
/work/x86_os_my/device/ioqueue.c:26 (discriminator 1)
c00041a9:	68 80 57 00 c0       	push   $0xc0005780
c00041ae:	68 f0 57 00 c0       	push   $0xc00057f0
c00041b3:	6a 1a                	push   $0x1a
c00041b5:	68 9e 57 00 c0       	push   $0xc000579e
c00041ba:	e8 a3 e1 ff ff       	call   c0002362 <panic_spin>
c00041bf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:27
   return ioq->head == ioq->tail;
c00041c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00041c5:	8b 50 64             	mov    0x64(%eax),%edx
c00041c8:	8b 45 08             	mov    0x8(%ebp),%eax
c00041cb:	8b 40 68             	mov    0x68(%eax),%eax
c00041ce:	39 c2                	cmp    %eax,%edx
c00041d0:	0f 94 c0             	sete   %al
c00041d3:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:28
}
c00041d6:	c9                   	leave  
c00041d7:	c3                   	ret    

c00041d8 <ioq_wait>:
ioq_wait():
/work/x86_os_my/device/ioqueue.c:31

/* 使当前生产者或消费者在此缓冲区上等待 */
static void ioq_wait(struct task_struct** waiter) {
c00041d8:	55                   	push   %ebp
c00041d9:	89 e5                	mov    %esp,%ebp
c00041db:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:32
   ASSERT(*waiter == NULL && waiter != NULL);
c00041de:	8b 45 08             	mov    0x8(%ebp),%eax
c00041e1:	8b 00                	mov    (%eax),%eax
c00041e3:	85 c0                	test   %eax,%eax
c00041e5:	75 06                	jne    c00041ed <ioq_wait+0x15>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 1)
c00041e7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00041eb:	75 19                	jne    c0004206 <ioq_wait+0x2e>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 3)
c00041ed:	68 b0 57 00 c0       	push   $0xc00057b0
c00041f2:	68 fc 57 00 c0       	push   $0xc00057fc
c00041f7:	6a 20                	push   $0x20
c00041f9:	68 9e 57 00 c0       	push   $0xc000579e
c00041fe:	e8 5f e1 ff ff       	call   c0002362 <panic_spin>
c0004203:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:33
   *waiter = running_thread();
c0004206:	e8 4f f0 ff ff       	call   c000325a <running_thread>
c000420b:	89 c2                	mov    %eax,%edx
c000420d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004210:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ioqueue.c:34
   thread_block(TASK_BLOCKED);
c0004212:	83 ec 0c             	sub    $0xc,%esp
c0004215:	6a 02                	push   $0x2
c0004217:	e8 44 f4 ff ff       	call   c0003660 <thread_block>
c000421c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:35
}
c000421f:	90                   	nop
c0004220:	c9                   	leave  
c0004221:	c3                   	ret    

c0004222 <wakeup>:
wakeup():
/work/x86_os_my/device/ioqueue.c:38

/* 唤醒waiter */
static void wakeup(struct task_struct** waiter) {
c0004222:	55                   	push   %ebp
c0004223:	89 e5                	mov    %esp,%ebp
c0004225:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:39
   ASSERT(*waiter != NULL);
c0004228:	8b 45 08             	mov    0x8(%ebp),%eax
c000422b:	8b 00                	mov    (%eax),%eax
c000422d:	85 c0                	test   %eax,%eax
c000422f:	75 19                	jne    c000424a <wakeup+0x28>
/work/x86_os_my/device/ioqueue.c:39 (discriminator 1)
c0004231:	68 d2 57 00 c0       	push   $0xc00057d2
c0004236:	68 08 58 00 c0       	push   $0xc0005808
c000423b:	6a 27                	push   $0x27
c000423d:	68 9e 57 00 c0       	push   $0xc000579e
c0004242:	e8 1b e1 ff ff       	call   c0002362 <panic_spin>
c0004247:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:40
   thread_unblock(*waiter); 
c000424a:	8b 45 08             	mov    0x8(%ebp),%eax
c000424d:	8b 00                	mov    (%eax),%eax
c000424f:	83 ec 0c             	sub    $0xc,%esp
c0004252:	50                   	push   %eax
c0004253:	e8 6b f4 ff ff       	call   c00036c3 <thread_unblock>
c0004258:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:41
   *waiter = NULL;
c000425b:	8b 45 08             	mov    0x8(%ebp),%eax
c000425e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/device/ioqueue.c:42
}
c0004264:	90                   	nop
c0004265:	c9                   	leave  
c0004266:	c3                   	ret    

c0004267 <ioq_getchar>:
ioq_getchar():
/work/x86_os_my/device/ioqueue.c:45

/* 消费者从ioq队列中获取一个字符 */
char ioq_getchar(struct ioqueue* ioq) {
c0004267:	55                   	push   %ebp
c0004268:	89 e5                	mov    %esp,%ebp
c000426a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ioqueue.c:46
   ASSERT(intr_get_status() == INTR_OFF);
c000426d:	e8 0e d8 ff ff       	call   c0001a80 <intr_get_status>
c0004272:	85 c0                	test   %eax,%eax
c0004274:	74 4b                	je     c00042c1 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:46 (discriminator 1)
c0004276:	68 80 57 00 c0       	push   $0xc0005780
c000427b:	68 10 58 00 c0       	push   $0xc0005810
c0004280:	6a 2e                	push   $0x2e
c0004282:	68 9e 57 00 c0       	push   $0xc000579e
c0004287:	e8 d6 e0 ff ff       	call   c0002362 <panic_spin>
c000428c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51 (discriminator 1)

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c000428f:	eb 30                	jmp    c00042c1 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:52
      lock_acquire(&ioq->lock);	 
c0004291:	8b 45 08             	mov    0x8(%ebp),%eax
c0004294:	83 ec 0c             	sub    $0xc,%esp
c0004297:	50                   	push   %eax
c0004298:	e8 42 fa ff ff       	call   c0003cdf <lock_acquire>
c000429d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:53
      ioq_wait(&ioq->consumer);
c00042a0:	8b 45 08             	mov    0x8(%ebp),%eax
c00042a3:	83 c0 20             	add    $0x20,%eax
c00042a6:	83 ec 0c             	sub    $0xc,%esp
c00042a9:	50                   	push   %eax
c00042aa:	e8 29 ff ff ff       	call   c00041d8 <ioq_wait>
c00042af:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:54
      lock_release(&ioq->lock);
c00042b2:	8b 45 08             	mov    0x8(%ebp),%eax
c00042b5:	83 ec 0c             	sub    $0xc,%esp
c00042b8:	50                   	push   %eax
c00042b9:	e8 98 fa ff ff       	call   c0003d56 <lock_release>
c00042be:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c00042c1:	83 ec 0c             	sub    $0xc,%esp
c00042c4:	ff 75 08             	pushl  0x8(%ebp)
c00042c7:	e8 ce fe ff ff       	call   c000419a <ioq_empty>
c00042cc:	83 c4 10             	add    $0x10,%esp
c00042cf:	85 c0                	test   %eax,%eax
c00042d1:	75 be                	jne    c0004291 <ioq_getchar+0x2a>
/work/x86_os_my/device/ioqueue.c:57
      lock_acquire(&ioq->lock);	 
      ioq_wait(&ioq->consumer);
      lock_release(&ioq->lock);
   }

   char byte = ioq->buf[ioq->tail];	  // 从缓冲区中取出
c00042d3:	8b 45 08             	mov    0x8(%ebp),%eax
c00042d6:	8b 40 68             	mov    0x68(%eax),%eax
c00042d9:	8b 55 08             	mov    0x8(%ebp),%edx
c00042dc:	0f b6 44 02 24       	movzbl 0x24(%edx,%eax,1),%eax
c00042e1:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ioqueue.c:58
   ioq->tail = next_pos(ioq->tail);	  // 把读游标移到下一位置
c00042e4:	8b 45 08             	mov    0x8(%ebp),%eax
c00042e7:	8b 40 68             	mov    0x68(%eax),%eax
c00042ea:	83 ec 0c             	sub    $0xc,%esp
c00042ed:	50                   	push   %eax
c00042ee:	e8 3f fe ff ff       	call   c0004132 <next_pos>
c00042f3:	83 c4 10             	add    $0x10,%esp
c00042f6:	89 c2                	mov    %eax,%edx
c00042f8:	8b 45 08             	mov    0x8(%ebp),%eax
c00042fb:	89 50 68             	mov    %edx,0x68(%eax)
/work/x86_os_my/device/ioqueue.c:60

   if (ioq->producer != NULL) {
c00042fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0004301:	8b 40 1c             	mov    0x1c(%eax),%eax
c0004304:	85 c0                	test   %eax,%eax
c0004306:	74 12                	je     c000431a <ioq_getchar+0xb3>
/work/x86_os_my/device/ioqueue.c:61
      wakeup(&ioq->producer);		  // 唤醒生产者
c0004308:	8b 45 08             	mov    0x8(%ebp),%eax
c000430b:	83 c0 1c             	add    $0x1c,%eax
c000430e:	83 ec 0c             	sub    $0xc,%esp
c0004311:	50                   	push   %eax
c0004312:	e8 0b ff ff ff       	call   c0004222 <wakeup>
c0004317:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:64
   }

   return byte; 
c000431a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
/work/x86_os_my/device/ioqueue.c:65
}
c000431e:	c9                   	leave  
c000431f:	c3                   	ret    

c0004320 <ioq_putchar>:
ioq_putchar():
/work/x86_os_my/device/ioqueue.c:68

/* 生产者往ioq队列中写入一个字符byte */
void ioq_putchar(struct ioqueue* ioq, char byte) {
c0004320:	55                   	push   %ebp
c0004321:	89 e5                	mov    %esp,%ebp
c0004323:	83 ec 18             	sub    $0x18,%esp
c0004326:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004329:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/ioqueue.c:69
   ASSERT(intr_get_status() == INTR_OFF);
c000432c:	e8 4f d7 ff ff       	call   c0001a80 <intr_get_status>
c0004331:	85 c0                	test   %eax,%eax
c0004333:	74 4b                	je     c0004380 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:69 (discriminator 1)
c0004335:	68 80 57 00 c0       	push   $0xc0005780
c000433a:	68 1c 58 00 c0       	push   $0xc000581c
c000433f:	6a 45                	push   $0x45
c0004341:	68 9e 57 00 c0       	push   $0xc000579e
c0004346:	e8 17 e0 ff ff       	call   c0002362 <panic_spin>
c000434b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74 (discriminator 1)

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c000434e:	eb 30                	jmp    c0004380 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:75
      lock_acquire(&ioq->lock);
c0004350:	8b 45 08             	mov    0x8(%ebp),%eax
c0004353:	83 ec 0c             	sub    $0xc,%esp
c0004356:	50                   	push   %eax
c0004357:	e8 83 f9 ff ff       	call   c0003cdf <lock_acquire>
c000435c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:76
      ioq_wait(&ioq->producer);
c000435f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004362:	83 c0 1c             	add    $0x1c,%eax
c0004365:	83 ec 0c             	sub    $0xc,%esp
c0004368:	50                   	push   %eax
c0004369:	e8 6a fe ff ff       	call   c00041d8 <ioq_wait>
c000436e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:77
      lock_release(&ioq->lock);
c0004371:	8b 45 08             	mov    0x8(%ebp),%eax
c0004374:	83 ec 0c             	sub    $0xc,%esp
c0004377:	50                   	push   %eax
c0004378:	e8 d9 f9 ff ff       	call   c0003d56 <lock_release>
c000437d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c0004380:	83 ec 0c             	sub    $0xc,%esp
c0004383:	ff 75 08             	pushl  0x8(%ebp)
c0004386:	e8 c3 fd ff ff       	call   c000414e <ioq_full>
c000438b:	83 c4 10             	add    $0x10,%esp
c000438e:	85 c0                	test   %eax,%eax
c0004390:	75 be                	jne    c0004350 <ioq_putchar+0x30>
/work/x86_os_my/device/ioqueue.c:79
      lock_acquire(&ioq->lock);
      ioq_wait(&ioq->producer);
      lock_release(&ioq->lock);
   }
   ioq->buf[ioq->head] = byte;      // 把字节放入缓冲区中
c0004392:	8b 45 08             	mov    0x8(%ebp),%eax
c0004395:	8b 40 64             	mov    0x64(%eax),%eax
c0004398:	8b 55 08             	mov    0x8(%ebp),%edx
c000439b:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
c000439f:	88 4c 02 24          	mov    %cl,0x24(%edx,%eax,1)
/work/x86_os_my/device/ioqueue.c:80
   ioq->head = next_pos(ioq->head); // 把写游标移到下一位置
c00043a3:	8b 45 08             	mov    0x8(%ebp),%eax
c00043a6:	8b 40 64             	mov    0x64(%eax),%eax
c00043a9:	83 ec 0c             	sub    $0xc,%esp
c00043ac:	50                   	push   %eax
c00043ad:	e8 80 fd ff ff       	call   c0004132 <next_pos>
c00043b2:	83 c4 10             	add    $0x10,%esp
c00043b5:	89 c2                	mov    %eax,%edx
c00043b7:	8b 45 08             	mov    0x8(%ebp),%eax
c00043ba:	89 50 64             	mov    %edx,0x64(%eax)
/work/x86_os_my/device/ioqueue.c:82

   if (ioq->consumer != NULL) {
c00043bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00043c0:	8b 40 20             	mov    0x20(%eax),%eax
c00043c3:	85 c0                	test   %eax,%eax
c00043c5:	74 12                	je     c00043d9 <ioq_putchar+0xb9>
/work/x86_os_my/device/ioqueue.c:83
      wakeup(&ioq->consumer);          // 唤醒消费者
c00043c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00043ca:	83 c0 20             	add    $0x20,%eax
c00043cd:	83 ec 0c             	sub    $0xc,%esp
c00043d0:	50                   	push   %eax
c00043d1:	e8 4c fe ff ff       	call   c0004222 <wakeup>
c00043d6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:85
   }
}
c00043d9:	90                   	nop
c00043da:	c9                   	leave  
c00043db:	c3                   	ret    

c00043dc <update_tss_esp>:
update_tss_esp():
/work/x86_os_my/userprog/tss.c:40
	uint32_t io_base;
}; 
static struct tss g_tss;

/* 更新tss中esp0字段的值为pthread的0级栈 */
void update_tss_esp(struct task_struct* pthread) {
c00043dc:	55                   	push   %ebp
c00043dd:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/userprog/tss.c:41
	g_tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c00043df:	8b 45 08             	mov    0x8(%ebp),%eax
c00043e2:	05 00 10 00 00       	add    $0x1000,%eax
c00043e7:	a3 a4 75 00 c0       	mov    %eax,0xc00075a4
/work/x86_os_my/userprog/tss.c:42
}
c00043ec:	90                   	nop
c00043ed:	5d                   	pop    %ebp
c00043ee:	c3                   	ret    

c00043ef <make_gdt_desc>:
make_gdt_desc():
/work/x86_os_my/userprog/tss.c:45

/* c语言方式，创建gdt描述符 */
static struct gdt_desc make_gdt_desc(uint32_t* desc_addr, uint32_t limit, uint8_t attr_low, uint8_t attr_high) {
c00043ef:	55                   	push   %ebp
c00043f0:	89 e5                	mov    %esp,%ebp
c00043f2:	83 ec 18             	sub    $0x18,%esp
c00043f5:	8b 55 14             	mov    0x14(%ebp),%edx
c00043f8:	8b 45 18             	mov    0x18(%ebp),%eax
c00043fb:	88 55 ec             	mov    %dl,-0x14(%ebp)
c00043fe:	88 45 e8             	mov    %al,-0x18(%ebp)
/work/x86_os_my/userprog/tss.c:46
	uint32_t desc_base = (uint32_t)desc_addr;
c0004401:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004404:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/userprog/tss.c:48
	struct gdt_desc desc;
	desc.limit_low_word = limit & 0x0000ffff;
c0004407:	8b 45 10             	mov    0x10(%ebp),%eax
c000440a:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/userprog/tss.c:49
	desc.base_low_word = desc_base & 0x0000ffff;
c000440e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004411:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/userprog/tss.c:50
	desc.base_mid_byte = ((desc_base & 0x00ff0000) >> 16);
c0004415:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004418:	25 00 00 ff 00       	and    $0xff0000,%eax
c000441d:	c1 e8 10             	shr    $0x10,%eax
c0004420:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/userprog/tss.c:51
	desc.attr_low_byte = (uint8_t)(attr_low);
c0004423:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0004427:	88 45 f9             	mov    %al,-0x7(%ebp)
/work/x86_os_my/userprog/tss.c:52
	desc.limit_high_attr_high = (((limit & 0x000f0000) >> 16) + (uint8_t)(attr_high));
c000442a:	8b 45 10             	mov    0x10(%ebp),%eax
c000442d:	25 00 00 0f 00       	and    $0xf0000,%eax
c0004432:	c1 e8 10             	shr    $0x10,%eax
c0004435:	89 c2                	mov    %eax,%edx
c0004437:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c000443b:	01 d0                	add    %edx,%eax
c000443d:	88 45 fa             	mov    %al,-0x6(%ebp)
/work/x86_os_my/userprog/tss.c:53
	desc.base_high_byte = desc_base >> 24;
c0004440:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004443:	c1 e8 18             	shr    $0x18,%eax
c0004446:	88 45 fb             	mov    %al,-0x5(%ebp)
/work/x86_os_my/userprog/tss.c:54
	return desc;
c0004449:	8b 4d 08             	mov    0x8(%ebp),%ecx
c000444c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000444f:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0004452:	89 01                	mov    %eax,(%ecx)
c0004454:	89 51 04             	mov    %edx,0x4(%ecx)
/work/x86_os_my/userprog/tss.c:55
}
c0004457:	8b 45 08             	mov    0x8(%ebp),%eax
c000445a:	c9                   	leave  
c000445b:	c2 04 00             	ret    $0x4

c000445e <tss_init>:
tss_init():
/work/x86_os_my/userprog/tss.c:61

/* 在gdt中创建tss描述符
 * 重新加载 gdt
 * 加载 tr
 */
void tss_init() {
c000445e:	55                   	push   %ebp
c000445f:	89 e5                	mov    %esp,%ebp
c0004461:	53                   	push   %ebx
c0004462:	83 ec 24             	sub    $0x24,%esp
/work/x86_os_my/userprog/tss.c:62
	put_str("tss_init start\n");
c0004465:	83 ec 0c             	sub    $0xc,%esp
c0004468:	68 28 58 00 c0       	push   $0xc0005828
c000446d:	e8 7e dd ff ff       	call   c00021f0 <put_str>
c0004472:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:63
	uint32_t tss_size = sizeof(g_tss);
c0004475:	c7 45 f4 6c 00 00 00 	movl   $0x6c,-0xc(%ebp)
/work/x86_os_my/userprog/tss.c:64
	memset(&g_tss, 0, tss_size);
c000447c:	83 ec 04             	sub    $0x4,%esp
c000447f:	ff 75 f4             	pushl  -0xc(%ebp)
c0004482:	6a 00                	push   $0x0
c0004484:	68 a0 75 00 c0       	push   $0xc00075a0
c0004489:	e8 fc e9 ff ff       	call   c0002e8a <memset>
c000448e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:66
	
	g_tss.ss0 = SELECTOR_K_STACK;	// 0 级栈段的选择子 
c0004491:	c7 05 a8 75 00 c0 10 	movl   $0x10,0xc00075a8
c0004498:	00 00 00 
/work/x86_os_my/userprog/tss.c:67
	g_tss.io_base = tss_size;		// 当 IO 位图的偏移地址大于等于 TSS 大小减 1 时，就表示没有 IO 位图。
c000449b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000449e:	a3 08 76 00 c0       	mov    %eax,0xc0007608
/work/x86_os_my/userprog/tss.c:75
	 * 内核地址 0xC000_0900 是映射到 0x900 的 
	 * 在GDT中，第 0 个段描述符不可用，第 1 个为代码段，第 2 个为数据段和栈，第 3 个为显存段
	 */

	/* 在gdt中添加dpl为0的TSS描述符 */
	*((struct gdt_desc*)0xc0000920) = make_gdt_desc((uint32_t*)&g_tss, tss_size - 1, TSS_ATTR_LOW, TSS_ATTR_HIGH);
c00044a3:	bb 20 09 00 c0       	mov    $0xc0000920,%ebx
c00044a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00044ab:	8d 50 ff             	lea    -0x1(%eax),%edx
c00044ae:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00044b1:	83 ec 0c             	sub    $0xc,%esp
c00044b4:	68 80 00 00 00       	push   $0x80
c00044b9:	68 89 00 00 00       	push   $0x89
c00044be:	52                   	push   %edx
c00044bf:	68 a0 75 00 c0       	push   $0xc00075a0
c00044c4:	50                   	push   %eax
c00044c5:	e8 25 ff ff ff       	call   c00043ef <make_gdt_desc>
c00044ca:	83 c4 1c             	add    $0x1c,%esp
c00044cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00044d0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00044d3:	89 03                	mov    %eax,(%ebx)
c00044d5:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:78

	/* 在gdt中添加dpl为3的,用户级,数据段和代码段描述符 */
	*((struct gdt_desc*)0xc0000928) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
c00044d8:	bb 28 09 00 c0       	mov    $0xc0000928,%ebx
c00044dd:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00044e0:	83 ec 0c             	sub    $0xc,%esp
c00044e3:	68 c0 00 00 00       	push   $0xc0
c00044e8:	68 f8 00 00 00       	push   $0xf8
c00044ed:	68 ff ff 0f 00       	push   $0xfffff
c00044f2:	6a 00                	push   $0x0
c00044f4:	50                   	push   %eax
c00044f5:	e8 f5 fe ff ff       	call   c00043ef <make_gdt_desc>
c00044fa:	83 c4 1c             	add    $0x1c,%esp
c00044fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0004500:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0004503:	89 03                	mov    %eax,(%ebx)
c0004505:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:79
	*((struct gdt_desc*)0xc0000930) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
c0004508:	bb 30 09 00 c0       	mov    $0xc0000930,%ebx
c000450d:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0004510:	83 ec 0c             	sub    $0xc,%esp
c0004513:	68 c0 00 00 00       	push   $0xc0
c0004518:	68 f2 00 00 00       	push   $0xf2
c000451d:	68 ff ff 0f 00       	push   $0xfffff
c0004522:	6a 00                	push   $0x0
c0004524:	50                   	push   %eax
c0004525:	e8 c5 fe ff ff       	call   c00043ef <make_gdt_desc>
c000452a:	83 c4 1c             	add    $0x1c,%esp
c000452d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0004530:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0004533:	89 03                	mov    %eax,(%ebx)
c0004535:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:83

	/* GDTR 16位的limit、32位的段基址 */
	// 先转换成 uint32_t 后，再将其转换成 uint64_t 位（不可一步到位转为 uint64_t）
	uint64_t gdt_operand = ((8 * 7 - 1) | ((uint64_t)(uint32_t)0xc0000900 << 16));   // 7个描述符大小
c0004538:	c7 45 e8 37 00 00 09 	movl   $0x9000037,-0x18(%ebp)
c000453f:	c7 45 ec 00 c0 00 00 	movl   $0xc000,-0x14(%ebp)
/work/x86_os_my/userprog/tss.c:84
	asm volatile ("lgdt %0" : : "m" (gdt_operand));
c0004546:	0f 01 55 e8          	lgdtl  -0x18(%ebp)
/work/x86_os_my/userprog/tss.c:85
	asm volatile ("ltr %w0" : : "r" (SELECTOR_TSS));
c000454a:	b8 20 00 00 00       	mov    $0x20,%eax
c000454f:	0f 00 d8             	ltr    %ax
/work/x86_os_my/userprog/tss.c:86
	put_str("tss_init and ltr done\n");
c0004552:	83 ec 0c             	sub    $0xc,%esp
c0004555:	68 38 58 00 c0       	push   $0xc0005838
c000455a:	e8 91 dc ff ff       	call   c00021f0 <put_str>
c000455f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:87
}
c0004562:	90                   	nop
c0004563:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0004566:	c9                   	leave  
c0004567:	c3                   	ret    

c0004568 <start_process>:
start_process():
/work/x86_os_my/userprog/process.c:17
extern void intr_exit(void);

/* 构建用户进程初始上下文信息
 * 填充用户进程的中断栈，并将中断栈的信息，利用iretd填充到 CPU 中
 */
void start_process(void* filename_) {
c0004568:	55                   	push   %ebp
c0004569:	89 e5                	mov    %esp,%ebp
c000456b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:18
	void* function = filename_;
c000456e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004571:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:19
	struct task_struct* cur = running_thread();
c0004574:	e8 e1 ec ff ff       	call   c000325a <running_thread>
c0004579:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:20
	cur->self_kstack += sizeof(struct thread_stack);
c000457c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000457f:	8b 00                	mov    (%eax),%eax
c0004581:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
c0004587:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000458a:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/process.c:21
	struct intr_stack* proc_stack = (struct intr_stack*)cur->self_kstack;	 
c000458c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000458f:	8b 00                	mov    (%eax),%eax
c0004591:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/userprog/process.c:22
	proc_stack->edi = proc_stack->esi = proc_stack->ebp = proc_stack->esp_dummy = 0;
c0004594:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004597:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
c000459e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045a1:	8b 50 10             	mov    0x10(%eax),%edx
c00045a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045a7:	89 50 0c             	mov    %edx,0xc(%eax)
c00045aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045ad:	8b 50 0c             	mov    0xc(%eax),%edx
c00045b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045b3:	89 50 08             	mov    %edx,0x8(%eax)
c00045b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045b9:	8b 50 08             	mov    0x8(%eax),%edx
c00045bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045bf:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/userprog/process.c:23
	proc_stack->ebx = proc_stack->edx = proc_stack->ecx = proc_stack->eax = 0;
c00045c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045c5:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c00045cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045cf:	8b 50 20             	mov    0x20(%eax),%edx
c00045d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045d5:	89 50 1c             	mov    %edx,0x1c(%eax)
c00045d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045db:	8b 50 1c             	mov    0x1c(%eax),%edx
c00045de:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045e1:	89 50 18             	mov    %edx,0x18(%eax)
c00045e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045e7:	8b 50 18             	mov    0x18(%eax),%edx
c00045ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045ed:	89 50 14             	mov    %edx,0x14(%eax)
/work/x86_os_my/userprog/process.c:28
	/* 在iretd返回时，如果发现未来的 CPL（也就是内核栈中 CS.RPL，或者说是返回到的用户进程的代码段CS.CPL）
	 * 权限低于（数值上大于） CPU 中段寄存器（如 DS、 ES、 FS、 GS）中选择子指向的内存段的 DPL，
	 * CPU 会自动将相应段寄存器的选择子置为 0 
	 * 这里gs的选择子在iretd返回后，会被自动清零。*/
	proc_stack->gs = 0;					// 用户态用不上,直接初始为0
c00045f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045f3:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
/work/x86_os_my/userprog/process.c:29
	proc_stack->ds = proc_stack->es = proc_stack->fs = SELECTOR_U_DATA;		// 用户级数据段
c00045fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045fd:	c7 40 28 33 00 00 00 	movl   $0x33,0x28(%eax)
c0004604:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004607:	8b 50 28             	mov    0x28(%eax),%edx
c000460a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000460d:	89 50 2c             	mov    %edx,0x2c(%eax)
c0004610:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004613:	8b 50 2c             	mov    0x2c(%eax),%edx
c0004616:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004619:	89 50 30             	mov    %edx,0x30(%eax)
/work/x86_os_my/userprog/process.c:30
	proc_stack->eip = function;			// 待执行的用户程序地址
c000461c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000461f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004622:	89 50 38             	mov    %edx,0x38(%eax)
/work/x86_os_my/userprog/process.c:31
	proc_stack->cs = SELECTOR_U_CODE;	// 用户级代码段
c0004625:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004628:	c7 40 3c 2b 00 00 00 	movl   $0x2b,0x3c(%eax)
/work/x86_os_my/userprog/process.c:32
	proc_stack->eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);
c000462f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004632:	c7 40 40 02 02 00 00 	movl   $0x202,0x40(%eax)
/work/x86_os_my/userprog/process.c:41
	 * process_activate 使用户进程页表生效【已经把CR3寄存器 更新为 用户进程的页表了】
	 * start_process    为用户进程创建3特权级栈【所以申请的内存空间来自用户进程的页表】
	 * 
	 * USER_STACK3_VADDR=(0xc0000000 - 0x1000)
	 */
	proc_stack->esp = (void*)((uint32_t)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE) ;
c0004639:	83 ec 08             	sub    $0x8,%esp
c000463c:	68 00 f0 ff bf       	push   $0xbffff000
c0004641:	6a 02                	push   $0x2
c0004643:	e8 78 e4 ff ff       	call   c0002ac0 <get_a_page>
c0004648:	83 c4 10             	add    $0x10,%esp
c000464b:	05 00 10 00 00       	add    $0x1000,%eax
c0004650:	89 c2                	mov    %eax,%edx
c0004652:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004655:	89 50 44             	mov    %edx,0x44(%eax)
/work/x86_os_my/userprog/process.c:42
	proc_stack->ss = SELECTOR_U_DATA;
c0004658:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000465b:	c7 40 48 33 00 00 00 	movl   $0x33,0x48(%eax)
/work/x86_os_my/userprog/process.c:49
	/* 将 esp 替换为 proc_stack
	 * 通过 jmp intr_exit 那里的一系列 pop 指令和 iretd 指令，
	 * 将 proc_stack 中的数据载入 CPU 的寄存器，
	 * 从而使程序“假装”退出中断，进入特权级 3
	 */
	asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (proc_stack) : "memory");
c0004662:	8b 65 ec             	mov    -0x14(%ebp),%esp
c0004665:	e9 26 d6 ff ff       	jmp    c0001c90 <intr_exit>
/work/x86_os_my/userprog/process.c:50
}
c000466a:	90                   	nop
c000466b:	c9                   	leave  
c000466c:	c3                   	ret    

c000466d <page_dir_activate>:
page_dir_activate():
/work/x86_os_my/userprog/process.c:53

/* 更新CR3寄存器，激活页目录表 */
void page_dir_activate(struct task_struct* p_thread) {
c000466d:	55                   	push   %ebp
c000466e:	89 e5                	mov    %esp,%ebp
c0004670:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:56
	
	/* 若为"内核线程",需要重新填充页表为0x100000 */
	uint32_t pagedir_phy_addr = 0x100000;	// 默认为内核的页目录物理地址,也就是内核线程所用的页目录表
c0004673:	c7 45 f4 00 00 10 00 	movl   $0x100000,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:59
	
	/* "用户态进程"有自己的页目录表 */
	if (p_thread->pgdir != NULL) {
c000467a:	8b 45 08             	mov    0x8(%ebp),%eax
c000467d:	8b 40 34             	mov    0x34(%eax),%eax
c0004680:	85 c0                	test   %eax,%eax
c0004682:	74 15                	je     c0004699 <page_dir_activate+0x2c>
/work/x86_os_my/userprog/process.c:60
		pagedir_phy_addr = addr_v2p((uint32_t)p_thread->pgdir);
c0004684:	8b 45 08             	mov    0x8(%ebp),%eax
c0004687:	8b 40 34             	mov    0x34(%eax),%eax
c000468a:	83 ec 0c             	sub    $0xc,%esp
c000468d:	50                   	push   %eax
c000468e:	e8 8b e5 ff ff       	call   c0002c1e <addr_v2p>
c0004693:	83 c4 10             	add    $0x10,%esp
c0004696:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:66
	}

	/* 更新页目录寄存器cr3,使新页表生效
	 * 实现进程间，虚拟地址空间的隔离。
	 */
	asm volatile ("movl %0, %%cr3" : : "r" (pagedir_phy_addr) : "memory");
c0004699:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000469c:	0f 22 d8             	mov    %eax,%cr3
/work/x86_os_my/userprog/process.c:67
}
c000469f:	90                   	nop
c00046a0:	c9                   	leave  
c00046a1:	c3                   	ret    

c00046a2 <process_activate>:
process_activate():
/work/x86_os_my/userprog/process.c:73

/* 1.激活线程或进程的页表,【更新CR3寄存器】
 * 2.用户进程，更新tss中的esp0为进程的特权级0的栈
 * 【只有在任务调度时（中断时），才会切换页表及更新 0 级栈，因此 process_activate 是被"中断执行流"的 schedule 调用的！】
 */
void process_activate(struct task_struct* p_thread) {
c00046a2:	55                   	push   %ebp
c00046a3:	89 e5                	mov    %esp,%ebp
c00046a5:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/process.c:74
	ASSERT(p_thread != NULL);
c00046a8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00046ac:	75 19                	jne    c00046c7 <process_activate+0x25>
/work/x86_os_my/userprog/process.c:74 (discriminator 1)
c00046ae:	68 50 58 00 c0       	push   $0xc0005850
c00046b3:	68 0c 59 00 c0       	push   $0xc000590c
c00046b8:	6a 4a                	push   $0x4a
c00046ba:	68 61 58 00 c0       	push   $0xc0005861
c00046bf:	e8 9e dc ff ff       	call   c0002362 <panic_spin>
c00046c4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:77
	
	/* 激活该进程或线程的页目录表【重新加载了CR3】 */
	page_dir_activate(p_thread);
c00046c7:	83 ec 0c             	sub    $0xc,%esp
c00046ca:	ff 75 08             	pushl  0x8(%ebp)
c00046cd:	e8 9b ff ff ff       	call   c000466d <page_dir_activate>
c00046d2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:80

	/* 内核线程特权级本身就是0,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */
	if (p_thread->pgdir != NULL) {
c00046d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00046d8:	8b 40 34             	mov    0x34(%eax),%eax
c00046db:	85 c0                	test   %eax,%eax
c00046dd:	74 0e                	je     c00046ed <process_activate+0x4b>
/work/x86_os_my/userprog/process.c:83
		/* 若为用户进程,更新该进程的esp0,用于此进程被中断时保留上下文 
		 * 需要从tss中获取0特权级栈地址 */
		update_tss_esp(p_thread);	//就一行：g_tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c00046df:	83 ec 0c             	sub    $0xc,%esp
c00046e2:	ff 75 08             	pushl  0x8(%ebp)
c00046e5:	e8 f2 fc ff ff       	call   c00043dc <update_tss_esp>
c00046ea:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:85
	}
}
c00046ed:	90                   	nop
c00046ee:	c9                   	leave  
c00046ef:	c3                   	ret    

c00046f0 <create_page_dir>:
create_page_dir():
/work/x86_os_my/userprog/process.c:94
 * 
 * 要确保用户进程，在自己的地址空间中，能够访问到内核。
 * 即：任意进程的页目录表中，用户进程占第 0~767 个页目录项，内核占第 768~1023 个页目录项。
 * 0x300 = 768
 */
uint32_t* create_page_dir(void) {
c00046f0:	55                   	push   %ebp
c00046f1:	89 e5                	mov    %esp,%ebp
c00046f3:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:97

	/* 用户进程的页表不能让用户直接访问到,所以在内核空间来申请 */
	uint32_t* page_dir_vaddr = get_kernel_pages(1);
c00046f6:	83 ec 0c             	sub    $0xc,%esp
c00046f9:	6a 01                	push   $0x1
c00046fb:	e8 0a e3 ff ff       	call   c0002a0a <get_kernel_pages>
c0004700:	83 c4 10             	add    $0x10,%esp
c0004703:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:98
	if (page_dir_vaddr == NULL) {
c0004706:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000470a:	75 17                	jne    c0004723 <create_page_dir+0x33>
/work/x86_os_my/userprog/process.c:99
		console_put_str("create_page_dir: get_kernel_page failed!");
c000470c:	83 ec 0c             	sub    $0xc,%esp
c000470f:	68 74 58 00 c0       	push   $0xc0005874
c0004714:	e8 57 f3 ff ff       	call   c0003a70 <console_put_str>
c0004719:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:100
		return NULL;
c000471c:	b8 00 00 00 00       	mov    $0x0,%eax
c0004721:	eb 43                	jmp    c0004766 <create_page_dir+0x76>
/work/x86_os_my/userprog/process.c:106
	}

	/*** 1 复制内核的页目录表  ***/
	// page_dir_vaddr + 0x300*4 是内核页目录的第768项
	// 复制的页目录项个数=1024/4
	memcpy((uint32_t*)((uint32_t)page_dir_vaddr + 0x300*4), (uint32_t*)(0xfffff000+0x300*4), 1024);
c0004723:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004726:	05 00 0c 00 00       	add    $0xc00,%eax
c000472b:	83 ec 04             	sub    $0x4,%esp
c000472e:	68 00 04 00 00       	push   $0x400
c0004733:	68 00 fc ff ff       	push   $0xfffffc00
c0004738:	50                   	push   %eax
c0004739:	e8 9e e7 ff ff       	call   c0002edc <memcpy>
c000473e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:110

	/*** 2 更新页目录表地址 ***/
	// 页目录表地址是页目录的最后一项
	uint32_t new_page_dir_phy_addr = addr_v2p((uint32_t)page_dir_vaddr);
c0004741:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004744:	83 ec 0c             	sub    $0xc,%esp
c0004747:	50                   	push   %eax
c0004748:	e8 d1 e4 ff ff       	call   c0002c1e <addr_v2p>
c000474d:	83 c4 10             	add    $0x10,%esp
c0004750:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:111
	page_dir_vaddr[1023] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1;
c0004753:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004756:	05 fc 0f 00 00       	add    $0xffc,%eax
c000475b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000475e:	83 ca 07             	or     $0x7,%edx
c0004761:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/process.c:113

	return page_dir_vaddr;
c0004763:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/userprog/process.c:114
}
c0004766:	c9                   	leave  
c0004767:	c3                   	ret    

c0004768 <create_user_vaddr_bitmap>:
create_user_vaddr_bitmap():
/work/x86_os_my/userprog/process.c:117

/* 创建用户进程虚拟地址位图 */
void create_user_vaddr_bitmap(struct task_struct* user_prog) {
c0004768:	55                   	push   %ebp
c0004769:	89 e5                	mov    %esp,%ebp
c000476b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:118
   user_prog->userprog_vaddr.vaddr_start = USER_VADDR_START;	// linux用户程序入口地址 0x80480000
c000476e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004771:	c7 40 40 00 80 04 08 	movl   $0x8048000,0x40(%eax)
/work/x86_os_my/userprog/process.c:119
   uint32_t bitmap_pg_cnt = DIV_ROUND_UP((0xc0000000 - USER_VADDR_START) / PG_SIZE / 8 , PG_SIZE);
c0004778:	c7 45 f4 17 00 00 00 	movl   $0x17,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:120
   user_prog->userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt);
c000477f:	83 ec 0c             	sub    $0xc,%esp
c0004782:	ff 75 f4             	pushl  -0xc(%ebp)
c0004785:	e8 80 e2 ff ff       	call   c0002a0a <get_kernel_pages>
c000478a:	83 c4 10             	add    $0x10,%esp
c000478d:	89 c2                	mov    %eax,%edx
c000478f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004792:	89 50 3c             	mov    %edx,0x3c(%eax)
/work/x86_os_my/userprog/process.c:121
   user_prog->userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (0xc0000000 - USER_VADDR_START) / PG_SIZE / 8;
c0004795:	8b 45 08             	mov    0x8(%ebp),%eax
c0004798:	c7 40 38 f7 6f 01 00 	movl   $0x16ff7,0x38(%eax)
/work/x86_os_my/userprog/process.c:122
   bitmap_init(&user_prog->userprog_vaddr.vaddr_bitmap);
c000479f:	8b 45 08             	mov    0x8(%ebp),%eax
c00047a2:	83 c0 38             	add    $0x38,%eax
c00047a5:	83 ec 0c             	sub    $0xc,%esp
c00047a8:	50                   	push   %eax
c00047a9:	e8 8a dc ff ff       	call   c0002438 <bitmap_init>
c00047ae:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:123
}
c00047b1:	90                   	nop
c00047b2:	c9                   	leave  
c00047b3:	c3                   	ret    

c00047b4 <process_execute>:
process_execute():
/work/x86_os_my/userprog/process.c:126

/* 创建用户进程 */
void process_execute(void* filename, char* name) {
c00047b4:	55                   	push   %ebp
c00047b5:	89 e5                	mov    %esp,%ebp
c00047b7:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:128
   /* pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 */
   struct task_struct* thread = get_kernel_pages(1);
c00047ba:	83 ec 0c             	sub    $0xc,%esp
c00047bd:	6a 01                	push   $0x1
c00047bf:	e8 46 e2 ff ff       	call   c0002a0a <get_kernel_pages>
c00047c4:	83 c4 10             	add    $0x10,%esp
c00047c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:129
   init_thread(thread, name, default_prio);			//初始化线程PCB结构体 struct task_struct
c00047ca:	83 ec 04             	sub    $0x4,%esp
c00047cd:	6a 1f                	push   $0x1f
c00047cf:	ff 75 0c             	pushl  0xc(%ebp)
c00047d2:	ff 75 f4             	pushl  -0xc(%ebp)
c00047d5:	e8 67 eb ff ff       	call   c0003341 <init_thread>
c00047da:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:130
   create_user_vaddr_bitmap(thread);				//【进程新增】创建用户进程，虚拟地址空间位图
c00047dd:	83 ec 0c             	sub    $0xc,%esp
c00047e0:	ff 75 f4             	pushl  -0xc(%ebp)
c00047e3:	e8 80 ff ff ff       	call   c0004768 <create_user_vaddr_bitmap>
c00047e8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:131
   thread_create(thread, start_process, filename);	//初始化线程栈结构体 struct thread_stack
c00047eb:	83 ec 04             	sub    $0x4,%esp
c00047ee:	ff 75 08             	pushl  0x8(%ebp)
c00047f1:	68 68 45 00 c0       	push   $0xc0004568
c00047f6:	ff 75 f4             	pushl  -0xc(%ebp)
c00047f9:	e8 cc ea ff ff       	call   c00032ca <thread_create>
c00047fe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:132
   thread->pgdir = create_page_dir();				//【进程新增】创建用户进程，页目录表
c0004801:	e8 ea fe ff ff       	call   c00046f0 <create_page_dir>
c0004806:	89 c2                	mov    %eax,%edx
c0004808:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000480b:	89 50 34             	mov    %edx,0x34(%eax)
/work/x86_os_my/userprog/process.c:134
   
   enum intr_status old_status = intr_disable();
c000480e:	e8 26 d2 ff ff       	call   c0001a39 <intr_disable>
c0004813:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:135
   ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));
c0004816:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004819:	83 c0 24             	add    $0x24,%eax
c000481c:	83 ec 08             	sub    $0x8,%esp
c000481f:	50                   	push   %eax
c0004820:	68 cc 7a 00 c0       	push   $0xc0007acc
c0004825:	e8 fc f0 ff ff       	call   c0003926 <elem_find>
c000482a:	83 c4 10             	add    $0x10,%esp
c000482d:	85 c0                	test   %eax,%eax
c000482f:	74 1c                	je     c000484d <process_execute+0x99>
/work/x86_os_my/userprog/process.c:135 (discriminator 1)
c0004831:	68 a0 58 00 c0       	push   $0xc00058a0
c0004836:	68 20 59 00 c0       	push   $0xc0005920
c000483b:	68 87 00 00 00       	push   $0x87
c0004840:	68 61 58 00 c0       	push   $0xc0005861
c0004845:	e8 18 db ff ff       	call   c0002362 <panic_spin>
c000484a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:136
   list_append(&thread_ready_list, &thread->general_tag);
c000484d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004850:	83 c0 24             	add    $0x24,%eax
c0004853:	83 ec 08             	sub    $0x8,%esp
c0004856:	50                   	push   %eax
c0004857:	68 cc 7a 00 c0       	push   $0xc0007acc
c000485c:	e8 4b f0 ff ff       	call   c00038ac <list_append>
c0004861:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:137
   ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
c0004864:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004867:	83 c0 2c             	add    $0x2c,%eax
c000486a:	83 ec 08             	sub    $0x8,%esp
c000486d:	50                   	push   %eax
c000486e:	68 dc 7a 00 c0       	push   $0xc0007adc
c0004873:	e8 ae f0 ff ff       	call   c0003926 <elem_find>
c0004878:	83 c4 10             	add    $0x10,%esp
c000487b:	85 c0                	test   %eax,%eax
c000487d:	74 1c                	je     c000489b <process_execute+0xe7>
/work/x86_os_my/userprog/process.c:137 (discriminator 1)
c000487f:	68 d8 58 00 c0       	push   $0xc00058d8
c0004884:	68 20 59 00 c0       	push   $0xc0005920
c0004889:	68 89 00 00 00       	push   $0x89
c000488e:	68 61 58 00 c0       	push   $0xc0005861
c0004893:	e8 ca da ff ff       	call   c0002362 <panic_spin>
c0004898:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:138
   list_append(&thread_all_list, &thread->all_list_tag);
c000489b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000489e:	83 c0 2c             	add    $0x2c,%eax
c00048a1:	83 ec 08             	sub    $0x8,%esp
c00048a4:	50                   	push   %eax
c00048a5:	68 dc 7a 00 c0       	push   $0xc0007adc
c00048aa:	e8 fd ef ff ff       	call   c00038ac <list_append>
c00048af:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:139
   intr_set_status(old_status);
c00048b2:	83 ec 0c             	sub    $0xc,%esp
c00048b5:	ff 75 f0             	pushl  -0x10(%ebp)
c00048b8:	e8 a5 d1 ff ff       	call   c0001a62 <intr_set_status>
c00048bd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:140
}
c00048c0:	90                   	nop
c00048c1:	c9                   	leave  
c00048c2:	c3                   	ret    

c00048c3 <getpid>:
getpid():
/work/x86_os_my/lib/user/syscall.c:52
   );							       \
   retval;						       \
})

/* 返回当前任务pid */
uint32_t getpid() {
c00048c3:	55                   	push   %ebp
c00048c4:	89 e5                	mov    %esp,%ebp
c00048c6:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:53
   return _syscall0(SYS_GETPID);
c00048c9:	b8 00 00 00 00       	mov    $0x0,%eax
c00048ce:	cd 80                	int    $0x80
c00048d0:	89 45 fc             	mov    %eax,-0x4(%ebp)
c00048d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:54
}
c00048d6:	c9                   	leave  
c00048d7:	c3                   	ret    

c00048d8 <write>:
write():
/work/x86_os_my/lib/user/syscall.c:57

/* 打印字符串str */
uint32_t write(char* str) {
c00048d8:	55                   	push   %ebp
c00048d9:	89 e5                	mov    %esp,%ebp
c00048db:	53                   	push   %ebx
c00048dc:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:58
	return _syscall1(SYS_WRITE, str);
c00048df:	b8 01 00 00 00       	mov    $0x1,%eax
c00048e4:	8b 55 08             	mov    0x8(%ebp),%edx
c00048e7:	89 d3                	mov    %edx,%ebx
c00048e9:	cd 80                	int    $0x80
c00048eb:	89 45 f8             	mov    %eax,-0x8(%ebp)
c00048ee:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:59
}
c00048f1:	83 c4 10             	add    $0x10,%esp
c00048f4:	5b                   	pop    %ebx
c00048f5:	5d                   	pop    %ebp
c00048f6:	c3                   	ret    

c00048f7 <sys_getpid>:
sys_getpid():
/work/x86_os_my/userprog/syscall-init.c:14
#define syscall_nr 32 
typedef void* syscall;
syscall syscall_table[syscall_nr];

/* 返回当前任务的pid */
uint32_t sys_getpid(void) {
c00048f7:	55                   	push   %ebp
c00048f8:	89 e5                	mov    %esp,%ebp
c00048fa:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/syscall-init.c:15
   return running_thread()->pid;
c00048fd:	e8 58 e9 ff ff       	call   c000325a <running_thread>
c0004902:	0f b7 40 04          	movzwl 0x4(%eax),%eax
c0004906:	98                   	cwtl   
/work/x86_os_my/userprog/syscall-init.c:16
}
c0004907:	c9                   	leave  
c0004908:	c3                   	ret    

c0004909 <sys_write>:
sys_write():
/work/x86_os_my/userprog/syscall-init.c:19

/* 打印字符串str(未实现文件系统前的版本) */
uint32_t sys_write(char* str) {
c0004909:	55                   	push   %ebp
c000490a:	89 e5                	mov    %esp,%ebp
c000490c:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/syscall-init.c:20
	console_put_str(str);
c000490f:	83 ec 0c             	sub    $0xc,%esp
c0004912:	ff 75 08             	pushl  0x8(%ebp)
c0004915:	e8 56 f1 ff ff       	call   c0003a70 <console_put_str>
c000491a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:21
	return strlen(str);
c000491d:	83 ec 0c             	sub    $0xc,%esp
c0004920:	ff 75 08             	pushl  0x8(%ebp)
c0004923:	e8 ec e6 ff ff       	call   c0003014 <strlen>
c0004928:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:22
}
c000492b:	c9                   	leave  
c000492c:	c3                   	ret    

c000492d <syscall_init>:
syscall_init():
/work/x86_os_my/userprog/syscall-init.c:25

/* 初始化系统调用 */
void syscall_init(void) {
c000492d:	55                   	push   %ebp
c000492e:	89 e5                	mov    %esp,%ebp
c0004930:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/syscall-init.c:26
   put_str("syscall_init start\n");
c0004933:	83 ec 0c             	sub    $0xc,%esp
c0004936:	68 30 59 00 c0       	push   $0xc0005930
c000493b:	e8 b0 d8 ff ff       	call   c00021f0 <put_str>
c0004940:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:27
   syscall_table[SYS_GETPID] = sys_getpid;
c0004943:	c7 05 a0 7b 00 c0 f7 	movl   $0xc00048f7,0xc0007ba0
c000494a:	48 00 c0 
/work/x86_os_my/userprog/syscall-init.c:28
   syscall_table[SYS_WRITE] = sys_write;
c000494d:	c7 05 a4 7b 00 c0 09 	movl   $0xc0004909,0xc0007ba4
c0004954:	49 00 c0 
/work/x86_os_my/userprog/syscall-init.c:29
   put_str("syscall_init done\n");
c0004957:	83 ec 0c             	sub    $0xc,%esp
c000495a:	68 44 59 00 c0       	push   $0xc0005944
c000495f:	e8 8c d8 ff ff       	call   c00021f0 <put_str>
c0004964:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:30
}
c0004967:	90                   	nop
c0004968:	c9                   	leave  
c0004969:	c3                   	ret    

c000496a <itoa>:
itoa():
/work/x86_os_my/lib/stdio.c:13
#define va_start(ap, v) ap = (va_list)&v	// 把ap指向第一个固定参数v
#define va_arg(ap, t) *((t*)(ap += 4))		// ap指向下一个参数并返回其值
#define va_end(ap) ap = NULL				// 清除ap

/* 将整型转换成字符(integer to ascii) */
static void itoa(uint32_t value, char** buf_ptr_addr, uint8_t base) {
c000496a:	55                   	push   %ebp
c000496b:	89 e5                	mov    %esp,%ebp
c000496d:	83 ec 28             	sub    $0x28,%esp
c0004970:	8b 45 10             	mov    0x10(%ebp),%eax
c0004973:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/stdio.c:14
	uint32_t m = value % base;	// 求模,最先掉下来的是最低位【比如base是16代表16进制】 
c0004976:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c000497a:	8b 45 08             	mov    0x8(%ebp),%eax
c000497d:	ba 00 00 00 00       	mov    $0x0,%edx
c0004982:	f7 f1                	div    %ecx
c0004984:	89 55 f4             	mov    %edx,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:15
	uint32_t i = value / base;	// 取整
c0004987:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c000498b:	8b 45 08             	mov    0x8(%ebp),%eax
c000498e:	ba 00 00 00 00       	mov    $0x0,%edx
c0004993:	f7 f1                	div    %ecx
c0004995:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/stdio.c:16
	if (i) {
c0004998:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000499c:	74 16                	je     c00049b4 <itoa+0x4a>
/work/x86_os_my/lib/stdio.c:17
		itoa(i, buf_ptr_addr, base);	// 如果倍数不为0则递归调用。
c000499e:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c00049a2:	83 ec 04             	sub    $0x4,%esp
c00049a5:	50                   	push   %eax
c00049a6:	ff 75 0c             	pushl  0xc(%ebp)
c00049a9:	ff 75 f0             	pushl  -0x10(%ebp)
c00049ac:	e8 b9 ff ff ff       	call   c000496a <itoa>
c00049b1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:19
	}
	if (m < 10) {	// 如果余数是0~9
c00049b4:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c00049b8:	77 17                	ja     c00049d1 <itoa+0x67>
/work/x86_os_my/lib/stdio.c:20
		*((*buf_ptr_addr)++) = m + '0';			// 将数字0~9转换为字符'0'~'9'
c00049ba:	8b 45 0c             	mov    0xc(%ebp),%eax
c00049bd:	8b 00                	mov    (%eax),%eax
c00049bf:	8d 48 01             	lea    0x1(%eax),%ecx
c00049c2:	8b 55 0c             	mov    0xc(%ebp),%edx
c00049c5:	89 0a                	mov    %ecx,(%edx)
c00049c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00049ca:	83 c2 30             	add    $0x30,%edx
c00049cd:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:24
	} else {		// 否则余数是A~F
		*((*buf_ptr_addr)++) = m - 10 + 'A';	// 将数字A~F转换为字符'A'~'F'
	}
}
c00049cf:	eb 15                	jmp    c00049e6 <itoa+0x7c>
/work/x86_os_my/lib/stdio.c:22
		itoa(i, buf_ptr_addr, base);	// 如果倍数不为0则递归调用。
	}
	if (m < 10) {	// 如果余数是0~9
		*((*buf_ptr_addr)++) = m + '0';			// 将数字0~9转换为字符'0'~'9'
	} else {		// 否则余数是A~F
		*((*buf_ptr_addr)++) = m - 10 + 'A';	// 将数字A~F转换为字符'A'~'F'
c00049d1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00049d4:	8b 00                	mov    (%eax),%eax
c00049d6:	8d 48 01             	lea    0x1(%eax),%ecx
c00049d9:	8b 55 0c             	mov    0xc(%ebp),%edx
c00049dc:	89 0a                	mov    %ecx,(%edx)
c00049de:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00049e1:	83 c2 37             	add    $0x37,%edx
c00049e4:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:24
	}
}
c00049e6:	90                   	nop
c00049e7:	c9                   	leave  
c00049e8:	c3                   	ret    

c00049e9 <vsprintf>:
vsprintf():
/work/x86_os_my/lib/stdio.c:27

/* 将参数ap按照格式format输出到字符串str,并返回替换后str长度 */
uint32_t vsprintf(char* str, const char* format, va_list ap) {
c00049e9:	55                   	push   %ebp
c00049ea:	89 e5                	mov    %esp,%ebp
c00049ec:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/lib/stdio.c:28
	char* buf_ptr = str;
c00049ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00049f2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/stdio.c:29
	const char* index_ptr = format;
c00049f5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00049f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:30
	char index_char = *index_ptr;
c00049fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00049fe:	0f b6 00             	movzbl (%eax),%eax
c0004a01:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:33
	int32_t arg_int;
	char* arg_str;
	while(index_char) {
c0004a04:	e9 43 01 00 00       	jmp    c0004b4c <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:34
		if (index_char != '%') {
c0004a09:	80 7d f3 25          	cmpb   $0x25,-0xd(%ebp)
c0004a0d:	74 21                	je     c0004a30 <vsprintf+0x47>
/work/x86_os_my/lib/stdio.c:35
			*(buf_ptr++) = index_char;
c0004a0f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0004a12:	8d 50 01             	lea    0x1(%eax),%edx
c0004a15:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0004a18:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
c0004a1c:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:36
			index_char = *(++index_ptr);
c0004a1e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0004a22:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004a25:	0f b6 00             	movzbl (%eax),%eax
c0004a28:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:37
			continue;
c0004a2b:	e9 1c 01 00 00       	jmp    c0004b4c <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:39
		}
		index_char = *(++index_ptr);	 // 得到%后面的字符
c0004a30:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0004a34:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004a37:	0f b6 00             	movzbl (%eax),%eax
c0004a3a:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:40
		switch(index_char) {
c0004a3d:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
c0004a41:	83 f8 64             	cmp    $0x64,%eax
c0004a44:	0f 84 8e 00 00 00    	je     c0004ad8 <vsprintf+0xef>
c0004a4a:	83 f8 64             	cmp    $0x64,%eax
c0004a4d:	7f 0a                	jg     c0004a59 <vsprintf+0x70>
c0004a4f:	83 f8 63             	cmp    $0x63,%eax
c0004a52:	74 60                	je     c0004ab4 <vsprintf+0xcb>
c0004a54:	e9 f3 00 00 00       	jmp    c0004b4c <vsprintf+0x163>
c0004a59:	83 f8 73             	cmp    $0x73,%eax
c0004a5c:	74 0e                	je     c0004a6c <vsprintf+0x83>
c0004a5e:	83 f8 78             	cmp    $0x78,%eax
c0004a61:	0f 84 b6 00 00 00    	je     c0004b1d <vsprintf+0x134>
c0004a67:	e9 e0 00 00 00       	jmp    c0004b4c <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:42
			case 's':
			arg_str = va_arg(ap, char*);
c0004a6c:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c0004a70:	8b 45 10             	mov    0x10(%ebp),%eax
c0004a73:	8b 00                	mov    (%eax),%eax
c0004a75:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/lib/stdio.c:43
			strcpy(buf_ptr, arg_str);
c0004a78:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0004a7b:	83 ec 08             	sub    $0x8,%esp
c0004a7e:	ff 75 e8             	pushl  -0x18(%ebp)
c0004a81:	50                   	push   %eax
c0004a82:	e8 38 e5 ff ff       	call   c0002fbf <strcpy>
c0004a87:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:44
			buf_ptr += strlen(arg_str);
c0004a8a:	83 ec 0c             	sub    $0xc,%esp
c0004a8d:	ff 75 e8             	pushl  -0x18(%ebp)
c0004a90:	e8 7f e5 ff ff       	call   c0003014 <strlen>
c0004a95:	83 c4 10             	add    $0x10,%esp
c0004a98:	89 c2                	mov    %eax,%edx
c0004a9a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0004a9d:	01 d0                	add    %edx,%eax
c0004a9f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/stdio.c:45
			index_char = *(++index_ptr);
c0004aa2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0004aa6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004aa9:	0f b6 00             	movzbl (%eax),%eax
c0004aac:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:46
			break;
c0004aaf:	e9 98 00 00 00       	jmp    c0004b4c <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:49

			case 'c':
			*(buf_ptr++) = va_arg(ap, char);
c0004ab4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0004ab7:	8d 50 01             	lea    0x1(%eax),%edx
c0004aba:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0004abd:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c0004ac1:	8b 55 10             	mov    0x10(%ebp),%edx
c0004ac4:	0f b6 12             	movzbl (%edx),%edx
c0004ac7:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:50
			index_char = *(++index_ptr);
c0004ac9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0004acd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004ad0:	0f b6 00             	movzbl (%eax),%eax
c0004ad3:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:51
			break;
c0004ad6:	eb 74                	jmp    c0004b4c <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:54

			case 'd':
			arg_int = va_arg(ap, int);
c0004ad8:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c0004adc:	8b 45 10             	mov    0x10(%ebp),%eax
c0004adf:	8b 00                	mov    (%eax),%eax
c0004ae1:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/stdio.c:56
			/* 若是负数, 将其转为正数后,再正数前面输出个负号'-'. */
			if (arg_int < 0) {
c0004ae4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0004ae8:	79 0f                	jns    c0004af9 <vsprintf+0x110>
/work/x86_os_my/lib/stdio.c:57
				arg_int = 0 - arg_int;
c0004aea:	f7 5d ec             	negl   -0x14(%ebp)
/work/x86_os_my/lib/stdio.c:58
				*buf_ptr++ = '-';
c0004aed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0004af0:	8d 50 01             	lea    0x1(%eax),%edx
c0004af3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0004af6:	c6 00 2d             	movb   $0x2d,(%eax)
/work/x86_os_my/lib/stdio.c:60
			}
			itoa(arg_int, &buf_ptr, 10); 
c0004af9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004afc:	83 ec 04             	sub    $0x4,%esp
c0004aff:	6a 0a                	push   $0xa
c0004b01:	8d 55 e4             	lea    -0x1c(%ebp),%edx
c0004b04:	52                   	push   %edx
c0004b05:	50                   	push   %eax
c0004b06:	e8 5f fe ff ff       	call   c000496a <itoa>
c0004b0b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:61
			index_char = *(++index_ptr);
c0004b0e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0004b12:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004b15:	0f b6 00             	movzbl (%eax),%eax
c0004b18:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:62
			break;
c0004b1b:	eb 2f                	jmp    c0004b4c <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:65

			case 'x':
			arg_int = va_arg(ap, int);
c0004b1d:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c0004b21:	8b 45 10             	mov    0x10(%ebp),%eax
c0004b24:	8b 00                	mov    (%eax),%eax
c0004b26:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/stdio.c:66
			itoa(arg_int, &buf_ptr, 16); 
c0004b29:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004b2c:	83 ec 04             	sub    $0x4,%esp
c0004b2f:	6a 10                	push   $0x10
c0004b31:	8d 55 e4             	lea    -0x1c(%ebp),%edx
c0004b34:	52                   	push   %edx
c0004b35:	50                   	push   %eax
c0004b36:	e8 2f fe ff ff       	call   c000496a <itoa>
c0004b3b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:67
			index_char = *(++index_ptr); // 跳过格式字符并更新index_char
c0004b3e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0004b42:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004b45:	0f b6 00             	movzbl (%eax),%eax
c0004b48:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:68
			break;
c0004b4b:	90                   	nop
/work/x86_os_my/lib/stdio.c:33
	char* buf_ptr = str;
	const char* index_ptr = format;
	char index_char = *index_ptr;
	int32_t arg_int;
	char* arg_str;
	while(index_char) {
c0004b4c:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c0004b50:	0f 85 b3 fe ff ff    	jne    c0004a09 <vsprintf+0x20>
/work/x86_os_my/lib/stdio.c:71
			itoa(arg_int, &buf_ptr, 16); 
			index_char = *(++index_ptr); // 跳过格式字符并更新index_char
			break;
		}
	}
	return strlen(str);
c0004b56:	83 ec 0c             	sub    $0xc,%esp
c0004b59:	ff 75 08             	pushl  0x8(%ebp)
c0004b5c:	e8 b3 e4 ff ff       	call   c0003014 <strlen>
c0004b61:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:72
}
c0004b64:	c9                   	leave  
c0004b65:	c3                   	ret    

c0004b66 <sprintf>:
sprintf():
/work/x86_os_my/lib/stdio.c:75

/* 同printf不同的地方就是字符串不是写到终端,而是写到buf中 */
uint32_t sprintf(char* buf, const char* format, ...) {
c0004b66:	55                   	push   %ebp
c0004b67:	89 e5                	mov    %esp,%ebp
c0004b69:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/stdio.c:78
	va_list args;
	uint32_t retval;
	va_start(args, format);
c0004b6c:	8d 45 0c             	lea    0xc(%ebp),%eax
c0004b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:79
	retval = vsprintf(buf, format, args);
c0004b72:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004b75:	83 ec 04             	sub    $0x4,%esp
c0004b78:	ff 75 f4             	pushl  -0xc(%ebp)
c0004b7b:	50                   	push   %eax
c0004b7c:	ff 75 08             	pushl  0x8(%ebp)
c0004b7f:	e8 65 fe ff ff       	call   c00049e9 <vsprintf>
c0004b84:	83 c4 10             	add    $0x10,%esp
c0004b87:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/stdio.c:80
	va_end(args);
c0004b8a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:81
	return retval;
c0004b91:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/lib/stdio.c:82
}
c0004b94:	c9                   	leave  
c0004b95:	c3                   	ret    

c0004b96 <printf>:
printf():
/work/x86_os_my/lib/stdio.c:85

/* 格式化输出字符串format */
uint32_t printf(const char* format, ...) {
c0004b96:	55                   	push   %ebp
c0004b97:	89 e5                	mov    %esp,%ebp
c0004b99:	57                   	push   %edi
c0004b9a:	81 ec 14 04 00 00    	sub    $0x414,%esp
/work/x86_os_my/lib/stdio.c:87
	va_list args;
	va_start(args, format);	       // 使args指向format
c0004ba0:	8d 45 08             	lea    0x8(%ebp),%eax
c0004ba3:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:88
	char buf[1024] = {0};	       // 用于存储拼接后的字符串
c0004ba6:	8d 95 f4 fb ff ff    	lea    -0x40c(%ebp),%edx
c0004bac:	b8 00 00 00 00       	mov    $0x0,%eax
c0004bb1:	b9 00 01 00 00       	mov    $0x100,%ecx
c0004bb6:	89 d7                	mov    %edx,%edi
c0004bb8:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/lib/stdio.c:89
	vsprintf(buf, format, args);
c0004bba:	8b 45 08             	mov    0x8(%ebp),%eax
c0004bbd:	83 ec 04             	sub    $0x4,%esp
c0004bc0:	ff 75 f4             	pushl  -0xc(%ebp)
c0004bc3:	50                   	push   %eax
c0004bc4:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c0004bca:	50                   	push   %eax
c0004bcb:	e8 19 fe ff ff       	call   c00049e9 <vsprintf>
c0004bd0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:90
	va_end(args);
c0004bd3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:91
	return write(buf);
c0004bda:	83 ec 0c             	sub    $0xc,%esp
c0004bdd:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c0004be3:	50                   	push   %eax
c0004be4:	e8 ef fc ff ff       	call   c00048d8 <write>
c0004be9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:92
}
c0004bec:	8b 7d fc             	mov    -0x4(%ebp),%edi
c0004bef:	c9                   	leave  
c0004bf0:	c3                   	ret    
