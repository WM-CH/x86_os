
./build/kernel.bin:     file format elf32-i386


Disassembly of section .text:

c0001500 <main>:
main():
/work/x86_os_my/kernel/main.c:33
void k_thread_a(void*);
void k_thread_b(void*);
void u_prog_a(void);
void u_prog_b(void);

int main(void) {
c0001500:	8d 4c 24 04          	lea    0x4(%esp),%ecx
c0001504:	83 e4 f0             	and    $0xfffffff0,%esp
c0001507:	ff 71 fc             	pushl  -0x4(%ecx)
c000150a:	55                   	push   %ebp
c000150b:	89 e5                	mov    %esp,%ebp
c000150d:	51                   	push   %ecx
c000150e:	83 ec 14             	sub    $0x14,%esp
/work/x86_os_my/kernel/main.c:34
	put_str("I am kernel\n");
c0001511:	83 ec 0c             	sub    $0xc,%esp
c0001514:	68 cc 86 00 c0       	push   $0xc00086cc
c0001519:	e8 a2 0f 00 00       	call   c00024c0 <put_str>
c000151e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:35
	init_all();
c0001521:	e8 a2 03 00 00       	call   c00018c8 <init_all>
/work/x86_os_my/kernel/main.c:36
	process_execute(u_prog_a, "u_prog_a");
c0001526:	83 ec 08             	sub    $0x8,%esp
c0001529:	68 d9 86 00 c0       	push   $0xc00086d9
c000152e:	68 96 17 00 c0       	push   $0xc0001796
c0001533:	e8 6c 3f 00 00       	call   c00054a4 <process_execute>
c0001538:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:37
	process_execute(u_prog_b, "u_prog_b");
c000153b:	83 ec 08             	sub    $0x8,%esp
c000153e:	68 e2 86 00 c0       	push   $0xc00086e2
c0001543:	68 2f 18 00 c0       	push   $0xc000182f
c0001548:	e8 57 3f 00 00       	call   c00054a4 <process_execute>
c000154d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:38
	thread_start("k_thread_a", 31, k_thread_a, "I am thread_a");
c0001550:	68 eb 86 00 c0       	push   $0xc00086eb
c0001555:	68 ce 15 00 c0       	push   $0xc00015ce
c000155a:	6a 1f                	push   $0x1f
c000155c:	68 f9 86 00 c0       	push   $0xc00086f9
c0001561:	e8 9f 2a 00 00       	call   c0004005 <thread_start>
c0001566:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:39
	thread_start("k_thread_b", 31, k_thread_b, "I am thread_b");
c0001569:	68 04 87 00 c0       	push   $0xc0008704
c000156e:	68 b2 16 00 c0       	push   $0xc00016b2
c0001573:	6a 1f                	push   $0x1f
c0001575:	68 12 87 00 c0       	push   $0xc0008712
c000157a:	e8 86 2a 00 00       	call   c0004005 <thread_start>
c000157f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:41

	uint32_t fd = sys_open("/file1", O_RDONLY);
c0001582:	83 ec 08             	sub    $0x8,%esp
c0001585:	6a 00                	push   $0x0
c0001587:	68 1d 87 00 c0       	push   $0xc000871d
c000158c:	e8 55 5b 00 00       	call   c00070e6 <sys_open>
c0001591:	83 c4 10             	add    $0x10,%esp
c0001594:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:42
	printf("fd:%d\n", fd);
c0001597:	83 ec 08             	sub    $0x8,%esp
c000159a:	ff 75 f4             	pushl  -0xc(%ebp)
c000159d:	68 24 87 00 c0       	push   $0xc0008724
c00015a2:	e8 41 43 00 00       	call   c00058e8 <printf>
c00015a7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:43
	sys_close(fd);
c00015aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00015ad:	83 ec 0c             	sub    $0xc,%esp
c00015b0:	50                   	push   %eax
c00015b1:	e8 dd 5d 00 00       	call   c0007393 <sys_close>
c00015b6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:44
	printf("%d closed now\n", fd);
c00015b9:	83 ec 08             	sub    $0x8,%esp
c00015bc:	ff 75 f4             	pushl  -0xc(%ebp)
c00015bf:	68 2b 87 00 c0       	push   $0xc000872b
c00015c4:	e8 1f 43 00 00       	call   c00058e8 <printf>
c00015c9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:45 (discriminator 1)
	while(1);
c00015cc:	eb fe                	jmp    c00015cc <main+0xcc>

c00015ce <k_thread_a>:
k_thread_a():
/work/x86_os_my/kernel/main.c:50
	return 0;
}

/* 在线程中运行的函数 */
void k_thread_a(void* arg) {     
c00015ce:	55                   	push   %ebp
c00015cf:	89 e5                	mov    %esp,%ebp
c00015d1:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:51
	void* addr1 = sys_malloc(256);
c00015d4:	83 ec 0c             	sub    $0xc,%esp
c00015d7:	68 00 01 00 00       	push   $0x100
c00015dc:	e8 72 19 00 00       	call   c0002f53 <sys_malloc>
c00015e1:	83 c4 10             	add    $0x10,%esp
c00015e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/main.c:52
	void* addr2 = sys_malloc(255);
c00015e7:	83 ec 0c             	sub    $0xc,%esp
c00015ea:	68 ff 00 00 00       	push   $0xff
c00015ef:	e8 5f 19 00 00       	call   c0002f53 <sys_malloc>
c00015f4:	83 c4 10             	add    $0x10,%esp
c00015f7:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/main.c:53
	void* addr3 = sys_malloc(254);
c00015fa:	83 ec 0c             	sub    $0xc,%esp
c00015fd:	68 fe 00 00 00       	push   $0xfe
c0001602:	e8 4c 19 00 00       	call   c0002f53 <sys_malloc>
c0001607:	83 c4 10             	add    $0x10,%esp
c000160a:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/main.c:54
	console_put_str(" thread_a malloc addr:0x");
c000160d:	83 ec 0c             	sub    $0xc,%esp
c0001610:	68 3a 87 00 c0       	push   $0xc000873a
c0001615:	e8 46 31 00 00       	call   c0004760 <console_put_str>
c000161a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:55
	console_put_int((int)addr1);
c000161d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001620:	83 ec 0c             	sub    $0xc,%esp
c0001623:	50                   	push   %eax
c0001624:	e8 81 31 00 00       	call   c00047aa <console_put_int>
c0001629:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:56
	console_put_char(',');
c000162c:	83 ec 0c             	sub    $0xc,%esp
c000162f:	6a 2c                	push   $0x2c
c0001631:	e8 4b 31 00 00       	call   c0004781 <console_put_char>
c0001636:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:57
	console_put_int((int)addr2);
c0001639:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000163c:	83 ec 0c             	sub    $0xc,%esp
c000163f:	50                   	push   %eax
c0001640:	e8 65 31 00 00       	call   c00047aa <console_put_int>
c0001645:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:58
	console_put_char(',');
c0001648:	83 ec 0c             	sub    $0xc,%esp
c000164b:	6a 2c                	push   $0x2c
c000164d:	e8 2f 31 00 00       	call   c0004781 <console_put_char>
c0001652:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:59
	console_put_int((int)addr3);
c0001655:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001658:	83 ec 0c             	sub    $0xc,%esp
c000165b:	50                   	push   %eax
c000165c:	e8 49 31 00 00       	call   c00047aa <console_put_int>
c0001661:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:60
	console_put_char('\n');
c0001664:	83 ec 0c             	sub    $0xc,%esp
c0001667:	6a 0a                	push   $0xa
c0001669:	e8 13 31 00 00       	call   c0004781 <console_put_char>
c000166e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:62

	int cpu_delay = 100000;
c0001671:	c7 45 f4 a0 86 01 00 	movl   $0x186a0,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:63
	while(cpu_delay-- > 0);
c0001678:	90                   	nop
/work/x86_os_my/kernel/main.c:63 (discriminator 1)
c0001679:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000167c:	8d 50 ff             	lea    -0x1(%eax),%edx
c000167f:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001682:	85 c0                	test   %eax,%eax
c0001684:	7f f3                	jg     c0001679 <k_thread_a+0xab>
/work/x86_os_my/kernel/main.c:64
	sys_free(addr1);
c0001686:	83 ec 0c             	sub    $0xc,%esp
c0001689:	ff 75 f0             	pushl  -0x10(%ebp)
c000168c:	e8 ef 1e 00 00       	call   c0003580 <sys_free>
c0001691:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:65
	sys_free(addr2);
c0001694:	83 ec 0c             	sub    $0xc,%esp
c0001697:	ff 75 ec             	pushl  -0x14(%ebp)
c000169a:	e8 e1 1e 00 00       	call   c0003580 <sys_free>
c000169f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:66
	sys_free(addr3);
c00016a2:	83 ec 0c             	sub    $0xc,%esp
c00016a5:	ff 75 e8             	pushl  -0x18(%ebp)
c00016a8:	e8 d3 1e 00 00       	call   c0003580 <sys_free>
c00016ad:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:67 (discriminator 1)
	while(1);
c00016b0:	eb fe                	jmp    c00016b0 <k_thread_a+0xe2>

c00016b2 <k_thread_b>:
k_thread_b():
/work/x86_os_my/kernel/main.c:71
}

/* 在线程中运行的函数 */
void k_thread_b(void* arg) {     
c00016b2:	55                   	push   %ebp
c00016b3:	89 e5                	mov    %esp,%ebp
c00016b5:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:72
	void* addr1 = sys_malloc(256);
c00016b8:	83 ec 0c             	sub    $0xc,%esp
c00016bb:	68 00 01 00 00       	push   $0x100
c00016c0:	e8 8e 18 00 00       	call   c0002f53 <sys_malloc>
c00016c5:	83 c4 10             	add    $0x10,%esp
c00016c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/main.c:73
	void* addr2 = sys_malloc(255);
c00016cb:	83 ec 0c             	sub    $0xc,%esp
c00016ce:	68 ff 00 00 00       	push   $0xff
c00016d3:	e8 7b 18 00 00       	call   c0002f53 <sys_malloc>
c00016d8:	83 c4 10             	add    $0x10,%esp
c00016db:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/main.c:74
	void* addr3 = sys_malloc(254);
c00016de:	83 ec 0c             	sub    $0xc,%esp
c00016e1:	68 fe 00 00 00       	push   $0xfe
c00016e6:	e8 68 18 00 00       	call   c0002f53 <sys_malloc>
c00016eb:	83 c4 10             	add    $0x10,%esp
c00016ee:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/main.c:75
	console_put_str(" thread_b malloc addr:0x");
c00016f1:	83 ec 0c             	sub    $0xc,%esp
c00016f4:	68 53 87 00 c0       	push   $0xc0008753
c00016f9:	e8 62 30 00 00       	call   c0004760 <console_put_str>
c00016fe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:76
	console_put_int((int)addr1);
c0001701:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001704:	83 ec 0c             	sub    $0xc,%esp
c0001707:	50                   	push   %eax
c0001708:	e8 9d 30 00 00       	call   c00047aa <console_put_int>
c000170d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:77
	console_put_char(',');
c0001710:	83 ec 0c             	sub    $0xc,%esp
c0001713:	6a 2c                	push   $0x2c
c0001715:	e8 67 30 00 00       	call   c0004781 <console_put_char>
c000171a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:78
	console_put_int((int)addr2);
c000171d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001720:	83 ec 0c             	sub    $0xc,%esp
c0001723:	50                   	push   %eax
c0001724:	e8 81 30 00 00       	call   c00047aa <console_put_int>
c0001729:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:79
	console_put_char(',');
c000172c:	83 ec 0c             	sub    $0xc,%esp
c000172f:	6a 2c                	push   $0x2c
c0001731:	e8 4b 30 00 00       	call   c0004781 <console_put_char>
c0001736:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:80
	console_put_int((int)addr3);
c0001739:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000173c:	83 ec 0c             	sub    $0xc,%esp
c000173f:	50                   	push   %eax
c0001740:	e8 65 30 00 00       	call   c00047aa <console_put_int>
c0001745:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:81
	console_put_char('\n');
c0001748:	83 ec 0c             	sub    $0xc,%esp
c000174b:	6a 0a                	push   $0xa
c000174d:	e8 2f 30 00 00       	call   c0004781 <console_put_char>
c0001752:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:83

	int cpu_delay = 100000;
c0001755:	c7 45 f4 a0 86 01 00 	movl   $0x186a0,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:84
	while(cpu_delay-- > 0);
c000175c:	90                   	nop
/work/x86_os_my/kernel/main.c:84 (discriminator 1)
c000175d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001760:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001763:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001766:	85 c0                	test   %eax,%eax
c0001768:	7f f3                	jg     c000175d <k_thread_b+0xab>
/work/x86_os_my/kernel/main.c:85
	sys_free(addr1);
c000176a:	83 ec 0c             	sub    $0xc,%esp
c000176d:	ff 75 f0             	pushl  -0x10(%ebp)
c0001770:	e8 0b 1e 00 00       	call   c0003580 <sys_free>
c0001775:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:86
	sys_free(addr2);
c0001778:	83 ec 0c             	sub    $0xc,%esp
c000177b:	ff 75 ec             	pushl  -0x14(%ebp)
c000177e:	e8 fd 1d 00 00       	call   c0003580 <sys_free>
c0001783:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:87
	sys_free(addr3);
c0001786:	83 ec 0c             	sub    $0xc,%esp
c0001789:	ff 75 e8             	pushl  -0x18(%ebp)
c000178c:	e8 ef 1d 00 00       	call   c0003580 <sys_free>
c0001791:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:88 (discriminator 1)
	while(1);
c0001794:	eb fe                	jmp    c0001794 <k_thread_b+0xe2>

c0001796 <u_prog_a>:
u_prog_a():
/work/x86_os_my/kernel/main.c:92
}

/* 测试用户进程 */
void u_prog_a(void) {
c0001796:	55                   	push   %ebp
c0001797:	89 e5                	mov    %esp,%ebp
c0001799:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:93
	void* addr1 = malloc(256);
c000179c:	83 ec 0c             	sub    $0xc,%esp
c000179f:	68 00 01 00 00       	push   $0x100
c00017a4:	e8 50 3e 00 00       	call   c00055f9 <malloc>
c00017a9:	83 c4 10             	add    $0x10,%esp
c00017ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/main.c:94
	void* addr2 = malloc(255);
c00017af:	83 ec 0c             	sub    $0xc,%esp
c00017b2:	68 ff 00 00 00       	push   $0xff
c00017b7:	e8 3d 3e 00 00       	call   c00055f9 <malloc>
c00017bc:	83 c4 10             	add    $0x10,%esp
c00017bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/main.c:95
	void* addr3 = malloc(254);
c00017c2:	83 ec 0c             	sub    $0xc,%esp
c00017c5:	68 fe 00 00 00       	push   $0xfe
c00017ca:	e8 2a 3e 00 00       	call   c00055f9 <malloc>
c00017cf:	83 c4 10             	add    $0x10,%esp
c00017d2:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/main.c:96
	printf(" prog_a malloc addr:0x%x,0x%x,0x%x\n", (int)addr1, (int)addr2, (int)addr3);
c00017d5:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c00017d8:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00017db:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00017de:	51                   	push   %ecx
c00017df:	52                   	push   %edx
c00017e0:	50                   	push   %eax
c00017e1:	68 6c 87 00 c0       	push   $0xc000876c
c00017e6:	e8 fd 40 00 00       	call   c00058e8 <printf>
c00017eb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:98

	int cpu_delay = 100000;
c00017ee:	c7 45 f4 a0 86 01 00 	movl   $0x186a0,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:99
	while(cpu_delay-- > 0);
c00017f5:	90                   	nop
/work/x86_os_my/kernel/main.c:99 (discriminator 1)
c00017f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00017f9:	8d 50 ff             	lea    -0x1(%eax),%edx
c00017fc:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00017ff:	85 c0                	test   %eax,%eax
c0001801:	7f f3                	jg     c00017f6 <u_prog_a+0x60>
/work/x86_os_my/kernel/main.c:100
	free(addr1);
c0001803:	83 ec 0c             	sub    $0xc,%esp
c0001806:	ff 75 f0             	pushl  -0x10(%ebp)
c0001809:	e8 0a 3e 00 00       	call   c0005618 <free>
c000180e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:101
	free(addr2);
c0001811:	83 ec 0c             	sub    $0xc,%esp
c0001814:	ff 75 ec             	pushl  -0x14(%ebp)
c0001817:	e8 fc 3d 00 00       	call   c0005618 <free>
c000181c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:102
	free(addr3);
c000181f:	83 ec 0c             	sub    $0xc,%esp
c0001822:	ff 75 e8             	pushl  -0x18(%ebp)
c0001825:	e8 ee 3d 00 00       	call   c0005618 <free>
c000182a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:103 (discriminator 1)
	while(1);
c000182d:	eb fe                	jmp    c000182d <u_prog_a+0x97>

c000182f <u_prog_b>:
u_prog_b():
/work/x86_os_my/kernel/main.c:107
}

/* 测试用户进程 */
void u_prog_b(void) {
c000182f:	55                   	push   %ebp
c0001830:	89 e5                	mov    %esp,%ebp
c0001832:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:108
	void* addr1 = malloc(256);
c0001835:	83 ec 0c             	sub    $0xc,%esp
c0001838:	68 00 01 00 00       	push   $0x100
c000183d:	e8 b7 3d 00 00       	call   c00055f9 <malloc>
c0001842:	83 c4 10             	add    $0x10,%esp
c0001845:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/main.c:109
	void* addr2 = malloc(255);
c0001848:	83 ec 0c             	sub    $0xc,%esp
c000184b:	68 ff 00 00 00       	push   $0xff
c0001850:	e8 a4 3d 00 00       	call   c00055f9 <malloc>
c0001855:	83 c4 10             	add    $0x10,%esp
c0001858:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/main.c:110
	void* addr3 = malloc(254);
c000185b:	83 ec 0c             	sub    $0xc,%esp
c000185e:	68 fe 00 00 00       	push   $0xfe
c0001863:	e8 91 3d 00 00       	call   c00055f9 <malloc>
c0001868:	83 c4 10             	add    $0x10,%esp
c000186b:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/main.c:111
	printf(" prog_b malloc addr:0x%x,0x%x,0x%x\n", (int)addr1, (int)addr2, (int)addr3);
c000186e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0001871:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0001874:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001877:	51                   	push   %ecx
c0001878:	52                   	push   %edx
c0001879:	50                   	push   %eax
c000187a:	68 90 87 00 c0       	push   $0xc0008790
c000187f:	e8 64 40 00 00       	call   c00058e8 <printf>
c0001884:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:113

	int cpu_delay = 100000;
c0001887:	c7 45 f4 a0 86 01 00 	movl   $0x186a0,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:114
	while(cpu_delay-- > 0);
c000188e:	90                   	nop
/work/x86_os_my/kernel/main.c:114 (discriminator 1)
c000188f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001892:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001895:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001898:	85 c0                	test   %eax,%eax
c000189a:	7f f3                	jg     c000188f <u_prog_b+0x60>
/work/x86_os_my/kernel/main.c:115
	free(addr1);
c000189c:	83 ec 0c             	sub    $0xc,%esp
c000189f:	ff 75 f0             	pushl  -0x10(%ebp)
c00018a2:	e8 71 3d 00 00       	call   c0005618 <free>
c00018a7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:116
	free(addr2);
c00018aa:	83 ec 0c             	sub    $0xc,%esp
c00018ad:	ff 75 ec             	pushl  -0x14(%ebp)
c00018b0:	e8 63 3d 00 00       	call   c0005618 <free>
c00018b5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:117
	free(addr3);
c00018b8:	83 ec 0c             	sub    $0xc,%esp
c00018bb:	ff 75 e8             	pushl  -0x18(%ebp)
c00018be:	e8 55 3d 00 00       	call   c0005618 <free>
c00018c3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:118 (discriminator 1)
	while(1);
c00018c6:	eb fe                	jmp    c00018c6 <u_prog_b+0x97>

c00018c8 <init_all>:
init_all():
/work/x86_os_my/kernel/init.c:15
#include "syscall-init.h"
#include "ide.h"
#include "fs.h"

/*负责初始化所有模块 */
void init_all() {
c00018c8:	55                   	push   %ebp
c00018c9:	89 e5                	mov    %esp,%ebp
c00018cb:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/init.c:16
	put_str("init_all\n");
c00018ce:	83 ec 0c             	sub    $0xc,%esp
c00018d1:	68 b4 87 00 c0       	push   $0xc00087b4
c00018d6:	e8 e5 0b 00 00       	call   c00024c0 <put_str>
c00018db:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/init.c:17
	idt_init();			// 初始化中断
c00018de:	e8 38 04 00 00       	call   c0001d1b <idt_init>
/work/x86_os_my/kernel/init.c:18
	mem_init();			// 初始化内存管理系统
c00018e3:	e8 11 21 00 00       	call   c00039f9 <mem_init>
/work/x86_os_my/kernel/init.c:19
	thread_init();		// 初始化线程相关结构
c00018e8:	e8 a2 2b 00 00       	call   c000448f <thread_init>
/work/x86_os_my/kernel/init.c:20
	timer_init();		// 初始化PIT
c00018ed:	e8 16 06 00 00       	call   c0001f08 <timer_init>
/work/x86_os_my/kernel/init.c:21
	console_init();		// 控制台初始化最好放在开中断之前
c00018f2:	e8 1e 2e 00 00       	call   c0004715 <console_init>
/work/x86_os_my/kernel/init.c:22
	keyboard_init();	// 键盘初始化
c00018f7:	e8 97 34 00 00       	call   c0004d93 <keyboard_init>
/work/x86_os_my/kernel/init.c:23
	tss_init();			// tss初始化
c00018fc:	e8 4d 38 00 00       	call   c000514e <tss_init>
/work/x86_os_my/kernel/init.c:24
	syscall_init();		// 初始化系统调用
c0001901:	e8 65 3d 00 00       	call   c000566b <syscall_init>
/work/x86_os_my/kernel/init.c:25
	intr_enable();		// 后面的ide_init需要打开中断
c0001906:	e8 5f 03 00 00       	call   c0001c6a <intr_enable>
/work/x86_os_my/kernel/init.c:26
	ide_init();			// 初始化硬盘
c000190b:	e8 af 4b 00 00       	call   c00064bf <ide_init>
/work/x86_os_my/kernel/init.c:27
	filesys_init();		// 初始化文件系统
c0001910:	e8 dd 5a 00 00       	call   c00073f2 <filesys_init>
/work/x86_os_my/kernel/init.c:28
}
c0001915:	90                   	nop
c0001916:	c9                   	leave  
c0001917:	c3                   	ret    

c0001918 <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c0001918:	55                   	push   %ebp
c0001919:	89 e5                	mov    %esp,%ebp
c000191b:	83 ec 08             	sub    $0x8,%esp
c000191e:	8b 55 08             	mov    0x8(%ebp),%edx
c0001921:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001924:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0001928:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c000192b:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c000192f:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0001933:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c0001934:	90                   	nop
c0001935:	c9                   	leave  
c0001936:	c3                   	ret    

c0001937 <pic_init>:
pic_init():
/work/x86_os_my/kernel/interrupt.c:41
//自定义类型 intr_handler = void*
extern intr_handler intr_entry_table[IDT_DESC_CNT];	    // 声明引用汇编kernel.S中的中断处理函数入口数组

/* 初始化可编程中断控制器8259A */
// outb 来着 lib/kernel/io.h 内联汇编写法
static void pic_init(void) {
c0001937:	55                   	push   %ebp
c0001938:	89 e5                	mov    %esp,%ebp
c000193a:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:43
	/* 初始化主片 */
	outb (PIC_M_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c000193d:	6a 11                	push   $0x11
c000193f:	6a 20                	push   $0x20
c0001941:	e8 d2 ff ff ff       	call   c0001918 <outb>
c0001946:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:44
	outb (PIC_M_DATA, 0x20);	// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.
c0001949:	6a 20                	push   $0x20
c000194b:	6a 21                	push   $0x21
c000194d:	e8 c6 ff ff ff       	call   c0001918 <outb>
c0001952:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:45
	outb (PIC_M_DATA, 0x04);	// ICW3: IR2接从片. 
c0001955:	6a 04                	push   $0x4
c0001957:	6a 21                	push   $0x21
c0001959:	e8 ba ff ff ff       	call   c0001918 <outb>
c000195e:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:46
	outb (PIC_M_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c0001961:	6a 01                	push   $0x1
c0001963:	6a 21                	push   $0x21
c0001965:	e8 ae ff ff ff       	call   c0001918 <outb>
c000196a:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:49

	/* 初始化从片 */
	outb (PIC_S_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c000196d:	6a 11                	push   $0x11
c000196f:	68 a0 00 00 00       	push   $0xa0
c0001974:	e8 9f ff ff ff       	call   c0001918 <outb>
c0001979:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:50
	outb (PIC_S_DATA, 0x28);	// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.
c000197c:	6a 28                	push   $0x28
c000197e:	68 a1 00 00 00       	push   $0xa1
c0001983:	e8 90 ff ff ff       	call   c0001918 <outb>
c0001988:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:51
	outb (PIC_S_DATA, 0x02);	// ICW3: 设置从片连接到主片的IR2引脚
c000198b:	6a 02                	push   $0x2
c000198d:	68 a1 00 00 00       	push   $0xa1
c0001992:	e8 81 ff ff ff       	call   c0001918 <outb>
c0001997:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:52
	outb (PIC_S_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c000199a:	6a 01                	push   $0x1
c000199c:	68 a1 00 00 00       	push   $0xa1
c00019a1:	e8 72 ff ff ff       	call   c0001918 <outb>
c00019a6:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:56

	/* IRQ2用于级联从片,必须打开,否则无法响应从片上的中断
	主片上打开的中断有IRQ0的时钟,IRQ1的键盘和级联从片的IRQ2,其它全部关闭 */
	outb (PIC_M_DATA, 0xf8);
c00019a9:	68 f8 00 00 00       	push   $0xf8
c00019ae:	6a 21                	push   $0x21
c00019b0:	e8 63 ff ff ff       	call   c0001918 <outb>
c00019b5:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:58
	/* 打开从片上的IRQ14,此引脚接收硬盘控制器的中断 */
	outb (PIC_S_DATA, 0xbf);
c00019b8:	68 bf 00 00 00       	push   $0xbf
c00019bd:	68 a1 00 00 00       	push   $0xa1
c00019c2:	e8 51 ff ff ff       	call   c0001918 <outb>
c00019c7:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:60

	put_str("   pic_init done\n");
c00019ca:	83 ec 0c             	sub    $0xc,%esp
c00019cd:	68 c0 87 00 c0       	push   $0xc00087c0
c00019d2:	e8 e9 0a 00 00       	call   c00024c0 <put_str>
c00019d7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:61
}
c00019da:	90                   	nop
c00019db:	c9                   	leave  
c00019dc:	c3                   	ret    

c00019dd <make_idt_desc>:
make_idt_desc():
/work/x86_os_my/kernel/interrupt.c:64

/* 创建中断门描述符 */
static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function) { 
c00019dd:	55                   	push   %ebp
c00019de:	89 e5                	mov    %esp,%ebp
c00019e0:	83 ec 04             	sub    $0x4,%esp
c00019e3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00019e6:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:65
	p_gdesc->func_offset_low_word = (uint32_t)function & 0x0000FFFF;
c00019e9:	8b 45 10             	mov    0x10(%ebp),%eax
c00019ec:	89 c2                	mov    %eax,%edx
c00019ee:	8b 45 08             	mov    0x8(%ebp),%eax
c00019f1:	66 89 10             	mov    %dx,(%eax)
/work/x86_os_my/kernel/interrupt.c:66
	p_gdesc->selector = SELECTOR_K_CODE;
c00019f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00019f7:	66 c7 40 02 08 00    	movw   $0x8,0x2(%eax)
/work/x86_os_my/kernel/interrupt.c:67
	p_gdesc->dcount = 0;
c00019fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a00:	c6 40 04 00          	movb   $0x0,0x4(%eax)
/work/x86_os_my/kernel/interrupt.c:68
	p_gdesc->attribute = attr;
c0001a04:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a07:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0001a0b:	88 50 05             	mov    %dl,0x5(%eax)
/work/x86_os_my/kernel/interrupt.c:69
	p_gdesc->func_offset_high_word = ((uint32_t)function & 0xFFFF0000) >> 16;
c0001a0e:	8b 45 10             	mov    0x10(%ebp),%eax
c0001a11:	c1 e8 10             	shr    $0x10,%eax
c0001a14:	89 c2                	mov    %eax,%edx
c0001a16:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a19:	66 89 50 06          	mov    %dx,0x6(%eax)
/work/x86_os_my/kernel/interrupt.c:70
}
c0001a1d:	90                   	nop
c0001a1e:	c9                   	leave  
c0001a1f:	c3                   	ret    

c0001a20 <idt_desc_init>:
idt_desc_init():
/work/x86_os_my/kernel/interrupt.c:73

/*初始化中断描述符表*/
static void idt_desc_init(void) {
c0001a20:	55                   	push   %ebp
c0001a21:	89 e5                	mov    %esp,%ebp
c0001a23:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:75
	int i;
	int lastindex = IDT_DESC_CNT - 1;
c0001a26:	c7 45 f0 80 00 00 00 	movl   $0x80,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:76
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001a2d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0001a34:	eb 29                	jmp    c0001a5f <idt_desc_init+0x3f>
/work/x86_os_my/kernel/interrupt.c:77 (discriminator 3)
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
c0001a36:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001a39:	8b 04 85 00 c0 00 c0 	mov    -0x3fff4000(,%eax,4),%eax
c0001a40:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0001a43:	c1 e2 03             	shl    $0x3,%edx
c0001a46:	81 c2 60 c1 00 c0    	add    $0xc000c160,%edx
c0001a4c:	50                   	push   %eax
c0001a4d:	68 8e 00 00 00       	push   $0x8e
c0001a52:	52                   	push   %edx
c0001a53:	e8 85 ff ff ff       	call   c00019dd <make_idt_desc>
c0001a58:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/kernel/interrupt.c:76 (discriminator 3)

/*初始化中断描述符表*/
static void idt_desc_init(void) {
	int i;
	int lastindex = IDT_DESC_CNT - 1;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001a5b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:76 (discriminator 1)
c0001a5f:	81 7d f4 80 00 00 00 	cmpl   $0x80,-0xc(%ebp)
c0001a66:	7e ce                	jle    c0001a36 <idt_desc_init+0x16>
/work/x86_os_my/kernel/interrupt.c:81
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
	}
	/* 系统调用对应的中断门dpl为3！
	 * 中断处理程序为单独的syscall_handler */
	make_idt_desc(&idt[lastindex], IDT_DESC_ATTR_DPL3, syscall_handler);
c0001a68:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001a6b:	c1 e0 03             	shl    $0x3,%eax
c0001a6e:	05 60 c1 00 c0       	add    $0xc000c160,%eax
c0001a73:	68 97 24 00 c0       	push   $0xc0002497
c0001a78:	68 ee 00 00 00       	push   $0xee
c0001a7d:	50                   	push   %eax
c0001a7e:	e8 5a ff ff ff       	call   c00019dd <make_idt_desc>
c0001a83:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/kernel/interrupt.c:82
	put_str("   idt_desc_init done\n");
c0001a86:	83 ec 0c             	sub    $0xc,%esp
c0001a89:	68 d2 87 00 c0       	push   $0xc00087d2
c0001a8e:	e8 2d 0a 00 00       	call   c00024c0 <put_str>
c0001a93:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:83
}
c0001a96:	90                   	nop
c0001a97:	c9                   	leave  
c0001a98:	c3                   	ret    

c0001a99 <general_intr_handler>:
general_intr_handler():
/work/x86_os_my/kernel/interrupt.c:86

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
c0001a99:	55                   	push   %ebp
c0001a9a:	89 e5                	mov    %esp,%ebp
c0001a9c:	83 ec 28             	sub    $0x28,%esp
c0001a9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001aa2:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/kernel/interrupt.c:87
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
c0001aa5:	80 7d e4 27          	cmpb   $0x27,-0x1c(%ebp)
c0001aa9:	0f 84 bf 00 00 00    	je     c0001b6e <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:87 (discriminator 1)
c0001aaf:	80 7d e4 2f          	cmpb   $0x2f,-0x1c(%ebp)
c0001ab3:	0f 84 b5 00 00 00    	je     c0001b6e <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:92
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
c0001ab9:	83 ec 0c             	sub    $0xc,%esp
c0001abc:	6a 00                	push   $0x0
c0001abe:	e8 4b 0b 00 00       	call   c000260e <set_cursor>
c0001ac3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:93
	int cursor_pos = 0;
c0001ac6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:94
	while(cursor_pos < 320) {
c0001acd:	eb 11                	jmp    c0001ae0 <general_intr_handler+0x47>
/work/x86_os_my/kernel/interrupt.c:95
		put_char(' ');
c0001acf:	83 ec 0c             	sub    $0xc,%esp
c0001ad2:	6a 20                	push   $0x20
c0001ad4:	e8 05 0a 00 00       	call   c00024de <put_char>
c0001ad9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:96
		cursor_pos++;
c0001adc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:94
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
	int cursor_pos = 0;
	while(cursor_pos < 320) {
c0001ae0:	81 7d f4 3f 01 00 00 	cmpl   $0x13f,-0xc(%ebp)
c0001ae7:	7e e6                	jle    c0001acf <general_intr_handler+0x36>
/work/x86_os_my/kernel/interrupt.c:100
		put_char(' ');
		cursor_pos++;
	}

	/* 将光标置为左上角 打印信息 */
	set_cursor(0);
c0001ae9:	83 ec 0c             	sub    $0xc,%esp
c0001aec:	6a 00                	push   $0x0
c0001aee:	e8 1b 0b 00 00       	call   c000260e <set_cursor>
c0001af3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:101
	put_str("!!!!!!!      excetion message begin  !!!!!!!!\n");
c0001af6:	83 ec 0c             	sub    $0xc,%esp
c0001af9:	68 ec 87 00 c0       	push   $0xc00087ec
c0001afe:	e8 bd 09 00 00       	call   c00024c0 <put_str>
c0001b03:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:102
	set_cursor(88);			// 第2行第8个字符
c0001b06:	83 ec 0c             	sub    $0xc,%esp
c0001b09:	6a 58                	push   $0x58
c0001b0b:	e8 fe 0a 00 00       	call   c000260e <set_cursor>
c0001b10:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:103
	put_str(intr_name[vec_nr]);
c0001b13:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0001b17:	8b 04 85 20 c6 00 c0 	mov    -0x3fff39e0(,%eax,4),%eax
c0001b1e:	83 ec 0c             	sub    $0xc,%esp
c0001b21:	50                   	push   %eax
c0001b22:	e8 99 09 00 00       	call   c00024c0 <put_str>
c0001b27:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:104
	if (vec_nr == 14) {		// 若为Pagefault,将缺失的地址打印出来并悬停
c0001b2a:	80 7d e4 0e          	cmpb   $0xe,-0x1c(%ebp)
c0001b2e:	75 2c                	jne    c0001b5c <general_intr_handler+0xc3>
/work/x86_os_my/kernel/interrupt.c:105
		int page_fault_vaddr = 0; 
c0001b30:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:106
		asm ("movl %%cr2, %0" : "=r" (page_fault_vaddr));	  // cr2是存放造成page_fault的地址
c0001b37:	0f 20 d0             	mov    %cr2,%eax
c0001b3a:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:107
		put_str("\npage fault addr is ");
c0001b3d:	83 ec 0c             	sub    $0xc,%esp
c0001b40:	68 1b 88 00 c0       	push   $0xc000881b
c0001b45:	e8 76 09 00 00       	call   c00024c0 <put_str>
c0001b4a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:108
		put_int(page_fault_vaddr); 
c0001b4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001b50:	83 ec 0c             	sub    $0xc,%esp
c0001b53:	50                   	push   %eax
c0001b54:	e8 52 0a 00 00       	call   c00025ab <put_int>
c0001b59:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:110
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
c0001b5c:	83 ec 0c             	sub    $0xc,%esp
c0001b5f:	68 30 88 00 c0       	push   $0xc0008830
c0001b64:	e8 57 09 00 00       	call   c00024c0 <put_str>
c0001b69:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:113 (discriminator 1)
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
c0001b6c:	eb fe                	jmp    c0001b6c <general_intr_handler+0xd3>
/work/x86_os_my/kernel/interrupt.c:88
}

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
c0001b6e:	90                   	nop
/work/x86_os_my/kernel/interrupt.c:114
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
}
c0001b6f:	c9                   	leave  
c0001b70:	c3                   	ret    

c0001b71 <exception_init>:
exception_init():
/work/x86_os_my/kernel/interrupt.c:117

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
c0001b71:	55                   	push   %ebp
c0001b72:	89 e5                	mov    %esp,%ebp
c0001b74:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:119
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001b77:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0001b7e:	eb 20                	jmp    c0001ba0 <exception_init+0x2f>
/work/x86_os_my/kernel/interrupt.c:122 (discriminator 3)
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
c0001b80:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001b83:	c7 04 85 40 c8 00 c0 	movl   $0xc0001a99,-0x3fff37c0(,%eax,4)
c0001b8a:	99 1a 00 c0 
/work/x86_os_my/kernel/interrupt.c:123 (discriminator 3)
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
c0001b8e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001b91:	c7 04 85 20 c6 00 c0 	movl   $0xc0008860,-0x3fff39e0(,%eax,4)
c0001b98:	60 88 00 c0 
/work/x86_os_my/kernel/interrupt.c:119 (discriminator 3)
}

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001b9c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:119 (discriminator 1)
c0001ba0:	81 7d fc 80 00 00 00 	cmpl   $0x80,-0x4(%ebp)
c0001ba7:	7e d7                	jle    c0001b80 <exception_init+0xf>
/work/x86_os_my/kernel/interrupt.c:125
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
	}
	intr_name[0] = "#DE Divide Error";
c0001ba9:	c7 05 20 c6 00 c0 68 	movl   $0xc0008868,0xc000c620
c0001bb0:	88 00 c0 
/work/x86_os_my/kernel/interrupt.c:126
	intr_name[1] = "#DB Debug Exception";
c0001bb3:	c7 05 24 c6 00 c0 79 	movl   $0xc0008879,0xc000c624
c0001bba:	88 00 c0 
/work/x86_os_my/kernel/interrupt.c:127
	intr_name[2] = "NMI Interrupt";
c0001bbd:	c7 05 28 c6 00 c0 8d 	movl   $0xc000888d,0xc000c628
c0001bc4:	88 00 c0 
/work/x86_os_my/kernel/interrupt.c:128
	intr_name[3] = "#BP Breakpoint Exception";
c0001bc7:	c7 05 2c c6 00 c0 9b 	movl   $0xc000889b,0xc000c62c
c0001bce:	88 00 c0 
/work/x86_os_my/kernel/interrupt.c:129
	intr_name[4] = "#OF Overflow Exception";
c0001bd1:	c7 05 30 c6 00 c0 b4 	movl   $0xc00088b4,0xc000c630
c0001bd8:	88 00 c0 
/work/x86_os_my/kernel/interrupt.c:130
	intr_name[5] = "#BR BOUND Range Exceeded Exception";
c0001bdb:	c7 05 34 c6 00 c0 cc 	movl   $0xc00088cc,0xc000c634
c0001be2:	88 00 c0 
/work/x86_os_my/kernel/interrupt.c:131
	intr_name[6] = "#UD Invalid Opcode Exception";
c0001be5:	c7 05 38 c6 00 c0 ef 	movl   $0xc00088ef,0xc000c638
c0001bec:	88 00 c0 
/work/x86_os_my/kernel/interrupt.c:132
	intr_name[7] = "#NM Device Not Available Exception";
c0001bef:	c7 05 3c c6 00 c0 0c 	movl   $0xc000890c,0xc000c63c
c0001bf6:	89 00 c0 
/work/x86_os_my/kernel/interrupt.c:133
	intr_name[8] = "#DF Double Fault Exception";
c0001bf9:	c7 05 40 c6 00 c0 2f 	movl   $0xc000892f,0xc000c640
c0001c00:	89 00 c0 
/work/x86_os_my/kernel/interrupt.c:134
	intr_name[9] = "Coprocessor Segment Overrun";
c0001c03:	c7 05 44 c6 00 c0 4a 	movl   $0xc000894a,0xc000c644
c0001c0a:	89 00 c0 
/work/x86_os_my/kernel/interrupt.c:135
	intr_name[10] = "#TS Invalid TSS Exception";
c0001c0d:	c7 05 48 c6 00 c0 66 	movl   $0xc0008966,0xc000c648
c0001c14:	89 00 c0 
/work/x86_os_my/kernel/interrupt.c:136
	intr_name[11] = "#NP Segment Not Present";
c0001c17:	c7 05 4c c6 00 c0 80 	movl   $0xc0008980,0xc000c64c
c0001c1e:	89 00 c0 
/work/x86_os_my/kernel/interrupt.c:137
	intr_name[12] = "#SS Stack Fault Exception";
c0001c21:	c7 05 50 c6 00 c0 98 	movl   $0xc0008998,0xc000c650
c0001c28:	89 00 c0 
/work/x86_os_my/kernel/interrupt.c:138
	intr_name[13] = "#GP General Protection Exception";
c0001c2b:	c7 05 54 c6 00 c0 b4 	movl   $0xc00089b4,0xc000c654
c0001c32:	89 00 c0 
/work/x86_os_my/kernel/interrupt.c:139
	intr_name[14] = "#PF Page-Fault Exception";
c0001c35:	c7 05 58 c6 00 c0 d5 	movl   $0xc00089d5,0xc000c658
c0001c3c:	89 00 c0 
/work/x86_os_my/kernel/interrupt.c:141
	// intr_name[15] 第15项是intel保留项，未使用
	intr_name[16] = "#MF x87 FPU Floating-Point Error";
c0001c3f:	c7 05 60 c6 00 c0 f0 	movl   $0xc00089f0,0xc000c660
c0001c46:	89 00 c0 
/work/x86_os_my/kernel/interrupt.c:142
	intr_name[17] = "#AC Alignment Check Exception";
c0001c49:	c7 05 64 c6 00 c0 11 	movl   $0xc0008a11,0xc000c664
c0001c50:	8a 00 c0 
/work/x86_os_my/kernel/interrupt.c:143
	intr_name[18] = "#MC Machine-Check Exception";
c0001c53:	c7 05 68 c6 00 c0 2f 	movl   $0xc0008a2f,0xc000c668
c0001c5a:	8a 00 c0 
/work/x86_os_my/kernel/interrupt.c:144
	intr_name[19] = "#XF SIMD Floating-Point Exception";
c0001c5d:	c7 05 6c c6 00 c0 4c 	movl   $0xc0008a4c,0xc000c66c
c0001c64:	8a 00 c0 
/work/x86_os_my/kernel/interrupt.c:145
}
c0001c67:	90                   	nop
c0001c68:	c9                   	leave  
c0001c69:	c3                   	ret    

c0001c6a <intr_enable>:
intr_enable():
/work/x86_os_my/kernel/interrupt.c:148

/* 开中断并返回开中断前的状态*/
enum intr_status intr_enable() {
c0001c6a:	55                   	push   %ebp
c0001c6b:	89 e5                	mov    %esp,%ebp
c0001c6d:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:150
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c0001c70:	e8 65 00 00 00       	call   c0001cda <intr_get_status>
c0001c75:	83 f8 01             	cmp    $0x1,%eax
c0001c78:	75 0c                	jne    c0001c86 <intr_enable+0x1c>
/work/x86_os_my/kernel/interrupt.c:151
		old_status = INTR_ON;
c0001c7a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:152
		return old_status;
c0001c81:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001c84:	eb 0b                	jmp    c0001c91 <intr_enable+0x27>
/work/x86_os_my/kernel/interrupt.c:154
	} else {
		old_status = INTR_OFF;
c0001c86:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:155
		asm volatile("sti");	 // 开中断,sti指令将IF位置1
c0001c8d:	fb                   	sti    
/work/x86_os_my/kernel/interrupt.c:156
		return old_status;
c0001c8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:158
	}
}
c0001c91:	c9                   	leave  
c0001c92:	c3                   	ret    

c0001c93 <intr_disable>:
intr_disable():
/work/x86_os_my/kernel/interrupt.c:161

/* 关中断,并且返回关中断前的状态 */
enum intr_status intr_disable() {     
c0001c93:	55                   	push   %ebp
c0001c94:	89 e5                	mov    %esp,%ebp
c0001c96:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:163
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c0001c99:	e8 3c 00 00 00       	call   c0001cda <intr_get_status>
c0001c9e:	83 f8 01             	cmp    $0x1,%eax
c0001ca1:	75 0d                	jne    c0001cb0 <intr_disable+0x1d>
/work/x86_os_my/kernel/interrupt.c:164
		old_status = INTR_ON;
c0001ca3:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:165
		asm volatile("cli" : : : "memory"); // 关中断,cli指令将IF位置0
c0001caa:	fa                   	cli    
/work/x86_os_my/kernel/interrupt.c:166
		return old_status;
c0001cab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001cae:	eb 0a                	jmp    c0001cba <intr_disable+0x27>
/work/x86_os_my/kernel/interrupt.c:168
	} else {
		old_status = INTR_OFF;
c0001cb0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:169
		return old_status;
c0001cb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:171
	}
}
c0001cba:	c9                   	leave  
c0001cbb:	c3                   	ret    

c0001cbc <intr_set_status>:
intr_set_status():
/work/x86_os_my/kernel/interrupt.c:174

/* 将中断状态设置为status */
enum intr_status intr_set_status(enum intr_status status) {
c0001cbc:	55                   	push   %ebp
c0001cbd:	89 e5                	mov    %esp,%ebp
c0001cbf:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:175
	return status & INTR_ON ? intr_enable() : intr_disable();
c0001cc2:	8b 45 08             	mov    0x8(%ebp),%eax
c0001cc5:	83 e0 01             	and    $0x1,%eax
c0001cc8:	85 c0                	test   %eax,%eax
c0001cca:	74 07                	je     c0001cd3 <intr_set_status+0x17>
/work/x86_os_my/kernel/interrupt.c:175 (discriminator 1)
c0001ccc:	e8 99 ff ff ff       	call   c0001c6a <intr_enable>
c0001cd1:	eb 05                	jmp    c0001cd8 <intr_set_status+0x1c>
/work/x86_os_my/kernel/interrupt.c:175 (discriminator 2)
c0001cd3:	e8 bb ff ff ff       	call   c0001c93 <intr_disable>
/work/x86_os_my/kernel/interrupt.c:176 (discriminator 5)
}
c0001cd8:	c9                   	leave  
c0001cd9:	c3                   	ret    

c0001cda <intr_get_status>:
intr_get_status():
/work/x86_os_my/kernel/interrupt.c:179

/* 获取当前中断状态 */
enum intr_status intr_get_status() {
c0001cda:	55                   	push   %ebp
c0001cdb:	89 e5                	mov    %esp,%ebp
c0001cdd:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:180
	uint32_t eflags = 0; 
c0001ce0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:181
	GET_EFLAGS(eflags);
c0001ce7:	9c                   	pushf  
c0001ce8:	58                   	pop    %eax
c0001ce9:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:182
	return (EFLAGS_IF & eflags) ? INTR_ON : INTR_OFF;
c0001cec:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001cef:	25 00 02 00 00       	and    $0x200,%eax
c0001cf4:	85 c0                	test   %eax,%eax
c0001cf6:	0f 95 c0             	setne  %al
c0001cf9:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/kernel/interrupt.c:183
}
c0001cfc:	c9                   	leave  
c0001cfd:	c3                   	ret    

c0001cfe <register_handler>:
register_handler():
/work/x86_os_my/kernel/interrupt.c:186

/* 在中断处理程序数组第vector_no个元素中注册安装中断处理程序function */
void register_handler(uint8_t vector_no, intr_handler function) {
c0001cfe:	55                   	push   %ebp
c0001cff:	89 e5                	mov    %esp,%ebp
c0001d01:	83 ec 04             	sub    $0x4,%esp
c0001d04:	8b 45 08             	mov    0x8(%ebp),%eax
c0001d07:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:189
/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
 * 见kernel/kernel.S的call [idt_table + %1*4] */
   idt_table[vector_no] = function; 
c0001d0a:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0001d0e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0001d11:	89 14 85 40 c8 00 c0 	mov    %edx,-0x3fff37c0(,%eax,4)
/work/x86_os_my/kernel/interrupt.c:190
}
c0001d18:	90                   	nop
c0001d19:	c9                   	leave  
c0001d1a:	c3                   	ret    

c0001d1b <idt_init>:
idt_init():
/work/x86_os_my/kernel/interrupt.c:193

/*完成有关中断的所有初始化工作*/
void idt_init() {
c0001d1b:	55                   	push   %ebp
c0001d1c:	89 e5                	mov    %esp,%ebp
c0001d1e:	56                   	push   %esi
c0001d1f:	53                   	push   %ebx
c0001d20:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:194
	put_str("idt_init start\n");
c0001d23:	83 ec 0c             	sub    $0xc,%esp
c0001d26:	68 6e 8a 00 c0       	push   $0xc0008a6e
c0001d2b:	e8 90 07 00 00       	call   c00024c0 <put_str>
c0001d30:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:195
	idt_desc_init();	// 初始化中断描述符表
c0001d33:	e8 e8 fc ff ff       	call   c0001a20 <idt_desc_init>
/work/x86_os_my/kernel/interrupt.c:196
	exception_init();	// 异常名初始化并注册通常的中断处理函数
c0001d38:	e8 34 fe ff ff       	call   c0001b71 <exception_init>
/work/x86_os_my/kernel/interrupt.c:197
	pic_init();			// 初始化8259A
c0001d3d:	e8 f5 fb ff ff       	call   c0001937 <pic_init>
/work/x86_os_my/kernel/interrupt.c:201

	/* 加载idt */
	// IDTR 是 48 位的寄存器，低 16 位是 IDT 的界限 = IDT 尺寸大小-1，高 32 位是 IDT 的线性基地址
	uint64_t idt_operand = ((sizeof(idt) - 1) | ((uint64_t)(uint32_t)idt << 16));
c0001d42:	b8 60 c1 00 c0       	mov    $0xc000c160,%eax
c0001d47:	ba 00 00 00 00       	mov    $0x0,%edx
c0001d4c:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0001d50:	c1 e0 10             	shl    $0x10,%eax
c0001d53:	89 c1                	mov    %eax,%ecx
c0001d55:	81 c9 07 04 00 00    	or     $0x407,%ecx
c0001d5b:	89 cb                	mov    %ecx,%ebx
c0001d5d:	89 d0                	mov    %edx,%eax
c0001d5f:	80 cc 00             	or     $0x0,%ah
c0001d62:	89 c6                	mov    %eax,%esi
c0001d64:	89 5d f0             	mov    %ebx,-0x10(%ebp)
c0001d67:	89 75 f4             	mov    %esi,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:202
	asm volatile("lidt %0" : : "m" (idt_operand));
c0001d6a:	0f 01 5d f0          	lidtl  -0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:203
	put_str("idt_init done\n");
c0001d6e:	83 ec 0c             	sub    $0xc,%esp
c0001d71:	68 7e 8a 00 c0       	push   $0xc0008a7e
c0001d76:	e8 45 07 00 00       	call   c00024c0 <put_str>
c0001d7b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:204
}
c0001d7e:	90                   	nop
c0001d7f:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001d82:	5b                   	pop    %ebx
c0001d83:	5e                   	pop    %esi
c0001d84:	5d                   	pop    %ebp
c0001d85:	c3                   	ret    

c0001d86 <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c0001d86:	55                   	push   %ebp
c0001d87:	89 e5                	mov    %esp,%ebp
c0001d89:	83 ec 08             	sub    $0x8,%esp
c0001d8c:	8b 55 08             	mov    0x8(%ebp),%edx
c0001d8f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001d92:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0001d96:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c0001d99:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0001d9d:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0001da1:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c0001da2:	90                   	nop
c0001da3:	c9                   	leave  
c0001da4:	c3                   	ret    

c0001da5 <frequency_set>:
frequency_set():
/work/x86_os_my/device/timer.c:27
/* 把操作的计数器counter_no、读写锁属性rwl、计数器模式counter_mode写入模式控制寄存器并赋予初始值counter_value */
static void frequency_set(uint8_t counter_port, \
		uint8_t counter_no, \
		uint8_t rwl, \
		uint8_t counter_mode, \
		uint16_t counter_value) {
c0001da5:	55                   	push   %ebp
c0001da6:	89 e5                	mov    %esp,%ebp
c0001da8:	56                   	push   %esi
c0001da9:	53                   	push   %ebx
c0001daa:	83 ec 14             	sub    $0x14,%esp
c0001dad:	8b 45 08             	mov    0x8(%ebp),%eax
c0001db0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c0001db3:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001db6:	8b 55 14             	mov    0x14(%ebp),%edx
c0001db9:	8b 75 18             	mov    0x18(%ebp),%esi
c0001dbc:	88 45 f4             	mov    %al,-0xc(%ebp)
c0001dbf:	88 5d f0             	mov    %bl,-0x10(%ebp)
c0001dc2:	88 4d ec             	mov    %cl,-0x14(%ebp)
c0001dc5:	88 55 e8             	mov    %dl,-0x18(%ebp)
c0001dc8:	66 89 75 e4          	mov    %si,-0x1c(%ebp)
/work/x86_os_my/device/timer.c:29
	/* 往控制字寄存器端口0x43中写入控制字 */
	outb(PIT_CONTROL_PORT, (uint8_t)(counter_no << 6 | rwl << 4 | counter_mode << 1));
c0001dcc:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0001dd0:	c1 e0 06             	shl    $0x6,%eax
c0001dd3:	89 c2                	mov    %eax,%edx
c0001dd5:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0001dd9:	c1 e0 04             	shl    $0x4,%eax
c0001ddc:	09 c2                	or     %eax,%edx
c0001dde:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0001de2:	01 c0                	add    %eax,%eax
c0001de4:	09 d0                	or     %edx,%eax
c0001de6:	0f b6 c0             	movzbl %al,%eax
c0001de9:	50                   	push   %eax
c0001dea:	6a 43                	push   $0x43
c0001dec:	e8 95 ff ff ff       	call   c0001d86 <outb>
c0001df1:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:31
	/* 先写入counter_value的低8位 */
	outb(counter_port, (uint8_t)counter_value);
c0001df4:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0001df8:	0f b6 d0             	movzbl %al,%edx
c0001dfb:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001dff:	52                   	push   %edx
c0001e00:	50                   	push   %eax
c0001e01:	e8 80 ff ff ff       	call   c0001d86 <outb>
c0001e06:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:33
	/* 再写入counter_value的高8位 */
	outb(counter_port, (uint8_t)counter_value >> 8);
c0001e09:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001e0d:	6a 00                	push   $0x0
c0001e0f:	50                   	push   %eax
c0001e10:	e8 71 ff ff ff       	call   c0001d86 <outb>
c0001e15:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:34
}
c0001e18:	90                   	nop
c0001e19:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001e1c:	5b                   	pop    %ebx
c0001e1d:	5e                   	pop    %esi
c0001e1e:	5d                   	pop    %ebp
c0001e1f:	c3                   	ret    

c0001e20 <intr_timer_handler>:
intr_timer_handler():
/work/x86_os_my/device/timer.c:37

/* 时钟的中断处理函数 */
static void intr_timer_handler(void) {
c0001e20:	55                   	push   %ebp
c0001e21:	89 e5                	mov    %esp,%ebp
c0001e23:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/timer.c:38
	struct task_struct* cur_thread = running_thread();		// 返回线程PCB
c0001e26:	e8 06 20 00 00       	call   c0003e31 <running_thread>
c0001e2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/timer.c:40

	ASSERT(cur_thread->stack_magic == 0x19870916);			// 检查栈是否溢出
c0001e2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001e31:	8b 80 0c 01 00 00    	mov    0x10c(%eax),%eax
c0001e37:	3d 16 09 87 19       	cmp    $0x19870916,%eax
c0001e3c:	74 19                	je     c0001e57 <intr_timer_handler+0x37>
/work/x86_os_my/device/timer.c:40 (discriminator 1)
c0001e3e:	68 90 8a 00 c0       	push   $0xc0008a90
c0001e43:	68 f8 8a 00 c0       	push   $0xc0008af8
c0001e48:	6a 28                	push   $0x28
c0001e4a:	68 b6 8a 00 c0       	push   $0xc0008ab6
c0001e4f:	e8 de 07 00 00       	call   c0002632 <panic_spin>
c0001e54:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:42

	cur_thread->elapsed_ticks++;// 记录此线程占用的cpu时间
c0001e57:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001e5a:	8b 40 20             	mov    0x20(%eax),%eax
c0001e5d:	8d 50 01             	lea    0x1(%eax),%edx
c0001e60:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001e63:	89 50 20             	mov    %edx,0x20(%eax)
/work/x86_os_my/device/timer.c:43
	ticks++;	//从内核第一次处理时间中断开始,至今的滴哒数,是内核态和用户态总共的嘀哒数
c0001e66:	a1 44 ca 00 c0       	mov    0xc000ca44,%eax
c0001e6b:	83 c0 01             	add    $0x1,%eax
c0001e6e:	a3 44 ca 00 c0       	mov    %eax,0xc000ca44
/work/x86_os_my/device/timer.c:45

	if (cur_thread->ticks == 0) {
c0001e73:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001e76:	0f b6 40 1d          	movzbl 0x1d(%eax),%eax
c0001e7a:	84 c0                	test   %al,%al
c0001e7c:	75 07                	jne    c0001e85 <intr_timer_handler+0x65>
/work/x86_os_my/device/timer.c:46
		schedule();				// 若进程时间片用完就开始调度新的进程上cpu
c0001e7e:	e8 de 22 00 00       	call   c0004161 <schedule>
/work/x86_os_my/device/timer.c:50
	} else {
		cur_thread->ticks--;	// 将当前进程的时间片-1
	}
}
c0001e83:	eb 10                	jmp    c0001e95 <intr_timer_handler+0x75>
/work/x86_os_my/device/timer.c:48
	ticks++;	//从内核第一次处理时间中断开始,至今的滴哒数,是内核态和用户态总共的嘀哒数

	if (cur_thread->ticks == 0) {
		schedule();				// 若进程时间片用完就开始调度新的进程上cpu
	} else {
		cur_thread->ticks--;	// 将当前进程的时间片-1
c0001e85:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001e88:	0f b6 40 1d          	movzbl 0x1d(%eax),%eax
c0001e8c:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001e8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001e92:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/device/timer.c:50
	}
}
c0001e95:	90                   	nop
c0001e96:	c9                   	leave  
c0001e97:	c3                   	ret    

c0001e98 <ticks_to_sleep>:
ticks_to_sleep():
/work/x86_os_my/device/timer.c:53

/* 以tick为单位的sleep,任何时间形式的sleep会转换此ticks形式 */
static void ticks_to_sleep(uint32_t sleep_ticks) {
c0001e98:	55                   	push   %ebp
c0001e99:	89 e5                	mov    %esp,%ebp
c0001e9b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/timer.c:54
	uint32_t start_tick = ticks;
c0001e9e:	a1 44 ca 00 c0       	mov    0xc000ca44,%eax
c0001ea3:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/timer.c:57

	/* 若间隔的ticks数不够便让出cpu */
	while (ticks - start_tick < sleep_ticks) {
c0001ea6:	eb 05                	jmp    c0001ead <ticks_to_sleep+0x15>
/work/x86_os_my/device/timer.c:58
		thread_yield();
c0001ea8:	e8 5e 25 00 00       	call   c000440b <thread_yield>
/work/x86_os_my/device/timer.c:57
/* 以tick为单位的sleep,任何时间形式的sleep会转换此ticks形式 */
static void ticks_to_sleep(uint32_t sleep_ticks) {
	uint32_t start_tick = ticks;

	/* 若间隔的ticks数不够便让出cpu */
	while (ticks - start_tick < sleep_ticks) {
c0001ead:	a1 44 ca 00 c0       	mov    0xc000ca44,%eax
c0001eb2:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0001eb5:	3b 45 08             	cmp    0x8(%ebp),%eax
c0001eb8:	72 ee                	jb     c0001ea8 <ticks_to_sleep+0x10>
/work/x86_os_my/device/timer.c:60
		thread_yield();
	}
}
c0001eba:	90                   	nop
c0001ebb:	c9                   	leave  
c0001ebc:	c3                   	ret    

c0001ebd <mtime_sleep>:
mtime_sleep():
/work/x86_os_my/device/timer.c:62

void mtime_sleep(uint32_t m_seconds) {
c0001ebd:	55                   	push   %ebp
c0001ebe:	89 e5                	mov    %esp,%ebp
c0001ec0:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/timer.c:63
	uint32_t sleep_ticks = DIV_ROUND_UP(m_seconds, mil_seconds_per_intr);
c0001ec3:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ec6:	83 c0 09             	add    $0x9,%eax
c0001ec9:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
c0001ece:	f7 e2                	mul    %edx
c0001ed0:	89 d0                	mov    %edx,%eax
c0001ed2:	c1 e8 03             	shr    $0x3,%eax
c0001ed5:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/timer.c:64
	ASSERT(sleep_ticks > 0);
c0001ed8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0001edc:	75 19                	jne    c0001ef7 <mtime_sleep+0x3a>
/work/x86_os_my/device/timer.c:64 (discriminator 1)
c0001ede:	68 c5 8a 00 c0       	push   $0xc0008ac5
c0001ee3:	68 0c 8b 00 c0       	push   $0xc0008b0c
c0001ee8:	6a 40                	push   $0x40
c0001eea:	68 b6 8a 00 c0       	push   $0xc0008ab6
c0001eef:	e8 3e 07 00 00       	call   c0002632 <panic_spin>
c0001ef4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:65
	ticks_to_sleep(sleep_ticks); 
c0001ef7:	83 ec 0c             	sub    $0xc,%esp
c0001efa:	ff 75 f4             	pushl  -0xc(%ebp)
c0001efd:	e8 96 ff ff ff       	call   c0001e98 <ticks_to_sleep>
c0001f02:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:66
}
c0001f05:	90                   	nop
c0001f06:	c9                   	leave  
c0001f07:	c3                   	ret    

c0001f08 <timer_init>:
timer_init():
/work/x86_os_my/device/timer.c:69

/* 初始化PIT8253 */
void timer_init() {
c0001f08:	55                   	push   %ebp
c0001f09:	89 e5                	mov    %esp,%ebp
c0001f0b:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/timer.c:70
	put_str("timer_init start\n");
c0001f0e:	83 ec 0c             	sub    $0xc,%esp
c0001f11:	68 d5 8a 00 c0       	push   $0xc0008ad5
c0001f16:	e8 a5 05 00 00       	call   c00024c0 <put_str>
c0001f1b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:72
	/* 设置8253的定时周期,也就是发中断的周期 */
	frequency_set(CONTRER0_PORT, COUNTER0_NO, READ_WRITE_LATCH, COUNTER_MODE, COUNTER0_VALUE);
c0001f1e:	83 ec 0c             	sub    $0xc,%esp
c0001f21:	68 9b 2e 00 00       	push   $0x2e9b
c0001f26:	6a 02                	push   $0x2
c0001f28:	6a 03                	push   $0x3
c0001f2a:	6a 00                	push   $0x0
c0001f2c:	6a 40                	push   $0x40
c0001f2e:	e8 72 fe ff ff       	call   c0001da5 <frequency_set>
c0001f33:	83 c4 20             	add    $0x20,%esp
/work/x86_os_my/device/timer.c:73
	register_handler(0x20, intr_timer_handler);
c0001f36:	83 ec 08             	sub    $0x8,%esp
c0001f39:	68 20 1e 00 c0       	push   $0xc0001e20
c0001f3e:	6a 20                	push   $0x20
c0001f40:	e8 b9 fd ff ff       	call   c0001cfe <register_handler>
c0001f45:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:74
	put_str("timer_init done\n");
c0001f48:	83 ec 0c             	sub    $0xc,%esp
c0001f4b:	68 e7 8a 00 c0       	push   $0xc0008ae7
c0001f50:	e8 6b 05 00 00       	call   c00024c0 <put_str>
c0001f55:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:75
}
c0001f58:	90                   	nop
c0001f59:	c9                   	leave  
c0001f5a:	c3                   	ret    
c0001f5b:	66 90                	xchg   %ax,%ax
c0001f5d:	66 90                	xchg   %ax,%ax
c0001f5f:	90                   	nop

c0001f60 <intr_exit>:
intr_exit():
c0001f60:	83 c4 04             	add    $0x4,%esp
c0001f63:	61                   	popa   
c0001f64:	0f a9                	pop    %gs
c0001f66:	0f a1                	pop    %fs
c0001f68:	07                   	pop    %es
c0001f69:	1f                   	pop    %ds
c0001f6a:	83 c4 04             	add    $0x4,%esp
c0001f6d:	cf                   	iret   

c0001f6e <intr0x00entry>:
intr0x00entry():
c0001f6e:	6a 00                	push   $0x0
c0001f70:	1e                   	push   %ds
c0001f71:	06                   	push   %es
c0001f72:	0f a0                	push   %fs
c0001f74:	0f a8                	push   %gs
c0001f76:	60                   	pusha  
c0001f77:	b0 20                	mov    $0x20,%al
c0001f79:	e6 a0                	out    %al,$0xa0
c0001f7b:	e6 20                	out    %al,$0x20
c0001f7d:	6a 00                	push   $0x0
c0001f7f:	ff 15 40 c8 00 c0    	call   *0xc000c840
c0001f85:	eb d9                	jmp    c0001f60 <intr_exit>

c0001f87 <intr0x01entry>:
intr0x01entry():
c0001f87:	6a 00                	push   $0x0
c0001f89:	1e                   	push   %ds
c0001f8a:	06                   	push   %es
c0001f8b:	0f a0                	push   %fs
c0001f8d:	0f a8                	push   %gs
c0001f8f:	60                   	pusha  
c0001f90:	b0 20                	mov    $0x20,%al
c0001f92:	e6 a0                	out    %al,$0xa0
c0001f94:	e6 20                	out    %al,$0x20
c0001f96:	6a 01                	push   $0x1
c0001f98:	ff 15 44 c8 00 c0    	call   *0xc000c844
c0001f9e:	eb c0                	jmp    c0001f60 <intr_exit>

c0001fa0 <intr0x02entry>:
intr0x02entry():
c0001fa0:	6a 00                	push   $0x0
c0001fa2:	1e                   	push   %ds
c0001fa3:	06                   	push   %es
c0001fa4:	0f a0                	push   %fs
c0001fa6:	0f a8                	push   %gs
c0001fa8:	60                   	pusha  
c0001fa9:	b0 20                	mov    $0x20,%al
c0001fab:	e6 a0                	out    %al,$0xa0
c0001fad:	e6 20                	out    %al,$0x20
c0001faf:	6a 02                	push   $0x2
c0001fb1:	ff 15 48 c8 00 c0    	call   *0xc000c848
c0001fb7:	eb a7                	jmp    c0001f60 <intr_exit>

c0001fb9 <intr0x03entry>:
intr0x03entry():
c0001fb9:	6a 00                	push   $0x0
c0001fbb:	1e                   	push   %ds
c0001fbc:	06                   	push   %es
c0001fbd:	0f a0                	push   %fs
c0001fbf:	0f a8                	push   %gs
c0001fc1:	60                   	pusha  
c0001fc2:	b0 20                	mov    $0x20,%al
c0001fc4:	e6 a0                	out    %al,$0xa0
c0001fc6:	e6 20                	out    %al,$0x20
c0001fc8:	6a 03                	push   $0x3
c0001fca:	ff 15 4c c8 00 c0    	call   *0xc000c84c
c0001fd0:	eb 8e                	jmp    c0001f60 <intr_exit>

c0001fd2 <intr0x04entry>:
intr0x04entry():
c0001fd2:	6a 00                	push   $0x0
c0001fd4:	1e                   	push   %ds
c0001fd5:	06                   	push   %es
c0001fd6:	0f a0                	push   %fs
c0001fd8:	0f a8                	push   %gs
c0001fda:	60                   	pusha  
c0001fdb:	b0 20                	mov    $0x20,%al
c0001fdd:	e6 a0                	out    %al,$0xa0
c0001fdf:	e6 20                	out    %al,$0x20
c0001fe1:	6a 04                	push   $0x4
c0001fe3:	ff 15 50 c8 00 c0    	call   *0xc000c850
c0001fe9:	e9 72 ff ff ff       	jmp    c0001f60 <intr_exit>

c0001fee <intr0x05entry>:
intr0x05entry():
c0001fee:	6a 00                	push   $0x0
c0001ff0:	1e                   	push   %ds
c0001ff1:	06                   	push   %es
c0001ff2:	0f a0                	push   %fs
c0001ff4:	0f a8                	push   %gs
c0001ff6:	60                   	pusha  
c0001ff7:	b0 20                	mov    $0x20,%al
c0001ff9:	e6 a0                	out    %al,$0xa0
c0001ffb:	e6 20                	out    %al,$0x20
c0001ffd:	6a 05                	push   $0x5
c0001fff:	ff 15 54 c8 00 c0    	call   *0xc000c854
c0002005:	e9 56 ff ff ff       	jmp    c0001f60 <intr_exit>

c000200a <intr0x06entry>:
intr0x06entry():
c000200a:	6a 00                	push   $0x0
c000200c:	1e                   	push   %ds
c000200d:	06                   	push   %es
c000200e:	0f a0                	push   %fs
c0002010:	0f a8                	push   %gs
c0002012:	60                   	pusha  
c0002013:	b0 20                	mov    $0x20,%al
c0002015:	e6 a0                	out    %al,$0xa0
c0002017:	e6 20                	out    %al,$0x20
c0002019:	6a 06                	push   $0x6
c000201b:	ff 15 58 c8 00 c0    	call   *0xc000c858
c0002021:	e9 3a ff ff ff       	jmp    c0001f60 <intr_exit>

c0002026 <intr0x07entry>:
intr0x07entry():
c0002026:	6a 00                	push   $0x0
c0002028:	1e                   	push   %ds
c0002029:	06                   	push   %es
c000202a:	0f a0                	push   %fs
c000202c:	0f a8                	push   %gs
c000202e:	60                   	pusha  
c000202f:	b0 20                	mov    $0x20,%al
c0002031:	e6 a0                	out    %al,$0xa0
c0002033:	e6 20                	out    %al,$0x20
c0002035:	6a 07                	push   $0x7
c0002037:	ff 15 5c c8 00 c0    	call   *0xc000c85c
c000203d:	e9 1e ff ff ff       	jmp    c0001f60 <intr_exit>

c0002042 <intr0x08entry>:
intr0x08entry():
c0002042:	90                   	nop
c0002043:	1e                   	push   %ds
c0002044:	06                   	push   %es
c0002045:	0f a0                	push   %fs
c0002047:	0f a8                	push   %gs
c0002049:	60                   	pusha  
c000204a:	b0 20                	mov    $0x20,%al
c000204c:	e6 a0                	out    %al,$0xa0
c000204e:	e6 20                	out    %al,$0x20
c0002050:	6a 08                	push   $0x8
c0002052:	ff 15 60 c8 00 c0    	call   *0xc000c860
c0002058:	e9 03 ff ff ff       	jmp    c0001f60 <intr_exit>

c000205d <intr0x09entry>:
intr0x09entry():
c000205d:	6a 00                	push   $0x0
c000205f:	1e                   	push   %ds
c0002060:	06                   	push   %es
c0002061:	0f a0                	push   %fs
c0002063:	0f a8                	push   %gs
c0002065:	60                   	pusha  
c0002066:	b0 20                	mov    $0x20,%al
c0002068:	e6 a0                	out    %al,$0xa0
c000206a:	e6 20                	out    %al,$0x20
c000206c:	6a 09                	push   $0x9
c000206e:	ff 15 64 c8 00 c0    	call   *0xc000c864
c0002074:	e9 e7 fe ff ff       	jmp    c0001f60 <intr_exit>

c0002079 <intr0x0aentry>:
intr0x0aentry():
c0002079:	90                   	nop
c000207a:	1e                   	push   %ds
c000207b:	06                   	push   %es
c000207c:	0f a0                	push   %fs
c000207e:	0f a8                	push   %gs
c0002080:	60                   	pusha  
c0002081:	b0 20                	mov    $0x20,%al
c0002083:	e6 a0                	out    %al,$0xa0
c0002085:	e6 20                	out    %al,$0x20
c0002087:	6a 0a                	push   $0xa
c0002089:	ff 15 68 c8 00 c0    	call   *0xc000c868
c000208f:	e9 cc fe ff ff       	jmp    c0001f60 <intr_exit>

c0002094 <intr0x0bentry>:
intr0x0bentry():
c0002094:	90                   	nop
c0002095:	1e                   	push   %ds
c0002096:	06                   	push   %es
c0002097:	0f a0                	push   %fs
c0002099:	0f a8                	push   %gs
c000209b:	60                   	pusha  
c000209c:	b0 20                	mov    $0x20,%al
c000209e:	e6 a0                	out    %al,$0xa0
c00020a0:	e6 20                	out    %al,$0x20
c00020a2:	6a 0b                	push   $0xb
c00020a4:	ff 15 6c c8 00 c0    	call   *0xc000c86c
c00020aa:	e9 b1 fe ff ff       	jmp    c0001f60 <intr_exit>

c00020af <intr0x0centry>:
intr0x0centry():
c00020af:	6a 00                	push   $0x0
c00020b1:	1e                   	push   %ds
c00020b2:	06                   	push   %es
c00020b3:	0f a0                	push   %fs
c00020b5:	0f a8                	push   %gs
c00020b7:	60                   	pusha  
c00020b8:	b0 20                	mov    $0x20,%al
c00020ba:	e6 a0                	out    %al,$0xa0
c00020bc:	e6 20                	out    %al,$0x20
c00020be:	6a 0c                	push   $0xc
c00020c0:	ff 15 70 c8 00 c0    	call   *0xc000c870
c00020c6:	e9 95 fe ff ff       	jmp    c0001f60 <intr_exit>

c00020cb <intr0x0dentry>:
intr0x0dentry():
c00020cb:	90                   	nop
c00020cc:	1e                   	push   %ds
c00020cd:	06                   	push   %es
c00020ce:	0f a0                	push   %fs
c00020d0:	0f a8                	push   %gs
c00020d2:	60                   	pusha  
c00020d3:	b0 20                	mov    $0x20,%al
c00020d5:	e6 a0                	out    %al,$0xa0
c00020d7:	e6 20                	out    %al,$0x20
c00020d9:	6a 0d                	push   $0xd
c00020db:	ff 15 74 c8 00 c0    	call   *0xc000c874
c00020e1:	e9 7a fe ff ff       	jmp    c0001f60 <intr_exit>

c00020e6 <intr0x0eentry>:
intr0x0eentry():
c00020e6:	90                   	nop
c00020e7:	1e                   	push   %ds
c00020e8:	06                   	push   %es
c00020e9:	0f a0                	push   %fs
c00020eb:	0f a8                	push   %gs
c00020ed:	60                   	pusha  
c00020ee:	b0 20                	mov    $0x20,%al
c00020f0:	e6 a0                	out    %al,$0xa0
c00020f2:	e6 20                	out    %al,$0x20
c00020f4:	6a 0e                	push   $0xe
c00020f6:	ff 15 78 c8 00 c0    	call   *0xc000c878
c00020fc:	e9 5f fe ff ff       	jmp    c0001f60 <intr_exit>

c0002101 <intr0x0fentry>:
intr0x0fentry():
c0002101:	6a 00                	push   $0x0
c0002103:	1e                   	push   %ds
c0002104:	06                   	push   %es
c0002105:	0f a0                	push   %fs
c0002107:	0f a8                	push   %gs
c0002109:	60                   	pusha  
c000210a:	b0 20                	mov    $0x20,%al
c000210c:	e6 a0                	out    %al,$0xa0
c000210e:	e6 20                	out    %al,$0x20
c0002110:	6a 0f                	push   $0xf
c0002112:	ff 15 7c c8 00 c0    	call   *0xc000c87c
c0002118:	e9 43 fe ff ff       	jmp    c0001f60 <intr_exit>

c000211d <intr0x10entry>:
intr0x10entry():
c000211d:	6a 00                	push   $0x0
c000211f:	1e                   	push   %ds
c0002120:	06                   	push   %es
c0002121:	0f a0                	push   %fs
c0002123:	0f a8                	push   %gs
c0002125:	60                   	pusha  
c0002126:	b0 20                	mov    $0x20,%al
c0002128:	e6 a0                	out    %al,$0xa0
c000212a:	e6 20                	out    %al,$0x20
c000212c:	6a 10                	push   $0x10
c000212e:	ff 15 80 c8 00 c0    	call   *0xc000c880
c0002134:	e9 27 fe ff ff       	jmp    c0001f60 <intr_exit>

c0002139 <intr0x11entry>:
intr0x11entry():
c0002139:	90                   	nop
c000213a:	1e                   	push   %ds
c000213b:	06                   	push   %es
c000213c:	0f a0                	push   %fs
c000213e:	0f a8                	push   %gs
c0002140:	60                   	pusha  
c0002141:	b0 20                	mov    $0x20,%al
c0002143:	e6 a0                	out    %al,$0xa0
c0002145:	e6 20                	out    %al,$0x20
c0002147:	6a 11                	push   $0x11
c0002149:	ff 15 84 c8 00 c0    	call   *0xc000c884
c000214f:	e9 0c fe ff ff       	jmp    c0001f60 <intr_exit>

c0002154 <intr0x12entry>:
intr0x12entry():
c0002154:	6a 00                	push   $0x0
c0002156:	1e                   	push   %ds
c0002157:	06                   	push   %es
c0002158:	0f a0                	push   %fs
c000215a:	0f a8                	push   %gs
c000215c:	60                   	pusha  
c000215d:	b0 20                	mov    $0x20,%al
c000215f:	e6 a0                	out    %al,$0xa0
c0002161:	e6 20                	out    %al,$0x20
c0002163:	6a 12                	push   $0x12
c0002165:	ff 15 88 c8 00 c0    	call   *0xc000c888
c000216b:	e9 f0 fd ff ff       	jmp    c0001f60 <intr_exit>

c0002170 <intr0x13entry>:
intr0x13entry():
c0002170:	6a 00                	push   $0x0
c0002172:	1e                   	push   %ds
c0002173:	06                   	push   %es
c0002174:	0f a0                	push   %fs
c0002176:	0f a8                	push   %gs
c0002178:	60                   	pusha  
c0002179:	b0 20                	mov    $0x20,%al
c000217b:	e6 a0                	out    %al,$0xa0
c000217d:	e6 20                	out    %al,$0x20
c000217f:	6a 13                	push   $0x13
c0002181:	ff 15 8c c8 00 c0    	call   *0xc000c88c
c0002187:	e9 d4 fd ff ff       	jmp    c0001f60 <intr_exit>

c000218c <intr0x14entry>:
intr0x14entry():
c000218c:	6a 00                	push   $0x0
c000218e:	1e                   	push   %ds
c000218f:	06                   	push   %es
c0002190:	0f a0                	push   %fs
c0002192:	0f a8                	push   %gs
c0002194:	60                   	pusha  
c0002195:	b0 20                	mov    $0x20,%al
c0002197:	e6 a0                	out    %al,$0xa0
c0002199:	e6 20                	out    %al,$0x20
c000219b:	6a 14                	push   $0x14
c000219d:	ff 15 90 c8 00 c0    	call   *0xc000c890
c00021a3:	e9 b8 fd ff ff       	jmp    c0001f60 <intr_exit>

c00021a8 <intr0x15entry>:
intr0x15entry():
c00021a8:	6a 00                	push   $0x0
c00021aa:	1e                   	push   %ds
c00021ab:	06                   	push   %es
c00021ac:	0f a0                	push   %fs
c00021ae:	0f a8                	push   %gs
c00021b0:	60                   	pusha  
c00021b1:	b0 20                	mov    $0x20,%al
c00021b3:	e6 a0                	out    %al,$0xa0
c00021b5:	e6 20                	out    %al,$0x20
c00021b7:	6a 15                	push   $0x15
c00021b9:	ff 15 94 c8 00 c0    	call   *0xc000c894
c00021bf:	e9 9c fd ff ff       	jmp    c0001f60 <intr_exit>

c00021c4 <intr0x16entry>:
intr0x16entry():
c00021c4:	6a 00                	push   $0x0
c00021c6:	1e                   	push   %ds
c00021c7:	06                   	push   %es
c00021c8:	0f a0                	push   %fs
c00021ca:	0f a8                	push   %gs
c00021cc:	60                   	pusha  
c00021cd:	b0 20                	mov    $0x20,%al
c00021cf:	e6 a0                	out    %al,$0xa0
c00021d1:	e6 20                	out    %al,$0x20
c00021d3:	6a 16                	push   $0x16
c00021d5:	ff 15 98 c8 00 c0    	call   *0xc000c898
c00021db:	e9 80 fd ff ff       	jmp    c0001f60 <intr_exit>

c00021e0 <intr0x17entry>:
intr0x17entry():
c00021e0:	6a 00                	push   $0x0
c00021e2:	1e                   	push   %ds
c00021e3:	06                   	push   %es
c00021e4:	0f a0                	push   %fs
c00021e6:	0f a8                	push   %gs
c00021e8:	60                   	pusha  
c00021e9:	b0 20                	mov    $0x20,%al
c00021eb:	e6 a0                	out    %al,$0xa0
c00021ed:	e6 20                	out    %al,$0x20
c00021ef:	6a 17                	push   $0x17
c00021f1:	ff 15 9c c8 00 c0    	call   *0xc000c89c
c00021f7:	e9 64 fd ff ff       	jmp    c0001f60 <intr_exit>

c00021fc <intr0x18entry>:
intr0x18entry():
c00021fc:	90                   	nop
c00021fd:	1e                   	push   %ds
c00021fe:	06                   	push   %es
c00021ff:	0f a0                	push   %fs
c0002201:	0f a8                	push   %gs
c0002203:	60                   	pusha  
c0002204:	b0 20                	mov    $0x20,%al
c0002206:	e6 a0                	out    %al,$0xa0
c0002208:	e6 20                	out    %al,$0x20
c000220a:	6a 18                	push   $0x18
c000220c:	ff 15 a0 c8 00 c0    	call   *0xc000c8a0
c0002212:	e9 49 fd ff ff       	jmp    c0001f60 <intr_exit>

c0002217 <intr0x19entry>:
intr0x19entry():
c0002217:	6a 00                	push   $0x0
c0002219:	1e                   	push   %ds
c000221a:	06                   	push   %es
c000221b:	0f a0                	push   %fs
c000221d:	0f a8                	push   %gs
c000221f:	60                   	pusha  
c0002220:	b0 20                	mov    $0x20,%al
c0002222:	e6 a0                	out    %al,$0xa0
c0002224:	e6 20                	out    %al,$0x20
c0002226:	6a 19                	push   $0x19
c0002228:	ff 15 a4 c8 00 c0    	call   *0xc000c8a4
c000222e:	e9 2d fd ff ff       	jmp    c0001f60 <intr_exit>

c0002233 <intr0x1aentry>:
intr0x1aentry():
c0002233:	90                   	nop
c0002234:	1e                   	push   %ds
c0002235:	06                   	push   %es
c0002236:	0f a0                	push   %fs
c0002238:	0f a8                	push   %gs
c000223a:	60                   	pusha  
c000223b:	b0 20                	mov    $0x20,%al
c000223d:	e6 a0                	out    %al,$0xa0
c000223f:	e6 20                	out    %al,$0x20
c0002241:	6a 1a                	push   $0x1a
c0002243:	ff 15 a8 c8 00 c0    	call   *0xc000c8a8
c0002249:	e9 12 fd ff ff       	jmp    c0001f60 <intr_exit>

c000224e <intr0x1bentry>:
intr0x1bentry():
c000224e:	90                   	nop
c000224f:	1e                   	push   %ds
c0002250:	06                   	push   %es
c0002251:	0f a0                	push   %fs
c0002253:	0f a8                	push   %gs
c0002255:	60                   	pusha  
c0002256:	b0 20                	mov    $0x20,%al
c0002258:	e6 a0                	out    %al,$0xa0
c000225a:	e6 20                	out    %al,$0x20
c000225c:	6a 1b                	push   $0x1b
c000225e:	ff 15 ac c8 00 c0    	call   *0xc000c8ac
c0002264:	e9 f7 fc ff ff       	jmp    c0001f60 <intr_exit>

c0002269 <intr0x1centry>:
intr0x1centry():
c0002269:	6a 00                	push   $0x0
c000226b:	1e                   	push   %ds
c000226c:	06                   	push   %es
c000226d:	0f a0                	push   %fs
c000226f:	0f a8                	push   %gs
c0002271:	60                   	pusha  
c0002272:	b0 20                	mov    $0x20,%al
c0002274:	e6 a0                	out    %al,$0xa0
c0002276:	e6 20                	out    %al,$0x20
c0002278:	6a 1c                	push   $0x1c
c000227a:	ff 15 b0 c8 00 c0    	call   *0xc000c8b0
c0002280:	e9 db fc ff ff       	jmp    c0001f60 <intr_exit>

c0002285 <intr0x1dentry>:
intr0x1dentry():
c0002285:	90                   	nop
c0002286:	1e                   	push   %ds
c0002287:	06                   	push   %es
c0002288:	0f a0                	push   %fs
c000228a:	0f a8                	push   %gs
c000228c:	60                   	pusha  
c000228d:	b0 20                	mov    $0x20,%al
c000228f:	e6 a0                	out    %al,$0xa0
c0002291:	e6 20                	out    %al,$0x20
c0002293:	6a 1d                	push   $0x1d
c0002295:	ff 15 b4 c8 00 c0    	call   *0xc000c8b4
c000229b:	e9 c0 fc ff ff       	jmp    c0001f60 <intr_exit>

c00022a0 <intr0x1eentry>:
intr0x1eentry():
c00022a0:	90                   	nop
c00022a1:	1e                   	push   %ds
c00022a2:	06                   	push   %es
c00022a3:	0f a0                	push   %fs
c00022a5:	0f a8                	push   %gs
c00022a7:	60                   	pusha  
c00022a8:	b0 20                	mov    $0x20,%al
c00022aa:	e6 a0                	out    %al,$0xa0
c00022ac:	e6 20                	out    %al,$0x20
c00022ae:	6a 1e                	push   $0x1e
c00022b0:	ff 15 b8 c8 00 c0    	call   *0xc000c8b8
c00022b6:	e9 a5 fc ff ff       	jmp    c0001f60 <intr_exit>

c00022bb <intr0x1fentry>:
intr0x1fentry():
c00022bb:	6a 00                	push   $0x0
c00022bd:	1e                   	push   %ds
c00022be:	06                   	push   %es
c00022bf:	0f a0                	push   %fs
c00022c1:	0f a8                	push   %gs
c00022c3:	60                   	pusha  
c00022c4:	b0 20                	mov    $0x20,%al
c00022c6:	e6 a0                	out    %al,$0xa0
c00022c8:	e6 20                	out    %al,$0x20
c00022ca:	6a 1f                	push   $0x1f
c00022cc:	ff 15 bc c8 00 c0    	call   *0xc000c8bc
c00022d2:	e9 89 fc ff ff       	jmp    c0001f60 <intr_exit>

c00022d7 <intr0x20entry>:
intr0x20entry():
c00022d7:	6a 00                	push   $0x0
c00022d9:	1e                   	push   %ds
c00022da:	06                   	push   %es
c00022db:	0f a0                	push   %fs
c00022dd:	0f a8                	push   %gs
c00022df:	60                   	pusha  
c00022e0:	b0 20                	mov    $0x20,%al
c00022e2:	e6 a0                	out    %al,$0xa0
c00022e4:	e6 20                	out    %al,$0x20
c00022e6:	6a 20                	push   $0x20
c00022e8:	ff 15 c0 c8 00 c0    	call   *0xc000c8c0
c00022ee:	e9 6d fc ff ff       	jmp    c0001f60 <intr_exit>

c00022f3 <intr0x21entry>:
intr0x21entry():
c00022f3:	6a 00                	push   $0x0
c00022f5:	1e                   	push   %ds
c00022f6:	06                   	push   %es
c00022f7:	0f a0                	push   %fs
c00022f9:	0f a8                	push   %gs
c00022fb:	60                   	pusha  
c00022fc:	b0 20                	mov    $0x20,%al
c00022fe:	e6 a0                	out    %al,$0xa0
c0002300:	e6 20                	out    %al,$0x20
c0002302:	6a 21                	push   $0x21
c0002304:	ff 15 c4 c8 00 c0    	call   *0xc000c8c4
c000230a:	e9 51 fc ff ff       	jmp    c0001f60 <intr_exit>

c000230f <intr0x22entry>:
intr0x22entry():
c000230f:	6a 00                	push   $0x0
c0002311:	1e                   	push   %ds
c0002312:	06                   	push   %es
c0002313:	0f a0                	push   %fs
c0002315:	0f a8                	push   %gs
c0002317:	60                   	pusha  
c0002318:	b0 20                	mov    $0x20,%al
c000231a:	e6 a0                	out    %al,$0xa0
c000231c:	e6 20                	out    %al,$0x20
c000231e:	6a 22                	push   $0x22
c0002320:	ff 15 c8 c8 00 c0    	call   *0xc000c8c8
c0002326:	e9 35 fc ff ff       	jmp    c0001f60 <intr_exit>

c000232b <intr0x23entry>:
intr0x23entry():
c000232b:	6a 00                	push   $0x0
c000232d:	1e                   	push   %ds
c000232e:	06                   	push   %es
c000232f:	0f a0                	push   %fs
c0002331:	0f a8                	push   %gs
c0002333:	60                   	pusha  
c0002334:	b0 20                	mov    $0x20,%al
c0002336:	e6 a0                	out    %al,$0xa0
c0002338:	e6 20                	out    %al,$0x20
c000233a:	6a 23                	push   $0x23
c000233c:	ff 15 cc c8 00 c0    	call   *0xc000c8cc
c0002342:	e9 19 fc ff ff       	jmp    c0001f60 <intr_exit>

c0002347 <intr0x24entry>:
intr0x24entry():
c0002347:	6a 00                	push   $0x0
c0002349:	1e                   	push   %ds
c000234a:	06                   	push   %es
c000234b:	0f a0                	push   %fs
c000234d:	0f a8                	push   %gs
c000234f:	60                   	pusha  
c0002350:	b0 20                	mov    $0x20,%al
c0002352:	e6 a0                	out    %al,$0xa0
c0002354:	e6 20                	out    %al,$0x20
c0002356:	6a 24                	push   $0x24
c0002358:	ff 15 d0 c8 00 c0    	call   *0xc000c8d0
c000235e:	e9 fd fb ff ff       	jmp    c0001f60 <intr_exit>

c0002363 <intr0x25entry>:
intr0x25entry():
c0002363:	6a 00                	push   $0x0
c0002365:	1e                   	push   %ds
c0002366:	06                   	push   %es
c0002367:	0f a0                	push   %fs
c0002369:	0f a8                	push   %gs
c000236b:	60                   	pusha  
c000236c:	b0 20                	mov    $0x20,%al
c000236e:	e6 a0                	out    %al,$0xa0
c0002370:	e6 20                	out    %al,$0x20
c0002372:	6a 25                	push   $0x25
c0002374:	ff 15 d4 c8 00 c0    	call   *0xc000c8d4
c000237a:	e9 e1 fb ff ff       	jmp    c0001f60 <intr_exit>

c000237f <intr0x26entry>:
intr0x26entry():
c000237f:	6a 00                	push   $0x0
c0002381:	1e                   	push   %ds
c0002382:	06                   	push   %es
c0002383:	0f a0                	push   %fs
c0002385:	0f a8                	push   %gs
c0002387:	60                   	pusha  
c0002388:	b0 20                	mov    $0x20,%al
c000238a:	e6 a0                	out    %al,$0xa0
c000238c:	e6 20                	out    %al,$0x20
c000238e:	6a 26                	push   $0x26
c0002390:	ff 15 d8 c8 00 c0    	call   *0xc000c8d8
c0002396:	e9 c5 fb ff ff       	jmp    c0001f60 <intr_exit>

c000239b <intr0x27entry>:
intr0x27entry():
c000239b:	6a 00                	push   $0x0
c000239d:	1e                   	push   %ds
c000239e:	06                   	push   %es
c000239f:	0f a0                	push   %fs
c00023a1:	0f a8                	push   %gs
c00023a3:	60                   	pusha  
c00023a4:	b0 20                	mov    $0x20,%al
c00023a6:	e6 a0                	out    %al,$0xa0
c00023a8:	e6 20                	out    %al,$0x20
c00023aa:	6a 27                	push   $0x27
c00023ac:	ff 15 dc c8 00 c0    	call   *0xc000c8dc
c00023b2:	e9 a9 fb ff ff       	jmp    c0001f60 <intr_exit>

c00023b7 <intr0x28entry>:
intr0x28entry():
c00023b7:	6a 00                	push   $0x0
c00023b9:	1e                   	push   %ds
c00023ba:	06                   	push   %es
c00023bb:	0f a0                	push   %fs
c00023bd:	0f a8                	push   %gs
c00023bf:	60                   	pusha  
c00023c0:	b0 20                	mov    $0x20,%al
c00023c2:	e6 a0                	out    %al,$0xa0
c00023c4:	e6 20                	out    %al,$0x20
c00023c6:	6a 28                	push   $0x28
c00023c8:	ff 15 e0 c8 00 c0    	call   *0xc000c8e0
c00023ce:	e9 8d fb ff ff       	jmp    c0001f60 <intr_exit>

c00023d3 <intr0x29entry>:
intr0x29entry():
c00023d3:	6a 00                	push   $0x0
c00023d5:	1e                   	push   %ds
c00023d6:	06                   	push   %es
c00023d7:	0f a0                	push   %fs
c00023d9:	0f a8                	push   %gs
c00023db:	60                   	pusha  
c00023dc:	b0 20                	mov    $0x20,%al
c00023de:	e6 a0                	out    %al,$0xa0
c00023e0:	e6 20                	out    %al,$0x20
c00023e2:	6a 29                	push   $0x29
c00023e4:	ff 15 e4 c8 00 c0    	call   *0xc000c8e4
c00023ea:	e9 71 fb ff ff       	jmp    c0001f60 <intr_exit>

c00023ef <intr0x2aentry>:
intr0x2aentry():
c00023ef:	6a 00                	push   $0x0
c00023f1:	1e                   	push   %ds
c00023f2:	06                   	push   %es
c00023f3:	0f a0                	push   %fs
c00023f5:	0f a8                	push   %gs
c00023f7:	60                   	pusha  
c00023f8:	b0 20                	mov    $0x20,%al
c00023fa:	e6 a0                	out    %al,$0xa0
c00023fc:	e6 20                	out    %al,$0x20
c00023fe:	6a 2a                	push   $0x2a
c0002400:	ff 15 e8 c8 00 c0    	call   *0xc000c8e8
c0002406:	e9 55 fb ff ff       	jmp    c0001f60 <intr_exit>

c000240b <intr0x2bentry>:
intr0x2bentry():
c000240b:	6a 00                	push   $0x0
c000240d:	1e                   	push   %ds
c000240e:	06                   	push   %es
c000240f:	0f a0                	push   %fs
c0002411:	0f a8                	push   %gs
c0002413:	60                   	pusha  
c0002414:	b0 20                	mov    $0x20,%al
c0002416:	e6 a0                	out    %al,$0xa0
c0002418:	e6 20                	out    %al,$0x20
c000241a:	6a 2b                	push   $0x2b
c000241c:	ff 15 ec c8 00 c0    	call   *0xc000c8ec
c0002422:	e9 39 fb ff ff       	jmp    c0001f60 <intr_exit>

c0002427 <intr0x2centry>:
intr0x2centry():
c0002427:	6a 00                	push   $0x0
c0002429:	1e                   	push   %ds
c000242a:	06                   	push   %es
c000242b:	0f a0                	push   %fs
c000242d:	0f a8                	push   %gs
c000242f:	60                   	pusha  
c0002430:	b0 20                	mov    $0x20,%al
c0002432:	e6 a0                	out    %al,$0xa0
c0002434:	e6 20                	out    %al,$0x20
c0002436:	6a 2c                	push   $0x2c
c0002438:	ff 15 f0 c8 00 c0    	call   *0xc000c8f0
c000243e:	e9 1d fb ff ff       	jmp    c0001f60 <intr_exit>

c0002443 <intr0x2dentry>:
intr0x2dentry():
c0002443:	6a 00                	push   $0x0
c0002445:	1e                   	push   %ds
c0002446:	06                   	push   %es
c0002447:	0f a0                	push   %fs
c0002449:	0f a8                	push   %gs
c000244b:	60                   	pusha  
c000244c:	b0 20                	mov    $0x20,%al
c000244e:	e6 a0                	out    %al,$0xa0
c0002450:	e6 20                	out    %al,$0x20
c0002452:	6a 2d                	push   $0x2d
c0002454:	ff 15 f4 c8 00 c0    	call   *0xc000c8f4
c000245a:	e9 01 fb ff ff       	jmp    c0001f60 <intr_exit>

c000245f <intr0x2eentry>:
intr0x2eentry():
c000245f:	6a 00                	push   $0x0
c0002461:	1e                   	push   %ds
c0002462:	06                   	push   %es
c0002463:	0f a0                	push   %fs
c0002465:	0f a8                	push   %gs
c0002467:	60                   	pusha  
c0002468:	b0 20                	mov    $0x20,%al
c000246a:	e6 a0                	out    %al,$0xa0
c000246c:	e6 20                	out    %al,$0x20
c000246e:	6a 2e                	push   $0x2e
c0002470:	ff 15 f8 c8 00 c0    	call   *0xc000c8f8
c0002476:	e9 e5 fa ff ff       	jmp    c0001f60 <intr_exit>

c000247b <intr0x2fentry>:
intr0x2fentry():
c000247b:	6a 00                	push   $0x0
c000247d:	1e                   	push   %ds
c000247e:	06                   	push   %es
c000247f:	0f a0                	push   %fs
c0002481:	0f a8                	push   %gs
c0002483:	60                   	pusha  
c0002484:	b0 20                	mov    $0x20,%al
c0002486:	e6 a0                	out    %al,$0xa0
c0002488:	e6 20                	out    %al,$0x20
c000248a:	6a 2f                	push   $0x2f
c000248c:	ff 15 fc c8 00 c0    	call   *0xc000c8fc
c0002492:	e9 c9 fa ff ff       	jmp    c0001f60 <intr_exit>

c0002497 <syscall_handler>:
syscall_handler():
c0002497:	6a 00                	push   $0x0
c0002499:	1e                   	push   %ds
c000249a:	06                   	push   %es
c000249b:	0f a0                	push   %fs
c000249d:	0f a8                	push   %gs
c000249f:	60                   	pusha  
c00024a0:	68 80 00 00 00       	push   $0x80
c00024a5:	52                   	push   %edx
c00024a6:	51                   	push   %ecx
c00024a7:	53                   	push   %ebx
c00024a8:	ff 14 85 60 cc 00 c0 	call   *-0x3fff33a0(,%eax,4)
c00024af:	83 c4 0c             	add    $0xc,%esp
c00024b2:	89 44 24 20          	mov    %eax,0x20(%esp)
c00024b6:	e9 a5 fa ff ff       	jmp    c0001f60 <intr_exit>
c00024bb:	66 90                	xchg   %ax,%ax
c00024bd:	66 90                	xchg   %ax,%ax
c00024bf:	90                   	nop

c00024c0 <put_str>:
put_str():
c00024c0:	53                   	push   %ebx
c00024c1:	51                   	push   %ecx
c00024c2:	31 c9                	xor    %ecx,%ecx
c00024c4:	8b 5c 24 0c          	mov    0xc(%esp),%ebx

c00024c8 <put_str.goon>:
put_str.goon():
c00024c8:	8a 0b                	mov    (%ebx),%cl
c00024ca:	80 f9 00             	cmp    $0x0,%cl
c00024cd:	74 0c                	je     c00024db <put_str.str_over>
c00024cf:	51                   	push   %ecx
c00024d0:	e8 09 00 00 00       	call   c00024de <put_char>
c00024d5:	83 c4 04             	add    $0x4,%esp
c00024d8:	43                   	inc    %ebx
c00024d9:	eb ed                	jmp    c00024c8 <put_str.goon>

c00024db <put_str.str_over>:
put_str.str_over():
c00024db:	59                   	pop    %ecx
c00024dc:	5b                   	pop    %ebx
c00024dd:	c3                   	ret    

c00024de <put_char>:
put_char():
c00024de:	60                   	pusha  
c00024df:	66 b8 18 00          	mov    $0x18,%ax
c00024e3:	8e e8                	mov    %eax,%gs
c00024e5:	66 ba d4 03          	mov    $0x3d4,%dx
c00024e9:	b0 0e                	mov    $0xe,%al
c00024eb:	ee                   	out    %al,(%dx)
c00024ec:	66 ba d5 03          	mov    $0x3d5,%dx
c00024f0:	ec                   	in     (%dx),%al
c00024f1:	88 c4                	mov    %al,%ah
c00024f3:	66 ba d4 03          	mov    $0x3d4,%dx
c00024f7:	b0 0f                	mov    $0xf,%al
c00024f9:	ee                   	out    %al,(%dx)
c00024fa:	66 ba d5 03          	mov    $0x3d5,%dx
c00024fe:	ec                   	in     (%dx),%al
c00024ff:	66 89 c3             	mov    %ax,%bx
c0002502:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0002506:	80 f9 0d             	cmp    $0xd,%cl
c0002509:	74 3c                	je     c0002547 <put_char.is_carriage_return>
c000250b:	80 f9 0a             	cmp    $0xa,%cl
c000250e:	74 37                	je     c0002547 <put_char.is_carriage_return>
c0002510:	80 f9 08             	cmp    $0x8,%cl
c0002513:	74 02                	je     c0002517 <put_char.is_backspace>
c0002515:	eb 16                	jmp    c000252d <put_char.put_other>

c0002517 <put_char.is_backspace>:
put_char.is_backspace():
c0002517:	66 4b                	dec    %bx
c0002519:	66 d1 e3             	shl    %bx
c000251c:	65 67 c6 07 20       	movb   $0x20,%gs:(%bx)
c0002521:	66 43                	inc    %bx
c0002523:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c0002528:	66 d1 eb             	shr    %bx
c000252b:	eb 60                	jmp    c000258d <put_char.set_cursor>

c000252d <put_char.put_other>:
put_char.put_other():
c000252d:	66 d1 e3             	shl    %bx
c0002530:	65 67 88 0f          	mov    %cl,%gs:(%bx)
c0002534:	66 43                	inc    %bx
c0002536:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c000253b:	66 d1 eb             	shr    %bx
c000253e:	66 43                	inc    %bx
c0002540:	66 81 fb d0 07       	cmp    $0x7d0,%bx
c0002545:	7c 46                	jl     c000258d <put_char.set_cursor>

c0002547 <put_char.is_carriage_return>:
put_char.is_line_feed():
c0002547:	66 31 d2             	xor    %dx,%dx
c000254a:	66 89 d8             	mov    %bx,%ax
c000254d:	66 be 50 00          	mov    $0x50,%si
c0002551:	66 f7 f6             	div    %si
c0002554:	66 29 d3             	sub    %dx,%bx

c0002557 <put_char.is_carriage_return_end>:
put_char.is_carriage_return_end():
c0002557:	66 83 c3 50          	add    $0x50,%bx
c000255b:	66 81 fb d0 07       	cmp    $0x7d0,%bx

c0002560 <put_char.is_line_feed_end>:
put_char.is_line_feed_end():
c0002560:	7c 2b                	jl     c000258d <put_char.set_cursor>

c0002562 <put_char.roll_screen>:
put_char.roll_screen():
c0002562:	fc                   	cld    
c0002563:	b9 c0 03 00 00       	mov    $0x3c0,%ecx
c0002568:	be a0 80 0b c0       	mov    $0xc00b80a0,%esi
c000256d:	bf 00 80 0b c0       	mov    $0xc00b8000,%edi
c0002572:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
c0002574:	bb 00 0f 00 00       	mov    $0xf00,%ebx
c0002579:	b9 50 00 00 00       	mov    $0x50,%ecx

c000257e <put_char.cls>:
put_char.cls():
c000257e:	65 66 c7 03 20 07    	movw   $0x720,%gs:(%ebx)
c0002584:	83 c3 02             	add    $0x2,%ebx
c0002587:	e2 f5                	loop   c000257e <put_char.cls>
c0002589:	66 bb 80 07          	mov    $0x780,%bx

c000258d <put_char.set_cursor>:
put_char.set_cursor():
c000258d:	66 ba d4 03          	mov    $0x3d4,%dx
c0002591:	b0 0e                	mov    $0xe,%al
c0002593:	ee                   	out    %al,(%dx)
c0002594:	66 ba d5 03          	mov    $0x3d5,%dx
c0002598:	88 f8                	mov    %bh,%al
c000259a:	ee                   	out    %al,(%dx)
c000259b:	66 ba d4 03          	mov    $0x3d4,%dx
c000259f:	b0 0f                	mov    $0xf,%al
c00025a1:	ee                   	out    %al,(%dx)
c00025a2:	66 ba d5 03          	mov    $0x3d5,%dx
c00025a6:	88 d8                	mov    %bl,%al
c00025a8:	ee                   	out    %al,(%dx)

c00025a9 <put_char.put_char_done>:
put_char.put_char_done():
c00025a9:	61                   	popa   
c00025aa:	c3                   	ret    

c00025ab <put_int>:
put_int():
c00025ab:	60                   	pusha  
c00025ac:	89 e5                	mov    %esp,%ebp
c00025ae:	8b 45 24             	mov    0x24(%ebp),%eax
c00025b1:	89 c2                	mov    %eax,%edx
c00025b3:	bf 07 00 00 00       	mov    $0x7,%edi
c00025b8:	b9 08 00 00 00       	mov    $0x8,%ecx
c00025bd:	bb c0 c0 00 c0       	mov    $0xc000c0c0,%ebx

c00025c2 <put_int.16based_4bits>:
put_int.16based_4bits():
c00025c2:	83 e2 0f             	and    $0xf,%edx
c00025c5:	83 fa 09             	cmp    $0x9,%edx
c00025c8:	7f 05                	jg     c00025cf <put_int.is_A2F>
c00025ca:	83 c2 30             	add    $0x30,%edx
c00025cd:	eb 06                	jmp    c00025d5 <put_int.store>

c00025cf <put_int.is_A2F>:
put_int.is_A2F():
c00025cf:	83 ea 0a             	sub    $0xa,%edx
c00025d2:	83 c2 41             	add    $0x41,%edx

c00025d5 <put_int.store>:
put_int.store():
c00025d5:	88 14 3b             	mov    %dl,(%ebx,%edi,1)
c00025d8:	4f                   	dec    %edi
c00025d9:	c1 e8 04             	shr    $0x4,%eax
c00025dc:	89 c2                	mov    %eax,%edx
c00025de:	e2 e2                	loop   c00025c2 <put_int.16based_4bits>

c00025e0 <put_int.ready_to_print>:
put_int.ready_to_print():
c00025e0:	47                   	inc    %edi

c00025e1 <put_int.skip_prefix_0>:
put_int.skip_prefix_0():
c00025e1:	83 ff 08             	cmp    $0x8,%edi
c00025e4:	74 0f                	je     c00025f5 <put_int.full0>

c00025e6 <put_int.go_on_skip>:
put_int.go_on_skip():
c00025e6:	8a 8f c0 c0 00 c0    	mov    -0x3fff3f40(%edi),%cl
c00025ec:	47                   	inc    %edi
c00025ed:	80 f9 30             	cmp    $0x30,%cl
c00025f0:	74 ef                	je     c00025e1 <put_int.skip_prefix_0>
c00025f2:	4f                   	dec    %edi
c00025f3:	eb 02                	jmp    c00025f7 <put_int.put_each_num>

c00025f5 <put_int.full0>:
put_int.full0():
c00025f5:	b1 30                	mov    $0x30,%cl

c00025f7 <put_int.put_each_num>:
put_int.put_each_num():
c00025f7:	51                   	push   %ecx
c00025f8:	e8 e1 fe ff ff       	call   c00024de <put_char>
c00025fd:	83 c4 04             	add    $0x4,%esp
c0002600:	47                   	inc    %edi
c0002601:	8a 8f c0 c0 00 c0    	mov    -0x3fff3f40(%edi),%cl
c0002607:	83 ff 08             	cmp    $0x8,%edi
c000260a:	7c eb                	jl     c00025f7 <put_int.put_each_num>
c000260c:	61                   	popa   
c000260d:	c3                   	ret    

c000260e <set_cursor>:
set_cursor():
c000260e:	60                   	pusha  
c000260f:	66 8b 5c 24 24       	mov    0x24(%esp),%bx
c0002614:	66 ba d4 03          	mov    $0x3d4,%dx
c0002618:	b0 0e                	mov    $0xe,%al
c000261a:	ee                   	out    %al,(%dx)
c000261b:	66 ba d5 03          	mov    $0x3d5,%dx
c000261f:	88 f8                	mov    %bh,%al
c0002621:	ee                   	out    %al,(%dx)
c0002622:	66 ba d4 03          	mov    $0x3d4,%dx
c0002626:	b0 0f                	mov    $0xf,%al
c0002628:	ee                   	out    %al,(%dx)
c0002629:	66 ba d5 03          	mov    $0x3d5,%dx
c000262d:	88 d8                	mov    %bl,%al
c000262f:	ee                   	out    %al,(%dx)
c0002630:	61                   	popa   
c0002631:	c3                   	ret    

c0002632 <panic_spin>:
panic_spin():
/work/x86_os_my/kernel/debug.c:10
/* 打印文件名,行号,函数名,条件并使程序悬停 */
void panic_spin(char* filename,	       \
	        int line,	       \
		const char* func,      \
		const char* condition) \
{
c0002632:	55                   	push   %ebp
c0002633:	89 e5                	mov    %esp,%ebp
c0002635:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/debug.c:11
   intr_disable();	// 因为有时候会单独调用panic_spin,所以在此处关中断。
c0002638:	e8 56 f6 ff ff       	call   c0001c93 <intr_disable>
/work/x86_os_my/kernel/debug.c:12
   put_str("\n\n\n!!!!! error !!!!!\n");
c000263d:	83 ec 0c             	sub    $0xc,%esp
c0002640:	68 18 8b 00 c0       	push   $0xc0008b18
c0002645:	e8 76 fe ff ff       	call   c00024c0 <put_str>
c000264a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:13
   put_str("filename:");put_str(filename);put_str("\n");
c000264d:	83 ec 0c             	sub    $0xc,%esp
c0002650:	68 2e 8b 00 c0       	push   $0xc0008b2e
c0002655:	e8 66 fe ff ff       	call   c00024c0 <put_str>
c000265a:	83 c4 10             	add    $0x10,%esp
c000265d:	83 ec 0c             	sub    $0xc,%esp
c0002660:	ff 75 08             	pushl  0x8(%ebp)
c0002663:	e8 58 fe ff ff       	call   c00024c0 <put_str>
c0002668:	83 c4 10             	add    $0x10,%esp
c000266b:	83 ec 0c             	sub    $0xc,%esp
c000266e:	68 38 8b 00 c0       	push   $0xc0008b38
c0002673:	e8 48 fe ff ff       	call   c00024c0 <put_str>
c0002678:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:14
   put_str("line:0x");put_int(line);put_str("\n");
c000267b:	83 ec 0c             	sub    $0xc,%esp
c000267e:	68 3a 8b 00 c0       	push   $0xc0008b3a
c0002683:	e8 38 fe ff ff       	call   c00024c0 <put_str>
c0002688:	83 c4 10             	add    $0x10,%esp
c000268b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000268e:	83 ec 0c             	sub    $0xc,%esp
c0002691:	50                   	push   %eax
c0002692:	e8 14 ff ff ff       	call   c00025ab <put_int>
c0002697:	83 c4 10             	add    $0x10,%esp
c000269a:	83 ec 0c             	sub    $0xc,%esp
c000269d:	68 38 8b 00 c0       	push   $0xc0008b38
c00026a2:	e8 19 fe ff ff       	call   c00024c0 <put_str>
c00026a7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:15
   put_str("function:");put_str((char*)func);put_str("\n");
c00026aa:	83 ec 0c             	sub    $0xc,%esp
c00026ad:	68 42 8b 00 c0       	push   $0xc0008b42
c00026b2:	e8 09 fe ff ff       	call   c00024c0 <put_str>
c00026b7:	83 c4 10             	add    $0x10,%esp
c00026ba:	83 ec 0c             	sub    $0xc,%esp
c00026bd:	ff 75 10             	pushl  0x10(%ebp)
c00026c0:	e8 fb fd ff ff       	call   c00024c0 <put_str>
c00026c5:	83 c4 10             	add    $0x10,%esp
c00026c8:	83 ec 0c             	sub    $0xc,%esp
c00026cb:	68 38 8b 00 c0       	push   $0xc0008b38
c00026d0:	e8 eb fd ff ff       	call   c00024c0 <put_str>
c00026d5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:16
   put_str("condition:");put_str((char*)condition);put_str("\n");
c00026d8:	83 ec 0c             	sub    $0xc,%esp
c00026db:	68 4c 8b 00 c0       	push   $0xc0008b4c
c00026e0:	e8 db fd ff ff       	call   c00024c0 <put_str>
c00026e5:	83 c4 10             	add    $0x10,%esp
c00026e8:	83 ec 0c             	sub    $0xc,%esp
c00026eb:	ff 75 14             	pushl  0x14(%ebp)
c00026ee:	e8 cd fd ff ff       	call   c00024c0 <put_str>
c00026f3:	83 c4 10             	add    $0x10,%esp
c00026f6:	83 ec 0c             	sub    $0xc,%esp
c00026f9:	68 38 8b 00 c0       	push   $0xc0008b38
c00026fe:	e8 bd fd ff ff       	call   c00024c0 <put_str>
c0002703:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:17 (discriminator 1)
   while(1);
c0002706:	eb fe                	jmp    c0002706 <panic_spin+0xd4>

c0002708 <bitmap_init>:
bitmap_init():
/work/x86_os_my/lib/kernel/bitmap.c:16
	uint8_t* bits;				位图空间
};
*/

/* 将位图btmp初始化 */
void bitmap_init(struct bitmap* btmp) {
c0002708:	55                   	push   %ebp
c0002709:	89 e5                	mov    %esp,%ebp
c000270b:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/bitmap.c:17
	memset(btmp->bits, 0, btmp->btmp_bytes_len);   
c000270e:	8b 45 08             	mov    0x8(%ebp),%eax
c0002711:	8b 10                	mov    (%eax),%edx
c0002713:	8b 45 08             	mov    0x8(%ebp),%eax
c0002716:	8b 40 04             	mov    0x4(%eax),%eax
c0002719:	83 ec 04             	sub    $0x4,%esp
c000271c:	52                   	push   %edx
c000271d:	6a 00                	push   $0x0
c000271f:	50                   	push   %eax
c0002720:	e8 25 13 00 00       	call   c0003a4a <memset>
c0002725:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:18
}
c0002728:	90                   	nop
c0002729:	c9                   	leave  
c000272a:	c3                   	ret    

c000272b <bitmap_scan_test>:
bitmap_scan_test():
/work/x86_os_my/lib/kernel/bitmap.c:23

/* 判断bit_idx位是否为1
若为1则返回true
否则返回false */
bool bitmap_scan_test(struct bitmap* btmp, uint32_t bit_idx) {
c000272b:	55                   	push   %ebp
c000272c:	89 e5                	mov    %esp,%ebp
c000272e:	53                   	push   %ebx
c000272f:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:24
	uint32_t byte_idx = bit_idx / 8;    // 向下取整用于索引数组下标
c0002732:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002735:	c1 e8 03             	shr    $0x3,%eax
c0002738:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:25
	uint32_t bit_odd  = bit_idx % 8;    // 取余用于索引数组内的位
c000273b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000273e:	83 e0 07             	and    $0x7,%eax
c0002741:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:26
	return (btmp->bits[byte_idx] & (BITMAP_MASK << bit_odd));
c0002744:	8b 45 08             	mov    0x8(%ebp),%eax
c0002747:	8b 50 04             	mov    0x4(%eax),%edx
c000274a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000274d:	01 d0                	add    %edx,%eax
c000274f:	0f b6 00             	movzbl (%eax),%eax
c0002752:	0f b6 d0             	movzbl %al,%edx
c0002755:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002758:	bb 01 00 00 00       	mov    $0x1,%ebx
c000275d:	89 c1                	mov    %eax,%ecx
c000275f:	d3 e3                	shl    %cl,%ebx
c0002761:	89 d8                	mov    %ebx,%eax
c0002763:	21 d0                	and    %edx,%eax
/work/x86_os_my/lib/kernel/bitmap.c:27
}
c0002765:	83 c4 10             	add    $0x10,%esp
c0002768:	5b                   	pop    %ebx
c0002769:	5d                   	pop    %ebp
c000276a:	c3                   	ret    

c000276b <bitmap_scan>:
bitmap_scan():
/work/x86_os_my/lib/kernel/bitmap.c:32

/* 在位图中申请连续cnt个位
成功：返回其起始位下标
失败：返回-1 */
int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {
c000276b:	55                   	push   %ebp
c000276c:	89 e5                	mov    %esp,%ebp
c000276e:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/lib/kernel/bitmap.c:33
	uint32_t idx_byte = 0;	 // 用于记录空闲位所在的字节
c0002771:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:35
	/* 先逐字节比较,蛮力法 */
	while (( 0xff == btmp->bits[idx_byte]) && (idx_byte < btmp->btmp_bytes_len)) {
c0002778:	eb 04                	jmp    c000277e <bitmap_scan+0x13>
/work/x86_os_my/lib/kernel/bitmap.c:37
		/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */
		idx_byte++;
c000277a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:35
成功：返回其起始位下标
失败：返回-1 */
int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {
	uint32_t idx_byte = 0;	 // 用于记录空闲位所在的字节
	/* 先逐字节比较,蛮力法 */
	while (( 0xff == btmp->bits[idx_byte]) && (idx_byte < btmp->btmp_bytes_len)) {
c000277e:	8b 45 08             	mov    0x8(%ebp),%eax
c0002781:	8b 50 04             	mov    0x4(%eax),%edx
c0002784:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002787:	01 d0                	add    %edx,%eax
c0002789:	0f b6 00             	movzbl (%eax),%eax
c000278c:	3c ff                	cmp    $0xff,%al
c000278e:	75 0a                	jne    c000279a <bitmap_scan+0x2f>
/work/x86_os_my/lib/kernel/bitmap.c:35 (discriminator 1)
c0002790:	8b 45 08             	mov    0x8(%ebp),%eax
c0002793:	8b 00                	mov    (%eax),%eax
c0002795:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0002798:	77 e0                	ja     c000277a <bitmap_scan+0xf>
/work/x86_os_my/lib/kernel/bitmap.c:39
		/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */
		idx_byte++;
	}
	ASSERT(idx_byte < btmp->btmp_bytes_len);	//这里应该是"<="
c000279a:	8b 45 08             	mov    0x8(%ebp),%eax
c000279d:	8b 00                	mov    (%eax),%eax
c000279f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00027a2:	77 19                	ja     c00027bd <bitmap_scan+0x52>
/work/x86_os_my/lib/kernel/bitmap.c:39 (discriminator 1)
c00027a4:	68 58 8b 00 c0       	push   $0xc0008b58
c00027a9:	68 ac 8b 00 c0       	push   $0xc0008bac
c00027ae:	6a 27                	push   $0x27
c00027b0:	68 78 8b 00 c0       	push   $0xc0008b78
c00027b5:	e8 78 fe ff ff       	call   c0002632 <panic_spin>
c00027ba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:40
	if (idx_byte == btmp->btmp_bytes_len) {		// 若该内存池找不到可用空间		
c00027bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00027c0:	8b 00                	mov    (%eax),%eax
c00027c2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00027c5:	75 0a                	jne    c00027d1 <bitmap_scan+0x66>
/work/x86_os_my/lib/kernel/bitmap.c:41
		return -1;
c00027c7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00027cc:	e9 cd 00 00 00       	jmp    c000289e <bitmap_scan+0x133>
/work/x86_os_my/lib/kernel/bitmap.c:46
	}

	/* 若在位图数组范围内的某字节内找到了空闲位，
	 * 在该字节内逐位比对,返回空闲位的索引。*/
	int idx_bit = 0;
c00027d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:48
	/* 和btmp->bits[idx_byte]这个字节逐位对比 */
	while ((uint8_t)(BITMAP_MASK << idx_bit) & btmp->bits[idx_byte]) { 
c00027d8:	eb 04                	jmp    c00027de <bitmap_scan+0x73>
/work/x86_os_my/lib/kernel/bitmap.c:49
		idx_bit++;
c00027da:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:48

	/* 若在位图数组范围内的某字节内找到了空闲位，
	 * 在该字节内逐位比对,返回空闲位的索引。*/
	int idx_bit = 0;
	/* 和btmp->bits[idx_byte]这个字节逐位对比 */
	while ((uint8_t)(BITMAP_MASK << idx_bit) & btmp->bits[idx_byte]) { 
c00027de:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00027e1:	ba 01 00 00 00       	mov    $0x1,%edx
c00027e6:	89 c1                	mov    %eax,%ecx
c00027e8:	d3 e2                	shl    %cl,%edx
c00027ea:	89 d0                	mov    %edx,%eax
c00027ec:	0f b6 d0             	movzbl %al,%edx
c00027ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00027f2:	8b 48 04             	mov    0x4(%eax),%ecx
c00027f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00027f8:	01 c8                	add    %ecx,%eax
c00027fa:	0f b6 00             	movzbl (%eax),%eax
c00027fd:	0f b6 c0             	movzbl %al,%eax
c0002800:	21 d0                	and    %edx,%eax
c0002802:	85 c0                	test   %eax,%eax
c0002804:	75 d4                	jne    c00027da <bitmap_scan+0x6f>
/work/x86_os_my/lib/kernel/bitmap.c:52
		idx_bit++;
	}
	
	int bit_idx_start = idx_byte * 8 + idx_bit;		// 空闲位在位图内的下标
c0002806:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002809:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c0002810:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002813:	01 d0                	add    %edx,%eax
c0002815:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:53
	if (cnt == 1) {
c0002818:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
c000281c:	75 05                	jne    c0002823 <bitmap_scan+0xb8>
/work/x86_os_my/lib/kernel/bitmap.c:54
		return bit_idx_start;
c000281e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002821:	eb 7b                	jmp    c000289e <bitmap_scan+0x133>
/work/x86_os_my/lib/kernel/bitmap.c:57
	}

	uint32_t bit_left = (btmp->btmp_bytes_len * 8 - bit_idx_start);	// 记录还有多少位可以判断
c0002823:	8b 45 08             	mov    0x8(%ebp),%eax
c0002826:	8b 00                	mov    (%eax),%eax
c0002828:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c000282f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002832:	29 c2                	sub    %eax,%edx
c0002834:	89 d0                	mov    %edx,%eax
c0002836:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:58
	uint32_t next_bit = bit_idx_start + 1;
c0002839:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000283c:	83 c0 01             	add    $0x1,%eax
c000283f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:59
	uint32_t count = 1;			// 用于记录找到的空闲位的个数
c0002842:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:61

	bit_idx_start = -1;			// 初始化为-1，若找不到连续的位就直接返回-1
c0002849:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:62
	while (bit_left-- > 0) {
c0002850:	eb 3c                	jmp    c000288e <bitmap_scan+0x123>
/work/x86_os_my/lib/kernel/bitmap.c:63
		if (!(bitmap_scan_test(btmp, next_bit))) {	// 判断next_bit位是否为1,=1返回true，=0返回false
c0002852:	83 ec 08             	sub    $0x8,%esp
c0002855:	ff 75 e4             	pushl  -0x1c(%ebp)
c0002858:	ff 75 08             	pushl  0x8(%ebp)
c000285b:	e8 cb fe ff ff       	call   c000272b <bitmap_scan_test>
c0002860:	83 c4 10             	add    $0x10,%esp
c0002863:	85 c0                	test   %eax,%eax
c0002865:	75 06                	jne    c000286d <bitmap_scan+0x102>
/work/x86_os_my/lib/kernel/bitmap.c:64
			count++;
c0002867:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
c000286b:	eb 07                	jmp    c0002874 <bitmap_scan+0x109>
/work/x86_os_my/lib/kernel/bitmap.c:66
		} else {
			count = 0;			// 重新从0找cnt个连续的bit
c000286d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:69
		}
		
		if (count == cnt) {		// 已找到连续的cnt个空位
c0002874:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002877:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000287a:	75 0e                	jne    c000288a <bitmap_scan+0x11f>
/work/x86_os_my/lib/kernel/bitmap.c:70
			bit_idx_start = next_bit - cnt + 1;
c000287c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000287f:	2b 45 0c             	sub    0xc(%ebp),%eax
c0002882:	83 c0 01             	add    $0x1,%eax
c0002885:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:71
			break;
c0002888:	eb 11                	jmp    c000289b <bitmap_scan+0x130>
/work/x86_os_my/lib/kernel/bitmap.c:73
		}
		next_bit++;
c000288a:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:62
	uint32_t bit_left = (btmp->btmp_bytes_len * 8 - bit_idx_start);	// 记录还有多少位可以判断
	uint32_t next_bit = bit_idx_start + 1;
	uint32_t count = 1;			// 用于记录找到的空闲位的个数

	bit_idx_start = -1;			// 初始化为-1，若找不到连续的位就直接返回-1
	while (bit_left-- > 0) {
c000288e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002891:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002894:	89 55 e8             	mov    %edx,-0x18(%ebp)
c0002897:	85 c0                	test   %eax,%eax
c0002899:	75 b7                	jne    c0002852 <bitmap_scan+0xe7>
/work/x86_os_my/lib/kernel/bitmap.c:75
			bit_idx_start = next_bit - cnt + 1;
			break;
		}
		next_bit++;
	}
	return bit_idx_start;
c000289b:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/lib/kernel/bitmap.c:76
}
c000289e:	c9                   	leave  
c000289f:	c3                   	ret    

c00028a0 <bitmap_set>:
bitmap_set():
/work/x86_os_my/lib/kernel/bitmap.c:79

/* 将位图btmp的bit_idx位设置为value */
void bitmap_set(struct bitmap* btmp, uint32_t bit_idx, int8_t value) {
c00028a0:	55                   	push   %ebp
c00028a1:	89 e5                	mov    %esp,%ebp
c00028a3:	56                   	push   %esi
c00028a4:	53                   	push   %ebx
c00028a5:	83 ec 20             	sub    $0x20,%esp
c00028a8:	8b 45 10             	mov    0x10(%ebp),%eax
c00028ab:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:80
	ASSERT((value == 0) || (value == 1));
c00028ae:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c00028b2:	74 1f                	je     c00028d3 <bitmap_set+0x33>
/work/x86_os_my/lib/kernel/bitmap.c:80 (discriminator 1)
c00028b4:	80 7d e4 01          	cmpb   $0x1,-0x1c(%ebp)
c00028b8:	74 19                	je     c00028d3 <bitmap_set+0x33>
/work/x86_os_my/lib/kernel/bitmap.c:80 (discriminator 2)
c00028ba:	68 8c 8b 00 c0       	push   $0xc0008b8c
c00028bf:	68 b8 8b 00 c0       	push   $0xc0008bb8
c00028c4:	6a 50                	push   $0x50
c00028c6:	68 78 8b 00 c0       	push   $0xc0008b78
c00028cb:	e8 62 fd ff ff       	call   c0002632 <panic_spin>
c00028d0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:81
	uint32_t byte_idx = bit_idx / 8;    // 向下取整用于索引数组下标
c00028d3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00028d6:	c1 e8 03             	shr    $0x3,%eax
c00028d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:82
	uint32_t bit_odd  = bit_idx % 8;    // 取余用于索引数组内的位
c00028dc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00028df:	83 e0 07             	and    $0x7,%eax
c00028e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:86

	/* 一般都会用个0x1这样的数对字节中的位操作,
	* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/
	if (value) {
c00028e5:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c00028e9:	74 2f                	je     c000291a <bitmap_set+0x7a>
/work/x86_os_my/lib/kernel/bitmap.c:87
		btmp->bits[byte_idx] |= (BITMAP_MASK << bit_odd);
c00028eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00028ee:	8b 50 04             	mov    0x4(%eax),%edx
c00028f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00028f4:	01 c2                	add    %eax,%edx
c00028f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00028f9:	8b 48 04             	mov    0x4(%eax),%ecx
c00028fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00028ff:	01 c8                	add    %ecx,%eax
c0002901:	0f b6 00             	movzbl (%eax),%eax
c0002904:	89 c6                	mov    %eax,%esi
c0002906:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002909:	bb 01 00 00 00       	mov    $0x1,%ebx
c000290e:	89 c1                	mov    %eax,%ecx
c0002910:	d3 e3                	shl    %cl,%ebx
c0002912:	89 d8                	mov    %ebx,%eax
c0002914:	09 f0                	or     %esi,%eax
c0002916:	88 02                	mov    %al,(%edx)
/work/x86_os_my/lib/kernel/bitmap.c:91
	} else {
		btmp->bits[byte_idx] &= ~(BITMAP_MASK << bit_odd);
	}
}
c0002918:	eb 2f                	jmp    c0002949 <bitmap_set+0xa9>
/work/x86_os_my/lib/kernel/bitmap.c:89
	/* 一般都会用个0x1这样的数对字节中的位操作,
	* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/
	if (value) {
		btmp->bits[byte_idx] |= (BITMAP_MASK << bit_odd);
	} else {
		btmp->bits[byte_idx] &= ~(BITMAP_MASK << bit_odd);
c000291a:	8b 45 08             	mov    0x8(%ebp),%eax
c000291d:	8b 50 04             	mov    0x4(%eax),%edx
c0002920:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002923:	01 c2                	add    %eax,%edx
c0002925:	8b 45 08             	mov    0x8(%ebp),%eax
c0002928:	8b 48 04             	mov    0x4(%eax),%ecx
c000292b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000292e:	01 c8                	add    %ecx,%eax
c0002930:	0f b6 00             	movzbl (%eax),%eax
c0002933:	89 c3                	mov    %eax,%ebx
c0002935:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002938:	be 01 00 00 00       	mov    $0x1,%esi
c000293d:	89 c1                	mov    %eax,%ecx
c000293f:	d3 e6                	shl    %cl,%esi
c0002941:	89 f0                	mov    %esi,%eax
c0002943:	f7 d0                	not    %eax
c0002945:	21 d8                	and    %ebx,%eax
c0002947:	88 02                	mov    %al,(%edx)
/work/x86_os_my/lib/kernel/bitmap.c:91
	}
}
c0002949:	90                   	nop
c000294a:	8d 65 f8             	lea    -0x8(%ebp),%esp
c000294d:	5b                   	pop    %ebx
c000294e:	5e                   	pop    %esi
c000294f:	5d                   	pop    %ebp
c0002950:	c3                   	ret    

c0002951 <vaddr_get>:
vaddr_get():
/work/x86_os_my/kernel/memory.c:66
struct pool kernel_pool, user_pool;		// 生成内核内存池和用户内存池
struct virtual_addr kernel_vaddr;		// 此结构是用来给内核分配虚拟地址

/* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页,
 * 成功则返回虚拟页的起始地址, 失败则返回NULL */
static void* vaddr_get(enum pool_flags pf, uint32_t pg_cnt) {
c0002951:	55                   	push   %ebp
c0002952:	89 e5                	mov    %esp,%ebp
c0002954:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:67
	int vaddr_start = 0, bit_idx_start = -1;
c0002957:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000295e:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:68
	uint32_t cnt = 0;
c0002965:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:69
	if (pf == PF_KERNEL) {
c000296c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0002970:	75 64                	jne    c00029d6 <vaddr_get+0x85>
/work/x86_os_my/kernel/memory.c:71
		// 在位图中申请连续cnt个位 成功：返回其起始位下标
		bit_idx_start  = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
c0002972:	83 ec 08             	sub    $0x8,%esp
c0002975:	ff 75 0c             	pushl  0xc(%ebp)
c0002978:	68 48 cb 00 c0       	push   $0xc000cb48
c000297d:	e8 e9 fd ff ff       	call   c000276b <bitmap_scan>
c0002982:	83 c4 10             	add    $0x10,%esp
c0002985:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:72
		if (bit_idx_start == -1) {	//失败
c0002988:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c000298c:	75 2b                	jne    c00029b9 <vaddr_get+0x68>
/work/x86_os_my/kernel/memory.c:73
			return NULL;
c000298e:	b8 00 00 00 00       	mov    $0x0,%eax
c0002993:	e9 cd 00 00 00       	jmp    c0002a65 <vaddr_get+0x114>
/work/x86_os_my/kernel/memory.c:77
		}
		while(cnt < pg_cnt) {
			// 设置位图中的位，表示内存已被占用
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
c0002998:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000299b:	8d 50 01             	lea    0x1(%eax),%edx
c000299e:	89 55 f0             	mov    %edx,-0x10(%ebp)
c00029a1:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00029a4:	01 d0                	add    %edx,%eax
c00029a6:	83 ec 04             	sub    $0x4,%esp
c00029a9:	6a 01                	push   $0x1
c00029ab:	50                   	push   %eax
c00029ac:	68 48 cb 00 c0       	push   $0xc000cb48
c00029b1:	e8 ea fe ff ff       	call   c00028a0 <bitmap_set>
c00029b6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:75
		// 在位图中申请连续cnt个位 成功：返回其起始位下标
		bit_idx_start  = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
		if (bit_idx_start == -1) {	//失败
			return NULL;
		}
		while(cnt < pg_cnt) {
c00029b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00029bc:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00029bf:	72 d7                	jb     c0002998 <vaddr_get+0x47>
/work/x86_os_my/kernel/memory.c:79
			// 设置位图中的位，表示内存已被占用
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
		}
		vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
c00029c1:	a1 50 cb 00 c0       	mov    0xc000cb50,%eax
c00029c6:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00029c9:	c1 e2 0c             	shl    $0xc,%edx
c00029cc:	01 d0                	add    %edx,%eax
c00029ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00029d1:	e9 8c 00 00 00       	jmp    c0002a62 <vaddr_get+0x111>
/work/x86_os_my/kernel/memory.c:81
	} else {
		struct task_struct* cur = running_thread();
c00029d6:	e8 56 14 00 00       	call   c0003e31 <running_thread>
c00029db:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:82
		bit_idx_start  = bitmap_scan(&cur->userprog_vaddr.vaddr_bitmap, pg_cnt);
c00029de:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00029e1:	83 c0 58             	add    $0x58,%eax
c00029e4:	83 ec 08             	sub    $0x8,%esp
c00029e7:	ff 75 0c             	pushl  0xc(%ebp)
c00029ea:	50                   	push   %eax
c00029eb:	e8 7b fd ff ff       	call   c000276b <bitmap_scan>
c00029f0:	83 c4 10             	add    $0x10,%esp
c00029f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:83
		if (bit_idx_start == -1) {
c00029f6:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c00029fa:	75 2a                	jne    c0002a26 <vaddr_get+0xd5>
/work/x86_os_my/kernel/memory.c:84
			return NULL;
c00029fc:	b8 00 00 00 00       	mov    $0x0,%eax
c0002a01:	eb 62                	jmp    c0002a65 <vaddr_get+0x114>
/work/x86_os_my/kernel/memory.c:87
		}
		while(cnt < pg_cnt) {
			bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
c0002a03:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002a06:	8d 50 01             	lea    0x1(%eax),%edx
c0002a09:	89 55 f0             	mov    %edx,-0x10(%ebp)
c0002a0c:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002a0f:	01 c2                	add    %eax,%edx
c0002a11:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002a14:	83 c0 58             	add    $0x58,%eax
c0002a17:	83 ec 04             	sub    $0x4,%esp
c0002a1a:	6a 01                	push   $0x1
c0002a1c:	52                   	push   %edx
c0002a1d:	50                   	push   %eax
c0002a1e:	e8 7d fe ff ff       	call   c00028a0 <bitmap_set>
c0002a23:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:86
		struct task_struct* cur = running_thread();
		bit_idx_start  = bitmap_scan(&cur->userprog_vaddr.vaddr_bitmap, pg_cnt);
		if (bit_idx_start == -1) {
			return NULL;
		}
		while(cnt < pg_cnt) {
c0002a26:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002a29:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0002a2c:	72 d5                	jb     c0002a03 <vaddr_get+0xb2>
/work/x86_os_my/kernel/memory.c:89
			bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
		}
		vaddr_start = cur->userprog_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
c0002a2e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002a31:	8b 40 60             	mov    0x60(%eax),%eax
c0002a34:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002a37:	c1 e2 0c             	shl    $0xc,%edx
c0002a3a:	01 d0                	add    %edx,%eax
c0002a3c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:92

		/* (0xc0000000 - PG_SIZE)做为用户3级栈已经在start_process被分配 */
		ASSERT((uint32_t)vaddr_start < (0xc0000000 - PG_SIZE));
c0002a3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002a42:	3d ff ef ff bf       	cmp    $0xbfffefff,%eax
c0002a47:	76 19                	jbe    c0002a62 <vaddr_get+0x111>
/work/x86_os_my/kernel/memory.c:92 (discriminator 1)
c0002a49:	68 c4 8b 00 c0       	push   $0xc0008bc4
c0002a4e:	68 2c 8f 00 c0       	push   $0xc0008f2c
c0002a53:	6a 5c                	push   $0x5c
c0002a55:	68 f3 8b 00 c0       	push   $0xc0008bf3
c0002a5a:	e8 d3 fb ff ff       	call   c0002632 <panic_spin>
c0002a5f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:95
		
	}
	return (void*)vaddr_start;
c0002a62:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:96
}
c0002a65:	c9                   	leave  
c0002a66:	c3                   	ret    

c0002a67 <pte_ptr>:
pte_ptr():
/work/x86_os_my/kernel/memory.c:103
// 页表项 page table
/* 得到虚拟地址vaddr对应的pte指针*/
// 虚拟地址 vaddr 所在 pte 的"虚拟地址"!!!
// *pte 代表的是 pte 页表项的内容,
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页表项"属性
uint32_t* pte_ptr(uint32_t vaddr) {
c0002a67:	55                   	push   %ebp
c0002a68:	89 e5                	mov    %esp,%ebp
c0002a6a:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:108
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
					((vaddr & 0xffc00000) >> 10) + \
c0002a6d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a70:	25 00 00 c0 ff       	and    $0xffc00000,%eax
c0002a75:	c1 e8 0a             	shr    $0xa,%eax
c0002a78:	89 c2                	mov    %eax,%edx
/work/x86_os_my/kernel/memory.c:109
					PTE_IDX(vaddr) * 4);
c0002a7a:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a7d:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c0002a82:	c1 e8 0c             	shr    $0xc,%eax
c0002a85:	c1 e0 02             	shl    $0x2,%eax
/work/x86_os_my/kernel/memory.c:108
uint32_t* pte_ptr(uint32_t vaddr) {
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
					((vaddr & 0xffc00000) >> 10) + \
c0002a88:	01 d0                	add    %edx,%eax
c0002a8a:	2d 00 00 40 00       	sub    $0x400000,%eax
/work/x86_os_my/kernel/memory.c:107
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页表项"属性
uint32_t* pte_ptr(uint32_t vaddr) {
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
c0002a8f:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:110
					((vaddr & 0xffc00000) >> 10) + \
					PTE_IDX(vaddr) * 4);
	return pte;
c0002a92:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/kernel/memory.c:111
}
c0002a95:	c9                   	leave  
c0002a96:	c3                   	ret    

c0002a97 <pde_ptr>:
pde_ptr():
/work/x86_os_my/kernel/memory.c:118
// 页目录表项 page Directory table entry
/* 得到虚拟地址vaddr对应的pde的指针 */
// 虚拟地址 vaddr 所在 pde 的"虚拟地址"!!!
// *pde 代表的是 pde 页目录项的内容
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页目录项"属性
uint32_t* pde_ptr(uint32_t vaddr) {
c0002a97:	55                   	push   %ebp
c0002a98:	89 e5                	mov    %esp,%ebp
c0002a9a:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:120
	/* 0xfffff是用来访问到页目录表本身所在的地址 */
	uint32_t* pde = (uint32_t*)((0xfffff000) + PDE_IDX(vaddr) * 4);
c0002a9d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002aa0:	c1 e8 16             	shr    $0x16,%eax
c0002aa3:	05 00 fc ff 3f       	add    $0x3ffffc00,%eax
c0002aa8:	c1 e0 02             	shl    $0x2,%eax
c0002aab:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:121
	return pde;
c0002aae:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/kernel/memory.c:122
}
c0002ab1:	c9                   	leave  
c0002ab2:	c3                   	ret    

c0002ab3 <palloc>:
palloc():
/work/x86_os_my/kernel/memory.c:126

/* 在m_pool指向的物理内存池中分配1个物理页,
 * 成功则返回页框的物理地址,失败则返回NULL */
static void* palloc(struct pool* m_pool) {
c0002ab3:	55                   	push   %ebp
c0002ab4:	89 e5                	mov    %esp,%ebp
c0002ab6:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:128
	/* 扫描或设置位图要保证原子操作 */
	int bit_idx = bitmap_scan(&m_pool->pool_bitmap, 1);    // 找一个物理页面
c0002ab9:	8b 45 08             	mov    0x8(%ebp),%eax
c0002abc:	83 ec 08             	sub    $0x8,%esp
c0002abf:	6a 01                	push   $0x1
c0002ac1:	50                   	push   %eax
c0002ac2:	e8 a4 fc ff ff       	call   c000276b <bitmap_scan>
c0002ac7:	83 c4 10             	add    $0x10,%esp
c0002aca:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:129
	if (bit_idx == -1 ) {
c0002acd:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0002ad1:	75 07                	jne    c0002ada <palloc+0x27>
/work/x86_os_my/kernel/memory.c:130
		return NULL;
c0002ad3:	b8 00 00 00 00       	mov    $0x0,%eax
c0002ad8:	eb 2b                	jmp    c0002b05 <palloc+0x52>
/work/x86_os_my/kernel/memory.c:132
	}
	bitmap_set(&m_pool->pool_bitmap, bit_idx, 1);	// 将此位bit_idx置1
c0002ada:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002add:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ae0:	83 ec 04             	sub    $0x4,%esp
c0002ae3:	6a 01                	push   $0x1
c0002ae5:	52                   	push   %edx
c0002ae6:	50                   	push   %eax
c0002ae7:	e8 b4 fd ff ff       	call   c00028a0 <bitmap_set>
c0002aec:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:133
	uint32_t page_phyaddr = ((bit_idx * PG_SIZE) + m_pool->phy_addr_start);
c0002aef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002af2:	c1 e0 0c             	shl    $0xc,%eax
c0002af5:	89 c2                	mov    %eax,%edx
c0002af7:	8b 45 08             	mov    0x8(%ebp),%eax
c0002afa:	8b 40 08             	mov    0x8(%eax),%eax
c0002afd:	01 d0                	add    %edx,%eax
c0002aff:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:134
	return (void*)page_phyaddr;
c0002b02:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/kernel/memory.c:135
}
c0002b05:	c9                   	leave  
c0002b06:	c3                   	ret    

c0002b07 <page_table_add>:
page_table_add():
/work/x86_os_my/kernel/memory.c:138

/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */
static void page_table_add(void* _vaddr, void* _page_phyaddr) {
c0002b07:	55                   	push   %ebp
c0002b08:	89 e5                	mov    %esp,%ebp
c0002b0a:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:139
	uint32_t vaddr = (uint32_t)_vaddr, page_phyaddr = (uint32_t)_page_phyaddr;
c0002b0d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002b10:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002b13:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002b16:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:140
	uint32_t* pde = pde_ptr(vaddr);	//变量pde是虚拟地址!!!
c0002b19:	ff 75 f4             	pushl  -0xc(%ebp)
c0002b1c:	e8 76 ff ff ff       	call   c0002a97 <pde_ptr>
c0002b21:	83 c4 04             	add    $0x4,%esp
c0002b24:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:141
	uint32_t* pte = pte_ptr(vaddr);	//变量pte是虚拟地址!!!
c0002b27:	ff 75 f4             	pushl  -0xc(%ebp)
c0002b2a:	e8 38 ff ff ff       	call   c0002a67 <pte_ptr>
c0002b2f:	83 c4 04             	add    $0x4,%esp
c0002b32:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:149
	* pde页目录项 pte页表项
	* 执行*pte可能会访问到空的pde。所以确保pde创建完成后才能执行*pte，否则会引发page_fault。
	* 因此在*pde为0时，*pte只能出现在下面else语句块中的*pde后面。
	* *********************************************************/
	/* 先在页目录内判断目录项的P位，若为1,则表示该表已存在 */
	if (*pde & 0x00000001) {			// 页目录项 存在
c0002b35:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002b38:	8b 00                	mov    (%eax),%eax
c0002b3a:	83 e0 01             	and    $0x1,%eax
c0002b3d:	85 c0                	test   %eax,%eax
c0002b3f:	74 64                	je     c0002ba5 <page_table_add+0x9e>
/work/x86_os_my/kernel/memory.c:150
		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
c0002b41:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002b44:	8b 00                	mov    (%eax),%eax
c0002b46:	83 e0 01             	and    $0x1,%eax
c0002b49:	85 c0                	test   %eax,%eax
c0002b4b:	74 1c                	je     c0002b69 <page_table_add+0x62>
/work/x86_os_my/kernel/memory.c:150 (discriminator 1)
c0002b4d:	68 03 8c 00 c0       	push   $0xc0008c03
c0002b52:	68 38 8f 00 c0       	push   $0xc0008f38
c0002b57:	68 96 00 00 00       	push   $0x96
c0002b5c:	68 f3 8b 00 c0       	push   $0xc0008bf3
c0002b61:	e8 cc fa ff ff       	call   c0002632 <panic_spin>
c0002b66:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:152

		if (!(*pte & 0x00000001)) {		// 页表项pte不存在，创建PTE
c0002b69:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002b6c:	8b 00                	mov    (%eax),%eax
c0002b6e:	83 e0 01             	and    $0x1,%eax
c0002b71:	85 c0                	test   %eax,%eax
c0002b73:	75 12                	jne    c0002b87 <page_table_add+0x80>
/work/x86_os_my/kernel/memory.c:153
			*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);		// 物理地址 | US=1,RW=1,P=1
c0002b75:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002b78:	83 c8 07             	or     $0x7,%eax
c0002b7b:	89 c2                	mov    %eax,%edx
c0002b7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002b80:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:173
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
	}
}
c0002b82:	e9 8e 00 00 00       	jmp    c0002c15 <page_table_add+0x10e>
/work/x86_os_my/kernel/memory.c:155
		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic

		if (!(*pte & 0x00000001)) {		// 页表项pte不存在，创建PTE
			*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);		// 物理地址 | US=1,RW=1,P=1
		} else {						// 不会执行到这，因为上面的ASSERT
			PANIC("pte repeat");
c0002b87:	68 18 8c 00 c0       	push   $0xc0008c18
c0002b8c:	68 38 8f 00 c0       	push   $0xc0008f38
c0002b91:	68 9b 00 00 00       	push   $0x9b
c0002b96:	68 f3 8b 00 c0       	push   $0xc0008bf3
c0002b9b:	e8 92 fa ff ff       	call   c0002632 <panic_spin>
c0002ba0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:173
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
	}
}
c0002ba3:	eb 70                	jmp    c0002c15 <page_table_add+0x10e>
/work/x86_os_my/kernel/memory.c:159
		} else {						// 不会执行到这，因为上面的ASSERT
			PANIC("pte repeat");
		}
	} else {							// 页目录项不存在，先创建页目录，再创建页表项
		/* 页表中用到的页一律从内核空间分配 */
		uint32_t pde_phyaddr = (uint32_t)palloc(&kernel_pool);
c0002ba5:	83 ec 0c             	sub    $0xc,%esp
c0002ba8:	68 60 cb 00 c0       	push   $0xc000cb60
c0002bad:	e8 01 ff ff ff       	call   c0002ab3 <palloc>
c0002bb2:	83 c4 10             	add    $0x10,%esp
c0002bb5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:160
		*pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 注意这行是pde_phyaddr，不是page_phyaddr!!!
c0002bb8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0002bbb:	83 c8 07             	or     $0x7,%eax
c0002bbe:	89 c2                	mov    %eax,%edx
c0002bc0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002bc3:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:168
		 * 访问物理地址 pde_phyaddr，需要找到它的虚拟地址！
		 * 只要用_vaddr的 PTE 取高20位即可。
		   搞得这么难理解，其实就是0xffc00000找到页目录表，然后加上vaddr的PDE在页目录表中的索引
		   (uint32_t*)(0xffc00000 + ((vaddr & 0xffc00000) >> 10))
		 */
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);
c0002bc5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002bc8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002bcd:	83 ec 04             	sub    $0x4,%esp
c0002bd0:	68 00 10 00 00       	push   $0x1000
c0002bd5:	6a 00                	push   $0x0
c0002bd7:	50                   	push   %eax
c0002bd8:	e8 6d 0e 00 00       	call   c0003a4a <memset>
c0002bdd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:170

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
c0002be0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002be3:	8b 00                	mov    (%eax),%eax
c0002be5:	83 e0 01             	and    $0x1,%eax
c0002be8:	85 c0                	test   %eax,%eax
c0002bea:	74 1c                	je     c0002c08 <page_table_add+0x101>
/work/x86_os_my/kernel/memory.c:170 (discriminator 1)
c0002bec:	68 03 8c 00 c0       	push   $0xc0008c03
c0002bf1:	68 38 8f 00 c0       	push   $0xc0008f38
c0002bf6:	68 aa 00 00 00       	push   $0xaa
c0002bfb:	68 f3 8b 00 c0       	push   $0xc0008bf3
c0002c00:	e8 2d fa ff ff       	call   c0002632 <panic_spin>
c0002c05:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:171
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
c0002c08:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002c0b:	83 c8 07             	or     $0x7,%eax
c0002c0e:	89 c2                	mov    %eax,%edx
c0002c10:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002c13:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:173
	}
}
c0002c15:	90                   	nop
c0002c16:	c9                   	leave  
c0002c17:	c3                   	ret    

c0002c18 <malloc_page>:
malloc_page():
/work/x86_os_my/kernel/memory.c:176

/* 分配pg_cnt个页空间,成功则返回起始虚拟地址,失败时返回NULL */
void* malloc_page(enum pool_flags pf, uint32_t pg_cnt) {
c0002c18:	55                   	push   %ebp
c0002c19:	89 e5                	mov    %esp,%ebp
c0002c1b:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:177
	ASSERT(pg_cnt > 0 && pg_cnt < 3840);
c0002c1e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002c22:	74 09                	je     c0002c2d <malloc_page+0x15>
/work/x86_os_my/kernel/memory.c:177 (discriminator 1)
c0002c24:	81 7d 0c ff 0e 00 00 	cmpl   $0xeff,0xc(%ebp)
c0002c2b:	76 1c                	jbe    c0002c49 <malloc_page+0x31>
/work/x86_os_my/kernel/memory.c:177 (discriminator 3)
c0002c2d:	68 23 8c 00 c0       	push   $0xc0008c23
c0002c32:	68 48 8f 00 c0       	push   $0xc0008f48
c0002c37:	68 b1 00 00 00       	push   $0xb1
c0002c3c:	68 f3 8b 00 c0       	push   $0xc0008bf3
c0002c41:	e8 ec f9 ff ff       	call   c0002632 <panic_spin>
c0002c46:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:183
	/***********   malloc_page的原理是三个动作的合成:   ***********
		1 通过vaddr_get在虚拟内存池中申请虚拟地址
		2 通过palloc在物理内存池中申请物理页
		3 通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射
	***************************************************************/
	void* vaddr_start = vaddr_get(pf, pg_cnt);
c0002c49:	83 ec 08             	sub    $0x8,%esp
c0002c4c:	ff 75 0c             	pushl  0xc(%ebp)
c0002c4f:	ff 75 08             	pushl  0x8(%ebp)
c0002c52:	e8 fa fc ff ff       	call   c0002951 <vaddr_get>
c0002c57:	83 c4 10             	add    $0x10,%esp
c0002c5a:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:184
	if (vaddr_start == NULL) {
c0002c5d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002c61:	75 07                	jne    c0002c6a <malloc_page+0x52>
/work/x86_os_my/kernel/memory.c:185
		return NULL;
c0002c63:	b8 00 00 00 00       	mov    $0x0,%eax
c0002c68:	eb 6e                	jmp    c0002cd8 <malloc_page+0xc0>
/work/x86_os_my/kernel/memory.c:188
	}

	uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
c0002c6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002c6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002c70:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002c73:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:189
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c0002c76:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c79:	83 e0 01             	and    $0x1,%eax
c0002c7c:	85 c0                	test   %eax,%eax
c0002c7e:	74 07                	je     c0002c87 <malloc_page+0x6f>
/work/x86_os_my/kernel/memory.c:189 (discriminator 1)
c0002c80:	b8 60 cb 00 c0       	mov    $0xc000cb60,%eax
c0002c85:	eb 05                	jmp    c0002c8c <malloc_page+0x74>
/work/x86_os_my/kernel/memory.c:189 (discriminator 2)
c0002c87:	b8 60 ca 00 c0       	mov    $0xc000ca60,%eax
/work/x86_os_my/kernel/memory.c:189 (discriminator 4)
c0002c8c:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:192 (discriminator 4)

	/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
	while (cnt-- > 0) {
c0002c8f:	eb 37                	jmp    c0002cc8 <malloc_page+0xb0>
/work/x86_os_my/kernel/memory.c:193
		void* page_phyaddr = palloc(mem_pool);
c0002c91:	83 ec 0c             	sub    $0xc,%esp
c0002c94:	ff 75 e8             	pushl  -0x18(%ebp)
c0002c97:	e8 17 fe ff ff       	call   c0002ab3 <palloc>
c0002c9c:	83 c4 10             	add    $0x10,%esp
c0002c9f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:194
		if (page_phyaddr == NULL) {  // 失败时要将曾经已申请的虚拟地址和物理页全部回滚，在将来完成内存回收时再补充
c0002ca2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0002ca6:	75 07                	jne    c0002caf <malloc_page+0x97>
/work/x86_os_my/kernel/memory.c:195
			return NULL;
c0002ca8:	b8 00 00 00 00       	mov    $0x0,%eax
c0002cad:	eb 29                	jmp    c0002cd8 <malloc_page+0xc0>
/work/x86_os_my/kernel/memory.c:197
		}
		page_table_add((void*)vaddr, page_phyaddr); // 在页表中做映射 
c0002caf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002cb2:	83 ec 08             	sub    $0x8,%esp
c0002cb5:	ff 75 e4             	pushl  -0x1c(%ebp)
c0002cb8:	50                   	push   %eax
c0002cb9:	e8 49 fe ff ff       	call   c0002b07 <page_table_add>
c0002cbe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:198
		vaddr += PG_SIZE;		 // 下一个虚拟页
c0002cc1:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:192

	uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;

	/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
	while (cnt-- > 0) {
c0002cc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002ccb:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002cce:	89 55 f0             	mov    %edx,-0x10(%ebp)
c0002cd1:	85 c0                	test   %eax,%eax
c0002cd3:	75 bc                	jne    c0002c91 <malloc_page+0x79>
/work/x86_os_my/kernel/memory.c:200
			return NULL;
		}
		page_table_add((void*)vaddr, page_phyaddr); // 在页表中做映射 
		vaddr += PG_SIZE;		 // 下一个虚拟页
	}
	return vaddr_start;
c0002cd5:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/kernel/memory.c:201
}
c0002cd8:	c9                   	leave  
c0002cd9:	c3                   	ret    

c0002cda <get_kernel_pages>:
get_kernel_pages():
/work/x86_os_my/kernel/memory.c:204

/* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */
void* get_kernel_pages(uint32_t pg_cnt) {
c0002cda:	55                   	push   %ebp
c0002cdb:	89 e5                	mov    %esp,%ebp
c0002cdd:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:205
	lock_acquire(&kernel_pool.lock);
c0002ce0:	83 ec 0c             	sub    $0xc,%esp
c0002ce3:	68 70 cb 00 c0       	push   $0xc000cb70
c0002ce8:	e8 e2 1c 00 00       	call   c00049cf <lock_acquire>
c0002ced:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:206
	void* vaddr =  malloc_page(PF_KERNEL, pg_cnt);
c0002cf0:	83 ec 08             	sub    $0x8,%esp
c0002cf3:	ff 75 08             	pushl  0x8(%ebp)
c0002cf6:	6a 01                	push   $0x1
c0002cf8:	e8 1b ff ff ff       	call   c0002c18 <malloc_page>
c0002cfd:	83 c4 10             	add    $0x10,%esp
c0002d00:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:207
	if (vaddr != NULL) {
c0002d03:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002d07:	74 17                	je     c0002d20 <get_kernel_pages+0x46>
/work/x86_os_my/kernel/memory.c:208
		memset(vaddr, 0, pg_cnt * PG_SIZE);
c0002d09:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d0c:	c1 e0 0c             	shl    $0xc,%eax
c0002d0f:	83 ec 04             	sub    $0x4,%esp
c0002d12:	50                   	push   %eax
c0002d13:	6a 00                	push   $0x0
c0002d15:	ff 75 f4             	pushl  -0xc(%ebp)
c0002d18:	e8 2d 0d 00 00       	call   c0003a4a <memset>
c0002d1d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:210
	}
	lock_release(&kernel_pool.lock);
c0002d20:	83 ec 0c             	sub    $0xc,%esp
c0002d23:	68 70 cb 00 c0       	push   $0xc000cb70
c0002d28:	e8 19 1d 00 00       	call   c0004a46 <lock_release>
c0002d2d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:211
	return vaddr;
c0002d30:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:212
}
c0002d33:	c9                   	leave  
c0002d34:	c3                   	ret    

c0002d35 <get_user_pages>:
get_user_pages():
/work/x86_os_my/kernel/memory.c:215

/* 在用户空间中申请4k内存,并返回其虚拟地址 */
void* get_user_pages(uint32_t pg_cnt) {
c0002d35:	55                   	push   %ebp
c0002d36:	89 e5                	mov    %esp,%ebp
c0002d38:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:216
	lock_acquire(&user_pool.lock);
c0002d3b:	83 ec 0c             	sub    $0xc,%esp
c0002d3e:	68 70 ca 00 c0       	push   $0xc000ca70
c0002d43:	e8 87 1c 00 00       	call   c00049cf <lock_acquire>
c0002d48:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:217
	void* vaddr = malloc_page(PF_USER, pg_cnt);
c0002d4b:	83 ec 08             	sub    $0x8,%esp
c0002d4e:	ff 75 08             	pushl  0x8(%ebp)
c0002d51:	6a 02                	push   $0x2
c0002d53:	e8 c0 fe ff ff       	call   c0002c18 <malloc_page>
c0002d58:	83 c4 10             	add    $0x10,%esp
c0002d5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:218
	if (vaddr != NULL) {
c0002d5e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002d62:	74 17                	je     c0002d7b <get_user_pages+0x46>
/work/x86_os_my/kernel/memory.c:219
		memset(vaddr, 0, pg_cnt * PG_SIZE);
c0002d64:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d67:	c1 e0 0c             	shl    $0xc,%eax
c0002d6a:	83 ec 04             	sub    $0x4,%esp
c0002d6d:	50                   	push   %eax
c0002d6e:	6a 00                	push   $0x0
c0002d70:	ff 75 f4             	pushl  -0xc(%ebp)
c0002d73:	e8 d2 0c 00 00       	call   c0003a4a <memset>
c0002d78:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:221
	}
	lock_release(&user_pool.lock);
c0002d7b:	83 ec 0c             	sub    $0xc,%esp
c0002d7e:	68 70 ca 00 c0       	push   $0xc000ca70
c0002d83:	e8 be 1c 00 00       	call   c0004a46 <lock_release>
c0002d88:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:222
	return vaddr;
c0002d8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:223
}
c0002d8e:	c9                   	leave  
c0002d8f:	c3                   	ret    

c0002d90 <get_a_page>:
get_a_page():
/work/x86_os_my/kernel/memory.c:227

/* 将虚拟地址vaddr与pf池中的物理地址关联,仅支持一页空间分配
 * 功能是，可以指定虚拟地址的内存分配 */
void* get_a_page(enum pool_flags pf, uint32_t vaddr) {
c0002d90:	55                   	push   %ebp
c0002d91:	89 e5                	mov    %esp,%ebp
c0002d93:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:228
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c0002d96:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d99:	83 e0 01             	and    $0x1,%eax
c0002d9c:	85 c0                	test   %eax,%eax
c0002d9e:	74 07                	je     c0002da7 <get_a_page+0x17>
/work/x86_os_my/kernel/memory.c:228 (discriminator 1)
c0002da0:	b8 60 cb 00 c0       	mov    $0xc000cb60,%eax
c0002da5:	eb 05                	jmp    c0002dac <get_a_page+0x1c>
/work/x86_os_my/kernel/memory.c:228 (discriminator 2)
c0002da7:	b8 60 ca 00 c0       	mov    $0xc000ca60,%eax
/work/x86_os_my/kernel/memory.c:228 (discriminator 4)
c0002dac:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:229 (discriminator 4)
	lock_acquire(&mem_pool->lock);
c0002daf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002db2:	83 c0 10             	add    $0x10,%eax
c0002db5:	83 ec 0c             	sub    $0xc,%esp
c0002db8:	50                   	push   %eax
c0002db9:	e8 11 1c 00 00       	call   c00049cf <lock_acquire>
c0002dbe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:232 (discriminator 4)

	/* 先将虚拟地址对应的位图置1 */
	struct task_struct* cur = running_thread();
c0002dc1:	e8 6b 10 00 00       	call   c0003e31 <running_thread>
c0002dc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:233 (discriminator 4)
	int32_t bit_idx = -1;
c0002dc9:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:235 (discriminator 4)

	if (cur->pgdir != NULL && pf == PF_USER) {
c0002dd0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002dd3:	8b 40 54             	mov    0x54(%eax),%eax
c0002dd6:	85 c0                	test   %eax,%eax
c0002dd8:	74 55                	je     c0002e2f <get_a_page+0x9f>
/work/x86_os_my/kernel/memory.c:235 (discriminator 1)
c0002dda:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0002dde:	75 4f                	jne    c0002e2f <get_a_page+0x9f>
/work/x86_os_my/kernel/memory.c:237
		/* 若当前是用户进程申请用户内存,就修改用户进程自己的虚拟地址池的 位图 */
		bit_idx = (vaddr - cur->userprog_vaddr.vaddr_start) / PG_SIZE;
c0002de0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002de3:	8b 40 60             	mov    0x60(%eax),%eax
c0002de6:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002de9:	29 c2                	sub    %eax,%edx
c0002deb:	89 d0                	mov    %edx,%eax
c0002ded:	c1 e8 0c             	shr    $0xc,%eax
c0002df0:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:238
		ASSERT(bit_idx > 0);
c0002df3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002df7:	7f 1c                	jg     c0002e15 <get_a_page+0x85>
/work/x86_os_my/kernel/memory.c:238 (discriminator 1)
c0002df9:	68 3f 8c 00 c0       	push   $0xc0008c3f
c0002dfe:	68 54 8f 00 c0       	push   $0xc0008f54
c0002e03:	68 ee 00 00 00       	push   $0xee
c0002e08:	68 f3 8b 00 c0       	push   $0xc0008bf3
c0002e0d:	e8 20 f8 ff ff       	call   c0002632 <panic_spin>
c0002e12:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:239
		bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx, 1);
c0002e15:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002e18:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002e1b:	83 c2 58             	add    $0x58,%edx
c0002e1e:	83 ec 04             	sub    $0x4,%esp
c0002e21:	6a 01                	push   $0x1
c0002e23:	50                   	push   %eax
c0002e24:	52                   	push   %edx
c0002e25:	e8 76 fa ff ff       	call   c00028a0 <bitmap_set>
c0002e2a:	83 c4 10             	add    $0x10,%esp
c0002e2d:	eb 78                	jmp    c0002ea7 <get_a_page+0x117>
/work/x86_os_my/kernel/memory.c:241

	} else if (cur->pgdir == NULL && pf == PF_KERNEL) {
c0002e2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002e32:	8b 40 54             	mov    0x54(%eax),%eax
c0002e35:	85 c0                	test   %eax,%eax
c0002e37:	75 52                	jne    c0002e8b <get_a_page+0xfb>
/work/x86_os_my/kernel/memory.c:241 (discriminator 1)
c0002e39:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0002e3d:	75 4c                	jne    c0002e8b <get_a_page+0xfb>
/work/x86_os_my/kernel/memory.c:243
		/* 如果是内核线程申请内核内存,就修改 kernel_vaddr */
		bit_idx = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
c0002e3f:	a1 50 cb 00 c0       	mov    0xc000cb50,%eax
c0002e44:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002e47:	29 c2                	sub    %eax,%edx
c0002e49:	89 d0                	mov    %edx,%eax
c0002e4b:	c1 e8 0c             	shr    $0xc,%eax
c0002e4e:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:244
		ASSERT(bit_idx > 0);
c0002e51:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002e55:	7f 1c                	jg     c0002e73 <get_a_page+0xe3>
/work/x86_os_my/kernel/memory.c:244 (discriminator 1)
c0002e57:	68 3f 8c 00 c0       	push   $0xc0008c3f
c0002e5c:	68 54 8f 00 c0       	push   $0xc0008f54
c0002e61:	68 f4 00 00 00       	push   $0xf4
c0002e66:	68 f3 8b 00 c0       	push   $0xc0008bf3
c0002e6b:	e8 c2 f7 ff ff       	call   c0002632 <panic_spin>
c0002e70:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:245
		bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx, 1);
c0002e73:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002e76:	83 ec 04             	sub    $0x4,%esp
c0002e79:	6a 01                	push   $0x1
c0002e7b:	50                   	push   %eax
c0002e7c:	68 48 cb 00 c0       	push   $0xc000cb48
c0002e81:	e8 1a fa ff ff       	call   c00028a0 <bitmap_set>
c0002e86:	83 c4 10             	add    $0x10,%esp
c0002e89:	eb 1c                	jmp    c0002ea7 <get_a_page+0x117>
/work/x86_os_my/kernel/memory.c:248

	} else {
		PANIC("get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page");
c0002e8b:	68 4c 8c 00 c0       	push   $0xc0008c4c
c0002e90:	68 54 8f 00 c0       	push   $0xc0008f54
c0002e95:	68 f8 00 00 00       	push   $0xf8
c0002e9a:	68 f3 8b 00 c0       	push   $0xc0008bf3
c0002e9f:	e8 8e f7 ff ff       	call   c0002632 <panic_spin>
c0002ea4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:251
	}

	void* page_phyaddr = palloc(mem_pool);
c0002ea7:	83 ec 0c             	sub    $0xc,%esp
c0002eaa:	ff 75 f4             	pushl  -0xc(%ebp)
c0002ead:	e8 01 fc ff ff       	call   c0002ab3 <palloc>
c0002eb2:	83 c4 10             	add    $0x10,%esp
c0002eb5:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:252
	if (page_phyaddr == NULL) {
c0002eb8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0002ebc:	75 19                	jne    c0002ed7 <get_a_page+0x147>
/work/x86_os_my/kernel/memory.c:253
		lock_release(&mem_pool->lock);	//哈哈
c0002ebe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002ec1:	83 c0 10             	add    $0x10,%eax
c0002ec4:	83 ec 0c             	sub    $0xc,%esp
c0002ec7:	50                   	push   %eax
c0002ec8:	e8 79 1b 00 00       	call   c0004a46 <lock_release>
c0002ecd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:254
		return NULL;
c0002ed0:	b8 00 00 00 00       	mov    $0x0,%eax
c0002ed5:	eb 27                	jmp    c0002efe <get_a_page+0x16e>
/work/x86_os_my/kernel/memory.c:256
	}
	page_table_add((void*)vaddr, page_phyaddr);
c0002ed7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002eda:	83 ec 08             	sub    $0x8,%esp
c0002edd:	ff 75 e8             	pushl  -0x18(%ebp)
c0002ee0:	50                   	push   %eax
c0002ee1:	e8 21 fc ff ff       	call   c0002b07 <page_table_add>
c0002ee6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:258
	
	lock_release(&mem_pool->lock);
c0002ee9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002eec:	83 c0 10             	add    $0x10,%eax
c0002eef:	83 ec 0c             	sub    $0xc,%esp
c0002ef2:	50                   	push   %eax
c0002ef3:	e8 4e 1b 00 00       	call   c0004a46 <lock_release>
c0002ef8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:259
	return (void*)vaddr;
c0002efb:	8b 45 0c             	mov    0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:260
}
c0002efe:	c9                   	leave  
c0002eff:	c3                   	ret    

c0002f00 <addr_v2p>:
addr_v2p():
/work/x86_os_my/kernel/memory.c:263

/* 得到虚拟地址映射到的物理地址 */
uint32_t addr_v2p(uint32_t vaddr) {
c0002f00:	55                   	push   %ebp
c0002f01:	89 e5                	mov    %esp,%ebp
c0002f03:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:264
	uint32_t* pte = pte_ptr(vaddr);
c0002f06:	ff 75 08             	pushl  0x8(%ebp)
c0002f09:	e8 59 fb ff ff       	call   c0002a67 <pte_ptr>
c0002f0e:	83 c4 04             	add    $0x4,%esp
c0002f11:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:268
	/* (*pte)的内容是 vaddr 所在 pte 的内容，也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的页表项属性，
	 * 因为页框都是自然页，低 12 位地址是 0，所以页表项 pte（和页目录项 pde）中只需要记录页框的高 20 位地址即可。
	 */
	return ((*pte & 0xfffff000) + (vaddr & 0x00000fff));
c0002f14:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002f17:	8b 00                	mov    (%eax),%eax
c0002f19:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002f1e:	89 c2                	mov    %eax,%edx
c0002f20:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f23:	25 ff 0f 00 00       	and    $0xfff,%eax
c0002f28:	01 d0                	add    %edx,%eax
/work/x86_os_my/kernel/memory.c:269
}
c0002f2a:	c9                   	leave  
c0002f2b:	c3                   	ret    

c0002f2c <arena2block>:
arena2block():
/work/x86_os_my/kernel/memory.c:283
|                     |
| +-----------------+ |
+-+  mem_block_desc |←+
  +-----------------+
*/
static struct mem_block* arena2block(struct arena* a, uint32_t idx) {
c0002f2c:	55                   	push   %ebp
c0002f2d:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/kernel/memory.c:284
	return (struct mem_block*)((uint32_t)a + sizeof(struct arena) + idx * a->desc->block_size);
c0002f2f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f32:	8b 00                	mov    (%eax),%eax
c0002f34:	8b 00                	mov    (%eax),%eax
c0002f36:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0002f3a:	89 c2                	mov    %eax,%edx
c0002f3c:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f3f:	01 d0                	add    %edx,%eax
c0002f41:	83 c0 0c             	add    $0xc,%eax
/work/x86_os_my/kernel/memory.c:285
}
c0002f44:	5d                   	pop    %ebp
c0002f45:	c3                   	ret    

c0002f46 <block2arena>:
block2arena():
/work/x86_os_my/kernel/memory.c:290

/* 返回内存块mem_block所在的arena地址
 * 取到了虚拟地址mem_block那一整页的地址
 */
static struct arena* block2arena(struct mem_block* b) {
c0002f46:	55                   	push   %ebp
c0002f47:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/kernel/memory.c:291
	return (struct arena*)((uint32_t)b & 0xfffff000);
c0002f49:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f4c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
/work/x86_os_my/kernel/memory.c:292
}
c0002f51:	5d                   	pop    %ebp
c0002f52:	c3                   	ret    

c0002f53 <sys_malloc>:
sys_malloc():
/work/x86_os_my/kernel/memory.c:303
 * 3.内存块地址被返回给用户后，用户可以自由使用此内存块 mem_block
 *   会把此内存块中的 list_elem 型变量 free_elem 覆盖
 *   不过 arena->mem_block_desc->free_list 中的元素已经记录了 mem_block->list_elem 的地址
 *   使用时覆盖的，只是 mem_block 的内容。
 */
void* sys_malloc(uint32_t size) {
c0002f53:	55                   	push   %ebp
c0002f54:	89 e5                	mov    %esp,%ebp
c0002f56:	83 ec 38             	sub    $0x38,%esp
/work/x86_os_my/kernel/memory.c:308
	enum pool_flags PF;
	struct pool* mem_pool;
	uint32_t pool_size;
	struct mem_block_desc* descs;
	struct task_struct* cur_thread = running_thread();
c0002f59:	e8 d3 0e 00 00       	call   c0003e31 <running_thread>
c0002f5e:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/kernel/memory.c:311

	/* 判断用哪个内存池*/
	if (cur_thread->pgdir == NULL) {	// 是内核线程
c0002f61:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0002f64:	8b 40 54             	mov    0x54(%eax),%eax
c0002f67:	85 c0                	test   %eax,%eax
c0002f69:	75 1f                	jne    c0002f8a <sys_malloc+0x37>
/work/x86_os_my/kernel/memory.c:312
		PF = PF_KERNEL;
c0002f6b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:313
		pool_size = kernel_pool.pool_size;
c0002f72:	a1 6c cb 00 c0       	mov    0xc000cb6c,%eax
c0002f77:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:314
		mem_pool = &kernel_pool;
c0002f7a:	c7 45 f0 60 cb 00 c0 	movl   $0xc000cb60,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:315
		descs = k_block_descs;
c0002f81:	c7 45 e8 a0 ca 00 c0 	movl   $0xc000caa0,-0x18(%ebp)
c0002f88:	eb 1f                	jmp    c0002fa9 <sys_malloc+0x56>
/work/x86_os_my/kernel/memory.c:317
	} else {							// 用户进程pcb中的pgdir（页目录表）会在为其分配页表时创建【create_page_dir】
		PF = PF_USER;
c0002f8a:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:318
		pool_size = user_pool.pool_size;
c0002f91:	a1 6c ca 00 c0       	mov    0xc000ca6c,%eax
c0002f96:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:319
		mem_pool = &user_pool;
c0002f99:	c7 45 f0 60 ca 00 c0 	movl   $0xc000ca60,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:320
		descs = cur_thread->u_block_desc;
c0002fa0:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0002fa3:	83 c0 64             	add    $0x64,%eax
c0002fa6:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:324
	}

	/* 若申请的内存不在内存池容量范围内则直接返回NULL */
	if (!(size > 0 && size < pool_size)) {
c0002fa9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002fad:	74 08                	je     c0002fb7 <sys_malloc+0x64>
/work/x86_os_my/kernel/memory.c:324 (discriminator 1)
c0002faf:	8b 45 08             	mov    0x8(%ebp),%eax
c0002fb2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0002fb5:	72 0a                	jb     c0002fc1 <sys_malloc+0x6e>
/work/x86_os_my/kernel/memory.c:325
		return NULL;
c0002fb7:	b8 00 00 00 00       	mov    $0x0,%eax
c0002fbc:	e9 c5 02 00 00       	jmp    c0003286 <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:330
	}

	struct arena* a;
	struct mem_block* b;
	lock_acquire(&mem_pool->lock);
c0002fc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002fc4:	83 c0 10             	add    $0x10,%eax
c0002fc7:	83 ec 0c             	sub    $0xc,%esp
c0002fca:	50                   	push   %eax
c0002fcb:	e8 ff 19 00 00       	call   c00049cf <lock_acquire>
c0002fd0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:333

	/* 超过最大内存块1024, 就分配页框 */
	if (size > 1024) {
c0002fd3:	81 7d 08 00 04 00 00 	cmpl   $0x400,0x8(%ebp)
c0002fda:	0f 86 94 00 00 00    	jbe    c0003074 <sys_malloc+0x121>
/work/x86_os_my/kernel/memory.c:334
		uint32_t page_cnt = DIV_ROUND_UP(size + sizeof(struct arena), PG_SIZE);	// 向上取整需要的页框数
c0002fe0:	8b 45 08             	mov    0x8(%ebp),%eax
c0002fe3:	05 0b 10 00 00       	add    $0x100b,%eax
c0002fe8:	c1 e8 0c             	shr    $0xc,%eax
c0002feb:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/kernel/memory.c:336

		a = malloc_page(PF, page_cnt);
c0002fee:	83 ec 08             	sub    $0x8,%esp
c0002ff1:	ff 75 d8             	pushl  -0x28(%ebp)
c0002ff4:	ff 75 f4             	pushl  -0xc(%ebp)
c0002ff7:	e8 1c fc ff ff       	call   c0002c18 <malloc_page>
c0002ffc:	83 c4 10             	add    $0x10,%esp
c0002fff:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:337
		if (a != NULL) {
c0003002:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0003006:	74 50                	je     c0003058 <sys_malloc+0x105>
/work/x86_os_my/kernel/memory.c:338
			memset(a, 0, page_cnt * PG_SIZE);
c0003008:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000300b:	c1 e0 0c             	shl    $0xc,%eax
c000300e:	83 ec 04             	sub    $0x4,%esp
c0003011:	50                   	push   %eax
c0003012:	6a 00                	push   $0x0
c0003014:	ff 75 d4             	pushl  -0x2c(%ebp)
c0003017:	e8 2e 0a 00 00       	call   c0003a4a <memset>
c000301c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:342

			// 【arena结构体初始化，情况1】
			/* 对于分配的大块页框,将desc置为NULL, cnt置为页框数, large置为true */
			a->desc = NULL;
c000301f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0003022:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/kernel/memory.c:343
			a->cnt = page_cnt;
c0003028:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000302b:	8b 55 d8             	mov    -0x28(%ebp),%edx
c000302e:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/kernel/memory.c:344
			a->large = true;
c0003031:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0003034:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/kernel/memory.c:346

			lock_release(&mem_pool->lock);
c000303b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000303e:	83 c0 10             	add    $0x10,%eax
c0003041:	83 ec 0c             	sub    $0xc,%esp
c0003044:	50                   	push   %eax
c0003045:	e8 fc 19 00 00       	call   c0004a46 <lock_release>
c000304a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:347
			return (void*)(a + 1);	// 跨过arena大小，把剩下的内存返回
c000304d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0003050:	83 c0 0c             	add    $0xc,%eax
c0003053:	e9 2e 02 00 00       	jmp    c0003286 <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:349
		} else {
			lock_release(&mem_pool->lock);
c0003058:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000305b:	83 c0 10             	add    $0x10,%eax
c000305e:	83 ec 0c             	sub    $0xc,%esp
c0003061:	50                   	push   %eax
c0003062:	e8 df 19 00 00       	call   c0004a46 <lock_release>
c0003067:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:350
			return NULL;
c000306a:	b8 00 00 00 00       	mov    $0x0,%eax
c000306f:	e9 12 02 00 00       	jmp    c0003286 <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:358
	} else {
	/* 若申请的内存小于等于1024,可在各种规格的mem_block_desc中去适配 */
		uint8_t desc_idx;

		/* 从内存块描述符中匹配合适的内存块规格 */
		for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c0003074:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
c0003078:	eb 25                	jmp    c000309f <sys_malloc+0x14c>
/work/x86_os_my/kernel/memory.c:359
			if (size <= descs[desc_idx].block_size) {	// 从小往大后,找到后退出
c000307a:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c000307e:	89 d0                	mov    %edx,%eax
c0003080:	01 c0                	add    %eax,%eax
c0003082:	01 d0                	add    %edx,%eax
c0003084:	c1 e0 03             	shl    $0x3,%eax
c0003087:	89 c2                	mov    %eax,%edx
c0003089:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000308c:	01 d0                	add    %edx,%eax
c000308e:	8b 00                	mov    (%eax),%eax
c0003090:	3b 45 08             	cmp    0x8(%ebp),%eax
c0003093:	73 12                	jae    c00030a7 <sys_malloc+0x154>
/work/x86_os_my/kernel/memory.c:358 (discriminator 2)
	} else {
	/* 若申请的内存小于等于1024,可在各种规格的mem_block_desc中去适配 */
		uint8_t desc_idx;

		/* 从内存块描述符中匹配合适的内存块规格 */
		for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c0003095:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
c0003099:	83 c0 01             	add    $0x1,%eax
c000309c:	88 45 e7             	mov    %al,-0x19(%ebp)
/work/x86_os_my/kernel/memory.c:358 (discriminator 1)
c000309f:	80 7d e7 06          	cmpb   $0x6,-0x19(%ebp)
c00030a3:	76 d5                	jbe    c000307a <sys_malloc+0x127>
c00030a5:	eb 01                	jmp    c00030a8 <sys_malloc+0x155>
/work/x86_os_my/kernel/memory.c:360
			if (size <= descs[desc_idx].block_size) {	// 从小往大后,找到后退出
				break;
c00030a7:	90                   	nop
/work/x86_os_my/kernel/memory.c:366
			}
		}

		/* 若mem_block_desc的free_list中已经没有可用的mem_block,
		 * 就创建新的arena提供mem_block */
		if (list_empty(&descs[desc_idx].free_list)) {
c00030a8:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c00030ac:	89 d0                	mov    %edx,%eax
c00030ae:	01 c0                	add    %eax,%eax
c00030b0:	01 d0                	add    %edx,%eax
c00030b2:	c1 e0 03             	shl    $0x3,%eax
c00030b5:	89 c2                	mov    %eax,%edx
c00030b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00030ba:	01 d0                	add    %edx,%eax
c00030bc:	83 c0 08             	add    $0x8,%eax
c00030bf:	83 ec 0c             	sub    $0xc,%esp
c00030c2:	50                   	push   %eax
c00030c3:	e8 18 16 00 00       	call   c00046e0 <list_empty>
c00030c8:	83 c4 10             	add    $0x10,%esp
c00030cb:	85 c0                	test   %eax,%eax
c00030cd:	0f 84 31 01 00 00    	je     c0003204 <sys_malloc+0x2b1>
/work/x86_os_my/kernel/memory.c:367
			a = malloc_page(PF, 1);       // 分配1页框做为arena
c00030d3:	83 ec 08             	sub    $0x8,%esp
c00030d6:	6a 01                	push   $0x1
c00030d8:	ff 75 f4             	pushl  -0xc(%ebp)
c00030db:	e8 38 fb ff ff       	call   c0002c18 <malloc_page>
c00030e0:	83 c4 10             	add    $0x10,%esp
c00030e3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:368
			if (a == NULL) {
c00030e6:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c00030ea:	75 1c                	jne    c0003108 <sys_malloc+0x1b5>
/work/x86_os_my/kernel/memory.c:369
				lock_release(&mem_pool->lock);
c00030ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00030ef:	83 c0 10             	add    $0x10,%eax
c00030f2:	83 ec 0c             	sub    $0xc,%esp
c00030f5:	50                   	push   %eax
c00030f6:	e8 4b 19 00 00       	call   c0004a46 <lock_release>
c00030fb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:370
				return NULL;
c00030fe:	b8 00 00 00 00       	mov    $0x0,%eax
c0003103:	e9 7e 01 00 00       	jmp    c0003286 <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:372
			}
			memset(a, 0, PG_SIZE);
c0003108:	83 ec 04             	sub    $0x4,%esp
c000310b:	68 00 10 00 00       	push   $0x1000
c0003110:	6a 00                	push   $0x0
c0003112:	ff 75 d4             	pushl  -0x2c(%ebp)
c0003115:	e8 30 09 00 00       	call   c0003a4a <memset>
c000311a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:376

			// 【arena结构体初始化，情况2】
			/* 对于分配的小块内存,将desc置为相应内存块描述符, cnt置为此arena可用的内存块数, large置为false */
			a->desc = &descs[desc_idx];
c000311d:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0003121:	89 d0                	mov    %edx,%eax
c0003123:	01 c0                	add    %eax,%eax
c0003125:	01 d0                	add    %edx,%eax
c0003127:	c1 e0 03             	shl    $0x3,%eax
c000312a:	89 c2                	mov    %eax,%edx
c000312c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000312f:	01 c2                	add    %eax,%edx
c0003131:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0003134:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:377
			a->large = false;
c0003136:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0003139:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/kernel/memory.c:378
			a->cnt = descs[desc_idx].blocks_per_arena;
c0003140:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0003144:	89 d0                	mov    %edx,%eax
c0003146:	01 c0                	add    %eax,%eax
c0003148:	01 d0                	add    %edx,%eax
c000314a:	c1 e0 03             	shl    $0x3,%eax
c000314d:	89 c2                	mov    %eax,%edx
c000314f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0003152:	01 d0                	add    %edx,%eax
c0003154:	8b 50 04             	mov    0x4(%eax),%edx
c0003157:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000315a:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/kernel/memory.c:380

			enum intr_status old_status = intr_disable();
c000315d:	e8 31 eb ff ff       	call   c0001c93 <intr_disable>
c0003162:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/kernel/memory.c:383
			/* 开始将arena拆分成内存块,并添加到内存块描述符的free_list中 */
			uint32_t block_idx;
			for (block_idx = 0; block_idx < descs[desc_idx].blocks_per_arena; block_idx++) {
c0003165:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c000316c:	eb 68                	jmp    c00031d6 <sys_malloc+0x283>
/work/x86_os_my/kernel/memory.c:384
				b = arena2block(a, block_idx);
c000316e:	83 ec 08             	sub    $0x8,%esp
c0003171:	ff 75 e0             	pushl  -0x20(%ebp)
c0003174:	ff 75 d4             	pushl  -0x2c(%ebp)
c0003177:	e8 b0 fd ff ff       	call   c0002f2c <arena2block>
c000317c:	83 c4 10             	add    $0x10,%esp
c000317f:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/kernel/memory.c:385
				ASSERT(!elem_find(&a->desc->free_list, &b->free_elem));
c0003182:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0003185:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0003188:	8b 12                	mov    (%edx),%edx
c000318a:	83 c2 08             	add    $0x8,%edx
c000318d:	83 ec 08             	sub    $0x8,%esp
c0003190:	50                   	push   %eax
c0003191:	52                   	push   %edx
c0003192:	e8 7c 14 00 00       	call   c0004613 <elem_find>
c0003197:	83 c4 10             	add    $0x10,%esp
c000319a:	85 c0                	test   %eax,%eax
c000319c:	74 1c                	je     c00031ba <sys_malloc+0x267>
/work/x86_os_my/kernel/memory.c:385 (discriminator 1)
c000319e:	68 a0 8c 00 c0       	push   $0xc0008ca0
c00031a3:	68 60 8f 00 c0       	push   $0xc0008f60
c00031a8:	68 81 01 00 00       	push   $0x181
c00031ad:	68 f3 8b 00 c0       	push   $0xc0008bf3
c00031b2:	e8 7b f4 ff ff       	call   c0002632 <panic_spin>
c00031b7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:386 (discriminator 2)
				list_append(&a->desc->free_list, &b->free_elem);
c00031ba:	8b 45 cc             	mov    -0x34(%ebp),%eax
c00031bd:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c00031c0:	8b 12                	mov    (%edx),%edx
c00031c2:	83 c2 08             	add    $0x8,%edx
c00031c5:	83 ec 08             	sub    $0x8,%esp
c00031c8:	50                   	push   %eax
c00031c9:	52                   	push   %edx
c00031ca:	e8 ca 13 00 00       	call   c0004599 <list_append>
c00031cf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:383 (discriminator 2)
			a->cnt = descs[desc_idx].blocks_per_arena;

			enum intr_status old_status = intr_disable();
			/* 开始将arena拆分成内存块,并添加到内存块描述符的free_list中 */
			uint32_t block_idx;
			for (block_idx = 0; block_idx < descs[desc_idx].blocks_per_arena; block_idx++) {
c00031d2:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
/work/x86_os_my/kernel/memory.c:383 (discriminator 1)
c00031d6:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c00031da:	89 d0                	mov    %edx,%eax
c00031dc:	01 c0                	add    %eax,%eax
c00031de:	01 d0                	add    %edx,%eax
c00031e0:	c1 e0 03             	shl    $0x3,%eax
c00031e3:	89 c2                	mov    %eax,%edx
c00031e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00031e8:	01 d0                	add    %edx,%eax
c00031ea:	8b 40 04             	mov    0x4(%eax),%eax
c00031ed:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c00031f0:	0f 87 78 ff ff ff    	ja     c000316e <sys_malloc+0x21b>
/work/x86_os_my/kernel/memory.c:388
				b = arena2block(a, block_idx);
				ASSERT(!elem_find(&a->desc->free_list, &b->free_elem));
				list_append(&a->desc->free_list, &b->free_elem);
			}
			intr_set_status(old_status);
c00031f6:	83 ec 0c             	sub    $0xc,%esp
c00031f9:	ff 75 d0             	pushl  -0x30(%ebp)
c00031fc:	e8 bb ea ff ff       	call   c0001cbc <intr_set_status>
c0003201:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:392
		}

		/* 开始分配内存块 */
		b = elem2entry(struct mem_block, free_elem, list_pop(&(descs[desc_idx].free_list)));
c0003204:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0003208:	89 d0                	mov    %edx,%eax
c000320a:	01 c0                	add    %eax,%eax
c000320c:	01 d0                	add    %edx,%eax
c000320e:	c1 e0 03             	shl    $0x3,%eax
c0003211:	89 c2                	mov    %eax,%edx
c0003213:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0003216:	01 d0                	add    %edx,%eax
c0003218:	83 c0 08             	add    $0x8,%eax
c000321b:	83 ec 0c             	sub    $0xc,%esp
c000321e:	50                   	push   %eax
c000321f:	e8 cd 13 00 00       	call   c00045f1 <list_pop>
c0003224:	83 c4 10             	add    $0x10,%esp
c0003227:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/kernel/memory.c:393
		memset(b, 0, descs[desc_idx].block_size);
c000322a:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c000322e:	89 d0                	mov    %edx,%eax
c0003230:	01 c0                	add    %eax,%eax
c0003232:	01 d0                	add    %edx,%eax
c0003234:	c1 e0 03             	shl    $0x3,%eax
c0003237:	89 c2                	mov    %eax,%edx
c0003239:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000323c:	01 d0                	add    %edx,%eax
c000323e:	8b 00                	mov    (%eax),%eax
c0003240:	83 ec 04             	sub    $0x4,%esp
c0003243:	50                   	push   %eax
c0003244:	6a 00                	push   $0x0
c0003246:	ff 75 cc             	pushl  -0x34(%ebp)
c0003249:	e8 fc 07 00 00       	call   c0003a4a <memset>
c000324e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:395

		a = block2arena(b);	// 获取内存块b所在的arena
c0003251:	83 ec 0c             	sub    $0xc,%esp
c0003254:	ff 75 cc             	pushl  -0x34(%ebp)
c0003257:	e8 ea fc ff ff       	call   c0002f46 <block2arena>
c000325c:	83 c4 10             	add    $0x10,%esp
c000325f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:396
		a->cnt--;			// 将此arena中的空闲内存块数减1
c0003262:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0003265:	8b 40 04             	mov    0x4(%eax),%eax
c0003268:	8d 50 ff             	lea    -0x1(%eax),%edx
c000326b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000326e:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/kernel/memory.c:398

		lock_release(&mem_pool->lock);
c0003271:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003274:	83 c0 10             	add    $0x10,%eax
c0003277:	83 ec 0c             	sub    $0xc,%esp
c000327a:	50                   	push   %eax
c000327b:	e8 c6 17 00 00       	call   c0004a46 <lock_release>
c0003280:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:399
		return (void*)b;
c0003283:	8b 45 cc             	mov    -0x34(%ebp),%eax
/work/x86_os_my/kernel/memory.c:401
	}
}
c0003286:	c9                   	leave  
c0003287:	c3                   	ret    

c0003288 <pfree>:
pfree():
/work/x86_os_my/kernel/memory.c:406

/* 将物理地址pg_phy_addr回收到物理内存池
 * 清理物理地址池位图
 */
void pfree(uint32_t pg_phy_addr) {
c0003288:	55                   	push   %ebp
c0003289:	89 e5                	mov    %esp,%ebp
c000328b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:408
	struct pool* mem_pool;
	uint32_t bit_idx = 0;
c000328e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:409
	if (pg_phy_addr >= user_pool.phy_addr_start) {	// 用户物理内存池
c0003295:	a1 68 ca 00 c0       	mov    0xc000ca68,%eax
c000329a:	3b 45 08             	cmp    0x8(%ebp),%eax
c000329d:	77 1b                	ja     c00032ba <pfree+0x32>
/work/x86_os_my/kernel/memory.c:410
		mem_pool = &user_pool;
c000329f:	c7 45 f4 60 ca 00 c0 	movl   $0xc000ca60,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:411
		bit_idx = (pg_phy_addr - user_pool.phy_addr_start) / PG_SIZE;
c00032a6:	a1 68 ca 00 c0       	mov    0xc000ca68,%eax
c00032ab:	8b 55 08             	mov    0x8(%ebp),%edx
c00032ae:	29 c2                	sub    %eax,%edx
c00032b0:	89 d0                	mov    %edx,%eax
c00032b2:	c1 e8 0c             	shr    $0xc,%eax
c00032b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00032b8:	eb 19                	jmp    c00032d3 <pfree+0x4b>
/work/x86_os_my/kernel/memory.c:413
	} else {	// 内核物理内存池
		mem_pool = &kernel_pool;
c00032ba:	c7 45 f4 60 cb 00 c0 	movl   $0xc000cb60,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:414
		bit_idx = (pg_phy_addr - kernel_pool.phy_addr_start) / PG_SIZE;
c00032c1:	a1 68 cb 00 c0       	mov    0xc000cb68,%eax
c00032c6:	8b 55 08             	mov    0x8(%ebp),%edx
c00032c9:	29 c2                	sub    %eax,%edx
c00032cb:	89 d0                	mov    %edx,%eax
c00032cd:	c1 e8 0c             	shr    $0xc,%eax
c00032d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:416
	}
	bitmap_set(&mem_pool->pool_bitmap, bit_idx, 0);	// 将位图中该位清0
c00032d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00032d6:	83 ec 04             	sub    $0x4,%esp
c00032d9:	6a 00                	push   $0x0
c00032db:	ff 75 f0             	pushl  -0x10(%ebp)
c00032de:	50                   	push   %eax
c00032df:	e8 bc f5 ff ff       	call   c00028a0 <bitmap_set>
c00032e4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:417
}
c00032e7:	90                   	nop
c00032e8:	c9                   	leave  
c00032e9:	c3                   	ret    

c00032ea <page_table_pte_remove>:
page_table_pte_remove():
/work/x86_os_my/kernel/memory.c:420

/* 去掉页表中虚拟地址vaddr的映射,只去掉vaddr对应的pte */
static void page_table_pte_remove(uint32_t vaddr) {
c00032ea:	55                   	push   %ebp
c00032eb:	89 e5                	mov    %esp,%ebp
c00032ed:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:421
	uint32_t* pte = pte_ptr(vaddr);
c00032f0:	8b 45 08             	mov    0x8(%ebp),%eax
c00032f3:	50                   	push   %eax
c00032f4:	e8 6e f7 ff ff       	call   c0002a67 <pte_ptr>
c00032f9:	83 c4 04             	add    $0x4,%esp
c00032fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:422
	*pte &= ~PG_P_1;	// 将页表项pte的P位置0
c00032ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003302:	8b 00                	mov    (%eax),%eax
c0003304:	83 e0 fe             	and    $0xfffffffe,%eax
c0003307:	89 c2                	mov    %eax,%edx
c0003309:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000330c:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:423
	asm volatile ("invlpg %0"::"m" (vaddr):"memory");	//更新tlb
c000330e:	0f 01 7d 08          	invlpg 0x8(%ebp)
/work/x86_os_my/kernel/memory.c:426
	/*更新 TLB 有两种方式，一是用 invlpg 指令更新单条虚拟地址条目，
	另外一个是重新加载 cr3 寄存器，这将直接清空 TLB，相当于更新整个页表。*/
}
c0003312:	90                   	nop
c0003313:	c9                   	leave  
c0003314:	c3                   	ret    

c0003315 <vaddr_remove>:
vaddr_remove():
/work/x86_os_my/kernel/memory.c:431

/* 在虚拟地址池中释放以_vaddr起始的连续pg_cnt个虚拟页地址
 * 清理虚拟地址池位图
 */
static void vaddr_remove(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {
c0003315:	55                   	push   %ebp
c0003316:	89 e5                	mov    %esp,%ebp
c0003318:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:432
	uint32_t bit_idx_start = 0, vaddr = (uint32_t)_vaddr, cnt = 0;
c000331b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0003322:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003325:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0003328:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:434

	if (pf == PF_KERNEL) {	// 内核虚拟内存池
c000332f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0003333:	75 3f                	jne    c0003374 <vaddr_remove+0x5f>
/work/x86_os_my/kernel/memory.c:435
		bit_idx_start = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
c0003335:	a1 50 cb 00 c0       	mov    0xc000cb50,%eax
c000333a:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000333d:	29 c2                	sub    %eax,%edx
c000333f:	89 d0                	mov    %edx,%eax
c0003341:	c1 e8 0c             	shr    $0xc,%eax
c0003344:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:436
		while(cnt < pg_cnt) {
c0003347:	eb 21                	jmp    c000336a <vaddr_remove+0x55>
/work/x86_os_my/kernel/memory.c:437
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
c0003349:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000334c:	8d 50 01             	lea    0x1(%eax),%edx
c000334f:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003352:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0003355:	01 d0                	add    %edx,%eax
c0003357:	83 ec 04             	sub    $0x4,%esp
c000335a:	6a 00                	push   $0x0
c000335c:	50                   	push   %eax
c000335d:	68 48 cb 00 c0       	push   $0xc000cb48
c0003362:	e8 39 f5 ff ff       	call   c00028a0 <bitmap_set>
c0003367:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:436
static void vaddr_remove(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {
	uint32_t bit_idx_start = 0, vaddr = (uint32_t)_vaddr, cnt = 0;

	if (pf == PF_KERNEL) {	// 内核虚拟内存池
		bit_idx_start = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
c000336a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000336d:	3b 45 10             	cmp    0x10(%ebp),%eax
c0003370:	72 d7                	jb     c0003349 <vaddr_remove+0x34>
/work/x86_os_my/kernel/memory.c:446
		bit_idx_start = (vaddr - cur_thread->userprog_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
			bitmap_set(&cur_thread->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	}
}
c0003372:	eb 48                	jmp    c00033bc <vaddr_remove+0xa7>
/work/x86_os_my/kernel/memory.c:440
		bit_idx_start = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	} else {	// 用户虚拟内存池
		struct task_struct* cur_thread = running_thread();
c0003374:	e8 b8 0a 00 00       	call   c0003e31 <running_thread>
c0003379:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:441
		bit_idx_start = (vaddr - cur_thread->userprog_vaddr.vaddr_start) / PG_SIZE;
c000337c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000337f:	8b 40 60             	mov    0x60(%eax),%eax
c0003382:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0003385:	29 c2                	sub    %eax,%edx
c0003387:	89 d0                	mov    %edx,%eax
c0003389:	c1 e8 0c             	shr    $0xc,%eax
c000338c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:442
		while(cnt < pg_cnt) {
c000338f:	eb 23                	jmp    c00033b4 <vaddr_remove+0x9f>
/work/x86_os_my/kernel/memory.c:443
			bitmap_set(&cur_thread->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
c0003391:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003394:	8d 50 01             	lea    0x1(%eax),%edx
c0003397:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000339a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000339d:	01 c2                	add    %eax,%edx
c000339f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00033a2:	83 c0 58             	add    $0x58,%eax
c00033a5:	83 ec 04             	sub    $0x4,%esp
c00033a8:	6a 00                	push   $0x0
c00033aa:	52                   	push   %edx
c00033ab:	50                   	push   %eax
c00033ac:	e8 ef f4 ff ff       	call   c00028a0 <bitmap_set>
c00033b1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:442
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	} else {	// 用户虚拟内存池
		struct task_struct* cur_thread = running_thread();
		bit_idx_start = (vaddr - cur_thread->userprog_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
c00033b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00033b7:	3b 45 10             	cmp    0x10(%ebp),%eax
c00033ba:	72 d5                	jb     c0003391 <vaddr_remove+0x7c>
/work/x86_os_my/kernel/memory.c:446
			bitmap_set(&cur_thread->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	}
}
c00033bc:	90                   	nop
c00033bd:	c9                   	leave  
c00033be:	c3                   	ret    

c00033bf <mfree_page>:
mfree_page():
/work/x86_os_my/kernel/memory.c:449

/* 释放以虚拟地址vaddr为起始的cnt个物理页框 */
void mfree_page(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {
c00033bf:	55                   	push   %ebp
c00033c0:	89 e5                	mov    %esp,%ebp
c00033c2:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:451
	uint32_t pg_phy_addr;
	uint32_t vaddr = (int32_t)_vaddr, page_cnt = 0;
c00033c5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00033c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00033cb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:452
	ASSERT(pg_cnt >=1 && vaddr % PG_SIZE == 0);
c00033d2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00033d6:	74 0c                	je     c00033e4 <mfree_page+0x25>
/work/x86_os_my/kernel/memory.c:452 (discriminator 1)
c00033d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00033db:	25 ff 0f 00 00       	and    $0xfff,%eax
c00033e0:	85 c0                	test   %eax,%eax
c00033e2:	74 1c                	je     c0003400 <mfree_page+0x41>
/work/x86_os_my/kernel/memory.c:452 (discriminator 3)
c00033e4:	68 d0 8c 00 c0       	push   $0xc0008cd0
c00033e9:	68 6c 8f 00 c0       	push   $0xc0008f6c
c00033ee:	68 c4 01 00 00       	push   $0x1c4
c00033f3:	68 f3 8b 00 c0       	push   $0xc0008bf3
c00033f8:	e8 35 f2 ff ff       	call   c0002632 <panic_spin>
c00033fd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:453
	pg_phy_addr = addr_v2p(vaddr);
c0003400:	83 ec 0c             	sub    $0xc,%esp
c0003403:	ff 75 f4             	pushl  -0xc(%ebp)
c0003406:	e8 f5 fa ff ff       	call   c0002f00 <addr_v2p>
c000340b:	83 c4 10             	add    $0x10,%esp
c000340e:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:456

	/* 确保待释放的物理内存在低端1M+1k大小的页目录+1k大小的页表地址范围外【内核空间】 */
	ASSERT((pg_phy_addr % PG_SIZE) == 0 && pg_phy_addr >= 0x102000);
c0003411:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0003414:	25 ff 0f 00 00       	and    $0xfff,%eax
c0003419:	85 c0                	test   %eax,%eax
c000341b:	75 09                	jne    c0003426 <mfree_page+0x67>
/work/x86_os_my/kernel/memory.c:456 (discriminator 1)
c000341d:	81 7d ec ff 1f 10 00 	cmpl   $0x101fff,-0x14(%ebp)
c0003424:	77 1c                	ja     c0003442 <mfree_page+0x83>
/work/x86_os_my/kernel/memory.c:456 (discriminator 3)
c0003426:	68 f4 8c 00 c0       	push   $0xc0008cf4
c000342b:	68 6c 8f 00 c0       	push   $0xc0008f6c
c0003430:	68 c8 01 00 00       	push   $0x1c8
c0003435:	68 f3 8b 00 c0       	push   $0xc0008bf3
c000343a:	e8 f3 f1 ff ff       	call   c0002632 <panic_spin>
c000343f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:460

	/* 判断pg_phy_addr属于用户物理内存池还是内核物理内存池 */
	/* 位于user_pool内存池 */
	if (pg_phy_addr >= user_pool.phy_addr_start) {
c0003442:	a1 68 ca 00 c0       	mov    0xc000ca68,%eax
c0003447:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c000344a:	0f 87 94 00 00 00    	ja     c00034e4 <mfree_page+0x125>
/work/x86_os_my/kernel/memory.c:461
		vaddr -= PG_SIZE;
c0003450:	81 6d f4 00 10 00 00 	subl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:462
		while (page_cnt < pg_cnt) {
c0003457:	eb 6a                	jmp    c00034c3 <mfree_page+0x104>
/work/x86_os_my/kernel/memory.c:463
			vaddr += PG_SIZE;
c0003459:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:464
			pg_phy_addr = addr_v2p(vaddr);
c0003460:	83 ec 0c             	sub    $0xc,%esp
c0003463:	ff 75 f4             	pushl  -0xc(%ebp)
c0003466:	e8 95 fa ff ff       	call   c0002f00 <addr_v2p>
c000346b:	83 c4 10             	add    $0x10,%esp
c000346e:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:467

			/* 确保物理地址属于用户物理内存池 */
			ASSERT((pg_phy_addr % PG_SIZE) == 0 && pg_phy_addr >= user_pool.phy_addr_start);
c0003471:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0003474:	25 ff 0f 00 00       	and    $0xfff,%eax
c0003479:	85 c0                	test   %eax,%eax
c000347b:	75 0a                	jne    c0003487 <mfree_page+0xc8>
/work/x86_os_my/kernel/memory.c:467 (discriminator 1)
c000347d:	a1 68 ca 00 c0       	mov    0xc000ca68,%eax
c0003482:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0003485:	76 1c                	jbe    c00034a3 <mfree_page+0xe4>
/work/x86_os_my/kernel/memory.c:467 (discriminator 3)
c0003487:	68 2c 8d 00 c0       	push   $0xc0008d2c
c000348c:	68 6c 8f 00 c0       	push   $0xc0008f6c
c0003491:	68 d3 01 00 00       	push   $0x1d3
c0003496:	68 f3 8b 00 c0       	push   $0xc0008bf3
c000349b:	e8 92 f1 ff ff       	call   c0002632 <panic_spin>
c00034a0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:470

			/* 先将对应的物理页框归还到内存池 */
			pfree(pg_phy_addr);
c00034a3:	83 ec 0c             	sub    $0xc,%esp
c00034a6:	ff 75 ec             	pushl  -0x14(%ebp)
c00034a9:	e8 da fd ff ff       	call   c0003288 <pfree>
c00034ae:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:473

			/* 再从页表中清除此虚拟地址所在的页表项pte */
			page_table_pte_remove(vaddr);
c00034b1:	83 ec 0c             	sub    $0xc,%esp
c00034b4:	ff 75 f4             	pushl  -0xc(%ebp)
c00034b7:	e8 2e fe ff ff       	call   c00032ea <page_table_pte_remove>
c00034bc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:475

			page_cnt++;
c00034bf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:462

	/* 判断pg_phy_addr属于用户物理内存池还是内核物理内存池 */
	/* 位于user_pool内存池 */
	if (pg_phy_addr >= user_pool.phy_addr_start) {
		vaddr -= PG_SIZE;
		while (page_cnt < pg_cnt) {
c00034c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00034c6:	3b 45 10             	cmp    0x10(%ebp),%eax
c00034c9:	72 8e                	jb     c0003459 <mfree_page+0x9a>
/work/x86_os_my/kernel/memory.c:478
			page_table_pte_remove(vaddr);

			page_cnt++;
		}
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);
c00034cb:	83 ec 04             	sub    $0x4,%esp
c00034ce:	ff 75 10             	pushl  0x10(%ebp)
c00034d1:	ff 75 0c             	pushl  0xc(%ebp)
c00034d4:	ff 75 08             	pushl  0x8(%ebp)
c00034d7:	e8 39 fe ff ff       	call   c0003315 <vaddr_remove>
c00034dc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:502
			page_cnt++;
		}
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);
	}
}
c00034df:	e9 99 00 00 00       	jmp    c000357d <mfree_page+0x1be>
/work/x86_os_my/kernel/memory.c:482
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);

	} else {
		/* 位于kernel_pool内存池 */
		vaddr -= PG_SIZE;
c00034e4:	81 6d f4 00 10 00 00 	subl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:483
		while (page_cnt < pg_cnt) {
c00034eb:	eb 74                	jmp    c0003561 <mfree_page+0x1a2>
/work/x86_os_my/kernel/memory.c:484
			vaddr += PG_SIZE;
c00034ed:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:485
			pg_phy_addr = addr_v2p(vaddr);
c00034f4:	83 ec 0c             	sub    $0xc,%esp
c00034f7:	ff 75 f4             	pushl  -0xc(%ebp)
c00034fa:	e8 01 fa ff ff       	call   c0002f00 <addr_v2p>
c00034ff:	83 c4 10             	add    $0x10,%esp
c0003502:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:488

			/* 确保待释放的物理内存只属于内核物理内存池 */
			ASSERT((pg_phy_addr % PG_SIZE) == 0 && pg_phy_addr >= kernel_pool.phy_addr_start && \
c0003505:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0003508:	25 ff 0f 00 00       	and    $0xfff,%eax
c000350d:	85 c0                	test   %eax,%eax
c000350f:	75 14                	jne    c0003525 <mfree_page+0x166>
/work/x86_os_my/kernel/memory.c:488 (discriminator 1)
c0003511:	a1 68 cb 00 c0       	mov    0xc000cb68,%eax
c0003516:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0003519:	77 0a                	ja     c0003525 <mfree_page+0x166>
/work/x86_os_my/kernel/memory.c:488 (discriminator 3)
c000351b:	a1 68 ca 00 c0       	mov    0xc000ca68,%eax
c0003520:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0003523:	77 1c                	ja     c0003541 <mfree_page+0x182>
/work/x86_os_my/kernel/memory.c:488 (discriminator 5)
c0003525:	68 74 8d 00 c0       	push   $0xc0008d74
c000352a:	68 6c 8f 00 c0       	push   $0xc0008f6c
c000352f:	68 e9 01 00 00       	push   $0x1e9
c0003534:	68 f3 8b 00 c0       	push   $0xc0008bf3
c0003539:	e8 f4 f0 ff ff       	call   c0002632 <panic_spin>
c000353e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:492
					pg_phy_addr < user_pool.phy_addr_start);

			/* 先将对应的物理页框归还到内存池 */
			pfree(pg_phy_addr);
c0003541:	83 ec 0c             	sub    $0xc,%esp
c0003544:	ff 75 ec             	pushl  -0x14(%ebp)
c0003547:	e8 3c fd ff ff       	call   c0003288 <pfree>
c000354c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:495

			/* 再从页表中清除此虚拟地址所在的页表项pte */
			page_table_pte_remove(vaddr);
c000354f:	83 ec 0c             	sub    $0xc,%esp
c0003552:	ff 75 f4             	pushl  -0xc(%ebp)
c0003555:	e8 90 fd ff ff       	call   c00032ea <page_table_pte_remove>
c000355a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:497

			page_cnt++;
c000355d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:483
		vaddr_remove(pf, _vaddr, pg_cnt);

	} else {
		/* 位于kernel_pool内存池 */
		vaddr -= PG_SIZE;
		while (page_cnt < pg_cnt) {
c0003561:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003564:	3b 45 10             	cmp    0x10(%ebp),%eax
c0003567:	72 84                	jb     c00034ed <mfree_page+0x12e>
/work/x86_os_my/kernel/memory.c:500
			page_table_pte_remove(vaddr);

			page_cnt++;
		}
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);
c0003569:	83 ec 04             	sub    $0x4,%esp
c000356c:	ff 75 10             	pushl  0x10(%ebp)
c000356f:	ff 75 0c             	pushl  0xc(%ebp)
c0003572:	ff 75 08             	pushl  0x8(%ebp)
c0003575:	e8 9b fd ff ff       	call   c0003315 <vaddr_remove>
c000357a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:502
	}
}
c000357d:	90                   	nop
c000357e:	c9                   	leave  
c000357f:	c3                   	ret    

c0003580 <sys_free>:
sys_free():
/work/x86_os_my/kernel/memory.c:505

/* 回收内存ptr */
void sys_free(void* ptr) {
c0003580:	55                   	push   %ebp
c0003581:	89 e5                	mov    %esp,%ebp
c0003583:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:506
	ASSERT(ptr != NULL);
c0003586:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000358a:	75 1c                	jne    c00035a8 <sys_free+0x28>
/work/x86_os_my/kernel/memory.c:506 (discriminator 1)
c000358c:	68 e8 8d 00 c0       	push   $0xc0008de8
c0003591:	68 78 8f 00 c0       	push   $0xc0008f78
c0003596:	68 fa 01 00 00       	push   $0x1fa
c000359b:	68 f3 8b 00 c0       	push   $0xc0008bf3
c00035a0:	e8 8d f0 ff ff       	call   c0002632 <panic_spin>
c00035a5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:507
	if (ptr != NULL) {
c00035a8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00035ac:	0f 84 b2 01 00 00    	je     c0003764 <sys_free+0x1e4>
/work/x86_os_my/kernel/memory.c:512
		enum pool_flags PF;
		struct pool* mem_pool;

		/* 判断是线程还是进程 */
		if (running_thread()->pgdir == NULL) {
c00035b2:	e8 7a 08 00 00       	call   c0003e31 <running_thread>
c00035b7:	8b 40 54             	mov    0x54(%eax),%eax
c00035ba:	85 c0                	test   %eax,%eax
c00035bc:	75 36                	jne    c00035f4 <sys_free+0x74>
/work/x86_os_my/kernel/memory.c:513
			ASSERT((uint32_t)ptr >= K_HEAP_START);
c00035be:	8b 45 08             	mov    0x8(%ebp),%eax
c00035c1:	3d ff ff 0f c0       	cmp    $0xc00fffff,%eax
c00035c6:	77 1c                	ja     c00035e4 <sys_free+0x64>
/work/x86_os_my/kernel/memory.c:513 (discriminator 1)
c00035c8:	68 f4 8d 00 c0       	push   $0xc0008df4
c00035cd:	68 78 8f 00 c0       	push   $0xc0008f78
c00035d2:	68 01 02 00 00       	push   $0x201
c00035d7:	68 f3 8b 00 c0       	push   $0xc0008bf3
c00035dc:	e8 51 f0 ff ff       	call   c0002632 <panic_spin>
c00035e1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:514
			PF = PF_KERNEL;
c00035e4:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:515
			mem_pool = &kernel_pool;
c00035eb:	c7 45 f0 60 cb 00 c0 	movl   $0xc000cb60,-0x10(%ebp)
c00035f2:	eb 0e                	jmp    c0003602 <sys_free+0x82>
/work/x86_os_my/kernel/memory.c:517
		} else {
			PF = PF_USER;
c00035f4:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:518
			mem_pool = &user_pool;
c00035fb:	c7 45 f0 60 ca 00 c0 	movl   $0xc000ca60,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:521
		}

		lock_acquire(&mem_pool->lock);
c0003602:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003605:	83 c0 10             	add    $0x10,%eax
c0003608:	83 ec 0c             	sub    $0xc,%esp
c000360b:	50                   	push   %eax
c000360c:	e8 be 13 00 00       	call   c00049cf <lock_acquire>
c0003611:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:522
		struct mem_block* b = ptr;
c0003614:	8b 45 08             	mov    0x8(%ebp),%eax
c0003617:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:523
		struct arena* a = block2arena(b);			// 把mem_block转换成arena,获取元信息
c000361a:	83 ec 0c             	sub    $0xc,%esp
c000361d:	ff 75 e8             	pushl  -0x18(%ebp)
c0003620:	e8 21 f9 ff ff       	call   c0002f46 <block2arena>
c0003625:	83 c4 10             	add    $0x10,%esp
c0003628:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:524
		ASSERT(a->large == 0 || a->large == 1);
c000362b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000362e:	8b 40 08             	mov    0x8(%eax),%eax
c0003631:	85 c0                	test   %eax,%eax
c0003633:	74 27                	je     c000365c <sys_free+0xdc>
/work/x86_os_my/kernel/memory.c:524 (discriminator 1)
c0003635:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003638:	8b 40 08             	mov    0x8(%eax),%eax
c000363b:	83 f8 01             	cmp    $0x1,%eax
c000363e:	74 1c                	je     c000365c <sys_free+0xdc>
/work/x86_os_my/kernel/memory.c:524 (discriminator 2)
c0003640:	68 14 8e 00 c0       	push   $0xc0008e14
c0003645:	68 78 8f 00 c0       	push   $0xc0008f78
c000364a:	68 0c 02 00 00       	push   $0x20c
c000364f:	68 f3 8b 00 c0       	push   $0xc0008bf3
c0003654:	e8 d9 ef ff ff       	call   c0002632 <panic_spin>
c0003659:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:525
		if (a->desc == NULL && a->large == true) {	// 大于1024的内存
c000365c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000365f:	8b 00                	mov    (%eax),%eax
c0003661:	85 c0                	test   %eax,%eax
c0003663:	75 28                	jne    c000368d <sys_free+0x10d>
/work/x86_os_my/kernel/memory.c:525 (discriminator 1)
c0003665:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003668:	8b 40 08             	mov    0x8(%eax),%eax
c000366b:	83 f8 01             	cmp    $0x1,%eax
c000366e:	75 1d                	jne    c000368d <sys_free+0x10d>
/work/x86_os_my/kernel/memory.c:526
			mfree_page(PF, a, a->cnt);
c0003670:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003673:	8b 40 04             	mov    0x4(%eax),%eax
c0003676:	83 ec 04             	sub    $0x4,%esp
c0003679:	50                   	push   %eax
c000367a:	ff 75 e4             	pushl  -0x1c(%ebp)
c000367d:	ff 75 f4             	pushl  -0xc(%ebp)
c0003680:	e8 3a fd ff ff       	call   c00033bf <mfree_page>
c0003685:	83 c4 10             	add    $0x10,%esp
c0003688:	e9 c5 00 00 00       	jmp    c0003752 <sys_free+0x1d2>
/work/x86_os_my/kernel/memory.c:530
		} else {									// 小于等于1024的内存块
			/* 先将内存块回收到free_list */
			// &b->free_elem == &b
			list_append(&a->desc->free_list, &b->free_elem);
c000368d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0003690:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0003693:	8b 12                	mov    (%edx),%edx
c0003695:	83 c2 08             	add    $0x8,%edx
c0003698:	83 ec 08             	sub    $0x8,%esp
c000369b:	50                   	push   %eax
c000369c:	52                   	push   %edx
c000369d:	e8 f7 0e 00 00       	call   c0004599 <list_append>
c00036a2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:533

			/* 再判断此arena中的内存块是否都是空闲,如果是就释放arena */
			if (++a->cnt == a->desc->blocks_per_arena) {
c00036a5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00036a8:	8b 40 04             	mov    0x4(%eax),%eax
c00036ab:	8d 50 01             	lea    0x1(%eax),%edx
c00036ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00036b1:	89 50 04             	mov    %edx,0x4(%eax)
c00036b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00036b7:	8b 50 04             	mov    0x4(%eax),%edx
c00036ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00036bd:	8b 00                	mov    (%eax),%eax
c00036bf:	8b 40 04             	mov    0x4(%eax),%eax
c00036c2:	39 c2                	cmp    %eax,%edx
c00036c4:	0f 85 88 00 00 00    	jne    c0003752 <sys_free+0x1d2>
/work/x86_os_my/kernel/memory.c:535
				uint32_t block_idx;
				for (block_idx = 0; block_idx < a->desc->blocks_per_arena; block_idx++) {
c00036ca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c00036d1:	eb 5f                	jmp    c0003732 <sys_free+0x1b2>
/work/x86_os_my/kernel/memory.c:536
					struct mem_block*  b = arena2block(a, block_idx);
c00036d3:	83 ec 08             	sub    $0x8,%esp
c00036d6:	ff 75 ec             	pushl  -0x14(%ebp)
c00036d9:	ff 75 e4             	pushl  -0x1c(%ebp)
c00036dc:	e8 4b f8 ff ff       	call   c0002f2c <arena2block>
c00036e1:	83 c4 10             	add    $0x10,%esp
c00036e4:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/kernel/memory.c:537
					ASSERT(elem_find(&a->desc->free_list, &b->free_elem));
c00036e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00036ea:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00036ed:	8b 12                	mov    (%edx),%edx
c00036ef:	83 c2 08             	add    $0x8,%edx
c00036f2:	83 ec 08             	sub    $0x8,%esp
c00036f5:	50                   	push   %eax
c00036f6:	52                   	push   %edx
c00036f7:	e8 17 0f 00 00       	call   c0004613 <elem_find>
c00036fc:	83 c4 10             	add    $0x10,%esp
c00036ff:	85 c0                	test   %eax,%eax
c0003701:	75 1c                	jne    c000371f <sys_free+0x19f>
/work/x86_os_my/kernel/memory.c:537 (discriminator 1)
c0003703:	68 34 8e 00 c0       	push   $0xc0008e34
c0003708:	68 78 8f 00 c0       	push   $0xc0008f78
c000370d:	68 19 02 00 00       	push   $0x219
c0003712:	68 f3 8b 00 c0       	push   $0xc0008bf3
c0003717:	e8 16 ef ff ff       	call   c0002632 <panic_spin>
c000371c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:538 (discriminator 2)
					list_remove(&b->free_elem);
c000371f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0003722:	83 ec 0c             	sub    $0xc,%esp
c0003725:	50                   	push   %eax
c0003726:	e8 8c 0e 00 00       	call   c00045b7 <list_remove>
c000372b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:535 (discriminator 2)
			list_append(&a->desc->free_list, &b->free_elem);

			/* 再判断此arena中的内存块是否都是空闲,如果是就释放arena */
			if (++a->cnt == a->desc->blocks_per_arena) {
				uint32_t block_idx;
				for (block_idx = 0; block_idx < a->desc->blocks_per_arena; block_idx++) {
c000372e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:535 (discriminator 1)
c0003732:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003735:	8b 00                	mov    (%eax),%eax
c0003737:	8b 40 04             	mov    0x4(%eax),%eax
c000373a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c000373d:	77 94                	ja     c00036d3 <sys_free+0x153>
/work/x86_os_my/kernel/memory.c:540
					struct mem_block*  b = arena2block(a, block_idx);
					ASSERT(elem_find(&a->desc->free_list, &b->free_elem));
					list_remove(&b->free_elem);
				}
				mfree_page(PF, a, 1);
c000373f:	83 ec 04             	sub    $0x4,%esp
c0003742:	6a 01                	push   $0x1
c0003744:	ff 75 e4             	pushl  -0x1c(%ebp)
c0003747:	ff 75 f4             	pushl  -0xc(%ebp)
c000374a:	e8 70 fc ff ff       	call   c00033bf <mfree_page>
c000374f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:543
			}
		}
		lock_release(&mem_pool->lock);
c0003752:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003755:	83 c0 10             	add    $0x10,%eax
c0003758:	83 ec 0c             	sub    $0xc,%esp
c000375b:	50                   	push   %eax
c000375c:	e8 e5 12 00 00       	call   c0004a46 <lock_release>
c0003761:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:545
	}
}
c0003764:	90                   	nop
c0003765:	c9                   	leave  
c0003766:	c3                   	ret    

c0003767 <mem_pool_init>:
mem_pool_init():
/work/x86_os_my/kernel/memory.c:548

/* 初始化内存池 */
static void mem_pool_init(uint32_t all_mem) {
c0003767:	55                   	push   %ebp
c0003768:	89 e5                	mov    %esp,%ebp
c000376a:	83 ec 38             	sub    $0x38,%esp
/work/x86_os_my/kernel/memory.c:549
	put_str("   mem_pool_init start\n");
c000376d:	83 ec 0c             	sub    $0xc,%esp
c0003770:	68 62 8e 00 c0       	push   $0xc0008e62
c0003775:	e8 46 ed ff ff       	call   c00024c0 <put_str>
c000377a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:550
	uint32_t page_table_size = PG_SIZE * 256;		// 页表大小= 1页的页目录表+第0和第768个页目录项指向同一个页表+
c000377d:	c7 45 f4 00 00 10 00 	movl   $0x100000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:552
													// 第769~1022个页目录项共指向254个页表,共256个页框
	uint32_t used_mem = page_table_size + 0x100000;	// 0x100000为低端1M内存
c0003784:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003787:	05 00 00 10 00       	add    $0x100000,%eax
c000378c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:553
	uint32_t free_mem = all_mem - used_mem;
c000378f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003792:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0003795:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:554
	uint16_t all_free_pages = free_mem / PG_SIZE;	// 1页为4k,不管总内存是不是4k的倍数,
c0003798:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000379b:	c1 e8 0c             	shr    $0xc,%eax
c000379e:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
/work/x86_os_my/kernel/memory.c:556
													// 对于以页为单位的内存分配策略，不足1页的内存不用考虑了。
	uint16_t kernel_free_pages = all_free_pages / 2;
c00037a2:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c00037a6:	66 d1 e8             	shr    %ax
c00037a9:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:557
	uint16_t user_free_pages = all_free_pages - kernel_free_pages;
c00037ad:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c00037b1:	66 2b 45 e8          	sub    -0x18(%ebp),%ax
c00037b5:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
/work/x86_os_my/kernel/memory.c:561

	/* 为简化位图操作，余数不处理，坏处是这样做会丢内存。
	好处是不用做内存的越界检查,因为位图表示的内存少于实际物理内存*/
	uint32_t kbm_length = kernel_free_pages / 8;	// Kernel BitMap的长度,位图中的一位表示一页,以字节为单位
c00037b9:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c00037bd:	66 c1 e8 03          	shr    $0x3,%ax
c00037c1:	0f b7 c0             	movzwl %ax,%eax
c00037c4:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/kernel/memory.c:562
	uint32_t ubm_length = user_free_pages / 8;		// User BitMap的长度.
c00037c7:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c00037cb:	66 c1 e8 03          	shr    $0x3,%ax
c00037cf:	0f b7 c0             	movzwl %ax,%eax
c00037d2:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/kernel/memory.c:564

	uint32_t kp_start = used_mem;								// Kernel Pool start,内核内存池的起始地址
c00037d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00037d8:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/kernel/memory.c:565
	uint32_t up_start = kp_start + kernel_free_pages * PG_SIZE;	// User Pool start,用户内存池的起始地址
c00037db:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c00037df:	c1 e0 0c             	shl    $0xc,%eax
c00037e2:	89 c2                	mov    %eax,%edx
c00037e4:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00037e7:	01 d0                	add    %edx,%eax
c00037e9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:567

	kernel_pool.phy_addr_start = kp_start;
c00037ec:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00037ef:	a3 68 cb 00 c0       	mov    %eax,0xc000cb68
/work/x86_os_my/kernel/memory.c:568
	user_pool.phy_addr_start   = up_start;
c00037f4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00037f7:	a3 68 ca 00 c0       	mov    %eax,0xc000ca68
/work/x86_os_my/kernel/memory.c:570

	kernel_pool.pool_size = kernel_free_pages * PG_SIZE;
c00037fc:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0003800:	c1 e0 0c             	shl    $0xc,%eax
c0003803:	a3 6c cb 00 c0       	mov    %eax,0xc000cb6c
/work/x86_os_my/kernel/memory.c:571
	user_pool.pool_size	 = user_free_pages * PG_SIZE;
c0003808:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c000380c:	c1 e0 0c             	shl    $0xc,%eax
c000380f:	a3 6c ca 00 c0       	mov    %eax,0xc000ca6c
/work/x86_os_my/kernel/memory.c:573

	kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;
c0003814:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0003817:	a3 60 cb 00 c0       	mov    %eax,0xc000cb60
/work/x86_os_my/kernel/memory.c:574
	user_pool.pool_bitmap.btmp_bytes_len	  = ubm_length;
c000381c:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000381f:	a3 60 ca 00 c0       	mov    %eax,0xc000ca60
/work/x86_os_my/kernel/memory.c:583
	*	而我们需要根据总内存大小在运行时，计算出位图的数组需要多少字节。
	*   所以改为指定一块内存来生成位图.
	*   ************************************************/
	// 内核使用的最高地址是0xc009f000,这是主线程的栈地址.(内核的大小预计为70K左右)
	// 32M内存占用的位图是2k.内核内存池的位图先定在MEM_BITMAP_BASE(0xc009a000)处.
	kernel_pool.pool_bitmap.bits = (void*)MEM_BITMAP_BASE;
c0003824:	c7 05 64 cb 00 c0 00 	movl   $0xc009a000,0xc000cb64
c000382b:	a0 09 c0 
/work/x86_os_my/kernel/memory.c:585
	/* 用户内存池的位图紧跟在内核内存池位图之后 */
	user_pool.pool_bitmap.bits = (void*)(MEM_BITMAP_BASE + kbm_length);
c000382e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0003831:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c0003836:	a3 64 ca 00 c0       	mov    %eax,0xc000ca64
/work/x86_os_my/kernel/memory.c:588
	
	/******************** 输出内存池信息 **********************/
	put_str("      kernel_pool_bitmap_start:");put_int((int)kernel_pool.pool_bitmap.bits);
c000383b:	83 ec 0c             	sub    $0xc,%esp
c000383e:	68 7c 8e 00 c0       	push   $0xc0008e7c
c0003843:	e8 78 ec ff ff       	call   c00024c0 <put_str>
c0003848:	83 c4 10             	add    $0x10,%esp
c000384b:	a1 64 cb 00 c0       	mov    0xc000cb64,%eax
c0003850:	83 ec 0c             	sub    $0xc,%esp
c0003853:	50                   	push   %eax
c0003854:	e8 52 ed ff ff       	call   c00025ab <put_int>
c0003859:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:589
	put_str(" kernel_pool_phy_addr_start:");put_int(kernel_pool.phy_addr_start);
c000385c:	83 ec 0c             	sub    $0xc,%esp
c000385f:	68 9c 8e 00 c0       	push   $0xc0008e9c
c0003864:	e8 57 ec ff ff       	call   c00024c0 <put_str>
c0003869:	83 c4 10             	add    $0x10,%esp
c000386c:	a1 68 cb 00 c0       	mov    0xc000cb68,%eax
c0003871:	83 ec 0c             	sub    $0xc,%esp
c0003874:	50                   	push   %eax
c0003875:	e8 31 ed ff ff       	call   c00025ab <put_int>
c000387a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:590
	put_str("\n");
c000387d:	83 ec 0c             	sub    $0xc,%esp
c0003880:	68 b9 8e 00 c0       	push   $0xc0008eb9
c0003885:	e8 36 ec ff ff       	call   c00024c0 <put_str>
c000388a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:591
	put_str("      user_pool_bitmap_start:");put_int((int)user_pool.pool_bitmap.bits);
c000388d:	83 ec 0c             	sub    $0xc,%esp
c0003890:	68 bb 8e 00 c0       	push   $0xc0008ebb
c0003895:	e8 26 ec ff ff       	call   c00024c0 <put_str>
c000389a:	83 c4 10             	add    $0x10,%esp
c000389d:	a1 64 ca 00 c0       	mov    0xc000ca64,%eax
c00038a2:	83 ec 0c             	sub    $0xc,%esp
c00038a5:	50                   	push   %eax
c00038a6:	e8 00 ed ff ff       	call   c00025ab <put_int>
c00038ab:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:592
	put_str(" user_pool_phy_addr_start:");put_int(user_pool.phy_addr_start);
c00038ae:	83 ec 0c             	sub    $0xc,%esp
c00038b1:	68 d9 8e 00 c0       	push   $0xc0008ed9
c00038b6:	e8 05 ec ff ff       	call   c00024c0 <put_str>
c00038bb:	83 c4 10             	add    $0x10,%esp
c00038be:	a1 68 ca 00 c0       	mov    0xc000ca68,%eax
c00038c3:	83 ec 0c             	sub    $0xc,%esp
c00038c6:	50                   	push   %eax
c00038c7:	e8 df ec ff ff       	call   c00025ab <put_int>
c00038cc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:593
	put_str("\n");
c00038cf:	83 ec 0c             	sub    $0xc,%esp
c00038d2:	68 b9 8e 00 c0       	push   $0xc0008eb9
c00038d7:	e8 e4 eb ff ff       	call   c00024c0 <put_str>
c00038dc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:596

	/* 将位图置0*/
	bitmap_init(&kernel_pool.pool_bitmap);
c00038df:	83 ec 0c             	sub    $0xc,%esp
c00038e2:	68 60 cb 00 c0       	push   $0xc000cb60
c00038e7:	e8 1c ee ff ff       	call   c0002708 <bitmap_init>
c00038ec:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:597
	bitmap_init(&user_pool.pool_bitmap);
c00038ef:	83 ec 0c             	sub    $0xc,%esp
c00038f2:	68 60 ca 00 c0       	push   $0xc000ca60
c00038f7:	e8 0c ee ff ff       	call   c0002708 <bitmap_init>
c00038fc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:599

	lock_init(&kernel_pool.lock);
c00038ff:	83 ec 0c             	sub    $0xc,%esp
c0003902:	68 70 cb 00 c0       	push   $0xc000cb70
c0003907:	e8 e9 0e 00 00       	call   c00047f5 <lock_init>
c000390c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:600
	lock_init(&user_pool.lock);
c000390f:	83 ec 0c             	sub    $0xc,%esp
c0003912:	68 70 ca 00 c0       	push   $0xc000ca70
c0003917:	e8 d9 0e 00 00       	call   c00047f5 <lock_init>
c000391c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:604
	
	/* 下面初始化内核虚拟地址的位图(bp_len + bits数组),按实际物理内存大小生成数组。*/
	// 用于维护内核堆的虚拟地址,所以要和内核内存池大小一致
	kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;
c000391f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0003922:	a3 48 cb 00 c0       	mov    %eax,0xc000cb48
/work/x86_os_my/kernel/memory.c:606
	/* 位图的数组指向一块未使用的内存,目前定位在内核内存池和用户内存池之外*/
	kernel_vaddr.vaddr_bitmap.bits = (void*)(MEM_BITMAP_BASE + kbm_length + ubm_length);
c0003927:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000392a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000392d:	01 d0                	add    %edx,%eax
c000392f:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c0003934:	a3 4c cb 00 c0       	mov    %eax,0xc000cb4c
/work/x86_os_my/kernel/memory.c:608

	kernel_vaddr.vaddr_start = K_HEAP_START;
c0003939:	c7 05 50 cb 00 c0 00 	movl   $0xc0100000,0xc000cb50
c0003940:	00 10 c0 
/work/x86_os_my/kernel/memory.c:609
	bitmap_init(&kernel_vaddr.vaddr_bitmap);
c0003943:	83 ec 0c             	sub    $0xc,%esp
c0003946:	68 48 cb 00 c0       	push   $0xc000cb48
c000394b:	e8 b8 ed ff ff       	call   c0002708 <bitmap_init>
c0003950:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:610
	put_str("   mem_pool_init done\n");
c0003953:	83 ec 0c             	sub    $0xc,%esp
c0003956:	68 f4 8e 00 c0       	push   $0xc0008ef4
c000395b:	e8 60 eb ff ff       	call   c00024c0 <put_str>
c0003960:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:611
}
c0003963:	90                   	nop
c0003964:	c9                   	leave  
c0003965:	c3                   	ret    

c0003966 <block_desc_init>:
block_desc_init():
/work/x86_os_my/kernel/memory.c:614

/* 为malloc做准备 */
void block_desc_init(struct mem_block_desc* desc_array) {
c0003966:	55                   	push   %ebp
c0003967:	89 e5                	mov    %esp,%ebp
c0003969:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:615
   uint16_t desc_idx, block_size = 16;
c000396c:	66 c7 45 f4 10 00    	movw   $0x10,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:618

   /* 初始化每个mem_block_desc描述符 */
   for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c0003972:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
c0003978:	eb 75                	jmp    c00039ef <block_desc_init+0x89>
/work/x86_os_my/kernel/memory.c:619 (discriminator 3)
      desc_array[desc_idx].block_size = block_size;
c000397a:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c000397e:	89 d0                	mov    %edx,%eax
c0003980:	01 c0                	add    %eax,%eax
c0003982:	01 d0                	add    %edx,%eax
c0003984:	c1 e0 03             	shl    $0x3,%eax
c0003987:	89 c2                	mov    %eax,%edx
c0003989:	8b 45 08             	mov    0x8(%ebp),%eax
c000398c:	01 c2                	add    %eax,%edx
c000398e:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c0003992:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/kernel/memory.c:622 (discriminator 3)

      /* 初始化arena中的内存块数量【注意计算方法】 */
      desc_array[desc_idx].blocks_per_arena = (PG_SIZE - sizeof(struct arena)) / block_size;
c0003994:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c0003998:	89 d0                	mov    %edx,%eax
c000399a:	01 c0                	add    %eax,%eax
c000399c:	01 d0                	add    %edx,%eax
c000399e:	c1 e0 03             	shl    $0x3,%eax
c00039a1:	89 c2                	mov    %eax,%edx
c00039a3:	8b 45 08             	mov    0x8(%ebp),%eax
c00039a6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c00039a9:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c00039ae:	ba 00 00 00 00       	mov    $0x0,%edx
c00039b3:	66 f7 75 f4          	divw   -0xc(%ebp)
c00039b7:	0f b7 c0             	movzwl %ax,%eax
c00039ba:	89 41 04             	mov    %eax,0x4(%ecx)
/work/x86_os_my/kernel/memory.c:624 (discriminator 3)

      list_init(&desc_array[desc_idx].free_list);
c00039bd:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c00039c1:	89 d0                	mov    %edx,%eax
c00039c3:	01 c0                	add    %eax,%eax
c00039c5:	01 d0                	add    %edx,%eax
c00039c7:	c1 e0 03             	shl    $0x3,%eax
c00039ca:	89 c2                	mov    %eax,%edx
c00039cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00039cf:	01 d0                	add    %edx,%eax
c00039d1:	83 c0 08             	add    $0x8,%eax
c00039d4:	83 ec 0c             	sub    $0xc,%esp
c00039d7:	50                   	push   %eax
c00039d8:	e8 2b 0b 00 00       	call   c0004508 <list_init>
c00039dd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:626 (discriminator 3)

      block_size *= 2;		// 下一个规格内存块！
c00039e0:	66 d1 65 f4          	shlw   -0xc(%ebp)
/work/x86_os_my/kernel/memory.c:618 (discriminator 3)
/* 为malloc做准备 */
void block_desc_init(struct mem_block_desc* desc_array) {
   uint16_t desc_idx, block_size = 16;

   /* 初始化每个mem_block_desc描述符 */
   for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c00039e4:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c00039e8:	83 c0 01             	add    $0x1,%eax
c00039eb:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/kernel/memory.c:618 (discriminator 1)
c00039ef:	66 83 7d f6 06       	cmpw   $0x6,-0xa(%ebp)
c00039f4:	76 84                	jbe    c000397a <block_desc_init+0x14>
/work/x86_os_my/kernel/memory.c:629
      list_init(&desc_array[desc_idx].free_list);

      block_size *= 2;		// 下一个规格内存块！
	  // 16/32/64/128/256/512/1024 总共 7 种规格
   }
}
c00039f6:	90                   	nop
c00039f7:	c9                   	leave  
c00039f8:	c3                   	ret    

c00039f9 <mem_init>:
mem_init():
/work/x86_os_my/kernel/memory.c:632

/* 内存管理部分初始化入口 */
void mem_init() {
c00039f9:	55                   	push   %ebp
c00039fa:	89 e5                	mov    %esp,%ebp
c00039fc:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:633
	put_str("mem_init start\n");
c00039ff:	83 ec 0c             	sub    $0xc,%esp
c0003a02:	68 0b 8f 00 c0       	push   $0xc0008f0b
c0003a07:	e8 b4 ea ff ff       	call   c00024c0 <put_str>
c0003a0c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:634
	uint32_t mem_bytes_total = (*(uint32_t*)(0xb00));	//内存总数在汇编中获取，放到了地址0xb00处。
c0003a0f:	b8 00 0b 00 00       	mov    $0xb00,%eax
c0003a14:	8b 00                	mov    (%eax),%eax
c0003a16:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:635
	mem_pool_init(mem_bytes_total);	// 初始化内存池
c0003a19:	83 ec 0c             	sub    $0xc,%esp
c0003a1c:	ff 75 f4             	pushl  -0xc(%ebp)
c0003a1f:	e8 43 fd ff ff       	call   c0003767 <mem_pool_init>
c0003a24:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:636
	block_desc_init(k_block_descs);	// 初始化mem_block_desc数组descs,为malloc做准备
c0003a27:	83 ec 0c             	sub    $0xc,%esp
c0003a2a:	68 a0 ca 00 c0       	push   $0xc000caa0
c0003a2f:	e8 32 ff ff ff       	call   c0003966 <block_desc_init>
c0003a34:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:637
	put_str("mem_init done\n");
c0003a37:	83 ec 0c             	sub    $0xc,%esp
c0003a3a:	68 1b 8f 00 c0       	push   $0xc0008f1b
c0003a3f:	e8 7c ea ff ff       	call   c00024c0 <put_str>
c0003a44:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:638
}
c0003a47:	90                   	nop
c0003a48:	c9                   	leave  
c0003a49:	c3                   	ret    

c0003a4a <memset>:
memset():
/work/x86_os_my/lib/string.c:6
#include "string.h"
#include "global.h"
#include "debug.h"

/* 将dst_起始的size个字节置为value */
void memset(void* dst_, uint8_t value, uint32_t size) {
c0003a4a:	55                   	push   %ebp
c0003a4b:	89 e5                	mov    %esp,%ebp
c0003a4d:	83 ec 28             	sub    $0x28,%esp
c0003a50:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003a53:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:7
   ASSERT(dst_ != NULL);
c0003a56:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003a5a:	75 19                	jne    c0003a75 <memset+0x2b>
/work/x86_os_my/lib/string.c:7 (discriminator 1)
c0003a5c:	68 84 8f 00 c0       	push   $0xc0008f84
c0003a61:	68 f8 8f 00 c0       	push   $0xc0008ff8
c0003a66:	6a 07                	push   $0x7
c0003a68:	68 91 8f 00 c0       	push   $0xc0008f91
c0003a6d:	e8 c0 eb ff ff       	call   c0002632 <panic_spin>
c0003a72:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:8
   uint8_t* dst = (uint8_t*)dst_;
c0003a75:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a78:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:9
   while (size-- > 0)
c0003a7b:	eb 0f                	jmp    c0003a8c <memset+0x42>
/work/x86_os_my/lib/string.c:10
      *dst++ = value;
c0003a7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003a80:	8d 50 01             	lea    0x1(%eax),%edx
c0003a83:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003a86:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c0003a8a:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/string.c:9

/* 将dst_起始的size个字节置为value */
void memset(void* dst_, uint8_t value, uint32_t size) {
   ASSERT(dst_ != NULL);
   uint8_t* dst = (uint8_t*)dst_;
   while (size-- > 0)
c0003a8c:	8b 45 10             	mov    0x10(%ebp),%eax
c0003a8f:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003a92:	89 55 10             	mov    %edx,0x10(%ebp)
c0003a95:	85 c0                	test   %eax,%eax
c0003a97:	75 e4                	jne    c0003a7d <memset+0x33>
/work/x86_os_my/lib/string.c:11
      *dst++ = value;
}
c0003a99:	90                   	nop
c0003a9a:	c9                   	leave  
c0003a9b:	c3                   	ret    

c0003a9c <memcpy>:
memcpy():
/work/x86_os_my/lib/string.c:14

/* 将src_起始的size个字节复制到dst_ */
void memcpy(void* dst_, const void* src_, uint32_t size) {
c0003a9c:	55                   	push   %ebp
c0003a9d:	89 e5                	mov    %esp,%ebp
c0003a9f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:15
   ASSERT(dst_ != NULL && src_ != NULL);
c0003aa2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003aa6:	74 06                	je     c0003aae <memcpy+0x12>
/work/x86_os_my/lib/string.c:15 (discriminator 1)
c0003aa8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0003aac:	75 19                	jne    c0003ac7 <memcpy+0x2b>
/work/x86_os_my/lib/string.c:15 (discriminator 3)
c0003aae:	68 9e 8f 00 c0       	push   $0xc0008f9e
c0003ab3:	68 00 90 00 c0       	push   $0xc0009000
c0003ab8:	6a 0f                	push   $0xf
c0003aba:	68 91 8f 00 c0       	push   $0xc0008f91
c0003abf:	e8 6e eb ff ff       	call   c0002632 <panic_spin>
c0003ac4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:16
   uint8_t* dst = dst_;
c0003ac7:	8b 45 08             	mov    0x8(%ebp),%eax
c0003aca:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:17
   const uint8_t* src = src_;
c0003acd:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003ad0:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:18
   while (size-- > 0)
c0003ad3:	eb 17                	jmp    c0003aec <memcpy+0x50>
/work/x86_os_my/lib/string.c:19
      *dst++ = *src++;
c0003ad5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003ad8:	8d 50 01             	lea    0x1(%eax),%edx
c0003adb:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003ade:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0003ae1:	8d 4a 01             	lea    0x1(%edx),%ecx
c0003ae4:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0003ae7:	0f b6 12             	movzbl (%edx),%edx
c0003aea:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/string.c:18
/* 将src_起始的size个字节复制到dst_ */
void memcpy(void* dst_, const void* src_, uint32_t size) {
   ASSERT(dst_ != NULL && src_ != NULL);
   uint8_t* dst = dst_;
   const uint8_t* src = src_;
   while (size-- > 0)
c0003aec:	8b 45 10             	mov    0x10(%ebp),%eax
c0003aef:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003af2:	89 55 10             	mov    %edx,0x10(%ebp)
c0003af5:	85 c0                	test   %eax,%eax
c0003af7:	75 dc                	jne    c0003ad5 <memcpy+0x39>
/work/x86_os_my/lib/string.c:20
      *dst++ = *src++;
}
c0003af9:	90                   	nop
c0003afa:	c9                   	leave  
c0003afb:	c3                   	ret    

c0003afc <memcmp>:
memcmp():
/work/x86_os_my/lib/string.c:23

/* 连续比较以地址a_和地址b_开头的size个字节,若相等则返回0,若a_大于b_返回+1,否则返回-1 */
int memcmp(const void* a_, const void* b_, uint32_t size) {
c0003afc:	55                   	push   %ebp
c0003afd:	89 e5                	mov    %esp,%ebp
c0003aff:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:24
   const char* a = a_;
c0003b02:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b05:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:25
   const char* b = b_;
c0003b08:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003b0b:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:26
   ASSERT(a != NULL || b != NULL);
c0003b0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0003b12:	75 57                	jne    c0003b6b <memcmp+0x6f>
/work/x86_os_my/lib/string.c:26 (discriminator 1)
c0003b14:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0003b18:	75 51                	jne    c0003b6b <memcmp+0x6f>
/work/x86_os_my/lib/string.c:26 (discriminator 2)
c0003b1a:	68 bb 8f 00 c0       	push   $0xc0008fbb
c0003b1f:	68 08 90 00 c0       	push   $0xc0009008
c0003b24:	6a 1a                	push   $0x1a
c0003b26:	68 91 8f 00 c0       	push   $0xc0008f91
c0003b2b:	e8 02 eb ff ff       	call   c0002632 <panic_spin>
c0003b30:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:27 (discriminator 2)
   while (size-- > 0) {
c0003b33:	eb 36                	jmp    c0003b6b <memcmp+0x6f>
/work/x86_os_my/lib/string.c:28
      if(*a != *b) {
c0003b35:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003b38:	0f b6 10             	movzbl (%eax),%edx
c0003b3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003b3e:	0f b6 00             	movzbl (%eax),%eax
c0003b41:	38 c2                	cmp    %al,%dl
c0003b43:	74 1e                	je     c0003b63 <memcmp+0x67>
/work/x86_os_my/lib/string.c:29
	 return *a > *b ? 1 : -1; 
c0003b45:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003b48:	0f b6 10             	movzbl (%eax),%edx
c0003b4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003b4e:	0f b6 00             	movzbl (%eax),%eax
c0003b51:	38 c2                	cmp    %al,%dl
c0003b53:	7e 07                	jle    c0003b5c <memcmp+0x60>
/work/x86_os_my/lib/string.c:29 (discriminator 1)
c0003b55:	b8 01 00 00 00       	mov    $0x1,%eax
c0003b5a:	eb 21                	jmp    c0003b7d <memcmp+0x81>
/work/x86_os_my/lib/string.c:29 (discriminator 2)
c0003b5c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003b61:	eb 1a                	jmp    c0003b7d <memcmp+0x81>
/work/x86_os_my/lib/string.c:31
      }
      a++;
c0003b63:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:32
      b++;
c0003b67:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/string.c:27
/* 连续比较以地址a_和地址b_开头的size个字节,若相等则返回0,若a_大于b_返回+1,否则返回-1 */
int memcmp(const void* a_, const void* b_, uint32_t size) {
   const char* a = a_;
   const char* b = b_;
   ASSERT(a != NULL || b != NULL);
   while (size-- > 0) {
c0003b6b:	8b 45 10             	mov    0x10(%ebp),%eax
c0003b6e:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003b71:	89 55 10             	mov    %edx,0x10(%ebp)
c0003b74:	85 c0                	test   %eax,%eax
c0003b76:	75 bd                	jne    c0003b35 <memcmp+0x39>
/work/x86_os_my/lib/string.c:34
	 return *a > *b ? 1 : -1; 
      }
      a++;
      b++;
   }
   return 0;
c0003b78:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/string.c:35
}
c0003b7d:	c9                   	leave  
c0003b7e:	c3                   	ret    

c0003b7f <strcpy>:
strcpy():
/work/x86_os_my/lib/string.c:38

/* 将字符串从src_复制到dst_ */
char* strcpy(char* dst_, const char* src_) {
c0003b7f:	55                   	push   %ebp
c0003b80:	89 e5                	mov    %esp,%ebp
c0003b82:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:39
   ASSERT(dst_ != NULL && src_ != NULL);
c0003b85:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003b89:	74 06                	je     c0003b91 <strcpy+0x12>
/work/x86_os_my/lib/string.c:39 (discriminator 1)
c0003b8b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0003b8f:	75 19                	jne    c0003baa <strcpy+0x2b>
/work/x86_os_my/lib/string.c:39 (discriminator 3)
c0003b91:	68 9e 8f 00 c0       	push   $0xc0008f9e
c0003b96:	68 10 90 00 c0       	push   $0xc0009010
c0003b9b:	6a 27                	push   $0x27
c0003b9d:	68 91 8f 00 c0       	push   $0xc0008f91
c0003ba2:	e8 8b ea ff ff       	call   c0002632 <panic_spin>
c0003ba7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:40
   char* r = dst_;		       // 用来返回目的字符串起始地址
c0003baa:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bad:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:41
   while((*dst_++ = *src_++));
c0003bb0:	90                   	nop
/work/x86_os_my/lib/string.c:41 (discriminator 1)
c0003bb1:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bb4:	8d 50 01             	lea    0x1(%eax),%edx
c0003bb7:	89 55 08             	mov    %edx,0x8(%ebp)
c0003bba:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003bbd:	8d 4a 01             	lea    0x1(%edx),%ecx
c0003bc0:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c0003bc3:	0f b6 12             	movzbl (%edx),%edx
c0003bc6:	88 10                	mov    %dl,(%eax)
c0003bc8:	0f b6 00             	movzbl (%eax),%eax
c0003bcb:	84 c0                	test   %al,%al
c0003bcd:	75 e2                	jne    c0003bb1 <strcpy+0x32>
/work/x86_os_my/lib/string.c:42
   return r;
c0003bcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:43
}
c0003bd2:	c9                   	leave  
c0003bd3:	c3                   	ret    

c0003bd4 <strlen>:
strlen():
/work/x86_os_my/lib/string.c:46

/* 返回字符串长度 */
uint32_t strlen(const char* str) {
c0003bd4:	55                   	push   %ebp
c0003bd5:	89 e5                	mov    %esp,%ebp
c0003bd7:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:47
   ASSERT(str != NULL);
c0003bda:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003bde:	75 19                	jne    c0003bf9 <strlen+0x25>
/work/x86_os_my/lib/string.c:47 (discriminator 1)
c0003be0:	68 d2 8f 00 c0       	push   $0xc0008fd2
c0003be5:	68 18 90 00 c0       	push   $0xc0009018
c0003bea:	6a 2f                	push   $0x2f
c0003bec:	68 91 8f 00 c0       	push   $0xc0008f91
c0003bf1:	e8 3c ea ff ff       	call   c0002632 <panic_spin>
c0003bf6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:48
   const char* p = str;
c0003bf9:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bfc:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:49
   while(*p++);
c0003bff:	90                   	nop
/work/x86_os_my/lib/string.c:49 (discriminator 1)
c0003c00:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003c03:	8d 50 01             	lea    0x1(%eax),%edx
c0003c06:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003c09:	0f b6 00             	movzbl (%eax),%eax
c0003c0c:	84 c0                	test   %al,%al
c0003c0e:	75 f0                	jne    c0003c00 <strlen+0x2c>
/work/x86_os_my/lib/string.c:50
   return (p - str - 1);
c0003c10:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0003c13:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c16:	29 c2                	sub    %eax,%edx
c0003c18:	89 d0                	mov    %edx,%eax
c0003c1a:	83 e8 01             	sub    $0x1,%eax
/work/x86_os_my/lib/string.c:51
}
c0003c1d:	c9                   	leave  
c0003c1e:	c3                   	ret    

c0003c1f <strcmp>:
strcmp():
/work/x86_os_my/lib/string.c:54

/* 比较两个字符串,若a_中的字符大于b_中的字符返回1,相等时返回0,否则返回-1. */
int8_t strcmp (const char* a, const char* b) {
c0003c1f:	55                   	push   %ebp
c0003c20:	89 e5                	mov    %esp,%ebp
c0003c22:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/string.c:55
   ASSERT(a != NULL && b != NULL);
c0003c25:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003c29:	74 06                	je     c0003c31 <strcmp+0x12>
/work/x86_os_my/lib/string.c:55 (discriminator 1)
c0003c2b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0003c2f:	75 19                	jne    c0003c4a <strcmp+0x2b>
/work/x86_os_my/lib/string.c:55 (discriminator 3)
c0003c31:	68 de 8f 00 c0       	push   $0xc0008fde
c0003c36:	68 20 90 00 c0       	push   $0xc0009020
c0003c3b:	6a 37                	push   $0x37
c0003c3d:	68 91 8f 00 c0       	push   $0xc0008f91
c0003c42:	e8 eb e9 ff ff       	call   c0002632 <panic_spin>
c0003c47:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:56 (discriminator 1)
   while (*a != 0 && *a == *b) {
c0003c4a:	eb 08                	jmp    c0003c54 <strcmp+0x35>
/work/x86_os_my/lib/string.c:57
      a++;
c0003c4c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:58
      b++;
c0003c50:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
/work/x86_os_my/lib/string.c:56
}

/* 比较两个字符串,若a_中的字符大于b_中的字符返回1,相等时返回0,否则返回-1. */
int8_t strcmp (const char* a, const char* b) {
   ASSERT(a != NULL && b != NULL);
   while (*a != 0 && *a == *b) {
c0003c54:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c57:	0f b6 00             	movzbl (%eax),%eax
c0003c5a:	84 c0                	test   %al,%al
c0003c5c:	74 10                	je     c0003c6e <strcmp+0x4f>
/work/x86_os_my/lib/string.c:56 (discriminator 1)
c0003c5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c61:	0f b6 10             	movzbl (%eax),%edx
c0003c64:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003c67:	0f b6 00             	movzbl (%eax),%eax
c0003c6a:	38 c2                	cmp    %al,%dl
c0003c6c:	74 de                	je     c0003c4c <strcmp+0x2d>
/work/x86_os_my/lib/string.c:62
      a++;
      b++;
   }
/* 如果*a小于*b就返回-1,否则就属于*a大于等于*b的情况。在后面的布尔表达式"*a > *b"中,
 * 若*a大于*b,表达式就等于1,否则就表达式不成立,也就是布尔值为0,恰恰表示*a等于*b */
   return *a < *b ? -1 : *a > *b;
c0003c6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c71:	0f b6 10             	movzbl (%eax),%edx
c0003c74:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003c77:	0f b6 00             	movzbl (%eax),%eax
c0003c7a:	38 c2                	cmp    %al,%dl
c0003c7c:	7c 13                	jl     c0003c91 <strcmp+0x72>
/work/x86_os_my/lib/string.c:62 (discriminator 1)
c0003c7e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c81:	0f b6 10             	movzbl (%eax),%edx
c0003c84:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003c87:	0f b6 00             	movzbl (%eax),%eax
c0003c8a:	38 c2                	cmp    %al,%dl
c0003c8c:	0f 9f c0             	setg   %al
c0003c8f:	eb 05                	jmp    c0003c96 <strcmp+0x77>
/work/x86_os_my/lib/string.c:62 (discriminator 2)
c0003c91:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/lib/string.c:63 (discriminator 5)
}
c0003c96:	c9                   	leave  
c0003c97:	c3                   	ret    

c0003c98 <strchr>:
strchr():
/work/x86_os_my/lib/string.c:66

/* 从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strchr(const char* str, const uint8_t ch) {
c0003c98:	55                   	push   %ebp
c0003c99:	89 e5                	mov    %esp,%ebp
c0003c9b:	83 ec 18             	sub    $0x18,%esp
c0003c9e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003ca1:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/lib/string.c:67
   ASSERT(str != NULL);
c0003ca4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003ca8:	75 35                	jne    c0003cdf <strchr+0x47>
/work/x86_os_my/lib/string.c:67 (discriminator 1)
c0003caa:	68 d2 8f 00 c0       	push   $0xc0008fd2
c0003caf:	68 28 90 00 c0       	push   $0xc0009028
c0003cb4:	6a 43                	push   $0x43
c0003cb6:	68 91 8f 00 c0       	push   $0xc0008f91
c0003cbb:	e8 72 e9 ff ff       	call   c0002632 <panic_spin>
c0003cc0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:68 (discriminator 1)
   while (*str != 0) {
c0003cc3:	eb 1a                	jmp    c0003cdf <strchr+0x47>
/work/x86_os_my/lib/string.c:69
      if (*str == ch) {
c0003cc5:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cc8:	0f b6 00             	movzbl (%eax),%eax
c0003ccb:	0f be d0             	movsbl %al,%edx
c0003cce:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0003cd2:	39 c2                	cmp    %eax,%edx
c0003cd4:	75 05                	jne    c0003cdb <strchr+0x43>
/work/x86_os_my/lib/string.c:70
	 return (char*)str;	    // 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.
c0003cd6:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cd9:	eb 13                	jmp    c0003cee <strchr+0x56>
/work/x86_os_my/lib/string.c:72
      }
      str++;
c0003cdb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:68
}

/* 从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strchr(const char* str, const uint8_t ch) {
   ASSERT(str != NULL);
   while (*str != 0) {
c0003cdf:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ce2:	0f b6 00             	movzbl (%eax),%eax
c0003ce5:	84 c0                	test   %al,%al
c0003ce7:	75 dc                	jne    c0003cc5 <strchr+0x2d>
/work/x86_os_my/lib/string.c:74
      if (*str == ch) {
	 return (char*)str;	    // 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.
      }
      str++;
   }
   return NULL;
c0003ce9:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/string.c:75
}
c0003cee:	c9                   	leave  
c0003cef:	c3                   	ret    

c0003cf0 <strrchr>:
strrchr():
/work/x86_os_my/lib/string.c:78

/* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strrchr(const char* str, const uint8_t ch) {
c0003cf0:	55                   	push   %ebp
c0003cf1:	89 e5                	mov    %esp,%ebp
c0003cf3:	83 ec 28             	sub    $0x28,%esp
c0003cf6:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003cf9:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:79
   ASSERT(str != NULL);
c0003cfc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003d00:	75 19                	jne    c0003d1b <strrchr+0x2b>
/work/x86_os_my/lib/string.c:79 (discriminator 1)
c0003d02:	68 d2 8f 00 c0       	push   $0xc0008fd2
c0003d07:	68 30 90 00 c0       	push   $0xc0009030
c0003d0c:	6a 4f                	push   $0x4f
c0003d0e:	68 91 8f 00 c0       	push   $0xc0008f91
c0003d13:	e8 1a e9 ff ff       	call   c0002632 <panic_spin>
c0003d18:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:80
   const char* last_char = NULL;
c0003d1b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/string.c:82
   /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/
   while (*str != 0) {
c0003d22:	eb 1b                	jmp    c0003d3f <strrchr+0x4f>
/work/x86_os_my/lib/string.c:83
      if (*str == ch) {
c0003d24:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d27:	0f b6 00             	movzbl (%eax),%eax
c0003d2a:	0f be d0             	movsbl %al,%edx
c0003d2d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0003d31:	39 c2                	cmp    %eax,%edx
c0003d33:	75 06                	jne    c0003d3b <strrchr+0x4b>
/work/x86_os_my/lib/string.c:84
	 last_char = str;
c0003d35:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d38:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:86
      }
      str++;
c0003d3b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:82
/* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strrchr(const char* str, const uint8_t ch) {
   ASSERT(str != NULL);
   const char* last_char = NULL;
   /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/
   while (*str != 0) {
c0003d3f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d42:	0f b6 00             	movzbl (%eax),%eax
c0003d45:	84 c0                	test   %al,%al
c0003d47:	75 db                	jne    c0003d24 <strrchr+0x34>
/work/x86_os_my/lib/string.c:88
      if (*str == ch) {
	 last_char = str;
      }
      str++;
   }
   return (char*)last_char;
c0003d49:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:89
}
c0003d4c:	c9                   	leave  
c0003d4d:	c3                   	ret    

c0003d4e <strcat>:
strcat():
/work/x86_os_my/lib/string.c:92

/* 将字符串src_拼接到dst_后,将回拼接的串地址 */
char* strcat(char* dst_, const char* src_) {
c0003d4e:	55                   	push   %ebp
c0003d4f:	89 e5                	mov    %esp,%ebp
c0003d51:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:93
   ASSERT(dst_ != NULL && src_ != NULL);
c0003d54:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003d58:	74 06                	je     c0003d60 <strcat+0x12>
/work/x86_os_my/lib/string.c:93 (discriminator 1)
c0003d5a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0003d5e:	75 19                	jne    c0003d79 <strcat+0x2b>
/work/x86_os_my/lib/string.c:93 (discriminator 3)
c0003d60:	68 9e 8f 00 c0       	push   $0xc0008f9e
c0003d65:	68 38 90 00 c0       	push   $0xc0009038
c0003d6a:	6a 5d                	push   $0x5d
c0003d6c:	68 91 8f 00 c0       	push   $0xc0008f91
c0003d71:	e8 bc e8 ff ff       	call   c0002632 <panic_spin>
c0003d76:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:94
   char* str = dst_;
c0003d79:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d7c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:95
   while (*str++);
c0003d7f:	90                   	nop
/work/x86_os_my/lib/string.c:95 (discriminator 1)
c0003d80:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003d83:	8d 50 01             	lea    0x1(%eax),%edx
c0003d86:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003d89:	0f b6 00             	movzbl (%eax),%eax
c0003d8c:	84 c0                	test   %al,%al
c0003d8e:	75 f0                	jne    c0003d80 <strcat+0x32>
/work/x86_os_my/lib/string.c:96
   --str;      // 别看错了，--str是独立的一句，并不是while的循环体
c0003d90:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:97
   while((*str++ = *src_++));	 // 当*str被赋值为0时,此时表达式不成立,正好添加了字符串结尾的0.
c0003d94:	90                   	nop
/work/x86_os_my/lib/string.c:97 (discriminator 1)
c0003d95:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003d98:	8d 50 01             	lea    0x1(%eax),%edx
c0003d9b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003d9e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003da1:	8d 4a 01             	lea    0x1(%edx),%ecx
c0003da4:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c0003da7:	0f b6 12             	movzbl (%edx),%edx
c0003daa:	88 10                	mov    %dl,(%eax)
c0003dac:	0f b6 00             	movzbl (%eax),%eax
c0003daf:	84 c0                	test   %al,%al
c0003db1:	75 e2                	jne    c0003d95 <strcat+0x47>
/work/x86_os_my/lib/string.c:98
   return dst_;
c0003db3:	8b 45 08             	mov    0x8(%ebp),%eax
/work/x86_os_my/lib/string.c:99
}
c0003db6:	c9                   	leave  
c0003db7:	c3                   	ret    

c0003db8 <strchrs>:
strchrs():
/work/x86_os_my/lib/string.c:102

/* 在字符串str中查找指定字符ch出现的次数 */
uint32_t strchrs(const char* str, uint8_t ch) {
c0003db8:	55                   	push   %ebp
c0003db9:	89 e5                	mov    %esp,%ebp
c0003dbb:	83 ec 28             	sub    $0x28,%esp
c0003dbe:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003dc1:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:103
   ASSERT(str != NULL);
c0003dc4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003dc8:	75 19                	jne    c0003de3 <strchrs+0x2b>
/work/x86_os_my/lib/string.c:103 (discriminator 1)
c0003dca:	68 d2 8f 00 c0       	push   $0xc0008fd2
c0003dcf:	68 40 90 00 c0       	push   $0xc0009040
c0003dd4:	6a 67                	push   $0x67
c0003dd6:	68 91 8f 00 c0       	push   $0xc0008f91
c0003ddb:	e8 52 e8 ff ff       	call   c0002632 <panic_spin>
c0003de0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:104
   uint32_t ch_cnt = 0;
c0003de3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/string.c:105
   const char* p = str;
c0003dea:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ded:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:106
   while(*p != 0) {
c0003df0:	eb 19                	jmp    c0003e0b <strchrs+0x53>
/work/x86_os_my/lib/string.c:107
      if (*p == ch) {
c0003df2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003df5:	0f b6 00             	movzbl (%eax),%eax
c0003df8:	0f be d0             	movsbl %al,%edx
c0003dfb:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0003dff:	39 c2                	cmp    %eax,%edx
c0003e01:	75 04                	jne    c0003e07 <strchrs+0x4f>
/work/x86_os_my/lib/string.c:108
	 ch_cnt++;
c0003e03:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:110
      }
      p++;
c0003e07:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/string.c:106
/* 在字符串str中查找指定字符ch出现的次数 */
uint32_t strchrs(const char* str, uint8_t ch) {
   ASSERT(str != NULL);
   uint32_t ch_cnt = 0;
   const char* p = str;
   while(*p != 0) {
c0003e0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003e0e:	0f b6 00             	movzbl (%eax),%eax
c0003e11:	84 c0                	test   %al,%al
c0003e13:	75 dd                	jne    c0003df2 <strchrs+0x3a>
/work/x86_os_my/lib/string.c:112
      if (*p == ch) {
	 ch_cnt++;
      }
      p++;
   }
   return ch_cnt;
c0003e15:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:113
}
c0003e18:	c9                   	leave  
c0003e19:	c3                   	ret    

c0003e1a <idle>:
idle():
/work/x86_os_my/thread/thread.c:22
static struct list_elem* g_thread_tag;// 用于临时保存队列中的线程结点

extern void switch_to(struct task_struct* cur, struct task_struct* next);

/* idle线程 */
static void idle(void* arg UNUSED) {
c0003e1a:	55                   	push   %ebp
c0003e1b:	89 e5                	mov    %esp,%ebp
c0003e1d:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:24 (discriminator 1)
	while(1) {
		thread_block(TASK_BLOCKED);
c0003e20:	83 ec 0c             	sub    $0xc,%esp
c0003e23:	6a 02                	push   $0x2
c0003e25:	e8 84 04 00 00       	call   c00042ae <thread_block>
c0003e2a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:28 (discriminator 1)
		//CPU停机
		//唯一能唤醒处理器的就是外部中断
		//执行hlt时必须要保证目前处在开中断的情况下
		asm volatile ("sti; hlt" : : : "memory");
c0003e2d:	fb                   	sti    
c0003e2e:	f4                   	hlt    
/work/x86_os_my/thread/thread.c:29 (discriminator 1)
	}
c0003e2f:	eb ef                	jmp    c0003e20 <idle+0x6>

c0003e31 <running_thread>:
running_thread():
/work/x86_os_my/thread/thread.c:36

/* 返回线程 PCB 地址。
 * 各个线程所用的 0 级栈都是在自己的 PCB 当中，
 * 取当前栈指针的高 20 位，就是当前运行线程的 PCB（PCB是在自然页的起始地址！）
 */
struct task_struct* running_thread() {
c0003e31:	55                   	push   %ebp
c0003e32:	89 e5                	mov    %esp,%ebp
c0003e34:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:38
	uint32_t esp;
	asm ("mov %%esp, %0" : "=g" (esp));	//esp寄存器的值，放入变量esp
c0003e37:	89 e0                	mov    %esp,%eax
c0003e39:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:39
	return (struct task_struct*)(esp & 0xfffff000);
c0003e3c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003e3f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
/work/x86_os_my/thread/thread.c:40
}
c0003e44:	c9                   	leave  
c0003e45:	c3                   	ret    

c0003e46 <kernel_thread>:
kernel_thread():
/work/x86_os_my/thread/thread.c:43

/* 由kernel_thread去执行function(func_arg) */
static void kernel_thread(thread_func* function, void* func_arg) {
c0003e46:	55                   	push   %ebp
c0003e47:	89 e5                	mov    %esp,%ebp
c0003e49:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:49
	/* 线程的首次运行是由时钟中断处理函数调用任务调度器 schedule 完成的，
	 * 进入中断后处理器会自动关中断，
	 * 因此在执行 function 前要打开中断，否则 kernel_thread 中的 function 在关中断的情况下运行，
	 * 也就是时钟中断被屏蔽了，再也不会调度到新的线程，function 会独享处理器。
	 */
	intr_enable();
c0003e4c:	e8 19 de ff ff       	call   c0001c6a <intr_enable>
/work/x86_os_my/thread/thread.c:50
	function(func_arg); 
c0003e51:	83 ec 0c             	sub    $0xc,%esp
c0003e54:	ff 75 0c             	pushl  0xc(%ebp)
c0003e57:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e5a:	ff d0                	call   *%eax
c0003e5c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:51
}
c0003e5f:	90                   	nop
c0003e60:	c9                   	leave  
c0003e61:	c3                   	ret    

c0003e62 <allocate_pid>:
allocate_pid():
/work/x86_os_my/thread/thread.c:54

/* 分配pid */
static pid_t allocate_pid(void) {
c0003e62:	55                   	push   %ebp
c0003e63:	89 e5                	mov    %esp,%ebp
c0003e65:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:56
   static pid_t next_pid = 0;
   lock_acquire(&pid_lock);
c0003e68:	83 ec 0c             	sub    $0xc,%esp
c0003e6b:	68 b4 cb 00 c0       	push   $0xc000cbb4
c0003e70:	e8 5a 0b 00 00       	call   c00049cf <lock_acquire>
c0003e75:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:57
   next_pid++;
c0003e78:	0f b7 05 6c c5 00 c0 	movzwl 0xc000c56c,%eax
c0003e7f:	83 c0 01             	add    $0x1,%eax
c0003e82:	66 a3 6c c5 00 c0    	mov    %ax,0xc000c56c
/work/x86_os_my/thread/thread.c:58
   lock_release(&pid_lock);
c0003e88:	83 ec 0c             	sub    $0xc,%esp
c0003e8b:	68 b4 cb 00 c0       	push   $0xc000cbb4
c0003e90:	e8 b1 0b 00 00       	call   c0004a46 <lock_release>
c0003e95:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:59
   return next_pid;
c0003e98:	0f b7 05 6c c5 00 c0 	movzwl 0xc000c56c,%eax
/work/x86_os_my/thread/thread.c:60
}
c0003e9f:	c9                   	leave  
c0003ea0:	c3                   	ret    

c0003ea1 <thread_create>:
thread_create():
/work/x86_os_my/thread/thread.c:63

/* 初始化线程栈结构体 struct thread_stack */
void thread_create(struct task_struct* pthread, thread_func function, void* func_arg) {
c0003ea1:	55                   	push   %ebp
c0003ea2:	89 e5                	mov    %esp,%ebp
c0003ea4:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:67
	/* 先预留中断使用栈的空间 
	 *（1）将来线程进入中断后，位于 kernel.S 中的中断代码会通过此栈来保存上下文。
	 *（2）将来实现用户进程时，会将用户进程的初始信息放在中断栈中。*/
	pthread->self_kstack -= sizeof(struct intr_stack);
c0003ea7:	8b 45 08             	mov    0x8(%ebp),%eax
c0003eaa:	8b 00                	mov    (%eax),%eax
c0003eac:	8d 90 d0 fe ff ff    	lea    -0x130(%eax),%edx
c0003eb2:	8b 45 08             	mov    0x8(%ebp),%eax
c0003eb5:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:70

	/* 再留出线程栈空间（unused_retaddr 所在的栈）*/
	pthread->self_kstack -= sizeof(struct thread_stack);
c0003eb7:	8b 45 08             	mov    0x8(%ebp),%eax
c0003eba:	8b 00                	mov    (%eax),%eax
c0003ebc:	8d 50 80             	lea    -0x80(%eax),%edx
c0003ebf:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ec2:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:71
	struct thread_stack* kthread_stack = (struct thread_stack*)pthread->self_kstack;
c0003ec4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ec7:	8b 00                	mov    (%eax),%eax
c0003ec9:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:79
	 * kernel_thread 并不是通过 call 指令调用的，而是通过 ret 来执行的，
	 * 因此无法按照正常的函数调用形式传递 kernel_thread 所需要的参数，
	 * 这样调用是不行的： kernel_thread(function, func_arg)，
	 * 只能将参数放在 kernel_thread 所用的栈中，即处理器进入 kernel_thread 函数体时，
	 * 栈顶为返回地址，栈顶+4 为参数function，栈顶+8 为参数func_arg */
	kthread_stack->eip = kernel_thread;
c0003ecc:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003ecf:	c7 40 10 46 3e 00 c0 	movl   $0xc0003e46,0x10(%eax)
/work/x86_os_my/thread/thread.c:80
	kthread_stack->function = function;
c0003ed6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003ed9:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003edc:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/thread.c:81
	kthread_stack->func_arg = func_arg;
c0003edf:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003ee2:	8b 55 10             	mov    0x10(%ebp),%edx
c0003ee5:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/thread/thread.c:82
	kthread_stack->ebp = kthread_stack->ebx = kthread_stack->esi = kthread_stack->edi = 0;
c0003ee8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003eeb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c0003ef2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003ef5:	8b 50 08             	mov    0x8(%eax),%edx
c0003ef8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003efb:	89 50 0c             	mov    %edx,0xc(%eax)
c0003efe:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003f01:	8b 50 0c             	mov    0xc(%eax),%edx
c0003f04:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003f07:	89 50 04             	mov    %edx,0x4(%eax)
c0003f0a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003f0d:	8b 50 04             	mov    0x4(%eax),%edx
c0003f10:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003f13:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:83
}
c0003f15:	90                   	nop
c0003f16:	c9                   	leave  
c0003f17:	c3                   	ret    

c0003f18 <init_thread>:
init_thread():
/work/x86_os_my/thread/thread.c:86

/* 初始化线程PCB结构体 struct task_struct */
void init_thread(struct task_struct* pthread, char* name, int prio) {
c0003f18:	55                   	push   %ebp
c0003f19:	89 e5                	mov    %esp,%ebp
c0003f1b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:87
	memset(pthread, 0, sizeof(*pthread));	//清空PCB
c0003f1e:	83 ec 04             	sub    $0x4,%esp
c0003f21:	68 10 01 00 00       	push   $0x110
c0003f26:	6a 00                	push   $0x0
c0003f28:	ff 75 08             	pushl  0x8(%ebp)
c0003f2b:	e8 1a fb ff ff       	call   c0003a4a <memset>
c0003f30:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:88
	pthread->pid = allocate_pid();
c0003f33:	e8 2a ff ff ff       	call   c0003e62 <allocate_pid>
c0003f38:	89 c2                	mov    %eax,%edx
c0003f3a:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f3d:	66 89 50 04          	mov    %dx,0x4(%eax)
/work/x86_os_my/thread/thread.c:89
	strcpy(pthread->name, name);
c0003f41:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f44:	83 c0 0c             	add    $0xc,%eax
c0003f47:	83 ec 08             	sub    $0x8,%esp
c0003f4a:	ff 75 0c             	pushl  0xc(%ebp)
c0003f4d:	50                   	push   %eax
c0003f4e:	e8 2c fc ff ff       	call   c0003b7f <strcpy>
c0003f53:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:91

	if (pthread == g_main_thread) {
c0003f56:	a1 b0 cb 00 c0       	mov    0xc000cbb0,%eax
c0003f5b:	39 45 08             	cmp    %eax,0x8(%ebp)
c0003f5e:	75 0c                	jne    c0003f6c <init_thread+0x54>
/work/x86_os_my/thread/thread.c:93
		/* 由于把main函数也封装成一个线程,并且它一直是运行的,故将其直接设为TASK_RUNNING */
		pthread->status = TASK_RUNNING;
c0003f60:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f63:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c0003f6a:	eb 0a                	jmp    c0003f76 <init_thread+0x5e>
/work/x86_os_my/thread/thread.c:95
	} else {
		pthread->status = TASK_READY;
c0003f6c:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f6f:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:101
	}

	/* self_kstack是线程自己在内核态下使用的栈顶地址 
	 * 线程自己在 0 特权级下所用的栈，在线程创建之初，
	 * 它被初始化为线程 PCB 的最顶端，即(uint32_t)pthread + PG_SIZE。*/
	pthread->self_kstack = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c0003f76:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f79:	05 00 10 00 00       	add    $0x1000,%eax
c0003f7e:	89 c2                	mov    %eax,%edx
c0003f80:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f83:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:102
	pthread->priority = prio;
c0003f85:	8b 45 10             	mov    0x10(%ebp),%eax
c0003f88:	89 c2                	mov    %eax,%edx
c0003f8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f8d:	88 50 1c             	mov    %dl,0x1c(%eax)
/work/x86_os_my/thread/thread.c:103
	pthread->ticks = prio;
c0003f90:	8b 45 10             	mov    0x10(%ebp),%eax
c0003f93:	89 c2                	mov    %eax,%edx
c0003f95:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f98:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/thread/thread.c:104
	pthread->elapsed_ticks = 0;
c0003f9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f9e:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
/work/x86_os_my/thread/thread.c:105
	pthread->pgdir = NULL;
c0003fa5:	8b 45 08             	mov    0x8(%ebp),%eax
c0003fa8:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
/work/x86_os_my/thread/thread.c:108

	/* 预留标准输入输出 */
	pthread->fd_table[0] = 0;
c0003faf:	8b 45 08             	mov    0x8(%ebp),%eax
c0003fb2:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
/work/x86_os_my/thread/thread.c:109
	pthread->fd_table[1] = 1;
c0003fb9:	8b 45 08             	mov    0x8(%ebp),%eax
c0003fbc:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
/work/x86_os_my/thread/thread.c:110
	pthread->fd_table[2] = 2;
c0003fc3:	8b 45 08             	mov    0x8(%ebp),%eax
c0003fc6:	c7 40 2c 02 00 00 00 	movl   $0x2,0x2c(%eax)
/work/x86_os_my/thread/thread.c:112
	/* 其余的全置为-1 */
	uint8_t fd_idx = 3;
c0003fcd:	c6 45 f7 03          	movb   $0x3,-0x9(%ebp)
/work/x86_os_my/thread/thread.c:113
	while (fd_idx < MAX_FILES_OPEN_PER_PROC) {
c0003fd1:	eb 1c                	jmp    c0003fef <init_thread+0xd7>
/work/x86_os_my/thread/thread.c:114
		pthread->fd_table[fd_idx] = -1;
c0003fd3:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0003fd7:	8b 45 08             	mov    0x8(%ebp),%eax
c0003fda:	83 c2 08             	add    $0x8,%edx
c0003fdd:	c7 44 90 04 ff ff ff 	movl   $0xffffffff,0x4(%eax,%edx,4)
c0003fe4:	ff 
/work/x86_os_my/thread/thread.c:115
		fd_idx++;
c0003fe5:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0003fe9:	83 c0 01             	add    $0x1,%eax
c0003fec:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/thread/thread.c:113
	pthread->fd_table[0] = 0;
	pthread->fd_table[1] = 1;
	pthread->fd_table[2] = 2;
	/* 其余的全置为-1 */
	uint8_t fd_idx = 3;
	while (fd_idx < MAX_FILES_OPEN_PER_PROC) {
c0003fef:	80 7d f7 07          	cmpb   $0x7,-0x9(%ebp)
c0003ff3:	76 de                	jbe    c0003fd3 <init_thread+0xbb>
/work/x86_os_my/thread/thread.c:118
		pthread->fd_table[fd_idx] = -1;
		fd_idx++;
	}

	pthread->stack_magic = 0x19870916;	  // 自定义的魔数
c0003ff5:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ff8:	c7 80 0c 01 00 00 16 	movl   $0x19870916,0x10c(%eax)
c0003fff:	09 87 19 
/work/x86_os_my/thread/thread.c:119
}
c0004002:	90                   	nop
c0004003:	c9                   	leave  
c0004004:	c3                   	ret    

c0004005 <thread_start>:
thread_start():
/work/x86_os_my/thread/thread.c:122

/* 创建线程 */
struct task_struct* thread_start(char* name, int prio, thread_func function, void* func_arg) {
c0004005:	55                   	push   %ebp
c0004006:	89 e5                	mov    %esp,%ebp
c0004008:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:124
	/* pcb都位于内核空间,包括用户进程的pcb也是在内核空间 */
	struct task_struct* thread = get_kernel_pages(1);
c000400b:	83 ec 0c             	sub    $0xc,%esp
c000400e:	6a 01                	push   $0x1
c0004010:	e8 c5 ec ff ff       	call   c0002cda <get_kernel_pages>
c0004015:	83 c4 10             	add    $0x10,%esp
c0004018:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:126

	init_thread(thread, name, prio);			//初始化线程PCB
c000401b:	83 ec 04             	sub    $0x4,%esp
c000401e:	ff 75 0c             	pushl  0xc(%ebp)
c0004021:	ff 75 08             	pushl  0x8(%ebp)
c0004024:	ff 75 f4             	pushl  -0xc(%ebp)
c0004027:	e8 ec fe ff ff       	call   c0003f18 <init_thread>
c000402c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:127
	thread_create(thread, function, func_arg);	//初始化线程栈结构体
c000402f:	83 ec 04             	sub    $0x4,%esp
c0004032:	ff 75 14             	pushl  0x14(%ebp)
c0004035:	ff 75 10             	pushl  0x10(%ebp)
c0004038:	ff 75 f4             	pushl  -0xc(%ebp)
c000403b:	e8 61 fe ff ff       	call   c0003ea1 <thread_create>
c0004040:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:129
	
	ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));	// 确保之前不在队列中
c0004043:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004046:	83 c0 44             	add    $0x44,%eax
c0004049:	83 ec 08             	sub    $0x8,%esp
c000404c:	50                   	push   %eax
c000404d:	68 8c cb 00 c0       	push   $0xc000cb8c
c0004052:	e8 bc 05 00 00       	call   c0004613 <elem_find>
c0004057:	83 c4 10             	add    $0x10,%esp
c000405a:	85 c0                	test   %eax,%eax
c000405c:	74 1c                	je     c000407a <thread_start+0x75>
/work/x86_os_my/thread/thread.c:129 (discriminator 1)
c000405e:	68 48 90 00 c0       	push   $0xc0009048
c0004063:	68 cc 92 00 c0       	push   $0xc00092cc
c0004068:	68 81 00 00 00       	push   $0x81
c000406d:	68 7d 90 00 c0       	push   $0xc000907d
c0004072:	e8 bb e5 ff ff       	call   c0002632 <panic_spin>
c0004077:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:130
	list_append(&thread_ready_list, &thread->general_tag);			// 加入就绪线程队列
c000407a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000407d:	83 c0 44             	add    $0x44,%eax
c0004080:	83 ec 08             	sub    $0x8,%esp
c0004083:	50                   	push   %eax
c0004084:	68 8c cb 00 c0       	push   $0xc000cb8c
c0004089:	e8 0b 05 00 00       	call   c0004599 <list_append>
c000408e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:132

	ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
c0004091:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004094:	83 c0 4c             	add    $0x4c,%eax
c0004097:	83 ec 08             	sub    $0x8,%esp
c000409a:	50                   	push   %eax
c000409b:	68 9c cb 00 c0       	push   $0xc000cb9c
c00040a0:	e8 6e 05 00 00       	call   c0004613 <elem_find>
c00040a5:	83 c4 10             	add    $0x10,%esp
c00040a8:	85 c0                	test   %eax,%eax
c00040aa:	74 1c                	je     c00040c8 <thread_start+0xc3>
/work/x86_os_my/thread/thread.c:132 (discriminator 1)
c00040ac:	68 90 90 00 c0       	push   $0xc0009090
c00040b1:	68 cc 92 00 c0       	push   $0xc00092cc
c00040b6:	68 84 00 00 00       	push   $0x84
c00040bb:	68 7d 90 00 c0       	push   $0xc000907d
c00040c0:	e8 6d e5 ff ff       	call   c0002632 <panic_spin>
c00040c5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:133
	list_append(&thread_all_list, &thread->all_list_tag);			// 加入全部线程队列
c00040c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00040cb:	83 c0 4c             	add    $0x4c,%eax
c00040ce:	83 ec 08             	sub    $0x8,%esp
c00040d1:	50                   	push   %eax
c00040d2:	68 9c cb 00 c0       	push   $0xc000cb9c
c00040d7:	e8 bd 04 00 00       	call   c0004599 <list_append>
c00040dc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:149
	 * 在执行 ret 后，esp 指向的数值被弹岀到 eip。
	 * 处理器会去执行 kernel_thread 函数。
	 * 在执行 kernel_thread 时，处理器以为栈顶是返回地址，其实只是一个假的占位置的变量 unused_retaddr！
	 * 接着会调用函数 function(func_arg) */
	//asm volatile ("movl %0, %%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret" : : "g" (thread->self_kstack) : "memory");
	return thread;
c00040df:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/thread/thread.c:150
}
c00040e2:	c9                   	leave  
c00040e3:	c3                   	ret    

c00040e4 <make_main_thread>:
make_main_thread():
/work/x86_os_my/thread/thread.c:154


/* 将kernel中的main函数完善为主线程 */
static void make_main_thread(void) {
c00040e4:	55                   	push   %ebp
c00040e5:	89 e5                	mov    %esp,%ebp
c00040e7:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:159
	/* 因为main线程早已运行,咱们在loader.S中进入内核时的mov esp, 0xc009f000设置了栈顶，也预留了pcb, 地址为0xc009e000
	 * 主线程不需要再为PCB申请页，只需要通过 init_thread 填充PCB成员：名称和优先级等。
	 * 也不需要再通过 thread_create 构造它的线程栈。
	 */
	g_main_thread = running_thread();	//用栈指针的高20位，当做当前线程的PCB
c00040ea:	e8 42 fd ff ff       	call   c0003e31 <running_thread>
c00040ef:	a3 b0 cb 00 c0       	mov    %eax,0xc000cbb0
/work/x86_os_my/thread/thread.c:160
	init_thread(g_main_thread, "main", 31);
c00040f4:	a1 b0 cb 00 c0       	mov    0xc000cbb0,%eax
c00040f9:	83 ec 04             	sub    $0x4,%esp
c00040fc:	6a 1f                	push   $0x1f
c00040fe:	68 c4 90 00 c0       	push   $0xc00090c4
c0004103:	50                   	push   %eax
c0004104:	e8 0f fe ff ff       	call   c0003f18 <init_thread>
c0004109:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:164

	/* main函数是当前线程,当前线程不在thread_ready_list中,
	 * 所以只将其加在thread_all_list中. */
	ASSERT(!elem_find(&thread_all_list, &g_main_thread->all_list_tag));
c000410c:	a1 b0 cb 00 c0       	mov    0xc000cbb0,%eax
c0004111:	83 c0 4c             	add    $0x4c,%eax
c0004114:	83 ec 08             	sub    $0x8,%esp
c0004117:	50                   	push   %eax
c0004118:	68 9c cb 00 c0       	push   $0xc000cb9c
c000411d:	e8 f1 04 00 00       	call   c0004613 <elem_find>
c0004122:	83 c4 10             	add    $0x10,%esp
c0004125:	85 c0                	test   %eax,%eax
c0004127:	74 1c                	je     c0004145 <make_main_thread+0x61>
/work/x86_os_my/thread/thread.c:164 (discriminator 1)
c0004129:	68 cc 90 00 c0       	push   $0xc00090cc
c000412e:	68 dc 92 00 c0       	push   $0xc00092dc
c0004133:	68 a4 00 00 00       	push   $0xa4
c0004138:	68 7d 90 00 c0       	push   $0xc000907d
c000413d:	e8 f0 e4 ff ff       	call   c0002632 <panic_spin>
c0004142:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:165
	list_append(&thread_all_list, &g_main_thread->all_list_tag);
c0004145:	a1 b0 cb 00 c0       	mov    0xc000cbb0,%eax
c000414a:	83 c0 4c             	add    $0x4c,%eax
c000414d:	83 ec 08             	sub    $0x8,%esp
c0004150:	50                   	push   %eax
c0004151:	68 9c cb 00 c0       	push   $0xc000cb9c
c0004156:	e8 3e 04 00 00       	call   c0004599 <list_append>
c000415b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:166
}
c000415e:	90                   	nop
c000415f:	c9                   	leave  
c0004160:	c3                   	ret    

c0004161 <schedule>:
schedule():
/work/x86_os_my/thread/thread.c:176
（2）调度器 schedule。
（3）任务切换函数 switch_to。
*/
/* 实现任务调度 */
void schedule()
{
c0004161:	55                   	push   %ebp
c0004162:	89 e5                	mov    %esp,%ebp
c0004164:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:177
	ASSERT(intr_get_status() == INTR_OFF);
c0004167:	e8 6e db ff ff       	call   c0001cda <intr_get_status>
c000416c:	85 c0                	test   %eax,%eax
c000416e:	74 1c                	je     c000418c <schedule+0x2b>
/work/x86_os_my/thread/thread.c:177 (discriminator 1)
c0004170:	68 07 91 00 c0       	push   $0xc0009107
c0004175:	68 f0 92 00 c0       	push   $0xc00092f0
c000417a:	68 b1 00 00 00       	push   $0xb1
c000417f:	68 7d 90 00 c0       	push   $0xc000907d
c0004184:	e8 a9 e4 ff ff       	call   c0002632 <panic_spin>
c0004189:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:180

	/* 换下 */
	struct task_struct* cur = running_thread(); 
c000418c:	e8 a0 fc ff ff       	call   c0003e31 <running_thread>
c0004191:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:181
	if (cur->status == TASK_RUNNING) { // 若此线程只是cpu时间片到了,将其加入到就绪队列尾
c0004194:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004197:	8b 40 08             	mov    0x8(%eax),%eax
c000419a:	85 c0                	test   %eax,%eax
c000419c:	75 65                	jne    c0004203 <schedule+0xa2>
/work/x86_os_my/thread/thread.c:182
		ASSERT(!elem_find(&thread_ready_list, &cur->general_tag));
c000419e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00041a1:	83 c0 44             	add    $0x44,%eax
c00041a4:	83 ec 08             	sub    $0x8,%esp
c00041a7:	50                   	push   %eax
c00041a8:	68 8c cb 00 c0       	push   $0xc000cb8c
c00041ad:	e8 61 04 00 00       	call   c0004613 <elem_find>
c00041b2:	83 c4 10             	add    $0x10,%esp
c00041b5:	85 c0                	test   %eax,%eax
c00041b7:	74 1c                	je     c00041d5 <schedule+0x74>
/work/x86_os_my/thread/thread.c:182 (discriminator 1)
c00041b9:	68 28 91 00 c0       	push   $0xc0009128
c00041be:	68 f0 92 00 c0       	push   $0xc00092f0
c00041c3:	68 b6 00 00 00       	push   $0xb6
c00041c8:	68 7d 90 00 c0       	push   $0xc000907d
c00041cd:	e8 60 e4 ff ff       	call   c0002632 <panic_spin>
c00041d2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:183
		list_append(&thread_ready_list, &cur->general_tag);
c00041d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00041d8:	83 c0 44             	add    $0x44,%eax
c00041db:	83 ec 08             	sub    $0x8,%esp
c00041de:	50                   	push   %eax
c00041df:	68 8c cb 00 c0       	push   $0xc000cb8c
c00041e4:	e8 b0 03 00 00       	call   c0004599 <list_append>
c00041e9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:184
		cur->ticks = cur->priority;     // 重新将当前线程的ticks再重置为其priority;
c00041ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00041ef:	0f b6 50 1c          	movzbl 0x1c(%eax),%edx
c00041f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00041f6:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/thread/thread.c:185
		cur->status = TASK_READY;
c00041f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00041fc:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:192
		/* 若此线程需要某事件发生后才能继续上cpu运行,
		不需要将其加入队列,因为当前线程不在就绪队列中。*/
	}

	/* 如果就绪队列中没有可运行的任务,就唤醒idle */
	if (list_empty(&thread_ready_list)) {
c0004203:	83 ec 0c             	sub    $0xc,%esp
c0004206:	68 8c cb 00 c0       	push   $0xc000cb8c
c000420b:	e8 d0 04 00 00       	call   c00046e0 <list_empty>
c0004210:	83 c4 10             	add    $0x10,%esp
c0004213:	85 c0                	test   %eax,%eax
c0004215:	74 11                	je     c0004228 <schedule+0xc7>
/work/x86_os_my/thread/thread.c:193
		thread_unblock(idle_thread);
c0004217:	a1 ac cb 00 c0       	mov    0xc000cbac,%eax
c000421c:	83 ec 0c             	sub    $0xc,%esp
c000421f:	50                   	push   %eax
c0004220:	e8 ec 00 00 00       	call   c0004311 <thread_unblock>
c0004225:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:197
	}
	
	/* 换上 */
	ASSERT(!list_empty(&thread_ready_list));
c0004228:	83 ec 0c             	sub    $0xc,%esp
c000422b:	68 8c cb 00 c0       	push   $0xc000cb8c
c0004230:	e8 ab 04 00 00       	call   c00046e0 <list_empty>
c0004235:	83 c4 10             	add    $0x10,%esp
c0004238:	85 c0                	test   %eax,%eax
c000423a:	74 1c                	je     c0004258 <schedule+0xf7>
/work/x86_os_my/thread/thread.c:197 (discriminator 1)
c000423c:	68 5c 91 00 c0       	push   $0xc000915c
c0004241:	68 f0 92 00 c0       	push   $0xc00092f0
c0004246:	68 c5 00 00 00       	push   $0xc5
c000424b:	68 7d 90 00 c0       	push   $0xc000907d
c0004250:	e8 dd e3 ff ff       	call   c0002632 <panic_spin>
c0004255:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:198
	g_thread_tag = NULL;	  // g_thread_tag清空
c0004258:	c7 05 68 c5 00 c0 00 	movl   $0x0,0xc000c568
c000425f:	00 00 00 
/work/x86_os_my/thread/thread.c:200
	/* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */
	g_thread_tag = list_pop(&thread_ready_list);   
c0004262:	83 ec 0c             	sub    $0xc,%esp
c0004265:	68 8c cb 00 c0       	push   $0xc000cb8c
c000426a:	e8 82 03 00 00       	call   c00045f1 <list_pop>
c000426f:	83 c4 10             	add    $0x10,%esp
c0004272:	a3 68 c5 00 c0       	mov    %eax,0xc000c568
/work/x86_os_my/thread/thread.c:201
	struct task_struct* next = elem2entry(struct task_struct, general_tag, g_thread_tag);
c0004277:	a1 68 c5 00 c0       	mov    0xc000c568,%eax
c000427c:	83 e8 44             	sub    $0x44,%eax
c000427f:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:202
	next->status = TASK_RUNNING;
c0004282:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0004285:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/thread/thread.c:206
	
	/* 1.激活线程或进程的页表,【更新CR3寄存器】
	 * 2.用户进程，更新tss中的esp0为进程的特权级0的栈 */
	process_activate(next);
c000428c:	83 ec 0c             	sub    $0xc,%esp
c000428f:	ff 75 f0             	pushl  -0x10(%ebp)
c0004292:	e8 fb 10 00 00       	call   c0005392 <process_activate>
c0004297:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:208

	switch_to(cur, next);
c000429a:	83 ec 08             	sub    $0x8,%esp
c000429d:	ff 75 f0             	pushl  -0x10(%ebp)
c00042a0:	ff 75 f4             	pushl  -0xc(%ebp)
c00042a3:	e8 58 04 00 00       	call   c0004700 <switch_to>
c00042a8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:209
}
c00042ab:	90                   	nop
c00042ac:	c9                   	leave  
c00042ad:	c3                   	ret    

c00042ae <thread_block>:
thread_block():
/work/x86_os_my/thread/thread.c:212

/* 当前线程将自己阻塞,标志其状态为stat. */
void thread_block(enum task_status stat) {
c00042ae:	55                   	push   %ebp
c00042af:	89 e5                	mov    %esp,%ebp
c00042b1:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:214
	/* stat取值为TASK_BLOCKED,TASK_WAITING,TASK_HANGING,也就是只有这三种状态才不会被调度*/
	ASSERT(((stat == TASK_BLOCKED) || (stat == TASK_WAITING) || (stat == TASK_HANGING)));
c00042b4:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c00042b8:	74 28                	je     c00042e2 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:214 (discriminator 1)
c00042ba:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c00042be:	74 22                	je     c00042e2 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:214 (discriminator 2)
c00042c0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
c00042c4:	74 1c                	je     c00042e2 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:214 (discriminator 3)
c00042c6:	68 7c 91 00 c0       	push   $0xc000917c
c00042cb:	68 fc 92 00 c0       	push   $0xc00092fc
c00042d0:	68 d6 00 00 00       	push   $0xd6
c00042d5:	68 7d 90 00 c0       	push   $0xc000907d
c00042da:	e8 53 e3 ff ff       	call   c0002632 <panic_spin>
c00042df:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:215
	enum intr_status old_status = intr_disable();
c00042e2:	e8 ac d9 ff ff       	call   c0001c93 <intr_disable>
c00042e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:217
	
	struct task_struct* cur_thread = running_thread();
c00042ea:	e8 42 fb ff ff       	call   c0003e31 <running_thread>
c00042ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:218
	cur_thread->status = stat;
c00042f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00042f5:	8b 55 08             	mov    0x8(%ebp),%edx
c00042f8:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/thread/thread.c:219
	schedule();
c00042fb:	e8 61 fe ff ff       	call   c0004161 <schedule>
/work/x86_os_my/thread/thread.c:222
	
	/* 待当前线程被解除阻塞后才继续运行下面的intr_set_status */
	intr_set_status(old_status);
c0004300:	83 ec 0c             	sub    $0xc,%esp
c0004303:	ff 75 f4             	pushl  -0xc(%ebp)
c0004306:	e8 b1 d9 ff ff       	call   c0001cbc <intr_set_status>
c000430b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:223
}
c000430e:	90                   	nop
c000430f:	c9                   	leave  
c0004310:	c3                   	ret    

c0004311 <thread_unblock>:
thread_unblock():
/work/x86_os_my/thread/thread.c:226

/* 将线程pthread解除阻塞 */
void thread_unblock(struct task_struct* pthread) {
c0004311:	55                   	push   %ebp
c0004312:	89 e5                	mov    %esp,%ebp
c0004314:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:227
	enum intr_status old_status = intr_disable();
c0004317:	e8 77 d9 ff ff       	call   c0001c93 <intr_disable>
c000431c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:228
	ASSERT(((pthread->status == TASK_BLOCKED) || (pthread->status == TASK_WAITING) || (pthread->status == TASK_HANGING)));
c000431f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004322:	8b 40 08             	mov    0x8(%eax),%eax
c0004325:	83 f8 02             	cmp    $0x2,%eax
c0004328:	74 32                	je     c000435c <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:228 (discriminator 1)
c000432a:	8b 45 08             	mov    0x8(%ebp),%eax
c000432d:	8b 40 08             	mov    0x8(%eax),%eax
c0004330:	83 f8 03             	cmp    $0x3,%eax
c0004333:	74 27                	je     c000435c <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:228 (discriminator 2)
c0004335:	8b 45 08             	mov    0x8(%ebp),%eax
c0004338:	8b 40 08             	mov    0x8(%eax),%eax
c000433b:	83 f8 04             	cmp    $0x4,%eax
c000433e:	74 1c                	je     c000435c <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:228 (discriminator 3)
c0004340:	68 cc 91 00 c0       	push   $0xc00091cc
c0004345:	68 0c 93 00 c0       	push   $0xc000930c
c000434a:	68 e4 00 00 00       	push   $0xe4
c000434f:	68 7d 90 00 c0       	push   $0xc000907d
c0004354:	e8 d9 e2 ff ff       	call   c0002632 <panic_spin>
c0004359:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:230
	
	if (pthread->status != TASK_READY) {
c000435c:	8b 45 08             	mov    0x8(%ebp),%eax
c000435f:	8b 40 08             	mov    0x8(%eax),%eax
c0004362:	83 f8 01             	cmp    $0x1,%eax
c0004365:	0f 84 8f 00 00 00    	je     c00043fa <thread_unblock+0xe9>
/work/x86_os_my/thread/thread.c:231
		ASSERT(!elem_find(&thread_ready_list, &pthread->general_tag));
c000436b:	8b 45 08             	mov    0x8(%ebp),%eax
c000436e:	83 c0 44             	add    $0x44,%eax
c0004371:	83 ec 08             	sub    $0x8,%esp
c0004374:	50                   	push   %eax
c0004375:	68 8c cb 00 c0       	push   $0xc000cb8c
c000437a:	e8 94 02 00 00       	call   c0004613 <elem_find>
c000437f:	83 c4 10             	add    $0x10,%esp
c0004382:	85 c0                	test   %eax,%eax
c0004384:	74 1c                	je     c00043a2 <thread_unblock+0x91>
/work/x86_os_my/thread/thread.c:231 (discriminator 1)
c0004386:	68 3c 92 00 c0       	push   $0xc000923c
c000438b:	68 0c 93 00 c0       	push   $0xc000930c
c0004390:	68 e7 00 00 00       	push   $0xe7
c0004395:	68 7d 90 00 c0       	push   $0xc000907d
c000439a:	e8 93 e2 ff ff       	call   c0002632 <panic_spin>
c000439f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:232
		if (elem_find(&thread_ready_list, &pthread->general_tag)) {
c00043a2:	8b 45 08             	mov    0x8(%ebp),%eax
c00043a5:	83 c0 44             	add    $0x44,%eax
c00043a8:	83 ec 08             	sub    $0x8,%esp
c00043ab:	50                   	push   %eax
c00043ac:	68 8c cb 00 c0       	push   $0xc000cb8c
c00043b1:	e8 5d 02 00 00       	call   c0004613 <elem_find>
c00043b6:	83 c4 10             	add    $0x10,%esp
c00043b9:	85 c0                	test   %eax,%eax
c00043bb:	74 1c                	je     c00043d9 <thread_unblock+0xc8>
/work/x86_os_my/thread/thread.c:233
			PANIC("thread_unblock: blocked thread in ready_list\n");
c00043bd:	68 74 92 00 c0       	push   $0xc0009274
c00043c2:	68 0c 93 00 c0       	push   $0xc000930c
c00043c7:	68 e9 00 00 00       	push   $0xe9
c00043cc:	68 7d 90 00 c0       	push   $0xc000907d
c00043d1:	e8 5c e2 ff ff       	call   c0002632 <panic_spin>
c00043d6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:235
		}
		list_push(&thread_ready_list, &pthread->general_tag);	// 放到队列的最前面,使其尽快得到调度
c00043d9:	8b 45 08             	mov    0x8(%ebp),%eax
c00043dc:	83 c0 44             	add    $0x44,%eax
c00043df:	83 ec 08             	sub    $0x8,%esp
c00043e2:	50                   	push   %eax
c00043e3:	68 8c cb 00 c0       	push   $0xc000cb8c
c00043e8:	e8 8e 01 00 00       	call   c000457b <list_push>
c00043ed:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:236
		pthread->status = TASK_READY;
c00043f0:	8b 45 08             	mov    0x8(%ebp),%eax
c00043f3:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:239
	}
	
	intr_set_status(old_status);
c00043fa:	83 ec 0c             	sub    $0xc,%esp
c00043fd:	ff 75 f4             	pushl  -0xc(%ebp)
c0004400:	e8 b7 d8 ff ff       	call   c0001cbc <intr_set_status>
c0004405:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:240
}
c0004408:	90                   	nop
c0004409:	c9                   	leave  
c000440a:	c3                   	ret    

c000440b <thread_yield>:
thread_yield():
/work/x86_os_my/thread/thread.c:243

/* 主动让出cpu，换其它线程运行，但状态仍是ready */
void thread_yield(void) {
c000440b:	55                   	push   %ebp
c000440c:	89 e5                	mov    %esp,%ebp
c000440e:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:244
	struct task_struct* cur = running_thread();
c0004411:	e8 1b fa ff ff       	call   c0003e31 <running_thread>
c0004416:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:245
	enum intr_status old_status = intr_disable();
c0004419:	e8 75 d8 ff ff       	call   c0001c93 <intr_disable>
c000441e:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:246
	ASSERT(!elem_find(&thread_ready_list, &cur->general_tag));
c0004421:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004424:	83 c0 44             	add    $0x44,%eax
c0004427:	83 ec 08             	sub    $0x8,%esp
c000442a:	50                   	push   %eax
c000442b:	68 8c cb 00 c0       	push   $0xc000cb8c
c0004430:	e8 de 01 00 00       	call   c0004613 <elem_find>
c0004435:	83 c4 10             	add    $0x10,%esp
c0004438:	85 c0                	test   %eax,%eax
c000443a:	74 1c                	je     c0004458 <thread_yield+0x4d>
/work/x86_os_my/thread/thread.c:246 (discriminator 1)
c000443c:	68 28 91 00 c0       	push   $0xc0009128
c0004441:	68 1c 93 00 c0       	push   $0xc000931c
c0004446:	68 f6 00 00 00       	push   $0xf6
c000444b:	68 7d 90 00 c0       	push   $0xc000907d
c0004450:	e8 dd e1 ff ff       	call   c0002632 <panic_spin>
c0004455:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:247
	list_append(&thread_ready_list, &cur->general_tag);
c0004458:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000445b:	83 c0 44             	add    $0x44,%eax
c000445e:	83 ec 08             	sub    $0x8,%esp
c0004461:	50                   	push   %eax
c0004462:	68 8c cb 00 c0       	push   $0xc000cb8c
c0004467:	e8 2d 01 00 00       	call   c0004599 <list_append>
c000446c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:248
	cur->status = TASK_READY;
c000446f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004472:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:249
	schedule();
c0004479:	e8 e3 fc ff ff       	call   c0004161 <schedule>
/work/x86_os_my/thread/thread.c:250
	intr_set_status(old_status);
c000447e:	83 ec 0c             	sub    $0xc,%esp
c0004481:	ff 75 f0             	pushl  -0x10(%ebp)
c0004484:	e8 33 d8 ff ff       	call   c0001cbc <intr_set_status>
c0004489:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:251
}
c000448c:	90                   	nop
c000448d:	c9                   	leave  
c000448e:	c3                   	ret    

c000448f <thread_init>:
thread_init():
/work/x86_os_my/thread/thread.c:254

/* 初始化线程环境 */
void thread_init(void) {
c000448f:	55                   	push   %ebp
c0004490:	89 e5                	mov    %esp,%ebp
c0004492:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:255
	put_str("thread_init start\n");
c0004495:	83 ec 0c             	sub    $0xc,%esp
c0004498:	68 a2 92 00 c0       	push   $0xc00092a2
c000449d:	e8 1e e0 ff ff       	call   c00024c0 <put_str>
c00044a2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:256
	list_init(&thread_ready_list);
c00044a5:	83 ec 0c             	sub    $0xc,%esp
c00044a8:	68 8c cb 00 c0       	push   $0xc000cb8c
c00044ad:	e8 56 00 00 00       	call   c0004508 <list_init>
c00044b2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:257
	list_init(&thread_all_list);
c00044b5:	83 ec 0c             	sub    $0xc,%esp
c00044b8:	68 9c cb 00 c0       	push   $0xc000cb9c
c00044bd:	e8 46 00 00 00       	call   c0004508 <list_init>
c00044c2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:258
	lock_init(&pid_lock);
c00044c5:	83 ec 0c             	sub    $0xc,%esp
c00044c8:	68 b4 cb 00 c0       	push   $0xc000cbb4
c00044cd:	e8 23 03 00 00       	call   c00047f5 <lock_init>
c00044d2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:260
	/* 将当前main函数创建为线程 */
	make_main_thread();
c00044d5:	e8 0a fc ff ff       	call   c00040e4 <make_main_thread>
/work/x86_os_my/thread/thread.c:262
	/* 创建idle线程 */
	idle_thread = thread_start("idle", 10, idle, NULL);
c00044da:	6a 00                	push   $0x0
c00044dc:	68 1a 3e 00 c0       	push   $0xc0003e1a
c00044e1:	6a 0a                	push   $0xa
c00044e3:	68 b5 92 00 c0       	push   $0xc00092b5
c00044e8:	e8 18 fb ff ff       	call   c0004005 <thread_start>
c00044ed:	83 c4 10             	add    $0x10,%esp
c00044f0:	a3 ac cb 00 c0       	mov    %eax,0xc000cbac
/work/x86_os_my/thread/thread.c:263
	put_str("thread_init done\n");
c00044f5:	83 ec 0c             	sub    $0xc,%esp
c00044f8:	68 ba 92 00 c0       	push   $0xc00092ba
c00044fd:	e8 be df ff ff       	call   c00024c0 <put_str>
c0004502:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:264
}
c0004505:	90                   	nop
c0004506:	c9                   	leave  
c0004507:	c3                   	ret    

c0004508 <list_init>:
list_init():
/work/x86_os_my/lib/kernel/list.c:6
#include "list.h"
#include "interrupt.h"
/* 注意关中断的操作：临界区 */

/* 初始化双向链表list */
void list_init (struct list* list) {
c0004508:	55                   	push   %ebp
c0004509:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/lib/kernel/list.c:7
	list->head.prev = NULL;
c000450b:	8b 45 08             	mov    0x8(%ebp),%eax
c000450e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/lib/kernel/list.c:8
	list->head.next = &list->tail;
c0004514:	8b 45 08             	mov    0x8(%ebp),%eax
c0004517:	8d 50 08             	lea    0x8(%eax),%edx
c000451a:	8b 45 08             	mov    0x8(%ebp),%eax
c000451d:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:9
	list->tail.prev = &list->head;
c0004520:	8b 55 08             	mov    0x8(%ebp),%edx
c0004523:	8b 45 08             	mov    0x8(%ebp),%eax
c0004526:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/lib/kernel/list.c:10
	list->tail.next = NULL;
c0004529:	8b 45 08             	mov    0x8(%ebp),%eax
c000452c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/lib/kernel/list.c:11
}
c0004533:	90                   	nop
c0004534:	5d                   	pop    %ebp
c0004535:	c3                   	ret    

c0004536 <list_insert_before>:
list_insert_before():
/work/x86_os_my/lib/kernel/list.c:14

/* 把链表元素elem插入在元素before之前 */
void list_insert_before(struct list_elem* before, struct list_elem* elem) { 
c0004536:	55                   	push   %ebp
c0004537:	89 e5                	mov    %esp,%ebp
c0004539:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:15
	enum intr_status old_status = intr_disable();
c000453c:	e8 52 d7 ff ff       	call   c0001c93 <intr_disable>
c0004541:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:18

	/* 将before前驱元素的后继元素更新为elem, 暂时使before脱离链表*/ 
	before->prev->next = elem; 
c0004544:	8b 45 08             	mov    0x8(%ebp),%eax
c0004547:	8b 00                	mov    (%eax),%eax
c0004549:	8b 55 0c             	mov    0xc(%ebp),%edx
c000454c:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:22

	/* 更新elem自己的前驱结点为before的前驱,
	* 更新elem自己的后继结点为before, 于是before又回到链表 */
	elem->prev = before->prev;
c000454f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004552:	8b 10                	mov    (%eax),%edx
c0004554:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004557:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:23
	elem->next = before;
c0004559:	8b 45 0c             	mov    0xc(%ebp),%eax
c000455c:	8b 55 08             	mov    0x8(%ebp),%edx
c000455f:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:26

	/* 更新before的前驱结点为elem */
	before->prev = elem;
c0004562:	8b 45 08             	mov    0x8(%ebp),%eax
c0004565:	8b 55 0c             	mov    0xc(%ebp),%edx
c0004568:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:28

	intr_set_status(old_status);
c000456a:	83 ec 0c             	sub    $0xc,%esp
c000456d:	ff 75 f4             	pushl  -0xc(%ebp)
c0004570:	e8 47 d7 ff ff       	call   c0001cbc <intr_set_status>
c0004575:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:29
}
c0004578:	90                   	nop
c0004579:	c9                   	leave  
c000457a:	c3                   	ret    

c000457b <list_push>:
list_push():
/work/x86_os_my/lib/kernel/list.c:32

/* 添加元素到列表队首,类似栈push操作 */
void list_push(struct list* plist, struct list_elem* elem) {
c000457b:	55                   	push   %ebp
c000457c:	89 e5                	mov    %esp,%ebp
c000457e:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/list.c:33
	list_insert_before(plist->head.next, elem); // 在队头插入elem
c0004581:	8b 45 08             	mov    0x8(%ebp),%eax
c0004584:	8b 40 04             	mov    0x4(%eax),%eax
c0004587:	83 ec 08             	sub    $0x8,%esp
c000458a:	ff 75 0c             	pushl  0xc(%ebp)
c000458d:	50                   	push   %eax
c000458e:	e8 a3 ff ff ff       	call   c0004536 <list_insert_before>
c0004593:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:34
}
c0004596:	90                   	nop
c0004597:	c9                   	leave  
c0004598:	c3                   	ret    

c0004599 <list_append>:
list_append():
/work/x86_os_my/lib/kernel/list.c:37

/* 追加元素到链表队尾,类似队列的先进先出操作 */
void list_append(struct list* plist, struct list_elem* elem) {
c0004599:	55                   	push   %ebp
c000459a:	89 e5                	mov    %esp,%ebp
c000459c:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/list.c:38
	list_insert_before(&plist->tail, elem);     // 在队尾的前面插入
c000459f:	8b 45 08             	mov    0x8(%ebp),%eax
c00045a2:	83 c0 08             	add    $0x8,%eax
c00045a5:	83 ec 08             	sub    $0x8,%esp
c00045a8:	ff 75 0c             	pushl  0xc(%ebp)
c00045ab:	50                   	push   %eax
c00045ac:	e8 85 ff ff ff       	call   c0004536 <list_insert_before>
c00045b1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:39
}
c00045b4:	90                   	nop
c00045b5:	c9                   	leave  
c00045b6:	c3                   	ret    

c00045b7 <list_remove>:
list_remove():
/work/x86_os_my/lib/kernel/list.c:42

/* 使元素pelem脱离链表 */
void list_remove(struct list_elem* pelem) {
c00045b7:	55                   	push   %ebp
c00045b8:	89 e5                	mov    %esp,%ebp
c00045ba:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:43
	enum intr_status old_status = intr_disable();
c00045bd:	e8 d1 d6 ff ff       	call   c0001c93 <intr_disable>
c00045c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:45

	pelem->prev->next = pelem->next;
c00045c5:	8b 45 08             	mov    0x8(%ebp),%eax
c00045c8:	8b 00                	mov    (%eax),%eax
c00045ca:	8b 55 08             	mov    0x8(%ebp),%edx
c00045cd:	8b 52 04             	mov    0x4(%edx),%edx
c00045d0:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:46
	pelem->next->prev = pelem->prev;
c00045d3:	8b 45 08             	mov    0x8(%ebp),%eax
c00045d6:	8b 40 04             	mov    0x4(%eax),%eax
c00045d9:	8b 55 08             	mov    0x8(%ebp),%edx
c00045dc:	8b 12                	mov    (%edx),%edx
c00045de:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:48

	intr_set_status(old_status);
c00045e0:	83 ec 0c             	sub    $0xc,%esp
c00045e3:	ff 75 f4             	pushl  -0xc(%ebp)
c00045e6:	e8 d1 d6 ff ff       	call   c0001cbc <intr_set_status>
c00045eb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:49
}
c00045ee:	90                   	nop
c00045ef:	c9                   	leave  
c00045f0:	c3                   	ret    

c00045f1 <list_pop>:
list_pop():
/work/x86_os_my/lib/kernel/list.c:52

/* 将链表第一个元素弹出并返回,类似栈的pop操作 */
struct list_elem* list_pop(struct list* plist) {
c00045f1:	55                   	push   %ebp
c00045f2:	89 e5                	mov    %esp,%ebp
c00045f4:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:53
	struct list_elem* elem = plist->head.next;
c00045f7:	8b 45 08             	mov    0x8(%ebp),%eax
c00045fa:	8b 40 04             	mov    0x4(%eax),%eax
c00045fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:54
	list_remove(elem);
c0004600:	83 ec 0c             	sub    $0xc,%esp
c0004603:	ff 75 f4             	pushl  -0xc(%ebp)
c0004606:	e8 ac ff ff ff       	call   c00045b7 <list_remove>
c000460b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:55
	return elem;
c000460e:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/kernel/list.c:56
} 
c0004611:	c9                   	leave  
c0004612:	c3                   	ret    

c0004613 <elem_find>:
elem_find():
/work/x86_os_my/lib/kernel/list.c:59

/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */
bool elem_find(struct list* plist, struct list_elem* obj_elem) {
c0004613:	55                   	push   %ebp
c0004614:	89 e5                	mov    %esp,%ebp
c0004616:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:60
	struct list_elem* elem = plist->head.next;
c0004619:	8b 45 08             	mov    0x8(%ebp),%eax
c000461c:	8b 40 04             	mov    0x4(%eax),%eax
c000461f:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:61
	while (elem != &plist->tail) {
c0004622:	eb 18                	jmp    c000463c <elem_find+0x29>
/work/x86_os_my/lib/kernel/list.c:62
	if (elem == obj_elem) {
c0004624:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004627:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000462a:	75 07                	jne    c0004633 <elem_find+0x20>
/work/x86_os_my/lib/kernel/list.c:63
		return true;
c000462c:	b8 01 00 00 00       	mov    $0x1,%eax
c0004631:	eb 19                	jmp    c000464c <elem_find+0x39>
/work/x86_os_my/lib/kernel/list.c:65
	}
		elem = elem->next;
c0004633:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004636:	8b 40 04             	mov    0x4(%eax),%eax
c0004639:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:61
} 

/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */
bool elem_find(struct list* plist, struct list_elem* obj_elem) {
	struct list_elem* elem = plist->head.next;
	while (elem != &plist->tail) {
c000463c:	8b 45 08             	mov    0x8(%ebp),%eax
c000463f:	83 c0 08             	add    $0x8,%eax
c0004642:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c0004645:	75 dd                	jne    c0004624 <elem_find+0x11>
/work/x86_os_my/lib/kernel/list.c:67
	if (elem == obj_elem) {
		return true;
	}
		elem = elem->next;
	}
	return false;
c0004647:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/kernel/list.c:68
}
c000464c:	c9                   	leave  
c000464d:	c3                   	ret    

c000464e <list_traversal>:
list_traversal():
/work/x86_os_my/lib/kernel/list.c:74

/* 把列表plist中的每个元素elem和arg传给回调函数func,
 * arg给func用来判断elem是否符合条件.
 * 本函数的功能是遍历列表内所有元素,逐个判断是否有符合条件的元素。
 * 找到符合条件的元素返回元素指针,否则返回NULL. */
struct list_elem* list_traversal(struct list* plist, function func, int arg) {
c000464e:	55                   	push   %ebp
c000464f:	89 e5                	mov    %esp,%ebp
c0004651:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:75
	struct list_elem* elem = plist->head.next;
c0004654:	8b 45 08             	mov    0x8(%ebp),%eax
c0004657:	8b 40 04             	mov    0x4(%eax),%eax
c000465a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:77
	/* 如果队列为空,就必然没有符合条件的结点,故直接返回NULL */
	if (list_empty(plist)) { 
c000465d:	83 ec 0c             	sub    $0xc,%esp
c0004660:	ff 75 08             	pushl  0x8(%ebp)
c0004663:	e8 78 00 00 00       	call   c00046e0 <list_empty>
c0004668:	83 c4 10             	add    $0x10,%esp
c000466b:	85 c0                	test   %eax,%eax
c000466d:	74 2a                	je     c0004699 <list_traversal+0x4b>
/work/x86_os_my/lib/kernel/list.c:78
		return NULL;
c000466f:	b8 00 00 00 00       	mov    $0x0,%eax
c0004674:	eb 33                	jmp    c00046a9 <list_traversal+0x5b>
/work/x86_os_my/lib/kernel/list.c:82
	}

	while (elem != &plist->tail) {
	if (func(elem, arg)) {		// func返回ture则认为该元素在回调函数中符合条件,命中,故停止继续遍历
c0004676:	83 ec 08             	sub    $0x8,%esp
c0004679:	ff 75 10             	pushl  0x10(%ebp)
c000467c:	ff 75 f4             	pushl  -0xc(%ebp)
c000467f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004682:	ff d0                	call   *%eax
c0004684:	83 c4 10             	add    $0x10,%esp
c0004687:	85 c0                	test   %eax,%eax
c0004689:	74 05                	je     c0004690 <list_traversal+0x42>
/work/x86_os_my/lib/kernel/list.c:83
		return elem;
c000468b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000468e:	eb 19                	jmp    c00046a9 <list_traversal+0x5b>
/work/x86_os_my/lib/kernel/list.c:85
	}
		elem = elem->next;		// 若回调函数func返回false,则继续遍历
c0004690:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004693:	8b 40 04             	mov    0x4(%eax),%eax
c0004696:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:81
	/* 如果队列为空,就必然没有符合条件的结点,故直接返回NULL */
	if (list_empty(plist)) { 
		return NULL;
	}

	while (elem != &plist->tail) {
c0004699:	8b 45 08             	mov    0x8(%ebp),%eax
c000469c:	83 c0 08             	add    $0x8,%eax
c000469f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00046a2:	75 d2                	jne    c0004676 <list_traversal+0x28>
/work/x86_os_my/lib/kernel/list.c:87
	if (func(elem, arg)) {		// func返回ture则认为该元素在回调函数中符合条件,命中,故停止继续遍历
		return elem;
	}
		elem = elem->next;		// 若回调函数func返回false,则继续遍历
	}
	return NULL;
c00046a4:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/kernel/list.c:88
}
c00046a9:	c9                   	leave  
c00046aa:	c3                   	ret    

c00046ab <list_len>:
list_len():
/work/x86_os_my/lib/kernel/list.c:91

/* 返回链表长度 */
uint32_t list_len(struct list* plist) {
c00046ab:	55                   	push   %ebp
c00046ac:	89 e5                	mov    %esp,%ebp
c00046ae:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:92
	struct list_elem* elem = plist->head.next;
c00046b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00046b4:	8b 40 04             	mov    0x4(%eax),%eax
c00046b7:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:93
	uint32_t length = 0;
c00046ba:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
/work/x86_os_my/lib/kernel/list.c:94
	while (elem != &plist->tail) {
c00046c1:	eb 0d                	jmp    c00046d0 <list_len+0x25>
/work/x86_os_my/lib/kernel/list.c:95
		length++; 
c00046c3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
/work/x86_os_my/lib/kernel/list.c:96
		elem = elem->next;
c00046c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00046ca:	8b 40 04             	mov    0x4(%eax),%eax
c00046cd:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:94

/* 返回链表长度 */
uint32_t list_len(struct list* plist) {
	struct list_elem* elem = plist->head.next;
	uint32_t length = 0;
	while (elem != &plist->tail) {
c00046d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00046d3:	83 c0 08             	add    $0x8,%eax
c00046d6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c00046d9:	75 e8                	jne    c00046c3 <list_len+0x18>
/work/x86_os_my/lib/kernel/list.c:98
		length++; 
		elem = elem->next;
	}
	return length;
c00046db:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/kernel/list.c:99
}
c00046de:	c9                   	leave  
c00046df:	c3                   	ret    

c00046e0 <list_empty>:
list_empty():
/work/x86_os_my/lib/kernel/list.c:102

/* 判断链表是否为空,空时返回true,否则返回false */
bool list_empty(struct list* plist) {		// 判断队列是否为空
c00046e0:	55                   	push   %ebp
c00046e1:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/lib/kernel/list.c:103
	return (plist->head.next == &plist->tail ? true : false);
c00046e3:	8b 45 08             	mov    0x8(%ebp),%eax
c00046e6:	8b 40 04             	mov    0x4(%eax),%eax
c00046e9:	8b 55 08             	mov    0x8(%ebp),%edx
c00046ec:	83 c2 08             	add    $0x8,%edx
c00046ef:	39 d0                	cmp    %edx,%eax
c00046f1:	0f 94 c0             	sete   %al
c00046f4:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/lib/kernel/list.c:104
}
c00046f7:	5d                   	pop    %ebp
c00046f8:	c3                   	ret    
c00046f9:	66 90                	xchg   %ax,%ax
c00046fb:	66 90                	xchg   %ax,%ax
c00046fd:	66 90                	xchg   %ax,%ax
c00046ff:	90                   	nop

c0004700 <switch_to>:
switch_to():
c0004700:	56                   	push   %esi
c0004701:	57                   	push   %edi
c0004702:	53                   	push   %ebx
c0004703:	55                   	push   %ebp
c0004704:	8b 44 24 14          	mov    0x14(%esp),%eax
c0004708:	89 20                	mov    %esp,(%eax)
c000470a:	8b 44 24 18          	mov    0x18(%esp),%eax
c000470e:	8b 20                	mov    (%eax),%esp
c0004710:	5d                   	pop    %ebp
c0004711:	5b                   	pop    %ebx
c0004712:	5f                   	pop    %edi
c0004713:	5e                   	pop    %esi
c0004714:	c3                   	ret    

c0004715 <console_init>:
console_init():
/work/x86_os_my/device/console.c:9
#include "sync.h"
#include "thread.h"
static struct lock console_lock;	// 控制台锁

/* 初始化终端 */
void console_init() {
c0004715:	55                   	push   %ebp
c0004716:	89 e5                	mov    %esp,%ebp
c0004718:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:10
	lock_init(&console_lock);
c000471b:	83 ec 0c             	sub    $0xc,%esp
c000471e:	68 70 c5 00 c0       	push   $0xc000c570
c0004723:	e8 cd 00 00 00       	call   c00047f5 <lock_init>
c0004728:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:11
}
c000472b:	90                   	nop
c000472c:	c9                   	leave  
c000472d:	c3                   	ret    

c000472e <console_acquire>:
console_acquire():
/work/x86_os_my/device/console.c:14

/* 获取终端 */
void console_acquire() {
c000472e:	55                   	push   %ebp
c000472f:	89 e5                	mov    %esp,%ebp
c0004731:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:15
	lock_acquire(&console_lock);
c0004734:	83 ec 0c             	sub    $0xc,%esp
c0004737:	68 70 c5 00 c0       	push   $0xc000c570
c000473c:	e8 8e 02 00 00       	call   c00049cf <lock_acquire>
c0004741:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:16
}
c0004744:	90                   	nop
c0004745:	c9                   	leave  
c0004746:	c3                   	ret    

c0004747 <console_release>:
console_release():
/work/x86_os_my/device/console.c:19

/* 释放终端 */
void console_release() {
c0004747:	55                   	push   %ebp
c0004748:	89 e5                	mov    %esp,%ebp
c000474a:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:20
	lock_release(&console_lock);
c000474d:	83 ec 0c             	sub    $0xc,%esp
c0004750:	68 70 c5 00 c0       	push   $0xc000c570
c0004755:	e8 ec 02 00 00       	call   c0004a46 <lock_release>
c000475a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:21
}
c000475d:	90                   	nop
c000475e:	c9                   	leave  
c000475f:	c3                   	ret    

c0004760 <console_put_str>:
console_put_str():
/work/x86_os_my/device/console.c:24

/* 终端中输出字符串 */
void console_put_str(char* str) {
c0004760:	55                   	push   %ebp
c0004761:	89 e5                	mov    %esp,%ebp
c0004763:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:25
	console_acquire();
c0004766:	e8 c3 ff ff ff       	call   c000472e <console_acquire>
/work/x86_os_my/device/console.c:26
	put_str(str);
c000476b:	83 ec 0c             	sub    $0xc,%esp
c000476e:	ff 75 08             	pushl  0x8(%ebp)
c0004771:	e8 4a dd ff ff       	call   c00024c0 <put_str>
c0004776:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:27
	console_release();
c0004779:	e8 c9 ff ff ff       	call   c0004747 <console_release>
/work/x86_os_my/device/console.c:28
}
c000477e:	90                   	nop
c000477f:	c9                   	leave  
c0004780:	c3                   	ret    

c0004781 <console_put_char>:
console_put_char():
/work/x86_os_my/device/console.c:31

/* 终端中输出字符 */
void console_put_char(uint8_t char_asci) {
c0004781:	55                   	push   %ebp
c0004782:	89 e5                	mov    %esp,%ebp
c0004784:	83 ec 18             	sub    $0x18,%esp
c0004787:	8b 45 08             	mov    0x8(%ebp),%eax
c000478a:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/console.c:32
	console_acquire();
c000478d:	e8 9c ff ff ff       	call   c000472e <console_acquire>
/work/x86_os_my/device/console.c:33
	put_char(char_asci);
c0004792:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0004796:	83 ec 0c             	sub    $0xc,%esp
c0004799:	50                   	push   %eax
c000479a:	e8 3f dd ff ff       	call   c00024de <put_char>
c000479f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:34
	console_release();
c00047a2:	e8 a0 ff ff ff       	call   c0004747 <console_release>
/work/x86_os_my/device/console.c:35
}
c00047a7:	90                   	nop
c00047a8:	c9                   	leave  
c00047a9:	c3                   	ret    

c00047aa <console_put_int>:
console_put_int():
/work/x86_os_my/device/console.c:38

/* 终端中输出16进制整数 */
void console_put_int(uint32_t num) {
c00047aa:	55                   	push   %ebp
c00047ab:	89 e5                	mov    %esp,%ebp
c00047ad:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:39
	console_acquire();
c00047b0:	e8 79 ff ff ff       	call   c000472e <console_acquire>
/work/x86_os_my/device/console.c:40
	put_int(num);
c00047b5:	83 ec 0c             	sub    $0xc,%esp
c00047b8:	ff 75 08             	pushl  0x8(%ebp)
c00047bb:	e8 eb dd ff ff       	call   c00025ab <put_int>
c00047c0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:41
	console_release();
c00047c3:	e8 7f ff ff ff       	call   c0004747 <console_release>
/work/x86_os_my/device/console.c:42
}
c00047c8:	90                   	nop
c00047c9:	c9                   	leave  
c00047ca:	c3                   	ret    

c00047cb <sema_init>:
sema_init():
/work/x86_os_my/thread/sync.c:8
#include "global.h"
#include "debug.h"
#include "interrupt.h"

/* 初始化信号量 */
void sema_init(struct semaphore* psema, uint8_t value) {
c00047cb:	55                   	push   %ebp
c00047cc:	89 e5                	mov    %esp,%ebp
c00047ce:	83 ec 18             	sub    $0x18,%esp
c00047d1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00047d4:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:9
	psema->value = value;       // 为信号量赋初值
c00047d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00047da:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c00047de:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:10
	list_init(&psema->waiters); //初始化信号量的等待队列
c00047e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00047e3:	83 c0 04             	add    $0x4,%eax
c00047e6:	83 ec 0c             	sub    $0xc,%esp
c00047e9:	50                   	push   %eax
c00047ea:	e8 19 fd ff ff       	call   c0004508 <list_init>
c00047ef:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:11
}
c00047f2:	90                   	nop
c00047f3:	c9                   	leave  
c00047f4:	c3                   	ret    

c00047f5 <lock_init>:
lock_init():
/work/x86_os_my/thread/sync.c:14

/* 初始化锁plock */
void lock_init(struct lock* plock) {
c00047f5:	55                   	push   %ebp
c00047f6:	89 e5                	mov    %esp,%ebp
c00047f8:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/sync.c:15
	plock->holder = NULL;
c00047fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00047fe:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:16
	plock->holder_repeat_nr = 0;
c0004804:	8b 45 08             	mov    0x8(%ebp),%eax
c0004807:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:17
	sema_init(&plock->semaphore, 1);  // 信号量初值为1
c000480e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004811:	83 c0 04             	add    $0x4,%eax
c0004814:	83 ec 08             	sub    $0x8,%esp
c0004817:	6a 01                	push   $0x1
c0004819:	50                   	push   %eax
c000481a:	e8 ac ff ff ff       	call   c00047cb <sema_init>
c000481f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:18
}
c0004822:	90                   	nop
c0004823:	c9                   	leave  
c0004824:	c3                   	ret    

c0004825 <sema_down>:
sema_down():
/work/x86_os_my/thread/sync.c:21

/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
c0004825:	55                   	push   %ebp
c0004826:	89 e5                	mov    %esp,%ebp
c0004828:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:23
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
c000482b:	e8 63 d4 ff ff       	call   c0001c93 <intr_disable>
c0004830:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:25
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c0004833:	e9 98 00 00 00       	jmp    c00048d0 <sema_down+0xab>
/work/x86_os_my/thread/sync.c:26
		ASSERT(!elem_find(&psema->waiters, &running_thread()->general_tag));
c0004838:	e8 f4 f5 ff ff       	call   c0003e31 <running_thread>
c000483d:	8d 50 44             	lea    0x44(%eax),%edx
c0004840:	8b 45 08             	mov    0x8(%ebp),%eax
c0004843:	83 c0 04             	add    $0x4,%eax
c0004846:	83 ec 08             	sub    $0x8,%esp
c0004849:	52                   	push   %edx
c000484a:	50                   	push   %eax
c000484b:	e8 c3 fd ff ff       	call   c0004613 <elem_find>
c0004850:	83 c4 10             	add    $0x10,%esp
c0004853:	85 c0                	test   %eax,%eax
c0004855:	74 19                	je     c0004870 <sema_down+0x4b>
/work/x86_os_my/thread/sync.c:26 (discriminator 1)
c0004857:	68 2c 93 00 c0       	push   $0xc000932c
c000485c:	68 30 94 00 c0       	push   $0xc0009430
c0004861:	6a 1a                	push   $0x1a
c0004863:	68 68 93 00 c0       	push   $0xc0009368
c0004868:	e8 c5 dd ff ff       	call   c0002632 <panic_spin>
c000486d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:28
		/* 当前线程不应该已在信号量的waiters队列中 */
		if (elem_find(&psema->waiters, &running_thread()->general_tag)) {
c0004870:	e8 bc f5 ff ff       	call   c0003e31 <running_thread>
c0004875:	8d 50 44             	lea    0x44(%eax),%edx
c0004878:	8b 45 08             	mov    0x8(%ebp),%eax
c000487b:	83 c0 04             	add    $0x4,%eax
c000487e:	83 ec 08             	sub    $0x8,%esp
c0004881:	52                   	push   %edx
c0004882:	50                   	push   %eax
c0004883:	e8 8b fd ff ff       	call   c0004613 <elem_find>
c0004888:	83 c4 10             	add    $0x10,%esp
c000488b:	85 c0                	test   %eax,%eax
c000488d:	74 19                	je     c00048a8 <sema_down+0x83>
/work/x86_os_my/thread/sync.c:29
			PANIC("sema_down: thread blocked has been in waiters_list\n");
c000488f:	68 78 93 00 c0       	push   $0xc0009378
c0004894:	68 30 94 00 c0       	push   $0xc0009430
c0004899:	6a 1d                	push   $0x1d
c000489b:	68 68 93 00 c0       	push   $0xc0009368
c00048a0:	e8 8d dd ff ff       	call   c0002632 <panic_spin>
c00048a5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:32
		}
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
c00048a8:	e8 84 f5 ff ff       	call   c0003e31 <running_thread>
c00048ad:	8d 50 44             	lea    0x44(%eax),%edx
c00048b0:	8b 45 08             	mov    0x8(%ebp),%eax
c00048b3:	83 c0 04             	add    $0x4,%eax
c00048b6:	83 ec 08             	sub    $0x8,%esp
c00048b9:	52                   	push   %edx
c00048ba:	50                   	push   %eax
c00048bb:	e8 d9 fc ff ff       	call   c0004599 <list_append>
c00048c0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:33
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
c00048c3:	83 ec 0c             	sub    $0xc,%esp
c00048c6:	6a 02                	push   $0x2
c00048c8:	e8 e1 f9 ff ff       	call   c00042ae <thread_block>
c00048cd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:25
/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c00048d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00048d3:	0f b6 00             	movzbl (%eax),%eax
c00048d6:	84 c0                	test   %al,%al
c00048d8:	0f 84 5a ff ff ff    	je     c0004838 <sema_down+0x13>
/work/x86_os_my/thread/sync.c:36
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
	}
	/* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*/
	psema->value--;
c00048de:	8b 45 08             	mov    0x8(%ebp),%eax
c00048e1:	0f b6 00             	movzbl (%eax),%eax
c00048e4:	8d 50 ff             	lea    -0x1(%eax),%edx
c00048e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00048ea:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:37
	ASSERT(psema->value == 0);
c00048ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00048ef:	0f b6 00             	movzbl (%eax),%eax
c00048f2:	84 c0                	test   %al,%al
c00048f4:	74 19                	je     c000490f <sema_down+0xea>
/work/x86_os_my/thread/sync.c:37 (discriminator 1)
c00048f6:	68 ac 93 00 c0       	push   $0xc00093ac
c00048fb:	68 30 94 00 c0       	push   $0xc0009430
c0004900:	6a 25                	push   $0x25
c0004902:	68 68 93 00 c0       	push   $0xc0009368
c0004907:	e8 26 dd ff ff       	call   c0002632 <panic_spin>
c000490c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:40
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c000490f:	83 ec 0c             	sub    $0xc,%esp
c0004912:	ff 75 f4             	pushl  -0xc(%ebp)
c0004915:	e8 a2 d3 ff ff       	call   c0001cbc <intr_set_status>
c000491a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:41
}
c000491d:	90                   	nop
c000491e:	c9                   	leave  
c000491f:	c3                   	ret    

c0004920 <sema_up>:
sema_up():
/work/x86_os_my/thread/sync.c:44

/* 信号量的up操作 */
void sema_up(struct semaphore* psema) {
c0004920:	55                   	push   %ebp
c0004921:	89 e5                	mov    %esp,%ebp
c0004923:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:46
	/* 关中断,保证原子操作 */
	enum intr_status old_status = intr_disable();
c0004926:	e8 68 d3 ff ff       	call   c0001c93 <intr_disable>
c000492b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:48
	
	ASSERT(psema->value == 0);
c000492e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004931:	0f b6 00             	movzbl (%eax),%eax
c0004934:	84 c0                	test   %al,%al
c0004936:	74 19                	je     c0004951 <sema_up+0x31>
/work/x86_os_my/thread/sync.c:48 (discriminator 1)
c0004938:	68 ac 93 00 c0       	push   $0xc00093ac
c000493d:	68 3c 94 00 c0       	push   $0xc000943c
c0004942:	6a 30                	push   $0x30
c0004944:	68 68 93 00 c0       	push   $0xc0009368
c0004949:	e8 e4 dc ff ff       	call   c0002632 <panic_spin>
c000494e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:49
	if (!list_empty(&psema->waiters)) {
c0004951:	8b 45 08             	mov    0x8(%ebp),%eax
c0004954:	83 c0 04             	add    $0x4,%eax
c0004957:	83 ec 0c             	sub    $0xc,%esp
c000495a:	50                   	push   %eax
c000495b:	e8 80 fd ff ff       	call   c00046e0 <list_empty>
c0004960:	83 c4 10             	add    $0x10,%esp
c0004963:	85 c0                	test   %eax,%eax
c0004965:	75 26                	jne    c000498d <sema_up+0x6d>
/work/x86_os_my/thread/sync.c:50
		struct task_struct* thread_blocked = elem2entry(struct task_struct, general_tag, list_pop(&psema->waiters));
c0004967:	8b 45 08             	mov    0x8(%ebp),%eax
c000496a:	83 c0 04             	add    $0x4,%eax
c000496d:	83 ec 0c             	sub    $0xc,%esp
c0004970:	50                   	push   %eax
c0004971:	e8 7b fc ff ff       	call   c00045f1 <list_pop>
c0004976:	83 c4 10             	add    $0x10,%esp
c0004979:	83 e8 44             	sub    $0x44,%eax
c000497c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/sync.c:51
		thread_unblock(thread_blocked);
c000497f:	83 ec 0c             	sub    $0xc,%esp
c0004982:	ff 75 f0             	pushl  -0x10(%ebp)
c0004985:	e8 87 f9 ff ff       	call   c0004311 <thread_unblock>
c000498a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:53
	}
	psema->value++;
c000498d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004990:	0f b6 00             	movzbl (%eax),%eax
c0004993:	8d 50 01             	lea    0x1(%eax),%edx
c0004996:	8b 45 08             	mov    0x8(%ebp),%eax
c0004999:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:54
	ASSERT(psema->value == 1);
c000499b:	8b 45 08             	mov    0x8(%ebp),%eax
c000499e:	0f b6 00             	movzbl (%eax),%eax
c00049a1:	3c 01                	cmp    $0x1,%al
c00049a3:	74 19                	je     c00049be <sema_up+0x9e>
/work/x86_os_my/thread/sync.c:54 (discriminator 1)
c00049a5:	68 be 93 00 c0       	push   $0xc00093be
c00049aa:	68 3c 94 00 c0       	push   $0xc000943c
c00049af:	6a 36                	push   $0x36
c00049b1:	68 68 93 00 c0       	push   $0xc0009368
c00049b6:	e8 77 dc ff ff       	call   c0002632 <panic_spin>
c00049bb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:57
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c00049be:	83 ec 0c             	sub    $0xc,%esp
c00049c1:	ff 75 f4             	pushl  -0xc(%ebp)
c00049c4:	e8 f3 d2 ff ff       	call   c0001cbc <intr_set_status>
c00049c9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:58
}
c00049cc:	90                   	nop
c00049cd:	c9                   	leave  
c00049ce:	c3                   	ret    

c00049cf <lock_acquire>:
lock_acquire():
/work/x86_os_my/thread/sync.c:61

/* 获取锁plock */
void lock_acquire(struct lock* plock) {
c00049cf:	55                   	push   %ebp
c00049d0:	89 e5                	mov    %esp,%ebp
c00049d2:	53                   	push   %ebx
c00049d3:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:63
	/* 排除曾经自己已经持有锁但还未将其释放的情况。*/
	if (plock->holder != running_thread()) {
c00049d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00049d9:	8b 18                	mov    (%eax),%ebx
c00049db:	e8 51 f4 ff ff       	call   c0003e31 <running_thread>
c00049e0:	39 c3                	cmp    %eax,%ebx
c00049e2:	74 4d                	je     c0004a31 <lock_acquire+0x62>
/work/x86_os_my/thread/sync.c:64
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
c00049e4:	8b 45 08             	mov    0x8(%ebp),%eax
c00049e7:	83 c0 04             	add    $0x4,%eax
c00049ea:	83 ec 0c             	sub    $0xc,%esp
c00049ed:	50                   	push   %eax
c00049ee:	e8 32 fe ff ff       	call   c0004825 <sema_down>
c00049f3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:65
		plock->holder = running_thread();
c00049f6:	e8 36 f4 ff ff       	call   c0003e31 <running_thread>
c00049fb:	89 c2                	mov    %eax,%edx
c00049fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a00:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/sync.c:66
		ASSERT(plock->holder_repeat_nr == 0);
c0004a02:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a05:	8b 40 18             	mov    0x18(%eax),%eax
c0004a08:	85 c0                	test   %eax,%eax
c0004a0a:	74 19                	je     c0004a25 <lock_acquire+0x56>
/work/x86_os_my/thread/sync.c:66 (discriminator 1)
c0004a0c:	68 d0 93 00 c0       	push   $0xc00093d0
c0004a11:	68 44 94 00 c0       	push   $0xc0009444
c0004a16:	6a 42                	push   $0x42
c0004a18:	68 68 93 00 c0       	push   $0xc0009368
c0004a1d:	e8 10 dc ff ff       	call   c0002632 <panic_spin>
c0004a22:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:67
		plock->holder_repeat_nr = 1;
c0004a25:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a28:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	} else {
		plock->holder_repeat_nr++;
	}
}
c0004a2f:	eb 0f                	jmp    c0004a40 <lock_acquire+0x71>
/work/x86_os_my/thread/sync.c:69
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
		plock->holder = running_thread();
		ASSERT(plock->holder_repeat_nr == 0);
		plock->holder_repeat_nr = 1;
	} else {
		plock->holder_repeat_nr++;
c0004a31:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a34:	8b 40 18             	mov    0x18(%eax),%eax
c0004a37:	8d 50 01             	lea    0x1(%eax),%edx
c0004a3a:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a3d:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	}
}
c0004a40:	90                   	nop
c0004a41:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0004a44:	c9                   	leave  
c0004a45:	c3                   	ret    

c0004a46 <lock_release>:
lock_release():
/work/x86_os_my/thread/sync.c:74

/* 释放锁plock */
void lock_release(struct lock* plock) {
c0004a46:	55                   	push   %ebp
c0004a47:	89 e5                	mov    %esp,%ebp
c0004a49:	53                   	push   %ebx
c0004a4a:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:75
	ASSERT(plock->holder == running_thread());
c0004a4d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a50:	8b 18                	mov    (%eax),%ebx
c0004a52:	e8 da f3 ff ff       	call   c0003e31 <running_thread>
c0004a57:	39 c3                	cmp    %eax,%ebx
c0004a59:	74 19                	je     c0004a74 <lock_release+0x2e>
/work/x86_os_my/thread/sync.c:75 (discriminator 1)
c0004a5b:	68 f0 93 00 c0       	push   $0xc00093f0
c0004a60:	68 54 94 00 c0       	push   $0xc0009454
c0004a65:	6a 4b                	push   $0x4b
c0004a67:	68 68 93 00 c0       	push   $0xc0009368
c0004a6c:	e8 c1 db ff ff       	call   c0002632 <panic_spin>
c0004a71:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:76
	if (plock->holder_repeat_nr > 1) {
c0004a74:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a77:	8b 40 18             	mov    0x18(%eax),%eax
c0004a7a:	83 f8 01             	cmp    $0x1,%eax
c0004a7d:	76 11                	jbe    c0004a90 <lock_release+0x4a>
/work/x86_os_my/thread/sync.c:77
		plock->holder_repeat_nr--;
c0004a7f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a82:	8b 40 18             	mov    0x18(%eax),%eax
c0004a85:	8d 50 ff             	lea    -0x1(%eax),%edx
c0004a88:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a8b:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:78
		return;
c0004a8e:	eb 49                	jmp    c0004ad9 <lock_release+0x93>
/work/x86_os_my/thread/sync.c:80
	}
	ASSERT(plock->holder_repeat_nr == 1);
c0004a90:	8b 45 08             	mov    0x8(%ebp),%eax
c0004a93:	8b 40 18             	mov    0x18(%eax),%eax
c0004a96:	83 f8 01             	cmp    $0x1,%eax
c0004a99:	74 19                	je     c0004ab4 <lock_release+0x6e>
/work/x86_os_my/thread/sync.c:80 (discriminator 1)
c0004a9b:	68 12 94 00 c0       	push   $0xc0009412
c0004aa0:	68 54 94 00 c0       	push   $0xc0009454
c0004aa5:	6a 50                	push   $0x50
c0004aa7:	68 68 93 00 c0       	push   $0xc0009368
c0004aac:	e8 81 db ff ff       	call   c0002632 <panic_spin>
c0004ab1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:82

	plock->holder = NULL;			// 把锁的持有者置空放在V操作之前
c0004ab4:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ab7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:83
	plock->holder_repeat_nr = 0;
c0004abd:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ac0:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:84
	sema_up(&plock->semaphore);		// 信号量的V操作,也是原子操作
c0004ac7:	8b 45 08             	mov    0x8(%ebp),%eax
c0004aca:	83 c0 04             	add    $0x4,%eax
c0004acd:	83 ec 0c             	sub    $0xc,%esp
c0004ad0:	50                   	push   %eax
c0004ad1:	e8 4a fe ff ff       	call   c0004920 <sema_up>
c0004ad6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:85
}
c0004ad9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0004adc:	c9                   	leave  
c0004add:	c3                   	ret    

c0004ade <inb>:
inb():
/work/x86_os_my/lib/kernel/io.h:36
   asm volatile ("cld; rep outsw" : "+S" (addr), "+c" (word_cnt) : "d" (port));
/******************************************************/
}

/* 将从端口port读入的一个字节返回 */
static inline uint8_t inb(uint16_t port) {
c0004ade:	55                   	push   %ebp
c0004adf:	89 e5                	mov    %esp,%ebp
c0004ae1:	83 ec 14             	sub    $0x14,%esp
c0004ae4:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ae7:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/io.h:38
   uint8_t data;
   asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0004aeb:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0004aef:	89 c2                	mov    %eax,%edx
c0004af1:	ec                   	in     (%dx),%al
c0004af2:	88 45 ff             	mov    %al,-0x1(%ebp)
/work/x86_os_my/lib/kernel/io.h:39
   return data;
c0004af5:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
/work/x86_os_my/lib/kernel/io.h:40
}
c0004af9:	c9                   	leave  
c0004afa:	c3                   	ret    

c0004afb <intr_keyboard_handler>:
intr_keyboard_handler():
/work/x86_os_my/device/keyboard.c:111
/* 0x3A */	{caps_lock_char, caps_lock_char}
/*其它按键暂不处理*/
};

/* 键盘中断处理程序 */
static void intr_keyboard_handler(void) {
c0004afb:	55                   	push   %ebp
c0004afc:	89 e5                	mov    %esp,%ebp
c0004afe:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/device/keyboard.c:114

/* 这次中断发生前的上一次中断,以下任意三个键是否有按下 */
   bool ctrl_down_last = ctrl_status;	  
c0004b01:	a1 8c c5 00 c0       	mov    0xc000c58c,%eax
c0004b06:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/device/keyboard.c:115
   bool shift_down_last = shift_status;
c0004b09:	a1 90 c5 00 c0       	mov    0xc000c590,%eax
c0004b0e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/device/keyboard.c:116
   bool caps_lock_last = caps_lock_status;
c0004b11:	a1 98 c5 00 c0       	mov    0xc000c598,%eax
c0004b16:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/device/keyboard.c:119

   bool break_code;
   uint16_t scancode = inb(KBD_BUF_PORT);
c0004b19:	6a 60                	push   $0x60
c0004b1b:	e8 be ff ff ff       	call   c0004ade <inb>
c0004b20:	83 c4 04             	add    $0x4,%esp
c0004b23:	0f b6 c0             	movzbl %al,%eax
c0004b26:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:123

/* 若扫描码是e0开头的,表示此键的按下将产生多个扫描码,
 * 所以马上结束此次中断处理函数,等待下一个扫描码进来*/ 
   if (scancode == 0xe0) { 
c0004b2a:	66 81 7d f6 e0 00    	cmpw   $0xe0,-0xa(%ebp)
c0004b30:	75 0f                	jne    c0004b41 <intr_keyboard_handler+0x46>
/work/x86_os_my/device/keyboard.c:124
      ext_scancode = true;    // 打开e0标记
c0004b32:	c7 05 9c c5 00 c0 01 	movl   $0x1,0xc000c59c
c0004b39:	00 00 00 
/work/x86_os_my/device/keyboard.c:125
      return;
c0004b3c:	e9 50 02 00 00       	jmp    c0004d91 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:129
   }

/* 如果上次是以0xe0开头,将扫描码合并 */
   if (ext_scancode) {
c0004b41:	a1 9c c5 00 c0       	mov    0xc000c59c,%eax
c0004b46:	85 c0                	test   %eax,%eax
c0004b48:	74 10                	je     c0004b5a <intr_keyboard_handler+0x5f>
/work/x86_os_my/device/keyboard.c:130
      scancode = ((0xe000) | scancode);
c0004b4a:	66 81 4d f6 00 e0    	orw    $0xe000,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:131
      ext_scancode = false;   // 关闭e0标记
c0004b50:	c7 05 9c c5 00 c0 00 	movl   $0x0,0xc000c59c
c0004b57:	00 00 00 
/work/x86_os_my/device/keyboard.c:134
   }   

   break_code = ((scancode & 0x0080) != 0);   // 获取break_code
c0004b5a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0004b5e:	25 80 00 00 00       	and    $0x80,%eax
c0004b63:	85 c0                	test   %eax,%eax
c0004b65:	0f 95 c0             	setne  %al
c0004b68:	0f b6 c0             	movzbl %al,%eax
c0004b6b:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/device/keyboard.c:136
   
   if (break_code) {   // 若是断码break_code(按键弹起时产生的扫描码)
c0004b6e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0004b72:	74 6a                	je     c0004bde <intr_keyboard_handler+0xe3>
/work/x86_os_my/device/keyboard.c:140

   /* 由于ctrl_r 和alt_r的make_code和break_code都是两字节,
   所以可用下面的方法取make_code,多字节的扫描码暂不处理 */
      uint16_t make_code = (scancode &= 0xff7f);   // 得到其make_code(按键按下时产生的扫描码)
c0004b74:	66 81 65 f6 7f ff    	andw   $0xff7f,-0xa(%ebp)
c0004b7a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0004b7e:	66 89 45 da          	mov    %ax,-0x26(%ebp)
/work/x86_os_my/device/keyboard.c:143

   /* 若是任意以下三个键弹起了,将状态置为false */
      if (make_code == ctrl_l_make || make_code == ctrl_r_make) {
c0004b82:	66 83 7d da 1d       	cmpw   $0x1d,-0x26(%ebp)
c0004b87:	74 08                	je     c0004b91 <intr_keyboard_handler+0x96>
/work/x86_os_my/device/keyboard.c:143 (discriminator 1)
c0004b89:	66 81 7d da 1d e0    	cmpw   $0xe01d,-0x26(%ebp)
c0004b8f:	75 0c                	jne    c0004b9d <intr_keyboard_handler+0xa2>
/work/x86_os_my/device/keyboard.c:144
	 ctrl_status = false;
c0004b91:	c7 05 8c c5 00 c0 00 	movl   $0x0,0xc000c58c
c0004b98:	00 00 00 
c0004b9b:	eb 3c                	jmp    c0004bd9 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:145
      } else if (make_code == shift_l_make || make_code == shift_r_make) {
c0004b9d:	66 83 7d da 2a       	cmpw   $0x2a,-0x26(%ebp)
c0004ba2:	74 07                	je     c0004bab <intr_keyboard_handler+0xb0>
/work/x86_os_my/device/keyboard.c:145 (discriminator 1)
c0004ba4:	66 83 7d da 36       	cmpw   $0x36,-0x26(%ebp)
c0004ba9:	75 0c                	jne    c0004bb7 <intr_keyboard_handler+0xbc>
/work/x86_os_my/device/keyboard.c:146
	 shift_status = false;
c0004bab:	c7 05 90 c5 00 c0 00 	movl   $0x0,0xc000c590
c0004bb2:	00 00 00 
c0004bb5:	eb 22                	jmp    c0004bd9 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:147
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
c0004bb7:	66 83 7d da 38       	cmpw   $0x38,-0x26(%ebp)
c0004bbc:	74 0c                	je     c0004bca <intr_keyboard_handler+0xcf>
/work/x86_os_my/device/keyboard.c:147 (discriminator 1)
c0004bbe:	66 81 7d da 38 e0    	cmpw   $0xe038,-0x26(%ebp)
c0004bc4:	0f 85 c0 01 00 00    	jne    c0004d8a <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:148
	 alt_status = false;
c0004bca:	c7 05 94 c5 00 c0 00 	movl   $0x0,0xc000c594
c0004bd1:	00 00 00 
/work/x86_os_my/device/keyboard.c:151
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c0004bd4:	e9 b1 01 00 00       	jmp    c0004d8a <intr_keyboard_handler+0x28f>
c0004bd9:	e9 ac 01 00 00       	jmp    c0004d8a <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:155

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
c0004bde:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c0004be3:	74 07                	je     c0004bec <intr_keyboard_handler+0xf1>
/work/x86_os_my/device/keyboard.c:155 (discriminator 1)
c0004be5:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0004bea:	76 14                	jbe    c0004c00 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:155 (discriminator 3)
c0004bec:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c0004bf2:	74 0c                	je     c0004c00 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:156
	       (scancode == alt_r_make) || \
c0004bf4:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0004bfa:	0f 85 78 01 00 00    	jne    c0004d78 <intr_keyboard_handler+0x27d>
/work/x86_os_my/device/keyboard.c:158
	       (scancode == ctrl_r_make)) {
      bool shift = false;  // 判断是否与shift组合,用来在一维数组中索引对应的字符
c0004c00:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:159
      if ((scancode < 0x0e) || (scancode == 0x29) || \
c0004c07:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%ebp)
c0004c0c:	76 3f                	jbe    c0004c4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 1)
c0004c0e:	66 83 7d f6 29       	cmpw   $0x29,-0xa(%ebp)
c0004c13:	74 38                	je     c0004c4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 2)
c0004c15:	66 83 7d f6 1a       	cmpw   $0x1a,-0xa(%ebp)
c0004c1a:	74 31                	je     c0004c4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160
	 (scancode == 0x1a) || (scancode == 0x1b) || \
c0004c1c:	66 83 7d f6 1b       	cmpw   $0x1b,-0xa(%ebp)
c0004c21:	74 2a                	je     c0004c4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160 (discriminator 1)
c0004c23:	66 83 7d f6 2b       	cmpw   $0x2b,-0xa(%ebp)
c0004c28:	74 23                	je     c0004c4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161
	 (scancode == 0x2b) || (scancode == 0x27) || \
c0004c2a:	66 83 7d f6 27       	cmpw   $0x27,-0xa(%ebp)
c0004c2f:	74 1c                	je     c0004c4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161 (discriminator 1)
c0004c31:	66 83 7d f6 28       	cmpw   $0x28,-0xa(%ebp)
c0004c36:	74 15                	je     c0004c4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162
	 (scancode == 0x28) || (scancode == 0x33) || \
c0004c38:	66 83 7d f6 33       	cmpw   $0x33,-0xa(%ebp)
c0004c3d:	74 0e                	je     c0004c4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162 (discriminator 1)
c0004c3f:	66 83 7d f6 34       	cmpw   $0x34,-0xa(%ebp)
c0004c44:	74 07                	je     c0004c4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:163
	 (scancode == 0x34) || (scancode == 0x35)) {  
c0004c46:	66 83 7d f6 35       	cmpw   $0x35,-0xa(%ebp)
c0004c4b:	75 0f                	jne    c0004c5c <intr_keyboard_handler+0x161>
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c0004c4d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0004c51:	74 3a                	je     c0004c8d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:177
	    shift = true;
c0004c53:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c0004c5a:	eb 31                	jmp    c0004c8d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:180
	    shift = true;
	 }
      } else {	  // 默认为字母键
	 if (shift_down_last && caps_lock_last) {  // 如果shift和capslock同时按下
c0004c5c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0004c60:	74 0f                	je     c0004c71 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:180 (discriminator 1)
c0004c62:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0004c66:	74 09                	je     c0004c71 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:181
	    shift = false;
c0004c68:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0004c6f:	eb 1c                	jmp    c0004c8d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:182
	 } else if (shift_down_last || caps_lock_last) { // 如果shift和capslock任意被按下
c0004c71:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0004c75:	75 06                	jne    c0004c7d <intr_keyboard_handler+0x182>
/work/x86_os_my/device/keyboard.c:182 (discriminator 1)
c0004c77:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0004c7b:	74 09                	je     c0004c86 <intr_keyboard_handler+0x18b>
/work/x86_os_my/device/keyboard.c:183
	    shift = true;
c0004c7d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c0004c84:	eb 07                	jmp    c0004c8d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:185
	 } else {
	    shift = false;
c0004c86:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:189
	 }
      }

      uint8_t index = (scancode &= 0x00ff);  // 将扫描码的高字节置0,主要是针对高字节是e0的扫描码.
c0004c8d:	66 81 65 f6 ff 00    	andw   $0xff,-0xa(%ebp)
c0004c93:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0004c97:	88 45 d9             	mov    %al,-0x27(%ebp)
/work/x86_os_my/device/keyboard.c:190
      char cur_char = keymap[index][shift];  // 在数组中找到对应的字符
c0004c9a:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
c0004c9e:	8d 14 00             	lea    (%eax,%eax,1),%edx
c0004ca1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0004ca4:	01 d0                	add    %edx,%eax
c0004ca6:	05 e0 c0 00 c0       	add    $0xc000c0e0,%eax
c0004cab:	0f b6 00             	movzbl (%eax),%eax
c0004cae:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:193

   /* 如果cur_char不为0,也就是ascii码为除'\0'外的字符就加入键盘缓冲区中 */
      if (cur_char) {
c0004cb1:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c0004cb5:	74 54                	je     c0004d0b <intr_keyboard_handler+0x210>
/work/x86_os_my/device/keyboard.c:200
     /*****************  快捷键ctrl+l和ctrl+u的处理 *********************
      * 下面是把ctrl+l和ctrl+u这两种组合键产生的字符置为:
      * cur_char的asc码-字符a的asc码, 此差值比较小,
      * 属于asc码表中不可见的字符部分.故不会产生可见字符.
      * 我们在shell中将ascii值为l-a和u-a的分别处理为清屏和删除输入的快捷键*/
	 if ((ctrl_down_last && cur_char == 'l') || (ctrl_down_last && cur_char == 'u')) {
c0004cb7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0004cbb:	74 06                	je     c0004cc3 <intr_keyboard_handler+0x1c8>
/work/x86_os_my/device/keyboard.c:200 (discriminator 1)
c0004cbd:	80 7d ef 6c          	cmpb   $0x6c,-0x11(%ebp)
c0004cc1:	74 0c                	je     c0004ccf <intr_keyboard_handler+0x1d4>
/work/x86_os_my/device/keyboard.c:200 (discriminator 3)
c0004cc3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0004cc7:	74 10                	je     c0004cd9 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:200 (discriminator 4)
c0004cc9:	80 7d ef 75          	cmpb   $0x75,-0x11(%ebp)
c0004ccd:	75 0a                	jne    c0004cd9 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:201
	    cur_char -= 'a';
c0004ccf:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c0004cd3:	83 e8 61             	sub    $0x61,%eax
c0004cd6:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:207
	 }
      /****************************************************************/
      
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
c0004cd9:	83 ec 0c             	sub    $0xc,%esp
c0004cdc:	68 e0 cb 00 c0       	push   $0xc000cbe0
c0004ce1:	e8 58 01 00 00       	call   c0004e3e <ioq_full>
c0004ce6:	83 c4 10             	add    $0x10,%esp
c0004ce9:	85 c0                	test   %eax,%eax
c0004ceb:	0f 85 9c 00 00 00    	jne    c0004d8d <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:208
	    ioq_putchar(&kbd_buf, cur_char);
c0004cf1:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
c0004cf5:	83 ec 08             	sub    $0x8,%esp
c0004cf8:	50                   	push   %eax
c0004cf9:	68 e0 cb 00 c0       	push   $0xc000cbe0
c0004cfe:	e8 0d 03 00 00       	call   c0005010 <ioq_putchar>
c0004d03:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:210
	 }
	 return;
c0004d06:	e9 82 00 00 00       	jmp    c0004d8d <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:214
      }

      /* 记录本次是否按下了下面几类控制键之一,供下次键入时判断组合键 */
      if (scancode == ctrl_l_make || scancode == ctrl_r_make) {
c0004d0b:	66 83 7d f6 1d       	cmpw   $0x1d,-0xa(%ebp)
c0004d10:	74 08                	je     c0004d1a <intr_keyboard_handler+0x21f>
/work/x86_os_my/device/keyboard.c:214 (discriminator 1)
c0004d12:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0004d18:	75 0c                	jne    c0004d26 <intr_keyboard_handler+0x22b>
/work/x86_os_my/device/keyboard.c:215
	 ctrl_status = true;
c0004d1a:	c7 05 8c c5 00 c0 01 	movl   $0x1,0xc000c58c
c0004d21:	00 00 00 
c0004d24:	eb 50                	jmp    c0004d76 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:216
      } else if (scancode == shift_l_make || scancode == shift_r_make) {
c0004d26:	66 83 7d f6 2a       	cmpw   $0x2a,-0xa(%ebp)
c0004d2b:	74 07                	je     c0004d34 <intr_keyboard_handler+0x239>
/work/x86_os_my/device/keyboard.c:216 (discriminator 1)
c0004d2d:	66 83 7d f6 36       	cmpw   $0x36,-0xa(%ebp)
c0004d32:	75 0c                	jne    c0004d40 <intr_keyboard_handler+0x245>
/work/x86_os_my/device/keyboard.c:217
	 shift_status = true;
c0004d34:	c7 05 90 c5 00 c0 01 	movl   $0x1,0xc000c590
c0004d3b:	00 00 00 
c0004d3e:	eb 36                	jmp    c0004d76 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:218
      } else if (scancode == alt_l_make || scancode == alt_r_make) {
c0004d40:	66 83 7d f6 38       	cmpw   $0x38,-0xa(%ebp)
c0004d45:	74 08                	je     c0004d4f <intr_keyboard_handler+0x254>
/work/x86_os_my/device/keyboard.c:218 (discriminator 1)
c0004d47:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c0004d4d:	75 0c                	jne    c0004d5b <intr_keyboard_handler+0x260>
/work/x86_os_my/device/keyboard.c:219
	 alt_status = true;
c0004d4f:	c7 05 94 c5 00 c0 01 	movl   $0x1,0xc000c594
c0004d56:	00 00 00 
c0004d59:	eb 1b                	jmp    c0004d76 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:220
      } else if (scancode == caps_lock_make) {
c0004d5b:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0004d60:	75 2e                	jne    c0004d90 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:223
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
c0004d62:	a1 98 c5 00 c0       	mov    0xc000c598,%eax
c0004d67:	85 c0                	test   %eax,%eax
c0004d69:	0f 94 c0             	sete   %al
c0004d6c:	0f b6 c0             	movzbl %al,%eax
c0004d6f:	a3 98 c5 00 c0       	mov    %eax,0xc000c598
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c0004d74:	eb 1a                	jmp    c0004d90 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:157 (discriminator 3)
c0004d76:	eb 18                	jmp    c0004d90 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:226
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
c0004d78:	83 ec 0c             	sub    $0xc,%esp
c0004d7b:	68 61 94 00 c0       	push   $0xc0009461
c0004d80:	e8 3b d7 ff ff       	call   c00024c0 <put_str>
c0004d85:	83 c4 10             	add    $0x10,%esp
c0004d88:	eb 07                	jmp    c0004d91 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:151
	 shift_status = false;
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
	 alt_status = false;
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c0004d8a:	90                   	nop
c0004d8b:	eb 04                	jmp    c0004d91 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:210
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
	    ioq_putchar(&kbd_buf, cur_char);
	 }
	 return;
c0004d8d:	90                   	nop
c0004d8e:	eb 01                	jmp    c0004d91 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c0004d90:	90                   	nop
/work/x86_os_my/device/keyboard.c:228
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
   }
}
c0004d91:	c9                   	leave  
c0004d92:	c3                   	ret    

c0004d93 <keyboard_init>:
keyboard_init():
/work/x86_os_my/device/keyboard.c:231

/* 键盘初始化 */
void keyboard_init() {
c0004d93:	55                   	push   %ebp
c0004d94:	89 e5                	mov    %esp,%ebp
c0004d96:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/keyboard.c:232
   put_str("keyboard init start\n");
c0004d99:	83 ec 0c             	sub    $0xc,%esp
c0004d9c:	68 6e 94 00 c0       	push   $0xc000946e
c0004da1:	e8 1a d7 ff ff       	call   c00024c0 <put_str>
c0004da6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:233
   ioqueue_init(&kbd_buf);
c0004da9:	83 ec 0c             	sub    $0xc,%esp
c0004dac:	68 e0 cb 00 c0       	push   $0xc000cbe0
c0004db1:	e8 28 00 00 00       	call   c0004dde <ioqueue_init>
c0004db6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:234
   register_handler(0x21, intr_keyboard_handler);
c0004db9:	83 ec 08             	sub    $0x8,%esp
c0004dbc:	68 fb 4a 00 c0       	push   $0xc0004afb
c0004dc1:	6a 21                	push   $0x21
c0004dc3:	e8 36 cf ff ff       	call   c0001cfe <register_handler>
c0004dc8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:235
   put_str("keyboard init done\n");
c0004dcb:	83 ec 0c             	sub    $0xc,%esp
c0004dce:	68 83 94 00 c0       	push   $0xc0009483
c0004dd3:	e8 e8 d6 ff ff       	call   c00024c0 <put_str>
c0004dd8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:236
}
c0004ddb:	90                   	nop
c0004ddc:	c9                   	leave  
c0004ddd:	c3                   	ret    

c0004dde <ioqueue_init>:
ioqueue_init():
/work/x86_os_my/device/ioqueue.c:7
#include "interrupt.h"
#include "global.h"
#include "debug.h"

/* 初始化io队列ioq */
void ioqueue_init(struct ioqueue* ioq) {
c0004dde:	55                   	push   %ebp
c0004ddf:	89 e5                	mov    %esp,%ebp
c0004de1:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:8
   lock_init(&ioq->lock);     // 初始化io队列的锁
c0004de4:	8b 45 08             	mov    0x8(%ebp),%eax
c0004de7:	83 ec 0c             	sub    $0xc,%esp
c0004dea:	50                   	push   %eax
c0004deb:	e8 05 fa ff ff       	call   c00047f5 <lock_init>
c0004df0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:9
   ioq->producer = ioq->consumer = NULL;  // 生产者和消费者置空
c0004df3:	8b 45 08             	mov    0x8(%ebp),%eax
c0004df6:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c0004dfd:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e00:	8b 50 20             	mov    0x20(%eax),%edx
c0004e03:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e06:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/device/ioqueue.c:10
   ioq->head = ioq->tail = 0; // 队列的首尾指针指向缓冲区数组第0个位置
c0004e09:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e0c:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)
c0004e13:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e16:	8b 50 68             	mov    0x68(%eax),%edx
c0004e19:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e1c:	89 50 64             	mov    %edx,0x64(%eax)
/work/x86_os_my/device/ioqueue.c:11
}
c0004e1f:	90                   	nop
c0004e20:	c9                   	leave  
c0004e21:	c3                   	ret    

c0004e22 <next_pos>:
next_pos():
/work/x86_os_my/device/ioqueue.c:14

/* 返回pos在缓冲区中的下一个位置值 */
static int32_t next_pos(int32_t pos) {
c0004e22:	55                   	push   %ebp
c0004e23:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/device/ioqueue.c:15
   return (pos + 1) % bufsize; 
c0004e25:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e28:	8d 50 01             	lea    0x1(%eax),%edx
c0004e2b:	89 d0                	mov    %edx,%eax
c0004e2d:	c1 f8 1f             	sar    $0x1f,%eax
c0004e30:	c1 e8 1a             	shr    $0x1a,%eax
c0004e33:	01 c2                	add    %eax,%edx
c0004e35:	83 e2 3f             	and    $0x3f,%edx
c0004e38:	29 c2                	sub    %eax,%edx
c0004e3a:	89 d0                	mov    %edx,%eax
/work/x86_os_my/device/ioqueue.c:16
}
c0004e3c:	5d                   	pop    %ebp
c0004e3d:	c3                   	ret    

c0004e3e <ioq_full>:
ioq_full():
/work/x86_os_my/device/ioqueue.c:19

/* 判断队列是否已满 */
bool ioq_full(struct ioqueue* ioq) {
c0004e3e:	55                   	push   %ebp
c0004e3f:	89 e5                	mov    %esp,%ebp
c0004e41:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:20
   ASSERT(intr_get_status() == INTR_OFF);
c0004e44:	e8 91 ce ff ff       	call   c0001cda <intr_get_status>
c0004e49:	85 c0                	test   %eax,%eax
c0004e4b:	74 19                	je     c0004e66 <ioq_full+0x28>
/work/x86_os_my/device/ioqueue.c:20 (discriminator 1)
c0004e4d:	68 98 94 00 c0       	push   $0xc0009498
c0004e52:	68 fc 94 00 c0       	push   $0xc00094fc
c0004e57:	6a 14                	push   $0x14
c0004e59:	68 b6 94 00 c0       	push   $0xc00094b6
c0004e5e:	e8 cf d7 ff ff       	call   c0002632 <panic_spin>
c0004e63:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:21
   return next_pos(ioq->head) == ioq->tail;
c0004e66:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e69:	8b 40 64             	mov    0x64(%eax),%eax
c0004e6c:	83 ec 0c             	sub    $0xc,%esp
c0004e6f:	50                   	push   %eax
c0004e70:	e8 ad ff ff ff       	call   c0004e22 <next_pos>
c0004e75:	83 c4 10             	add    $0x10,%esp
c0004e78:	89 c2                	mov    %eax,%edx
c0004e7a:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e7d:	8b 40 68             	mov    0x68(%eax),%eax
c0004e80:	39 c2                	cmp    %eax,%edx
c0004e82:	0f 94 c0             	sete   %al
c0004e85:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:22
}
c0004e88:	c9                   	leave  
c0004e89:	c3                   	ret    

c0004e8a <ioq_empty>:
ioq_empty():
/work/x86_os_my/device/ioqueue.c:25

/* 判断队列是否已空 */
static bool ioq_empty(struct ioqueue* ioq) {
c0004e8a:	55                   	push   %ebp
c0004e8b:	89 e5                	mov    %esp,%ebp
c0004e8d:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:26
   ASSERT(intr_get_status() == INTR_OFF);
c0004e90:	e8 45 ce ff ff       	call   c0001cda <intr_get_status>
c0004e95:	85 c0                	test   %eax,%eax
c0004e97:	74 19                	je     c0004eb2 <ioq_empty+0x28>
/work/x86_os_my/device/ioqueue.c:26 (discriminator 1)
c0004e99:	68 98 94 00 c0       	push   $0xc0009498
c0004e9e:	68 08 95 00 c0       	push   $0xc0009508
c0004ea3:	6a 1a                	push   $0x1a
c0004ea5:	68 b6 94 00 c0       	push   $0xc00094b6
c0004eaa:	e8 83 d7 ff ff       	call   c0002632 <panic_spin>
c0004eaf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:27
   return ioq->head == ioq->tail;
c0004eb2:	8b 45 08             	mov    0x8(%ebp),%eax
c0004eb5:	8b 50 64             	mov    0x64(%eax),%edx
c0004eb8:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ebb:	8b 40 68             	mov    0x68(%eax),%eax
c0004ebe:	39 c2                	cmp    %eax,%edx
c0004ec0:	0f 94 c0             	sete   %al
c0004ec3:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:28
}
c0004ec6:	c9                   	leave  
c0004ec7:	c3                   	ret    

c0004ec8 <ioq_wait>:
ioq_wait():
/work/x86_os_my/device/ioqueue.c:31

/* 使当前生产者或消费者在此缓冲区上等待 */
static void ioq_wait(struct task_struct** waiter) {
c0004ec8:	55                   	push   %ebp
c0004ec9:	89 e5                	mov    %esp,%ebp
c0004ecb:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:32
   ASSERT(*waiter == NULL && waiter != NULL);
c0004ece:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ed1:	8b 00                	mov    (%eax),%eax
c0004ed3:	85 c0                	test   %eax,%eax
c0004ed5:	75 06                	jne    c0004edd <ioq_wait+0x15>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 1)
c0004ed7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0004edb:	75 19                	jne    c0004ef6 <ioq_wait+0x2e>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 3)
c0004edd:	68 c8 94 00 c0       	push   $0xc00094c8
c0004ee2:	68 14 95 00 c0       	push   $0xc0009514
c0004ee7:	6a 20                	push   $0x20
c0004ee9:	68 b6 94 00 c0       	push   $0xc00094b6
c0004eee:	e8 3f d7 ff ff       	call   c0002632 <panic_spin>
c0004ef3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:33
   *waiter = running_thread();
c0004ef6:	e8 36 ef ff ff       	call   c0003e31 <running_thread>
c0004efb:	89 c2                	mov    %eax,%edx
c0004efd:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f00:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ioqueue.c:34
   thread_block(TASK_BLOCKED);
c0004f02:	83 ec 0c             	sub    $0xc,%esp
c0004f05:	6a 02                	push   $0x2
c0004f07:	e8 a2 f3 ff ff       	call   c00042ae <thread_block>
c0004f0c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:35
}
c0004f0f:	90                   	nop
c0004f10:	c9                   	leave  
c0004f11:	c3                   	ret    

c0004f12 <wakeup>:
wakeup():
/work/x86_os_my/device/ioqueue.c:38

/* 唤醒waiter */
static void wakeup(struct task_struct** waiter) {
c0004f12:	55                   	push   %ebp
c0004f13:	89 e5                	mov    %esp,%ebp
c0004f15:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:39
   ASSERT(*waiter != NULL);
c0004f18:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f1b:	8b 00                	mov    (%eax),%eax
c0004f1d:	85 c0                	test   %eax,%eax
c0004f1f:	75 19                	jne    c0004f3a <wakeup+0x28>
/work/x86_os_my/device/ioqueue.c:39 (discriminator 1)
c0004f21:	68 ea 94 00 c0       	push   $0xc00094ea
c0004f26:	68 20 95 00 c0       	push   $0xc0009520
c0004f2b:	6a 27                	push   $0x27
c0004f2d:	68 b6 94 00 c0       	push   $0xc00094b6
c0004f32:	e8 fb d6 ff ff       	call   c0002632 <panic_spin>
c0004f37:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:40
   thread_unblock(*waiter); 
c0004f3a:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f3d:	8b 00                	mov    (%eax),%eax
c0004f3f:	83 ec 0c             	sub    $0xc,%esp
c0004f42:	50                   	push   %eax
c0004f43:	e8 c9 f3 ff ff       	call   c0004311 <thread_unblock>
c0004f48:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:41
   *waiter = NULL;
c0004f4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f4e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/device/ioqueue.c:42
}
c0004f54:	90                   	nop
c0004f55:	c9                   	leave  
c0004f56:	c3                   	ret    

c0004f57 <ioq_getchar>:
ioq_getchar():
/work/x86_os_my/device/ioqueue.c:45

/* 消费者从ioq队列中获取一个字符 */
char ioq_getchar(struct ioqueue* ioq) {
c0004f57:	55                   	push   %ebp
c0004f58:	89 e5                	mov    %esp,%ebp
c0004f5a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ioqueue.c:46
   ASSERT(intr_get_status() == INTR_OFF);
c0004f5d:	e8 78 cd ff ff       	call   c0001cda <intr_get_status>
c0004f62:	85 c0                	test   %eax,%eax
c0004f64:	74 4b                	je     c0004fb1 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:46 (discriminator 1)
c0004f66:	68 98 94 00 c0       	push   $0xc0009498
c0004f6b:	68 28 95 00 c0       	push   $0xc0009528
c0004f70:	6a 2e                	push   $0x2e
c0004f72:	68 b6 94 00 c0       	push   $0xc00094b6
c0004f77:	e8 b6 d6 ff ff       	call   c0002632 <panic_spin>
c0004f7c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51 (discriminator 1)

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c0004f7f:	eb 30                	jmp    c0004fb1 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:52
      lock_acquire(&ioq->lock);	 
c0004f81:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f84:	83 ec 0c             	sub    $0xc,%esp
c0004f87:	50                   	push   %eax
c0004f88:	e8 42 fa ff ff       	call   c00049cf <lock_acquire>
c0004f8d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:53
      ioq_wait(&ioq->consumer);
c0004f90:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f93:	83 c0 20             	add    $0x20,%eax
c0004f96:	83 ec 0c             	sub    $0xc,%esp
c0004f99:	50                   	push   %eax
c0004f9a:	e8 29 ff ff ff       	call   c0004ec8 <ioq_wait>
c0004f9f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:54
      lock_release(&ioq->lock);
c0004fa2:	8b 45 08             	mov    0x8(%ebp),%eax
c0004fa5:	83 ec 0c             	sub    $0xc,%esp
c0004fa8:	50                   	push   %eax
c0004fa9:	e8 98 fa ff ff       	call   c0004a46 <lock_release>
c0004fae:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c0004fb1:	83 ec 0c             	sub    $0xc,%esp
c0004fb4:	ff 75 08             	pushl  0x8(%ebp)
c0004fb7:	e8 ce fe ff ff       	call   c0004e8a <ioq_empty>
c0004fbc:	83 c4 10             	add    $0x10,%esp
c0004fbf:	85 c0                	test   %eax,%eax
c0004fc1:	75 be                	jne    c0004f81 <ioq_getchar+0x2a>
/work/x86_os_my/device/ioqueue.c:57
      lock_acquire(&ioq->lock);	 
      ioq_wait(&ioq->consumer);
      lock_release(&ioq->lock);
   }

   char byte = ioq->buf[ioq->tail];	  // 从缓冲区中取出
c0004fc3:	8b 45 08             	mov    0x8(%ebp),%eax
c0004fc6:	8b 40 68             	mov    0x68(%eax),%eax
c0004fc9:	8b 55 08             	mov    0x8(%ebp),%edx
c0004fcc:	0f b6 44 02 24       	movzbl 0x24(%edx,%eax,1),%eax
c0004fd1:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ioqueue.c:58
   ioq->tail = next_pos(ioq->tail);	  // 把读游标移到下一位置
c0004fd4:	8b 45 08             	mov    0x8(%ebp),%eax
c0004fd7:	8b 40 68             	mov    0x68(%eax),%eax
c0004fda:	83 ec 0c             	sub    $0xc,%esp
c0004fdd:	50                   	push   %eax
c0004fde:	e8 3f fe ff ff       	call   c0004e22 <next_pos>
c0004fe3:	83 c4 10             	add    $0x10,%esp
c0004fe6:	89 c2                	mov    %eax,%edx
c0004fe8:	8b 45 08             	mov    0x8(%ebp),%eax
c0004feb:	89 50 68             	mov    %edx,0x68(%eax)
/work/x86_os_my/device/ioqueue.c:60

   if (ioq->producer != NULL) {
c0004fee:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ff1:	8b 40 1c             	mov    0x1c(%eax),%eax
c0004ff4:	85 c0                	test   %eax,%eax
c0004ff6:	74 12                	je     c000500a <ioq_getchar+0xb3>
/work/x86_os_my/device/ioqueue.c:61
      wakeup(&ioq->producer);		  // 唤醒生产者
c0004ff8:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ffb:	83 c0 1c             	add    $0x1c,%eax
c0004ffe:	83 ec 0c             	sub    $0xc,%esp
c0005001:	50                   	push   %eax
c0005002:	e8 0b ff ff ff       	call   c0004f12 <wakeup>
c0005007:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:64
   }

   return byte; 
c000500a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
/work/x86_os_my/device/ioqueue.c:65
}
c000500e:	c9                   	leave  
c000500f:	c3                   	ret    

c0005010 <ioq_putchar>:
ioq_putchar():
/work/x86_os_my/device/ioqueue.c:68

/* 生产者往ioq队列中写入一个字符byte */
void ioq_putchar(struct ioqueue* ioq, char byte) {
c0005010:	55                   	push   %ebp
c0005011:	89 e5                	mov    %esp,%ebp
c0005013:	83 ec 18             	sub    $0x18,%esp
c0005016:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005019:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/ioqueue.c:69
   ASSERT(intr_get_status() == INTR_OFF);
c000501c:	e8 b9 cc ff ff       	call   c0001cda <intr_get_status>
c0005021:	85 c0                	test   %eax,%eax
c0005023:	74 4b                	je     c0005070 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:69 (discriminator 1)
c0005025:	68 98 94 00 c0       	push   $0xc0009498
c000502a:	68 34 95 00 c0       	push   $0xc0009534
c000502f:	6a 45                	push   $0x45
c0005031:	68 b6 94 00 c0       	push   $0xc00094b6
c0005036:	e8 f7 d5 ff ff       	call   c0002632 <panic_spin>
c000503b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74 (discriminator 1)

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c000503e:	eb 30                	jmp    c0005070 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:75
      lock_acquire(&ioq->lock);
c0005040:	8b 45 08             	mov    0x8(%ebp),%eax
c0005043:	83 ec 0c             	sub    $0xc,%esp
c0005046:	50                   	push   %eax
c0005047:	e8 83 f9 ff ff       	call   c00049cf <lock_acquire>
c000504c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:76
      ioq_wait(&ioq->producer);
c000504f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005052:	83 c0 1c             	add    $0x1c,%eax
c0005055:	83 ec 0c             	sub    $0xc,%esp
c0005058:	50                   	push   %eax
c0005059:	e8 6a fe ff ff       	call   c0004ec8 <ioq_wait>
c000505e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:77
      lock_release(&ioq->lock);
c0005061:	8b 45 08             	mov    0x8(%ebp),%eax
c0005064:	83 ec 0c             	sub    $0xc,%esp
c0005067:	50                   	push   %eax
c0005068:	e8 d9 f9 ff ff       	call   c0004a46 <lock_release>
c000506d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c0005070:	83 ec 0c             	sub    $0xc,%esp
c0005073:	ff 75 08             	pushl  0x8(%ebp)
c0005076:	e8 c3 fd ff ff       	call   c0004e3e <ioq_full>
c000507b:	83 c4 10             	add    $0x10,%esp
c000507e:	85 c0                	test   %eax,%eax
c0005080:	75 be                	jne    c0005040 <ioq_putchar+0x30>
/work/x86_os_my/device/ioqueue.c:79
      lock_acquire(&ioq->lock);
      ioq_wait(&ioq->producer);
      lock_release(&ioq->lock);
   }
   ioq->buf[ioq->head] = byte;      // 把字节放入缓冲区中
c0005082:	8b 45 08             	mov    0x8(%ebp),%eax
c0005085:	8b 40 64             	mov    0x64(%eax),%eax
c0005088:	8b 55 08             	mov    0x8(%ebp),%edx
c000508b:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
c000508f:	88 4c 02 24          	mov    %cl,0x24(%edx,%eax,1)
/work/x86_os_my/device/ioqueue.c:80
   ioq->head = next_pos(ioq->head); // 把写游标移到下一位置
c0005093:	8b 45 08             	mov    0x8(%ebp),%eax
c0005096:	8b 40 64             	mov    0x64(%eax),%eax
c0005099:	83 ec 0c             	sub    $0xc,%esp
c000509c:	50                   	push   %eax
c000509d:	e8 80 fd ff ff       	call   c0004e22 <next_pos>
c00050a2:	83 c4 10             	add    $0x10,%esp
c00050a5:	89 c2                	mov    %eax,%edx
c00050a7:	8b 45 08             	mov    0x8(%ebp),%eax
c00050aa:	89 50 64             	mov    %edx,0x64(%eax)
/work/x86_os_my/device/ioqueue.c:82

   if (ioq->consumer != NULL) {
c00050ad:	8b 45 08             	mov    0x8(%ebp),%eax
c00050b0:	8b 40 20             	mov    0x20(%eax),%eax
c00050b3:	85 c0                	test   %eax,%eax
c00050b5:	74 12                	je     c00050c9 <ioq_putchar+0xb9>
/work/x86_os_my/device/ioqueue.c:83
      wakeup(&ioq->consumer);          // 唤醒消费者
c00050b7:	8b 45 08             	mov    0x8(%ebp),%eax
c00050ba:	83 c0 20             	add    $0x20,%eax
c00050bd:	83 ec 0c             	sub    $0xc,%esp
c00050c0:	50                   	push   %eax
c00050c1:	e8 4c fe ff ff       	call   c0004f12 <wakeup>
c00050c6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:85
   }
}
c00050c9:	90                   	nop
c00050ca:	c9                   	leave  
c00050cb:	c3                   	ret    

c00050cc <update_tss_esp>:
update_tss_esp():
/work/x86_os_my/userprog/tss.c:40
	uint32_t io_base;
}; 
static struct tss g_tss;

/* 更新tss中esp0字段的值为pthread的0级栈 */
void update_tss_esp(struct task_struct* pthread) {
c00050cc:	55                   	push   %ebp
c00050cd:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/userprog/tss.c:41
	g_tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c00050cf:	8b 45 08             	mov    0x8(%ebp),%eax
c00050d2:	05 00 10 00 00       	add    $0x1000,%eax
c00050d7:	a3 a4 c5 00 c0       	mov    %eax,0xc000c5a4
/work/x86_os_my/userprog/tss.c:42
}
c00050dc:	90                   	nop
c00050dd:	5d                   	pop    %ebp
c00050de:	c3                   	ret    

c00050df <make_gdt_desc>:
make_gdt_desc():
/work/x86_os_my/userprog/tss.c:45

/* c语言方式，创建gdt描述符 */
static struct gdt_desc make_gdt_desc(uint32_t* desc_addr, uint32_t limit, uint8_t attr_low, uint8_t attr_high) {
c00050df:	55                   	push   %ebp
c00050e0:	89 e5                	mov    %esp,%ebp
c00050e2:	83 ec 18             	sub    $0x18,%esp
c00050e5:	8b 55 14             	mov    0x14(%ebp),%edx
c00050e8:	8b 45 18             	mov    0x18(%ebp),%eax
c00050eb:	88 55 ec             	mov    %dl,-0x14(%ebp)
c00050ee:	88 45 e8             	mov    %al,-0x18(%ebp)
/work/x86_os_my/userprog/tss.c:46
	uint32_t desc_base = (uint32_t)desc_addr;
c00050f1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00050f4:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/userprog/tss.c:48
	struct gdt_desc desc;
	desc.limit_low_word = limit & 0x0000ffff;
c00050f7:	8b 45 10             	mov    0x10(%ebp),%eax
c00050fa:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/userprog/tss.c:49
	desc.base_low_word = desc_base & 0x0000ffff;
c00050fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0005101:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/userprog/tss.c:50
	desc.base_mid_byte = ((desc_base & 0x00ff0000) >> 16);
c0005105:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0005108:	25 00 00 ff 00       	and    $0xff0000,%eax
c000510d:	c1 e8 10             	shr    $0x10,%eax
c0005110:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/userprog/tss.c:51
	desc.attr_low_byte = (uint8_t)(attr_low);
c0005113:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0005117:	88 45 f9             	mov    %al,-0x7(%ebp)
/work/x86_os_my/userprog/tss.c:52
	desc.limit_high_attr_high = (((limit & 0x000f0000) >> 16) + (uint8_t)(attr_high));
c000511a:	8b 45 10             	mov    0x10(%ebp),%eax
c000511d:	25 00 00 0f 00       	and    $0xf0000,%eax
c0005122:	c1 e8 10             	shr    $0x10,%eax
c0005125:	89 c2                	mov    %eax,%edx
c0005127:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c000512b:	01 d0                	add    %edx,%eax
c000512d:	88 45 fa             	mov    %al,-0x6(%ebp)
/work/x86_os_my/userprog/tss.c:53
	desc.base_high_byte = desc_base >> 24;
c0005130:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0005133:	c1 e8 18             	shr    $0x18,%eax
c0005136:	88 45 fb             	mov    %al,-0x5(%ebp)
/work/x86_os_my/userprog/tss.c:54
	return desc;
c0005139:	8b 4d 08             	mov    0x8(%ebp),%ecx
c000513c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000513f:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0005142:	89 01                	mov    %eax,(%ecx)
c0005144:	89 51 04             	mov    %edx,0x4(%ecx)
/work/x86_os_my/userprog/tss.c:55
}
c0005147:	8b 45 08             	mov    0x8(%ebp),%eax
c000514a:	c9                   	leave  
c000514b:	c2 04 00             	ret    $0x4

c000514e <tss_init>:
tss_init():
/work/x86_os_my/userprog/tss.c:61

/* 在gdt中创建tss描述符
 * 重新加载 gdt
 * 加载 tr
 */
void tss_init() {
c000514e:	55                   	push   %ebp
c000514f:	89 e5                	mov    %esp,%ebp
c0005151:	53                   	push   %ebx
c0005152:	83 ec 24             	sub    $0x24,%esp
/work/x86_os_my/userprog/tss.c:62
	put_str("tss_init start\n");
c0005155:	83 ec 0c             	sub    $0xc,%esp
c0005158:	68 40 95 00 c0       	push   $0xc0009540
c000515d:	e8 5e d3 ff ff       	call   c00024c0 <put_str>
c0005162:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:63
	uint32_t tss_size = sizeof(g_tss);
c0005165:	c7 45 f4 6c 00 00 00 	movl   $0x6c,-0xc(%ebp)
/work/x86_os_my/userprog/tss.c:64
	memset(&g_tss, 0, tss_size);
c000516c:	83 ec 04             	sub    $0x4,%esp
c000516f:	ff 75 f4             	pushl  -0xc(%ebp)
c0005172:	6a 00                	push   $0x0
c0005174:	68 a0 c5 00 c0       	push   $0xc000c5a0
c0005179:	e8 cc e8 ff ff       	call   c0003a4a <memset>
c000517e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:66
	
	g_tss.ss0 = SELECTOR_K_STACK;	// 0 级栈段的选择子 
c0005181:	c7 05 a8 c5 00 c0 10 	movl   $0x10,0xc000c5a8
c0005188:	00 00 00 
/work/x86_os_my/userprog/tss.c:67
	g_tss.io_base = tss_size;		// 当 IO 位图的偏移地址大于等于 TSS 大小减 1 时，就表示没有 IO 位图。
c000518b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000518e:	a3 08 c6 00 c0       	mov    %eax,0xc000c608
/work/x86_os_my/userprog/tss.c:75
	 * 内核地址 0xC000_0900 是映射到 0x900 的 
	 * 在GDT中，第 0 个段描述符不可用，第 1 个为代码段，第 2 个为数据段和栈，第 3 个为显存段
	 */

	/* 在gdt中添加dpl为0的TSS描述符 */
	*((struct gdt_desc*)0xc0000920) = make_gdt_desc((uint32_t*)&g_tss, tss_size - 1, TSS_ATTR_LOW, TSS_ATTR_HIGH);
c0005193:	bb 20 09 00 c0       	mov    $0xc0000920,%ebx
c0005198:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000519b:	8d 50 ff             	lea    -0x1(%eax),%edx
c000519e:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00051a1:	83 ec 0c             	sub    $0xc,%esp
c00051a4:	68 80 00 00 00       	push   $0x80
c00051a9:	68 89 00 00 00       	push   $0x89
c00051ae:	52                   	push   %edx
c00051af:	68 a0 c5 00 c0       	push   $0xc000c5a0
c00051b4:	50                   	push   %eax
c00051b5:	e8 25 ff ff ff       	call   c00050df <make_gdt_desc>
c00051ba:	83 c4 1c             	add    $0x1c,%esp
c00051bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00051c0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00051c3:	89 03                	mov    %eax,(%ebx)
c00051c5:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:78

	/* 在gdt中添加dpl为3的,用户级,数据段和代码段描述符 */
	*((struct gdt_desc*)0xc0000928) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
c00051c8:	bb 28 09 00 c0       	mov    $0xc0000928,%ebx
c00051cd:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00051d0:	83 ec 0c             	sub    $0xc,%esp
c00051d3:	68 c0 00 00 00       	push   $0xc0
c00051d8:	68 f8 00 00 00       	push   $0xf8
c00051dd:	68 ff ff 0f 00       	push   $0xfffff
c00051e2:	6a 00                	push   $0x0
c00051e4:	50                   	push   %eax
c00051e5:	e8 f5 fe ff ff       	call   c00050df <make_gdt_desc>
c00051ea:	83 c4 1c             	add    $0x1c,%esp
c00051ed:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00051f0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00051f3:	89 03                	mov    %eax,(%ebx)
c00051f5:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:79
	*((struct gdt_desc*)0xc0000930) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
c00051f8:	bb 30 09 00 c0       	mov    $0xc0000930,%ebx
c00051fd:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0005200:	83 ec 0c             	sub    $0xc,%esp
c0005203:	68 c0 00 00 00       	push   $0xc0
c0005208:	68 f2 00 00 00       	push   $0xf2
c000520d:	68 ff ff 0f 00       	push   $0xfffff
c0005212:	6a 00                	push   $0x0
c0005214:	50                   	push   %eax
c0005215:	e8 c5 fe ff ff       	call   c00050df <make_gdt_desc>
c000521a:	83 c4 1c             	add    $0x1c,%esp
c000521d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0005220:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0005223:	89 03                	mov    %eax,(%ebx)
c0005225:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:83

	/* GDTR 16位的limit、32位的段基址 */
	// 先转换成 uint32_t 后，再将其转换成 uint64_t 位（不可一步到位转为 uint64_t）
	uint64_t gdt_operand = ((8 * 7 - 1) | ((uint64_t)(uint32_t)0xc0000900 << 16));   // 7个描述符大小
c0005228:	c7 45 e8 37 00 00 09 	movl   $0x9000037,-0x18(%ebp)
c000522f:	c7 45 ec 00 c0 00 00 	movl   $0xc000,-0x14(%ebp)
/work/x86_os_my/userprog/tss.c:84
	asm volatile ("lgdt %0" : : "m" (gdt_operand));
c0005236:	0f 01 55 e8          	lgdtl  -0x18(%ebp)
/work/x86_os_my/userprog/tss.c:85
	asm volatile ("ltr %w0" : : "r" (SELECTOR_TSS));
c000523a:	b8 20 00 00 00       	mov    $0x20,%eax
c000523f:	0f 00 d8             	ltr    %ax
/work/x86_os_my/userprog/tss.c:86
	put_str("tss_init and ltr done\n");
c0005242:	83 ec 0c             	sub    $0xc,%esp
c0005245:	68 50 95 00 c0       	push   $0xc0009550
c000524a:	e8 71 d2 ff ff       	call   c00024c0 <put_str>
c000524f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:87
}
c0005252:	90                   	nop
c0005253:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0005256:	c9                   	leave  
c0005257:	c3                   	ret    

c0005258 <start_process>:
start_process():
/work/x86_os_my/userprog/process.c:17
extern void intr_exit(void);

/* 构建用户进程初始上下文信息
 * 填充用户进程的中断栈，并将中断栈的信息，利用iretd填充到 CPU 中
 */
void start_process(void* filename_) {
c0005258:	55                   	push   %ebp
c0005259:	89 e5                	mov    %esp,%ebp
c000525b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:18
	void* function = filename_;
c000525e:	8b 45 08             	mov    0x8(%ebp),%eax
c0005261:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:19
	struct task_struct* cur = running_thread();
c0005264:	e8 c8 eb ff ff       	call   c0003e31 <running_thread>
c0005269:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:20
	cur->self_kstack += sizeof(struct thread_stack);
c000526c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000526f:	8b 00                	mov    (%eax),%eax
c0005271:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
c0005277:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000527a:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/process.c:21
	struct intr_stack* proc_stack = (struct intr_stack*)cur->self_kstack;	 
c000527c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000527f:	8b 00                	mov    (%eax),%eax
c0005281:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/userprog/process.c:22
	proc_stack->edi = proc_stack->esi = proc_stack->ebp = proc_stack->esp_dummy = 0;
c0005284:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005287:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
c000528e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005291:	8b 50 10             	mov    0x10(%eax),%edx
c0005294:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005297:	89 50 0c             	mov    %edx,0xc(%eax)
c000529a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000529d:	8b 50 0c             	mov    0xc(%eax),%edx
c00052a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00052a3:	89 50 08             	mov    %edx,0x8(%eax)
c00052a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00052a9:	8b 50 08             	mov    0x8(%eax),%edx
c00052ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00052af:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/userprog/process.c:23
	proc_stack->ebx = proc_stack->edx = proc_stack->ecx = proc_stack->eax = 0;
c00052b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00052b5:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c00052bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00052bf:	8b 50 20             	mov    0x20(%eax),%edx
c00052c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00052c5:	89 50 1c             	mov    %edx,0x1c(%eax)
c00052c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00052cb:	8b 50 1c             	mov    0x1c(%eax),%edx
c00052ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00052d1:	89 50 18             	mov    %edx,0x18(%eax)
c00052d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00052d7:	8b 50 18             	mov    0x18(%eax),%edx
c00052da:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00052dd:	89 50 14             	mov    %edx,0x14(%eax)
/work/x86_os_my/userprog/process.c:28
	/* 在iretd返回时，如果发现未来的 CPL（也就是内核栈中 CS.RPL，或者说是返回到的用户进程的代码段CS.CPL）
	 * 权限低于（数值上大于） CPU 中段寄存器（如 DS、 ES、 FS、 GS）中选择子指向的内存段的 DPL，
	 * CPU 会自动将相应段寄存器的选择子置为 0 
	 * 这里gs的选择子在iretd返回后，会被自动清零。*/
	proc_stack->gs = 0;					// 用户态用不上,直接初始为0
c00052e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00052e3:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
/work/x86_os_my/userprog/process.c:29
	proc_stack->ds = proc_stack->es = proc_stack->fs = SELECTOR_U_DATA;		// 用户级数据段
c00052ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00052ed:	c7 40 28 33 00 00 00 	movl   $0x33,0x28(%eax)
c00052f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00052f7:	8b 50 28             	mov    0x28(%eax),%edx
c00052fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00052fd:	89 50 2c             	mov    %edx,0x2c(%eax)
c0005300:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005303:	8b 50 2c             	mov    0x2c(%eax),%edx
c0005306:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005309:	89 50 30             	mov    %edx,0x30(%eax)
/work/x86_os_my/userprog/process.c:30
	proc_stack->eip = function;			// 待执行的用户程序地址
c000530c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000530f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005312:	89 50 38             	mov    %edx,0x38(%eax)
/work/x86_os_my/userprog/process.c:31
	proc_stack->cs = SELECTOR_U_CODE;	// 用户级代码段
c0005315:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005318:	c7 40 3c 2b 00 00 00 	movl   $0x2b,0x3c(%eax)
/work/x86_os_my/userprog/process.c:32
	proc_stack->eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);
c000531f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005322:	c7 40 40 02 02 00 00 	movl   $0x202,0x40(%eax)
/work/x86_os_my/userprog/process.c:41
	 * process_activate 使用户进程页表生效【已经把CR3寄存器 更新为 用户进程的页表了】
	 * start_process    为用户进程创建3特权级栈【所以申请的内存空间来自用户进程的页表】
	 * 
	 * USER_STACK3_VADDR=(0xc0000000 - 0x1000)
	 */
	proc_stack->esp = (void*)((uint32_t)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE) ;
c0005329:	83 ec 08             	sub    $0x8,%esp
c000532c:	68 00 f0 ff bf       	push   $0xbffff000
c0005331:	6a 02                	push   $0x2
c0005333:	e8 58 da ff ff       	call   c0002d90 <get_a_page>
c0005338:	83 c4 10             	add    $0x10,%esp
c000533b:	05 00 10 00 00       	add    $0x1000,%eax
c0005340:	89 c2                	mov    %eax,%edx
c0005342:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005345:	89 50 44             	mov    %edx,0x44(%eax)
/work/x86_os_my/userprog/process.c:42
	proc_stack->ss = SELECTOR_U_DATA;
c0005348:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000534b:	c7 40 48 33 00 00 00 	movl   $0x33,0x48(%eax)
/work/x86_os_my/userprog/process.c:49
	/* 将 esp 替换为 proc_stack
	 * 通过 jmp intr_exit 那里的一系列 pop 指令和 iretd 指令，
	 * 将 proc_stack 中的数据载入 CPU 的寄存器，
	 * 从而使程序“假装”退出中断，进入特权级 3
	 */
	asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (proc_stack) : "memory");
c0005352:	8b 65 ec             	mov    -0x14(%ebp),%esp
c0005355:	e9 06 cc ff ff       	jmp    c0001f60 <intr_exit>
/work/x86_os_my/userprog/process.c:50
}
c000535a:	90                   	nop
c000535b:	c9                   	leave  
c000535c:	c3                   	ret    

c000535d <page_dir_activate>:
page_dir_activate():
/work/x86_os_my/userprog/process.c:53

/* 更新CR3寄存器，激活页目录表 */
void page_dir_activate(struct task_struct* p_thread) {
c000535d:	55                   	push   %ebp
c000535e:	89 e5                	mov    %esp,%ebp
c0005360:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:56
	
	/* 若为"内核线程",需要重新填充页表为0x100000 */
	uint32_t pagedir_phy_addr = 0x100000;	// 默认为内核的页目录物理地址,也就是内核线程所用的页目录表
c0005363:	c7 45 f4 00 00 10 00 	movl   $0x100000,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:59
	
	/* "用户态进程"有自己的页目录表 */
	if (p_thread->pgdir != NULL) {
c000536a:	8b 45 08             	mov    0x8(%ebp),%eax
c000536d:	8b 40 54             	mov    0x54(%eax),%eax
c0005370:	85 c0                	test   %eax,%eax
c0005372:	74 15                	je     c0005389 <page_dir_activate+0x2c>
/work/x86_os_my/userprog/process.c:60
		pagedir_phy_addr = addr_v2p((uint32_t)p_thread->pgdir);
c0005374:	8b 45 08             	mov    0x8(%ebp),%eax
c0005377:	8b 40 54             	mov    0x54(%eax),%eax
c000537a:	83 ec 0c             	sub    $0xc,%esp
c000537d:	50                   	push   %eax
c000537e:	e8 7d db ff ff       	call   c0002f00 <addr_v2p>
c0005383:	83 c4 10             	add    $0x10,%esp
c0005386:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:66
	}

	/* 更新页目录寄存器cr3,使新页表生效
	 * 实现进程间，虚拟地址空间的隔离。
	 */
	asm volatile ("movl %0, %%cr3" : : "r" (pagedir_phy_addr) : "memory");
c0005389:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000538c:	0f 22 d8             	mov    %eax,%cr3
/work/x86_os_my/userprog/process.c:67
}
c000538f:	90                   	nop
c0005390:	c9                   	leave  
c0005391:	c3                   	ret    

c0005392 <process_activate>:
process_activate():
/work/x86_os_my/userprog/process.c:73

/* 1.激活线程或进程的页表,【更新CR3寄存器】
 * 2.用户进程，更新tss中的esp0为进程的特权级0的栈
 * 【只有在任务调度时（中断时），才会切换页表及更新 0 级栈，因此 process_activate 是被"中断执行流"的 schedule 调用的！】
 */
void process_activate(struct task_struct* p_thread) {
c0005392:	55                   	push   %ebp
c0005393:	89 e5                	mov    %esp,%ebp
c0005395:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/process.c:74
	ASSERT(p_thread != NULL);
c0005398:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000539c:	75 19                	jne    c00053b7 <process_activate+0x25>
/work/x86_os_my/userprog/process.c:74 (discriminator 1)
c000539e:	68 68 95 00 c0       	push   $0xc0009568
c00053a3:	68 24 96 00 c0       	push   $0xc0009624
c00053a8:	6a 4a                	push   $0x4a
c00053aa:	68 79 95 00 c0       	push   $0xc0009579
c00053af:	e8 7e d2 ff ff       	call   c0002632 <panic_spin>
c00053b4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:77
	
	/* 激活该进程或线程的页目录表【重新加载了CR3】 */
	page_dir_activate(p_thread);
c00053b7:	83 ec 0c             	sub    $0xc,%esp
c00053ba:	ff 75 08             	pushl  0x8(%ebp)
c00053bd:	e8 9b ff ff ff       	call   c000535d <page_dir_activate>
c00053c2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:80

	/* 内核线程特权级本身就是0,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */
	if (p_thread->pgdir != NULL) {
c00053c5:	8b 45 08             	mov    0x8(%ebp),%eax
c00053c8:	8b 40 54             	mov    0x54(%eax),%eax
c00053cb:	85 c0                	test   %eax,%eax
c00053cd:	74 0e                	je     c00053dd <process_activate+0x4b>
/work/x86_os_my/userprog/process.c:83
		/* 若为用户进程,更新该进程的esp0,用于此进程被中断时保留上下文 
		 * 需要从tss中获取0特权级栈地址 */
		update_tss_esp(p_thread);	//就一行：g_tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c00053cf:	83 ec 0c             	sub    $0xc,%esp
c00053d2:	ff 75 08             	pushl  0x8(%ebp)
c00053d5:	e8 f2 fc ff ff       	call   c00050cc <update_tss_esp>
c00053da:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:85
	}
}
c00053dd:	90                   	nop
c00053de:	c9                   	leave  
c00053df:	c3                   	ret    

c00053e0 <create_page_dir>:
create_page_dir():
/work/x86_os_my/userprog/process.c:94
 * 
 * 要确保用户进程，在自己的地址空间中，能够访问到内核。
 * 即：任意进程的页目录表中，用户进程占第 0~767 个页目录项，内核占第 768~1023 个页目录项。
 * 0x300 = 768
 */
uint32_t* create_page_dir(void) {
c00053e0:	55                   	push   %ebp
c00053e1:	89 e5                	mov    %esp,%ebp
c00053e3:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:97

	/* 用户进程的页表不能让用户直接访问到,所以在内核空间来申请 */
	uint32_t* page_dir_vaddr = get_kernel_pages(1);
c00053e6:	83 ec 0c             	sub    $0xc,%esp
c00053e9:	6a 01                	push   $0x1
c00053eb:	e8 ea d8 ff ff       	call   c0002cda <get_kernel_pages>
c00053f0:	83 c4 10             	add    $0x10,%esp
c00053f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:98
	if (page_dir_vaddr == NULL) {
c00053f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00053fa:	75 17                	jne    c0005413 <create_page_dir+0x33>
/work/x86_os_my/userprog/process.c:99
		console_put_str("create_page_dir: get_kernel_page failed!");
c00053fc:	83 ec 0c             	sub    $0xc,%esp
c00053ff:	68 8c 95 00 c0       	push   $0xc000958c
c0005404:	e8 57 f3 ff ff       	call   c0004760 <console_put_str>
c0005409:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:100
		return NULL;
c000540c:	b8 00 00 00 00       	mov    $0x0,%eax
c0005411:	eb 43                	jmp    c0005456 <create_page_dir+0x76>
/work/x86_os_my/userprog/process.c:106
	}

	/*** 1 复制内核的页目录表  ***/
	// page_dir_vaddr + 0x300*4 是内核页目录的第768项
	// 复制的页目录项个数=1024/4
	memcpy((uint32_t*)((uint32_t)page_dir_vaddr + 0x300*4), (uint32_t*)(0xfffff000+0x300*4), 1024);
c0005413:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005416:	05 00 0c 00 00       	add    $0xc00,%eax
c000541b:	83 ec 04             	sub    $0x4,%esp
c000541e:	68 00 04 00 00       	push   $0x400
c0005423:	68 00 fc ff ff       	push   $0xfffffc00
c0005428:	50                   	push   %eax
c0005429:	e8 6e e6 ff ff       	call   c0003a9c <memcpy>
c000542e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:110

	/*** 2 更新页目录表地址 ***/
	// 页目录表地址是页目录的最后一项
	uint32_t new_page_dir_phy_addr = addr_v2p((uint32_t)page_dir_vaddr);
c0005431:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005434:	83 ec 0c             	sub    $0xc,%esp
c0005437:	50                   	push   %eax
c0005438:	e8 c3 da ff ff       	call   c0002f00 <addr_v2p>
c000543d:	83 c4 10             	add    $0x10,%esp
c0005440:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:111
	page_dir_vaddr[1023] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1;
c0005443:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005446:	05 fc 0f 00 00       	add    $0xffc,%eax
c000544b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000544e:	83 ca 07             	or     $0x7,%edx
c0005451:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/process.c:113

	return page_dir_vaddr;
c0005453:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/userprog/process.c:114
}
c0005456:	c9                   	leave  
c0005457:	c3                   	ret    

c0005458 <create_user_vaddr_bitmap>:
create_user_vaddr_bitmap():
/work/x86_os_my/userprog/process.c:117

/* 创建用户进程虚拟地址位图 */
void create_user_vaddr_bitmap(struct task_struct* user_prog) {
c0005458:	55                   	push   %ebp
c0005459:	89 e5                	mov    %esp,%ebp
c000545b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:118
   user_prog->userprog_vaddr.vaddr_start = USER_VADDR_START;	// linux用户程序入口地址 0x80480000
c000545e:	8b 45 08             	mov    0x8(%ebp),%eax
c0005461:	c7 40 60 00 80 04 08 	movl   $0x8048000,0x60(%eax)
/work/x86_os_my/userprog/process.c:119
   uint32_t bitmap_pg_cnt = DIV_ROUND_UP((0xc0000000 - USER_VADDR_START) / PG_SIZE / 8 , PG_SIZE);
c0005468:	c7 45 f4 17 00 00 00 	movl   $0x17,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:120
   user_prog->userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt);
c000546f:	83 ec 0c             	sub    $0xc,%esp
c0005472:	ff 75 f4             	pushl  -0xc(%ebp)
c0005475:	e8 60 d8 ff ff       	call   c0002cda <get_kernel_pages>
c000547a:	83 c4 10             	add    $0x10,%esp
c000547d:	89 c2                	mov    %eax,%edx
c000547f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005482:	89 50 5c             	mov    %edx,0x5c(%eax)
/work/x86_os_my/userprog/process.c:121
   user_prog->userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (0xc0000000 - USER_VADDR_START) / PG_SIZE / 8;
c0005485:	8b 45 08             	mov    0x8(%ebp),%eax
c0005488:	c7 40 58 f7 6f 01 00 	movl   $0x16ff7,0x58(%eax)
/work/x86_os_my/userprog/process.c:122
   bitmap_init(&user_prog->userprog_vaddr.vaddr_bitmap);
c000548f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005492:	83 c0 58             	add    $0x58,%eax
c0005495:	83 ec 0c             	sub    $0xc,%esp
c0005498:	50                   	push   %eax
c0005499:	e8 6a d2 ff ff       	call   c0002708 <bitmap_init>
c000549e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:123
}
c00054a1:	90                   	nop
c00054a2:	c9                   	leave  
c00054a3:	c3                   	ret    

c00054a4 <process_execute>:
process_execute():
/work/x86_os_my/userprog/process.c:126

/* 创建用户进程 */
void process_execute(void* filename, char* name) {
c00054a4:	55                   	push   %ebp
c00054a5:	89 e5                	mov    %esp,%ebp
c00054a7:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:128
   /* pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 */
   struct task_struct* thread = get_kernel_pages(1);
c00054aa:	83 ec 0c             	sub    $0xc,%esp
c00054ad:	6a 01                	push   $0x1
c00054af:	e8 26 d8 ff ff       	call   c0002cda <get_kernel_pages>
c00054b4:	83 c4 10             	add    $0x10,%esp
c00054b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:129
   init_thread(thread, name, default_prio);			//初始化线程PCB结构体 struct task_struct
c00054ba:	83 ec 04             	sub    $0x4,%esp
c00054bd:	6a 1f                	push   $0x1f
c00054bf:	ff 75 0c             	pushl  0xc(%ebp)
c00054c2:	ff 75 f4             	pushl  -0xc(%ebp)
c00054c5:	e8 4e ea ff ff       	call   c0003f18 <init_thread>
c00054ca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:130
   create_user_vaddr_bitmap(thread);				//【进程新增】创建用户进程，虚拟地址空间位图
c00054cd:	83 ec 0c             	sub    $0xc,%esp
c00054d0:	ff 75 f4             	pushl  -0xc(%ebp)
c00054d3:	e8 80 ff ff ff       	call   c0005458 <create_user_vaddr_bitmap>
c00054d8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:131
   thread_create(thread, start_process, filename);	//初始化线程栈结构体 struct thread_stack
c00054db:	83 ec 04             	sub    $0x4,%esp
c00054de:	ff 75 08             	pushl  0x8(%ebp)
c00054e1:	68 58 52 00 c0       	push   $0xc0005258
c00054e6:	ff 75 f4             	pushl  -0xc(%ebp)
c00054e9:	e8 b3 e9 ff ff       	call   c0003ea1 <thread_create>
c00054ee:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:132
   thread->pgdir = create_page_dir();				//【进程新增】创建用户进程，页目录表
c00054f1:	e8 ea fe ff ff       	call   c00053e0 <create_page_dir>
c00054f6:	89 c2                	mov    %eax,%edx
c00054f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00054fb:	89 50 54             	mov    %edx,0x54(%eax)
/work/x86_os_my/userprog/process.c:133
   block_desc_init(thread->u_block_desc);
c00054fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005501:	83 c0 64             	add    $0x64,%eax
c0005504:	83 ec 0c             	sub    $0xc,%esp
c0005507:	50                   	push   %eax
c0005508:	e8 59 e4 ff ff       	call   c0003966 <block_desc_init>
c000550d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:135
   
   enum intr_status old_status = intr_disable();
c0005510:	e8 7e c7 ff ff       	call   c0001c93 <intr_disable>
c0005515:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:136
   ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));
c0005518:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000551b:	83 c0 44             	add    $0x44,%eax
c000551e:	83 ec 08             	sub    $0x8,%esp
c0005521:	50                   	push   %eax
c0005522:	68 8c cb 00 c0       	push   $0xc000cb8c
c0005527:	e8 e7 f0 ff ff       	call   c0004613 <elem_find>
c000552c:	83 c4 10             	add    $0x10,%esp
c000552f:	85 c0                	test   %eax,%eax
c0005531:	74 1c                	je     c000554f <process_execute+0xab>
/work/x86_os_my/userprog/process.c:136 (discriminator 1)
c0005533:	68 b8 95 00 c0       	push   $0xc00095b8
c0005538:	68 38 96 00 c0       	push   $0xc0009638
c000553d:	68 88 00 00 00       	push   $0x88
c0005542:	68 79 95 00 c0       	push   $0xc0009579
c0005547:	e8 e6 d0 ff ff       	call   c0002632 <panic_spin>
c000554c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:137
   list_append(&thread_ready_list, &thread->general_tag);
c000554f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005552:	83 c0 44             	add    $0x44,%eax
c0005555:	83 ec 08             	sub    $0x8,%esp
c0005558:	50                   	push   %eax
c0005559:	68 8c cb 00 c0       	push   $0xc000cb8c
c000555e:	e8 36 f0 ff ff       	call   c0004599 <list_append>
c0005563:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:138
   ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
c0005566:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005569:	83 c0 4c             	add    $0x4c,%eax
c000556c:	83 ec 08             	sub    $0x8,%esp
c000556f:	50                   	push   %eax
c0005570:	68 9c cb 00 c0       	push   $0xc000cb9c
c0005575:	e8 99 f0 ff ff       	call   c0004613 <elem_find>
c000557a:	83 c4 10             	add    $0x10,%esp
c000557d:	85 c0                	test   %eax,%eax
c000557f:	74 1c                	je     c000559d <process_execute+0xf9>
/work/x86_os_my/userprog/process.c:138 (discriminator 1)
c0005581:	68 f0 95 00 c0       	push   $0xc00095f0
c0005586:	68 38 96 00 c0       	push   $0xc0009638
c000558b:	68 8a 00 00 00       	push   $0x8a
c0005590:	68 79 95 00 c0       	push   $0xc0009579
c0005595:	e8 98 d0 ff ff       	call   c0002632 <panic_spin>
c000559a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:139
   list_append(&thread_all_list, &thread->all_list_tag);
c000559d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00055a0:	83 c0 4c             	add    $0x4c,%eax
c00055a3:	83 ec 08             	sub    $0x8,%esp
c00055a6:	50                   	push   %eax
c00055a7:	68 9c cb 00 c0       	push   $0xc000cb9c
c00055ac:	e8 e8 ef ff ff       	call   c0004599 <list_append>
c00055b1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:140
   intr_set_status(old_status);
c00055b4:	83 ec 0c             	sub    $0xc,%esp
c00055b7:	ff 75 f0             	pushl  -0x10(%ebp)
c00055ba:	e8 fd c6 ff ff       	call   c0001cbc <intr_set_status>
c00055bf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:141
}
c00055c2:	90                   	nop
c00055c3:	c9                   	leave  
c00055c4:	c3                   	ret    

c00055c5 <getpid>:
getpid():
/work/x86_os_my/lib/user/syscall.c:52
   );							       \
   retval;						       \
})

/* 返回当前任务pid */
uint32_t getpid() {
c00055c5:	55                   	push   %ebp
c00055c6:	89 e5                	mov    %esp,%ebp
c00055c8:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:53
   return _syscall0(SYS_GETPID);
c00055cb:	b8 00 00 00 00       	mov    $0x0,%eax
c00055d0:	cd 80                	int    $0x80
c00055d2:	89 45 fc             	mov    %eax,-0x4(%ebp)
c00055d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:54
}
c00055d8:	c9                   	leave  
c00055d9:	c3                   	ret    

c00055da <write>:
write():
/work/x86_os_my/lib/user/syscall.c:57

/* 打印字符串str */
uint32_t write(char* str) {
c00055da:	55                   	push   %ebp
c00055db:	89 e5                	mov    %esp,%ebp
c00055dd:	53                   	push   %ebx
c00055de:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:58
	return _syscall1(SYS_WRITE, str);
c00055e1:	b8 01 00 00 00       	mov    $0x1,%eax
c00055e6:	8b 55 08             	mov    0x8(%ebp),%edx
c00055e9:	89 d3                	mov    %edx,%ebx
c00055eb:	cd 80                	int    $0x80
c00055ed:	89 45 f8             	mov    %eax,-0x8(%ebp)
c00055f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:59
}
c00055f3:	83 c4 10             	add    $0x10,%esp
c00055f6:	5b                   	pop    %ebx
c00055f7:	5d                   	pop    %ebp
c00055f8:	c3                   	ret    

c00055f9 <malloc>:
malloc():
/work/x86_os_my/lib/user/syscall.c:62

/* 申请size字节大小的内存,并返回结果 */
void* malloc(uint32_t size) {
c00055f9:	55                   	push   %ebp
c00055fa:	89 e5                	mov    %esp,%ebp
c00055fc:	53                   	push   %ebx
c00055fd:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:63
	return (void*)_syscall1(SYS_MALLOC, size);
c0005600:	b8 02 00 00 00       	mov    $0x2,%eax
c0005605:	8b 55 08             	mov    0x8(%ebp),%edx
c0005608:	89 d3                	mov    %edx,%ebx
c000560a:	cd 80                	int    $0x80
c000560c:	89 45 f8             	mov    %eax,-0x8(%ebp)
c000560f:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:64
}
c0005612:	83 c4 10             	add    $0x10,%esp
c0005615:	5b                   	pop    %ebx
c0005616:	5d                   	pop    %ebp
c0005617:	c3                   	ret    

c0005618 <free>:
free():
/work/x86_os_my/lib/user/syscall.c:67

/* 释放ptr指向的内存 */
void free(void* ptr) {
c0005618:	55                   	push   %ebp
c0005619:	89 e5                	mov    %esp,%ebp
c000561b:	53                   	push   %ebx
c000561c:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:68
	_syscall1(SYS_FREE, ptr);
c000561f:	b8 03 00 00 00       	mov    $0x3,%eax
c0005624:	8b 55 08             	mov    0x8(%ebp),%edx
c0005627:	89 d3                	mov    %edx,%ebx
c0005629:	cd 80                	int    $0x80
c000562b:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/lib/user/syscall.c:69
}
c000562e:	90                   	nop
c000562f:	83 c4 10             	add    $0x10,%esp
c0005632:	5b                   	pop    %ebx
c0005633:	5d                   	pop    %ebp
c0005634:	c3                   	ret    

c0005635 <sys_getpid>:
sys_getpid():
/work/x86_os_my/userprog/syscall-init.c:15
#define syscall_nr 32 
typedef void* syscall;
syscall syscall_table[syscall_nr];

/* 返回当前任务的pid */
uint32_t sys_getpid(void) {
c0005635:	55                   	push   %ebp
c0005636:	89 e5                	mov    %esp,%ebp
c0005638:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/syscall-init.c:16
	return running_thread()->pid;
c000563b:	e8 f1 e7 ff ff       	call   c0003e31 <running_thread>
c0005640:	0f b7 40 04          	movzwl 0x4(%eax),%eax
c0005644:	98                   	cwtl   
/work/x86_os_my/userprog/syscall-init.c:17
}
c0005645:	c9                   	leave  
c0005646:	c3                   	ret    

c0005647 <sys_write>:
sys_write():
/work/x86_os_my/userprog/syscall-init.c:20

/* 打印字符串str(未实现文件系统前的版本) */
uint32_t sys_write(char* str) {
c0005647:	55                   	push   %ebp
c0005648:	89 e5                	mov    %esp,%ebp
c000564a:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/syscall-init.c:21
	console_put_str(str);
c000564d:	83 ec 0c             	sub    $0xc,%esp
c0005650:	ff 75 08             	pushl  0x8(%ebp)
c0005653:	e8 08 f1 ff ff       	call   c0004760 <console_put_str>
c0005658:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:22
	return strlen(str);
c000565b:	83 ec 0c             	sub    $0xc,%esp
c000565e:	ff 75 08             	pushl  0x8(%ebp)
c0005661:	e8 6e e5 ff ff       	call   c0003bd4 <strlen>
c0005666:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:23
}
c0005669:	c9                   	leave  
c000566a:	c3                   	ret    

c000566b <syscall_init>:
syscall_init():
/work/x86_os_my/userprog/syscall-init.c:26

/* 初始化系统调用 */
void syscall_init(void) {
c000566b:	55                   	push   %ebp
c000566c:	89 e5                	mov    %esp,%ebp
c000566e:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/syscall-init.c:27
	put_str("syscall_init start\n");
c0005671:	83 ec 0c             	sub    $0xc,%esp
c0005674:	68 48 96 00 c0       	push   $0xc0009648
c0005679:	e8 42 ce ff ff       	call   c00024c0 <put_str>
c000567e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:28
	syscall_table[SYS_GETPID] = sys_getpid;
c0005681:	c7 05 60 cc 00 c0 35 	movl   $0xc0005635,0xc000cc60
c0005688:	56 00 c0 
/work/x86_os_my/userprog/syscall-init.c:29
	syscall_table[SYS_WRITE] = sys_write;
c000568b:	c7 05 64 cc 00 c0 47 	movl   $0xc0005647,0xc000cc64
c0005692:	56 00 c0 
/work/x86_os_my/userprog/syscall-init.c:30
	syscall_table[SYS_MALLOC] = sys_malloc;
c0005695:	c7 05 68 cc 00 c0 53 	movl   $0xc0002f53,0xc000cc68
c000569c:	2f 00 c0 
/work/x86_os_my/userprog/syscall-init.c:31
	syscall_table[SYS_FREE] = sys_free;
c000569f:	c7 05 6c cc 00 c0 80 	movl   $0xc0003580,0xc000cc6c
c00056a6:	35 00 c0 
/work/x86_os_my/userprog/syscall-init.c:32
	put_str("syscall_init done\n");
c00056a9:	83 ec 0c             	sub    $0xc,%esp
c00056ac:	68 5c 96 00 c0       	push   $0xc000965c
c00056b1:	e8 0a ce ff ff       	call   c00024c0 <put_str>
c00056b6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:33
}
c00056b9:	90                   	nop
c00056ba:	c9                   	leave  
c00056bb:	c3                   	ret    

c00056bc <itoa>:
itoa():
/work/x86_os_my/lib/stdio.c:13
#define va_start(ap, v) ap = (va_list)&v	// 把ap指向第一个固定参数v
#define va_arg(ap, t) *((t*)(ap += 4))		// ap指向下一个参数并返回其值
#define va_end(ap) ap = NULL				// 清除ap

/* 将整型转换成字符(integer to ascii) */
static void itoa(uint32_t value, char** buf_ptr_addr, uint8_t base) {
c00056bc:	55                   	push   %ebp
c00056bd:	89 e5                	mov    %esp,%ebp
c00056bf:	83 ec 28             	sub    $0x28,%esp
c00056c2:	8b 45 10             	mov    0x10(%ebp),%eax
c00056c5:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/stdio.c:14
	uint32_t m = value % base;	// 求模,最先掉下来的是最低位【比如base是16代表16进制】 
c00056c8:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c00056cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00056cf:	ba 00 00 00 00       	mov    $0x0,%edx
c00056d4:	f7 f1                	div    %ecx
c00056d6:	89 55 f4             	mov    %edx,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:15
	uint32_t i = value / base;	// 取整
c00056d9:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c00056dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00056e0:	ba 00 00 00 00       	mov    $0x0,%edx
c00056e5:	f7 f1                	div    %ecx
c00056e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/stdio.c:16
	if (i) {
c00056ea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00056ee:	74 16                	je     c0005706 <itoa+0x4a>
/work/x86_os_my/lib/stdio.c:17
		itoa(i, buf_ptr_addr, base);	// 如果倍数不为0则递归调用。
c00056f0:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c00056f4:	83 ec 04             	sub    $0x4,%esp
c00056f7:	50                   	push   %eax
c00056f8:	ff 75 0c             	pushl  0xc(%ebp)
c00056fb:	ff 75 f0             	pushl  -0x10(%ebp)
c00056fe:	e8 b9 ff ff ff       	call   c00056bc <itoa>
c0005703:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:19
	}
	if (m < 10) {	// 如果余数是0~9
c0005706:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c000570a:	77 17                	ja     c0005723 <itoa+0x67>
/work/x86_os_my/lib/stdio.c:20
		*((*buf_ptr_addr)++) = m + '0';			// 将数字0~9转换为字符'0'~'9'
c000570c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000570f:	8b 00                	mov    (%eax),%eax
c0005711:	8d 48 01             	lea    0x1(%eax),%ecx
c0005714:	8b 55 0c             	mov    0xc(%ebp),%edx
c0005717:	89 0a                	mov    %ecx,(%edx)
c0005719:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000571c:	83 c2 30             	add    $0x30,%edx
c000571f:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:24
	} else {		// 否则余数是A~F
		*((*buf_ptr_addr)++) = m - 10 + 'A';	// 将数字A~F转换为字符'A'~'F'
	}
}
c0005721:	eb 15                	jmp    c0005738 <itoa+0x7c>
/work/x86_os_my/lib/stdio.c:22
		itoa(i, buf_ptr_addr, base);	// 如果倍数不为0则递归调用。
	}
	if (m < 10) {	// 如果余数是0~9
		*((*buf_ptr_addr)++) = m + '0';			// 将数字0~9转换为字符'0'~'9'
	} else {		// 否则余数是A~F
		*((*buf_ptr_addr)++) = m - 10 + 'A';	// 将数字A~F转换为字符'A'~'F'
c0005723:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005726:	8b 00                	mov    (%eax),%eax
c0005728:	8d 48 01             	lea    0x1(%eax),%ecx
c000572b:	8b 55 0c             	mov    0xc(%ebp),%edx
c000572e:	89 0a                	mov    %ecx,(%edx)
c0005730:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0005733:	83 c2 37             	add    $0x37,%edx
c0005736:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:24
	}
}
c0005738:	90                   	nop
c0005739:	c9                   	leave  
c000573a:	c3                   	ret    

c000573b <vsprintf>:
vsprintf():
/work/x86_os_my/lib/stdio.c:27

/* 将参数ap按照格式format输出到字符串str,并返回替换后str长度 */
uint32_t vsprintf(char* str, const char* format, va_list ap) {
c000573b:	55                   	push   %ebp
c000573c:	89 e5                	mov    %esp,%ebp
c000573e:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/lib/stdio.c:28
	char* buf_ptr = str;
c0005741:	8b 45 08             	mov    0x8(%ebp),%eax
c0005744:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/stdio.c:29
	const char* index_ptr = format;
c0005747:	8b 45 0c             	mov    0xc(%ebp),%eax
c000574a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:30
	char index_char = *index_ptr;
c000574d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005750:	0f b6 00             	movzbl (%eax),%eax
c0005753:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:33
	int32_t arg_int;
	char* arg_str;
	while(index_char) {
c0005756:	e9 43 01 00 00       	jmp    c000589e <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:34
		if (index_char != '%') {
c000575b:	80 7d f3 25          	cmpb   $0x25,-0xd(%ebp)
c000575f:	74 21                	je     c0005782 <vsprintf+0x47>
/work/x86_os_my/lib/stdio.c:35
			*(buf_ptr++) = index_char;
c0005761:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0005764:	8d 50 01             	lea    0x1(%eax),%edx
c0005767:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c000576a:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
c000576e:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:36
			index_char = *(++index_ptr);
c0005770:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0005774:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005777:	0f b6 00             	movzbl (%eax),%eax
c000577a:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:37
			continue;
c000577d:	e9 1c 01 00 00       	jmp    c000589e <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:39
		}
		index_char = *(++index_ptr);	 // 得到%后面的字符
c0005782:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0005786:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005789:	0f b6 00             	movzbl (%eax),%eax
c000578c:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:40
		switch(index_char) {
c000578f:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
c0005793:	83 f8 64             	cmp    $0x64,%eax
c0005796:	0f 84 8e 00 00 00    	je     c000582a <vsprintf+0xef>
c000579c:	83 f8 64             	cmp    $0x64,%eax
c000579f:	7f 0a                	jg     c00057ab <vsprintf+0x70>
c00057a1:	83 f8 63             	cmp    $0x63,%eax
c00057a4:	74 60                	je     c0005806 <vsprintf+0xcb>
c00057a6:	e9 f3 00 00 00       	jmp    c000589e <vsprintf+0x163>
c00057ab:	83 f8 73             	cmp    $0x73,%eax
c00057ae:	74 0e                	je     c00057be <vsprintf+0x83>
c00057b0:	83 f8 78             	cmp    $0x78,%eax
c00057b3:	0f 84 b6 00 00 00    	je     c000586f <vsprintf+0x134>
c00057b9:	e9 e0 00 00 00       	jmp    c000589e <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:42
			case 's':
			arg_str = va_arg(ap, char*);
c00057be:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c00057c2:	8b 45 10             	mov    0x10(%ebp),%eax
c00057c5:	8b 00                	mov    (%eax),%eax
c00057c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/lib/stdio.c:43
			strcpy(buf_ptr, arg_str);
c00057ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00057cd:	83 ec 08             	sub    $0x8,%esp
c00057d0:	ff 75 e8             	pushl  -0x18(%ebp)
c00057d3:	50                   	push   %eax
c00057d4:	e8 a6 e3 ff ff       	call   c0003b7f <strcpy>
c00057d9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:44
			buf_ptr += strlen(arg_str);
c00057dc:	83 ec 0c             	sub    $0xc,%esp
c00057df:	ff 75 e8             	pushl  -0x18(%ebp)
c00057e2:	e8 ed e3 ff ff       	call   c0003bd4 <strlen>
c00057e7:	83 c4 10             	add    $0x10,%esp
c00057ea:	89 c2                	mov    %eax,%edx
c00057ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00057ef:	01 d0                	add    %edx,%eax
c00057f1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/stdio.c:45
			index_char = *(++index_ptr);
c00057f4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00057f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00057fb:	0f b6 00             	movzbl (%eax),%eax
c00057fe:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:46
			break;
c0005801:	e9 98 00 00 00       	jmp    c000589e <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:49

			case 'c':
			*(buf_ptr++) = va_arg(ap, char);
c0005806:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0005809:	8d 50 01             	lea    0x1(%eax),%edx
c000580c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c000580f:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c0005813:	8b 55 10             	mov    0x10(%ebp),%edx
c0005816:	0f b6 12             	movzbl (%edx),%edx
c0005819:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:50
			index_char = *(++index_ptr);
c000581b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c000581f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005822:	0f b6 00             	movzbl (%eax),%eax
c0005825:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:51
			break;
c0005828:	eb 74                	jmp    c000589e <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:54

			case 'd':
			arg_int = va_arg(ap, int);
c000582a:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c000582e:	8b 45 10             	mov    0x10(%ebp),%eax
c0005831:	8b 00                	mov    (%eax),%eax
c0005833:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/stdio.c:56
			/* 若是负数, 将其转为正数后,再正数前面输出个负号'-'. */
			if (arg_int < 0) {
c0005836:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c000583a:	79 0f                	jns    c000584b <vsprintf+0x110>
/work/x86_os_my/lib/stdio.c:57
				arg_int = 0 - arg_int;
c000583c:	f7 5d ec             	negl   -0x14(%ebp)
/work/x86_os_my/lib/stdio.c:58
				*buf_ptr++ = '-';
c000583f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0005842:	8d 50 01             	lea    0x1(%eax),%edx
c0005845:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0005848:	c6 00 2d             	movb   $0x2d,(%eax)
/work/x86_os_my/lib/stdio.c:60
			}
			itoa(arg_int, &buf_ptr, 10); 
c000584b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000584e:	83 ec 04             	sub    $0x4,%esp
c0005851:	6a 0a                	push   $0xa
c0005853:	8d 55 e4             	lea    -0x1c(%ebp),%edx
c0005856:	52                   	push   %edx
c0005857:	50                   	push   %eax
c0005858:	e8 5f fe ff ff       	call   c00056bc <itoa>
c000585d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:61
			index_char = *(++index_ptr);
c0005860:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0005864:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005867:	0f b6 00             	movzbl (%eax),%eax
c000586a:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:62
			break;
c000586d:	eb 2f                	jmp    c000589e <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:65

			case 'x':
			arg_int = va_arg(ap, int);
c000586f:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c0005873:	8b 45 10             	mov    0x10(%ebp),%eax
c0005876:	8b 00                	mov    (%eax),%eax
c0005878:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/stdio.c:66
			itoa(arg_int, &buf_ptr, 16); 
c000587b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000587e:	83 ec 04             	sub    $0x4,%esp
c0005881:	6a 10                	push   $0x10
c0005883:	8d 55 e4             	lea    -0x1c(%ebp),%edx
c0005886:	52                   	push   %edx
c0005887:	50                   	push   %eax
c0005888:	e8 2f fe ff ff       	call   c00056bc <itoa>
c000588d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:67
			index_char = *(++index_ptr); // 跳过格式字符并更新index_char
c0005890:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0005894:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005897:	0f b6 00             	movzbl (%eax),%eax
c000589a:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:68
			break;
c000589d:	90                   	nop
/work/x86_os_my/lib/stdio.c:33
	char* buf_ptr = str;
	const char* index_ptr = format;
	char index_char = *index_ptr;
	int32_t arg_int;
	char* arg_str;
	while(index_char) {
c000589e:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c00058a2:	0f 85 b3 fe ff ff    	jne    c000575b <vsprintf+0x20>
/work/x86_os_my/lib/stdio.c:71
			itoa(arg_int, &buf_ptr, 16); 
			index_char = *(++index_ptr); // 跳过格式字符并更新index_char
			break;
		}
	}
	return strlen(str);
c00058a8:	83 ec 0c             	sub    $0xc,%esp
c00058ab:	ff 75 08             	pushl  0x8(%ebp)
c00058ae:	e8 21 e3 ff ff       	call   c0003bd4 <strlen>
c00058b3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:72
}
c00058b6:	c9                   	leave  
c00058b7:	c3                   	ret    

c00058b8 <sprintf>:
sprintf():
/work/x86_os_my/lib/stdio.c:75

/* 同printf不同的地方就是字符串不是写到终端,而是写到buf中 */
uint32_t sprintf(char* buf, const char* format, ...) {
c00058b8:	55                   	push   %ebp
c00058b9:	89 e5                	mov    %esp,%ebp
c00058bb:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/stdio.c:78
	va_list args;
	uint32_t retval;
	va_start(args, format);
c00058be:	8d 45 0c             	lea    0xc(%ebp),%eax
c00058c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:79
	retval = vsprintf(buf, format, args);
c00058c4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00058c7:	83 ec 04             	sub    $0x4,%esp
c00058ca:	ff 75 f4             	pushl  -0xc(%ebp)
c00058cd:	50                   	push   %eax
c00058ce:	ff 75 08             	pushl  0x8(%ebp)
c00058d1:	e8 65 fe ff ff       	call   c000573b <vsprintf>
c00058d6:	83 c4 10             	add    $0x10,%esp
c00058d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/stdio.c:80
	va_end(args);
c00058dc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:81
	return retval;
c00058e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/lib/stdio.c:82
}
c00058e6:	c9                   	leave  
c00058e7:	c3                   	ret    

c00058e8 <printf>:
printf():
/work/x86_os_my/lib/stdio.c:85

/* 格式化输出字符串format */
uint32_t printf(const char* format, ...) {
c00058e8:	55                   	push   %ebp
c00058e9:	89 e5                	mov    %esp,%ebp
c00058eb:	57                   	push   %edi
c00058ec:	81 ec 14 04 00 00    	sub    $0x414,%esp
/work/x86_os_my/lib/stdio.c:87
	va_list args;
	va_start(args, format);	       // 使args指向format
c00058f2:	8d 45 08             	lea    0x8(%ebp),%eax
c00058f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:88
	char buf[1024] = {0};	       // 用于存储拼接后的字符串
c00058f8:	8d 95 f4 fb ff ff    	lea    -0x40c(%ebp),%edx
c00058fe:	b8 00 00 00 00       	mov    $0x0,%eax
c0005903:	b9 00 01 00 00       	mov    $0x100,%ecx
c0005908:	89 d7                	mov    %edx,%edi
c000590a:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/lib/stdio.c:89
	vsprintf(buf, format, args);
c000590c:	8b 45 08             	mov    0x8(%ebp),%eax
c000590f:	83 ec 04             	sub    $0x4,%esp
c0005912:	ff 75 f4             	pushl  -0xc(%ebp)
c0005915:	50                   	push   %eax
c0005916:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c000591c:	50                   	push   %eax
c000591d:	e8 19 fe ff ff       	call   c000573b <vsprintf>
c0005922:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:90
	va_end(args);
c0005925:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:91
	return write(buf);
c000592c:	83 ec 0c             	sub    $0xc,%esp
c000592f:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c0005935:	50                   	push   %eax
c0005936:	e8 9f fc ff ff       	call   c00055da <write>
c000593b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:92
}
c000593e:	8b 7d fc             	mov    -0x4(%ebp),%edi
c0005941:	c9                   	leave  
c0005942:	c3                   	ret    

c0005943 <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c0005943:	55                   	push   %ebp
c0005944:	89 e5                	mov    %esp,%ebp
c0005946:	83 ec 08             	sub    $0x8,%esp
c0005949:	8b 55 08             	mov    0x8(%ebp),%edx
c000594c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000594f:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0005953:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c0005956:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c000595a:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c000595e:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c000595f:	90                   	nop
c0005960:	c9                   	leave  
c0005961:	c3                   	ret    

c0005962 <outsw>:
outsw():
/work/x86_os_my/lib/kernel/io.h:26

/* 将addr处起始的word_cnt个字写入端口port */
static inline void outsw(uint16_t port, const void* addr, uint32_t word_cnt) {
c0005962:	55                   	push   %ebp
c0005963:	89 e5                	mov    %esp,%ebp
c0005965:	56                   	push   %esi
c0005966:	53                   	push   %ebx
c0005967:	83 ec 04             	sub    $0x4,%esp
c000596a:	8b 45 08             	mov    0x8(%ebp),%eax
c000596d:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/io.h:31
/*********************************************************
   +表示此限制即做输入又做输出.
   outsw是把ds:esi处的16位的内容写入port端口, 我们在设置段描述符时, 
   已经将ds,es,ss段的选择子都设置为相同的值了,此时不用担心数据错乱。*/
   asm volatile ("cld; rep outsw" : "+S" (addr), "+c" (word_cnt) : "d" (port));
c0005971:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c0005975:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0005978:	8b 45 10             	mov    0x10(%ebp),%eax
c000597b:	89 cb                	mov    %ecx,%ebx
c000597d:	89 de                	mov    %ebx,%esi
c000597f:	89 c1                	mov    %eax,%ecx
c0005981:	fc                   	cld    
c0005982:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
c0005985:	89 c8                	mov    %ecx,%eax
c0005987:	89 f3                	mov    %esi,%ebx
c0005989:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c000598c:	89 45 10             	mov    %eax,0x10(%ebp)
/work/x86_os_my/lib/kernel/io.h:33
/******************************************************/
}
c000598f:	90                   	nop
c0005990:	83 c4 04             	add    $0x4,%esp
c0005993:	5b                   	pop    %ebx
c0005994:	5e                   	pop    %esi
c0005995:	5d                   	pop    %ebp
c0005996:	c3                   	ret    

c0005997 <inb>:
inb():
/work/x86_os_my/lib/kernel/io.h:36

/* 将从端口port读入的一个字节返回 */
static inline uint8_t inb(uint16_t port) {
c0005997:	55                   	push   %ebp
c0005998:	89 e5                	mov    %esp,%ebp
c000599a:	83 ec 14             	sub    $0x14,%esp
c000599d:	8b 45 08             	mov    0x8(%ebp),%eax
c00059a0:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/io.h:38
   uint8_t data;
   asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00059a4:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c00059a8:	89 c2                	mov    %eax,%edx
c00059aa:	ec                   	in     (%dx),%al
c00059ab:	88 45 ff             	mov    %al,-0x1(%ebp)
/work/x86_os_my/lib/kernel/io.h:39
   return data;
c00059ae:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
/work/x86_os_my/lib/kernel/io.h:40
}
c00059b2:	c9                   	leave  
c00059b3:	c3                   	ret    

c00059b4 <insw>:
insw():
/work/x86_os_my/lib/kernel/io.h:43

/* 将从端口port读入的word_cnt个字写入addr */
static inline void insw(uint16_t port, void* addr, uint32_t word_cnt) {
c00059b4:	55                   	push   %ebp
c00059b5:	89 e5                	mov    %esp,%ebp
c00059b7:	57                   	push   %edi
c00059b8:	53                   	push   %ebx
c00059b9:	83 ec 04             	sub    $0x4,%esp
c00059bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00059bf:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/io.h:48
/******************************************************
   insw是将从端口port处读入的16位内容写入es:edi指向的内存,
   我们在设置段描述符时, 已经将ds,es,ss段的选择子都设置为相同的值了,
   此时不用担心数据错乱。*/
   asm volatile ("cld; rep insw" : "+D" (addr), "+c" (word_cnt) : "d" (port) : "memory");
c00059c3:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c00059c7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c00059ca:	8b 45 10             	mov    0x10(%ebp),%eax
c00059cd:	89 cb                	mov    %ecx,%ebx
c00059cf:	89 df                	mov    %ebx,%edi
c00059d1:	89 c1                	mov    %eax,%ecx
c00059d3:	fc                   	cld    
c00059d4:	66 f3 6d             	rep insw (%dx),%es:(%edi)
c00059d7:	89 c8                	mov    %ecx,%eax
c00059d9:	89 fb                	mov    %edi,%ebx
c00059db:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c00059de:	89 45 10             	mov    %eax,0x10(%ebp)
/work/x86_os_my/lib/kernel/io.h:50
/******************************************************/
}
c00059e1:	90                   	nop
c00059e2:	83 c4 04             	add    $0x4,%esp
c00059e5:	5b                   	pop    %ebx
c00059e6:	5f                   	pop    %edi
c00059e7:	5d                   	pop    %ebp
c00059e8:	c3                   	ret    

c00059e9 <select_disk>:
select_disk():
/work/x86_os_my/device/ide.c:78
} __attribute__ ((packed));


/////////////////////////////////////// ide驱动部分 ////////////////////////////////////////////////
/* 选择读写的硬盘 */
static void select_disk(struct disk* hd) {
c00059e9:	55                   	push   %ebp
c00059ea:	89 e5                	mov    %esp,%ebp
c00059ec:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/device/ide.c:79
	uint8_t reg_device = BIT_DEV_MBS | BIT_DEV_LBA;
c00059ef:	c6 45 ff e0          	movb   $0xe0,-0x1(%ebp)
/work/x86_os_my/device/ide.c:80
	if (hd->dev_no == 1) {	// 若是从盘就置DEV位为1
c00059f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00059f6:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
c00059fa:	3c 01                	cmp    $0x1,%al
c00059fc:	75 04                	jne    c0005a02 <select_disk+0x19>
/work/x86_os_my/device/ide.c:81
		reg_device |= BIT_DEV_DEV;
c00059fe:	80 4d ff 10          	orb    $0x10,-0x1(%ebp)
/work/x86_os_my/device/ide.c:83
	}
	outb(reg_dev(hd->my_channel), reg_device);
c0005a02:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c0005a06:	8b 45 08             	mov    0x8(%ebp),%eax
c0005a09:	8b 40 08             	mov    0x8(%eax),%eax
c0005a0c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005a10:	83 c0 06             	add    $0x6,%eax
c0005a13:	0f b7 c0             	movzwl %ax,%eax
c0005a16:	52                   	push   %edx
c0005a17:	50                   	push   %eax
c0005a18:	e8 26 ff ff ff       	call   c0005943 <outb>
c0005a1d:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/ide.c:84
}
c0005a20:	90                   	nop
c0005a21:	c9                   	leave  
c0005a22:	c3                   	ret    

c0005a23 <select_sector>:
select_sector():
/work/x86_os_my/device/ide.c:87

/* 向硬盘控制器写入起始扇区地址及要读写的扇区数 */
static void select_sector(struct disk* hd, uint32_t lba, uint8_t sec_cnt) {
c0005a23:	55                   	push   %ebp
c0005a24:	89 e5                	mov    %esp,%ebp
c0005a26:	83 ec 28             	sub    $0x28,%esp
c0005a29:	8b 45 10             	mov    0x10(%ebp),%eax
c0005a2c:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/device/ide.c:88
	ASSERT(lba <= max_lba);
c0005a2f:	81 7d 0c ff 7f 02 00 	cmpl   $0x27fff,0xc(%ebp)
c0005a36:	76 19                	jbe    c0005a51 <select_sector+0x2e>
/work/x86_os_my/device/ide.c:88 (discriminator 1)
c0005a38:	68 70 96 00 c0       	push   $0xc0009670
c0005a3d:	68 08 98 00 c0       	push   $0xc0009808
c0005a42:	6a 58                	push   $0x58
c0005a44:	68 7f 96 00 c0       	push   $0xc000967f
c0005a49:	e8 e4 cb ff ff       	call   c0002632 <panic_spin>
c0005a4e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:89
	struct ide_channel* channel = hd->my_channel;
c0005a51:	8b 45 08             	mov    0x8(%ebp),%eax
c0005a54:	8b 40 08             	mov    0x8(%eax),%eax
c0005a57:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:92

	/* 写入要读写的扇区数*/
	outb(reg_sect_cnt(channel), sec_cnt);	// 如果sec_cnt为0,则表示写入256个扇区
c0005a5a:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c0005a5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005a61:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005a65:	83 c0 02             	add    $0x2,%eax
c0005a68:	0f b7 c0             	movzwl %ax,%eax
c0005a6b:	83 ec 08             	sub    $0x8,%esp
c0005a6e:	52                   	push   %edx
c0005a6f:	50                   	push   %eax
c0005a70:	e8 ce fe ff ff       	call   c0005943 <outb>
c0005a75:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:95

	/* 写入lba地址(即扇区号) */
	outb(reg_lba_l(channel), lba);			// lba地址的低8位,不用单独取出低8位.outb函数中的汇编指令outb %b0, %w1会只用al。
c0005a78:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005a7b:	0f b6 d0             	movzbl %al,%edx
c0005a7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005a81:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005a85:	83 c0 03             	add    $0x3,%eax
c0005a88:	0f b7 c0             	movzwl %ax,%eax
c0005a8b:	83 ec 08             	sub    $0x8,%esp
c0005a8e:	52                   	push   %edx
c0005a8f:	50                   	push   %eax
c0005a90:	e8 ae fe ff ff       	call   c0005943 <outb>
c0005a95:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:96
	outb(reg_lba_m(channel), lba >> 8);		// lba地址的8~15位
c0005a98:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005a9b:	c1 e8 08             	shr    $0x8,%eax
c0005a9e:	0f b6 d0             	movzbl %al,%edx
c0005aa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005aa4:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005aa8:	83 c0 04             	add    $0x4,%eax
c0005aab:	0f b7 c0             	movzwl %ax,%eax
c0005aae:	83 ec 08             	sub    $0x8,%esp
c0005ab1:	52                   	push   %edx
c0005ab2:	50                   	push   %eax
c0005ab3:	e8 8b fe ff ff       	call   c0005943 <outb>
c0005ab8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:97
	outb(reg_lba_h(channel), lba >> 16);	// lba地址的16~23位
c0005abb:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005abe:	c1 e8 10             	shr    $0x10,%eax
c0005ac1:	0f b6 d0             	movzbl %al,%edx
c0005ac4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005ac7:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005acb:	83 c0 05             	add    $0x5,%eax
c0005ace:	0f b7 c0             	movzwl %ax,%eax
c0005ad1:	83 ec 08             	sub    $0x8,%esp
c0005ad4:	52                   	push   %edx
c0005ad5:	50                   	push   %eax
c0005ad6:	e8 68 fe ff ff       	call   c0005943 <outb>
c0005adb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:101

	/* 因为lba地址的24~27位要存储在device寄存器的0～3位,
	* 无法单独写入这4位,所以在此处把device寄存器再重新写入一次*/
	outb(reg_dev(channel), BIT_DEV_MBS | BIT_DEV_LBA | (hd->dev_no == 1 ? BIT_DEV_DEV : 0) | lba >> 24);
c0005ade:	8b 45 08             	mov    0x8(%ebp),%eax
c0005ae1:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
c0005ae5:	3c 01                	cmp    $0x1,%al
c0005ae7:	75 07                	jne    c0005af0 <select_sector+0xcd>
/work/x86_os_my/device/ide.c:101 (discriminator 1)
c0005ae9:	ba f0 ff ff ff       	mov    $0xfffffff0,%edx
c0005aee:	eb 05                	jmp    c0005af5 <select_sector+0xd2>
/work/x86_os_my/device/ide.c:101 (discriminator 2)
c0005af0:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
/work/x86_os_my/device/ide.c:101 (discriminator 4)
c0005af5:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005af8:	c1 e8 18             	shr    $0x18,%eax
c0005afb:	09 d0                	or     %edx,%eax
c0005afd:	0f b6 d0             	movzbl %al,%edx
c0005b00:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005b03:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005b07:	83 c0 06             	add    $0x6,%eax
c0005b0a:	0f b7 c0             	movzwl %ax,%eax
c0005b0d:	83 ec 08             	sub    $0x8,%esp
c0005b10:	52                   	push   %edx
c0005b11:	50                   	push   %eax
c0005b12:	e8 2c fe ff ff       	call   c0005943 <outb>
c0005b17:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:102 (discriminator 4)
}
c0005b1a:	90                   	nop
c0005b1b:	c9                   	leave  
c0005b1c:	c3                   	ret    

c0005b1d <cmd_out>:
cmd_out():
/work/x86_os_my/device/ide.c:105

/* 向通道channel发命令cmd */
static void cmd_out(struct ide_channel* channel, uint8_t cmd) {
c0005b1d:	55                   	push   %ebp
c0005b1e:	89 e5                	mov    %esp,%ebp
c0005b20:	83 ec 04             	sub    $0x4,%esp
c0005b23:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005b26:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/device/ide.c:107
	/* 只要向硬盘发出了命令便将此标记置为true,硬盘中断处理程序需要根据它来判断 */
	channel->expecting_intr = true;
c0005b29:	8b 45 08             	mov    0x8(%ebp),%eax
c0005b2c:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
/work/x86_os_my/device/ide.c:108
	outb(reg_cmd(channel), cmd);
c0005b33:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0005b37:	8b 45 08             	mov    0x8(%ebp),%eax
c0005b3a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005b3e:	83 c0 07             	add    $0x7,%eax
c0005b41:	0f b7 c0             	movzwl %ax,%eax
c0005b44:	52                   	push   %edx
c0005b45:	50                   	push   %eax
c0005b46:	e8 f8 fd ff ff       	call   c0005943 <outb>
c0005b4b:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/ide.c:109
}
c0005b4e:	90                   	nop
c0005b4f:	c9                   	leave  
c0005b50:	c3                   	ret    

c0005b51 <read_from_sector>:
read_from_sector():
/work/x86_os_my/device/ide.c:112

/* 硬盘读入sec_cnt个扇区的数据到buf */
static void read_from_sector(struct disk* hd, void* buf, uint8_t sec_cnt) {
c0005b51:	55                   	push   %ebp
c0005b52:	89 e5                	mov    %esp,%ebp
c0005b54:	83 ec 14             	sub    $0x14,%esp
c0005b57:	8b 45 10             	mov    0x10(%ebp),%eax
c0005b5a:	88 45 ec             	mov    %al,-0x14(%ebp)
/work/x86_os_my/device/ide.c:114
	uint32_t size_in_byte;
	if (sec_cnt == 0) {
c0005b5d:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
c0005b61:	75 09                	jne    c0005b6c <read_from_sector+0x1b>
/work/x86_os_my/device/ide.c:116
		/* 因为sec_cnt是8位变量,由主调函数将其赋值时,若为256则会将最高位的1丢掉变为0 */
		size_in_byte = 256 * 512;
c0005b63:	c7 45 fc 00 00 02 00 	movl   $0x20000,-0x4(%ebp)
c0005b6a:	eb 0a                	jmp    c0005b76 <read_from_sector+0x25>
/work/x86_os_my/device/ide.c:118
	} else { 
		size_in_byte = sec_cnt * 512; 
c0005b6c:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0005b70:	c1 e0 09             	shl    $0x9,%eax
c0005b73:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/device/ide.c:120
	}
	insw(reg_data(hd->my_channel), buf, size_in_byte / 2);
c0005b76:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0005b79:	d1 e8                	shr    %eax
c0005b7b:	89 c2                	mov    %eax,%edx
c0005b7d:	8b 45 08             	mov    0x8(%ebp),%eax
c0005b80:	8b 40 08             	mov    0x8(%eax),%eax
c0005b83:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005b87:	0f b7 c0             	movzwl %ax,%eax
c0005b8a:	52                   	push   %edx
c0005b8b:	ff 75 0c             	pushl  0xc(%ebp)
c0005b8e:	50                   	push   %eax
c0005b8f:	e8 20 fe ff ff       	call   c00059b4 <insw>
c0005b94:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/device/ide.c:121
}
c0005b97:	90                   	nop
c0005b98:	c9                   	leave  
c0005b99:	c3                   	ret    

c0005b9a <write2sector>:
write2sector():
/work/x86_os_my/device/ide.c:124

/* 将buf中sec_cnt扇区的数据写入硬盘 */
static void write2sector(struct disk* hd, void* buf, uint8_t sec_cnt) {
c0005b9a:	55                   	push   %ebp
c0005b9b:	89 e5                	mov    %esp,%ebp
c0005b9d:	83 ec 14             	sub    $0x14,%esp
c0005ba0:	8b 45 10             	mov    0x10(%ebp),%eax
c0005ba3:	88 45 ec             	mov    %al,-0x14(%ebp)
/work/x86_os_my/device/ide.c:126
	uint32_t size_in_byte;
	if (sec_cnt == 0) {
c0005ba6:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
c0005baa:	75 09                	jne    c0005bb5 <write2sector+0x1b>
/work/x86_os_my/device/ide.c:128
		/* 因为sec_cnt是8位变量,由主调函数将其赋值时,若为256则会将最高位的1丢掉变为0 */
		size_in_byte = 256 * 512;
c0005bac:	c7 45 fc 00 00 02 00 	movl   $0x20000,-0x4(%ebp)
c0005bb3:	eb 0a                	jmp    c0005bbf <write2sector+0x25>
/work/x86_os_my/device/ide.c:130
	} else { 
		size_in_byte = sec_cnt * 512; 
c0005bb5:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0005bb9:	c1 e0 09             	shl    $0x9,%eax
c0005bbc:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/device/ide.c:132
	}
	outsw(reg_data(hd->my_channel), buf, size_in_byte / 2);
c0005bbf:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0005bc2:	d1 e8                	shr    %eax
c0005bc4:	89 c2                	mov    %eax,%edx
c0005bc6:	8b 45 08             	mov    0x8(%ebp),%eax
c0005bc9:	8b 40 08             	mov    0x8(%eax),%eax
c0005bcc:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005bd0:	0f b7 c0             	movzwl %ax,%eax
c0005bd3:	52                   	push   %edx
c0005bd4:	ff 75 0c             	pushl  0xc(%ebp)
c0005bd7:	50                   	push   %eax
c0005bd8:	e8 85 fd ff ff       	call   c0005962 <outsw>
c0005bdd:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/device/ide.c:133
}
c0005be0:	90                   	nop
c0005be1:	c9                   	leave  
c0005be2:	c3                   	ret    

c0005be3 <busy_wait>:
busy_wait():
/work/x86_os_my/device/ide.c:136

/* 等待30秒 */
static bool busy_wait(struct disk* hd) {
c0005be3:	55                   	push   %ebp
c0005be4:	89 e5                	mov    %esp,%ebp
c0005be6:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ide.c:137
	struct ide_channel* channel = hd->my_channel;
c0005be9:	8b 45 08             	mov    0x8(%ebp),%eax
c0005bec:	8b 40 08             	mov    0x8(%eax),%eax
c0005bef:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:138
	uint16_t time_limit = 30 * 1000;	// 可以等待30000毫秒
c0005bf2:	66 c7 45 f6 30 75    	movw   $0x7530,-0xa(%ebp)
/work/x86_os_my/device/ide.c:139
	while (time_limit -= 10 >= 0) {
c0005bf8:	eb 45                	jmp    c0005c3f <busy_wait+0x5c>
/work/x86_os_my/device/ide.c:140
		if (!(inb(reg_status(channel)) & BIT_STAT_BSY)) {
c0005bfa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005bfd:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005c01:	83 c0 07             	add    $0x7,%eax
c0005c04:	0f b7 c0             	movzwl %ax,%eax
c0005c07:	50                   	push   %eax
c0005c08:	e8 8a fd ff ff       	call   c0005997 <inb>
c0005c0d:	83 c4 04             	add    $0x4,%esp
c0005c10:	84 c0                	test   %al,%al
c0005c12:	78 1e                	js     c0005c32 <busy_wait+0x4f>
/work/x86_os_my/device/ide.c:141
			return (inb(reg_status(channel)) & BIT_STAT_DRQ);
c0005c14:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005c17:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005c1b:	83 c0 07             	add    $0x7,%eax
c0005c1e:	0f b7 c0             	movzwl %ax,%eax
c0005c21:	50                   	push   %eax
c0005c22:	e8 70 fd ff ff       	call   c0005997 <inb>
c0005c27:	83 c4 04             	add    $0x4,%esp
c0005c2a:	0f b6 c0             	movzbl %al,%eax
c0005c2d:	83 e0 08             	and    $0x8,%eax
c0005c30:	eb 1e                	jmp    c0005c50 <busy_wait+0x6d>
/work/x86_os_my/device/ide.c:143
		} else {
			mtime_sleep(10);			// 睡眠10毫秒
c0005c32:	83 ec 0c             	sub    $0xc,%esp
c0005c35:	6a 0a                	push   $0xa
c0005c37:	e8 81 c2 ff ff       	call   c0001ebd <mtime_sleep>
c0005c3c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:139

/* 等待30秒 */
static bool busy_wait(struct disk* hd) {
	struct ide_channel* channel = hd->my_channel;
	uint16_t time_limit = 30 * 1000;	// 可以等待30000毫秒
	while (time_limit -= 10 >= 0) {
c0005c3f:	66 83 6d f6 01       	subw   $0x1,-0xa(%ebp)
c0005c44:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c0005c49:	75 af                	jne    c0005bfa <busy_wait+0x17>
/work/x86_os_my/device/ide.c:146
			return (inb(reg_status(channel)) & BIT_STAT_DRQ);
		} else {
			mtime_sleep(10);			// 睡眠10毫秒
		}
	}
	return false;
c0005c4b:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/device/ide.c:147
}
c0005c50:	c9                   	leave  
c0005c51:	c3                   	ret    

c0005c52 <ide_read>:
ide_read():
/work/x86_os_my/device/ide.c:150

/* 从硬盘读取sec_cnt个扇区到buf */
void ide_read(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt) { 
c0005c52:	55                   	push   %ebp
c0005c53:	89 e5                	mov    %esp,%ebp
c0005c55:	83 ec 58             	sub    $0x58,%esp
/work/x86_os_my/device/ide.c:151
	ASSERT(lba <= max_lba);
c0005c58:	81 7d 0c ff 7f 02 00 	cmpl   $0x27fff,0xc(%ebp)
c0005c5f:	76 1c                	jbe    c0005c7d <ide_read+0x2b>
/work/x86_os_my/device/ide.c:151 (discriminator 1)
c0005c61:	68 70 96 00 c0       	push   $0xc0009670
c0005c66:	68 18 98 00 c0       	push   $0xc0009818
c0005c6b:	68 97 00 00 00       	push   $0x97
c0005c70:	68 7f 96 00 c0       	push   $0xc000967f
c0005c75:	e8 b8 c9 ff ff       	call   c0002632 <panic_spin>
c0005c7a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:152
	ASSERT(sec_cnt > 0);
c0005c7d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0005c81:	75 1c                	jne    c0005c9f <ide_read+0x4d>
/work/x86_os_my/device/ide.c:152 (discriminator 1)
c0005c83:	68 8c 96 00 c0       	push   $0xc000968c
c0005c88:	68 18 98 00 c0       	push   $0xc0009818
c0005c8d:	68 98 00 00 00       	push   $0x98
c0005c92:	68 7f 96 00 c0       	push   $0xc000967f
c0005c97:	e8 96 c9 ff ff       	call   c0002632 <panic_spin>
c0005c9c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:153
	lock_acquire (&hd->my_channel->lock);
c0005c9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005ca2:	8b 40 08             	mov    0x8(%eax),%eax
c0005ca5:	83 c0 0c             	add    $0xc,%eax
c0005ca8:	83 ec 0c             	sub    $0xc,%esp
c0005cab:	50                   	push   %eax
c0005cac:	e8 1e ed ff ff       	call   c00049cf <lock_acquire>
c0005cb1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:156

	/* 1 先选择操作的硬盘 */
	select_disk(hd);
c0005cb4:	83 ec 0c             	sub    $0xc,%esp
c0005cb7:	ff 75 08             	pushl  0x8(%ebp)
c0005cba:	e8 2a fd ff ff       	call   c00059e9 <select_disk>
c0005cbf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:159

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
c0005cc2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/ide.c:160
	while(secs_done < sec_cnt) {
c0005cc9:	e9 d4 00 00 00       	jmp    c0005da2 <ide_read+0x150>
/work/x86_os_my/device/ide.c:161
		if ((secs_done + 256) <= sec_cnt) {
c0005cce:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005cd1:	05 00 01 00 00       	add    $0x100,%eax
c0005cd6:	3b 45 14             	cmp    0x14(%ebp),%eax
c0005cd9:	77 09                	ja     c0005ce4 <ide_read+0x92>
/work/x86_os_my/device/ide.c:162
			secs_op = 256;
c0005cdb:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
c0005ce2:	eb 09                	jmp    c0005ced <ide_read+0x9b>
/work/x86_os_my/device/ide.c:164
		} else {
			secs_op = sec_cnt - secs_done;
c0005ce4:	8b 45 14             	mov    0x14(%ebp),%eax
c0005ce7:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0005cea:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:168
		}

		/* 2 写入待读入的扇区数和起始扇区号 */
		select_sector(hd, lba + secs_done, secs_op);
c0005ced:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005cf0:	0f b6 c0             	movzbl %al,%eax
c0005cf3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0005cf6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0005cf9:	01 ca                	add    %ecx,%edx
c0005cfb:	83 ec 04             	sub    $0x4,%esp
c0005cfe:	50                   	push   %eax
c0005cff:	52                   	push   %edx
c0005d00:	ff 75 08             	pushl  0x8(%ebp)
c0005d03:	e8 1b fd ff ff       	call   c0005a23 <select_sector>
c0005d08:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:171

		/* 3 执行的命令写入reg_cmd寄存器 */
		cmd_out(hd->my_channel, CMD_READ_SECTOR);	// 准备开始读数据
c0005d0b:	8b 45 08             	mov    0x8(%ebp),%eax
c0005d0e:	8b 40 08             	mov    0x8(%eax),%eax
c0005d11:	83 ec 08             	sub    $0x8,%esp
c0005d14:	6a 20                	push   $0x20
c0005d16:	50                   	push   %eax
c0005d17:	e8 01 fe ff ff       	call   c0005b1d <cmd_out>
c0005d1c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:176

		/*********************   阻塞自己的时机  ***********************
		在硬盘已经开始工作(开始在内部读数据或写数据)后才能阻塞自己,现在硬盘已经开始忙了,
		将自己阻塞,等待硬盘完成读操作后通过中断处理程序唤醒自己*/
		sema_down(&hd->my_channel->disk_done);
c0005d1f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005d22:	8b 40 08             	mov    0x8(%eax),%eax
c0005d25:	83 c0 2c             	add    $0x2c,%eax
c0005d28:	83 ec 0c             	sub    $0xc,%esp
c0005d2b:	50                   	push   %eax
c0005d2c:	e8 f4 ea ff ff       	call   c0004825 <sema_down>
c0005d31:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:181
		/*************************************************************/

		/* 4 检测硬盘状态是否可读 */
		/* 醒来后开始执行下面代码*/
		if (!busy_wait(hd)) {	// 若失败
c0005d34:	83 ec 0c             	sub    $0xc,%esp
c0005d37:	ff 75 08             	pushl  0x8(%ebp)
c0005d3a:	e8 a4 fe ff ff       	call   c0005be3 <busy_wait>
c0005d3f:	83 c4 10             	add    $0x10,%esp
c0005d42:	85 c0                	test   %eax,%eax
c0005d44:	75 33                	jne    c0005d79 <ide_read+0x127>
/work/x86_os_my/device/ide.c:183
			char error[64];
			sprintf(error, "%s read sector %d failed!!!!!!\n", hd->name, lba);
c0005d46:	8b 45 08             	mov    0x8(%ebp),%eax
c0005d49:	ff 75 0c             	pushl  0xc(%ebp)
c0005d4c:	50                   	push   %eax
c0005d4d:	68 98 96 00 c0       	push   $0xc0009698
c0005d52:	8d 45 b0             	lea    -0x50(%ebp),%eax
c0005d55:	50                   	push   %eax
c0005d56:	e8 5d fb ff ff       	call   c00058b8 <sprintf>
c0005d5b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:184
			PANIC(error);
c0005d5e:	8d 45 b0             	lea    -0x50(%ebp),%eax
c0005d61:	50                   	push   %eax
c0005d62:	68 18 98 00 c0       	push   $0xc0009818
c0005d67:	68 b8 00 00 00       	push   $0xb8
c0005d6c:	68 7f 96 00 c0       	push   $0xc000967f
c0005d71:	e8 bc c8 ff ff       	call   c0002632 <panic_spin>
c0005d76:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:188
		}

		/* 5 把数据从硬盘的缓冲区中读出 */
		read_from_sector(hd, (void*)((uint32_t)buf + secs_done * 512), secs_op);
c0005d79:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005d7c:	0f b6 c0             	movzbl %al,%eax
c0005d7f:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0005d82:	89 d1                	mov    %edx,%ecx
c0005d84:	c1 e1 09             	shl    $0x9,%ecx
c0005d87:	8b 55 10             	mov    0x10(%ebp),%edx
c0005d8a:	01 ca                	add    %ecx,%edx
c0005d8c:	83 ec 04             	sub    $0x4,%esp
c0005d8f:	50                   	push   %eax
c0005d90:	52                   	push   %edx
c0005d91:	ff 75 08             	pushl  0x8(%ebp)
c0005d94:	e8 b8 fd ff ff       	call   c0005b51 <read_from_sector>
c0005d99:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:189
		secs_done += secs_op;
c0005d9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005d9f:	01 45 f0             	add    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:160
	/* 1 先选择操作的硬盘 */
	select_disk(hd);

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
	while(secs_done < sec_cnt) {
c0005da2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005da5:	3b 45 14             	cmp    0x14(%ebp),%eax
c0005da8:	0f 82 20 ff ff ff    	jb     c0005cce <ide_read+0x7c>
/work/x86_os_my/device/ide.c:191

		/* 5 把数据从硬盘的缓冲区中读出 */
		read_from_sector(hd, (void*)((uint32_t)buf + secs_done * 512), secs_op);
		secs_done += secs_op;
	}
	lock_release(&hd->my_channel->lock);
c0005dae:	8b 45 08             	mov    0x8(%ebp),%eax
c0005db1:	8b 40 08             	mov    0x8(%eax),%eax
c0005db4:	83 c0 0c             	add    $0xc,%eax
c0005db7:	83 ec 0c             	sub    $0xc,%esp
c0005dba:	50                   	push   %eax
c0005dbb:	e8 86 ec ff ff       	call   c0004a46 <lock_release>
c0005dc0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:192
}
c0005dc3:	90                   	nop
c0005dc4:	c9                   	leave  
c0005dc5:	c3                   	ret    

c0005dc6 <ide_write>:
ide_write():
/work/x86_os_my/device/ide.c:195

/* 将buf中sec_cnt扇区数据写入硬盘 */
void ide_write(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt) {
c0005dc6:	55                   	push   %ebp
c0005dc7:	89 e5                	mov    %esp,%ebp
c0005dc9:	83 ec 58             	sub    $0x58,%esp
/work/x86_os_my/device/ide.c:196
	ASSERT(lba <= max_lba);
c0005dcc:	81 7d 0c ff 7f 02 00 	cmpl   $0x27fff,0xc(%ebp)
c0005dd3:	76 1c                	jbe    c0005df1 <ide_write+0x2b>
/work/x86_os_my/device/ide.c:196 (discriminator 1)
c0005dd5:	68 70 96 00 c0       	push   $0xc0009670
c0005dda:	68 24 98 00 c0       	push   $0xc0009824
c0005ddf:	68 c4 00 00 00       	push   $0xc4
c0005de4:	68 7f 96 00 c0       	push   $0xc000967f
c0005de9:	e8 44 c8 ff ff       	call   c0002632 <panic_spin>
c0005dee:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:197
	ASSERT(sec_cnt > 0);
c0005df1:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0005df5:	75 1c                	jne    c0005e13 <ide_write+0x4d>
/work/x86_os_my/device/ide.c:197 (discriminator 1)
c0005df7:	68 8c 96 00 c0       	push   $0xc000968c
c0005dfc:	68 24 98 00 c0       	push   $0xc0009824
c0005e01:	68 c5 00 00 00       	push   $0xc5
c0005e06:	68 7f 96 00 c0       	push   $0xc000967f
c0005e0b:	e8 22 c8 ff ff       	call   c0002632 <panic_spin>
c0005e10:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:198
	lock_acquire (&hd->my_channel->lock);
c0005e13:	8b 45 08             	mov    0x8(%ebp),%eax
c0005e16:	8b 40 08             	mov    0x8(%eax),%eax
c0005e19:	83 c0 0c             	add    $0xc,%eax
c0005e1c:	83 ec 0c             	sub    $0xc,%esp
c0005e1f:	50                   	push   %eax
c0005e20:	e8 aa eb ff ff       	call   c00049cf <lock_acquire>
c0005e25:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:201

	/* 1 先选择操作的硬盘 */
	select_disk(hd);
c0005e28:	83 ec 0c             	sub    $0xc,%esp
c0005e2b:	ff 75 08             	pushl  0x8(%ebp)
c0005e2e:	e8 b6 fb ff ff       	call   c00059e9 <select_disk>
c0005e33:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:204

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
c0005e36:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/ide.c:205
	while(secs_done < sec_cnt) {
c0005e3d:	e9 d4 00 00 00       	jmp    c0005f16 <ide_write+0x150>
/work/x86_os_my/device/ide.c:206
		if ((secs_done + 256) <= sec_cnt) {
c0005e42:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005e45:	05 00 01 00 00       	add    $0x100,%eax
c0005e4a:	3b 45 14             	cmp    0x14(%ebp),%eax
c0005e4d:	77 09                	ja     c0005e58 <ide_write+0x92>
/work/x86_os_my/device/ide.c:207
			secs_op = 256;
c0005e4f:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
c0005e56:	eb 09                	jmp    c0005e61 <ide_write+0x9b>
/work/x86_os_my/device/ide.c:209
		} else {
			secs_op = sec_cnt - secs_done;
c0005e58:	8b 45 14             	mov    0x14(%ebp),%eax
c0005e5b:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0005e5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:213
		}

		/* 2 写入待写入的扇区数和起始扇区号 */
		select_sector(hd, lba + secs_done, secs_op);
c0005e61:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005e64:	0f b6 c0             	movzbl %al,%eax
c0005e67:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0005e6a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0005e6d:	01 ca                	add    %ecx,%edx
c0005e6f:	83 ec 04             	sub    $0x4,%esp
c0005e72:	50                   	push   %eax
c0005e73:	52                   	push   %edx
c0005e74:	ff 75 08             	pushl  0x8(%ebp)
c0005e77:	e8 a7 fb ff ff       	call   c0005a23 <select_sector>
c0005e7c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:216

		/* 3 执行的命令写入reg_cmd寄存器 */
		cmd_out(hd->my_channel, CMD_WRITE_SECTOR);	// 准备开始写数据
c0005e7f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005e82:	8b 40 08             	mov    0x8(%eax),%eax
c0005e85:	83 ec 08             	sub    $0x8,%esp
c0005e88:	6a 30                	push   $0x30
c0005e8a:	50                   	push   %eax
c0005e8b:	e8 8d fc ff ff       	call   c0005b1d <cmd_out>
c0005e90:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:219

		/* 4 检测硬盘状态是否可读 */
		if (!busy_wait(hd)) {	// 若失败
c0005e93:	83 ec 0c             	sub    $0xc,%esp
c0005e96:	ff 75 08             	pushl  0x8(%ebp)
c0005e99:	e8 45 fd ff ff       	call   c0005be3 <busy_wait>
c0005e9e:	83 c4 10             	add    $0x10,%esp
c0005ea1:	85 c0                	test   %eax,%eax
c0005ea3:	75 33                	jne    c0005ed8 <ide_write+0x112>
/work/x86_os_my/device/ide.c:221
			char error[64];
			sprintf(error, "%s write sector %d failed!!!!!!\n", hd->name, lba);
c0005ea5:	8b 45 08             	mov    0x8(%ebp),%eax
c0005ea8:	ff 75 0c             	pushl  0xc(%ebp)
c0005eab:	50                   	push   %eax
c0005eac:	68 b8 96 00 c0       	push   $0xc00096b8
c0005eb1:	8d 45 b0             	lea    -0x50(%ebp),%eax
c0005eb4:	50                   	push   %eax
c0005eb5:	e8 fe f9 ff ff       	call   c00058b8 <sprintf>
c0005eba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:222
			PANIC(error);
c0005ebd:	8d 45 b0             	lea    -0x50(%ebp),%eax
c0005ec0:	50                   	push   %eax
c0005ec1:	68 24 98 00 c0       	push   $0xc0009824
c0005ec6:	68 de 00 00 00       	push   $0xde
c0005ecb:	68 7f 96 00 c0       	push   $0xc000967f
c0005ed0:	e8 5d c7 ff ff       	call   c0002632 <panic_spin>
c0005ed5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:226
		}

		/* 5 将数据写入硬盘 */
		write2sector(hd, (void*)((uint32_t)buf + secs_done * 512), secs_op);
c0005ed8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005edb:	0f b6 c0             	movzbl %al,%eax
c0005ede:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0005ee1:	89 d1                	mov    %edx,%ecx
c0005ee3:	c1 e1 09             	shl    $0x9,%ecx
c0005ee6:	8b 55 10             	mov    0x10(%ebp),%edx
c0005ee9:	01 ca                	add    %ecx,%edx
c0005eeb:	83 ec 04             	sub    $0x4,%esp
c0005eee:	50                   	push   %eax
c0005eef:	52                   	push   %edx
c0005ef0:	ff 75 08             	pushl  0x8(%ebp)
c0005ef3:	e8 a2 fc ff ff       	call   c0005b9a <write2sector>
c0005ef8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:229

		/* 在硬盘响应期间阻塞自己 */
		sema_down(&hd->my_channel->disk_done);
c0005efb:	8b 45 08             	mov    0x8(%ebp),%eax
c0005efe:	8b 40 08             	mov    0x8(%eax),%eax
c0005f01:	83 c0 2c             	add    $0x2c,%eax
c0005f04:	83 ec 0c             	sub    $0xc,%esp
c0005f07:	50                   	push   %eax
c0005f08:	e8 18 e9 ff ff       	call   c0004825 <sema_down>
c0005f0d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:230
		secs_done += secs_op;
c0005f10:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005f13:	01 45 f0             	add    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:205
	/* 1 先选择操作的硬盘 */
	select_disk(hd);

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
	while(secs_done < sec_cnt) {
c0005f16:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005f19:	3b 45 14             	cmp    0x14(%ebp),%eax
c0005f1c:	0f 82 20 ff ff ff    	jb     c0005e42 <ide_write+0x7c>
/work/x86_os_my/device/ide.c:233
		/* 在硬盘响应期间阻塞自己 */
		sema_down(&hd->my_channel->disk_done);
		secs_done += secs_op;
	}
	/* 醒来后开始释放锁*/
	lock_release(&hd->my_channel->lock);
c0005f22:	8b 45 08             	mov    0x8(%ebp),%eax
c0005f25:	8b 40 08             	mov    0x8(%eax),%eax
c0005f28:	83 c0 0c             	add    $0xc,%eax
c0005f2b:	83 ec 0c             	sub    $0xc,%esp
c0005f2e:	50                   	push   %eax
c0005f2f:	e8 12 eb ff ff       	call   c0004a46 <lock_release>
c0005f34:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:234
}
c0005f37:	90                   	nop
c0005f38:	c9                   	leave  
c0005f39:	c3                   	ret    

c0005f3a <swap_pairs_bytes>:
swap_pairs_bytes():
/work/x86_os_my/device/ide.c:238

/////////////////////////////////////// 读取分区表部分 ////////////////////////////////////////////////
/* 将dst中len个相邻字节交换位置后存入buf */
static void swap_pairs_bytes(const char* dst, char* buf, uint32_t len) {
c0005f3a:	55                   	push   %ebp
c0005f3b:	89 e5                	mov    %esp,%ebp
c0005f3d:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/device/ide.c:240
	uint8_t idx;
	for (idx = 0; idx < len; idx += 2) {
c0005f40:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
c0005f44:	eb 37                	jmp    c0005f7d <swap_pairs_bytes+0x43>
/work/x86_os_my/device/ide.c:242 (discriminator 3)
		/* buf中存储dst中两相邻元素交换位置后的字符串*/
		buf[idx + 1] = *dst++;
c0005f46:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c0005f4a:	8d 50 01             	lea    0x1(%eax),%edx
c0005f4d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005f50:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c0005f53:	8b 45 08             	mov    0x8(%ebp),%eax
c0005f56:	8d 50 01             	lea    0x1(%eax),%edx
c0005f59:	89 55 08             	mov    %edx,0x8(%ebp)
c0005f5c:	0f b6 00             	movzbl (%eax),%eax
c0005f5f:	88 01                	mov    %al,(%ecx)
/work/x86_os_my/device/ide.c:243 (discriminator 3)
		buf[idx]     = *dst++;
c0005f61:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c0005f65:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005f68:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c0005f6b:	8b 45 08             	mov    0x8(%ebp),%eax
c0005f6e:	8d 50 01             	lea    0x1(%eax),%edx
c0005f71:	89 55 08             	mov    %edx,0x8(%ebp)
c0005f74:	0f b6 00             	movzbl (%eax),%eax
c0005f77:	88 01                	mov    %al,(%ecx)
/work/x86_os_my/device/ide.c:240 (discriminator 3)

/////////////////////////////////////// 读取分区表部分 ////////////////////////////////////////////////
/* 将dst中len个相邻字节交换位置后存入buf */
static void swap_pairs_bytes(const char* dst, char* buf, uint32_t len) {
	uint8_t idx;
	for (idx = 0; idx < len; idx += 2) {
c0005f79:	80 45 ff 02          	addb   $0x2,-0x1(%ebp)
/work/x86_os_my/device/ide.c:240 (discriminator 1)
c0005f7d:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c0005f81:	3b 45 10             	cmp    0x10(%ebp),%eax
c0005f84:	72 c0                	jb     c0005f46 <swap_pairs_bytes+0xc>
/work/x86_os_my/device/ide.c:245
		/* buf中存储dst中两相邻元素交换位置后的字符串*/
		buf[idx + 1] = *dst++;
		buf[idx]     = *dst++;
	}
	buf[idx] = '\0';
c0005f86:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c0005f8a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005f8d:	01 d0                	add    %edx,%eax
c0005f8f:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/device/ide.c:246
}
c0005f92:	90                   	nop
c0005f93:	c9                   	leave  
c0005f94:	c3                   	ret    

c0005f95 <identify_disk>:
identify_disk():
/work/x86_os_my/device/ide.c:249

/* 获得硬盘参数信息 */
static void identify_disk(struct disk* hd) {
c0005f95:	55                   	push   %ebp
c0005f96:	89 e5                	mov    %esp,%ebp
c0005f98:	81 ec 98 02 00 00    	sub    $0x298,%esp
/work/x86_os_my/device/ide.c:251
	char id_info[512];
	select_disk(hd);
c0005f9e:	ff 75 08             	pushl  0x8(%ebp)
c0005fa1:	e8 43 fa ff ff       	call   c00059e9 <select_disk>
c0005fa6:	83 c4 04             	add    $0x4,%esp
/work/x86_os_my/device/ide.c:252
	cmd_out(hd->my_channel, CMD_IDENTIFY);
c0005fa9:	8b 45 08             	mov    0x8(%ebp),%eax
c0005fac:	8b 40 08             	mov    0x8(%eax),%eax
c0005faf:	68 ec 00 00 00       	push   $0xec
c0005fb4:	50                   	push   %eax
c0005fb5:	e8 63 fb ff ff       	call   c0005b1d <cmd_out>
c0005fba:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/ide.c:255
	/* 向硬盘发送指令后便通过信号量阻塞自己,
	* 待硬盘处理完成后,通过中断处理程序将自己唤醒 */
	sema_down(&hd->my_channel->disk_done);
c0005fbd:	8b 45 08             	mov    0x8(%ebp),%eax
c0005fc0:	8b 40 08             	mov    0x8(%eax),%eax
c0005fc3:	83 c0 2c             	add    $0x2c,%eax
c0005fc6:	83 ec 0c             	sub    $0xc,%esp
c0005fc9:	50                   	push   %eax
c0005fca:	e8 56 e8 ff ff       	call   c0004825 <sema_down>
c0005fcf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:258

	/* 醒来后开始执行下面代码*/
	if (!busy_wait(hd)) {     //  若失败
c0005fd2:	83 ec 0c             	sub    $0xc,%esp
c0005fd5:	ff 75 08             	pushl  0x8(%ebp)
c0005fd8:	e8 06 fc ff ff       	call   c0005be3 <busy_wait>
c0005fdd:	83 c4 10             	add    $0x10,%esp
c0005fe0:	85 c0                	test   %eax,%eax
c0005fe2:	75 39                	jne    c000601d <identify_disk+0x88>
/work/x86_os_my/device/ide.c:260
		char error[64];
		sprintf(error, "%s identify failed!!!!!!\n", hd->name);
c0005fe4:	8b 45 08             	mov    0x8(%ebp),%eax
c0005fe7:	83 ec 04             	sub    $0x4,%esp
c0005fea:	50                   	push   %eax
c0005feb:	68 d9 96 00 c0       	push   $0xc00096d9
c0005ff0:	8d 85 70 fd ff ff    	lea    -0x290(%ebp),%eax
c0005ff6:	50                   	push   %eax
c0005ff7:	e8 bc f8 ff ff       	call   c00058b8 <sprintf>
c0005ffc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:261
		PANIC(error);
c0005fff:	8d 85 70 fd ff ff    	lea    -0x290(%ebp),%eax
c0006005:	50                   	push   %eax
c0006006:	68 30 98 00 c0       	push   $0xc0009830
c000600b:	68 05 01 00 00       	push   $0x105
c0006010:	68 7f 96 00 c0       	push   $0xc000967f
c0006015:	e8 18 c6 ff ff       	call   c0002632 <panic_spin>
c000601a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:263
	}
	read_from_sector(hd, id_info, 1);
c000601d:	83 ec 04             	sub    $0x4,%esp
c0006020:	6a 01                	push   $0x1
c0006022:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c0006028:	50                   	push   %eax
c0006029:	ff 75 08             	pushl  0x8(%ebp)
c000602c:	e8 20 fb ff ff       	call   c0005b51 <read_from_sector>
c0006031:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:266

	char buf[64];
	uint8_t sn_start = 10 * 2, sn_len = 20, md_start = 27 * 2, md_len = 40;
c0006034:	c6 45 f7 14          	movb   $0x14,-0x9(%ebp)
c0006038:	c6 45 f6 14          	movb   $0x14,-0xa(%ebp)
c000603c:	c6 45 f5 36          	movb   $0x36,-0xb(%ebp)
c0006040:	c6 45 f4 28          	movb   $0x28,-0xc(%ebp)
/work/x86_os_my/device/ide.c:267
	swap_pairs_bytes(&id_info[sn_start], buf, sn_len);
c0006044:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0006048:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c000604c:	8d 8d f0 fd ff ff    	lea    -0x210(%ebp),%ecx
c0006052:	01 ca                	add    %ecx,%edx
c0006054:	83 ec 04             	sub    $0x4,%esp
c0006057:	50                   	push   %eax
c0006058:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c000605e:	50                   	push   %eax
c000605f:	52                   	push   %edx
c0006060:	e8 d5 fe ff ff       	call   c0005f3a <swap_pairs_bytes>
c0006065:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:268
	printk("   disk %s info:\n      SN: %s\n", hd->name, buf);
c0006068:	8b 45 08             	mov    0x8(%ebp),%eax
c000606b:	83 ec 04             	sub    $0x4,%esp
c000606e:	8d 95 b0 fd ff ff    	lea    -0x250(%ebp),%edx
c0006074:	52                   	push   %edx
c0006075:	50                   	push   %eax
c0006076:	68 f4 96 00 c0       	push   $0xc00096f4
c000607b:	e8 4b 06 00 00       	call   c00066cb <printk>
c0006080:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:269
	memset(buf, 0, sizeof(buf));
c0006083:	83 ec 04             	sub    $0x4,%esp
c0006086:	6a 40                	push   $0x40
c0006088:	6a 00                	push   $0x0
c000608a:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c0006090:	50                   	push   %eax
c0006091:	e8 b4 d9 ff ff       	call   c0003a4a <memset>
c0006096:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:270
	swap_pairs_bytes(&id_info[md_start], buf, md_len);
c0006099:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c000609d:	0f b6 55 f5          	movzbl -0xb(%ebp),%edx
c00060a1:	8d 8d f0 fd ff ff    	lea    -0x210(%ebp),%ecx
c00060a7:	01 ca                	add    %ecx,%edx
c00060a9:	83 ec 04             	sub    $0x4,%esp
c00060ac:	50                   	push   %eax
c00060ad:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c00060b3:	50                   	push   %eax
c00060b4:	52                   	push   %edx
c00060b5:	e8 80 fe ff ff       	call   c0005f3a <swap_pairs_bytes>
c00060ba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:271
	printk("      MODULE: %s\n", buf);
c00060bd:	83 ec 08             	sub    $0x8,%esp
c00060c0:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c00060c6:	50                   	push   %eax
c00060c7:	68 13 97 00 c0       	push   $0xc0009713
c00060cc:	e8 fa 05 00 00       	call   c00066cb <printk>
c00060d1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:272
	uint32_t sectors = *(uint32_t*)&id_info[60 * 2];
c00060d4:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c00060da:	83 c0 78             	add    $0x78,%eax
c00060dd:	8b 00                	mov    (%eax),%eax
c00060df:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:273
	printk("      SECTORS: %d\n", sectors);
c00060e2:	83 ec 08             	sub    $0x8,%esp
c00060e5:	ff 75 f0             	pushl  -0x10(%ebp)
c00060e8:	68 25 97 00 c0       	push   $0xc0009725
c00060ed:	e8 d9 05 00 00       	call   c00066cb <printk>
c00060f2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:274
	printk("      CAPACITY: %dMB\n", sectors * 512 / 1024 / 1024);
c00060f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00060f8:	c1 e0 09             	shl    $0x9,%eax
c00060fb:	c1 e8 14             	shr    $0x14,%eax
c00060fe:	83 ec 08             	sub    $0x8,%esp
c0006101:	50                   	push   %eax
c0006102:	68 38 97 00 c0       	push   $0xc0009738
c0006107:	e8 bf 05 00 00       	call   c00066cb <printk>
c000610c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:275
}
c000610f:	90                   	nop
c0006110:	c9                   	leave  
c0006111:	c3                   	ret    

c0006112 <partition_scan>:
partition_scan():
/work/x86_os_my/device/ide.c:278

/* 扫描硬盘hd中地址为ext_lba的扇区中的所有分区 */
static void partition_scan(struct disk* hd, uint32_t ext_lba) {
c0006112:	55                   	push   %ebp
c0006113:	89 e5                	mov    %esp,%ebp
c0006115:	53                   	push   %ebx
c0006116:	83 ec 14             	sub    $0x14,%esp
/work/x86_os_my/device/ide.c:279
	struct boot_sector* bs = sys_malloc(sizeof(struct boot_sector));
c0006119:	83 ec 0c             	sub    $0xc,%esp
c000611c:	68 00 02 00 00       	push   $0x200
c0006121:	e8 2d ce ff ff       	call   c0002f53 <sys_malloc>
c0006126:	83 c4 10             	add    $0x10,%esp
c0006129:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/device/ide.c:280
	ide_read(hd, ext_lba, bs, 1);
c000612c:	6a 01                	push   $0x1
c000612e:	ff 75 ec             	pushl  -0x14(%ebp)
c0006131:	ff 75 0c             	pushl  0xc(%ebp)
c0006134:	ff 75 08             	pushl  0x8(%ebp)
c0006137:	e8 16 fb ff ff       	call   c0005c52 <ide_read>
c000613c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:281
	uint8_t part_idx = 0;
c000613f:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/device/ide.c:282
	struct partition_table_entry* p = bs->partition_table;
c0006143:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0006146:	05 be 01 00 00       	add    $0x1be,%eax
c000614b:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:285

	/* 遍历分区表4个分区表项 */
	while (part_idx++ < 4) {
c000614e:	e9 53 02 00 00       	jmp    c00063a6 <partition_scan+0x294>
/work/x86_os_my/device/ide.c:286
		if (p->fs_type == 0x5) {	// 若为扩展分区
c0006153:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006156:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c000615a:	3c 05                	cmp    $0x5,%al
c000615c:	75 50                	jne    c00061ae <partition_scan+0x9c>
/work/x86_os_my/device/ide.c:287
			if (ext_lba_base != 0) {
c000615e:	a1 0c c6 00 c0       	mov    0xc000c60c,%eax
c0006163:	85 c0                	test   %eax,%eax
c0006165:	74 22                	je     c0006189 <partition_scan+0x77>
/work/x86_os_my/device/ide.c:289
				/* 子扩展分区的start_lba是相对于主引导扇区中的总扩展分区地址 */
				partition_scan(hd, p->start_lba + ext_lba_base);
c0006167:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000616a:	8b 40 08             	mov    0x8(%eax),%eax
c000616d:	8b 15 0c c6 00 c0    	mov    0xc000c60c,%edx
c0006173:	01 d0                	add    %edx,%eax
c0006175:	83 ec 08             	sub    $0x8,%esp
c0006178:	50                   	push   %eax
c0006179:	ff 75 08             	pushl  0x8(%ebp)
c000617c:	e8 91 ff ff ff       	call   c0006112 <partition_scan>
c0006181:	83 c4 10             	add    $0x10,%esp
c0006184:	e9 19 02 00 00       	jmp    c00063a2 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:292
			} else {	// ext_lba_base为0表示是第一次读取引导块,也就是主引导记录所在的扇区
				/* 记录下扩展分区的起始lba地址,后面所有的扩展分区地址都相对于此 */
				ext_lba_base = p->start_lba;
c0006189:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000618c:	8b 40 08             	mov    0x8(%eax),%eax
c000618f:	a3 0c c6 00 c0       	mov    %eax,0xc000c60c
/work/x86_os_my/device/ide.c:293
				partition_scan(hd, p->start_lba);
c0006194:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006197:	8b 40 08             	mov    0x8(%eax),%eax
c000619a:	83 ec 08             	sub    $0x8,%esp
c000619d:	50                   	push   %eax
c000619e:	ff 75 08             	pushl  0x8(%ebp)
c00061a1:	e8 6c ff ff ff       	call   c0006112 <partition_scan>
c00061a6:	83 c4 10             	add    $0x10,%esp
c00061a9:	e9 f4 01 00 00       	jmp    c00063a2 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:295
			}
		} else if (p->fs_type != 0) {	// 若是有效的分区类型
c00061ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00061b1:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c00061b5:	84 c0                	test   %al,%al
c00061b7:	0f 84 e5 01 00 00    	je     c00063a2 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:296
			if (ext_lba == 0) {	// 此时全是主分区
c00061bd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00061c1:	0f 85 f9 00 00 00    	jne    c00062c0 <partition_scan+0x1ae>
/work/x86_os_my/device/ide.c:297
				hd->prim_parts[p_no].start_lba = ext_lba + p->start_lba;
c00061c7:	0f b6 05 10 c6 00 c0 	movzbl 0xc000c610,%eax
c00061ce:	0f b6 c8             	movzbl %al,%ecx
c00061d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00061d4:	8b 50 08             	mov    0x8(%eax),%edx
c00061d7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00061da:	01 c2                	add    %eax,%edx
c00061dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00061df:	c1 e1 06             	shl    $0x6,%ecx
c00061e2:	01 c8                	add    %ecx,%eax
c00061e4:	83 c0 10             	add    $0x10,%eax
c00061e7:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ide.c:298
				hd->prim_parts[p_no].sec_cnt = p->sec_cnt;
c00061e9:	0f b6 05 10 c6 00 c0 	movzbl 0xc000c610,%eax
c00061f0:	0f b6 c8             	movzbl %al,%ecx
c00061f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00061f6:	8b 40 0c             	mov    0xc(%eax),%eax
c00061f9:	8b 55 08             	mov    0x8(%ebp),%edx
c00061fc:	c1 e1 06             	shl    $0x6,%ecx
c00061ff:	01 ca                	add    %ecx,%edx
c0006201:	83 c2 14             	add    $0x14,%edx
c0006204:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:299
				hd->prim_parts[p_no].my_disk = hd;
c0006206:	0f b6 05 10 c6 00 c0 	movzbl 0xc000c610,%eax
c000620d:	0f b6 d0             	movzbl %al,%edx
c0006210:	8b 45 08             	mov    0x8(%ebp),%eax
c0006213:	c1 e2 06             	shl    $0x6,%edx
c0006216:	01 d0                	add    %edx,%eax
c0006218:	8d 50 18             	lea    0x18(%eax),%edx
c000621b:	8b 45 08             	mov    0x8(%ebp),%eax
c000621e:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:300
				list_append(&partition_list, &hd->prim_parts[p_no].part_tag);
c0006220:	0f b6 05 10 c6 00 c0 	movzbl 0xc000c610,%eax
c0006227:	0f b6 c0             	movzbl %al,%eax
c000622a:	c1 e0 06             	shl    $0x6,%eax
c000622d:	8d 50 10             	lea    0x10(%eax),%edx
c0006230:	8b 45 08             	mov    0x8(%ebp),%eax
c0006233:	01 d0                	add    %edx,%eax
c0006235:	83 c0 0c             	add    $0xc,%eax
c0006238:	83 ec 08             	sub    $0x8,%esp
c000623b:	50                   	push   %eax
c000623c:	68 c0 d9 00 c0       	push   $0xc000d9c0
c0006241:	e8 53 e3 ff ff       	call   c0004599 <list_append>
c0006246:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:301
				sprintf(hd->prim_parts[p_no].name, "%s%d", hd->name, p_no + 1);
c0006249:	0f b6 05 10 c6 00 c0 	movzbl 0xc000c610,%eax
c0006250:	0f b6 c0             	movzbl %al,%eax
c0006253:	8d 48 01             	lea    0x1(%eax),%ecx
c0006256:	8b 45 08             	mov    0x8(%ebp),%eax
c0006259:	0f b6 15 10 c6 00 c0 	movzbl 0xc000c610,%edx
c0006260:	0f b6 d2             	movzbl %dl,%edx
c0006263:	c1 e2 06             	shl    $0x6,%edx
c0006266:	8d 5a 20             	lea    0x20(%edx),%ebx
c0006269:	8b 55 08             	mov    0x8(%ebp),%edx
c000626c:	01 da                	add    %ebx,%edx
c000626e:	83 c2 04             	add    $0x4,%edx
c0006271:	51                   	push   %ecx
c0006272:	50                   	push   %eax
c0006273:	68 4e 97 00 c0       	push   $0xc000974e
c0006278:	52                   	push   %edx
c0006279:	e8 3a f6 ff ff       	call   c00058b8 <sprintf>
c000627e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:302
				p_no++;
c0006281:	0f b6 05 10 c6 00 c0 	movzbl 0xc000c610,%eax
c0006288:	83 c0 01             	add    $0x1,%eax
c000628b:	a2 10 c6 00 c0       	mov    %al,0xc000c610
/work/x86_os_my/device/ide.c:303
				ASSERT(p_no < 4);	// 0,1,2,3
c0006290:	0f b6 05 10 c6 00 c0 	movzbl 0xc000c610,%eax
c0006297:	3c 03                	cmp    $0x3,%al
c0006299:	0f 86 03 01 00 00    	jbe    c00063a2 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:303 (discriminator 1)
c000629f:	68 53 97 00 c0       	push   $0xc0009753
c00062a4:	68 40 98 00 c0       	push   $0xc0009840
c00062a9:	68 2f 01 00 00       	push   $0x12f
c00062ae:	68 7f 96 00 c0       	push   $0xc000967f
c00062b3:	e8 7a c3 ff ff       	call   c0002632 <panic_spin>
c00062b8:	83 c4 10             	add    $0x10,%esp
c00062bb:	e9 e2 00 00 00       	jmp    c00063a2 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:305
			} else {
				hd->logic_parts[l_no].start_lba = ext_lba + p->start_lba;
c00062c0:	0f b6 05 11 c6 00 c0 	movzbl 0xc000c611,%eax
c00062c7:	0f b6 c8             	movzbl %al,%ecx
c00062ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00062cd:	8b 50 08             	mov    0x8(%eax),%edx
c00062d0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00062d3:	01 c2                	add    %eax,%edx
c00062d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00062d8:	c1 e1 06             	shl    $0x6,%ecx
c00062db:	01 c8                	add    %ecx,%eax
c00062dd:	05 10 01 00 00       	add    $0x110,%eax
c00062e2:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ide.c:306
				hd->logic_parts[l_no].sec_cnt = p->sec_cnt;
c00062e4:	0f b6 05 11 c6 00 c0 	movzbl 0xc000c611,%eax
c00062eb:	0f b6 c8             	movzbl %al,%ecx
c00062ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00062f1:	8b 40 0c             	mov    0xc(%eax),%eax
c00062f4:	8b 55 08             	mov    0x8(%ebp),%edx
c00062f7:	c1 e1 06             	shl    $0x6,%ecx
c00062fa:	01 ca                	add    %ecx,%edx
c00062fc:	81 c2 14 01 00 00    	add    $0x114,%edx
c0006302:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:307
				hd->logic_parts[l_no].my_disk = hd;
c0006304:	0f b6 05 11 c6 00 c0 	movzbl 0xc000c611,%eax
c000630b:	0f b6 d0             	movzbl %al,%edx
c000630e:	8b 45 08             	mov    0x8(%ebp),%eax
c0006311:	c1 e2 06             	shl    $0x6,%edx
c0006314:	01 d0                	add    %edx,%eax
c0006316:	8d 90 18 01 00 00    	lea    0x118(%eax),%edx
c000631c:	8b 45 08             	mov    0x8(%ebp),%eax
c000631f:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:308
				list_append(&partition_list, &hd->logic_parts[l_no].part_tag);
c0006321:	0f b6 05 11 c6 00 c0 	movzbl 0xc000c611,%eax
c0006328:	0f b6 c0             	movzbl %al,%eax
c000632b:	c1 e0 06             	shl    $0x6,%eax
c000632e:	8d 90 10 01 00 00    	lea    0x110(%eax),%edx
c0006334:	8b 45 08             	mov    0x8(%ebp),%eax
c0006337:	01 d0                	add    %edx,%eax
c0006339:	83 c0 0c             	add    $0xc,%eax
c000633c:	83 ec 08             	sub    $0x8,%esp
c000633f:	50                   	push   %eax
c0006340:	68 c0 d9 00 c0       	push   $0xc000d9c0
c0006345:	e8 4f e2 ff ff       	call   c0004599 <list_append>
c000634a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:309
				sprintf(hd->logic_parts[l_no].name, "%s%d", hd->name, l_no + 5);	// 逻辑分区数字是从5开始,主分区是1～4.
c000634d:	0f b6 05 11 c6 00 c0 	movzbl 0xc000c611,%eax
c0006354:	0f b6 c0             	movzbl %al,%eax
c0006357:	8d 48 05             	lea    0x5(%eax),%ecx
c000635a:	8b 45 08             	mov    0x8(%ebp),%eax
c000635d:	0f b6 15 11 c6 00 c0 	movzbl 0xc000c611,%edx
c0006364:	0f b6 d2             	movzbl %dl,%edx
c0006367:	c1 e2 06             	shl    $0x6,%edx
c000636a:	8d 9a 20 01 00 00    	lea    0x120(%edx),%ebx
c0006370:	8b 55 08             	mov    0x8(%ebp),%edx
c0006373:	01 da                	add    %ebx,%edx
c0006375:	83 c2 04             	add    $0x4,%edx
c0006378:	51                   	push   %ecx
c0006379:	50                   	push   %eax
c000637a:	68 4e 97 00 c0       	push   $0xc000974e
c000637f:	52                   	push   %edx
c0006380:	e8 33 f5 ff ff       	call   c00058b8 <sprintf>
c0006385:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:310
				l_no++;
c0006388:	0f b6 05 11 c6 00 c0 	movzbl 0xc000c611,%eax
c000638f:	83 c0 01             	add    $0x1,%eax
c0006392:	a2 11 c6 00 c0       	mov    %al,0xc000c611
/work/x86_os_my/device/ide.c:311
				if (l_no >= 8)	// 只支持8个逻辑分区,避免数组越界
c0006397:	0f b6 05 11 c6 00 c0 	movzbl 0xc000c611,%eax
c000639e:	3c 07                	cmp    $0x7,%al
c00063a0:	77 26                	ja     c00063c8 <partition_scan+0x2b6>
/work/x86_os_my/device/ide.c:315
					return;
			}
		}
		p++;
c00063a2:	83 45 f0 10          	addl   $0x10,-0x10(%ebp)
/work/x86_os_my/device/ide.c:285
	ide_read(hd, ext_lba, bs, 1);
	uint8_t part_idx = 0;
	struct partition_table_entry* p = bs->partition_table;

	/* 遍历分区表4个分区表项 */
	while (part_idx++ < 4) {
c00063a6:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00063aa:	8d 50 01             	lea    0x1(%eax),%edx
c00063ad:	88 55 f7             	mov    %dl,-0x9(%ebp)
c00063b0:	3c 03                	cmp    $0x3,%al
c00063b2:	0f 86 9b fd ff ff    	jbe    c0006153 <partition_scan+0x41>
/work/x86_os_my/device/ide.c:317
					return;
			}
		}
		p++;
	}
	sys_free(bs);
c00063b8:	83 ec 0c             	sub    $0xc,%esp
c00063bb:	ff 75 ec             	pushl  -0x14(%ebp)
c00063be:	e8 bd d1 ff ff       	call   c0003580 <sys_free>
c00063c3:	83 c4 10             	add    $0x10,%esp
c00063c6:	eb 01                	jmp    c00063c9 <partition_scan+0x2b7>
/work/x86_os_my/device/ide.c:312
				hd->logic_parts[l_no].my_disk = hd;
				list_append(&partition_list, &hd->logic_parts[l_no].part_tag);
				sprintf(hd->logic_parts[l_no].name, "%s%d", hd->name, l_no + 5);	// 逻辑分区数字是从5开始,主分区是1～4.
				l_no++;
				if (l_no >= 8)	// 只支持8个逻辑分区,避免数组越界
					return;
c00063c8:	90                   	nop
/work/x86_os_my/device/ide.c:318
			}
		}
		p++;
	}
	sys_free(bs);
}
c00063c9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00063cc:	c9                   	leave  
c00063cd:	c3                   	ret    

c00063ce <partition_info>:
partition_info():
/work/x86_os_my/device/ide.c:321

/* 打印分区信息 */
static bool partition_info(struct list_elem* pelem, int arg UNUSED) {
c00063ce:	55                   	push   %ebp
c00063cf:	89 e5                	mov    %esp,%ebp
c00063d1:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ide.c:322
	struct partition* part = elem2entry(struct partition, part_tag, pelem);
c00063d4:	8b 45 08             	mov    0x8(%ebp),%eax
c00063d7:	83 e8 0c             	sub    $0xc,%eax
c00063da:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:323
	printk("   %s start_lba:0x%x, sec_cnt:0x%x\n",part->name, part->start_lba, part->sec_cnt);
c00063dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00063e0:	8b 50 04             	mov    0x4(%eax),%edx
c00063e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00063e6:	8b 00                	mov    (%eax),%eax
c00063e8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c00063eb:	83 c1 14             	add    $0x14,%ecx
c00063ee:	52                   	push   %edx
c00063ef:	50                   	push   %eax
c00063f0:	51                   	push   %ecx
c00063f1:	68 5c 97 00 c0       	push   $0xc000975c
c00063f6:	e8 d0 02 00 00       	call   c00066cb <printk>
c00063fb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:327

	/* 在此处return false与函数本身功能无关,
	 * 只是为了让主调函数list_traversal继续向下遍历元素 */
	return false;
c00063fe:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/device/ide.c:328
}
c0006403:	c9                   	leave  
c0006404:	c3                   	ret    

c0006405 <intr_hd_handler>:
intr_hd_handler():
/work/x86_os_my/device/ide.c:331

/* 硬盘中断处理程序 */
void intr_hd_handler(uint8_t irq_no) {
c0006405:	55                   	push   %ebp
c0006406:	89 e5                	mov    %esp,%ebp
c0006408:	83 ec 28             	sub    $0x28,%esp
c000640b:	8b 45 08             	mov    0x8(%ebp),%eax
c000640e:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/device/ide.c:332
	ASSERT(irq_no == 0x2e || irq_no == 0x2f);
c0006411:	80 7d e4 2e          	cmpb   $0x2e,-0x1c(%ebp)
c0006415:	74 22                	je     c0006439 <intr_hd_handler+0x34>
/work/x86_os_my/device/ide.c:332 (discriminator 1)
c0006417:	80 7d e4 2f          	cmpb   $0x2f,-0x1c(%ebp)
c000641b:	74 1c                	je     c0006439 <intr_hd_handler+0x34>
/work/x86_os_my/device/ide.c:332 (discriminator 2)
c000641d:	68 80 97 00 c0       	push   $0xc0009780
c0006422:	68 50 98 00 c0       	push   $0xc0009850
c0006427:	68 4c 01 00 00       	push   $0x14c
c000642c:	68 7f 96 00 c0       	push   $0xc000967f
c0006431:	e8 fc c1 ff ff       	call   c0002632 <panic_spin>
c0006436:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:333
	uint8_t ch_no = irq_no - 0x2e;
c0006439:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c000643d:	83 e8 2e             	sub    $0x2e,%eax
c0006440:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ide.c:334
	struct ide_channel* channel = &channels[ch_no];
c0006443:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0006447:	69 c0 60 06 00 00    	imul   $0x660,%eax,%eax
c000644d:	05 00 cd 00 c0       	add    $0xc000cd00,%eax
c0006452:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:335
	ASSERT(channel->irq_no == irq_no);
c0006455:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006458:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c000645c:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c000645f:	74 1c                	je     c000647d <intr_hd_handler+0x78>
/work/x86_os_my/device/ide.c:335 (discriminator 1)
c0006461:	68 a1 97 00 c0       	push   $0xc00097a1
c0006466:	68 50 98 00 c0       	push   $0xc0009850
c000646b:	68 4f 01 00 00       	push   $0x14f
c0006470:	68 7f 96 00 c0       	push   $0xc000967f
c0006475:	e8 b8 c1 ff ff       	call   c0002632 <panic_spin>
c000647a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:338
	/* 不必担心此中断是否对应的是这一次的expecting_intr,
	* 每次读写硬盘时会申请锁,从而保证了同步一致性 */
	if (channel->expecting_intr) {
c000647d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006480:	8b 40 28             	mov    0x28(%eax),%eax
c0006483:	85 c0                	test   %eax,%eax
c0006485:	74 35                	je     c00064bc <intr_hd_handler+0xb7>
/work/x86_os_my/device/ide.c:339
		channel->expecting_intr = false;
c0006487:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000648a:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
/work/x86_os_my/device/ide.c:340
		sema_up(&channel->disk_done);
c0006491:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006494:	83 c0 2c             	add    $0x2c,%eax
c0006497:	83 ec 0c             	sub    $0xc,%esp
c000649a:	50                   	push   %eax
c000649b:	e8 80 e4 ff ff       	call   c0004920 <sema_up>
c00064a0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:343

		/* 读取状态寄存器使硬盘控制器认为此次的中断已被处理,从而硬盘可以继续执行新的读写 */
		inb(reg_status(channel));
c00064a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00064a6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00064aa:	83 c0 07             	add    $0x7,%eax
c00064ad:	0f b7 c0             	movzwl %ax,%eax
c00064b0:	83 ec 0c             	sub    $0xc,%esp
c00064b3:	50                   	push   %eax
c00064b4:	e8 de f4 ff ff       	call   c0005997 <inb>
c00064b9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:345
	}
}
c00064bc:	90                   	nop
c00064bd:	c9                   	leave  
c00064be:	c3                   	ret    

c00064bf <ide_init>:
ide_init():
/work/x86_os_my/device/ide.c:348

/* 硬盘数据结构初始化 */
void ide_init() {
c00064bf:	55                   	push   %ebp
c00064c0:	89 e5                	mov    %esp,%ebp
c00064c2:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ide.c:349
	printk("ide_init start\n");
c00064c5:	83 ec 0c             	sub    $0xc,%esp
c00064c8:	68 bb 97 00 c0       	push   $0xc00097bb
c00064cd:	e8 f9 01 00 00       	call   c00066cb <printk>
c00064d2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:350
	uint8_t hd_cnt = *((uint8_t*)(0x475));	// 获取硬盘的数量
c00064d5:	b8 75 04 00 00       	mov    $0x475,%eax
c00064da:	0f b6 00             	movzbl (%eax),%eax
c00064dd:	88 45 f5             	mov    %al,-0xb(%ebp)
/work/x86_os_my/device/ide.c:351
	ASSERT(hd_cnt > 0);
c00064e0:	80 7d f5 00          	cmpb   $0x0,-0xb(%ebp)
c00064e4:	75 1c                	jne    c0006502 <ide_init+0x43>
/work/x86_os_my/device/ide.c:351 (discriminator 1)
c00064e6:	68 cb 97 00 c0       	push   $0xc00097cb
c00064eb:	68 60 98 00 c0       	push   $0xc0009860
c00064f0:	68 5f 01 00 00       	push   $0x15f
c00064f5:	68 7f 96 00 c0       	push   $0xc000967f
c00064fa:	e8 33 c1 ff ff       	call   c0002632 <panic_spin>
c00064ff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:352
	list_init(&partition_list);
c0006502:	83 ec 0c             	sub    $0xc,%esp
c0006505:	68 c0 d9 00 c0       	push   $0xc000d9c0
c000650a:	e8 f9 df ff ff       	call   c0004508 <list_init>
c000650f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:353
	channel_cnt = DIV_ROUND_UP(hd_cnt, 2);	// 一个ide通道上有两个硬盘,根据硬盘数量反推有几个ide通道
c0006512:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
c0006516:	83 c0 01             	add    $0x1,%eax
c0006519:	89 c2                	mov    %eax,%edx
c000651b:	c1 ea 1f             	shr    $0x1f,%edx
c000651e:	01 d0                	add    %edx,%eax
c0006520:	d1 f8                	sar    %eax
c0006522:	a2 e0 cc 00 c0       	mov    %al,0xc000cce0
/work/x86_os_my/device/ide.c:355
	struct ide_channel* channel;
	uint8_t channel_no = 0, dev_no = 0;
c0006527:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
c000652b:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
/work/x86_os_my/device/ide.c:358

	/* 处理每个通道上的硬盘 */
	while (channel_no < channel_cnt) {
c000652f:	e9 4d 01 00 00       	jmp    c0006681 <ide_init+0x1c2>
/work/x86_os_my/device/ide.c:359
		channel = &channels[channel_no];
c0006534:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0006538:	69 c0 60 06 00 00    	imul   $0x660,%eax,%eax
c000653e:	05 00 cd 00 c0       	add    $0xc000cd00,%eax
c0006543:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:360
		sprintf(channel->name, "ide%d", channel_no);
c0006546:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c000654a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000654d:	83 ec 04             	sub    $0x4,%esp
c0006550:	52                   	push   %edx
c0006551:	68 d6 97 00 c0       	push   $0xc00097d6
c0006556:	50                   	push   %eax
c0006557:	e8 5c f3 ff ff       	call   c00058b8 <sprintf>
c000655c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:363

		/* 为每个ide通道初始化端口基址及中断向量 */
		switch (channel_no) {
c000655f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0006563:	85 c0                	test   %eax,%eax
c0006565:	74 07                	je     c000656e <ide_init+0xaf>
c0006567:	83 f8 01             	cmp    $0x1,%eax
c000656a:	74 14                	je     c0006580 <ide_init+0xc1>
c000656c:	eb 23                	jmp    c0006591 <ide_init+0xd2>
/work/x86_os_my/device/ide.c:365
			case 0:
			channel->port_base	 = 0x1f0;	// ide0通道的起始端口号是0x1f0
c000656e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006571:	66 c7 40 08 f0 01    	movw   $0x1f0,0x8(%eax)
/work/x86_os_my/device/ide.c:366
			channel->irq_no	 = 0x20 + 14;	// 从片8259a上倒数第二的中断引脚,温盘,也就是ide0通道的的中断向量号
c0006577:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000657a:	c6 40 0a 2e          	movb   $0x2e,0xa(%eax)
/work/x86_os_my/device/ide.c:367
			break;
c000657e:	eb 11                	jmp    c0006591 <ide_init+0xd2>
/work/x86_os_my/device/ide.c:370
			
			case 1:
			channel->port_base	 = 0x170;	// ide1通道的起始端口号是0x170
c0006580:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006583:	66 c7 40 08 70 01    	movw   $0x170,0x8(%eax)
/work/x86_os_my/device/ide.c:371
			channel->irq_no	 = 0x20 + 15;	// 从8259A上的最后一个中断引脚,我们用来响应ide1通道上的硬盘中断
c0006589:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000658c:	c6 40 0a 2f          	movb   $0x2f,0xa(%eax)
/work/x86_os_my/device/ide.c:372
			break;
c0006590:	90                   	nop
/work/x86_os_my/device/ide.c:375
		}

		channel->expecting_intr = false;	// 未向硬盘写入指令时不期待硬盘的中断
c0006591:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006594:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
/work/x86_os_my/device/ide.c:376
		lock_init(&channel->lock);
c000659b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000659e:	83 c0 0c             	add    $0xc,%eax
c00065a1:	83 ec 0c             	sub    $0xc,%esp
c00065a4:	50                   	push   %eax
c00065a5:	e8 4b e2 ff ff       	call   c00047f5 <lock_init>
c00065aa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:380

		/* 初始化为0,目的是向硬盘控制器请求数据后,硬盘驱动sema_down此信号量会阻塞线程,
		直到硬盘完成后通过发中断,由中断处理程序将此信号量sema_up,唤醒线程. */
		sema_init(&channel->disk_done, 0);
c00065ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00065b0:	83 c0 2c             	add    $0x2c,%eax
c00065b3:	83 ec 08             	sub    $0x8,%esp
c00065b6:	6a 00                	push   $0x0
c00065b8:	50                   	push   %eax
c00065b9:	e8 0d e2 ff ff       	call   c00047cb <sema_init>
c00065be:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:381
		register_handler(channel->irq_no, intr_hd_handler);
c00065c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00065c4:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c00065c8:	0f b6 c0             	movzbl %al,%eax
c00065cb:	83 ec 08             	sub    $0x8,%esp
c00065ce:	68 05 64 00 c0       	push   $0xc0006405
c00065d3:	50                   	push   %eax
c00065d4:	e8 25 b7 ff ff       	call   c0001cfe <register_handler>
c00065d9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:384

		/* 分别获取两个硬盘的参数及分区信息 */
		while (dev_no < 2) {
c00065dc:	e9 88 00 00 00       	jmp    c0006669 <ide_init+0x1aa>
/work/x86_os_my/device/ide.c:385
			struct disk* hd = &channel->devices[dev_no];
c00065e1:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c00065e5:	69 c0 10 03 00 00    	imul   $0x310,%eax,%eax
c00065eb:	8d 50 40             	lea    0x40(%eax),%edx
c00065ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00065f1:	01 d0                	add    %edx,%eax
c00065f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/device/ide.c:386
			hd->my_channel = channel;
c00065f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00065f9:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00065fc:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/device/ide.c:387
			hd->dev_no = dev_no;
c00065ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0006602:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
c0006606:	88 50 0c             	mov    %dl,0xc(%eax)
/work/x86_os_my/device/ide.c:388
			sprintf(hd->name, "sd%c", 'a' + channel_no * 2 + dev_no);
c0006609:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000660d:	01 c0                	add    %eax,%eax
c000660f:	8d 50 61             	lea    0x61(%eax),%edx
c0006612:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0006616:	01 c2                	add    %eax,%edx
c0006618:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000661b:	83 ec 04             	sub    $0x4,%esp
c000661e:	52                   	push   %edx
c000661f:	68 dc 97 00 c0       	push   $0xc00097dc
c0006624:	50                   	push   %eax
c0006625:	e8 8e f2 ff ff       	call   c00058b8 <sprintf>
c000662a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:389
			identify_disk(hd);		// 获取硬盘参数
c000662d:	83 ec 0c             	sub    $0xc,%esp
c0006630:	ff 75 ec             	pushl  -0x14(%ebp)
c0006633:	e8 5d f9 ff ff       	call   c0005f95 <identify_disk>
c0006638:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:390
			if (dev_no != 0) {		// 内核本身的裸硬盘(hd60M.img)不处理
c000663b:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c000663f:	74 10                	je     c0006651 <ide_init+0x192>
/work/x86_os_my/device/ide.c:391
				partition_scan(hd, 0);	// 扫描该硬盘上的分区
c0006641:	83 ec 08             	sub    $0x8,%esp
c0006644:	6a 00                	push   $0x0
c0006646:	ff 75 ec             	pushl  -0x14(%ebp)
c0006649:	e8 c4 fa ff ff       	call   c0006112 <partition_scan>
c000664e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:393
			}
			p_no = 0, l_no = 0;
c0006651:	c6 05 10 c6 00 c0 00 	movb   $0x0,0xc000c610
c0006658:	c6 05 11 c6 00 c0 00 	movb   $0x0,0xc000c611
/work/x86_os_my/device/ide.c:394
			dev_no++;
c000665f:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0006663:	83 c0 01             	add    $0x1,%eax
c0006666:	88 45 f6             	mov    %al,-0xa(%ebp)
/work/x86_os_my/device/ide.c:384
		直到硬盘完成后通过发中断,由中断处理程序将此信号量sema_up,唤醒线程. */
		sema_init(&channel->disk_done, 0);
		register_handler(channel->irq_no, intr_hd_handler);

		/* 分别获取两个硬盘的参数及分区信息 */
		while (dev_no < 2) {
c0006669:	80 7d f6 01          	cmpb   $0x1,-0xa(%ebp)
c000666d:	0f 86 6e ff ff ff    	jbe    c00065e1 <ide_init+0x122>
/work/x86_os_my/device/ide.c:396
				partition_scan(hd, 0);	// 扫描该硬盘上的分区
			}
			p_no = 0, l_no = 0;
			dev_no++;
		}
		dev_no = 0;		// 将硬盘驱动器号置0,为下一个channel的两个硬盘初始化。
c0006673:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
/work/x86_os_my/device/ide.c:397
		channel_no++;	// 下一个channel
c0006677:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000667b:	83 c0 01             	add    $0x1,%eax
c000667e:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ide.c:358
	channel_cnt = DIV_ROUND_UP(hd_cnt, 2);	// 一个ide通道上有两个硬盘,根据硬盘数量反推有几个ide通道
	struct ide_channel* channel;
	uint8_t channel_no = 0, dev_no = 0;

	/* 处理每个通道上的硬盘 */
	while (channel_no < channel_cnt) {
c0006681:	0f b6 05 e0 cc 00 c0 	movzbl 0xc000cce0,%eax
c0006688:	38 45 f7             	cmp    %al,-0x9(%ebp)
c000668b:	0f 82 a3 fe ff ff    	jb     c0006534 <ide_init+0x75>
/work/x86_os_my/device/ide.c:400
		}
		dev_no = 0;		// 将硬盘驱动器号置0,为下一个channel的两个硬盘初始化。
		channel_no++;	// 下一个channel
	}

	printk("\n   all partition info\n");
c0006691:	83 ec 0c             	sub    $0xc,%esp
c0006694:	68 e1 97 00 c0       	push   $0xc00097e1
c0006699:	e8 2d 00 00 00       	call   c00066cb <printk>
c000669e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:402
	/* 打印所有分区信息 */
	list_traversal(&partition_list, partition_info, (int)NULL);
c00066a1:	83 ec 04             	sub    $0x4,%esp
c00066a4:	6a 00                	push   $0x0
c00066a6:	68 ce 63 00 c0       	push   $0xc00063ce
c00066ab:	68 c0 d9 00 c0       	push   $0xc000d9c0
c00066b0:	e8 99 df ff ff       	call   c000464e <list_traversal>
c00066b5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:403
	printk("ide_init done\n");
c00066b8:	83 ec 0c             	sub    $0xc,%esp
c00066bb:	68 f9 97 00 c0       	push   $0xc00097f9
c00066c0:	e8 06 00 00 00       	call   c00066cb <printk>
c00066c5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:404
}
c00066c8:	90                   	nop
c00066c9:	c9                   	leave  
c00066ca:	c3                   	ret    

c00066cb <printk>:
printk():
/work/x86_os_my/lib/kernel/stdio-kernel.c:11

#define va_start(args, first_fix) args = (va_list)&first_fix
#define va_end(args) args = NULL

/* 供内核使用的格式化输出函数 */
void printk(const char* format, ...) {
c00066cb:	55                   	push   %ebp
c00066cc:	89 e5                	mov    %esp,%ebp
c00066ce:	57                   	push   %edi
c00066cf:	81 ec 14 04 00 00    	sub    $0x414,%esp
/work/x86_os_my/lib/kernel/stdio-kernel.c:13
	va_list args;
	va_start(args, format);
c00066d5:	8d 45 08             	lea    0x8(%ebp),%eax
c00066d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/stdio-kernel.c:14
	char buf[1024] = {0};
c00066db:	8d 95 f4 fb ff ff    	lea    -0x40c(%ebp),%edx
c00066e1:	b8 00 00 00 00       	mov    $0x0,%eax
c00066e6:	b9 00 01 00 00       	mov    $0x100,%ecx
c00066eb:	89 d7                	mov    %edx,%edi
c00066ed:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/lib/kernel/stdio-kernel.c:15
	vsprintf(buf, format, args);
c00066ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00066f2:	83 ec 04             	sub    $0x4,%esp
c00066f5:	ff 75 f4             	pushl  -0xc(%ebp)
c00066f8:	50                   	push   %eax
c00066f9:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c00066ff:	50                   	push   %eax
c0006700:	e8 36 f0 ff ff       	call   c000573b <vsprintf>
c0006705:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/stdio-kernel.c:16
	va_end(args);
c0006708:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/kernel/stdio-kernel.c:17
	console_put_str(buf);
c000670f:	83 ec 0c             	sub    $0xc,%esp
c0006712:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c0006718:	50                   	push   %eax
c0006719:	e8 42 e0 ff ff       	call   c0004760 <console_put_str>
c000671e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/stdio-kernel.c:18
}
c0006721:	90                   	nop
c0006722:	8b 7d fc             	mov    -0x4(%ebp),%edi
c0006725:	c9                   	leave  
c0006726:	c3                   	ret    

c0006727 <mount_partition>:
mount_partition():
/work/x86_os_my/fs/fs.c:24
把该分区文件系统的元信息从硬盘上读出来加载到内存中，
这样硬盘资源的变化都用内存中元信息来跟踪，
如果有写操作，及时将内存中的元信息同步写入到硬盘以持久化。
*/
//sb_buf没释放！
static bool mount_partition(struct list_elem* pelem, int arg) {
c0006727:	55                   	push   %ebp
c0006728:	89 e5                	mov    %esp,%ebp
c000672a:	53                   	push   %ebx
c000672b:	83 ec 14             	sub    $0x14,%esp
/work/x86_os_my/fs/fs.c:25
	char* part_name = (char*)arg;	// sdb1
c000672e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006731:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:26
	struct partition* part = elem2entry(struct partition, part_tag, pelem);	// 根据pelem找到partition
c0006734:	8b 45 08             	mov    0x8(%ebp),%eax
c0006737:	83 e8 0c             	sub    $0xc,%eax
c000673a:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:27
	if (!strcmp(part->name, part_name)) {	//名字一致
c000673d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006740:	83 c0 14             	add    $0x14,%eax
c0006743:	83 ec 08             	sub    $0x8,%esp
c0006746:	ff 75 f4             	pushl  -0xc(%ebp)
c0006749:	50                   	push   %eax
c000674a:	e8 d0 d4 ff ff       	call   c0003c1f <strcmp>
c000674f:	83 c4 10             	add    $0x10,%esp
c0006752:	84 c0                	test   %al,%al
c0006754:	0f 85 ce 01 00 00    	jne    c0006928 <mount_partition+0x201>
/work/x86_os_my/fs/fs.c:28
		cur_part = part;
c000675a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000675d:	a3 d0 d9 00 c0       	mov    %eax,0xc000d9d0
/work/x86_os_my/fs/fs.c:29
		struct disk* hd = cur_part->my_disk;
c0006762:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c0006767:	8b 40 08             	mov    0x8(%eax),%eax
c000676a:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:30
		struct super_block* sb_buf = (struct super_block*)sys_malloc(SECTOR_SIZE);
c000676d:	83 ec 0c             	sub    $0xc,%esp
c0006770:	68 00 02 00 00       	push   $0x200
c0006775:	e8 d9 c7 ff ff       	call   c0002f53 <sys_malloc>
c000677a:	83 c4 10             	add    $0x10,%esp
c000677d:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:34

		/* 在内存中创建分区cur_part的超级块 */
		// super_block 占用了1个扇区，但是它后边有很多数据是pad只做填充用
		cur_part->sb = (struct super_block*)sys_malloc(sizeof(struct super_block));
c0006780:	8b 1d d0 d9 00 c0    	mov    0xc000d9d0,%ebx
c0006786:	83 ec 0c             	sub    $0xc,%esp
c0006789:	68 00 02 00 00       	push   $0x200
c000678e:	e8 c0 c7 ff ff       	call   c0002f53 <sys_malloc>
c0006793:	83 c4 10             	add    $0x10,%esp
c0006796:	89 43 1c             	mov    %eax,0x1c(%ebx)
/work/x86_os_my/fs/fs.c:35
		if (cur_part->sb == NULL) {
c0006799:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c000679e:	8b 40 1c             	mov    0x1c(%eax),%eax
c00067a1:	85 c0                	test   %eax,%eax
c00067a3:	75 19                	jne    c00067be <mount_partition+0x97>
/work/x86_os_my/fs/fs.c:36
			PANIC("alloc memory failed!");
c00067a5:	68 6c 98 00 c0       	push   $0xc000986c
c00067aa:	68 dc 9b 00 c0       	push   $0xc0009bdc
c00067af:	6a 24                	push   $0x24
c00067b1:	68 81 98 00 c0       	push   $0xc0009881
c00067b6:	e8 77 be ff ff       	call   c0002632 <panic_spin>
c00067bb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:40
		}

		/* 读入超级块 */
		memset(sb_buf, 0, SECTOR_SIZE);
c00067be:	83 ec 04             	sub    $0x4,%esp
c00067c1:	68 00 02 00 00       	push   $0x200
c00067c6:	6a 00                	push   $0x0
c00067c8:	ff 75 e8             	pushl  -0x18(%ebp)
c00067cb:	e8 7a d2 ff ff       	call   c0003a4a <memset>
c00067d0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:41
		ide_read(hd, cur_part->start_lba + 1, sb_buf, 1);
c00067d3:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c00067d8:	8b 00                	mov    (%eax),%eax
c00067da:	83 c0 01             	add    $0x1,%eax
c00067dd:	6a 01                	push   $0x1
c00067df:	ff 75 e8             	pushl  -0x18(%ebp)
c00067e2:	50                   	push   %eax
c00067e3:	ff 75 ec             	pushl  -0x14(%ebp)
c00067e6:	e8 67 f4 ff ff       	call   c0005c52 <ide_read>
c00067eb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:43
		// 拷贝给 cur_part->sb
		memcpy(cur_part->sb, sb_buf, sizeof(struct super_block));
c00067ee:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c00067f3:	8b 40 1c             	mov    0x1c(%eax),%eax
c00067f6:	83 ec 04             	sub    $0x4,%esp
c00067f9:	68 00 02 00 00       	push   $0x200
c00067fe:	ff 75 e8             	pushl  -0x18(%ebp)
c0006801:	50                   	push   %eax
c0006802:	e8 95 d2 ff ff       	call   c0003a9c <memcpy>
c0006807:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:46

		/* 读入块位图 */
		cur_part->block_bitmap.bits = (uint8_t*)sys_malloc(sb_buf->block_bitmap_sects * SECTOR_SIZE);
c000680a:	8b 1d d0 d9 00 c0    	mov    0xc000d9d0,%ebx
c0006810:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0006813:	8b 40 14             	mov    0x14(%eax),%eax
c0006816:	c1 e0 09             	shl    $0x9,%eax
c0006819:	83 ec 0c             	sub    $0xc,%esp
c000681c:	50                   	push   %eax
c000681d:	e8 31 c7 ff ff       	call   c0002f53 <sys_malloc>
c0006822:	83 c4 10             	add    $0x10,%esp
c0006825:	89 43 24             	mov    %eax,0x24(%ebx)
/work/x86_os_my/fs/fs.c:47
		if (cur_part->block_bitmap.bits == NULL) {
c0006828:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c000682d:	8b 40 24             	mov    0x24(%eax),%eax
c0006830:	85 c0                	test   %eax,%eax
c0006832:	75 19                	jne    c000684d <mount_partition+0x126>
/work/x86_os_my/fs/fs.c:48
			PANIC("alloc memory failed!");
c0006834:	68 6c 98 00 c0       	push   $0xc000986c
c0006839:	68 dc 9b 00 c0       	push   $0xc0009bdc
c000683e:	6a 30                	push   $0x30
c0006840:	68 81 98 00 c0       	push   $0xc0009881
c0006845:	e8 e8 bd ff ff       	call   c0002632 <panic_spin>
c000684a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:50
		}
		cur_part->block_bitmap.btmp_bytes_len = sb_buf->block_bitmap_sects * SECTOR_SIZE;
c000684d:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c0006852:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0006855:	8b 52 14             	mov    0x14(%edx),%edx
c0006858:	c1 e2 09             	shl    $0x9,%edx
c000685b:	89 50 20             	mov    %edx,0x20(%eax)
/work/x86_os_my/fs/fs.c:51
		ide_read(hd, sb_buf->block_bitmap_lba, cur_part->block_bitmap.bits, sb_buf->block_bitmap_sects);
c000685e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0006861:	8b 48 14             	mov    0x14(%eax),%ecx
c0006864:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c0006869:	8b 50 24             	mov    0x24(%eax),%edx
c000686c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000686f:	8b 40 10             	mov    0x10(%eax),%eax
c0006872:	51                   	push   %ecx
c0006873:	52                   	push   %edx
c0006874:	50                   	push   %eax
c0006875:	ff 75 ec             	pushl  -0x14(%ebp)
c0006878:	e8 d5 f3 ff ff       	call   c0005c52 <ide_read>
c000687d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:54

		/* 读入inode位图 */
		cur_part->inode_bitmap.bits = (uint8_t*)sys_malloc(sb_buf->inode_bitmap_sects * SECTOR_SIZE);
c0006880:	8b 1d d0 d9 00 c0    	mov    0xc000d9d0,%ebx
c0006886:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0006889:	8b 40 1c             	mov    0x1c(%eax),%eax
c000688c:	c1 e0 09             	shl    $0x9,%eax
c000688f:	83 ec 0c             	sub    $0xc,%esp
c0006892:	50                   	push   %eax
c0006893:	e8 bb c6 ff ff       	call   c0002f53 <sys_malloc>
c0006898:	83 c4 10             	add    $0x10,%esp
c000689b:	89 43 2c             	mov    %eax,0x2c(%ebx)
/work/x86_os_my/fs/fs.c:55
		if (cur_part->inode_bitmap.bits == NULL) {
c000689e:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c00068a3:	8b 40 2c             	mov    0x2c(%eax),%eax
c00068a6:	85 c0                	test   %eax,%eax
c00068a8:	75 19                	jne    c00068c3 <mount_partition+0x19c>
/work/x86_os_my/fs/fs.c:56
			PANIC("alloc memory failed!");
c00068aa:	68 6c 98 00 c0       	push   $0xc000986c
c00068af:	68 dc 9b 00 c0       	push   $0xc0009bdc
c00068b4:	6a 38                	push   $0x38
c00068b6:	68 81 98 00 c0       	push   $0xc0009881
c00068bb:	e8 72 bd ff ff       	call   c0002632 <panic_spin>
c00068c0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:58
		}
		cur_part->inode_bitmap.btmp_bytes_len = sb_buf->inode_bitmap_sects * SECTOR_SIZE;
c00068c3:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c00068c8:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00068cb:	8b 52 1c             	mov    0x1c(%edx),%edx
c00068ce:	c1 e2 09             	shl    $0x9,%edx
c00068d1:	89 50 28             	mov    %edx,0x28(%eax)
/work/x86_os_my/fs/fs.c:59
		ide_read(hd, sb_buf->inode_bitmap_lba, cur_part->inode_bitmap.bits, sb_buf->inode_bitmap_sects);
c00068d4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00068d7:	8b 48 1c             	mov    0x1c(%eax),%ecx
c00068da:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c00068df:	8b 50 2c             	mov    0x2c(%eax),%edx
c00068e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00068e5:	8b 40 18             	mov    0x18(%eax),%eax
c00068e8:	51                   	push   %ecx
c00068e9:	52                   	push   %edx
c00068ea:	50                   	push   %eax
c00068eb:	ff 75 ec             	pushl  -0x14(%ebp)
c00068ee:	e8 5f f3 ff ff       	call   c0005c52 <ide_read>
c00068f3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:62


		list_init(&cur_part->open_inodes);	// 本分区打开的inode队列！
c00068f6:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c00068fb:	83 c0 30             	add    $0x30,%eax
c00068fe:	83 ec 0c             	sub    $0xc,%esp
c0006901:	50                   	push   %eax
c0006902:	e8 01 dc ff ff       	call   c0004508 <list_init>
c0006907:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:65


		printk("mount %s done!\n", part->name);
c000690a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000690d:	83 c0 14             	add    $0x14,%eax
c0006910:	83 ec 08             	sub    $0x8,%esp
c0006913:	50                   	push   %eax
c0006914:	68 89 98 00 c0       	push   $0xc0009889
c0006919:	e8 ad fd ff ff       	call   c00066cb <printk>
c000691e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:67
		/* 返回true时list_traversal才会停止遍历,减少了后面元素无意义的遍历. */
		return true;
c0006921:	b8 01 00 00 00       	mov    $0x1,%eax
c0006926:	eb 05                	jmp    c000692d <mount_partition+0x206>
/work/x86_os_my/fs/fs.c:69
	}//if (!strcmp(part->name, part_name))
	return false;	// list_traversal继续遍历
c0006928:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/fs.c:70
}
c000692d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0006930:	c9                   	leave  
c0006931:	c3                   	ret    

c0006932 <partition_format>:
partition_format():
/work/x86_os_my/fs/fs.c:86
	| 操作系统引导块，超级块，空闲块位图，inode位图，inode数组，根目录，空闲块区域 |
	+------------------------------------------------------------------------------+
	partition结构见ide.h
	MAX_FILES_PER_PART == 4096
****************************************************************************************/
static void partition_format(struct partition* part) {
c0006932:	55                   	push   %ebp
c0006933:	89 e5                	mov    %esp,%ebp
c0006935:	57                   	push   %edi
c0006936:	56                   	push   %esi
c0006937:	53                   	push   %ebx
c0006938:	81 ec 7c 02 00 00    	sub    $0x27c,%esp
/work/x86_os_my/fs/fs.c:88
	/* 为方便实现，inode管理的数据块，一个块大小是一扇区 */
	uint32_t boot_sector_sects = 1;		//引导块
c000693e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
/work/x86_os_my/fs/fs.c:89
	uint32_t super_block_sects = 1;		//超级块
c0006945:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
/work/x86_os_my/fs/fs.c:90
	uint32_t inode_bitmap_sects = DIV_ROUND_UP(MAX_FILES_PER_PART, BITS_PER_SECTOR);	// inode位图占几个扇区.最多支持4096个文件
c000694c:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
/work/x86_os_my/fs/fs.c:91
	uint32_t inode_table_sects = DIV_ROUND_UP((sizeof(struct inode) * MAX_FILES_PER_PART), SECTOR_SIZE);	//inode数组占几个扇区
c0006953:	c7 45 d4 60 02 00 00 	movl   $0x260,-0x2c(%ebp)
/work/x86_os_my/fs/fs.c:92
	uint32_t used_sects = boot_sector_sects + super_block_sects + inode_bitmap_sects + inode_table_sects;
c000695a:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000695d:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0006960:	01 c2                	add    %eax,%edx
c0006962:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0006965:	01 c2                	add    %eax,%edx
c0006967:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000696a:	01 d0                	add    %edx,%eax
c000696c:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/fs/fs.c:93
	uint32_t free_sects = part->sec_cnt - used_sects;  
c000696f:	8b 45 08             	mov    0x8(%ebp),%eax
c0006972:	8b 40 04             	mov    0x4(%eax),%eax
c0006975:	2b 45 d0             	sub    -0x30(%ebp),%eax
c0006978:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/fs/fs.c:97

	/************** 简单处理块位图占据的扇区数 ***************/
	uint32_t block_bitmap_sects;	//空闲块位图占几个扇区
	block_bitmap_sects = DIV_ROUND_UP(free_sects, BITS_PER_SECTOR);		//free_sects空闲块位图要占几个扇区
c000697b:	8b 45 cc             	mov    -0x34(%ebp),%eax
c000697e:	05 ff 0f 00 00       	add    $0xfff,%eax
c0006983:	c1 e8 0c             	shr    $0xc,%eax
c0006986:	89 45 c8             	mov    %eax,-0x38(%ebp)
/work/x86_os_my/fs/fs.c:99
	/* 再算一次空闲块数量 */
	uint32_t block_bitmap_bit_len = free_sects - block_bitmap_sects;	//block_bitmap_bit_len 是位图长度，也是空闲块数量
c0006989:	8b 45 cc             	mov    -0x34(%ebp),%eax
c000698c:	2b 45 c8             	sub    -0x38(%ebp),%eax
c000698f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
/work/x86_os_my/fs/fs.c:100
	block_bitmap_sects = DIV_ROUND_UP(block_bitmap_bit_len, BITS_PER_SECTOR); 
c0006992:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c0006995:	05 ff 0f 00 00       	add    $0xfff,%eax
c000699a:	c1 e8 0c             	shr    $0xc,%eax
c000699d:	89 45 c8             	mov    %eax,-0x38(%ebp)
/work/x86_os_my/fs/fs.c:105
	/*********************************************************/

	/* 超级块初始化 */
	struct super_block sb;		//局部变量在栈中512字节
	sb.magic = 0x19590318;
c00069a0:	c7 85 a4 fd ff ff 18 	movl   $0x19590318,-0x25c(%ebp)
c00069a7:	03 59 19 
/work/x86_os_my/fs/fs.c:106
	sb.sec_cnt = part->sec_cnt;
c00069aa:	8b 45 08             	mov    0x8(%ebp),%eax
c00069ad:	8b 40 04             	mov    0x4(%eax),%eax
c00069b0:	89 85 a8 fd ff ff    	mov    %eax,-0x258(%ebp)
/work/x86_os_my/fs/fs.c:107
	sb.inode_cnt = MAX_FILES_PER_PART;
c00069b6:	c7 85 ac fd ff ff 00 	movl   $0x1000,-0x254(%ebp)
c00069bd:	10 00 00 
/work/x86_os_my/fs/fs.c:108
	sb.part_lba_base = part->start_lba;
c00069c0:	8b 45 08             	mov    0x8(%ebp),%eax
c00069c3:	8b 00                	mov    (%eax),%eax
c00069c5:	89 85 b0 fd ff ff    	mov    %eax,-0x250(%ebp)
/work/x86_os_my/fs/fs.c:110

	sb.block_bitmap_lba = sb.part_lba_base + 2;	// 第0块是引导块,第1块是超级块
c00069cb:	8b 85 b0 fd ff ff    	mov    -0x250(%ebp),%eax
c00069d1:	83 c0 02             	add    $0x2,%eax
c00069d4:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
/work/x86_os_my/fs/fs.c:111
	sb.block_bitmap_sects = block_bitmap_sects;	// 空闲块位图占几个扇区
c00069da:	8b 45 c8             	mov    -0x38(%ebp),%eax
c00069dd:	89 85 b8 fd ff ff    	mov    %eax,-0x248(%ebp)
/work/x86_os_my/fs/fs.c:113

	sb.inode_bitmap_lba = sb.block_bitmap_lba + sb.block_bitmap_sects;
c00069e3:	8b 95 b4 fd ff ff    	mov    -0x24c(%ebp),%edx
c00069e9:	8b 85 b8 fd ff ff    	mov    -0x248(%ebp),%eax
c00069ef:	01 d0                	add    %edx,%eax
c00069f1:	89 85 bc fd ff ff    	mov    %eax,-0x244(%ebp)
/work/x86_os_my/fs/fs.c:114
	sb.inode_bitmap_sects = inode_bitmap_sects;	// inode位图占几个扇区
c00069f7:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00069fa:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
/work/x86_os_my/fs/fs.c:116

	sb.inode_table_lba = sb.inode_bitmap_lba + sb.inode_bitmap_sects;
c0006a00:	8b 95 bc fd ff ff    	mov    -0x244(%ebp),%edx
c0006a06:	8b 85 c0 fd ff ff    	mov    -0x240(%ebp),%eax
c0006a0c:	01 d0                	add    %edx,%eax
c0006a0e:	89 85 c4 fd ff ff    	mov    %eax,-0x23c(%ebp)
/work/x86_os_my/fs/fs.c:117
	sb.inode_table_sects = inode_table_sects;	// inode数组占几个扇区
c0006a14:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0006a17:	89 85 c8 fd ff ff    	mov    %eax,-0x238(%ebp)
/work/x86_os_my/fs/fs.c:119

	sb.data_start_lba = sb.inode_table_lba + sb.inode_table_sects;	// 数据区开始的第一个扇区号
c0006a1d:	8b 95 c4 fd ff ff    	mov    -0x23c(%ebp),%edx
c0006a23:	8b 85 c8 fd ff ff    	mov    -0x238(%ebp),%eax
c0006a29:	01 d0                	add    %edx,%eax
c0006a2b:	89 85 cc fd ff ff    	mov    %eax,-0x234(%ebp)
/work/x86_os_my/fs/fs.c:121

	sb.root_inode_no = 0;	//根目录的inode号是0
c0006a31:	c7 85 d0 fd ff ff 00 	movl   $0x0,-0x230(%ebp)
c0006a38:	00 00 00 
/work/x86_os_my/fs/fs.c:122
	sb.dir_entry_size = sizeof(struct dir_entry);
c0006a3b:	c7 85 d4 fd ff ff 18 	movl   $0x18,-0x22c(%ebp)
c0006a42:	00 00 00 
/work/x86_os_my/fs/fs.c:124

	printk("%s info:\n", part->name);
c0006a45:	8b 45 08             	mov    0x8(%ebp),%eax
c0006a48:	83 c0 14             	add    $0x14,%eax
c0006a4b:	83 ec 08             	sub    $0x8,%esp
c0006a4e:	50                   	push   %eax
c0006a4f:	68 99 98 00 c0       	push   $0xc0009899
c0006a54:	e8 72 fc ff ff       	call   c00066cb <printk>
c0006a59:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:125
	printk("   magic:0x%x\n   part_lba_base:0x%x\n   all_sectors:0x%x\n   inode_cnt:0x%x\n   block_bitmap_lba:0x%x\n   block_bitmap_sectors:0x%x\n   inode_bitmap_lba:0x%x\n   inode_bitmap_sectors:0x%x\n   inode_table_lba:0x%x\n   inode_table_sectors:0x%x\n   data_start_lba:0x%x\n", sb.magic, sb.part_lba_base, sb.sec_cnt, sb.inode_cnt, sb.block_bitmap_lba, sb.block_bitmap_sects, sb.inode_bitmap_lba, sb.inode_bitmap_sects, sb.inode_table_lba, sb.inode_table_sects, sb.data_start_lba);
c0006a5c:	8b 95 cc fd ff ff    	mov    -0x234(%ebp),%edx
c0006a62:	8b 9d c8 fd ff ff    	mov    -0x238(%ebp),%ebx
c0006a68:	8b bd c4 fd ff ff    	mov    -0x23c(%ebp),%edi
c0006a6e:	8b 85 c0 fd ff ff    	mov    -0x240(%ebp),%eax
c0006a74:	89 85 94 fd ff ff    	mov    %eax,-0x26c(%ebp)
c0006a7a:	8b b5 bc fd ff ff    	mov    -0x244(%ebp),%esi
c0006a80:	89 b5 90 fd ff ff    	mov    %esi,-0x270(%ebp)
c0006a86:	8b 8d b8 fd ff ff    	mov    -0x248(%ebp),%ecx
c0006a8c:	89 8d 8c fd ff ff    	mov    %ecx,-0x274(%ebp)
c0006a92:	8b 85 b4 fd ff ff    	mov    -0x24c(%ebp),%eax
c0006a98:	89 85 88 fd ff ff    	mov    %eax,-0x278(%ebp)
c0006a9e:	8b b5 ac fd ff ff    	mov    -0x254(%ebp),%esi
c0006aa4:	89 b5 84 fd ff ff    	mov    %esi,-0x27c(%ebp)
c0006aaa:	8b b5 a8 fd ff ff    	mov    -0x258(%ebp),%esi
c0006ab0:	8b 8d b0 fd ff ff    	mov    -0x250(%ebp),%ecx
c0006ab6:	8b 85 a4 fd ff ff    	mov    -0x25c(%ebp),%eax
c0006abc:	52                   	push   %edx
c0006abd:	53                   	push   %ebx
c0006abe:	57                   	push   %edi
c0006abf:	ff b5 94 fd ff ff    	pushl  -0x26c(%ebp)
c0006ac5:	ff b5 90 fd ff ff    	pushl  -0x270(%ebp)
c0006acb:	ff b5 8c fd ff ff    	pushl  -0x274(%ebp)
c0006ad1:	ff b5 88 fd ff ff    	pushl  -0x278(%ebp)
c0006ad7:	ff b5 84 fd ff ff    	pushl  -0x27c(%ebp)
c0006add:	56                   	push   %esi
c0006ade:	51                   	push   %ecx
c0006adf:	50                   	push   %eax
c0006ae0:	68 a4 98 00 c0       	push   $0xc00098a4
c0006ae5:	e8 e1 fb ff ff       	call   c00066cb <printk>
c0006aea:	83 c4 30             	add    $0x30,%esp
/work/x86_os_my/fs/fs.c:129


	/***** 1 将超级块写入本分区的1号扇区 *****/
	struct disk* hd = part->my_disk;	// 分区所属的硬盘
c0006aed:	8b 45 08             	mov    0x8(%ebp),%eax
c0006af0:	8b 40 08             	mov    0x8(%eax),%eax
c0006af3:	89 45 c0             	mov    %eax,-0x40(%ebp)
/work/x86_os_my/fs/fs.c:131
	// void ide_write(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt);
	ide_write(hd, part->start_lba + 1, &sb, 1);
c0006af6:	8b 45 08             	mov    0x8(%ebp),%eax
c0006af9:	8b 00                	mov    (%eax),%eax
c0006afb:	8d 50 01             	lea    0x1(%eax),%edx
c0006afe:	6a 01                	push   $0x1
c0006b00:	8d 85 a4 fd ff ff    	lea    -0x25c(%ebp),%eax
c0006b06:	50                   	push   %eax
c0006b07:	52                   	push   %edx
c0006b08:	ff 75 c0             	pushl  -0x40(%ebp)
c0006b0b:	e8 b6 f2 ff ff       	call   c0005dc6 <ide_write>
c0006b10:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:132
	printk("   super_block_lba:0x%x\n", part->start_lba + 1);
c0006b13:	8b 45 08             	mov    0x8(%ebp),%eax
c0006b16:	8b 00                	mov    (%eax),%eax
c0006b18:	83 c0 01             	add    $0x1,%eax
c0006b1b:	83 ec 08             	sub    $0x8,%esp
c0006b1e:	50                   	push   %eax
c0006b1f:	68 a6 99 00 c0       	push   $0xc00099a6
c0006b24:	e8 a2 fb ff ff       	call   c00066cb <printk>
c0006b29:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:136


	/* 他们三个写到硬盘上：block_bitmap_sects/inode_bitmap_sects/inode_table_sects 缓冲区选三者最大的 */
	uint32_t buf_size = (sb.block_bitmap_sects >= sb.inode_bitmap_sects ? sb.block_bitmap_sects : sb.inode_bitmap_sects);
c0006b2c:	8b 95 b8 fd ff ff    	mov    -0x248(%ebp),%edx
c0006b32:	8b 85 c0 fd ff ff    	mov    -0x240(%ebp),%eax
c0006b38:	39 c2                	cmp    %eax,%edx
c0006b3a:	0f 43 c2             	cmovae %edx,%eax
c0006b3d:	89 45 bc             	mov    %eax,-0x44(%ebp)
/work/x86_os_my/fs/fs.c:137
	buf_size = (buf_size >= sb.inode_table_sects ? buf_size : sb.inode_table_sects) * SECTOR_SIZE;
c0006b40:	8b 95 c8 fd ff ff    	mov    -0x238(%ebp),%edx
c0006b46:	8b 45 bc             	mov    -0x44(%ebp),%eax
c0006b49:	39 c2                	cmp    %eax,%edx
c0006b4b:	0f 43 c2             	cmovae %edx,%eax
c0006b4e:	c1 e0 09             	shl    $0x9,%eax
c0006b51:	89 45 bc             	mov    %eax,-0x44(%ebp)
/work/x86_os_my/fs/fs.c:138
	uint8_t* buf = (uint8_t*)sys_malloc(buf_size);	// 申请的内存由内存管理系统清0后返回
c0006b54:	83 ec 0c             	sub    $0xc,%esp
c0006b57:	ff 75 bc             	pushl  -0x44(%ebp)
c0006b5a:	e8 f4 c3 ff ff       	call   c0002f53 <sys_malloc>
c0006b5f:	83 c4 10             	add    $0x10,%esp
c0006b62:	89 45 b8             	mov    %eax,-0x48(%ebp)
/work/x86_os_my/fs/fs.c:143


	/***** 2 将块位图初始化并写入sb.block_bitmap_lba *****/
	/* 初始化块位图 block_bitmap */
	buf[0] |= 0x01;	// 第0个块预留给根目录,位图中先占位
c0006b65:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0006b68:	0f b6 00             	movzbl (%eax),%eax
c0006b6b:	83 c8 01             	or     $0x1,%eax
c0006b6e:	89 c2                	mov    %eax,%edx
c0006b70:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0006b73:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/fs/fs.c:144
	uint32_t block_bitmap_last_byte = block_bitmap_bit_len / 8;		//block_bitmap_bit_len 是位图长度，也是空闲块数量
c0006b75:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c0006b78:	c1 e8 03             	shr    $0x3,%eax
c0006b7b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
/work/x86_os_my/fs/fs.c:145
	uint8_t  block_bitmap_last_bit  = block_bitmap_bit_len % 8;
c0006b7e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c0006b81:	83 e0 07             	and    $0x7,%eax
c0006b84:	88 45 b3             	mov    %al,-0x4d(%ebp)
/work/x86_os_my/fs/fs.c:146
	uint32_t last_size = SECTOR_SIZE - (block_bitmap_last_byte % SECTOR_SIZE);	// last_size是位图占用的最后一个扇区中，不足一扇区的空闲部分
c0006b87:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0006b8a:	25 ff 01 00 00       	and    $0x1ff,%eax
c0006b8f:	ba 00 02 00 00       	mov    $0x200,%edx
c0006b94:	29 c2                	sub    %eax,%edx
c0006b96:	89 d0                	mov    %edx,%eax
c0006b98:	89 45 ac             	mov    %eax,-0x54(%ebp)
/work/x86_os_my/fs/fs.c:149

	// 1 空闲块位图最后一字节，到最后一字节所在扇区的末尾，全置为占用（空闲块位图所在扇区的空闲部分）
	memset(&buf[block_bitmap_last_byte], 0xff, last_size);
c0006b9b:	8b 55 b8             	mov    -0x48(%ebp),%edx
c0006b9e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0006ba1:	01 d0                	add    %edx,%eax
c0006ba3:	83 ec 04             	sub    $0x4,%esp
c0006ba6:	ff 75 ac             	pushl  -0x54(%ebp)
c0006ba9:	68 ff 00 00 00       	push   $0xff
c0006bae:	50                   	push   %eax
c0006baf:	e8 96 ce ff ff       	call   c0003a4a <memset>
c0006bb4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:152

	// 2 上一步中最后一字节内，有效的位重新置0
	uint8_t bit_idx = 0;
c0006bb7:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
/work/x86_os_my/fs/fs.c:153
	while (bit_idx <= block_bitmap_last_bit) {
c0006bbb:	eb 37                	jmp    c0006bf4 <partition_format+0x2c2>
/work/x86_os_my/fs/fs.c:154
		buf[block_bitmap_last_byte] &= ~(1 << bit_idx++);
c0006bbd:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
c0006bc1:	8d 50 01             	lea    0x1(%eax),%edx
c0006bc4:	88 55 e7             	mov    %dl,-0x19(%ebp)
c0006bc7:	0f b6 c0             	movzbl %al,%eax
c0006bca:	ba 01 00 00 00       	mov    $0x1,%edx
c0006bcf:	89 c1                	mov    %eax,%ecx
c0006bd1:	d3 e2                	shl    %cl,%edx
c0006bd3:	89 d0                	mov    %edx,%eax
c0006bd5:	f7 d0                	not    %eax
c0006bd7:	89 c3                	mov    %eax,%ebx
c0006bd9:	8b 55 b8             	mov    -0x48(%ebp),%edx
c0006bdc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0006bdf:	01 d0                	add    %edx,%eax
c0006be1:	8b 4d b8             	mov    -0x48(%ebp),%ecx
c0006be4:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c0006be7:	01 ca                	add    %ecx,%edx
c0006be9:	0f b6 12             	movzbl (%edx),%edx
c0006bec:	89 d1                	mov    %edx,%ecx
c0006bee:	89 da                	mov    %ebx,%edx
c0006bf0:	21 ca                	and    %ecx,%edx
c0006bf2:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/fs/fs.c:153
	// 1 空闲块位图最后一字节，到最后一字节所在扇区的末尾，全置为占用（空闲块位图所在扇区的空闲部分）
	memset(&buf[block_bitmap_last_byte], 0xff, last_size);

	// 2 上一步中最后一字节内，有效的位重新置0
	uint8_t bit_idx = 0;
	while (bit_idx <= block_bitmap_last_bit) {
c0006bf4:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
c0006bf8:	3a 45 b3             	cmp    -0x4d(%ebp),%al
c0006bfb:	76 c0                	jbe    c0006bbd <partition_format+0x28b>
/work/x86_os_my/fs/fs.c:157
		buf[block_bitmap_last_byte] &= ~(1 << bit_idx++);
	}
	// 3 写回到硬盘 空闲块位图 区域
	ide_write(hd, sb.block_bitmap_lba, buf, sb.block_bitmap_sects);
c0006bfd:	8b 95 b8 fd ff ff    	mov    -0x248(%ebp),%edx
c0006c03:	8b 85 b4 fd ff ff    	mov    -0x24c(%ebp),%eax
c0006c09:	52                   	push   %edx
c0006c0a:	ff 75 b8             	pushl  -0x48(%ebp)
c0006c0d:	50                   	push   %eax
c0006c0e:	ff 75 c0             	pushl  -0x40(%ebp)
c0006c11:	e8 b0 f1 ff ff       	call   c0005dc6 <ide_write>
c0006c16:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:161


	/***** 3 将inode位图初始化并写入sb.inode_bitmap_lba *****/
	memset(buf, 0, buf_size);
c0006c19:	83 ec 04             	sub    $0x4,%esp
c0006c1c:	ff 75 bc             	pushl  -0x44(%ebp)
c0006c1f:	6a 00                	push   $0x0
c0006c21:	ff 75 b8             	pushl  -0x48(%ebp)
c0006c24:	e8 21 ce ff ff       	call   c0003a4a <memset>
c0006c29:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:162
	buf[0] |= 0x1;	// 第0个inode分给了根目录
c0006c2c:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0006c2f:	0f b6 00             	movzbl (%eax),%eax
c0006c32:	83 c8 01             	or     $0x1,%eax
c0006c35:	89 c2                	mov    %eax,%edx
c0006c37:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0006c3a:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/fs/fs.c:166
	/* 最多4096个文件，inode位图4096个bit，正好占用1扇区，inode_bitmap_sects等于1
	 * 不像block_bitmap，在inode_bitmap的扇区中，没有多余的空闲无效位 */
	// 写回到硬盘 inode位图 区域
	ide_write(hd, sb.inode_bitmap_lba, buf, sb.inode_bitmap_sects);
c0006c3c:	8b 95 c0 fd ff ff    	mov    -0x240(%ebp),%edx
c0006c42:	8b 85 bc fd ff ff    	mov    -0x244(%ebp),%eax
c0006c48:	52                   	push   %edx
c0006c49:	ff 75 b8             	pushl  -0x48(%ebp)
c0006c4c:	50                   	push   %eax
c0006c4d:	ff 75 c0             	pushl  -0x40(%ebp)
c0006c50:	e8 71 f1 ff ff       	call   c0005dc6 <ide_write>
c0006c55:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:171


	/***** 4 将inode数组初始化并写入sb.inode_table_lba *****/
	/* 处理inode_table中的第0项，即根目录所在的inode */
	memset(buf, 0, buf_size);
c0006c58:	83 ec 04             	sub    $0x4,%esp
c0006c5b:	ff 75 bc             	pushl  -0x44(%ebp)
c0006c5e:	6a 00                	push   $0x0
c0006c60:	ff 75 b8             	pushl  -0x48(%ebp)
c0006c63:	e8 e2 cd ff ff       	call   c0003a4a <memset>
c0006c68:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:172
	struct inode* i = (struct inode*)buf;
c0006c6b:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0006c6e:	89 45 a8             	mov    %eax,-0x58(%ebp)
/work/x86_os_my/fs/fs.c:173
	i->i_size = sb.dir_entry_size * 2;		// .和..	// 所有目录项大小之和
c0006c71:	8b 85 d4 fd ff ff    	mov    -0x22c(%ebp),%eax
c0006c77:	8d 14 00             	lea    (%eax,%eax,1),%edx
c0006c7a:	8b 45 a8             	mov    -0x58(%ebp),%eax
c0006c7d:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/fs.c:174
	i->i_no = 0;   // 根目录占inode数组中第0个inode
c0006c80:	8b 45 a8             	mov    -0x58(%ebp),%eax
c0006c83:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:178
	// inode管理的是数据块（对于我们来说就是扇区）
	// 此处是指定根目录这个inode管理的数据块的位置
	// i_sectors数组后边的元素都是0 没用到
	i->i_sectors[0] = sb.data_start_lba;
c0006c89:	8b 95 cc fd ff ff    	mov    -0x234(%ebp),%edx
c0006c8f:	8b 45 a8             	mov    -0x58(%ebp),%eax
c0006c92:	89 50 10             	mov    %edx,0x10(%eax)
/work/x86_os_my/fs/fs.c:181
	// 写到硬盘 inode数组
	// 其实我们只处理了第0项
	ide_write(hd, sb.inode_table_lba, buf, sb.inode_table_sects);
c0006c95:	8b 95 c8 fd ff ff    	mov    -0x238(%ebp),%edx
c0006c9b:	8b 85 c4 fd ff ff    	mov    -0x23c(%ebp),%eax
c0006ca1:	52                   	push   %edx
c0006ca2:	ff 75 b8             	pushl  -0x48(%ebp)
c0006ca5:	50                   	push   %eax
c0006ca6:	ff 75 c0             	pushl  -0x40(%ebp)
c0006ca9:	e8 18 f1 ff ff       	call   c0005dc6 <ide_write>
c0006cae:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:187


	/***** 5 将根目录初始化并写入sb.data_start_lba *****/
	/* 写入根目录的两个目录项.和.. */
	// inode不知道数据块中是普通文件，还是目录。但是目录项知道。
	memset(buf, 0, buf_size);
c0006cb1:	83 ec 04             	sub    $0x4,%esp
c0006cb4:	ff 75 bc             	pushl  -0x44(%ebp)
c0006cb7:	6a 00                	push   $0x0
c0006cb9:	ff 75 b8             	pushl  -0x48(%ebp)
c0006cbc:	e8 89 cd ff ff       	call   c0003a4a <memset>
c0006cc1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:188
	struct dir_entry* p_de = (struct dir_entry*)buf;
c0006cc4:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0006cc7:	89 45 a4             	mov    %eax,-0x5c(%ebp)
/work/x86_os_my/fs/fs.c:191

	/* 初始化当前目录"." */
	memcpy(p_de->filename, ".", 1);
c0006cca:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c0006ccd:	83 ec 04             	sub    $0x4,%esp
c0006cd0:	6a 01                	push   $0x1
c0006cd2:	68 bf 99 00 c0       	push   $0xc00099bf
c0006cd7:	50                   	push   %eax
c0006cd8:	e8 bf cd ff ff       	call   c0003a9c <memcpy>
c0006cdd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:192
	p_de->i_no = 0;	// 目录或文件对应的inode编号
c0006ce0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c0006ce3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
/work/x86_os_my/fs/fs.c:193
	p_de->f_type = FT_DIRECTORY;
c0006cea:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c0006ced:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%eax)
/work/x86_os_my/fs/fs.c:195

	p_de++;
c0006cf4:	83 45 a4 18          	addl   $0x18,-0x5c(%ebp)
/work/x86_os_my/fs/fs.c:198

	/* 初始化当前目录父目录".." */
	memcpy(p_de->filename, "..", 2);
c0006cf8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c0006cfb:	83 ec 04             	sub    $0x4,%esp
c0006cfe:	6a 02                	push   $0x2
c0006d00:	68 c1 99 00 c0       	push   $0xc00099c1
c0006d05:	50                   	push   %eax
c0006d06:	e8 91 cd ff ff       	call   c0003a9c <memcpy>
c0006d0b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:199
	p_de->i_no = 0;	// 根目录的父目录依然是根目录自己
c0006d0e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c0006d11:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
/work/x86_os_my/fs/fs.c:200
	p_de->f_type = FT_DIRECTORY;
c0006d18:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c0006d1b:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%eax)
/work/x86_os_my/fs/fs.c:203

	/* sb.data_start_lba已经分配给了根目录，我们把根目录的目录项放进去 */
	ide_write(hd, sb.data_start_lba, buf, 1);
c0006d22:	8b 85 cc fd ff ff    	mov    -0x234(%ebp),%eax
c0006d28:	6a 01                	push   $0x1
c0006d2a:	ff 75 b8             	pushl  -0x48(%ebp)
c0006d2d:	50                   	push   %eax
c0006d2e:	ff 75 c0             	pushl  -0x40(%ebp)
c0006d31:	e8 90 f0 ff ff       	call   c0005dc6 <ide_write>
c0006d36:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:206


	printk("   root_dir_lba:0x%x\n", sb.data_start_lba);
c0006d39:	8b 85 cc fd ff ff    	mov    -0x234(%ebp),%eax
c0006d3f:	83 ec 08             	sub    $0x8,%esp
c0006d42:	50                   	push   %eax
c0006d43:	68 c4 99 00 c0       	push   $0xc00099c4
c0006d48:	e8 7e f9 ff ff       	call   c00066cb <printk>
c0006d4d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:207
	printk("%s format done\n", part->name);
c0006d50:	8b 45 08             	mov    0x8(%ebp),%eax
c0006d53:	83 c0 14             	add    $0x14,%eax
c0006d56:	83 ec 08             	sub    $0x8,%esp
c0006d59:	50                   	push   %eax
c0006d5a:	68 da 99 00 c0       	push   $0xc00099da
c0006d5f:	e8 67 f9 ff ff       	call   c00066cb <printk>
c0006d64:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:208
	sys_free(buf);
c0006d67:	83 ec 0c             	sub    $0xc,%esp
c0006d6a:	ff 75 b8             	pushl  -0x48(%ebp)
c0006d6d:	e8 0e c8 ff ff       	call   c0003580 <sys_free>
c0006d72:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:209
}
c0006d75:	90                   	nop
c0006d76:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0006d79:	5b                   	pop    %ebx
c0006d7a:	5e                   	pop    %esi
c0006d7b:	5f                   	pop    %edi
c0006d7c:	5d                   	pop    %ebp
c0006d7d:	c3                   	ret    

c0006d7e <path_parse>:
path_parse():
/work/x86_os_my/fs/fs.c:214


/* 将最上层路径名称解析出来，比如pathname="a/b/c"得到name_store="a"
 * 返回剩下的目录 "b/c" */
static char* path_parse(char* pathname, char* name_store) {
c0006d7e:	55                   	push   %ebp
c0006d7f:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/fs/fs.c:215
	if (pathname[0] == '/') {	// 根目录不需要单独解析
c0006d81:	8b 45 08             	mov    0x8(%ebp),%eax
c0006d84:	0f b6 00             	movzbl (%eax),%eax
c0006d87:	3c 2f                	cmp    $0x2f,%al
c0006d89:	75 27                	jne    c0006db2 <path_parse+0x34>
/work/x86_os_my/fs/fs.c:217 (discriminator 1)
		/* 路径中出现1个或多个连续的字符'/',将这些'/'跳过,如"///a/b" */
		while(*(++pathname) == '/');
c0006d8b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0006d8f:	8b 45 08             	mov    0x8(%ebp),%eax
c0006d92:	0f b6 00             	movzbl (%eax),%eax
c0006d95:	3c 2f                	cmp    $0x2f,%al
c0006d97:	74 f2                	je     c0006d8b <path_parse+0xd>
/work/x86_os_my/fs/fs.c:221
	}

	/* 开始一般的路径解析 */
	while (*pathname != '/' && *pathname != 0) {
c0006d99:	eb 17                	jmp    c0006db2 <path_parse+0x34>
/work/x86_os_my/fs/fs.c:222
		*name_store++ = *pathname++;
c0006d9b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006d9e:	8d 50 01             	lea    0x1(%eax),%edx
c0006da1:	89 55 0c             	mov    %edx,0xc(%ebp)
c0006da4:	8b 55 08             	mov    0x8(%ebp),%edx
c0006da7:	8d 4a 01             	lea    0x1(%edx),%ecx
c0006daa:	89 4d 08             	mov    %ecx,0x8(%ebp)
c0006dad:	0f b6 12             	movzbl (%edx),%edx
c0006db0:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/fs/fs.c:221
		/* 路径中出现1个或多个连续的字符'/',将这些'/'跳过,如"///a/b" */
		while(*(++pathname) == '/');
	}

	/* 开始一般的路径解析 */
	while (*pathname != '/' && *pathname != 0) {
c0006db2:	8b 45 08             	mov    0x8(%ebp),%eax
c0006db5:	0f b6 00             	movzbl (%eax),%eax
c0006db8:	3c 2f                	cmp    $0x2f,%al
c0006dba:	74 0a                	je     c0006dc6 <path_parse+0x48>
/work/x86_os_my/fs/fs.c:221 (discriminator 1)
c0006dbc:	8b 45 08             	mov    0x8(%ebp),%eax
c0006dbf:	0f b6 00             	movzbl (%eax),%eax
c0006dc2:	84 c0                	test   %al,%al
c0006dc4:	75 d5                	jne    c0006d9b <path_parse+0x1d>
/work/x86_os_my/fs/fs.c:225
		*name_store++ = *pathname++;
	}

	if (pathname[0] == 0) {   // 若路径字符串为空则返回NULL
c0006dc6:	8b 45 08             	mov    0x8(%ebp),%eax
c0006dc9:	0f b6 00             	movzbl (%eax),%eax
c0006dcc:	84 c0                	test   %al,%al
c0006dce:	75 07                	jne    c0006dd7 <path_parse+0x59>
/work/x86_os_my/fs/fs.c:226
		return NULL;
c0006dd0:	b8 00 00 00 00       	mov    $0x0,%eax
c0006dd5:	eb 03                	jmp    c0006dda <path_parse+0x5c>
/work/x86_os_my/fs/fs.c:228
	}
	return pathname;
c0006dd7:	8b 45 08             	mov    0x8(%ebp),%eax
/work/x86_os_my/fs/fs.c:229
}
c0006dda:	5d                   	pop    %ebp
c0006ddb:	c3                   	ret    

c0006ddc <path_depth_cnt>:
path_depth_cnt():
/work/x86_os_my/fs/fs.c:232

/* 返回路径深度,比如/a/b/c,深度为3 */
int32_t path_depth_cnt(char* pathname) {
c0006ddc:	55                   	push   %ebp
c0006ddd:	89 e5                	mov    %esp,%ebp
c0006ddf:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/fs/fs.c:233
	ASSERT(pathname != NULL);
c0006de2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0006de6:	75 1c                	jne    c0006e04 <path_depth_cnt+0x28>
/work/x86_os_my/fs/fs.c:233 (discriminator 1)
c0006de8:	68 ea 99 00 c0       	push   $0xc00099ea
c0006ded:	68 ec 9b 00 c0       	push   $0xc0009bec
c0006df2:	68 e9 00 00 00       	push   $0xe9
c0006df7:	68 81 98 00 c0       	push   $0xc0009881
c0006dfc:	e8 31 b8 ff ff       	call   c0002632 <panic_spin>
c0006e01:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:234
	char* p = pathname;
c0006e04:	8b 45 08             	mov    0x8(%ebp),%eax
c0006e07:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:236
	char name[MAX_FILE_NAME_LEN];	// 用于path_parse的参数做路径解析
	uint32_t depth = 0;
c0006e0a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:239

	/* 解析路径,从中拆分出各级名称 */
	p = path_parse(p, name);
c0006e11:	83 ec 08             	sub    $0x8,%esp
c0006e14:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0006e17:	50                   	push   %eax
c0006e18:	ff 75 f4             	pushl  -0xc(%ebp)
c0006e1b:	e8 5e ff ff ff       	call   c0006d7e <path_parse>
c0006e20:	83 c4 10             	add    $0x10,%esp
c0006e23:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:240
	while (name[0]) {
c0006e26:	eb 32                	jmp    c0006e5a <path_depth_cnt+0x7e>
/work/x86_os_my/fs/fs.c:241
		depth++;
c0006e28:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:242
		memset(name, 0, MAX_FILE_NAME_LEN);
c0006e2c:	83 ec 04             	sub    $0x4,%esp
c0006e2f:	6a 10                	push   $0x10
c0006e31:	6a 00                	push   $0x0
c0006e33:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0006e36:	50                   	push   %eax
c0006e37:	e8 0e cc ff ff       	call   c0003a4a <memset>
c0006e3c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:243
		if (p) {	// 如果p不等于NULL,继续分析路径
c0006e3f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0006e43:	74 15                	je     c0006e5a <path_depth_cnt+0x7e>
/work/x86_os_my/fs/fs.c:244
			p  = path_parse(p, name);
c0006e45:	83 ec 08             	sub    $0x8,%esp
c0006e48:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0006e4b:	50                   	push   %eax
c0006e4c:	ff 75 f4             	pushl  -0xc(%ebp)
c0006e4f:	e8 2a ff ff ff       	call   c0006d7e <path_parse>
c0006e54:	83 c4 10             	add    $0x10,%esp
c0006e57:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:240
	char name[MAX_FILE_NAME_LEN];	// 用于path_parse的参数做路径解析
	uint32_t depth = 0;

	/* 解析路径,从中拆分出各级名称 */
	p = path_parse(p, name);
	while (name[0]) {
c0006e5a:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
c0006e5e:	84 c0                	test   %al,%al
c0006e60:	75 c6                	jne    c0006e28 <path_depth_cnt+0x4c>
/work/x86_os_my/fs/fs.c:247
		memset(name, 0, MAX_FILE_NAME_LEN);
		if (p) {	// 如果p不等于NULL,继续分析路径
			p  = path_parse(p, name);
		}
	}
	return depth;
c0006e62:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/fs/fs.c:248
}
c0006e65:	c9                   	leave  
c0006e66:	c3                   	ret    

c0006e67 <search_file>:
search_file():
/work/x86_os_my/fs/fs.c:257
 * 全局变量 struct dir root_dir 定义在 dir.c
 * 也支持 /./a 或者 /../b 会把.和..当做一个目录项继续往下层找
 * /a/b/c若c不存在，那么 searched_record.searched_path 是 /a/b/c
 * 注意下边三种return的地方，是三种情况！
 */
static int search_file(const char* pathname, struct path_search_record* searched_record) {
c0006e67:	55                   	push   %ebp
c0006e68:	89 e5                	mov    %esp,%ebp
c0006e6a:	83 ec 48             	sub    $0x48,%esp
/work/x86_os_my/fs/fs.c:259
	/* 如果待查找的是根目录,为避免下面无用的查找,直接返回已知根目录信息 */
	if (!strcmp(pathname, "/") || !strcmp(pathname, "/.") || !strcmp(pathname, "/..")) {
c0006e6d:	83 ec 08             	sub    $0x8,%esp
c0006e70:	68 fb 99 00 c0       	push   $0xc00099fb
c0006e75:	ff 75 08             	pushl  0x8(%ebp)
c0006e78:	e8 a2 cd ff ff       	call   c0003c1f <strcmp>
c0006e7d:	83 c4 10             	add    $0x10,%esp
c0006e80:	84 c0                	test   %al,%al
c0006e82:	74 2e                	je     c0006eb2 <search_file+0x4b>
/work/x86_os_my/fs/fs.c:259 (discriminator 1)
c0006e84:	83 ec 08             	sub    $0x8,%esp
c0006e87:	68 fd 99 00 c0       	push   $0xc00099fd
c0006e8c:	ff 75 08             	pushl  0x8(%ebp)
c0006e8f:	e8 8b cd ff ff       	call   c0003c1f <strcmp>
c0006e94:	83 c4 10             	add    $0x10,%esp
c0006e97:	84 c0                	test   %al,%al
c0006e99:	74 17                	je     c0006eb2 <search_file+0x4b>
/work/x86_os_my/fs/fs.c:259 (discriminator 2)
c0006e9b:	83 ec 08             	sub    $0x8,%esp
c0006e9e:	68 00 9a 00 c0       	push   $0xc0009a00
c0006ea3:	ff 75 08             	pushl  0x8(%ebp)
c0006ea6:	e8 74 cd ff ff       	call   c0003c1f <strcmp>
c0006eab:	83 c4 10             	add    $0x10,%esp
c0006eae:	84 c0                	test   %al,%al
c0006eb0:	75 2a                	jne    c0006edc <search_file+0x75>
/work/x86_os_my/fs/fs.c:260
		searched_record->parent_dir = &root_dir;	// 直接父目录
c0006eb2:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006eb5:	c7 80 00 02 00 00 60 	movl   $0xc000db60,0x200(%eax)
c0006ebc:	db 00 c0 
/work/x86_os_my/fs/fs.c:261
		searched_record->file_type = FT_DIRECTORY;	// FT_UNKNOWN代表没找到，找到才有类型是文件或目录
c0006ebf:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006ec2:	c7 80 04 02 00 00 02 	movl   $0x2,0x204(%eax)
c0006ec9:	00 00 00 
/work/x86_os_my/fs/fs.c:262
		searched_record->searched_path[0] = 0;		// 搜索过的路径置空
c0006ecc:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006ecf:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:263
		return 0;
c0006ed2:	b8 00 00 00 00       	mov    $0x0,%eax
c0006ed7:	e9 08 02 00 00       	jmp    c00070e4 <search_file+0x27d>
/work/x86_os_my/fs/fs.c:266
	}

	uint32_t path_len = strlen(pathname);
c0006edc:	83 ec 0c             	sub    $0xc,%esp
c0006edf:	ff 75 08             	pushl  0x8(%ebp)
c0006ee2:	e8 ed cc ff ff       	call   c0003bd4 <strlen>
c0006ee7:	83 c4 10             	add    $0x10,%esp
c0006eea:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:268
	/* 保证pathname至少是这样的路径/x且小于最大长度 */
	ASSERT(pathname[0] == '/' && path_len > 1 && path_len < MAX_PATH_LEN);
c0006eed:	8b 45 08             	mov    0x8(%ebp),%eax
c0006ef0:	0f b6 00             	movzbl (%eax),%eax
c0006ef3:	3c 2f                	cmp    $0x2f,%al
c0006ef5:	75 0f                	jne    c0006f06 <search_file+0x9f>
/work/x86_os_my/fs/fs.c:268 (discriminator 1)
c0006ef7:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c0006efb:	76 09                	jbe    c0006f06 <search_file+0x9f>
/work/x86_os_my/fs/fs.c:268 (discriminator 3)
c0006efd:	81 7d e8 ff 01 00 00 	cmpl   $0x1ff,-0x18(%ebp)
c0006f04:	76 1c                	jbe    c0006f22 <search_file+0xbb>
/work/x86_os_my/fs/fs.c:268 (discriminator 5)
c0006f06:	68 04 9a 00 c0       	push   $0xc0009a04
c0006f0b:	68 fc 9b 00 c0       	push   $0xc0009bfc
c0006f10:	68 0c 01 00 00       	push   $0x10c
c0006f15:	68 81 98 00 c0       	push   $0xc0009881
c0006f1a:	e8 13 b7 ff ff       	call   c0002632 <panic_spin>
c0006f1f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:269
	char* sub_path = (char*)pathname;
c0006f22:	8b 45 08             	mov    0x8(%ebp),%eax
c0006f25:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:270
	struct dir* parent_dir = &root_dir;
c0006f28:	c7 45 f0 60 db 00 c0 	movl   $0xc000db60,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:274
	struct dir_entry dir_e;

	/* 数组name每次的值分别是各级目录的名字："a","b","c" */
	char name[MAX_FILE_NAME_LEN] = {0};
c0006f2f:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
c0006f36:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
c0006f3d:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
c0006f44:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
/work/x86_os_my/fs/fs.c:276

	searched_record->parent_dir = parent_dir;	// 直接父目录
c0006f4b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006f4e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0006f51:	89 90 00 02 00 00    	mov    %edx,0x200(%eax)
/work/x86_os_my/fs/fs.c:277
	searched_record->file_type = FT_UNKNOWN;	// 初始值代表没找到，找到才有类型是文件或目录
c0006f57:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006f5a:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%eax)
c0006f61:	00 00 00 
/work/x86_os_my/fs/fs.c:278
	uint32_t parent_inode_no = 0;  // 备份各层解析出来的路径，的父目录，的inode号
c0006f64:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:280

	sub_path = path_parse(sub_path, name);
c0006f6b:	83 ec 08             	sub    $0x8,%esp
c0006f6e:	8d 45 c0             	lea    -0x40(%ebp),%eax
c0006f71:	50                   	push   %eax
c0006f72:	ff 75 f4             	pushl  -0xc(%ebp)
c0006f75:	e8 04 fe ff ff       	call   c0006d7e <path_parse>
c0006f7a:	83 c4 10             	add    $0x10,%esp
c0006f7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:281
	while (name[0]) {	   // 若第一个字符就是结束符,结束循环
c0006f80:	e9 0f 01 00 00       	jmp    c0007094 <search_file+0x22d>
/work/x86_os_my/fs/fs.c:283
		/* 记录查找过的路径,但不能超过searched_path的长度512字节 */
		ASSERT(strlen(searched_record->searched_path) < 512);
c0006f85:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006f88:	83 ec 0c             	sub    $0xc,%esp
c0006f8b:	50                   	push   %eax
c0006f8c:	e8 43 cc ff ff       	call   c0003bd4 <strlen>
c0006f91:	83 c4 10             	add    $0x10,%esp
c0006f94:	3d ff 01 00 00       	cmp    $0x1ff,%eax
c0006f99:	76 1c                	jbe    c0006fb7 <search_file+0x150>
/work/x86_os_my/fs/fs.c:283 (discriminator 1)
c0006f9b:	68 44 9a 00 c0       	push   $0xc0009a44
c0006fa0:	68 fc 9b 00 c0       	push   $0xc0009bfc
c0006fa5:	68 1b 01 00 00       	push   $0x11b
c0006faa:	68 81 98 00 c0       	push   $0xc0009881
c0006faf:	e8 7e b6 ff ff       	call   c0002632 <panic_spin>
c0006fb4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:286

		/* 追加到已存在的父目录 */
		strcat(searched_record->searched_path, "/");
c0006fb7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006fba:	83 ec 08             	sub    $0x8,%esp
c0006fbd:	68 fb 99 00 c0       	push   $0xc00099fb
c0006fc2:	50                   	push   %eax
c0006fc3:	e8 86 cd ff ff       	call   c0003d4e <strcat>
c0006fc8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:287
		strcat(searched_record->searched_path, name);
c0006fcb:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006fce:	83 ec 08             	sub    $0x8,%esp
c0006fd1:	8d 55 c0             	lea    -0x40(%ebp),%edx
c0006fd4:	52                   	push   %edx
c0006fd5:	50                   	push   %eax
c0006fd6:	e8 73 cd ff ff       	call   c0003d4e <strcat>
c0006fdb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:290

		/* 在所给的目录中查找目录项，找到后将目录项填入dir_e */
		if (false != search_dir_entry(cur_part, parent_dir, name, &dir_e)) {
c0006fde:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c0006fe3:	8d 55 d0             	lea    -0x30(%ebp),%edx
c0006fe6:	52                   	push   %edx
c0006fe7:	8d 55 c0             	lea    -0x40(%ebp),%edx
c0006fea:	52                   	push   %edx
c0006feb:	ff 75 f0             	pushl  -0x10(%ebp)
c0006fee:	50                   	push   %eax
c0006fef:	e8 3f 10 00 00       	call   c0008033 <search_dir_entry>
c0006ff4:	83 c4 10             	add    $0x10,%esp
c0006ff7:	85 c0                	test   %eax,%eax
c0006ff9:	0f 84 8e 00 00 00    	je     c000708d <search_file+0x226>
/work/x86_os_my/fs/fs.c:291
			memset(name, 0, MAX_FILE_NAME_LEN);
c0006fff:	83 ec 04             	sub    $0x4,%esp
c0007002:	6a 10                	push   $0x10
c0007004:	6a 00                	push   $0x0
c0007006:	8d 45 c0             	lea    -0x40(%ebp),%eax
c0007009:	50                   	push   %eax
c000700a:	e8 3b ca ff ff       	call   c0003a4a <memset>
c000700f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:293
			/* 若sub_path不等于NULL，也就是搜索未结束，继续拆分路径 */
			if (sub_path) {
c0007012:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0007016:	74 15                	je     c000702d <search_file+0x1c6>
/work/x86_os_my/fs/fs.c:294
				sub_path = path_parse(sub_path, name);
c0007018:	83 ec 08             	sub    $0x8,%esp
c000701b:	8d 45 c0             	lea    -0x40(%ebp),%eax
c000701e:	50                   	push   %eax
c000701f:	ff 75 f4             	pushl  -0xc(%ebp)
c0007022:	e8 57 fd ff ff       	call   c0006d7e <path_parse>
c0007027:	83 c4 10             	add    $0x10,%esp
c000702a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:297
			}

			if (FT_DIRECTORY == dir_e.f_type) {			// 如果被打开的是目录
c000702d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0007030:	83 f8 02             	cmp    $0x2,%eax
c0007033:	75 3e                	jne    c0007073 <search_file+0x20c>
/work/x86_os_my/fs/fs.c:298
				parent_inode_no = parent_dir->inode->i_no;
c0007035:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0007038:	8b 00                	mov    (%eax),%eax
c000703a:	8b 00                	mov    (%eax),%eax
c000703c:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:299
				dir_close(parent_dir);
c000703f:	83 ec 0c             	sub    $0xc,%esp
c0007042:	ff 75 f0             	pushl  -0x10(%ebp)
c0007045:	e8 c1 11 00 00       	call   c000820b <dir_close>
c000704a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:301

				parent_dir = dir_open(cur_part, dir_e.i_no);
c000704d:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0007050:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c0007055:	83 ec 08             	sub    $0x8,%esp
c0007058:	52                   	push   %edx
c0007059:	50                   	push   %eax
c000705a:	e8 94 0f 00 00       	call   c0007ff3 <dir_open>
c000705f:	83 c4 10             	add    $0x10,%esp
c0007062:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:302
				searched_record->parent_dir = parent_dir;	// 更新直接父目录
c0007065:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007068:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000706b:	89 90 00 02 00 00    	mov    %edx,0x200(%eax)
/work/x86_os_my/fs/fs.c:303
				continue;
c0007071:	eb 21                	jmp    c0007094 <search_file+0x22d>
/work/x86_os_my/fs/fs.c:304
			} else if (FT_REGULAR == dir_e.f_type) {	// 若是普通文件
c0007073:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0007076:	83 f8 01             	cmp    $0x1,%eax
c0007079:	75 19                	jne    c0007094 <search_file+0x22d>
/work/x86_os_my/fs/fs.c:309
				/* 如果搜索路径为 /a/b 但是目录下只有文件a 此时也会返回文件a的inode号【中间某个目录不存在】
				 * 由主调函数根据 searched_record.searched_path 判断："提供的 pathname 是否正确，是否处理完了"
				 * 【情况1】
				 */
				searched_record->file_type = FT_REGULAR;
c000707b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000707e:	c7 80 04 02 00 00 01 	movl   $0x1,0x204(%eax)
c0007085:	00 00 00 
/work/x86_os_my/fs/fs.c:310
				return dir_e.i_no;
c0007088:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000708b:	eb 57                	jmp    c00070e4 <search_file+0x27d>
/work/x86_os_my/fs/fs.c:318
			/* 找不到目录项时，要留着 parent_dir 不要关闭，
			 * 主调函数需要据此知道在哪个目录中创建文件，此时的 searched_record->parent_dir 指向父目录，主调函数负责关闭该目录
			 * 主调函数，创建新文件的话需要在 parent_dir 中创建
			 * 【情况2】
			 */
			return -1;
c000708d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007092:	eb 50                	jmp    c00070e4 <search_file+0x27d>
/work/x86_os_my/fs/fs.c:281
	searched_record->parent_dir = parent_dir;	// 直接父目录
	searched_record->file_type = FT_UNKNOWN;	// 初始值代表没找到，找到才有类型是文件或目录
	uint32_t parent_inode_no = 0;  // 备份各层解析出来的路径，的父目录，的inode号

	sub_path = path_parse(sub_path, name);
	while (name[0]) {	   // 若第一个字符就是结束符,结束循环
c0007094:	0f b6 45 c0          	movzbl -0x40(%ebp),%eax
c0007098:	84 c0                	test   %al,%al
c000709a:	0f 85 e5 fe ff ff    	jne    c0006f85 <search_file+0x11e>
/work/x86_os_my/fs/fs.c:329
	 * 此时 searched_record-> parent_dir 是路径 pathname 中的最后一级目录 c，并不是倒数第二级的父目录 b
	 * 要保证，无论搜索目标是普通文件，还是目录，searched_record->parent_dir 中记录的都应该是父目录！
	 * 因此要关闭目录c，重新打开目录b
	 * 【情况3】
	 */
	dir_close(searched_record->parent_dir);
c00070a0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00070a3:	8b 80 00 02 00 00    	mov    0x200(%eax),%eax
c00070a9:	83 ec 0c             	sub    $0xc,%esp
c00070ac:	50                   	push   %eax
c00070ad:	e8 59 11 00 00       	call   c000820b <dir_close>
c00070b2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:330
	searched_record->parent_dir = dir_open(cur_part, parent_inode_no);
c00070b5:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c00070ba:	83 ec 08             	sub    $0x8,%esp
c00070bd:	ff 75 ec             	pushl  -0x14(%ebp)
c00070c0:	50                   	push   %eax
c00070c1:	e8 2d 0f 00 00       	call   c0007ff3 <dir_open>
c00070c6:	83 c4 10             	add    $0x10,%esp
c00070c9:	89 c2                	mov    %eax,%edx
c00070cb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00070ce:	89 90 00 02 00 00    	mov    %edx,0x200(%eax)
/work/x86_os_my/fs/fs.c:331
	searched_record->file_type = FT_DIRECTORY;
c00070d4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00070d7:	c7 80 04 02 00 00 02 	movl   $0x2,0x204(%eax)
c00070de:	00 00 00 
/work/x86_os_my/fs/fs.c:332
	return dir_e.i_no;	//目录c的inode号
c00070e1:	8b 45 e0             	mov    -0x20(%ebp),%eax
/work/x86_os_my/fs/fs.c:333 (discriminator 1)
}
c00070e4:	c9                   	leave  
c00070e5:	c3                   	ret    

c00070e6 <sys_open>:
sys_open():
/work/x86_os_my/fs/fs.c:340
/* 打开或创建文件成功后,返回文件描述符,否则返回-1
 * 对应 file.c 中的 file_create
 *
 * open(const char * pathname, (O_CREAT|O_WRONLY|O_TRUNC));
 */
int32_t sys_open(const char* pathname, uint8_t flags) {
c00070e6:	55                   	push   %ebp
c00070e7:	89 e5                	mov    %esp,%ebp
c00070e9:	53                   	push   %ebx
c00070ea:	81 ec 34 02 00 00    	sub    $0x234,%esp
c00070f0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00070f3:	88 85 d4 fd ff ff    	mov    %al,-0x22c(%ebp)
/work/x86_os_my/fs/fs.c:342
	/* 对目录要用dir_open,这里只有open文件 */
	if (pathname[strlen(pathname) - 1] == '/') {
c00070f9:	83 ec 0c             	sub    $0xc,%esp
c00070fc:	ff 75 08             	pushl  0x8(%ebp)
c00070ff:	e8 d0 ca ff ff       	call   c0003bd4 <strlen>
c0007104:	83 c4 10             	add    $0x10,%esp
c0007107:	8d 50 ff             	lea    -0x1(%eax),%edx
c000710a:	8b 45 08             	mov    0x8(%ebp),%eax
c000710d:	01 d0                	add    %edx,%eax
c000710f:	0f b6 00             	movzbl (%eax),%eax
c0007112:	3c 2f                	cmp    $0x2f,%al
c0007114:	75 1d                	jne    c0007133 <sys_open+0x4d>
/work/x86_os_my/fs/fs.c:343
		printk("can`t open a directory %s\n", pathname);
c0007116:	83 ec 08             	sub    $0x8,%esp
c0007119:	ff 75 08             	pushl  0x8(%ebp)
c000711c:	68 71 9a 00 c0       	push   $0xc0009a71
c0007121:	e8 a5 f5 ff ff       	call   c00066cb <printk>
c0007126:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:344
		return -1;
c0007129:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000712e:	e9 10 02 00 00       	jmp    c0007343 <sys_open+0x25d>
/work/x86_os_my/fs/fs.c:346
	}
	ASSERT(flags <= 7);
c0007133:	80 bd d4 fd ff ff 07 	cmpb   $0x7,-0x22c(%ebp)
c000713a:	76 1c                	jbe    c0007158 <sys_open+0x72>
/work/x86_os_my/fs/fs.c:346 (discriminator 1)
c000713c:	68 8c 9a 00 c0       	push   $0xc0009a8c
c0007141:	68 08 9c 00 c0       	push   $0xc0009c08
c0007146:	68 5a 01 00 00       	push   $0x15a
c000714b:	68 81 98 00 c0       	push   $0xc0009881
c0007150:	e8 dd b4 ff ff       	call   c0002632 <panic_spin>
c0007155:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:347
	int32_t fd = -1;	// 默认为找不到
c0007158:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:350

	struct path_search_record searched_record;
	memset(&searched_record, 0, sizeof(struct path_search_record));
c000715f:	83 ec 04             	sub    $0x4,%esp
c0007162:	68 08 02 00 00       	push   $0x208
c0007167:	6a 00                	push   $0x0
c0007169:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c000716f:	50                   	push   %eax
c0007170:	e8 d5 c8 ff ff       	call   c0003a4a <memset>
c0007175:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:353

	/* 记录目录深度.帮助判断中间某个目录不存在的情况 */
	uint32_t pathname_depth = path_depth_cnt((char*)pathname);
c0007178:	83 ec 0c             	sub    $0xc,%esp
c000717b:	ff 75 08             	pushl  0x8(%ebp)
c000717e:	e8 59 fc ff ff       	call   c0006ddc <path_depth_cnt>
c0007183:	83 c4 10             	add    $0x10,%esp
c0007186:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:356

	/* 先检查文件是否存在 */
	int inode_no = search_file(pathname, &searched_record);
c0007189:	83 ec 08             	sub    $0x8,%esp
c000718c:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c0007192:	50                   	push   %eax
c0007193:	ff 75 08             	pushl  0x8(%ebp)
c0007196:	e8 cc fc ff ff       	call   c0006e67 <search_file>
c000719b:	83 c4 10             	add    $0x10,%esp
c000719e:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:357
	bool found = (inode_no != -1 ? true : false);
c00071a1:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c00071a5:	0f 95 c0             	setne  %al
c00071a8:	0f b6 c0             	movzbl %al,%eax
c00071ab:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:359

	if (searched_record.file_type == FT_DIRECTORY) {
c00071ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00071b1:	83 f8 02             	cmp    $0x2,%eax
c00071b4:	75 29                	jne    c00071df <sys_open+0xf9>
/work/x86_os_my/fs/fs.c:360
		printk("can`t open a direcotry with open(), use opendir() to instead\n");
c00071b6:	83 ec 0c             	sub    $0xc,%esp
c00071b9:	68 98 9a 00 c0       	push   $0xc0009a98
c00071be:	e8 08 f5 ff ff       	call   c00066cb <printk>
c00071c3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:361
		dir_close(searched_record.parent_dir);	//主调函数负责关闭该目录
c00071c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00071c9:	83 ec 0c             	sub    $0xc,%esp
c00071cc:	50                   	push   %eax
c00071cd:	e8 39 10 00 00       	call   c000820b <dir_close>
c00071d2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:362
		return -1;
c00071d5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00071da:	e9 64 01 00 00       	jmp    c0007343 <sys_open+0x25d>
/work/x86_os_my/fs/fs.c:365
	}

	uint32_t path_searched_depth = path_depth_cnt(searched_record.searched_path);
c00071df:	83 ec 0c             	sub    $0xc,%esp
c00071e2:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c00071e8:	50                   	push   %eax
c00071e9:	e8 ee fb ff ff       	call   c0006ddc <path_depth_cnt>
c00071ee:	83 c4 10             	add    $0x10,%esp
c00071f1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/fs.c:369

	/* 先判断是否把pathname的各层目录都访问到了 */
	// 【search_file情况1】说明并没有访问到全部的路径,某个中间目录是不存在的【是一个同名的普通文件】
	if (pathname_depth != path_searched_depth) {
c00071f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00071f7:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c00071fa:	74 33                	je     c000722f <sys_open+0x149>
/work/x86_os_my/fs/fs.c:370
		printk("cannot access %s: Not a directory, subpath %s is`t exist\n",
c00071fc:	83 ec 04             	sub    $0x4,%esp
c00071ff:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c0007205:	50                   	push   %eax
c0007206:	ff 75 08             	pushl  0x8(%ebp)
c0007209:	68 d8 9a 00 c0       	push   $0xc0009ad8
c000720e:	e8 b8 f4 ff ff       	call   c00066cb <printk>
c0007213:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:372
			pathname, searched_record.searched_path);
		dir_close(searched_record.parent_dir);
c0007216:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0007219:	83 ec 0c             	sub    $0xc,%esp
c000721c:	50                   	push   %eax
c000721d:	e8 e9 0f 00 00       	call   c000820b <dir_close>
c0007222:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:373
		return -1;
c0007225:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000722a:	e9 14 01 00 00       	jmp    c0007343 <sys_open+0x25d>
/work/x86_os_my/fs/fs.c:378
	}

	// 【search_file情况2】若是在最后一个路径上没找到
	// 并且此时也不是要创建文件,直接返回-1 */
	if (!found && !(flags & O_CREAT)) {
c000722f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0007233:	75 56                	jne    c000728b <sys_open+0x1a5>
/work/x86_os_my/fs/fs.c:378 (discriminator 1)
c0007235:	0f b6 85 d4 fd ff ff 	movzbl -0x22c(%ebp),%eax
c000723c:	83 e0 04             	and    $0x4,%eax
c000723f:	85 c0                	test   %eax,%eax
c0007241:	75 48                	jne    c000728b <sys_open+0x1a5>
/work/x86_os_my/fs/fs.c:380
		printk("in path %s, file %s is`t exist\n",
			searched_record.searched_path, (strrchr(searched_record.searched_path, '/') + 1));
c0007243:	83 ec 08             	sub    $0x8,%esp
c0007246:	6a 2f                	push   $0x2f
c0007248:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c000724e:	50                   	push   %eax
c000724f:	e8 9c ca ff ff       	call   c0003cf0 <strrchr>
c0007254:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:379
	}

	// 【search_file情况2】若是在最后一个路径上没找到
	// 并且此时也不是要创建文件,直接返回-1 */
	if (!found && !(flags & O_CREAT)) {
		printk("in path %s, file %s is`t exist\n",
c0007257:	83 c0 01             	add    $0x1,%eax
c000725a:	83 ec 04             	sub    $0x4,%esp
c000725d:	50                   	push   %eax
c000725e:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c0007264:	50                   	push   %eax
c0007265:	68 14 9b 00 c0       	push   $0xc0009b14
c000726a:	e8 5c f4 ff ff       	call   c00066cb <printk>
c000726f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:381
			searched_record.searched_path, (strrchr(searched_record.searched_path, '/') + 1));
		dir_close(searched_record.parent_dir);
c0007272:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0007275:	83 ec 0c             	sub    $0xc,%esp
c0007278:	50                   	push   %eax
c0007279:	e8 8d 0f 00 00       	call   c000820b <dir_close>
c000727e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:382
		return -1;
c0007281:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007286:	e9 b8 00 00 00       	jmp    c0007343 <sys_open+0x25d>
/work/x86_os_my/fs/fs.c:383
	} else if (found && flags & O_CREAT) {	// 若要创建的文件已存在，相同目录下不可以有同名文件，返回-1
c000728b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c000728f:	74 37                	je     c00072c8 <sys_open+0x1e2>
/work/x86_os_my/fs/fs.c:383 (discriminator 1)
c0007291:	0f b6 85 d4 fd ff ff 	movzbl -0x22c(%ebp),%eax
c0007298:	83 e0 04             	and    $0x4,%eax
c000729b:	85 c0                	test   %eax,%eax
c000729d:	74 29                	je     c00072c8 <sys_open+0x1e2>
/work/x86_os_my/fs/fs.c:384
		printk("%s has already exist!\n", pathname);
c000729f:	83 ec 08             	sub    $0x8,%esp
c00072a2:	ff 75 08             	pushl  0x8(%ebp)
c00072a5:	68 34 9b 00 c0       	push   $0xc0009b34
c00072aa:	e8 1c f4 ff ff       	call   c00066cb <printk>
c00072af:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:385
		dir_close(searched_record.parent_dir);
c00072b2:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00072b5:	83 ec 0c             	sub    $0xc,%esp
c00072b8:	50                   	push   %eax
c00072b9:	e8 4d 0f 00 00       	call   c000820b <dir_close>
c00072be:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:386
		return -1;
c00072c1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00072c6:	eb 7b                	jmp    c0007343 <sys_open+0x25d>
/work/x86_os_my/fs/fs.c:389
	}

	switch (flags & O_CREAT) {	// sys_open("xxx", O_CREAT|O_XXX)
c00072c8:	0f b6 85 d4 fd ff ff 	movzbl -0x22c(%ebp),%eax
c00072cf:	83 e0 04             	and    $0x4,%eax
c00072d2:	83 f8 04             	cmp    $0x4,%eax
c00072d5:	75 4f                	jne    c0007326 <sys_open+0x240>
/work/x86_os_my/fs/fs.c:391
		case O_CREAT:
		printk("creating file\n");
c00072d7:	83 ec 0c             	sub    $0xc,%esp
c00072da:	68 4b 9b 00 c0       	push   $0xc0009b4b
c00072df:	e8 e7 f3 ff ff       	call   c00066cb <printk>
c00072e4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:393
		// 【search_file情况3】主调函数用到此目录，在该目录下创建文件
		fd = file_create(searched_record.parent_dir, (strrchr(pathname, '/') + 1), flags);
c00072e7:	0f b6 9d d4 fd ff ff 	movzbl -0x22c(%ebp),%ebx
c00072ee:	83 ec 08             	sub    $0x8,%esp
c00072f1:	6a 2f                	push   $0x2f
c00072f3:	ff 75 08             	pushl  0x8(%ebp)
c00072f6:	e8 f5 c9 ff ff       	call   c0003cf0 <strrchr>
c00072fb:	83 c4 10             	add    $0x10,%esp
c00072fe:	8d 50 01             	lea    0x1(%eax),%edx
c0007301:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0007304:	83 ec 04             	sub    $0x4,%esp
c0007307:	53                   	push   %ebx
c0007308:	52                   	push   %edx
c0007309:	50                   	push   %eax
c000730a:	e8 96 08 00 00       	call   c0007ba5 <file_create>
c000730f:	83 c4 10             	add    $0x10,%esp
c0007312:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:394
		dir_close(searched_record.parent_dir);
c0007315:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0007318:	83 ec 0c             	sub    $0xc,%esp
c000731b:	50                   	push   %eax
c000731c:	e8 ea 0e 00 00       	call   c000820b <dir_close>
c0007321:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:395
		break;
c0007324:	eb 1a                	jmp    c0007340 <sys_open+0x25a>
/work/x86_os_my/fs/fs.c:399
		
		default:
		/* 其余情况均为打开已存在文件: O_RDONLY,O_WRONLY,O_RDWR */
		fd = file_open(inode_no, flags);
c0007326:	0f b6 95 d4 fd ff ff 	movzbl -0x22c(%ebp),%edx
c000732d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0007330:	83 ec 08             	sub    $0x8,%esp
c0007333:	52                   	push   %edx
c0007334:	50                   	push   %eax
c0007335:	e8 2d 0b 00 00       	call   c0007e67 <file_open>
c000733a:	83 c4 10             	add    $0x10,%esp
c000733d:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:404
	}

	/* 此fd是指任务pcb->fd_table数组中的元素下标,
	 * 并不是指全局file_table中的下标 */
	return fd;
c0007340:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:405 (discriminator 1)
}
c0007343:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0007346:	c9                   	leave  
c0007347:	c3                   	ret    

c0007348 <fd_local2global>:
fd_local2global():
/work/x86_os_my/fs/fs.c:408

/* 将文件描述符转化为文件表的下标 */
static uint32_t fd_local2global(uint32_t local_fd) {
c0007348:	55                   	push   %ebp
c0007349:	89 e5                	mov    %esp,%ebp
c000734b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/fs.c:409
	struct task_struct* cur = running_thread();
c000734e:	e8 de ca ff ff       	call   c0003e31 <running_thread>
c0007353:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:410
	int32_t global_fd = cur->fd_table[local_fd];  
c0007356:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0007359:	8b 55 08             	mov    0x8(%ebp),%edx
c000735c:	83 c2 08             	add    $0x8,%edx
c000735f:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
c0007363:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:411
	ASSERT(global_fd >= 0 && global_fd < MAX_FILE_OPEN);
c0007366:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000736a:	78 06                	js     c0007372 <fd_local2global+0x2a>
/work/x86_os_my/fs/fs.c:411 (discriminator 1)
c000736c:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
c0007370:	7e 1c                	jle    c000738e <fd_local2global+0x46>
/work/x86_os_my/fs/fs.c:411 (discriminator 3)
c0007372:	68 5c 9b 00 c0       	push   $0xc0009b5c
c0007377:	68 14 9c 00 c0       	push   $0xc0009c14
c000737c:	68 9b 01 00 00       	push   $0x19b
c0007381:	68 81 98 00 c0       	push   $0xc0009881
c0007386:	e8 a7 b2 ff ff       	call   c0002632 <panic_spin>
c000738b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:412
	return (uint32_t)global_fd;
c000738e:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/fs/fs.c:413
} 
c0007391:	c9                   	leave  
c0007392:	c3                   	ret    

c0007393 <sys_close>:
sys_close():
/work/x86_os_my/fs/fs.c:416

/* 关闭文件描述符fd指向的文件,成功返回0,否则返回-1 */
int32_t sys_close(int32_t fd) {
c0007393:	55                   	push   %ebp
c0007394:	89 e5                	mov    %esp,%ebp
c0007396:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/fs.c:417
	int32_t ret = -1;   // 返回值默认为-1,即失败
c0007399:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:418
	if (fd > 2) {
c00073a0:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c00073a4:	7e 47                	jle    c00073ed <sys_close+0x5a>
/work/x86_os_my/fs/fs.c:419
		uint32_t _fd = fd_local2global(fd);
c00073a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00073a9:	83 ec 0c             	sub    $0xc,%esp
c00073ac:	50                   	push   %eax
c00073ad:	e8 96 ff ff ff       	call   c0007348 <fd_local2global>
c00073b2:	83 c4 10             	add    $0x10,%esp
c00073b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:420
		ret = file_close(&file_table[_fd]);
c00073b8:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00073bb:	89 d0                	mov    %edx,%eax
c00073bd:	01 c0                	add    %eax,%eax
c00073bf:	01 d0                	add    %edx,%eax
c00073c1:	c1 e0 02             	shl    $0x2,%eax
c00073c4:	05 e0 d9 00 c0       	add    $0xc000d9e0,%eax
c00073c9:	83 ec 0c             	sub    $0xc,%esp
c00073cc:	50                   	push   %eax
c00073cd:	e8 ae 0b 00 00       	call   c0007f80 <file_close>
c00073d2:	83 c4 10             	add    $0x10,%esp
c00073d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:421
		running_thread()->fd_table[fd] = -1; // 使该文件描述符位可用
c00073d8:	e8 54 ca ff ff       	call   c0003e31 <running_thread>
c00073dd:	89 c2                	mov    %eax,%edx
c00073df:	8b 45 08             	mov    0x8(%ebp),%eax
c00073e2:	83 c0 08             	add    $0x8,%eax
c00073e5:	c7 44 82 04 ff ff ff 	movl   $0xffffffff,0x4(%edx,%eax,4)
c00073ec:	ff 
/work/x86_os_my/fs/fs.c:423
	}
	return ret;
c00073ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:424
}
c00073f0:	c9                   	leave  
c00073f1:	c3                   	ret    

c00073f2 <filesys_init>:
filesys_init():
/work/x86_os_my/fs/fs.c:436
 * 只支持 partition_format 函数创建的文件系统，其魔数等于 0x19590318
 * 三层循环：遍历通道，遍历通道中的硬盘，遍历硬盘上的分区
 * 全局变量 channel_cnt 通道数，定义在 ide.c
 * 全局变量 channels 结构体，定义在 ide.c
 */
void filesys_init() {
c00073f2:	55                   	push   %ebp
c00073f3:	89 e5                	mov    %esp,%ebp
c00073f5:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/fs/fs.c:437
	uint8_t channel_no = 0, dev_no, part_idx = 0;
c00073f8:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
c00073fc:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
/work/x86_os_my/fs/fs.c:440

	/* sb_buf用来存储从硬盘上读入的超级块 */
	struct super_block* sb_buf = (struct super_block*)sys_malloc(SECTOR_SIZE);
c0007400:	83 ec 0c             	sub    $0xc,%esp
c0007403:	68 00 02 00 00       	push   $0x200
c0007408:	e8 46 bb ff ff       	call   c0002f53 <sys_malloc>
c000740d:	83 c4 10             	add    $0x10,%esp
c0007410:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:441
	if (sb_buf == NULL) {
c0007413:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0007417:	75 1c                	jne    c0007435 <filesys_init+0x43>
/work/x86_os_my/fs/fs.c:442
		PANIC("alloc memory failed!");
c0007419:	68 6c 98 00 c0       	push   $0xc000986c
c000741e:	68 24 9c 00 c0       	push   $0xc0009c24
c0007423:	68 ba 01 00 00       	push   $0x1ba
c0007428:	68 81 98 00 c0       	push   $0xc0009881
c000742d:	e8 00 b2 ff ff       	call   c0002632 <panic_spin>
c0007432:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:445
	}

	printk("searching filesystem......\n");
c0007435:	83 ec 0c             	sub    $0xc,%esp
c0007438:	68 88 9b 00 c0       	push   $0xc0009b88
c000743d:	e8 89 f2 ff ff       	call   c00066cb <printk>
c0007442:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:447
	/* 遍历通道 */
	while (channel_no < channel_cnt) {
c0007445:	e9 1a 01 00 00       	jmp    c0007564 <filesys_init+0x172>
/work/x86_os_my/fs/fs.c:448
		dev_no = 0;
c000744a:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
/work/x86_os_my/fs/fs.c:450
		/* 遍历通道里的硬盘 */
		while(dev_no < 2) {
c000744e:	e9 fd 00 00 00       	jmp    c0007550 <filesys_init+0x15e>
/work/x86_os_my/fs/fs.c:451
			if (dev_no == 0) {		// 跨过裸盘hd60M.img
c0007453:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c0007457:	75 0f                	jne    c0007468 <filesys_init+0x76>
/work/x86_os_my/fs/fs.c:452
				dev_no++;
c0007459:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c000745d:	83 c0 01             	add    $0x1,%eax
c0007460:	88 45 f6             	mov    %al,-0xa(%ebp)
/work/x86_os_my/fs/fs.c:453
				continue;
c0007463:	e9 e8 00 00 00       	jmp    c0007550 <filesys_init+0x15e>
/work/x86_os_my/fs/fs.c:455
			}
			struct disk* hd = &channels[channel_no].devices[dev_no];
c0007468:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000746c:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
c0007470:	69 d2 10 03 00 00    	imul   $0x310,%edx,%edx
c0007476:	69 c0 60 06 00 00    	imul   $0x660,%eax,%eax
c000747c:	01 d0                	add    %edx,%eax
c000747e:	83 c0 40             	add    $0x40,%eax
c0007481:	05 00 cd 00 c0       	add    $0xc000cd00,%eax
c0007486:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/fs.c:456
			struct partition* part = hd->prim_parts;	// 主分区数组
c0007489:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000748c:	83 c0 10             	add    $0x10,%eax
c000748f:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:458
			/* 遍历硬盘里的分区 */
			while(part_idx < 12) {						// 4个主分区+8个逻辑
c0007492:	e9 a5 00 00 00       	jmp    c000753c <filesys_init+0x14a>
/work/x86_os_my/fs/fs.c:459
				if (part_idx == 4) {
c0007497:	80 7d f5 04          	cmpb   $0x4,-0xb(%ebp)
c000749b:	75 0b                	jne    c00074a8 <filesys_init+0xb6>
/work/x86_os_my/fs/fs.c:460
					part = hd->logic_parts;				// 逻辑分区数组
c000749d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00074a0:	05 10 01 00 00       	add    $0x110,%eax
c00074a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:465
				}

				/* channels数组是全局变量,默认值为0
				 * 固 channels.disk.partition.sec_cnt 在未初始化时，也为0 */
				if (part->sec_cnt != 0) {	// 如果分区存在，以sec_cnt是否为0当判断依据
c00074a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00074ab:	8b 40 04             	mov    0x4(%eax),%eax
c00074ae:	85 c0                	test   %eax,%eax
c00074b0:	74 7c                	je     c000752e <filesys_init+0x13c>
/work/x86_os_my/fs/fs.c:466
					memset(sb_buf, 0, SECTOR_SIZE);
c00074b2:	83 ec 04             	sub    $0x4,%esp
c00074b5:	68 00 02 00 00       	push   $0x200
c00074ba:	6a 00                	push   $0x0
c00074bc:	ff 75 e8             	pushl  -0x18(%ebp)
c00074bf:	e8 86 c5 ff ff       	call   c0003a4a <memset>
c00074c4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:469

					/* 读出分区的超级块，根据魔数判断是否存在我们定义的文件系统  */
					ide_read(hd, part->start_lba + 1, sb_buf, 1);
c00074c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00074ca:	8b 00                	mov    (%eax),%eax
c00074cc:	83 c0 01             	add    $0x1,%eax
c00074cf:	6a 01                	push   $0x1
c00074d1:	ff 75 e8             	pushl  -0x18(%ebp)
c00074d4:	50                   	push   %eax
c00074d5:	ff 75 e4             	pushl  -0x1c(%ebp)
c00074d8:	e8 75 e7 ff ff       	call   c0005c52 <ide_read>
c00074dd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:470
					if (sb_buf->magic == 0x19590318) {
c00074e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00074e3:	8b 00                	mov    (%eax),%eax
c00074e5:	3d 18 03 59 19       	cmp    $0x19590318,%eax
c00074ea:	75 19                	jne    c0007505 <filesys_init+0x113>
/work/x86_os_my/fs/fs.c:471
						printk("%s has filesystem\n", part->name);
c00074ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00074ef:	83 c0 14             	add    $0x14,%eax
c00074f2:	83 ec 08             	sub    $0x8,%esp
c00074f5:	50                   	push   %eax
c00074f6:	68 a4 9b 00 c0       	push   $0xc0009ba4
c00074fb:	e8 cb f1 ff ff       	call   c00066cb <printk>
c0007500:	83 c4 10             	add    $0x10,%esp
c0007503:	eb 29                	jmp    c000752e <filesys_init+0x13c>
/work/x86_os_my/fs/fs.c:474
					} else {
						// 不存在我们的文件系统，则进行格式化
						printk("formatting %s`s partition %s......\n", hd->name, part->name);
c0007505:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0007508:	8d 50 14             	lea    0x14(%eax),%edx
c000750b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000750e:	83 ec 04             	sub    $0x4,%esp
c0007511:	52                   	push   %edx
c0007512:	50                   	push   %eax
c0007513:	68 b8 9b 00 c0       	push   $0xc0009bb8
c0007518:	e8 ae f1 ff ff       	call   c00066cb <printk>
c000751d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:475
						partition_format(part);
c0007520:	83 ec 0c             	sub    $0xc,%esp
c0007523:	ff 75 f0             	pushl  -0x10(%ebp)
c0007526:	e8 07 f4 ff ff       	call   c0006932 <partition_format>
c000752b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:478
					}
				}
				part_idx++;
c000752e:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
c0007532:	83 c0 01             	add    $0x1,%eax
c0007535:	88 45 f5             	mov    %al,-0xb(%ebp)
/work/x86_os_my/fs/fs.c:479
				part++;
c0007538:	83 45 f0 40          	addl   $0x40,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:458
				continue;
			}
			struct disk* hd = &channels[channel_no].devices[dev_no];
			struct partition* part = hd->prim_parts;	// 主分区数组
			/* 遍历硬盘里的分区 */
			while(part_idx < 12) {						// 4个主分区+8个逻辑
c000753c:	80 7d f5 0b          	cmpb   $0xb,-0xb(%ebp)
c0007540:	0f 86 51 ff ff ff    	jbe    c0007497 <filesys_init+0xa5>
/work/x86_os_my/fs/fs.c:481
					}
				}
				part_idx++;
				part++;
			}	/* end of 遍历分区 */
			dev_no++;
c0007546:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c000754a:	83 c0 01             	add    $0x1,%eax
c000754d:	88 45 f6             	mov    %al,-0xa(%ebp)
/work/x86_os_my/fs/fs.c:450
	printk("searching filesystem......\n");
	/* 遍历通道 */
	while (channel_no < channel_cnt) {
		dev_no = 0;
		/* 遍历通道里的硬盘 */
		while(dev_no < 2) {
c0007550:	80 7d f6 01          	cmpb   $0x1,-0xa(%ebp)
c0007554:	0f 86 f9 fe ff ff    	jbe    c0007453 <filesys_init+0x61>
/work/x86_os_my/fs/fs.c:483
				part_idx++;
				part++;
			}	/* end of 遍历分区 */
			dev_no++;
		}	/* end of 遍历硬盘 */
		channel_no++;
c000755a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000755e:	83 c0 01             	add    $0x1,%eax
c0007561:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:447
		PANIC("alloc memory failed!");
	}

	printk("searching filesystem......\n");
	/* 遍历通道 */
	while (channel_no < channel_cnt) {
c0007564:	0f b6 05 e0 cc 00 c0 	movzbl 0xc000cce0,%eax
c000756b:	38 45 f7             	cmp    %al,-0x9(%ebp)
c000756e:	0f 82 d6 fe ff ff    	jb     c000744a <filesys_init+0x58>
/work/x86_os_my/fs/fs.c:485
			}	/* end of 遍历分区 */
			dev_no++;
		}	/* end of 遍历硬盘 */
		channel_no++;
	}	/* end of 遍历通道 */
	sys_free(sb_buf);
c0007574:	83 ec 0c             	sub    $0xc,%esp
c0007577:	ff 75 e8             	pushl  -0x18(%ebp)
c000757a:	e8 01 c0 ff ff       	call   c0003580 <sys_free>
c000757f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:490


	/* 挂载分区 */
	/* 默认操作的分区 */
	char default_part[8] = "sdb1";
c0007582:	c7 45 dc 73 64 62 31 	movl   $0x31626473,-0x24(%ebp)
c0007589:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
/work/x86_os_my/fs/fs.c:501
	参数：
	partition_list 是所有分区的链表
	mount_partition 是挂载分区的函数
	(int)default_part 将数组地址转换成整型作为 mount_partition 的参数
	*/
	list_traversal(&partition_list, mount_partition, (int)default_part);
c0007590:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0007593:	83 ec 04             	sub    $0x4,%esp
c0007596:	50                   	push   %eax
c0007597:	68 27 67 00 c0       	push   $0xc0006727
c000759c:	68 c0 d9 00 c0       	push   $0xc000d9c0
c00075a1:	e8 a8 d0 ff ff       	call   c000464e <list_traversal>
c00075a6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:505


	/* 将当前分区的根目录打开 + 初始化文件表 */
	open_root_dir(cur_part);
c00075a9:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c00075ae:	83 ec 0c             	sub    $0xc,%esp
c00075b1:	50                   	push   %eax
c00075b2:	e8 0c 0a 00 00       	call   c0007fc3 <open_root_dir>
c00075b7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:506
	uint32_t fd_idx = 0;
c00075ba:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:507
	while (fd_idx < MAX_FILE_OPEN) {
c00075c1:	eb 1d                	jmp    c00075e0 <filesys_init+0x1ee>
/work/x86_os_my/fs/fs.c:508
		file_table[fd_idx++].fd_inode = NULL;
c00075c3:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00075c6:	8d 42 01             	lea    0x1(%edx),%eax
c00075c9:	89 45 ec             	mov    %eax,-0x14(%ebp)
c00075cc:	89 d0                	mov    %edx,%eax
c00075ce:	01 c0                	add    %eax,%eax
c00075d0:	01 d0                	add    %edx,%eax
c00075d2:	c1 e0 02             	shl    $0x2,%eax
c00075d5:	05 e8 d9 00 c0       	add    $0xc000d9e8,%eax
c00075da:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:507


	/* 将当前分区的根目录打开 + 初始化文件表 */
	open_root_dir(cur_part);
	uint32_t fd_idx = 0;
	while (fd_idx < MAX_FILE_OPEN) {
c00075e0:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
c00075e4:	76 dd                	jbe    c00075c3 <filesys_init+0x1d1>
/work/x86_os_my/fs/fs.c:510
		file_table[fd_idx++].fd_inode = NULL;
	}
}
c00075e6:	90                   	nop
c00075e7:	c9                   	leave  
c00075e8:	c3                   	ret    

c00075e9 <inode_locate>:
inode_locate():
/work/x86_os_my/fs/inode.c:23
};

/* 获取inode所在的扇区和扇区内的偏移量
 * out: inode_pos
 */
static void inode_locate(struct partition* part, uint32_t inode_no, struct inode_position* inode_pos) {
c00075e9:	55                   	push   %ebp
c00075ea:	89 e5                	mov    %esp,%ebp
c00075ec:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/fs/inode.c:25
	/* inode_table在硬盘上是连续的 */
	ASSERT(inode_no < 4096);
c00075ef:	81 7d 0c ff 0f 00 00 	cmpl   $0xfff,0xc(%ebp)
c00075f6:	76 19                	jbe    c0007611 <inode_locate+0x28>
/work/x86_os_my/fs/inode.c:25 (discriminator 1)
c00075f8:	68 34 9c 00 c0       	push   $0xc0009c34
c00075fd:	68 88 9c 00 c0       	push   $0xc0009c88
c0007602:	6a 19                	push   $0x19
c0007604:	68 44 9c 00 c0       	push   $0xc0009c44
c0007609:	e8 24 b0 ff ff       	call   c0002632 <panic_spin>
c000760e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:26
	uint32_t inode_table_lba = part->sb->inode_table_lba;
c0007611:	8b 45 08             	mov    0x8(%ebp),%eax
c0007614:	8b 40 1c             	mov    0x1c(%eax),%eax
c0007617:	8b 40 20             	mov    0x20(%eax),%eax
c000761a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/inode.c:28

	uint32_t inode_size = sizeof(struct inode);
c000761d:	c7 45 f0 4c 00 00 00 	movl   $0x4c,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:29
	uint32_t off_size = inode_no * inode_size;	// 第inode_no号inode相对于inode_table_lba的字节偏移量
c0007624:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007627:	0f af 45 f0          	imul   -0x10(%ebp),%eax
c000762b:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:30
	uint32_t off_sec  = off_size / 512;			// 第inode_no号inode相对于inode_table_lba的扇区偏移量
c000762e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0007631:	c1 e8 09             	shr    $0x9,%eax
c0007634:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/inode.c:31
	uint32_t off_size_in_sec = off_size % 512;	// 待查找的inode所在扇区中的起始地址
c0007637:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000763a:	25 ff 01 00 00       	and    $0x1ff,%eax
c000763f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/inode.c:34

	/* 判断此inode是否跨越2个扇区 */
	uint32_t left_in_sec = 512 - off_size_in_sec;
c0007642:	b8 00 02 00 00       	mov    $0x200,%eax
c0007647:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c000764a:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/inode.c:36
	// 若扇区内剩下的空间不足以容纳一个inode,必然是inode跨越了2个扇区
	if (left_in_sec < inode_size ) {
c000764d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0007650:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0007653:	73 0b                	jae    c0007660 <inode_locate+0x77>
/work/x86_os_my/fs/inode.c:37
		inode_pos->two_sec = true;	//跨越了
c0007655:	8b 45 10             	mov    0x10(%ebp),%eax
c0007658:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
c000765e:	eb 09                	jmp    c0007669 <inode_locate+0x80>
/work/x86_os_my/fs/inode.c:39
	} else {
		inode_pos->two_sec = false;
c0007660:	8b 45 10             	mov    0x10(%ebp),%eax
c0007663:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/inode.c:41
	}
	inode_pos->sec_lba = inode_table_lba + off_sec;
c0007669:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000766c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000766f:	01 c2                	add    %eax,%edx
c0007671:	8b 45 10             	mov    0x10(%ebp),%eax
c0007674:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/inode.c:42
	inode_pos->off_size = off_size_in_sec;
c0007677:	8b 45 10             	mov    0x10(%ebp),%eax
c000767a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000767d:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/fs/inode.c:43
}
c0007680:	90                   	nop
c0007681:	c9                   	leave  
c0007682:	c3                   	ret    

c0007683 <inode_sync>:
inode_sync():
/work/x86_os_my/fs/inode.c:51
io_buf是用于硬盘io的缓冲区，它由主调函数提供！
原因是
一般情况下把内存中的数据同步到硬盘都是最后的操作，其前已经做了大量工作，
若到这最后一步时才申请内存失败，前面的所有操作都白费了，还要回滚到之前的旧状态，代价太大
*/
void inode_sync(struct partition* part, struct inode* inode, void* io_buf) {
c0007683:	55                   	push   %ebp
c0007684:	89 e5                	mov    %esp,%ebp
c0007686:	83 ec 68             	sub    $0x68,%esp
/work/x86_os_my/fs/inode.c:52
	uint8_t inode_no = inode->i_no;
c0007689:	8b 45 0c             	mov    0xc(%ebp),%eax
c000768c:	8b 00                	mov    (%eax),%eax
c000768e:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/inode.c:54
	struct inode_position inode_pos;
	inode_locate(part, inode_no, &inode_pos);	// inode位置信息会存入inode_pos
c0007691:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0007695:	83 ec 04             	sub    $0x4,%esp
c0007698:	8d 55 e4             	lea    -0x1c(%ebp),%edx
c000769b:	52                   	push   %edx
c000769c:	50                   	push   %eax
c000769d:	ff 75 08             	pushl  0x8(%ebp)
c00076a0:	e8 44 ff ff ff       	call   c00075e9 <inode_locate>
c00076a5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:55
	ASSERT(inode_pos.sec_lba <= (part->start_lba + part->sec_cnt));
c00076a8:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00076ab:	8b 45 08             	mov    0x8(%ebp),%eax
c00076ae:	8b 08                	mov    (%eax),%ecx
c00076b0:	8b 45 08             	mov    0x8(%ebp),%eax
c00076b3:	8b 40 04             	mov    0x4(%eax),%eax
c00076b6:	01 c8                	add    %ecx,%eax
c00076b8:	39 c2                	cmp    %eax,%edx
c00076ba:	76 19                	jbe    c00076d5 <inode_sync+0x52>
/work/x86_os_my/fs/inode.c:55 (discriminator 1)
c00076bc:	68 50 9c 00 c0       	push   $0xc0009c50
c00076c1:	68 98 9c 00 c0       	push   $0xc0009c98
c00076c6:	6a 37                	push   $0x37
c00076c8:	68 44 9c 00 c0       	push   $0xc0009c44
c00076cd:	e8 60 af ff ff       	call   c0002632 <panic_spin>
c00076d2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:62
	/* 硬盘中的inode中的成员inode_tag和i_open_cnts是不需要的，
	* 它们只在内存中有效，记录链表位置和被多少进程共享，
	* 将inode同步到硬盘时,清掉这三项即可。
	*/
	struct inode pure_inode;
	memcpy(&pure_inode, inode, sizeof(struct inode));
c00076d5:	83 ec 04             	sub    $0x4,%esp
c00076d8:	6a 4c                	push   $0x4c
c00076da:	ff 75 0c             	pushl  0xc(%ebp)
c00076dd:	8d 45 98             	lea    -0x68(%ebp),%eax
c00076e0:	50                   	push   %eax
c00076e1:	e8 b6 c3 ff ff       	call   c0003a9c <memcpy>
c00076e6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:63
	pure_inode.i_open_cnts = 0;
c00076e9:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
/work/x86_os_my/fs/inode.c:64
	pure_inode.write_deny = false;	// 置为false,以保证在硬盘中读出时为可写
c00076f0:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
/work/x86_os_my/fs/inode.c:65
	pure_inode.inode_tag.prev = pure_inode.inode_tag.next = NULL;
c00076f7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c00076fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0007701:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/inode.c:67

	char* inode_buf = (char*)io_buf;
c0007704:	8b 45 10             	mov    0x10(%ebp),%eax
c0007707:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:69
	// 若inode结构，跨了两个扇区,就要读出两个扇区再写入两个扇区
	if (inode_pos.two_sec) {
c000770a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000770d:	85 c0                	test   %eax,%eax
c000770f:	74 4c                	je     c000775d <inode_sync+0xda>
/work/x86_os_my/fs/inode.c:72
		/* 读写硬盘是以扇区为单位的
		所以需要将待写入的inode结构拼入到这2个扇区的中间位置 */
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 2);	// inode_table在格式化时，写入硬盘是连续写入的，所以读入2块扇区
c0007711:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0007714:	8b 45 08             	mov    0x8(%ebp),%eax
c0007717:	8b 40 08             	mov    0x8(%eax),%eax
c000771a:	6a 02                	push   $0x2
c000771c:	ff 75 f0             	pushl  -0x10(%ebp)
c000771f:	52                   	push   %edx
c0007720:	50                   	push   %eax
c0007721:	e8 2c e5 ff ff       	call   c0005c52 <ide_read>
c0007726:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:73
		memcpy((inode_buf + inode_pos.off_size), &pure_inode, sizeof(struct inode));	// inode_buf+inode在扇区中的偏移
c0007729:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000772c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000772f:	01 c2                	add    %eax,%edx
c0007731:	83 ec 04             	sub    $0x4,%esp
c0007734:	6a 4c                	push   $0x4c
c0007736:	8d 45 98             	lea    -0x68(%ebp),%eax
c0007739:	50                   	push   %eax
c000773a:	52                   	push   %edx
c000773b:	e8 5c c3 ff ff       	call   c0003a9c <memcpy>
c0007740:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:74
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
c0007743:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0007746:	8b 45 08             	mov    0x8(%ebp),%eax
c0007749:	8b 40 08             	mov    0x8(%eax),%eax
c000774c:	6a 02                	push   $0x2
c000774e:	ff 75 f0             	pushl  -0x10(%ebp)
c0007751:	52                   	push   %edx
c0007752:	50                   	push   %eax
c0007753:	e8 6e e6 ff ff       	call   c0005dc6 <ide_write>
c0007758:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:81
		// 若inode结构，只在一个扇区中
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
		memcpy((inode_buf + inode_pos.off_size), &pure_inode, sizeof(struct inode));	// inode_buf+inode在扇区中的偏移
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
	}
}
c000775b:	eb 4a                	jmp    c00077a7 <inode_sync+0x124>
/work/x86_os_my/fs/inode.c:77
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 2);	// inode_table在格式化时，写入硬盘是连续写入的，所以读入2块扇区
		memcpy((inode_buf + inode_pos.off_size), &pure_inode, sizeof(struct inode));	// inode_buf+inode在扇区中的偏移
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
	} else {
		// 若inode结构，只在一个扇区中
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
c000775d:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0007760:	8b 45 08             	mov    0x8(%ebp),%eax
c0007763:	8b 40 08             	mov    0x8(%eax),%eax
c0007766:	6a 01                	push   $0x1
c0007768:	ff 75 f0             	pushl  -0x10(%ebp)
c000776b:	52                   	push   %edx
c000776c:	50                   	push   %eax
c000776d:	e8 e0 e4 ff ff       	call   c0005c52 <ide_read>
c0007772:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:78
		memcpy((inode_buf + inode_pos.off_size), &pure_inode, sizeof(struct inode));	// inode_buf+inode在扇区中的偏移
c0007775:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0007778:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000777b:	01 c2                	add    %eax,%edx
c000777d:	83 ec 04             	sub    $0x4,%esp
c0007780:	6a 4c                	push   $0x4c
c0007782:	8d 45 98             	lea    -0x68(%ebp),%eax
c0007785:	50                   	push   %eax
c0007786:	52                   	push   %edx
c0007787:	e8 10 c3 ff ff       	call   c0003a9c <memcpy>
c000778c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:79
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
c000778f:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0007792:	8b 45 08             	mov    0x8(%ebp),%eax
c0007795:	8b 40 08             	mov    0x8(%eax),%eax
c0007798:	6a 01                	push   $0x1
c000779a:	ff 75 f0             	pushl  -0x10(%ebp)
c000779d:	52                   	push   %edx
c000779e:	50                   	push   %eax
c000779f:	e8 22 e6 ff ff       	call   c0005dc6 <ide_write>
c00077a4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:81
	}
}
c00077a7:	90                   	nop
c00077a8:	c9                   	leave  
c00077a9:	c3                   	ret    

c00077aa <inode_open>:
inode_open():
/work/x86_os_my/fs/inode.c:84

/* 根据i结点号，获取到相应的inode结构，插入到inode缓存队列，并返回它 */
struct inode* inode_open(struct partition* part, uint32_t inode_no) {
c00077aa:	55                   	push   %ebp
c00077ab:	89 e5                	mov    %esp,%ebp
c00077ad:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/fs/inode.c:86
	/* 1.先在已打开inode链表中找inode，此链表作用是提速 */
	struct list_elem* elem = part->open_inodes.head.next;
c00077b0:	8b 45 08             	mov    0x8(%ebp),%eax
c00077b3:	8b 40 34             	mov    0x34(%eax),%eax
c00077b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/inode.c:88
	struct inode* inode_found;
	while (elem != &part->open_inodes.tail) {
c00077b9:	eb 33                	jmp    c00077ee <inode_open+0x44>
/work/x86_os_my/fs/inode.c:89
		inode_found = elem2entry(struct inode, inode_tag, elem);
c00077bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00077be:	83 e8 44             	sub    $0x44,%eax
c00077c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:90
		if (inode_found->i_no == inode_no) {
c00077c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00077c7:	8b 00                	mov    (%eax),%eax
c00077c9:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00077cc:	75 17                	jne    c00077e5 <inode_open+0x3b>
/work/x86_os_my/fs/inode.c:91
			inode_found->i_open_cnts++;
c00077ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00077d1:	8b 40 08             	mov    0x8(%eax),%eax
c00077d4:	8d 50 01             	lea    0x1(%eax),%edx
c00077d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00077da:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/fs/inode.c:92
			return inode_found;
c00077dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00077e0:	e9 09 01 00 00       	jmp    c00078ee <inode_open+0x144>
/work/x86_os_my/fs/inode.c:94
		}
		elem = elem->next;
c00077e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00077e8:	8b 40 04             	mov    0x4(%eax),%eax
c00077eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/inode.c:88
/* 根据i结点号，获取到相应的inode结构，插入到inode缓存队列，并返回它 */
struct inode* inode_open(struct partition* part, uint32_t inode_no) {
	/* 1.先在已打开inode链表中找inode，此链表作用是提速 */
	struct list_elem* elem = part->open_inodes.head.next;
	struct inode* inode_found;
	while (elem != &part->open_inodes.tail) {
c00077ee:	8b 45 08             	mov    0x8(%ebp),%eax
c00077f1:	83 c0 38             	add    $0x38,%eax
c00077f4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00077f7:	75 c2                	jne    c00077bb <inode_open+0x11>
/work/x86_os_my/fs/inode.c:100
	}

	
	/* 2.open_inodes链表中找不到，从硬盘上读入此inode并加入到inode缓存链表 */
	struct inode_position inode_pos;	// 记录inode位置的结构
	inode_locate(part, inode_no, &inode_pos);
c00077f9:	83 ec 04             	sub    $0x4,%esp
c00077fc:	8d 45 d8             	lea    -0x28(%ebp),%eax
c00077ff:	50                   	push   %eax
c0007800:	ff 75 0c             	pushl  0xc(%ebp)
c0007803:	ff 75 08             	pushl  0x8(%ebp)
c0007806:	e8 de fd ff ff       	call   c00075e9 <inode_locate>
c000780b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:104

	/* 为使通过sys_malloc创建的新inode被所有任务共享，需要将inode置于内核空间
	故临时将cur_pbc->pgdir置为NULL，sys_malloc就会以为是从内核空间分配 */
	struct task_struct* cur = running_thread();
c000780e:	e8 1e c6 ff ff       	call   c0003e31 <running_thread>
c0007813:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/inode.c:105
	uint32_t* cur_pagedir_bak = cur->pgdir;
c0007816:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0007819:	8b 40 54             	mov    0x54(%eax),%eax
c000781c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/inode.c:106
	cur->pgdir = NULL;
c000781f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0007822:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
/work/x86_os_my/fs/inode.c:107
	inode_found = (struct inode*)sys_malloc(sizeof(struct inode));
c0007829:	83 ec 0c             	sub    $0xc,%esp
c000782c:	6a 4c                	push   $0x4c
c000782e:	e8 20 b7 ff ff       	call   c0002f53 <sys_malloc>
c0007833:	83 c4 10             	add    $0x10,%esp
c0007836:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:108
	cur->pgdir = cur_pagedir_bak;	// 恢复pgdir
c0007839:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000783c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000783f:	89 50 54             	mov    %edx,0x54(%eax)
/work/x86_os_my/fs/inode.c:111

	char* inode_buf;
	if (inode_pos.two_sec) {	// inode结构跨扇区了
c0007842:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0007845:	85 c0                	test   %eax,%eax
c0007847:	74 2d                	je     c0007876 <inode_open+0xcc>
/work/x86_os_my/fs/inode.c:112
		inode_buf = (char*)sys_malloc(1024);
c0007849:	83 ec 0c             	sub    $0xc,%esp
c000784c:	68 00 04 00 00       	push   $0x400
c0007851:	e8 fd b6 ff ff       	call   c0002f53 <sys_malloc>
c0007856:	83 c4 10             	add    $0x10,%esp
c0007859:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:114
		// inode_table在格式化时，写入硬盘是连续写入的，所以可以连续读入2块扇区
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
c000785c:	8b 55 dc             	mov    -0x24(%ebp),%edx
c000785f:	8b 45 08             	mov    0x8(%ebp),%eax
c0007862:	8b 40 08             	mov    0x8(%eax),%eax
c0007865:	6a 02                	push   $0x2
c0007867:	ff 75 f0             	pushl  -0x10(%ebp)
c000786a:	52                   	push   %edx
c000786b:	50                   	push   %eax
c000786c:	e8 e1 e3 ff ff       	call   c0005c52 <ide_read>
c0007871:	83 c4 10             	add    $0x10,%esp
c0007874:	eb 2b                	jmp    c00078a1 <inode_open+0xf7>
/work/x86_os_my/fs/inode.c:116
	} else {
		inode_buf = (char*)sys_malloc(512);
c0007876:	83 ec 0c             	sub    $0xc,%esp
c0007879:	68 00 02 00 00       	push   $0x200
c000787e:	e8 d0 b6 ff ff       	call   c0002f53 <sys_malloc>
c0007883:	83 c4 10             	add    $0x10,%esp
c0007886:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:117
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
c0007889:	8b 55 dc             	mov    -0x24(%ebp),%edx
c000788c:	8b 45 08             	mov    0x8(%ebp),%eax
c000788f:	8b 40 08             	mov    0x8(%eax),%eax
c0007892:	6a 01                	push   $0x1
c0007894:	ff 75 f0             	pushl  -0x10(%ebp)
c0007897:	52                   	push   %edx
c0007898:	50                   	push   %eax
c0007899:	e8 b4 e3 ff ff       	call   c0005c52 <ide_read>
c000789e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:119
	}
	memcpy(inode_found, inode_buf + inode_pos.off_size, sizeof(struct inode));	// inode_buf+inode在扇区中的偏移
c00078a1:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00078a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00078a7:	01 d0                	add    %edx,%eax
c00078a9:	83 ec 04             	sub    $0x4,%esp
c00078ac:	6a 4c                	push   $0x4c
c00078ae:	50                   	push   %eax
c00078af:	ff 75 ec             	pushl  -0x14(%ebp)
c00078b2:	e8 e5 c1 ff ff       	call   c0003a9c <memcpy>
c00078b7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:123

	
	/* 3.马上要用这个inode，固插入到队首 */
	list_push(&part->open_inodes, &inode_found->inode_tag);
c00078ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00078bd:	8d 50 44             	lea    0x44(%eax),%edx
c00078c0:	8b 45 08             	mov    0x8(%ebp),%eax
c00078c3:	83 c0 30             	add    $0x30,%eax
c00078c6:	83 ec 08             	sub    $0x8,%esp
c00078c9:	52                   	push   %edx
c00078ca:	50                   	push   %eax
c00078cb:	e8 ab cc ff ff       	call   c000457b <list_push>
c00078d0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:124
	inode_found->i_open_cnts = 1;
c00078d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00078d6:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/fs/inode.c:126

	sys_free(inode_buf);
c00078dd:	83 ec 0c             	sub    $0xc,%esp
c00078e0:	ff 75 f0             	pushl  -0x10(%ebp)
c00078e3:	e8 98 bc ff ff       	call   c0003580 <sys_free>
c00078e8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:127
	return inode_found;
c00078eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/fs/inode.c:128 (discriminator 1)
}
c00078ee:	c9                   	leave  
c00078ef:	c3                   	ret    

c00078f0 <inode_close>:
inode_close():
/work/x86_os_my/fs/inode.c:132

/* 关闭inode或减少inode的打开数 */
//1.从inode队列踢掉 2.释放内核内存池中的这个inode内存
void inode_close(struct inode* inode) {
c00078f0:	55                   	push   %ebp
c00078f1:	89 e5                	mov    %esp,%ebp
c00078f3:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/inode.c:134
	/* 若没有进程再打开此文件,将此inode去掉并释放空间 */
	enum intr_status old_status = intr_disable();
c00078f6:	e8 98 a3 ff ff       	call   c0001c93 <intr_disable>
c00078fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/inode.c:135
	if (--inode->i_open_cnts == 0) {
c00078fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0007901:	8b 40 08             	mov    0x8(%eax),%eax
c0007904:	8d 50 ff             	lea    -0x1(%eax),%edx
c0007907:	8b 45 08             	mov    0x8(%ebp),%eax
c000790a:	89 50 08             	mov    %edx,0x8(%eax)
c000790d:	8b 45 08             	mov    0x8(%ebp),%eax
c0007910:	8b 40 08             	mov    0x8(%eax),%eax
c0007913:	85 c0                	test   %eax,%eax
c0007915:	75 44                	jne    c000795b <inode_close+0x6b>
/work/x86_os_my/fs/inode.c:136
		list_remove(&inode->inode_tag);
c0007917:	8b 45 08             	mov    0x8(%ebp),%eax
c000791a:	83 c0 44             	add    $0x44,%eax
c000791d:	83 ec 0c             	sub    $0xc,%esp
c0007920:	50                   	push   %eax
c0007921:	e8 91 cc ff ff       	call   c00045b7 <list_remove>
c0007926:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:139
		/* inode结构在内核空间，释放时要释放到内核内存池。
		pgdir为NULL时，sys_free认为是内核空间 */
		struct task_struct* cur = running_thread();
c0007929:	e8 03 c5 ff ff       	call   c0003e31 <running_thread>
c000792e:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:140
		uint32_t* cur_pagedir_bak = cur->pgdir;	// 进程自己页目录表的虚拟地址，加载到cr3时需转成物理地址
c0007931:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0007934:	8b 40 54             	mov    0x54(%eax),%eax
c0007937:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:141
		cur->pgdir = NULL;
c000793a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000793d:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
/work/x86_os_my/fs/inode.c:142
		sys_free(inode);
c0007944:	83 ec 0c             	sub    $0xc,%esp
c0007947:	ff 75 08             	pushl  0x8(%ebp)
c000794a:	e8 31 bc ff ff       	call   c0003580 <sys_free>
c000794f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:143
		cur->pgdir = cur_pagedir_bak;
c0007952:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0007955:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0007958:	89 50 54             	mov    %edx,0x54(%eax)
/work/x86_os_my/fs/inode.c:145
	}
	intr_set_status(old_status);
c000795b:	83 ec 0c             	sub    $0xc,%esp
c000795e:	ff 75 f4             	pushl  -0xc(%ebp)
c0007961:	e8 56 a3 ff ff       	call   c0001cbc <intr_set_status>
c0007966:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:146
}
c0007969:	90                   	nop
c000796a:	c9                   	leave  
c000796b:	c3                   	ret    

c000796c <inode_init>:
inode_init():
/work/x86_os_my/fs/inode.c:149

/* 初始化一个inode结构，inode号是inode_no */
void inode_init(uint32_t inode_no, struct inode* new_inode) {
c000796c:	55                   	push   %ebp
c000796d:	89 e5                	mov    %esp,%ebp
c000796f:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/fs/inode.c:150
	new_inode->i_no = inode_no;
c0007972:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007975:	8b 55 08             	mov    0x8(%ebp),%edx
c0007978:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/inode.c:151
	new_inode->i_size = 0;
c000797a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000797d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
/work/x86_os_my/fs/inode.c:152
	new_inode->i_open_cnts = 0;
c0007984:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007987:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/fs/inode.c:153
	new_inode->write_deny = false;
c000798e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007991:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/fs/inode.c:156

	/* 初始化块索引数组i_sector */
	uint8_t sec_idx = 0;
c0007998:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
/work/x86_os_my/fs/inode.c:157
	while (sec_idx < 13) {
c000799c:	eb 1b                	jmp    c00079b9 <inode_init+0x4d>
/work/x86_os_my/fs/inode.c:159
		/* i_sectors[12]为一级间接块地址 */
		new_inode->i_sectors[sec_idx] = 0;
c000799e:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c00079a2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00079a5:	83 c2 04             	add    $0x4,%edx
c00079a8:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
/work/x86_os_my/fs/inode.c:160
		sec_idx++;
c00079af:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c00079b3:	83 c0 01             	add    $0x1,%eax
c00079b6:	88 45 ff             	mov    %al,-0x1(%ebp)
/work/x86_os_my/fs/inode.c:157
	new_inode->i_open_cnts = 0;
	new_inode->write_deny = false;

	/* 初始化块索引数组i_sector */
	uint8_t sec_idx = 0;
	while (sec_idx < 13) {
c00079b9:	80 7d ff 0c          	cmpb   $0xc,-0x1(%ebp)
c00079bd:	76 df                	jbe    c000799e <inode_init+0x32>
/work/x86_os_my/fs/inode.c:165
		sec_idx++;
	}
	/*为什么不提前分配inode管理的数据块（对我们来说是块=扇区）
	1.不知道文件大小，因此不知道分配多少个扇区合适
	2.文件创建后未必马上会写数据*/
}
c00079bf:	90                   	nop
c00079c0:	c9                   	leave  
c00079c1:	c3                   	ret    

c00079c2 <get_free_slot_in_global>:
get_free_slot_in_global():
/work/x86_os_my/fs/file.c:19

/* 文件表 */
struct file file_table[MAX_FILE_OPEN];

/* 从文件表 file_table 中获取一个空闲位,成功返回下标,失败返回-1 */
int32_t get_free_slot_in_global(void) {
c00079c2:	55                   	push   %ebp
c00079c3:	89 e5                	mov    %esp,%ebp
c00079c5:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/file.c:20
	uint32_t fd_idx = 3;
c00079c8:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
/work/x86_os_my/fs/file.c:21
	while (fd_idx < MAX_FILE_OPEN) {
c00079cf:	eb 1b                	jmp    c00079ec <get_free_slot_in_global+0x2a>
/work/x86_os_my/fs/file.c:22
		if (file_table[fd_idx].fd_inode == NULL) {
c00079d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00079d4:	89 d0                	mov    %edx,%eax
c00079d6:	01 c0                	add    %eax,%eax
c00079d8:	01 d0                	add    %edx,%eax
c00079da:	c1 e0 02             	shl    $0x2,%eax
c00079dd:	05 e8 d9 00 c0       	add    $0xc000d9e8,%eax
c00079e2:	8b 00                	mov    (%eax),%eax
c00079e4:	85 c0                	test   %eax,%eax
c00079e6:	74 0c                	je     c00079f4 <get_free_slot_in_global+0x32>
/work/x86_os_my/fs/file.c:25
			break;
		}
		fd_idx++;
c00079e8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/file.c:21
struct file file_table[MAX_FILE_OPEN];

/* 从文件表 file_table 中获取一个空闲位,成功返回下标,失败返回-1 */
int32_t get_free_slot_in_global(void) {
	uint32_t fd_idx = 3;
	while (fd_idx < MAX_FILE_OPEN) {
c00079ec:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
c00079f0:	76 df                	jbe    c00079d1 <get_free_slot_in_global+0xf>
c00079f2:	eb 01                	jmp    c00079f5 <get_free_slot_in_global+0x33>
/work/x86_os_my/fs/file.c:23
		if (file_table[fd_idx].fd_inode == NULL) {
			break;
c00079f4:	90                   	nop
/work/x86_os_my/fs/file.c:27
		}
		fd_idx++;
	}
	if (fd_idx == MAX_FILE_OPEN) {
c00079f5:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
c00079f9:	75 17                	jne    c0007a12 <get_free_slot_in_global+0x50>
/work/x86_os_my/fs/file.c:28
		printk("exceed max open files\n");
c00079fb:	83 ec 0c             	sub    $0xc,%esp
c00079fe:	68 a4 9c 00 c0       	push   $0xc0009ca4
c0007a03:	e8 c3 ec ff ff       	call   c00066cb <printk>
c0007a08:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:29
		return -1;
c0007a0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007a10:	eb 03                	jmp    c0007a15 <get_free_slot_in_global+0x53>
/work/x86_os_my/fs/file.c:31
	}
	return fd_idx;
c0007a12:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/file.c:32
}
c0007a15:	c9                   	leave  
c0007a16:	c3                   	ret    

c0007a17 <pcb_fd_install>:
pcb_fd_install():
/work/x86_os_my/fs/file.c:36

/* 将 file_table 的下标，安装到，线程PCB中文件描述符数组 fd_table
 * 成功返回 fd_table 的下标（即文件描述符）,失败返回-1 */
int32_t pcb_fd_install(int32_t globa_fd_idx) {
c0007a17:	55                   	push   %ebp
c0007a18:	89 e5                	mov    %esp,%ebp
c0007a1a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/file.c:37
	struct task_struct* cur = running_thread();
c0007a1d:	e8 0f c4 ff ff       	call   c0003e31 <running_thread>
c0007a22:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:38
	uint8_t local_fd_idx = 3;	// 跨过stdin,stdout,stderr
c0007a25:	c6 45 f7 03          	movb   $0x3,-0x9(%ebp)
/work/x86_os_my/fs/file.c:39
	while (local_fd_idx < MAX_FILES_OPEN_PER_PROC) {
c0007a29:	eb 30                	jmp    c0007a5b <pcb_fd_install+0x44>
/work/x86_os_my/fs/file.c:40
		if (cur->fd_table[local_fd_idx] == -1) {	// -1表示free_slot,可用
c0007a2b:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0007a2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0007a32:	83 c2 08             	add    $0x8,%edx
c0007a35:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
c0007a39:	83 f8 ff             	cmp    $0xffffffff,%eax
c0007a3c:	75 13                	jne    c0007a51 <pcb_fd_install+0x3a>
/work/x86_os_my/fs/file.c:41
			cur->fd_table[local_fd_idx] = globa_fd_idx;
c0007a3e:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0007a42:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0007a45:	8d 4a 08             	lea    0x8(%edx),%ecx
c0007a48:	8b 55 08             	mov    0x8(%ebp),%edx
c0007a4b:	89 54 88 04          	mov    %edx,0x4(%eax,%ecx,4)
/work/x86_os_my/fs/file.c:42
			break;
c0007a4f:	eb 10                	jmp    c0007a61 <pcb_fd_install+0x4a>
/work/x86_os_my/fs/file.c:44
		}
		local_fd_idx++;
c0007a51:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0007a55:	83 c0 01             	add    $0x1,%eax
c0007a58:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/file.c:39
/* 将 file_table 的下标，安装到，线程PCB中文件描述符数组 fd_table
 * 成功返回 fd_table 的下标（即文件描述符）,失败返回-1 */
int32_t pcb_fd_install(int32_t globa_fd_idx) {
	struct task_struct* cur = running_thread();
	uint8_t local_fd_idx = 3;	// 跨过stdin,stdout,stderr
	while (local_fd_idx < MAX_FILES_OPEN_PER_PROC) {
c0007a5b:	80 7d f7 07          	cmpb   $0x7,-0x9(%ebp)
c0007a5f:	76 ca                	jbe    c0007a2b <pcb_fd_install+0x14>
/work/x86_os_my/fs/file.c:46
			cur->fd_table[local_fd_idx] = globa_fd_idx;
			break;
		}
		local_fd_idx++;
	}
	if (local_fd_idx == MAX_FILES_OPEN_PER_PROC) {
c0007a61:	80 7d f7 08          	cmpb   $0x8,-0x9(%ebp)
c0007a65:	75 17                	jne    c0007a7e <pcb_fd_install+0x67>
/work/x86_os_my/fs/file.c:47
		printk("exceed max open files_per_proc\n");
c0007a67:	83 ec 0c             	sub    $0xc,%esp
c0007a6a:	68 bc 9c 00 c0       	push   $0xc0009cbc
c0007a6f:	e8 57 ec ff ff       	call   c00066cb <printk>
c0007a74:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:48
		return -1;
c0007a77:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007a7c:	eb 04                	jmp    c0007a82 <pcb_fd_install+0x6b>
/work/x86_os_my/fs/file.c:50
	}
	return local_fd_idx;
c0007a7e:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
/work/x86_os_my/fs/file.c:51
}
c0007a82:	c9                   	leave  
c0007a83:	c3                   	ret    

c0007a84 <inode_bitmap_alloc>:
inode_bitmap_alloc():
/work/x86_os_my/fs/file.c:54

/* 从分区的inode位图中，分配一个i结点，返回"inode号" */
int32_t inode_bitmap_alloc(struct partition* part) {
c0007a84:	55                   	push   %ebp
c0007a85:	89 e5                	mov    %esp,%ebp
c0007a87:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/file.c:55
	int32_t bit_idx = bitmap_scan(&part->inode_bitmap, 1);
c0007a8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0007a8d:	83 c0 28             	add    $0x28,%eax
c0007a90:	83 ec 08             	sub    $0x8,%esp
c0007a93:	6a 01                	push   $0x1
c0007a95:	50                   	push   %eax
c0007a96:	e8 d0 ac ff ff       	call   c000276b <bitmap_scan>
c0007a9b:	83 c4 10             	add    $0x10,%esp
c0007a9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:56
	if (bit_idx == -1) {
c0007aa1:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0007aa5:	75 07                	jne    c0007aae <inode_bitmap_alloc+0x2a>
/work/x86_os_my/fs/file.c:57
		return -1;
c0007aa7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007aac:	eb 1b                	jmp    c0007ac9 <inode_bitmap_alloc+0x45>
/work/x86_os_my/fs/file.c:59
	}
	bitmap_set(&part->inode_bitmap, bit_idx, 1);
c0007aae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0007ab1:	8b 55 08             	mov    0x8(%ebp),%edx
c0007ab4:	83 c2 28             	add    $0x28,%edx
c0007ab7:	83 ec 04             	sub    $0x4,%esp
c0007aba:	6a 01                	push   $0x1
c0007abc:	50                   	push   %eax
c0007abd:	52                   	push   %edx
c0007abe:	e8 dd ad ff ff       	call   c00028a0 <bitmap_set>
c0007ac3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:60
	return bit_idx;
c0007ac6:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/file.c:61
}
c0007ac9:	c9                   	leave  
c0007aca:	c3                   	ret    

c0007acb <block_bitmap_alloc>:
block_bitmap_alloc():
/work/x86_os_my/fs/file.c:64
   
/* 从分区的block位图中，分配1个扇区，返回"扇区地址" */
int32_t block_bitmap_alloc(struct partition* part) {
c0007acb:	55                   	push   %ebp
c0007acc:	89 e5                	mov    %esp,%ebp
c0007ace:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/file.c:65
	int32_t bit_idx = bitmap_scan(&part->block_bitmap, 1);
c0007ad1:	8b 45 08             	mov    0x8(%ebp),%eax
c0007ad4:	83 c0 20             	add    $0x20,%eax
c0007ad7:	83 ec 08             	sub    $0x8,%esp
c0007ada:	6a 01                	push   $0x1
c0007adc:	50                   	push   %eax
c0007add:	e8 89 ac ff ff       	call   c000276b <bitmap_scan>
c0007ae2:	83 c4 10             	add    $0x10,%esp
c0007ae5:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:66
	if (bit_idx == -1) {
c0007ae8:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0007aec:	75 07                	jne    c0007af5 <block_bitmap_alloc+0x2a>
/work/x86_os_my/fs/file.c:67
		return -1;
c0007aee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007af3:	eb 26                	jmp    c0007b1b <block_bitmap_alloc+0x50>
/work/x86_os_my/fs/file.c:69
	}
	bitmap_set(&part->block_bitmap, bit_idx, 1);
c0007af5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0007af8:	8b 55 08             	mov    0x8(%ebp),%edx
c0007afb:	83 c2 20             	add    $0x20,%edx
c0007afe:	83 ec 04             	sub    $0x4,%esp
c0007b01:	6a 01                	push   $0x1
c0007b03:	50                   	push   %eax
c0007b04:	52                   	push   %edx
c0007b05:	e8 96 ad ff ff       	call   c00028a0 <bitmap_set>
c0007b0a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:71
	/* 和inode_bitmap_malloc不同,此处返回的不是位图索引,而是具体可用的扇区地址 */
	return (part->sb->data_start_lba + bit_idx);
c0007b0d:	8b 45 08             	mov    0x8(%ebp),%eax
c0007b10:	8b 40 1c             	mov    0x1c(%eax),%eax
c0007b13:	8b 50 28             	mov    0x28(%eax),%edx
c0007b16:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0007b19:	01 d0                	add    %edx,%eax
/work/x86_os_my/fs/file.c:72
} 
c0007b1b:	c9                   	leave  
c0007b1c:	c3                   	ret    

c0007b1d <bitmap_sync>:
bitmap_sync():
/work/x86_os_my/fs/file.c:76

/* 将内存中bitmap第bit_idx位所在的那个512字节，同步到硬盘中bitmap第bit_idx位所在的扇区 */
// 硬盘以扇区为读写单位
void bitmap_sync(struct partition* part, uint32_t bit_idx, uint8_t btmp_type) {
c0007b1d:	55                   	push   %ebp
c0007b1e:	89 e5                	mov    %esp,%ebp
c0007b20:	83 ec 28             	sub    $0x28,%esp
c0007b23:	8b 45 10             	mov    0x10(%ebp),%eax
c0007b26:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:77
	uint32_t off_sec = bit_idx / 4096;			// dst(硬盘中): bit_idx 相对于位图起始lba，在后边的第几个扇区(512*8=4096)
c0007b29:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007b2c:	c1 e8 0c             	shr    $0xc,%eax
c0007b2f:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:78
	uint32_t off_size = off_sec * BLOCK_SIZE;	// src(内存中): bit_idx 相对于位图数组bits，以512字节为单位，在后边的第几个单位处
c0007b32:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0007b35:	c1 e0 09             	shl    $0x9,%eax
c0007b38:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:84
												// off_size是，第 bit_idx位所在位图中以 512 字节为单位的起始地址。BLOCK_SIZE=512
	uint32_t sec_lba;
	uint8_t* bitmap_off;

	/* 需要被同步到硬盘的位图只有inode_bitmap和block_bitmap */
	switch (btmp_type) {
c0007b3b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0007b3f:	85 c0                	test   %eax,%eax
c0007b41:	74 07                	je     c0007b4a <bitmap_sync+0x2d>
c0007b43:	83 f8 01             	cmp    $0x1,%eax
c0007b46:	74 23                	je     c0007b6b <bitmap_sync+0x4e>
c0007b48:	eb 41                	jmp    c0007b8b <bitmap_sync+0x6e>
/work/x86_os_my/fs/file.c:86
		case INODE_BITMAP:
		sec_lba = part->sb->inode_bitmap_lba + off_sec;
c0007b4a:	8b 45 08             	mov    0x8(%ebp),%eax
c0007b4d:	8b 40 1c             	mov    0x1c(%eax),%eax
c0007b50:	8b 50 18             	mov    0x18(%eax),%edx
c0007b53:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0007b56:	01 d0                	add    %edx,%eax
c0007b58:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:87
		bitmap_off = part->inode_bitmap.bits + off_size;
c0007b5b:	8b 45 08             	mov    0x8(%ebp),%eax
c0007b5e:	8b 50 2c             	mov    0x2c(%eax),%edx
c0007b61:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0007b64:	01 d0                	add    %edx,%eax
c0007b66:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:88
		break;
c0007b69:	eb 20                	jmp    c0007b8b <bitmap_sync+0x6e>
/work/x86_os_my/fs/file.c:91

		case BLOCK_BITMAP: 
		sec_lba = part->sb->block_bitmap_lba + off_sec;
c0007b6b:	8b 45 08             	mov    0x8(%ebp),%eax
c0007b6e:	8b 40 1c             	mov    0x1c(%eax),%eax
c0007b71:	8b 50 10             	mov    0x10(%eax),%edx
c0007b74:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0007b77:	01 d0                	add    %edx,%eax
c0007b79:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:92
		bitmap_off = part->block_bitmap.bits + off_size;
c0007b7c:	8b 45 08             	mov    0x8(%ebp),%eax
c0007b7f:	8b 50 24             	mov    0x24(%eax),%edx
c0007b82:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0007b85:	01 d0                	add    %edx,%eax
c0007b87:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:93
		break;
c0007b8a:	90                   	nop
/work/x86_os_my/fs/file.c:95
	}
	ide_write(part->my_disk, sec_lba, bitmap_off, 1);	// 将bitmap_off中1个扇区的数据写入硬盘sec_lba处
c0007b8b:	8b 45 08             	mov    0x8(%ebp),%eax
c0007b8e:	8b 40 08             	mov    0x8(%eax),%eax
c0007b91:	6a 01                	push   $0x1
c0007b93:	ff 75 f0             	pushl  -0x10(%ebp)
c0007b96:	ff 75 f4             	pushl  -0xc(%ebp)
c0007b99:	50                   	push   %eax
c0007b9a:	e8 27 e2 ff ff       	call   c0005dc6 <ide_write>
c0007b9f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:96
}
c0007ba2:	90                   	nop
c0007ba3:	c9                   	leave  
c0007ba4:	c3                   	ret    

c0007ba5 <file_create>:
file_create():
/work/x86_os_my/fs/file.c:114
此新增加的文件对应的目录项，需要写入该目录的 inode->i_sectors[]中的某个扇区，
原有扇区可能已满，所以有可能要申请新扇区来存储目录项。【sync_dir_entry】
4. 若其中某步操作失败，需要回滚之前已成功的操作。
5. inode_bitmap、 block_bitmap、新文件的 inode 及文件所在目录的 inode，这些位于内存中已经被改变的数据要同步到硬盘。
*/
int32_t file_create(struct dir* parent_dir, char* filename, uint8_t flag) {
c0007ba5:	55                   	push   %ebp
c0007ba6:	89 e5                	mov    %esp,%ebp
c0007ba8:	83 ec 48             	sub    $0x48,%esp
c0007bab:	8b 45 10             	mov    0x10(%ebp),%eax
c0007bae:	88 45 c4             	mov    %al,-0x3c(%ebp)
/work/x86_os_my/fs/file.c:116
	/* 后续操作的公共缓冲区 */
	void* io_buf = sys_malloc(1024);	//跨扇区的数据，会操作2个扇区
c0007bb1:	83 ec 0c             	sub    $0xc,%esp
c0007bb4:	68 00 04 00 00       	push   $0x400
c0007bb9:	e8 95 b3 ff ff       	call   c0002f53 <sys_malloc>
c0007bbe:	83 c4 10             	add    $0x10,%esp
c0007bc1:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:117
	if (io_buf == NULL) {
c0007bc4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0007bc8:	75 1a                	jne    c0007be4 <file_create+0x3f>
/work/x86_os_my/fs/file.c:118
		printk("in file_creat: sys_malloc for io_buf failed\n");
c0007bca:	83 ec 0c             	sub    $0xc,%esp
c0007bcd:	68 dc 9c 00 c0       	push   $0xc0009cdc
c0007bd2:	e8 f4 ea ff ff       	call   c00066cb <printk>
c0007bd7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:119
		return -1;
c0007bda:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007bdf:	e9 81 02 00 00       	jmp    c0007e65 <file_create+0x2c0>
/work/x86_os_my/fs/file.c:122
	}

	uint8_t rollback_step = 0;	// 用于操作失败时回滚各资源状态
c0007be4:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/file.c:125

	/* 1.为新文件从分区inode位图中，分配inode号 */
	int32_t inode_no = inode_bitmap_alloc(cur_part); 
c0007be8:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c0007bed:	83 ec 0c             	sub    $0xc,%esp
c0007bf0:	50                   	push   %eax
c0007bf1:	e8 8e fe ff ff       	call   c0007a84 <inode_bitmap_alloc>
c0007bf6:	83 c4 10             	add    $0x10,%esp
c0007bf9:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:126
	if (inode_no == -1) {
c0007bfc:	83 7d e8 ff          	cmpl   $0xffffffff,-0x18(%ebp)
c0007c00:	75 1a                	jne    c0007c1c <file_create+0x77>
/work/x86_os_my/fs/file.c:127
		printk("in file_creat: allocate inode failed\n");
c0007c02:	83 ec 0c             	sub    $0xc,%esp
c0007c05:	68 0c 9d 00 c0       	push   $0xc0009d0c
c0007c0a:	e8 bc ea ff ff       	call   c00066cb <printk>
c0007c0f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:128
		return -1;
c0007c12:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007c17:	e9 49 02 00 00       	jmp    c0007e65 <file_create+0x2c0>
/work/x86_os_my/fs/file.c:133
	}

	/* 2.堆中分配inode节点，不可以是栈中的局部变量！
	 * 因为 file_table 中的 fd_inode 指针要指向它. */
	struct inode* new_file_inode = (struct inode*)sys_malloc(sizeof(struct inode)); 
c0007c1c:	83 ec 0c             	sub    $0xc,%esp
c0007c1f:	6a 4c                	push   $0x4c
c0007c21:	e8 2d b3 ff ff       	call   c0002f53 <sys_malloc>
c0007c26:	83 c4 10             	add    $0x10,%esp
c0007c29:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:134
	if (new_file_inode == NULL) {
c0007c2c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0007c30:	75 19                	jne    c0007c4b <file_create+0xa6>
/work/x86_os_my/fs/file.c:135
		printk("file_create: sys_malloc for inode failded\n");
c0007c32:	83 ec 0c             	sub    $0xc,%esp
c0007c35:	68 34 9d 00 c0       	push   $0xc0009d34
c0007c3a:	e8 8c ea ff ff       	call   c00066cb <printk>
c0007c3f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:136
		rollback_step = 1;
c0007c42:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
/work/x86_os_my/fs/file.c:137
		goto rollback;
c0007c46:	e9 a7 01 00 00       	jmp    c0007df2 <file_create+0x24d>
/work/x86_os_my/fs/file.c:139
	}
	inode_init(inode_no, new_file_inode);	    // 初始化inode
c0007c4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0007c4e:	83 ec 08             	sub    $0x8,%esp
c0007c51:	ff 75 e4             	pushl  -0x1c(%ebp)
c0007c54:	50                   	push   %eax
c0007c55:	e8 12 fd ff ff       	call   c000796c <inode_init>
c0007c5a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:142

	/* 3.申请一个file_table数组的下标 */
	int fd_idx = get_free_slot_in_global();
c0007c5d:	e8 60 fd ff ff       	call   c00079c2 <get_free_slot_in_global>
c0007c62:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:143
	if (fd_idx == -1) {
c0007c65:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0007c69:	75 19                	jne    c0007c84 <file_create+0xdf>
/work/x86_os_my/fs/file.c:144
		printk("exceed max open files\n");
c0007c6b:	83 ec 0c             	sub    $0xc,%esp
c0007c6e:	68 a4 9c 00 c0       	push   $0xc0009ca4
c0007c73:	e8 53 ea ff ff       	call   c00066cb <printk>
c0007c78:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:145
		rollback_step = 2;
c0007c7b:	c6 45 f7 02          	movb   $0x2,-0x9(%ebp)
/work/x86_os_my/fs/file.c:146
		goto rollback;
c0007c7f:	e9 6e 01 00 00       	jmp    c0007df2 <file_create+0x24d>
/work/x86_os_my/fs/file.c:150
	}

	// 4.填充文件表中的文件结构
	file_table[fd_idx].fd_inode = new_file_inode;
c0007c84:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007c87:	89 d0                	mov    %edx,%eax
c0007c89:	01 c0                	add    %eax,%eax
c0007c8b:	01 d0                	add    %edx,%eax
c0007c8d:	c1 e0 02             	shl    $0x2,%eax
c0007c90:	8d 90 e8 d9 00 c0    	lea    -0x3fff2618(%eax),%edx
c0007c96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0007c99:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/file.c:151
	file_table[fd_idx].fd_pos = 0;
c0007c9b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007c9e:	89 d0                	mov    %edx,%eax
c0007ca0:	01 c0                	add    %eax,%eax
c0007ca2:	01 d0                	add    %edx,%eax
c0007ca4:	c1 e0 02             	shl    $0x2,%eax
c0007ca7:	05 e0 d9 00 c0       	add    $0xc000d9e0,%eax
c0007cac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/file.c:152
	file_table[fd_idx].fd_flag = flag;
c0007cb2:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
c0007cb6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007cb9:	89 d0                	mov    %edx,%eax
c0007cbb:	01 c0                	add    %eax,%eax
c0007cbd:	01 d0                	add    %edx,%eax
c0007cbf:	c1 e0 02             	shl    $0x2,%eax
c0007cc2:	05 e4 d9 00 c0       	add    $0xc000d9e4,%eax
c0007cc7:	89 08                	mov    %ecx,(%eax)
/work/x86_os_my/fs/file.c:153
	file_table[fd_idx].fd_inode->write_deny = false;
c0007cc9:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007ccc:	89 d0                	mov    %edx,%eax
c0007cce:	01 c0                	add    %eax,%eax
c0007cd0:	01 d0                	add    %edx,%eax
c0007cd2:	c1 e0 02             	shl    $0x2,%eax
c0007cd5:	05 e8 d9 00 c0       	add    $0xc000d9e8,%eax
c0007cda:	8b 00                	mov    (%eax),%eax
c0007cdc:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/fs/file.c:156

	struct dir_entry new_dir_entry;
	memset(&new_dir_entry, 0, sizeof(struct dir_entry));
c0007ce3:	83 ec 04             	sub    $0x4,%esp
c0007ce6:	6a 18                	push   $0x18
c0007ce8:	6a 00                	push   $0x0
c0007cea:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0007ced:	50                   	push   %eax
c0007cee:	e8 57 bd ff ff       	call   c0003a4a <memset>
c0007cf3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:159

	// create_dir_entry在内存中初始化目录项p_de，只是内存操作不会返回失败
	create_dir_entry(filename, inode_no, FT_REGULAR, &new_dir_entry);
c0007cf6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0007cf9:	8d 55 cc             	lea    -0x34(%ebp),%edx
c0007cfc:	52                   	push   %edx
c0007cfd:	6a 01                	push   $0x1
c0007cff:	50                   	push   %eax
c0007d00:	ff 75 0c             	pushl  0xc(%ebp)
c0007d03:	e8 36 05 00 00       	call   c000823e <create_dir_entry>
c0007d08:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:164


	/* 同步内存数据到硬盘 */
	/* a 在目录parent_dir下安装目录项new_dir_entry, 写入硬盘后返回true, 否则false【dir.c】 */
	if (!sync_dir_entry(parent_dir, &new_dir_entry, io_buf)) {
c0007d0b:	83 ec 04             	sub    $0x4,%esp
c0007d0e:	ff 75 ec             	pushl  -0x14(%ebp)
c0007d11:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0007d14:	50                   	push   %eax
c0007d15:	ff 75 08             	pushl  0x8(%ebp)
c0007d18:	e8 92 05 00 00       	call   c00082af <sync_dir_entry>
c0007d1d:	83 c4 10             	add    $0x10,%esp
c0007d20:	85 c0                	test   %eax,%eax
c0007d22:	75 19                	jne    c0007d3d <file_create+0x198>
/work/x86_os_my/fs/file.c:165
		printk("sync dir_entry to disk failed\n");
c0007d24:	83 ec 0c             	sub    $0xc,%esp
c0007d27:	68 60 9d 00 c0       	push   $0xc0009d60
c0007d2c:	e8 9a e9 ff ff       	call   c00066cb <printk>
c0007d31:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:166
		rollback_step = 3;
c0007d34:	c6 45 f7 03          	movb   $0x3,-0x9(%ebp)
/work/x86_os_my/fs/file.c:167
		goto rollback;
c0007d38:	e9 b5 00 00 00       	jmp    c0007df2 <file_create+0x24d>
/work/x86_os_my/fs/file.c:171
	}

	/* b sync_dir_entry 会改变父目录 inode 中的信息，因此，将父目录inode的内容同步到硬盘【inode.c】 */
	memset(io_buf, 0, 1024);
c0007d3d:	83 ec 04             	sub    $0x4,%esp
c0007d40:	68 00 04 00 00       	push   $0x400
c0007d45:	6a 00                	push   $0x0
c0007d47:	ff 75 ec             	pushl  -0x14(%ebp)
c0007d4a:	e8 fb bc ff ff       	call   c0003a4a <memset>
c0007d4f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:172
	inode_sync(cur_part, parent_dir->inode, io_buf);
c0007d52:	8b 45 08             	mov    0x8(%ebp),%eax
c0007d55:	8b 10                	mov    (%eax),%edx
c0007d57:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c0007d5c:	83 ec 04             	sub    $0x4,%esp
c0007d5f:	ff 75 ec             	pushl  -0x14(%ebp)
c0007d62:	52                   	push   %edx
c0007d63:	50                   	push   %eax
c0007d64:	e8 1a f9 ff ff       	call   c0007683 <inode_sync>
c0007d69:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:175

	/* c 将新创建文件的inode内容同步到硬盘 */
	memset(io_buf, 0, 1024);
c0007d6c:	83 ec 04             	sub    $0x4,%esp
c0007d6f:	68 00 04 00 00       	push   $0x400
c0007d74:	6a 00                	push   $0x0
c0007d76:	ff 75 ec             	pushl  -0x14(%ebp)
c0007d79:	e8 cc bc ff ff       	call   c0003a4a <memset>
c0007d7e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:176
	inode_sync(cur_part, new_file_inode, io_buf);
c0007d81:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c0007d86:	83 ec 04             	sub    $0x4,%esp
c0007d89:	ff 75 ec             	pushl  -0x14(%ebp)
c0007d8c:	ff 75 e4             	pushl  -0x1c(%ebp)
c0007d8f:	50                   	push   %eax
c0007d90:	e8 ee f8 ff ff       	call   c0007683 <inode_sync>
c0007d95:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:179

	/* d 将inode_bitmap位图同步到硬盘【file.c】 */
	bitmap_sync(cur_part, inode_no, INODE_BITMAP);
c0007d98:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0007d9b:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c0007da0:	83 ec 04             	sub    $0x4,%esp
c0007da3:	6a 00                	push   $0x0
c0007da5:	52                   	push   %edx
c0007da6:	50                   	push   %eax
c0007da7:	e8 71 fd ff ff       	call   c0007b1d <bitmap_sync>
c0007dac:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:182

	/* e 将创建的文件i结点添加到open_inodes链表 */
	list_push(&cur_part->open_inodes, &new_file_inode->inode_tag);
c0007daf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0007db2:	8d 50 44             	lea    0x44(%eax),%edx
c0007db5:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c0007dba:	83 c0 30             	add    $0x30,%eax
c0007dbd:	83 ec 08             	sub    $0x8,%esp
c0007dc0:	52                   	push   %edx
c0007dc1:	50                   	push   %eax
c0007dc2:	e8 b4 c7 ff ff       	call   c000457b <list_push>
c0007dc7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:183
	new_file_inode->i_open_cnts = 1;
c0007dca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0007dcd:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/fs/file.c:186


	sys_free(io_buf);
c0007dd4:	83 ec 0c             	sub    $0xc,%esp
c0007dd7:	ff 75 ec             	pushl  -0x14(%ebp)
c0007dda:	e8 a1 b7 ff ff       	call   c0003580 <sys_free>
c0007ddf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:187
	return pcb_fd_install(fd_idx);	// 将 file_table 的下标，安装到，线程PCB中文件描述符数组 fd_table【file.c】
c0007de2:	83 ec 0c             	sub    $0xc,%esp
c0007de5:	ff 75 f0             	pushl  -0x10(%ebp)
c0007de8:	e8 2a fc ff ff       	call   c0007a17 <pcb_fd_install>
c0007ded:	83 c4 10             	add    $0x10,%esp
c0007df0:	eb 73                	jmp    c0007e65 <file_create+0x2c0>
/work/x86_os_my/fs/file.c:191


rollback:
	switch (rollback_step) {
c0007df2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0007df6:	83 f8 02             	cmp    $0x2,%eax
c0007df9:	74 2d                	je     c0007e28 <file_create+0x283>
c0007dfb:	83 f8 03             	cmp    $0x3,%eax
c0007dfe:	74 07                	je     c0007e07 <file_create+0x262>
c0007e00:	83 f8 01             	cmp    $0x1,%eax
c0007e03:	74 31                	je     c0007e36 <file_create+0x291>
c0007e05:	eb 4b                	jmp    c0007e52 <file_create+0x2ad>
/work/x86_os_my/fs/file.c:194
		case 3:
		/* file_table 相应位清空 */
		memset(&file_table[fd_idx], 0, sizeof(struct file)); 
c0007e07:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007e0a:	89 d0                	mov    %edx,%eax
c0007e0c:	01 c0                	add    %eax,%eax
c0007e0e:	01 d0                	add    %edx,%eax
c0007e10:	c1 e0 02             	shl    $0x2,%eax
c0007e13:	05 e0 d9 00 c0       	add    $0xc000d9e0,%eax
c0007e18:	83 ec 04             	sub    $0x4,%esp
c0007e1b:	6a 0c                	push   $0xc
c0007e1d:	6a 00                	push   $0x0
c0007e1f:	50                   	push   %eax
c0007e20:	e8 25 bc ff ff       	call   c0003a4a <memset>
c0007e25:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:196
		case 2:
		sys_free(new_file_inode);
c0007e28:	83 ec 0c             	sub    $0xc,%esp
c0007e2b:	ff 75 e4             	pushl  -0x1c(%ebp)
c0007e2e:	e8 4d b7 ff ff       	call   c0003580 <sys_free>
c0007e33:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:199
		case 1:
		/* inode位图 恢复 */
		bitmap_set(&cur_part->inode_bitmap, inode_no, 0);
c0007e36:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0007e39:	8b 15 d0 d9 00 c0    	mov    0xc000d9d0,%edx
c0007e3f:	83 c2 28             	add    $0x28,%edx
c0007e42:	83 ec 04             	sub    $0x4,%esp
c0007e45:	6a 00                	push   $0x0
c0007e47:	50                   	push   %eax
c0007e48:	52                   	push   %edx
c0007e49:	e8 52 aa ff ff       	call   c00028a0 <bitmap_set>
c0007e4e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:200
		break;
c0007e51:	90                   	nop
/work/x86_os_my/fs/file.c:202
	}
	sys_free(io_buf);
c0007e52:	83 ec 0c             	sub    $0xc,%esp
c0007e55:	ff 75 ec             	pushl  -0x14(%ebp)
c0007e58:	e8 23 b7 ff ff       	call   c0003580 <sys_free>
c0007e5d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:203
	return -1;
c0007e60:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/fs/file.c:204 (discriminator 1)
}
c0007e65:	c9                   	leave  
c0007e66:	c3                   	ret    

c0007e67 <file_open>:
file_open():
/work/x86_os_my/fs/file.c:207

/* 打开编号为inode_no的inode对应的文件,若成功则返回文件描述符,否则返回-1 */
int32_t file_open(uint32_t inode_no, uint8_t flag) {
c0007e67:	55                   	push   %ebp
c0007e68:	89 e5                	mov    %esp,%ebp
c0007e6a:	83 ec 28             	sub    $0x28,%esp
c0007e6d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007e70:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:208
	int fd_idx = get_free_slot_in_global();
c0007e73:	e8 4a fb ff ff       	call   c00079c2 <get_free_slot_in_global>
c0007e78:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:209
	if (fd_idx == -1) {
c0007e7b:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0007e7f:	75 1a                	jne    c0007e9b <file_open+0x34>
/work/x86_os_my/fs/file.c:210
		printk("exceed max open files\n");
c0007e81:	83 ec 0c             	sub    $0xc,%esp
c0007e84:	68 a4 9c 00 c0       	push   $0xc0009ca4
c0007e89:	e8 3d e8 ff ff       	call   c00066cb <printk>
c0007e8e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:211
		return -1;
c0007e91:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007e96:	e9 e3 00 00 00       	jmp    c0007f7e <file_open+0x117>
/work/x86_os_my/fs/file.c:213
	}
	file_table[fd_idx].fd_inode = inode_open(cur_part, inode_no);
c0007e9b:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c0007ea0:	83 ec 08             	sub    $0x8,%esp
c0007ea3:	ff 75 08             	pushl  0x8(%ebp)
c0007ea6:	50                   	push   %eax
c0007ea7:	e8 fe f8 ff ff       	call   c00077aa <inode_open>
c0007eac:	83 c4 10             	add    $0x10,%esp
c0007eaf:	89 c1                	mov    %eax,%ecx
c0007eb1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0007eb4:	89 d0                	mov    %edx,%eax
c0007eb6:	01 c0                	add    %eax,%eax
c0007eb8:	01 d0                	add    %edx,%eax
c0007eba:	c1 e0 02             	shl    $0x2,%eax
c0007ebd:	05 e8 d9 00 c0       	add    $0xc000d9e8,%eax
c0007ec2:	89 08                	mov    %ecx,(%eax)
/work/x86_os_my/fs/file.c:214
	file_table[fd_idx].fd_pos = 0;		// 每次打开文件,要将fd_pos还原为0,即让文件内的指针指向开头
c0007ec4:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0007ec7:	89 d0                	mov    %edx,%eax
c0007ec9:	01 c0                	add    %eax,%eax
c0007ecb:	01 d0                	add    %edx,%eax
c0007ecd:	c1 e0 02             	shl    $0x2,%eax
c0007ed0:	05 e0 d9 00 c0       	add    $0xc000d9e0,%eax
c0007ed5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/file.c:215
	file_table[fd_idx].fd_flag = flag;
c0007edb:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c0007edf:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0007ee2:	89 d0                	mov    %edx,%eax
c0007ee4:	01 c0                	add    %eax,%eax
c0007ee6:	01 d0                	add    %edx,%eax
c0007ee8:	c1 e0 02             	shl    $0x2,%eax
c0007eeb:	05 e4 d9 00 c0       	add    $0xc000d9e4,%eax
c0007ef0:	89 08                	mov    %ecx,(%eax)
/work/x86_os_my/fs/file.c:216
	bool* write_deny = &file_table[fd_idx].fd_inode->write_deny; 
c0007ef2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0007ef5:	89 d0                	mov    %edx,%eax
c0007ef7:	01 c0                	add    %eax,%eax
c0007ef9:	01 d0                	add    %edx,%eax
c0007efb:	c1 e0 02             	shl    $0x2,%eax
c0007efe:	05 e8 d9 00 c0       	add    $0xc000d9e8,%eax
c0007f03:	8b 00                	mov    (%eax),%eax
c0007f05:	83 c0 0c             	add    $0xc,%eax
c0007f08:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:218

	if (flag & O_WRONLY || flag & O_RDWR) {	// 要写文件,需要判断是否有其它进程正写此文件。创建文件、读文件不考虑write_deny。
c0007f0b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0007f0f:	83 e0 01             	and    $0x1,%eax
c0007f12:	85 c0                	test   %eax,%eax
c0007f14:	75 0b                	jne    c0007f21 <file_open+0xba>
/work/x86_os_my/fs/file.c:218 (discriminator 1)
c0007f16:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0007f1a:	83 e0 02             	and    $0x2,%eax
c0007f1d:	85 c0                	test   %eax,%eax
c0007f1f:	74 4f                	je     c0007f70 <file_open+0x109>
/work/x86_os_my/fs/file.c:220
		/* 以下进入临界区前先关中断 */
		enum intr_status old_status = intr_disable();
c0007f21:	e8 6d 9d ff ff       	call   c0001c93 <intr_disable>
c0007f26:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:221
		if (!(*write_deny)) {	// 若当前没有其它进程写该文件,将其占用.
c0007f29:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0007f2c:	8b 00                	mov    (%eax),%eax
c0007f2e:	85 c0                	test   %eax,%eax
c0007f30:	75 19                	jne    c0007f4b <file_open+0xe4>
/work/x86_os_my/fs/file.c:222
			*write_deny = true;
c0007f32:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0007f35:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
/work/x86_os_my/fs/file.c:223
			intr_set_status(old_status);
c0007f3b:	83 ec 0c             	sub    $0xc,%esp
c0007f3e:	ff 75 ec             	pushl  -0x14(%ebp)
c0007f41:	e8 76 9d ff ff       	call   c0001cbc <intr_set_status>
c0007f46:	83 c4 10             	add    $0x10,%esp
c0007f49:	eb 25                	jmp    c0007f70 <file_open+0x109>
/work/x86_os_my/fs/file.c:225
		} else {
			intr_set_status(old_status);
c0007f4b:	83 ec 0c             	sub    $0xc,%esp
c0007f4e:	ff 75 ec             	pushl  -0x14(%ebp)
c0007f51:	e8 66 9d ff ff       	call   c0001cbc <intr_set_status>
c0007f56:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:226
			printk("file can`t be write now, try again later\n");
c0007f59:	83 ec 0c             	sub    $0xc,%esp
c0007f5c:	68 80 9d 00 c0       	push   $0xc0009d80
c0007f61:	e8 65 e7 ff ff       	call   c00066cb <printk>
c0007f66:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:227
			return -1;
c0007f69:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007f6e:	eb 0e                	jmp    c0007f7e <file_open+0x117>
/work/x86_os_my/fs/file.c:230
		}
	}
	return pcb_fd_install(fd_idx);
c0007f70:	83 ec 0c             	sub    $0xc,%esp
c0007f73:	ff 75 f4             	pushl  -0xc(%ebp)
c0007f76:	e8 9c fa ff ff       	call   c0007a17 <pcb_fd_install>
c0007f7b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:231
}
c0007f7e:	c9                   	leave  
c0007f7f:	c3                   	ret    

c0007f80 <file_close>:
file_close():
/work/x86_os_my/fs/file.c:234

/* 关闭文件 */
int32_t file_close(struct file* file) {
c0007f80:	55                   	push   %ebp
c0007f81:	89 e5                	mov    %esp,%ebp
c0007f83:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/fs/file.c:235
	if (file == NULL) {
c0007f86:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0007f8a:	75 07                	jne    c0007f93 <file_close+0x13>
/work/x86_os_my/fs/file.c:236
		return -1;
c0007f8c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007f91:	eb 2e                	jmp    c0007fc1 <file_close+0x41>
/work/x86_os_my/fs/file.c:238
	}
	file->fd_inode->write_deny = false;
c0007f93:	8b 45 08             	mov    0x8(%ebp),%eax
c0007f96:	8b 40 08             	mov    0x8(%eax),%eax
c0007f99:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/fs/file.c:239
	inode_close(file->fd_inode);
c0007fa0:	8b 45 08             	mov    0x8(%ebp),%eax
c0007fa3:	8b 40 08             	mov    0x8(%eax),%eax
c0007fa6:	83 ec 0c             	sub    $0xc,%esp
c0007fa9:	50                   	push   %eax
c0007faa:	e8 41 f9 ff ff       	call   c00078f0 <inode_close>
c0007faf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:240
	file->fd_inode = NULL;   // 使文件结构可用
c0007fb2:	8b 45 08             	mov    0x8(%ebp),%eax
c0007fb5:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/fs/file.c:241
	return 0;
c0007fbc:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/file.c:242
}
c0007fc1:	c9                   	leave  
c0007fc2:	c3                   	ret    

c0007fc3 <open_root_dir>:
open_root_dir():
/work/x86_os_my/fs/dir.c:17
#include "super_block.h"

struct dir root_dir;	// 根目录

/* 打开根目录 */
void open_root_dir(struct partition* part) {
c0007fc3:	55                   	push   %ebp
c0007fc4:	89 e5                	mov    %esp,%ebp
c0007fc6:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/fs/dir.c:18
	root_dir.inode = inode_open(part, part->sb->root_inode_no);
c0007fc9:	8b 45 08             	mov    0x8(%ebp),%eax
c0007fcc:	8b 40 1c             	mov    0x1c(%eax),%eax
c0007fcf:	8b 40 2c             	mov    0x2c(%eax),%eax
c0007fd2:	83 ec 08             	sub    $0x8,%esp
c0007fd5:	50                   	push   %eax
c0007fd6:	ff 75 08             	pushl  0x8(%ebp)
c0007fd9:	e8 cc f7 ff ff       	call   c00077aa <inode_open>
c0007fde:	83 c4 10             	add    $0x10,%esp
c0007fe1:	a3 60 db 00 c0       	mov    %eax,0xc000db60
/work/x86_os_my/fs/dir.c:19
	root_dir.dir_pos = 0;
c0007fe6:	c7 05 64 db 00 c0 00 	movl   $0x0,0xc000db64
c0007fed:	00 00 00 
/work/x86_os_my/fs/dir.c:20
}
c0007ff0:	90                   	nop
c0007ff1:	c9                   	leave  
c0007ff2:	c3                   	ret    

c0007ff3 <dir_open>:
dir_open():
/work/x86_os_my/fs/dir.c:23

/* 在分区part上打开i结点为inode_no的目录，并返回目录指针 */
struct dir* dir_open(struct partition* part, uint32_t inode_no) {
c0007ff3:	55                   	push   %ebp
c0007ff4:	89 e5                	mov    %esp,%ebp
c0007ff6:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/dir.c:24
	struct dir* pdir = (struct dir*)sys_malloc(sizeof(struct dir));	//除根目录以外的其他目录，要分配内存
c0007ff9:	83 ec 0c             	sub    $0xc,%esp
c0007ffc:	68 08 02 00 00       	push   $0x208
c0008001:	e8 4d af ff ff       	call   c0002f53 <sys_malloc>
c0008006:	83 c4 10             	add    $0x10,%esp
c0008009:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:25
	pdir->inode = inode_open(part, inode_no);
c000800c:	83 ec 08             	sub    $0x8,%esp
c000800f:	ff 75 0c             	pushl  0xc(%ebp)
c0008012:	ff 75 08             	pushl  0x8(%ebp)
c0008015:	e8 90 f7 ff ff       	call   c00077aa <inode_open>
c000801a:	83 c4 10             	add    $0x10,%esp
c000801d:	89 c2                	mov    %eax,%edx
c000801f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0008022:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/dir.c:26
	pdir->dir_pos = 0;
c0008024:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0008027:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
/work/x86_os_my/fs/dir.c:27
	return pdir;
c000802e:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/dir.c:28
}
c0008031:	c9                   	leave  
c0008032:	c3                   	ret    

c0008033 <search_dir_entry>:
search_dir_entry():
/work/x86_os_my/fs/dir.c:32

/* 在part分区内的pdir目录内，寻找名为name的目录项，
 * 找到后返回true，并将其目录项存入dir_e；否则返回false */
bool search_dir_entry(struct partition* part, struct dir* pdir, const char* name, struct dir_entry* dir_e) {
c0008033:	55                   	push   %ebp
c0008034:	89 e5                	mov    %esp,%ebp
c0008036:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/fs/dir.c:34
	/* 1分配 */
	uint32_t block_cnt = 140;	 // 12个直接块+128个一级间接块 = 目录的inode管理的所有块 = 140块
c0008039:	c7 45 e8 8c 00 00 00 	movl   $0x8c,-0x18(%ebp)
/work/x86_os_my/fs/dir.c:39

	/* 12个直接块大小+128个间接块,共560字节（140个块，inode需要管理块的地址，每个4字节）
	注意: all_blocks 里面并没有一级间接表的地址，只有直接块+间接块的地址！
	用all_blocks检索inode管理的所有块地址 */
	uint32_t* all_blocks = (uint32_t*)sys_malloc(48 + 512);
c0008040:	83 ec 0c             	sub    $0xc,%esp
c0008043:	68 30 02 00 00       	push   $0x230
c0008048:	e8 06 af ff ff       	call   c0002f53 <sys_malloc>
c000804d:	83 c4 10             	add    $0x10,%esp
c0008050:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/dir.c:40
	if (all_blocks == NULL) {
c0008053:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0008057:	75 1a                	jne    c0008073 <search_dir_entry+0x40>
/work/x86_os_my/fs/dir.c:41
		printk("search_dir_entry: sys_malloc for all_blocks failed");
c0008059:	83 ec 0c             	sub    $0xc,%esp
c000805c:	68 ac 9d 00 c0       	push   $0xc0009dac
c0008061:	e8 65 e6 ff ff       	call   c00066cb <printk>
c0008066:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:42
		return false;
c0008069:	b8 00 00 00 00       	mov    $0x0,%eax
c000806e:	e9 96 01 00 00       	jmp    c0008209 <search_dir_entry+0x1d6>
/work/x86_os_my/fs/dir.c:45
	}

	uint32_t block_idx = 0;
c0008073:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:46
	while (block_idx < 12) {
c000807a:	eb 23                	jmp    c000809f <search_dir_entry+0x6c>
/work/x86_os_my/fs/dir.c:47
		all_blocks[block_idx] = pdir->inode->i_sectors[block_idx];
c000807c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000807f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0008086:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0008089:	01 c2                	add    %eax,%edx
c000808b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000808e:	8b 00                	mov    (%eax),%eax
c0008090:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0008093:	83 c1 04             	add    $0x4,%ecx
c0008096:	8b 04 88             	mov    (%eax,%ecx,4),%eax
c0008099:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/dir.c:48
		block_idx++;
c000809b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:46
		printk("search_dir_entry: sys_malloc for all_blocks failed");
		return false;
	}

	uint32_t block_idx = 0;
	while (block_idx < 12) {
c000809f:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
c00080a3:	76 d7                	jbe    c000807c <search_dir_entry+0x49>
/work/x86_os_my/fs/dir.c:50
		all_blocks[block_idx] = pdir->inode->i_sectors[block_idx];
		block_idx++;
	}
	block_idx = 0;
c00080a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:52

	if (pdir->inode->i_sectors[12] != 0) {	// i_sectors[12] != 0代表含有一级间接块表
c00080ac:	8b 45 0c             	mov    0xc(%ebp),%eax
c00080af:	8b 00                	mov    (%eax),%eax
c00080b1:	8b 40 40             	mov    0x40(%eax),%eax
c00080b4:	85 c0                	test   %eax,%eax
c00080b6:	74 21                	je     c00080d9 <search_dir_entry+0xa6>
/work/x86_os_my/fs/dir.c:54
		//从硬盘的扇区地址i_sectors[12]处获取 1 扇区数据，就是 128 个间接块的地址，将其复制到 all_blocks+12 处【复制的是整个一级间接表】
		ide_read(part->my_disk, pdir->inode->i_sectors[12], all_blocks + 12, 1);
c00080b8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00080bb:	8d 48 30             	lea    0x30(%eax),%ecx
c00080be:	8b 45 0c             	mov    0xc(%ebp),%eax
c00080c1:	8b 00                	mov    (%eax),%eax
c00080c3:	8b 50 40             	mov    0x40(%eax),%edx
c00080c6:	8b 45 08             	mov    0x8(%ebp),%eax
c00080c9:	8b 40 08             	mov    0x8(%eax),%eax
c00080cc:	6a 01                	push   $0x1
c00080ce:	51                   	push   %ecx
c00080cf:	52                   	push   %edx
c00080d0:	50                   	push   %eax
c00080d1:	e8 7c db ff ff       	call   c0005c52 <ide_read>
c00080d6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:62


	/* 2查找 */
	/* 写目录项的时候已保证目录项不跨扇区，这样读目录项时容易处理，只申请容纳1个扇区的内存
	 * 和处理inode_table不同，在往目录中写目录项的时候(sync_dir_entry)，避免了某个目录项 跨扇区的情况 */
	uint8_t* buf = (uint8_t*)sys_malloc(SECTOR_SIZE);
c00080d9:	83 ec 0c             	sub    $0xc,%esp
c00080dc:	68 00 02 00 00       	push   $0x200
c00080e1:	e8 6d ae ff ff       	call   c0002f53 <sys_malloc>
c00080e6:	83 c4 10             	add    $0x10,%esp
c00080e9:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:63
	struct dir_entry* p_de = (struct dir_entry*)buf;		// p_de为指向目录项的指针,值为buf起始地址
c00080ec:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00080ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:64
	uint32_t dir_entry_size = part->sb->dir_entry_size;
c00080f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00080f5:	8b 40 1c             	mov    0x1c(%eax),%eax
c00080f8:	8b 40 30             	mov    0x30(%eax),%eax
c00080fb:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:65
	uint32_t dir_entry_cnt = SECTOR_SIZE / dir_entry_size;	// 1扇区内可容纳的目录项个数
c00080fe:	b8 00 02 00 00       	mov    $0x200,%eax
c0008103:	ba 00 00 00 00       	mov    $0x0,%edx
c0008108:	f7 75 dc             	divl   -0x24(%ebp)
c000810b:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/dir.c:67
	/* 在所有块中查找目录项 */
	while (block_idx < block_cnt) {
c000810e:	e9 c9 00 00 00       	jmp    c00081dc <search_dir_entry+0x1a9>
/work/x86_os_my/fs/dir.c:69
		/* 块地址为0时表示该块中无数据,继续在其它块中找 */
		if (all_blocks[block_idx] == 0) {
c0008113:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0008116:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000811d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0008120:	01 d0                	add    %edx,%eax
c0008122:	8b 00                	mov    (%eax),%eax
c0008124:	85 c0                	test   %eax,%eax
c0008126:	75 09                	jne    c0008131 <search_dir_entry+0xfe>
/work/x86_os_my/fs/dir.c:70
			block_idx++;
c0008128:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:71
			continue;
c000812c:	e9 ab 00 00 00       	jmp    c00081dc <search_dir_entry+0x1a9>
/work/x86_os_my/fs/dir.c:73
		}
		ide_read(part->my_disk, all_blocks[block_idx], buf, 1);
c0008131:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0008134:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000813b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000813e:	01 d0                	add    %edx,%eax
c0008140:	8b 10                	mov    (%eax),%edx
c0008142:	8b 45 08             	mov    0x8(%ebp),%eax
c0008145:	8b 40 08             	mov    0x8(%eax),%eax
c0008148:	6a 01                	push   $0x1
c000814a:	ff 75 e0             	pushl  -0x20(%ebp)
c000814d:	52                   	push   %edx
c000814e:	50                   	push   %eax
c000814f:	e8 fe da ff ff       	call   c0005c52 <ide_read>
c0008154:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:75

		uint32_t dir_entry_idx = 0;
c0008157:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:77
		/* 遍历扇区中所有目录项 */
		while (dir_entry_idx < dir_entry_cnt) {
c000815e:	eb 55                	jmp    c00081b5 <search_dir_entry+0x182>
/work/x86_os_my/fs/dir.c:79
			/* 若找到了,就直接复制整个目录项 */
			if (!strcmp(p_de->filename, name)) {
c0008160:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0008163:	83 ec 08             	sub    $0x8,%esp
c0008166:	ff 75 10             	pushl  0x10(%ebp)
c0008169:	50                   	push   %eax
c000816a:	e8 b0 ba ff ff       	call   c0003c1f <strcmp>
c000816f:	83 c4 10             	add    $0x10,%esp
c0008172:	84 c0                	test   %al,%al
c0008174:	75 37                	jne    c00081ad <search_dir_entry+0x17a>
/work/x86_os_my/fs/dir.c:80
				memcpy(dir_e, p_de, dir_entry_size);
c0008176:	83 ec 04             	sub    $0x4,%esp
c0008179:	ff 75 dc             	pushl  -0x24(%ebp)
c000817c:	ff 75 f0             	pushl  -0x10(%ebp)
c000817f:	ff 75 14             	pushl  0x14(%ebp)
c0008182:	e8 15 b9 ff ff       	call   c0003a9c <memcpy>
c0008187:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:81
				sys_free(buf);
c000818a:	83 ec 0c             	sub    $0xc,%esp
c000818d:	ff 75 e0             	pushl  -0x20(%ebp)
c0008190:	e8 eb b3 ff ff       	call   c0003580 <sys_free>
c0008195:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:82
				sys_free(all_blocks);
c0008198:	83 ec 0c             	sub    $0xc,%esp
c000819b:	ff 75 e4             	pushl  -0x1c(%ebp)
c000819e:	e8 dd b3 ff ff       	call   c0003580 <sys_free>
c00081a3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:83
				return true;
c00081a6:	b8 01 00 00 00       	mov    $0x1,%eax
c00081ab:	eb 5c                	jmp    c0008209 <search_dir_entry+0x1d6>
/work/x86_os_my/fs/dir.c:85
			}
			dir_entry_idx++;
c00081ad:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:86
			p_de++;
c00081b1:	83 45 f0 18          	addl   $0x18,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:77
		}
		ide_read(part->my_disk, all_blocks[block_idx], buf, 1);

		uint32_t dir_entry_idx = 0;
		/* 遍历扇区中所有目录项 */
		while (dir_entry_idx < dir_entry_cnt) {
c00081b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00081b8:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c00081bb:	72 a3                	jb     c0008160 <search_dir_entry+0x12d>
/work/x86_os_my/fs/dir.c:89
			}
			dir_entry_idx++;
			p_de++;
		}

		block_idx++;					// 目录inode管理的下一个数据块（扇区）【目录里面是目录项，所以buf赋给p_de】
c00081bd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:90
		p_de = (struct dir_entry*)buf;	// p_de已经指向上一个扇区内，最后一个目录项，需要恢复p_de指向为buf
c00081c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00081c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:91
		memset(buf, 0, SECTOR_SIZE);	// 将buf清0,下次再用
c00081c7:	83 ec 04             	sub    $0x4,%esp
c00081ca:	68 00 02 00 00       	push   $0x200
c00081cf:	6a 00                	push   $0x0
c00081d1:	ff 75 e0             	pushl  -0x20(%ebp)
c00081d4:	e8 71 b8 ff ff       	call   c0003a4a <memset>
c00081d9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:67
	uint8_t* buf = (uint8_t*)sys_malloc(SECTOR_SIZE);
	struct dir_entry* p_de = (struct dir_entry*)buf;		// p_de为指向目录项的指针,值为buf起始地址
	uint32_t dir_entry_size = part->sb->dir_entry_size;
	uint32_t dir_entry_cnt = SECTOR_SIZE / dir_entry_size;	// 1扇区内可容纳的目录项个数
	/* 在所有块中查找目录项 */
	while (block_idx < block_cnt) {
c00081dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00081df:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c00081e2:	0f 82 2b ff ff ff    	jb     c0008113 <search_dir_entry+0xe0>
/work/x86_os_my/fs/dir.c:93

		block_idx++;					// 目录inode管理的下一个数据块（扇区）【目录里面是目录项，所以buf赋给p_de】
		p_de = (struct dir_entry*)buf;	// p_de已经指向上一个扇区内，最后一个目录项，需要恢复p_de指向为buf
		memset(buf, 0, SECTOR_SIZE);	// 将buf清0,下次再用
	}
	sys_free(buf);
c00081e8:	83 ec 0c             	sub    $0xc,%esp
c00081eb:	ff 75 e0             	pushl  -0x20(%ebp)
c00081ee:	e8 8d b3 ff ff       	call   c0003580 <sys_free>
c00081f3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:94
	sys_free(all_blocks);
c00081f6:	83 ec 0c             	sub    $0xc,%esp
c00081f9:	ff 75 e4             	pushl  -0x1c(%ebp)
c00081fc:	e8 7f b3 ff ff       	call   c0003580 <sys_free>
c0008201:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:95
	return false;
c0008204:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/dir.c:96
}
c0008209:	c9                   	leave  
c000820a:	c3                   	ret    

c000820b <dir_close>:
dir_close():
/work/x86_os_my/fs/dir.c:99

/* 关闭目录 */
void dir_close(struct dir* dir) {
c000820b:	55                   	push   %ebp
c000820c:	89 e5                	mov    %esp,%ebp
c000820e:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/fs/dir.c:103
	/*************      根目录不能关闭     ***************
	*1 根目录自打开后就不应该关闭,否则还需要再次open_root_dir();
	*2 root_dir所在的内存是低端1M之内,并非在堆中,free会出问题 */
	if (dir == &root_dir) {
c0008211:	81 7d 08 60 db 00 c0 	cmpl   $0xc000db60,0x8(%ebp)
c0008218:	74 21                	je     c000823b <dir_close+0x30>
/work/x86_os_my/fs/dir.c:106
		return;
	}
	inode_close(dir->inode);
c000821a:	8b 45 08             	mov    0x8(%ebp),%eax
c000821d:	8b 00                	mov    (%eax),%eax
c000821f:	83 ec 0c             	sub    $0xc,%esp
c0008222:	50                   	push   %eax
c0008223:	e8 c8 f6 ff ff       	call   c00078f0 <inode_close>
c0008228:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:107
	sys_free(dir);
c000822b:	83 ec 0c             	sub    $0xc,%esp
c000822e:	ff 75 08             	pushl  0x8(%ebp)
c0008231:	e8 4a b3 ff ff       	call   c0003580 <sys_free>
c0008236:	83 c4 10             	add    $0x10,%esp
c0008239:	eb 01                	jmp    c000823c <dir_close+0x31>
/work/x86_os_my/fs/dir.c:104
void dir_close(struct dir* dir) {
	/*************      根目录不能关闭     ***************
	*1 根目录自打开后就不应该关闭,否则还需要再次open_root_dir();
	*2 root_dir所在的内存是低端1M之内,并非在堆中,free会出问题 */
	if (dir == &root_dir) {
		return;
c000823b:	90                   	nop
/work/x86_os_my/fs/dir.c:108
	}
	inode_close(dir->inode);
	sys_free(dir);
}
c000823c:	c9                   	leave  
c000823d:	c3                   	ret    

c000823e <create_dir_entry>:
create_dir_entry():
/work/x86_os_my/fs/dir.c:111

/* 在内存中初始化目录项p_de */
void create_dir_entry(char* filename, uint32_t inode_no, uint8_t file_type, struct dir_entry* p_de) {
c000823e:	55                   	push   %ebp
c000823f:	89 e5                	mov    %esp,%ebp
c0008241:	83 ec 18             	sub    $0x18,%esp
c0008244:	8b 45 10             	mov    0x10(%ebp),%eax
c0008247:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:112
	ASSERT(strlen(filename) <=  MAX_FILE_NAME_LEN);
c000824a:	83 ec 0c             	sub    $0xc,%esp
c000824d:	ff 75 08             	pushl  0x8(%ebp)
c0008250:	e8 7f b9 ff ff       	call   c0003bd4 <strlen>
c0008255:	83 c4 10             	add    $0x10,%esp
c0008258:	83 f8 10             	cmp    $0x10,%eax
c000825b:	76 19                	jbe    c0008276 <create_dir_entry+0x38>
/work/x86_os_my/fs/dir.c:112 (discriminator 1)
c000825d:	68 e0 9d 00 c0       	push   $0xc0009de0
c0008262:	68 8c 9e 00 c0       	push   $0xc0009e8c
c0008267:	6a 70                	push   $0x70
c0008269:	68 06 9e 00 c0       	push   $0xc0009e06
c000826e:	e8 bf a3 ff ff       	call   c0002632 <panic_spin>
c0008273:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:115

	/* 初始化目录项 */
	memcpy(p_de->filename, filename, strlen(filename));
c0008276:	83 ec 0c             	sub    $0xc,%esp
c0008279:	ff 75 08             	pushl  0x8(%ebp)
c000827c:	e8 53 b9 ff ff       	call   c0003bd4 <strlen>
c0008281:	83 c4 10             	add    $0x10,%esp
c0008284:	89 c2                	mov    %eax,%edx
c0008286:	8b 45 14             	mov    0x14(%ebp),%eax
c0008289:	83 ec 04             	sub    $0x4,%esp
c000828c:	52                   	push   %edx
c000828d:	ff 75 08             	pushl  0x8(%ebp)
c0008290:	50                   	push   %eax
c0008291:	e8 06 b8 ff ff       	call   c0003a9c <memcpy>
c0008296:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:116
	p_de->i_no = inode_no;
c0008299:	8b 45 14             	mov    0x14(%ebp),%eax
c000829c:	8b 55 0c             	mov    0xc(%ebp),%edx
c000829f:	89 50 10             	mov    %edx,0x10(%eax)
/work/x86_os_my/fs/dir.c:117
	p_de->f_type = file_type;
c00082a2:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c00082a6:	8b 45 14             	mov    0x14(%ebp),%eax
c00082a9:	89 50 14             	mov    %edx,0x14(%eax)
/work/x86_os_my/fs/dir.c:118
}
c00082ac:	90                   	nop
c00082ad:	c9                   	leave  
c00082ae:	c3                   	ret    

c00082af <sync_dir_entry>:
sync_dir_entry():
/work/x86_os_my/fs/dir.c:128
 * io_buf是由主调函数提供的，里面是一个一个的目录项
 */
// 全局变量 cur_part 定义在fs.c中
// 临时变量 all_blocks 保存目录中 所有数据块的地址【4*140=560字节，去掉前12个直接块的地址48字节，后边全是间接块，后边正好是512字节】
// 注意: all_blocks 里面并没有一级间接表的地址，只有直接块+间接块的地址！
bool sync_dir_entry(struct dir* parent_dir, struct dir_entry* p_de, void* io_buf) {
c00082af:	55                   	push   %ebp
c00082b0:	89 e5                	mov    %esp,%ebp
c00082b2:	57                   	push   %edi
c00082b3:	81 ec 54 02 00 00    	sub    $0x254,%esp
/work/x86_os_my/fs/dir.c:129
	struct inode* dir_inode = parent_dir->inode;	//dir->inode：“已打开的 inode 队列”part->open_inodes 中的节点
c00082b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00082bc:	8b 00                	mov    (%eax),%eax
c00082be:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:130
	uint32_t dir_size = dir_inode->i_size;			//inode->i_size：当inode是目录时，代表 目录下所有目录项大小之和
c00082c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00082c4:	8b 40 04             	mov    0x4(%eax),%eax
c00082c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:131
	uint32_t dir_entry_size = cur_part->sb->dir_entry_size;
c00082ca:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c00082cf:	8b 40 1c             	mov    0x1c(%eax),%eax
c00082d2:	8b 40 30             	mov    0x30(%eax),%eax
c00082d5:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/dir.c:133

	ASSERT(dir_size % dir_entry_size == 0);	// dir_size应该是dir_entry_size的整数倍
c00082d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00082db:	ba 00 00 00 00       	mov    $0x0,%edx
c00082e0:	f7 75 e8             	divl   -0x18(%ebp)
c00082e3:	89 d0                	mov    %edx,%eax
c00082e5:	85 c0                	test   %eax,%eax
c00082e7:	74 1c                	je     c0008305 <sync_dir_entry+0x56>
/work/x86_os_my/fs/dir.c:133 (discriminator 1)
c00082e9:	68 10 9e 00 c0       	push   $0xc0009e10
c00082ee:	68 a0 9e 00 c0       	push   $0xc0009ea0
c00082f3:	68 85 00 00 00       	push   $0x85
c00082f8:	68 06 9e 00 c0       	push   $0xc0009e06
c00082fd:	e8 30 a3 ff ff       	call   c0002632 <panic_spin>
c0008302:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:135

	uint32_t dir_entrys_per_sec = (512 / dir_entry_size);	// 每扇区最多有几个目录项【保证了：写入目录项时不会跨扇区】
c0008305:	b8 00 02 00 00       	mov    $0x200,%eax
c000830a:	ba 00 00 00 00       	mov    $0x0,%edx
c000830f:	f7 75 e8             	divl   -0x18(%ebp)
c0008312:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/dir.c:136
	int32_t block_lba = -1;
c0008315:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:140


	/* 将该目录inode管理的所有块(扇区)地址(12个直接块+ 128个间接块)存入all_blocks */
	uint8_t block_idx = 0;
c000831c:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/dir.c:143
	// all_blocks 保存目录中 所有数据块的地址【4*140=560字节，去掉前12个直接块的地址48字节，后边全是间接块，后边正好是512字节】
	// 注意: all_blocks 里面并没有一级间接表的地址，只有直接块+间接块的地址！
	uint32_t all_blocks[140] = {0};
c0008320:	8d 95 a8 fd ff ff    	lea    -0x258(%ebp),%edx
c0008326:	b8 00 00 00 00       	mov    $0x0,%eax
c000832b:	b9 8c 00 00 00       	mov    $0x8c,%ecx
c0008330:	89 d7                	mov    %edx,%edi
c0008332:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/fs/dir.c:144
	while (block_idx < 12) {
c0008334:	eb 22                	jmp    c0008358 <sync_dir_entry+0xa9>
/work/x86_os_my/fs/dir.c:145
		all_blocks[block_idx] = dir_inode->i_sectors[block_idx];
c0008336:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000833a:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
c000833e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008341:	83 c1 04             	add    $0x4,%ecx
c0008344:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
c0008347:	89 94 85 a8 fd ff ff 	mov    %edx,-0x258(%ebp,%eax,4)
/work/x86_os_my/fs/dir.c:146
		block_idx++;
c000834e:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008352:	83 c0 01             	add    $0x1,%eax
c0008355:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/dir.c:144
	/* 将该目录inode管理的所有块(扇区)地址(12个直接块+ 128个间接块)存入all_blocks */
	uint8_t block_idx = 0;
	// all_blocks 保存目录中 所有数据块的地址【4*140=560字节，去掉前12个直接块的地址48字节，后边全是间接块，后边正好是512字节】
	// 注意: all_blocks 里面并没有一级间接表的地址，只有直接块+间接块的地址！
	uint32_t all_blocks[140] = {0};
	while (block_idx < 12) {
c0008358:	80 7d f7 0b          	cmpb   $0xb,-0x9(%ebp)
c000835c:	76 d8                	jbe    c0008336 <sync_dir_entry+0x87>
/work/x86_os_my/fs/dir.c:151
		block_idx++;
	}


	/* 开始遍历所有块以寻找目录项空位 */
	block_idx = 0;
c000835e:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/dir.c:152
	while (block_idx < 140) {	// 文件(包括目录)最多管理140个块
c0008362:	e9 3f 03 00 00       	jmp    c00086a6 <sync_dir_entry+0x3f7>
/work/x86_os_my/fs/dir.c:155
		/* 一、若inode管理的第block_idx块是不存在的，需要分配。
		   下边是需要分配块的三种情况 @1 @2 @3 */
		int32_t block_bitmap_idx = -1;
c0008367:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:156
		if (all_blocks[block_idx] == 0) {
c000836e:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008372:	8b 84 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%eax
c0008379:	85 c0                	test   %eax,%eax
c000837b:	0f 85 58 02 00 00    	jne    c00085d9 <sync_dir_entry+0x32a>
/work/x86_os_my/fs/dir.c:157
			block_lba = block_bitmap_alloc(cur_part);	// #1 从分区的block位图中，分配1个扇区，返回"扇区地址"
c0008381:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c0008386:	83 ec 0c             	sub    $0xc,%esp
c0008389:	50                   	push   %eax
c000838a:	e8 3c f7 ff ff       	call   c0007acb <block_bitmap_alloc>
c000838f:	83 c4 10             	add    $0x10,%esp
c0008392:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:158
			if (block_lba == -1) {
c0008395:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
c0008399:	75 1a                	jne    c00083b5 <sync_dir_entry+0x106>
/work/x86_os_my/fs/dir.c:159
				printk("alloc block bitmap for sync_dir_entry failed\n");
c000839b:	83 ec 0c             	sub    $0xc,%esp
c000839e:	68 30 9e 00 c0       	push   $0xc0009e30
c00083a3:	e8 23 e3 ff ff       	call   c00066cb <printk>
c00083a8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:160
				return false;
c00083ab:	b8 00 00 00 00       	mov    $0x0,%eax
c00083b0:	e9 10 03 00 00       	jmp    c00086c5 <sync_dir_entry+0x416>
/work/x86_os_my/fs/dir.c:163
			}
			/* 每分配一个块就同步一次block_bitmap */
			block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c00083b5:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00083b8:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c00083bd:	8b 40 1c             	mov    0x1c(%eax),%eax
c00083c0:	8b 40 28             	mov    0x28(%eax),%eax
c00083c3:	29 c2                	sub    %eax,%edx
c00083c5:	89 d0                	mov    %edx,%eax
c00083c7:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:164
			ASSERT(block_bitmap_idx != -1);	//怎么可能是-1啊。。。？
c00083ca:	83 7d dc ff          	cmpl   $0xffffffff,-0x24(%ebp)
c00083ce:	75 1c                	jne    c00083ec <sync_dir_entry+0x13d>
/work/x86_os_my/fs/dir.c:164 (discriminator 1)
c00083d0:	68 5e 9e 00 c0       	push   $0xc0009e5e
c00083d5:	68 a0 9e 00 c0       	push   $0xc0009ea0
c00083da:	68 a4 00 00 00       	push   $0xa4
c00083df:	68 06 9e 00 c0       	push   $0xc0009e06
c00083e4:	e8 49 a2 ff ff       	call   c0002632 <panic_spin>
c00083e9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:165
			bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c00083ec:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00083ef:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c00083f4:	83 ec 04             	sub    $0x4,%esp
c00083f7:	6a 01                	push   $0x1
c00083f9:	52                   	push   %edx
c00083fa:	50                   	push   %eax
c00083fb:	e8 1d f7 ff ff       	call   c0007b1d <bitmap_sync>
c0008400:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:167

			block_bitmap_idx = -1;
c0008403:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:168
			if (block_idx < 12) {			// @1 若是直接块
c000840a:	80 7d f7 0b          	cmpb   $0xb,-0x9(%ebp)
c000840e:	77 27                	ja     c0008437 <sync_dir_entry+0x188>
/work/x86_os_my/fs/dir.c:169
				dir_inode->i_sectors[block_idx] = all_blocks[block_idx] = block_lba;
c0008410:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
c0008414:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008418:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000841b:	89 94 85 a8 fd ff ff 	mov    %edx,-0x258(%ebp,%eax,4)
c0008422:	8b 94 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%edx
c0008429:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000842c:	83 c1 04             	add    $0x4,%ecx
c000842f:	89 14 88             	mov    %edx,(%eax,%ecx,4)
c0008432:	e9 3c 01 00 00       	jmp    c0008573 <sync_dir_entry+0x2c4>
/work/x86_os_my/fs/dir.c:170
			} else if (block_idx == 12) {	// @2 若是未分配 一级间接块表(block_idx==12表示第0个间接块)
c0008437:	80 7d f7 0c          	cmpb   $0xc,-0x9(%ebp)
c000843b:	0f 85 ff 00 00 00    	jne    c0008540 <sync_dir_entry+0x291>
/work/x86_os_my/fs/dir.c:171
				dir_inode->i_sectors[12] = block_lba;		// 将 #1 分配的块做为"一级间接块表"地址
c0008441:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0008444:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0008447:	89 50 40             	mov    %edx,0x40(%eax)
/work/x86_os_my/fs/dir.c:173
				
				block_lba = -1;
c000844a:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:174
				block_lba = block_bitmap_alloc(cur_part);	// #2 再分配一个块做为"第0个间接块"
c0008451:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c0008456:	83 ec 0c             	sub    $0xc,%esp
c0008459:	50                   	push   %eax
c000845a:	e8 6c f6 ff ff       	call   c0007acb <block_bitmap_alloc>
c000845f:	83 c4 10             	add    $0x10,%esp
c0008462:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:175
				if (block_lba == -1) {
c0008465:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
c0008469:	75 57                	jne    c00084c2 <sync_dir_entry+0x213>
/work/x86_os_my/fs/dir.c:177
					// 回滚block_bitmap
					block_bitmap_idx = dir_inode->i_sectors[12] - cur_part->sb->data_start_lba;
c000846b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000846e:	8b 50 40             	mov    0x40(%eax),%edx
c0008471:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c0008476:	8b 40 1c             	mov    0x1c(%eax),%eax
c0008479:	8b 40 28             	mov    0x28(%eax),%eax
c000847c:	29 c2                	sub    %eax,%edx
c000847e:	89 d0                	mov    %edx,%eax
c0008480:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:178
					bitmap_set(&cur_part->block_bitmap, block_bitmap_idx, 0);	//释放 #1
c0008483:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0008486:	8b 15 d0 d9 00 c0    	mov    0xc000d9d0,%edx
c000848c:	83 c2 20             	add    $0x20,%edx
c000848f:	83 ec 04             	sub    $0x4,%esp
c0008492:	6a 00                	push   $0x0
c0008494:	50                   	push   %eax
c0008495:	52                   	push   %edx
c0008496:	e8 05 a4 ff ff       	call   c00028a0 <bitmap_set>
c000849b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:180
					// 取消掉这个一级间接块表
					dir_inode->i_sectors[12] = 0;
c000849e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00084a1:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
/work/x86_os_my/fs/dir.c:181
					printk("alloc block bitmap for sync_dir_entry failed\n");
c00084a8:	83 ec 0c             	sub    $0xc,%esp
c00084ab:	68 30 9e 00 c0       	push   $0xc0009e30
c00084b0:	e8 16 e2 ff ff       	call   c00066cb <printk>
c00084b5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:182
					return false;
c00084b8:	b8 00 00 00 00       	mov    $0x0,%eax
c00084bd:	e9 03 02 00 00       	jmp    c00086c5 <sync_dir_entry+0x416>
/work/x86_os_my/fs/dir.c:185
				}
				/* 每分配一个块就同步一次block_bitmap */
				block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c00084c2:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00084c5:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c00084ca:	8b 40 1c             	mov    0x1c(%eax),%eax
c00084cd:	8b 40 28             	mov    0x28(%eax),%eax
c00084d0:	29 c2                	sub    %eax,%edx
c00084d2:	89 d0                	mov    %edx,%eax
c00084d4:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:186
				ASSERT(block_bitmap_idx != -1);
c00084d7:	83 7d dc ff          	cmpl   $0xffffffff,-0x24(%ebp)
c00084db:	75 1c                	jne    c00084f9 <sync_dir_entry+0x24a>
/work/x86_os_my/fs/dir.c:186 (discriminator 1)
c00084dd:	68 5e 9e 00 c0       	push   $0xc0009e5e
c00084e2:	68 a0 9e 00 c0       	push   $0xc0009ea0
c00084e7:	68 ba 00 00 00       	push   $0xba
c00084ec:	68 06 9e 00 c0       	push   $0xc0009e06
c00084f1:	e8 3c a1 ff ff       	call   c0002632 <panic_spin>
c00084f6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:187
				bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c00084f9:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00084fc:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c0008501:	83 ec 04             	sub    $0x4,%esp
c0008504:	6a 01                	push   $0x1
c0008506:	52                   	push   %edx
c0008507:	50                   	push   %eax
c0008508:	e8 10 f6 ff ff       	call   c0007b1d <bitmap_sync>
c000850d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:190

				/* 把新分配的"第0个间接块地址"写入硬盘中"一级间接块表" */
				all_blocks[12] = block_lba;
c0008510:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0008513:	89 85 d8 fd ff ff    	mov    %eax,-0x228(%ebp)
/work/x86_os_my/fs/dir.c:194
				// all_blocks 共有4*140=560字节，去掉前12个直接块的地址48字节，后边全是间接块，后边正好是512字节】
				// 注意: all_blocks 里面并没有一级间接表的地址，只有直接块+间接块的地址！
				// 我们的一级间接表大小是和普通数据块大小一样的512字节，可以容纳128个数据块的地址！
				ide_write(cur_part->my_disk, dir_inode->i_sectors[12], all_blocks + 12, 1);
c0008519:	8d 85 a8 fd ff ff    	lea    -0x258(%ebp),%eax
c000851f:	83 c0 30             	add    $0x30,%eax
c0008522:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008525:	8b 4a 40             	mov    0x40(%edx),%ecx
c0008528:	8b 15 d0 d9 00 c0    	mov    0xc000d9d0,%edx
c000852e:	8b 52 08             	mov    0x8(%edx),%edx
c0008531:	6a 01                	push   $0x1
c0008533:	50                   	push   %eax
c0008534:	51                   	push   %ecx
c0008535:	52                   	push   %edx
c0008536:	e8 8b d8 ff ff       	call   c0005dc6 <ide_write>
c000853b:	83 c4 10             	add    $0x10,%esp
c000853e:	eb 33                	jmp    c0008573 <sync_dir_entry+0x2c4>
/work/x86_os_my/fs/dir.c:197
			} else {						// @3 若是未分配 间接块【父目录inode管理的只有前13个数据块需要特殊处理，后边的全是间接块】
				/* 把新分配的第(block_idx-12)个间接块地址"写入硬盘中"一级间接块表 */
				all_blocks[block_idx] = block_lba;
c0008540:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008544:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0008547:	89 94 85 a8 fd ff ff 	mov    %edx,-0x258(%ebp,%eax,4)
/work/x86_os_my/fs/dir.c:198
				ide_write(cur_part->my_disk, dir_inode->i_sectors[12], all_blocks + 12, 1);
c000854e:	8d 85 a8 fd ff ff    	lea    -0x258(%ebp),%eax
c0008554:	83 c0 30             	add    $0x30,%eax
c0008557:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000855a:	8b 4a 40             	mov    0x40(%edx),%ecx
c000855d:	8b 15 d0 d9 00 c0    	mov    0xc000d9d0,%edx
c0008563:	8b 52 08             	mov    0x8(%edx),%edx
c0008566:	6a 01                	push   $0x1
c0008568:	50                   	push   %eax
c0008569:	51                   	push   %ecx
c000856a:	52                   	push   %edx
c000856b:	e8 56 d8 ff ff       	call   c0005dc6 <ide_write>
c0008570:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:204
			}


			/* 这里才是重点，前边只是处理，父目录indoe管理的某个数据块为空的情况，需要新分配数据块，包括一级间接块表、间接块 */
			/* 再将硬盘中，新目录项p_de写入新分配的间接块 */
			memset(io_buf, 0, 512);
c0008573:	83 ec 04             	sub    $0x4,%esp
c0008576:	68 00 02 00 00       	push   $0x200
c000857b:	6a 00                	push   $0x0
c000857d:	ff 75 10             	pushl  0x10(%ebp)
c0008580:	e8 c5 b4 ff ff       	call   c0003a4a <memset>
c0008585:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:205
			memcpy(io_buf, p_de, dir_entry_size);
c0008588:	83 ec 04             	sub    $0x4,%esp
c000858b:	ff 75 e8             	pushl  -0x18(%ebp)
c000858e:	ff 75 0c             	pushl  0xc(%ebp)
c0008591:	ff 75 10             	pushl  0x10(%ebp)
c0008594:	e8 03 b5 ff ff       	call   c0003a9c <memcpy>
c0008599:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:206
			ide_write(cur_part->my_disk, all_blocks[block_idx], io_buf, 1);
c000859c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00085a0:	8b 94 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%edx
c00085a7:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c00085ac:	8b 40 08             	mov    0x8(%eax),%eax
c00085af:	6a 01                	push   $0x1
c00085b1:	ff 75 10             	pushl  0x10(%ebp)
c00085b4:	52                   	push   %edx
c00085b5:	50                   	push   %eax
c00085b6:	e8 0b d8 ff ff       	call   c0005dc6 <ide_write>
c00085bb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:207
			dir_inode->i_size += dir_entry_size;	//struct inode* dir_inode = parent_dir->inode;更新的是父目录的inode结构
c00085be:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00085c1:	8b 50 04             	mov    0x4(%eax),%edx
c00085c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00085c7:	01 c2                	add    %eax,%edx
c00085c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00085cc:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/dir.c:208
			return true;
c00085cf:	b8 01 00 00 00       	mov    $0x1,%eax
c00085d4:	e9 ec 00 00 00       	jmp    c00086c5 <sync_dir_entry+0x416>
/work/x86_os_my/fs/dir.c:213
		}//if (all_blocks[block_idx] == 0)


		/* 二、若inode管理的第block_idx块是存在的，不需要分配，将其读进内存，然后在该块中查找空目录项，将p_de填入 */
		ide_read(cur_part->my_disk, all_blocks[block_idx], io_buf, 1); 
c00085d9:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00085dd:	8b 94 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%edx
c00085e4:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c00085e9:	8b 40 08             	mov    0x8(%eax),%eax
c00085ec:	6a 01                	push   $0x1
c00085ee:	ff 75 10             	pushl  0x10(%ebp)
c00085f1:	52                   	push   %edx
c00085f2:	50                   	push   %eax
c00085f3:	e8 5a d6 ff ff       	call   c0005c52 <ide_read>
c00085f8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:215
		/* 在扇区内查找空目录项 */
		uint8_t dir_entry_idx = 0;
c00085fb:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
/work/x86_os_my/fs/dir.c:216
		struct dir_entry* dir_e = (struct dir_entry*)io_buf;		// dir_e用来在io_buf中遍历目录项【io_buf里面是一个一个的目录项】
c00085ff:	8b 45 10             	mov    0x10(%ebp),%eax
c0008602:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/dir.c:217
		while (dir_entry_idx < dir_entrys_per_sec) {
c0008605:	e9 85 00 00 00       	jmp    c000868f <sync_dir_entry+0x3e0>
/work/x86_os_my/fs/dir.c:218
			if ((dir_e + dir_entry_idx)->f_type == FT_UNKNOWN) {	// 无论是初始化或是删除文件，都会将f_type置为FT_UNKNOWN.
c000860a:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
c000860e:	89 d0                	mov    %edx,%eax
c0008610:	01 c0                	add    %eax,%eax
c0008612:	01 d0                	add    %edx,%eax
c0008614:	c1 e0 03             	shl    $0x3,%eax
c0008617:	89 c2                	mov    %eax,%edx
c0008619:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000861c:	01 d0                	add    %edx,%eax
c000861e:	8b 40 14             	mov    0x14(%eax),%eax
c0008621:	85 c0                	test   %eax,%eax
c0008623:	75 60                	jne    c0008685 <sync_dir_entry+0x3d6>
/work/x86_os_my/fs/dir.c:219
				memcpy(dir_e + dir_entry_idx, p_de, dir_entry_size);    
c0008625:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
c0008629:	89 d0                	mov    %edx,%eax
c000862b:	01 c0                	add    %eax,%eax
c000862d:	01 d0                	add    %edx,%eax
c000862f:	c1 e0 03             	shl    $0x3,%eax
c0008632:	89 c2                	mov    %eax,%edx
c0008634:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0008637:	01 d0                	add    %edx,%eax
c0008639:	83 ec 04             	sub    $0x4,%esp
c000863c:	ff 75 e8             	pushl  -0x18(%ebp)
c000863f:	ff 75 0c             	pushl  0xc(%ebp)
c0008642:	50                   	push   %eax
c0008643:	e8 54 b4 ff ff       	call   c0003a9c <memcpy>
c0008648:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:220
				ide_write(cur_part->my_disk, all_blocks[block_idx], io_buf, 1);
c000864b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000864f:	8b 94 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%edx
c0008656:	a1 d0 d9 00 c0       	mov    0xc000d9d0,%eax
c000865b:	8b 40 08             	mov    0x8(%eax),%eax
c000865e:	6a 01                	push   $0x1
c0008660:	ff 75 10             	pushl  0x10(%ebp)
c0008663:	52                   	push   %edx
c0008664:	50                   	push   %eax
c0008665:	e8 5c d7 ff ff       	call   c0005dc6 <ide_write>
c000866a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:222

				dir_inode->i_size += dir_entry_size;
c000866d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0008670:	8b 50 04             	mov    0x4(%eax),%edx
c0008673:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0008676:	01 c2                	add    %eax,%edx
c0008678:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000867b:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/dir.c:223
				return true;
c000867e:	b8 01 00 00 00       	mov    $0x1,%eax
c0008683:	eb 40                	jmp    c00086c5 <sync_dir_entry+0x416>
/work/x86_os_my/fs/dir.c:225
			}
			dir_entry_idx++;
c0008685:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0008689:	83 c0 01             	add    $0x1,%eax
c000868c:	88 45 f6             	mov    %al,-0xa(%ebp)
/work/x86_os_my/fs/dir.c:217
		/* 二、若inode管理的第block_idx块是存在的，不需要分配，将其读进内存，然后在该块中查找空目录项，将p_de填入 */
		ide_read(cur_part->my_disk, all_blocks[block_idx], io_buf, 1); 
		/* 在扇区内查找空目录项 */
		uint8_t dir_entry_idx = 0;
		struct dir_entry* dir_e = (struct dir_entry*)io_buf;		// dir_e用来在io_buf中遍历目录项【io_buf里面是一个一个的目录项】
		while (dir_entry_idx < dir_entrys_per_sec) {
c000868f:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0008693:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0008696:	0f 82 6e ff ff ff    	jb     c000860a <sync_dir_entry+0x35b>
/work/x86_os_my/fs/dir.c:230
			dir_entry_idx++;
		}


		/* 三、若inode管理的第block_idx块是存在的，不需要分配，但是都不是空闲(FT_UNKNOWN)的 */
		block_idx++;	//下一个inode管理的block
c000869c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00086a0:	83 c0 01             	add    $0x1,%eax
c00086a3:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/dir.c:152
	}


	/* 开始遍历所有块以寻找目录项空位 */
	block_idx = 0;
	while (block_idx < 140) {	// 文件(包括目录)最多管理140个块
c00086a6:	80 7d f7 8b          	cmpb   $0x8b,-0x9(%ebp)
c00086aa:	0f 86 b7 fc ff ff    	jbe    c0008367 <sync_dir_entry+0xb8>
/work/x86_os_my/fs/dir.c:233

		/* 三、若inode管理的第block_idx块是存在的，不需要分配，但是都不是空闲(FT_UNKNOWN)的 */
		block_idx++;	//下一个inode管理的block
	}//while (block_idx < 140)

	printk("directory is full!\n");
c00086b0:	83 ec 0c             	sub    $0xc,%esp
c00086b3:	68 75 9e 00 c0       	push   $0xc0009e75
c00086b8:	e8 0e e0 ff ff       	call   c00066cb <printk>
c00086bd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:234
	return false;
c00086c0:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/dir.c:235 (discriminator 1)
}
c00086c5:	8b 7d fc             	mov    -0x4(%ebp),%edi
c00086c8:	c9                   	leave  
c00086c9:	c3                   	ret    
