
./build/kernel.bin:     file format elf32-i386


Disassembly of section .text:

c0001500 <main>:
main():
/work/x86_os_my/kernel/main.c:36
void k_thread_a(void*);
void k_thread_b(void*);
void u_prog_a(void);
void u_prog_b(void);

int main(void) {
c0001500:	8d 4c 24 04          	lea    0x4(%esp),%ecx
c0001504:	83 e4 f0             	and    $0xfffffff0,%esp
c0001507:	ff 71 fc             	pushl  -0x4(%ecx)
c000150a:	55                   	push   %ebp
c000150b:	89 e5                	mov    %esp,%ebp
c000150d:	51                   	push   %ecx
c000150e:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/kernel/main.c:37
	put_str("I am kernel\n");
c0001511:	83 ec 0c             	sub    $0xc,%esp
c0001514:	68 54 65 00 c0       	push   $0xc0006554
c0001519:	e8 f2 0e 00 00       	call   c0002410 <put_str>
c000151e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:38
	init_all();
c0001521:	e8 fc 02 00 00       	call   c0001822 <init_all>
/work/x86_os_my/kernel/main.c:39 (discriminator 1)
	while(1);
c0001526:	eb fe                	jmp    c0001526 <main+0x26>

c0001528 <k_thread_a>:
k_thread_a():
/work/x86_os_my/kernel/main.c:49
	while(1);
	return 0;
}

/* 在线程中运行的函数 */
void k_thread_a(void* arg) {     
c0001528:	55                   	push   %ebp
c0001529:	89 e5                	mov    %esp,%ebp
c000152b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:50
	void* addr1 = sys_malloc(256);
c000152e:	83 ec 0c             	sub    $0xc,%esp
c0001531:	68 00 01 00 00       	push   $0x100
c0001536:	e8 68 19 00 00       	call   c0002ea3 <sys_malloc>
c000153b:	83 c4 10             	add    $0x10,%esp
c000153e:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/main.c:51
	void* addr2 = sys_malloc(255);
c0001541:	83 ec 0c             	sub    $0xc,%esp
c0001544:	68 ff 00 00 00       	push   $0xff
c0001549:	e8 55 19 00 00       	call   c0002ea3 <sys_malloc>
c000154e:	83 c4 10             	add    $0x10,%esp
c0001551:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/main.c:52
	void* addr3 = sys_malloc(254);
c0001554:	83 ec 0c             	sub    $0xc,%esp
c0001557:	68 fe 00 00 00       	push   $0xfe
c000155c:	e8 42 19 00 00       	call   c0002ea3 <sys_malloc>
c0001561:	83 c4 10             	add    $0x10,%esp
c0001564:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/main.c:53
	console_put_str(" thread_a malloc addr:0x");
c0001567:	83 ec 0c             	sub    $0xc,%esp
c000156a:	68 61 65 00 c0       	push   $0xc0006561
c000156f:	e8 ec 30 00 00       	call   c0004660 <console_put_str>
c0001574:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:54
	console_put_int((int)addr1);
c0001577:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000157a:	83 ec 0c             	sub    $0xc,%esp
c000157d:	50                   	push   %eax
c000157e:	e8 27 31 00 00       	call   c00046aa <console_put_int>
c0001583:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:55
	console_put_char(',');
c0001586:	83 ec 0c             	sub    $0xc,%esp
c0001589:	6a 2c                	push   $0x2c
c000158b:	e8 f1 30 00 00       	call   c0004681 <console_put_char>
c0001590:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:56
	console_put_int((int)addr2);
c0001593:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0001596:	83 ec 0c             	sub    $0xc,%esp
c0001599:	50                   	push   %eax
c000159a:	e8 0b 31 00 00       	call   c00046aa <console_put_int>
c000159f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:57
	console_put_char(',');
c00015a2:	83 ec 0c             	sub    $0xc,%esp
c00015a5:	6a 2c                	push   $0x2c
c00015a7:	e8 d5 30 00 00       	call   c0004681 <console_put_char>
c00015ac:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:58
	console_put_int((int)addr3);
c00015af:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00015b2:	83 ec 0c             	sub    $0xc,%esp
c00015b5:	50                   	push   %eax
c00015b6:	e8 ef 30 00 00       	call   c00046aa <console_put_int>
c00015bb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:59
	console_put_char('\n');
c00015be:	83 ec 0c             	sub    $0xc,%esp
c00015c1:	6a 0a                	push   $0xa
c00015c3:	e8 b9 30 00 00       	call   c0004681 <console_put_char>
c00015c8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:61

	int cpu_delay = 100000;
c00015cb:	c7 45 f4 a0 86 01 00 	movl   $0x186a0,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:62
	while(cpu_delay-- > 0);
c00015d2:	90                   	nop
/work/x86_os_my/kernel/main.c:62 (discriminator 1)
c00015d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00015d6:	8d 50 ff             	lea    -0x1(%eax),%edx
c00015d9:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00015dc:	85 c0                	test   %eax,%eax
c00015de:	7f f3                	jg     c00015d3 <k_thread_a+0xab>
/work/x86_os_my/kernel/main.c:63
	sys_free(addr1);
c00015e0:	83 ec 0c             	sub    $0xc,%esp
c00015e3:	ff 75 f0             	pushl  -0x10(%ebp)
c00015e6:	e8 e5 1e 00 00       	call   c00034d0 <sys_free>
c00015eb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:64
	sys_free(addr2);
c00015ee:	83 ec 0c             	sub    $0xc,%esp
c00015f1:	ff 75 ec             	pushl  -0x14(%ebp)
c00015f4:	e8 d7 1e 00 00       	call   c00034d0 <sys_free>
c00015f9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:65
	sys_free(addr3);
c00015fc:	83 ec 0c             	sub    $0xc,%esp
c00015ff:	ff 75 e8             	pushl  -0x18(%ebp)
c0001602:	e8 c9 1e 00 00       	call   c00034d0 <sys_free>
c0001607:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:66 (discriminator 1)
	while(1);
c000160a:	eb fe                	jmp    c000160a <k_thread_a+0xe2>

c000160c <k_thread_b>:
k_thread_b():
/work/x86_os_my/kernel/main.c:70
}

/* 在线程中运行的函数 */
void k_thread_b(void* arg) {     
c000160c:	55                   	push   %ebp
c000160d:	89 e5                	mov    %esp,%ebp
c000160f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:71
	void* addr1 = sys_malloc(256);
c0001612:	83 ec 0c             	sub    $0xc,%esp
c0001615:	68 00 01 00 00       	push   $0x100
c000161a:	e8 84 18 00 00       	call   c0002ea3 <sys_malloc>
c000161f:	83 c4 10             	add    $0x10,%esp
c0001622:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/main.c:72
	void* addr2 = sys_malloc(255);
c0001625:	83 ec 0c             	sub    $0xc,%esp
c0001628:	68 ff 00 00 00       	push   $0xff
c000162d:	e8 71 18 00 00       	call   c0002ea3 <sys_malloc>
c0001632:	83 c4 10             	add    $0x10,%esp
c0001635:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/main.c:73
	void* addr3 = sys_malloc(254);
c0001638:	83 ec 0c             	sub    $0xc,%esp
c000163b:	68 fe 00 00 00       	push   $0xfe
c0001640:	e8 5e 18 00 00       	call   c0002ea3 <sys_malloc>
c0001645:	83 c4 10             	add    $0x10,%esp
c0001648:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/main.c:74
	console_put_str(" thread_b malloc addr:0x");
c000164b:	83 ec 0c             	sub    $0xc,%esp
c000164e:	68 7a 65 00 c0       	push   $0xc000657a
c0001653:	e8 08 30 00 00       	call   c0004660 <console_put_str>
c0001658:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:75
	console_put_int((int)addr1);
c000165b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000165e:	83 ec 0c             	sub    $0xc,%esp
c0001661:	50                   	push   %eax
c0001662:	e8 43 30 00 00       	call   c00046aa <console_put_int>
c0001667:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:76
	console_put_char(',');
c000166a:	83 ec 0c             	sub    $0xc,%esp
c000166d:	6a 2c                	push   $0x2c
c000166f:	e8 0d 30 00 00       	call   c0004681 <console_put_char>
c0001674:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:77
	console_put_int((int)addr2);
c0001677:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000167a:	83 ec 0c             	sub    $0xc,%esp
c000167d:	50                   	push   %eax
c000167e:	e8 27 30 00 00       	call   c00046aa <console_put_int>
c0001683:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:78
	console_put_char(',');
c0001686:	83 ec 0c             	sub    $0xc,%esp
c0001689:	6a 2c                	push   $0x2c
c000168b:	e8 f1 2f 00 00       	call   c0004681 <console_put_char>
c0001690:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:79
	console_put_int((int)addr3);
c0001693:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0001696:	83 ec 0c             	sub    $0xc,%esp
c0001699:	50                   	push   %eax
c000169a:	e8 0b 30 00 00       	call   c00046aa <console_put_int>
c000169f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:80
	console_put_char('\n');
c00016a2:	83 ec 0c             	sub    $0xc,%esp
c00016a5:	6a 0a                	push   $0xa
c00016a7:	e8 d5 2f 00 00       	call   c0004681 <console_put_char>
c00016ac:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:82

	int cpu_delay = 100000;
c00016af:	c7 45 f4 a0 86 01 00 	movl   $0x186a0,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:83
	while(cpu_delay-- > 0);
c00016b6:	90                   	nop
/work/x86_os_my/kernel/main.c:83 (discriminator 1)
c00016b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00016ba:	8d 50 ff             	lea    -0x1(%eax),%edx
c00016bd:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00016c0:	85 c0                	test   %eax,%eax
c00016c2:	7f f3                	jg     c00016b7 <k_thread_b+0xab>
/work/x86_os_my/kernel/main.c:84
	sys_free(addr1);
c00016c4:	83 ec 0c             	sub    $0xc,%esp
c00016c7:	ff 75 f0             	pushl  -0x10(%ebp)
c00016ca:	e8 01 1e 00 00       	call   c00034d0 <sys_free>
c00016cf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:85
	sys_free(addr2);
c00016d2:	83 ec 0c             	sub    $0xc,%esp
c00016d5:	ff 75 ec             	pushl  -0x14(%ebp)
c00016d8:	e8 f3 1d 00 00       	call   c00034d0 <sys_free>
c00016dd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:86
	sys_free(addr3);
c00016e0:	83 ec 0c             	sub    $0xc,%esp
c00016e3:	ff 75 e8             	pushl  -0x18(%ebp)
c00016e6:	e8 e5 1d 00 00       	call   c00034d0 <sys_free>
c00016eb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:87 (discriminator 1)
	while(1);
c00016ee:	eb fe                	jmp    c00016ee <k_thread_b+0xe2>

c00016f0 <u_prog_a>:
u_prog_a():
/work/x86_os_my/kernel/main.c:91
}

/* 测试用户进程 */
void u_prog_a(void) {
c00016f0:	55                   	push   %ebp
c00016f1:	89 e5                	mov    %esp,%ebp
c00016f3:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:92
	void* addr1 = malloc(256);
c00016f6:	83 ec 0c             	sub    $0xc,%esp
c00016f9:	68 00 01 00 00       	push   $0x100
c00016fe:	e8 f6 3d 00 00       	call   c00054f9 <malloc>
c0001703:	83 c4 10             	add    $0x10,%esp
c0001706:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/main.c:93
	void* addr2 = malloc(255);
c0001709:	83 ec 0c             	sub    $0xc,%esp
c000170c:	68 ff 00 00 00       	push   $0xff
c0001711:	e8 e3 3d 00 00       	call   c00054f9 <malloc>
c0001716:	83 c4 10             	add    $0x10,%esp
c0001719:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/main.c:94
	void* addr3 = malloc(254);
c000171c:	83 ec 0c             	sub    $0xc,%esp
c000171f:	68 fe 00 00 00       	push   $0xfe
c0001724:	e8 d0 3d 00 00       	call   c00054f9 <malloc>
c0001729:	83 c4 10             	add    $0x10,%esp
c000172c:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/main.c:95
	printf(" prog_a malloc addr:0x%x,0x%x,0x%x\n", (int)addr1, (int)addr2, (int)addr3);
c000172f:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0001732:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0001735:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001738:	51                   	push   %ecx
c0001739:	52                   	push   %edx
c000173a:	50                   	push   %eax
c000173b:	68 94 65 00 c0       	push   $0xc0006594
c0001740:	e8 a3 40 00 00       	call   c00057e8 <printf>
c0001745:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:97

	int cpu_delay = 100000;
c0001748:	c7 45 f4 a0 86 01 00 	movl   $0x186a0,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:98
	while(cpu_delay-- > 0);
c000174f:	90                   	nop
/work/x86_os_my/kernel/main.c:98 (discriminator 1)
c0001750:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001753:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001756:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0001759:	85 c0                	test   %eax,%eax
c000175b:	7f f3                	jg     c0001750 <u_prog_a+0x60>
/work/x86_os_my/kernel/main.c:99
	free(addr1);
c000175d:	83 ec 0c             	sub    $0xc,%esp
c0001760:	ff 75 f0             	pushl  -0x10(%ebp)
c0001763:	e8 b0 3d 00 00       	call   c0005518 <free>
c0001768:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:100
	free(addr2);
c000176b:	83 ec 0c             	sub    $0xc,%esp
c000176e:	ff 75 ec             	pushl  -0x14(%ebp)
c0001771:	e8 a2 3d 00 00       	call   c0005518 <free>
c0001776:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:101
	free(addr3);
c0001779:	83 ec 0c             	sub    $0xc,%esp
c000177c:	ff 75 e8             	pushl  -0x18(%ebp)
c000177f:	e8 94 3d 00 00       	call   c0005518 <free>
c0001784:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:102 (discriminator 1)
	while(1);
c0001787:	eb fe                	jmp    c0001787 <u_prog_a+0x97>

c0001789 <u_prog_b>:
u_prog_b():
/work/x86_os_my/kernel/main.c:106
}

/* 测试用户进程 */
void u_prog_b(void) {
c0001789:	55                   	push   %ebp
c000178a:	89 e5                	mov    %esp,%ebp
c000178c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:107
	void* addr1 = malloc(256);
c000178f:	83 ec 0c             	sub    $0xc,%esp
c0001792:	68 00 01 00 00       	push   $0x100
c0001797:	e8 5d 3d 00 00       	call   c00054f9 <malloc>
c000179c:	83 c4 10             	add    $0x10,%esp
c000179f:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/main.c:108
	void* addr2 = malloc(255);
c00017a2:	83 ec 0c             	sub    $0xc,%esp
c00017a5:	68 ff 00 00 00       	push   $0xff
c00017aa:	e8 4a 3d 00 00       	call   c00054f9 <malloc>
c00017af:	83 c4 10             	add    $0x10,%esp
c00017b2:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/main.c:109
	void* addr3 = malloc(254);
c00017b5:	83 ec 0c             	sub    $0xc,%esp
c00017b8:	68 fe 00 00 00       	push   $0xfe
c00017bd:	e8 37 3d 00 00       	call   c00054f9 <malloc>
c00017c2:	83 c4 10             	add    $0x10,%esp
c00017c5:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/main.c:110
	printf(" prog_b malloc addr:0x%x,0x%x,0x%x\n", (int)addr1, (int)addr2, (int)addr3);
c00017c8:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c00017cb:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00017ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00017d1:	51                   	push   %ecx
c00017d2:	52                   	push   %edx
c00017d3:	50                   	push   %eax
c00017d4:	68 b8 65 00 c0       	push   $0xc00065b8
c00017d9:	e8 0a 40 00 00       	call   c00057e8 <printf>
c00017de:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:112

	int cpu_delay = 100000;
c00017e1:	c7 45 f4 a0 86 01 00 	movl   $0x186a0,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:113
	while(cpu_delay-- > 0);
c00017e8:	90                   	nop
/work/x86_os_my/kernel/main.c:113 (discriminator 1)
c00017e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00017ec:	8d 50 ff             	lea    -0x1(%eax),%edx
c00017ef:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00017f2:	85 c0                	test   %eax,%eax
c00017f4:	7f f3                	jg     c00017e9 <u_prog_b+0x60>
/work/x86_os_my/kernel/main.c:114
	free(addr1);
c00017f6:	83 ec 0c             	sub    $0xc,%esp
c00017f9:	ff 75 f0             	pushl  -0x10(%ebp)
c00017fc:	e8 17 3d 00 00       	call   c0005518 <free>
c0001801:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:115
	free(addr2);
c0001804:	83 ec 0c             	sub    $0xc,%esp
c0001807:	ff 75 ec             	pushl  -0x14(%ebp)
c000180a:	e8 09 3d 00 00       	call   c0005518 <free>
c000180f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:116
	free(addr3);
c0001812:	83 ec 0c             	sub    $0xc,%esp
c0001815:	ff 75 e8             	pushl  -0x18(%ebp)
c0001818:	e8 fb 3c 00 00       	call   c0005518 <free>
c000181d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:117 (discriminator 1)
	while(1);
c0001820:	eb fe                	jmp    c0001820 <u_prog_b+0x97>

c0001822 <init_all>:
init_all():
/work/x86_os_my/kernel/init.c:14
#include "tss.h"
#include "syscall-init.h"
#include "ide.h"

/*负责初始化所有模块 */
void init_all() {
c0001822:	55                   	push   %ebp
c0001823:	89 e5                	mov    %esp,%ebp
c0001825:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/init.c:15
	put_str("init_all\n");
c0001828:	83 ec 0c             	sub    $0xc,%esp
c000182b:	68 dc 65 00 c0       	push   $0xc00065dc
c0001830:	e8 db 0b 00 00       	call   c0002410 <put_str>
c0001835:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/init.c:16
	idt_init();			// 初始化中断
c0001838:	e8 33 04 00 00       	call   c0001c70 <idt_init>
/work/x86_os_my/kernel/init.c:17
	mem_init();			// 初始化内存管理系统
c000183d:	e8 07 21 00 00       	call   c0003949 <mem_init>
/work/x86_os_my/kernel/init.c:18
	thread_init();		// 初始化线程相关结构
c0001842:	e8 4c 2b 00 00       	call   c0004393 <thread_init>
/work/x86_os_my/kernel/init.c:19
	timer_init();		// 初始化PIT
c0001847:	e8 11 06 00 00       	call   c0001e5d <timer_init>
/work/x86_os_my/kernel/init.c:20
	console_init();		// 控制台初始化最好放在开中断之前
c000184c:	e8 c4 2d 00 00       	call   c0004615 <console_init>
/work/x86_os_my/kernel/init.c:21
	keyboard_init();	// 键盘初始化
c0001851:	e8 3d 34 00 00       	call   c0004c93 <keyboard_init>
/work/x86_os_my/kernel/init.c:22
	tss_init();			// tss初始化
c0001856:	e8 f3 37 00 00       	call   c000504e <tss_init>
/work/x86_os_my/kernel/init.c:23
	syscall_init();		// 初始化系统调用
c000185b:	e8 0b 3d 00 00       	call   c000556b <syscall_init>
/work/x86_os_my/kernel/init.c:24
	intr_enable();		// 后面的ide_init需要打开中断
c0001860:	e8 5a 03 00 00       	call   c0001bbf <intr_enable>
/work/x86_os_my/kernel/init.c:25
	ide_init();			// 初始化硬盘
c0001865:	e8 55 4b 00 00       	call   c00063bf <ide_init>
/work/x86_os_my/kernel/init.c:26
}
c000186a:	90                   	nop
c000186b:	c9                   	leave  
c000186c:	c3                   	ret    

c000186d <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c000186d:	55                   	push   %ebp
c000186e:	89 e5                	mov    %esp,%ebp
c0001870:	83 ec 08             	sub    $0x8,%esp
c0001873:	8b 55 08             	mov    0x8(%ebp),%edx
c0001876:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001879:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c000187d:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c0001880:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0001884:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0001888:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c0001889:	90                   	nop
c000188a:	c9                   	leave  
c000188b:	c3                   	ret    

c000188c <pic_init>:
pic_init():
/work/x86_os_my/kernel/interrupt.c:41
//自定义类型 intr_handler = void*
extern intr_handler intr_entry_table[IDT_DESC_CNT];	    // 声明引用汇编kernel.S中的中断处理函数入口数组

/* 初始化可编程中断控制器8259A */
// outb 来着 lib/kernel/io.h 内联汇编写法
static void pic_init(void) {
c000188c:	55                   	push   %ebp
c000188d:	89 e5                	mov    %esp,%ebp
c000188f:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:43
	/* 初始化主片 */
	outb (PIC_M_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c0001892:	6a 11                	push   $0x11
c0001894:	6a 20                	push   $0x20
c0001896:	e8 d2 ff ff ff       	call   c000186d <outb>
c000189b:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:44
	outb (PIC_M_DATA, 0x20);	// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.
c000189e:	6a 20                	push   $0x20
c00018a0:	6a 21                	push   $0x21
c00018a2:	e8 c6 ff ff ff       	call   c000186d <outb>
c00018a7:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:45
	outb (PIC_M_DATA, 0x04);	// ICW3: IR2接从片. 
c00018aa:	6a 04                	push   $0x4
c00018ac:	6a 21                	push   $0x21
c00018ae:	e8 ba ff ff ff       	call   c000186d <outb>
c00018b3:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:46
	outb (PIC_M_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c00018b6:	6a 01                	push   $0x1
c00018b8:	6a 21                	push   $0x21
c00018ba:	e8 ae ff ff ff       	call   c000186d <outb>
c00018bf:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:49

	/* 初始化从片 */
	outb (PIC_S_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c00018c2:	6a 11                	push   $0x11
c00018c4:	68 a0 00 00 00       	push   $0xa0
c00018c9:	e8 9f ff ff ff       	call   c000186d <outb>
c00018ce:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:50
	outb (PIC_S_DATA, 0x28);	// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.
c00018d1:	6a 28                	push   $0x28
c00018d3:	68 a1 00 00 00       	push   $0xa1
c00018d8:	e8 90 ff ff ff       	call   c000186d <outb>
c00018dd:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:51
	outb (PIC_S_DATA, 0x02);	// ICW3: 设置从片连接到主片的IR2引脚
c00018e0:	6a 02                	push   $0x2
c00018e2:	68 a1 00 00 00       	push   $0xa1
c00018e7:	e8 81 ff ff ff       	call   c000186d <outb>
c00018ec:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:52
	outb (PIC_S_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c00018ef:	6a 01                	push   $0x1
c00018f1:	68 a1 00 00 00       	push   $0xa1
c00018f6:	e8 72 ff ff ff       	call   c000186d <outb>
c00018fb:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:56

	/* IRQ2用于级联从片,必须打开,否则无法响应从片上的中断
	主片上打开的中断有IRQ0的时钟,IRQ1的键盘和级联从片的IRQ2,其它全部关闭 */
	outb (PIC_M_DATA, 0xf8);
c00018fe:	68 f8 00 00 00       	push   $0xf8
c0001903:	6a 21                	push   $0x21
c0001905:	e8 63 ff ff ff       	call   c000186d <outb>
c000190a:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:58
	/* 打开从片上的IRQ14,此引脚接收硬盘控制器的中断 */
	outb (PIC_S_DATA, 0xbf);
c000190d:	68 bf 00 00 00       	push   $0xbf
c0001912:	68 a1 00 00 00       	push   $0xa1
c0001917:	e8 51 ff ff ff       	call   c000186d <outb>
c000191c:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:60

	put_str("   pic_init done\n");
c000191f:	83 ec 0c             	sub    $0xc,%esp
c0001922:	68 e8 65 00 c0       	push   $0xc00065e8
c0001927:	e8 e4 0a 00 00       	call   c0002410 <put_str>
c000192c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:61
}
c000192f:	90                   	nop
c0001930:	c9                   	leave  
c0001931:	c3                   	ret    

c0001932 <make_idt_desc>:
make_idt_desc():
/work/x86_os_my/kernel/interrupt.c:64

/* 创建中断门描述符 */
static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function) { 
c0001932:	55                   	push   %ebp
c0001933:	89 e5                	mov    %esp,%ebp
c0001935:	83 ec 04             	sub    $0x4,%esp
c0001938:	8b 45 0c             	mov    0xc(%ebp),%eax
c000193b:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:65
	p_gdesc->func_offset_low_word = (uint32_t)function & 0x0000FFFF;
c000193e:	8b 45 10             	mov    0x10(%ebp),%eax
c0001941:	89 c2                	mov    %eax,%edx
c0001943:	8b 45 08             	mov    0x8(%ebp),%eax
c0001946:	66 89 10             	mov    %dx,(%eax)
/work/x86_os_my/kernel/interrupt.c:66
	p_gdesc->selector = SELECTOR_K_CODE;
c0001949:	8b 45 08             	mov    0x8(%ebp),%eax
c000194c:	66 c7 40 02 08 00    	movw   $0x8,0x2(%eax)
/work/x86_os_my/kernel/interrupt.c:67
	p_gdesc->dcount = 0;
c0001952:	8b 45 08             	mov    0x8(%ebp),%eax
c0001955:	c6 40 04 00          	movb   $0x0,0x4(%eax)
/work/x86_os_my/kernel/interrupt.c:68
	p_gdesc->attribute = attr;
c0001959:	8b 45 08             	mov    0x8(%ebp),%eax
c000195c:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0001960:	88 50 05             	mov    %dl,0x5(%eax)
/work/x86_os_my/kernel/interrupt.c:69
	p_gdesc->func_offset_high_word = ((uint32_t)function & 0xFFFF0000) >> 16;
c0001963:	8b 45 10             	mov    0x10(%ebp),%eax
c0001966:	c1 e8 10             	shr    $0x10,%eax
c0001969:	89 c2                	mov    %eax,%edx
c000196b:	8b 45 08             	mov    0x8(%ebp),%eax
c000196e:	66 89 50 06          	mov    %dx,0x6(%eax)
/work/x86_os_my/kernel/interrupt.c:70
}
c0001972:	90                   	nop
c0001973:	c9                   	leave  
c0001974:	c3                   	ret    

c0001975 <idt_desc_init>:
idt_desc_init():
/work/x86_os_my/kernel/interrupt.c:73

/*初始化中断描述符表*/
static void idt_desc_init(void) {
c0001975:	55                   	push   %ebp
c0001976:	89 e5                	mov    %esp,%ebp
c0001978:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:75
	int i;
	int lastindex = IDT_DESC_CNT - 1;
c000197b:	c7 45 f0 80 00 00 00 	movl   $0x80,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:76
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001982:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0001989:	eb 29                	jmp    c00019b4 <idt_desc_init+0x3f>
/work/x86_os_my/kernel/interrupt.c:77 (discriminator 3)
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
c000198b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000198e:	8b 04 85 00 90 00 c0 	mov    -0x3fff7000(,%eax,4),%eax
c0001995:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0001998:	c1 e2 03             	shl    $0x3,%edx
c000199b:	81 c2 60 91 00 c0    	add    $0xc0009160,%edx
c00019a1:	50                   	push   %eax
c00019a2:	68 8e 00 00 00       	push   $0x8e
c00019a7:	52                   	push   %edx
c00019a8:	e8 85 ff ff ff       	call   c0001932 <make_idt_desc>
c00019ad:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/kernel/interrupt.c:76 (discriminator 3)

/*初始化中断描述符表*/
static void idt_desc_init(void) {
	int i;
	int lastindex = IDT_DESC_CNT - 1;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c00019b0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:76 (discriminator 1)
c00019b4:	81 7d f4 80 00 00 00 	cmpl   $0x80,-0xc(%ebp)
c00019bb:	7e ce                	jle    c000198b <idt_desc_init+0x16>
/work/x86_os_my/kernel/interrupt.c:81
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
	}
	/* 系统调用对应的中断门dpl为3！
	 * 中断处理程序为单独的syscall_handler */
	make_idt_desc(&idt[lastindex], IDT_DESC_ATTR_DPL3, syscall_handler);
c00019bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00019c0:	c1 e0 03             	shl    $0x3,%eax
c00019c3:	05 60 91 00 c0       	add    $0xc0009160,%eax
c00019c8:	68 e7 23 00 c0       	push   $0xc00023e7
c00019cd:	68 ee 00 00 00       	push   $0xee
c00019d2:	50                   	push   %eax
c00019d3:	e8 5a ff ff ff       	call   c0001932 <make_idt_desc>
c00019d8:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/kernel/interrupt.c:82
	put_str("   idt_desc_init done\n");
c00019db:	83 ec 0c             	sub    $0xc,%esp
c00019de:	68 fa 65 00 c0       	push   $0xc00065fa
c00019e3:	e8 28 0a 00 00       	call   c0002410 <put_str>
c00019e8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:83
}
c00019eb:	90                   	nop
c00019ec:	c9                   	leave  
c00019ed:	c3                   	ret    

c00019ee <general_intr_handler>:
general_intr_handler():
/work/x86_os_my/kernel/interrupt.c:86

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
c00019ee:	55                   	push   %ebp
c00019ef:	89 e5                	mov    %esp,%ebp
c00019f1:	83 ec 28             	sub    $0x28,%esp
c00019f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00019f7:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/kernel/interrupt.c:87
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
c00019fa:	80 7d e4 27          	cmpb   $0x27,-0x1c(%ebp)
c00019fe:	0f 84 bf 00 00 00    	je     c0001ac3 <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:87 (discriminator 1)
c0001a04:	80 7d e4 2f          	cmpb   $0x2f,-0x1c(%ebp)
c0001a08:	0f 84 b5 00 00 00    	je     c0001ac3 <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:92
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
c0001a0e:	83 ec 0c             	sub    $0xc,%esp
c0001a11:	6a 00                	push   $0x0
c0001a13:	e8 46 0b 00 00       	call   c000255e <set_cursor>
c0001a18:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:93
	int cursor_pos = 0;
c0001a1b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:94
	while(cursor_pos < 320) {
c0001a22:	eb 11                	jmp    c0001a35 <general_intr_handler+0x47>
/work/x86_os_my/kernel/interrupt.c:95
		put_char(' ');
c0001a24:	83 ec 0c             	sub    $0xc,%esp
c0001a27:	6a 20                	push   $0x20
c0001a29:	e8 00 0a 00 00       	call   c000242e <put_char>
c0001a2e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:96
		cursor_pos++;
c0001a31:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:94
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
	int cursor_pos = 0;
	while(cursor_pos < 320) {
c0001a35:	81 7d f4 3f 01 00 00 	cmpl   $0x13f,-0xc(%ebp)
c0001a3c:	7e e6                	jle    c0001a24 <general_intr_handler+0x36>
/work/x86_os_my/kernel/interrupt.c:100
		put_char(' ');
		cursor_pos++;
	}

	/* 将光标置为左上角 打印信息 */
	set_cursor(0);
c0001a3e:	83 ec 0c             	sub    $0xc,%esp
c0001a41:	6a 00                	push   $0x0
c0001a43:	e8 16 0b 00 00       	call   c000255e <set_cursor>
c0001a48:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:101
	put_str("!!!!!!!      excetion message begin  !!!!!!!!\n");
c0001a4b:	83 ec 0c             	sub    $0xc,%esp
c0001a4e:	68 14 66 00 c0       	push   $0xc0006614
c0001a53:	e8 b8 09 00 00       	call   c0002410 <put_str>
c0001a58:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:102
	set_cursor(88);			// 第2行第8个字符
c0001a5b:	83 ec 0c             	sub    $0xc,%esp
c0001a5e:	6a 58                	push   $0x58
c0001a60:	e8 f9 0a 00 00       	call   c000255e <set_cursor>
c0001a65:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:103
	put_str(intr_name[vec_nr]);
c0001a68:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0001a6c:	8b 04 85 20 96 00 c0 	mov    -0x3fff69e0(,%eax,4),%eax
c0001a73:	83 ec 0c             	sub    $0xc,%esp
c0001a76:	50                   	push   %eax
c0001a77:	e8 94 09 00 00       	call   c0002410 <put_str>
c0001a7c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:104
	if (vec_nr == 14) {		// 若为Pagefault,将缺失的地址打印出来并悬停
c0001a7f:	80 7d e4 0e          	cmpb   $0xe,-0x1c(%ebp)
c0001a83:	75 2c                	jne    c0001ab1 <general_intr_handler+0xc3>
/work/x86_os_my/kernel/interrupt.c:105
		int page_fault_vaddr = 0; 
c0001a85:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:106
		asm ("movl %%cr2, %0" : "=r" (page_fault_vaddr));	  // cr2是存放造成page_fault的地址
c0001a8c:	0f 20 d0             	mov    %cr2,%eax
c0001a8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:107
		put_str("\npage fault addr is ");
c0001a92:	83 ec 0c             	sub    $0xc,%esp
c0001a95:	68 43 66 00 c0       	push   $0xc0006643
c0001a9a:	e8 71 09 00 00       	call   c0002410 <put_str>
c0001a9f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:108
		put_int(page_fault_vaddr); 
c0001aa2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001aa5:	83 ec 0c             	sub    $0xc,%esp
c0001aa8:	50                   	push   %eax
c0001aa9:	e8 4d 0a 00 00       	call   c00024fb <put_int>
c0001aae:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:110
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
c0001ab1:	83 ec 0c             	sub    $0xc,%esp
c0001ab4:	68 58 66 00 c0       	push   $0xc0006658
c0001ab9:	e8 52 09 00 00       	call   c0002410 <put_str>
c0001abe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:113 (discriminator 1)
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
c0001ac1:	eb fe                	jmp    c0001ac1 <general_intr_handler+0xd3>
/work/x86_os_my/kernel/interrupt.c:88
}

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
c0001ac3:	90                   	nop
/work/x86_os_my/kernel/interrupt.c:114
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
}
c0001ac4:	c9                   	leave  
c0001ac5:	c3                   	ret    

c0001ac6 <exception_init>:
exception_init():
/work/x86_os_my/kernel/interrupt.c:117

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
c0001ac6:	55                   	push   %ebp
c0001ac7:	89 e5                	mov    %esp,%ebp
c0001ac9:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:119
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001acc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0001ad3:	eb 20                	jmp    c0001af5 <exception_init+0x2f>
/work/x86_os_my/kernel/interrupt.c:122 (discriminator 3)
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
c0001ad5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001ad8:	c7 04 85 40 98 00 c0 	movl   $0xc00019ee,-0x3fff67c0(,%eax,4)
c0001adf:	ee 19 00 c0 
/work/x86_os_my/kernel/interrupt.c:123 (discriminator 3)
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
c0001ae3:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001ae6:	c7 04 85 20 96 00 c0 	movl   $0xc0006688,-0x3fff69e0(,%eax,4)
c0001aed:	88 66 00 c0 
/work/x86_os_my/kernel/interrupt.c:119 (discriminator 3)
}

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001af1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:119 (discriminator 1)
c0001af5:	81 7d fc 80 00 00 00 	cmpl   $0x80,-0x4(%ebp)
c0001afc:	7e d7                	jle    c0001ad5 <exception_init+0xf>
/work/x86_os_my/kernel/interrupt.c:125
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
	}
	intr_name[0] = "#DE Divide Error";
c0001afe:	c7 05 20 96 00 c0 90 	movl   $0xc0006690,0xc0009620
c0001b05:	66 00 c0 
/work/x86_os_my/kernel/interrupt.c:126
	intr_name[1] = "#DB Debug Exception";
c0001b08:	c7 05 24 96 00 c0 a1 	movl   $0xc00066a1,0xc0009624
c0001b0f:	66 00 c0 
/work/x86_os_my/kernel/interrupt.c:127
	intr_name[2] = "NMI Interrupt";
c0001b12:	c7 05 28 96 00 c0 b5 	movl   $0xc00066b5,0xc0009628
c0001b19:	66 00 c0 
/work/x86_os_my/kernel/interrupt.c:128
	intr_name[3] = "#BP Breakpoint Exception";
c0001b1c:	c7 05 2c 96 00 c0 c3 	movl   $0xc00066c3,0xc000962c
c0001b23:	66 00 c0 
/work/x86_os_my/kernel/interrupt.c:129
	intr_name[4] = "#OF Overflow Exception";
c0001b26:	c7 05 30 96 00 c0 dc 	movl   $0xc00066dc,0xc0009630
c0001b2d:	66 00 c0 
/work/x86_os_my/kernel/interrupt.c:130
	intr_name[5] = "#BR BOUND Range Exceeded Exception";
c0001b30:	c7 05 34 96 00 c0 f4 	movl   $0xc00066f4,0xc0009634
c0001b37:	66 00 c0 
/work/x86_os_my/kernel/interrupt.c:131
	intr_name[6] = "#UD Invalid Opcode Exception";
c0001b3a:	c7 05 38 96 00 c0 17 	movl   $0xc0006717,0xc0009638
c0001b41:	67 00 c0 
/work/x86_os_my/kernel/interrupt.c:132
	intr_name[7] = "#NM Device Not Available Exception";
c0001b44:	c7 05 3c 96 00 c0 34 	movl   $0xc0006734,0xc000963c
c0001b4b:	67 00 c0 
/work/x86_os_my/kernel/interrupt.c:133
	intr_name[8] = "#DF Double Fault Exception";
c0001b4e:	c7 05 40 96 00 c0 57 	movl   $0xc0006757,0xc0009640
c0001b55:	67 00 c0 
/work/x86_os_my/kernel/interrupt.c:134
	intr_name[9] = "Coprocessor Segment Overrun";
c0001b58:	c7 05 44 96 00 c0 72 	movl   $0xc0006772,0xc0009644
c0001b5f:	67 00 c0 
/work/x86_os_my/kernel/interrupt.c:135
	intr_name[10] = "#TS Invalid TSS Exception";
c0001b62:	c7 05 48 96 00 c0 8e 	movl   $0xc000678e,0xc0009648
c0001b69:	67 00 c0 
/work/x86_os_my/kernel/interrupt.c:136
	intr_name[11] = "#NP Segment Not Present";
c0001b6c:	c7 05 4c 96 00 c0 a8 	movl   $0xc00067a8,0xc000964c
c0001b73:	67 00 c0 
/work/x86_os_my/kernel/interrupt.c:137
	intr_name[12] = "#SS Stack Fault Exception";
c0001b76:	c7 05 50 96 00 c0 c0 	movl   $0xc00067c0,0xc0009650
c0001b7d:	67 00 c0 
/work/x86_os_my/kernel/interrupt.c:138
	intr_name[13] = "#GP General Protection Exception";
c0001b80:	c7 05 54 96 00 c0 dc 	movl   $0xc00067dc,0xc0009654
c0001b87:	67 00 c0 
/work/x86_os_my/kernel/interrupt.c:139
	intr_name[14] = "#PF Page-Fault Exception";
c0001b8a:	c7 05 58 96 00 c0 fd 	movl   $0xc00067fd,0xc0009658
c0001b91:	67 00 c0 
/work/x86_os_my/kernel/interrupt.c:141
	// intr_name[15] 第15项是intel保留项，未使用
	intr_name[16] = "#MF x87 FPU Floating-Point Error";
c0001b94:	c7 05 60 96 00 c0 18 	movl   $0xc0006818,0xc0009660
c0001b9b:	68 00 c0 
/work/x86_os_my/kernel/interrupt.c:142
	intr_name[17] = "#AC Alignment Check Exception";
c0001b9e:	c7 05 64 96 00 c0 39 	movl   $0xc0006839,0xc0009664
c0001ba5:	68 00 c0 
/work/x86_os_my/kernel/interrupt.c:143
	intr_name[18] = "#MC Machine-Check Exception";
c0001ba8:	c7 05 68 96 00 c0 57 	movl   $0xc0006857,0xc0009668
c0001baf:	68 00 c0 
/work/x86_os_my/kernel/interrupt.c:144
	intr_name[19] = "#XF SIMD Floating-Point Exception";
c0001bb2:	c7 05 6c 96 00 c0 74 	movl   $0xc0006874,0xc000966c
c0001bb9:	68 00 c0 
/work/x86_os_my/kernel/interrupt.c:145
}
c0001bbc:	90                   	nop
c0001bbd:	c9                   	leave  
c0001bbe:	c3                   	ret    

c0001bbf <intr_enable>:
intr_enable():
/work/x86_os_my/kernel/interrupt.c:148

/* 开中断并返回开中断前的状态*/
enum intr_status intr_enable() {
c0001bbf:	55                   	push   %ebp
c0001bc0:	89 e5                	mov    %esp,%ebp
c0001bc2:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:150
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c0001bc5:	e8 65 00 00 00       	call   c0001c2f <intr_get_status>
c0001bca:	83 f8 01             	cmp    $0x1,%eax
c0001bcd:	75 0c                	jne    c0001bdb <intr_enable+0x1c>
/work/x86_os_my/kernel/interrupt.c:151
		old_status = INTR_ON;
c0001bcf:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:152
		return old_status;
c0001bd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001bd9:	eb 0b                	jmp    c0001be6 <intr_enable+0x27>
/work/x86_os_my/kernel/interrupt.c:154
	} else {
		old_status = INTR_OFF;
c0001bdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:155
		asm volatile("sti");	 // 开中断,sti指令将IF位置1
c0001be2:	fb                   	sti    
/work/x86_os_my/kernel/interrupt.c:156
		return old_status;
c0001be3:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:158
	}
}
c0001be6:	c9                   	leave  
c0001be7:	c3                   	ret    

c0001be8 <intr_disable>:
intr_disable():
/work/x86_os_my/kernel/interrupt.c:161

/* 关中断,并且返回关中断前的状态 */
enum intr_status intr_disable() {     
c0001be8:	55                   	push   %ebp
c0001be9:	89 e5                	mov    %esp,%ebp
c0001beb:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:163
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c0001bee:	e8 3c 00 00 00       	call   c0001c2f <intr_get_status>
c0001bf3:	83 f8 01             	cmp    $0x1,%eax
c0001bf6:	75 0d                	jne    c0001c05 <intr_disable+0x1d>
/work/x86_os_my/kernel/interrupt.c:164
		old_status = INTR_ON;
c0001bf8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:165
		asm volatile("cli" : : : "memory"); // 关中断,cli指令将IF位置0
c0001bff:	fa                   	cli    
/work/x86_os_my/kernel/interrupt.c:166
		return old_status;
c0001c00:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001c03:	eb 0a                	jmp    c0001c0f <intr_disable+0x27>
/work/x86_os_my/kernel/interrupt.c:168
	} else {
		old_status = INTR_OFF;
c0001c05:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:169
		return old_status;
c0001c0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:171
	}
}
c0001c0f:	c9                   	leave  
c0001c10:	c3                   	ret    

c0001c11 <intr_set_status>:
intr_set_status():
/work/x86_os_my/kernel/interrupt.c:174

/* 将中断状态设置为status */
enum intr_status intr_set_status(enum intr_status status) {
c0001c11:	55                   	push   %ebp
c0001c12:	89 e5                	mov    %esp,%ebp
c0001c14:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:175
	return status & INTR_ON ? intr_enable() : intr_disable();
c0001c17:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c1a:	83 e0 01             	and    $0x1,%eax
c0001c1d:	85 c0                	test   %eax,%eax
c0001c1f:	74 07                	je     c0001c28 <intr_set_status+0x17>
/work/x86_os_my/kernel/interrupt.c:175 (discriminator 1)
c0001c21:	e8 99 ff ff ff       	call   c0001bbf <intr_enable>
c0001c26:	eb 05                	jmp    c0001c2d <intr_set_status+0x1c>
/work/x86_os_my/kernel/interrupt.c:175 (discriminator 2)
c0001c28:	e8 bb ff ff ff       	call   c0001be8 <intr_disable>
/work/x86_os_my/kernel/interrupt.c:176 (discriminator 5)
}
c0001c2d:	c9                   	leave  
c0001c2e:	c3                   	ret    

c0001c2f <intr_get_status>:
intr_get_status():
/work/x86_os_my/kernel/interrupt.c:179

/* 获取当前中断状态 */
enum intr_status intr_get_status() {
c0001c2f:	55                   	push   %ebp
c0001c30:	89 e5                	mov    %esp,%ebp
c0001c32:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:180
	uint32_t eflags = 0; 
c0001c35:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:181
	GET_EFLAGS(eflags);
c0001c3c:	9c                   	pushf  
c0001c3d:	58                   	pop    %eax
c0001c3e:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:182
	return (EFLAGS_IF & eflags) ? INTR_ON : INTR_OFF;
c0001c41:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001c44:	25 00 02 00 00       	and    $0x200,%eax
c0001c49:	85 c0                	test   %eax,%eax
c0001c4b:	0f 95 c0             	setne  %al
c0001c4e:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/kernel/interrupt.c:183
}
c0001c51:	c9                   	leave  
c0001c52:	c3                   	ret    

c0001c53 <register_handler>:
register_handler():
/work/x86_os_my/kernel/interrupt.c:186

/* 在中断处理程序数组第vector_no个元素中注册安装中断处理程序function */
void register_handler(uint8_t vector_no, intr_handler function) {
c0001c53:	55                   	push   %ebp
c0001c54:	89 e5                	mov    %esp,%ebp
c0001c56:	83 ec 04             	sub    $0x4,%esp
c0001c59:	8b 45 08             	mov    0x8(%ebp),%eax
c0001c5c:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:189
/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
 * 见kernel/kernel.S的call [idt_table + %1*4] */
   idt_table[vector_no] = function; 
c0001c5f:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0001c63:	8b 55 0c             	mov    0xc(%ebp),%edx
c0001c66:	89 14 85 40 98 00 c0 	mov    %edx,-0x3fff67c0(,%eax,4)
/work/x86_os_my/kernel/interrupt.c:190
}
c0001c6d:	90                   	nop
c0001c6e:	c9                   	leave  
c0001c6f:	c3                   	ret    

c0001c70 <idt_init>:
idt_init():
/work/x86_os_my/kernel/interrupt.c:193

/*完成有关中断的所有初始化工作*/
void idt_init() {
c0001c70:	55                   	push   %ebp
c0001c71:	89 e5                	mov    %esp,%ebp
c0001c73:	56                   	push   %esi
c0001c74:	53                   	push   %ebx
c0001c75:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:194
	put_str("idt_init start\n");
c0001c78:	83 ec 0c             	sub    $0xc,%esp
c0001c7b:	68 96 68 00 c0       	push   $0xc0006896
c0001c80:	e8 8b 07 00 00       	call   c0002410 <put_str>
c0001c85:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:195
	idt_desc_init();	// 初始化中断描述符表
c0001c88:	e8 e8 fc ff ff       	call   c0001975 <idt_desc_init>
/work/x86_os_my/kernel/interrupt.c:196
	exception_init();	// 异常名初始化并注册通常的中断处理函数
c0001c8d:	e8 34 fe ff ff       	call   c0001ac6 <exception_init>
/work/x86_os_my/kernel/interrupt.c:197
	pic_init();			// 初始化8259A
c0001c92:	e8 f5 fb ff ff       	call   c000188c <pic_init>
/work/x86_os_my/kernel/interrupt.c:201

	/* 加载idt */
	// IDTR 是 48 位的寄存器，低 16 位是 IDT 的界限 = IDT 尺寸大小-1，高 32 位是 IDT 的线性基地址
	uint64_t idt_operand = ((sizeof(idt) - 1) | ((uint64_t)(uint32_t)idt << 16));
c0001c97:	b8 60 91 00 c0       	mov    $0xc0009160,%eax
c0001c9c:	ba 00 00 00 00       	mov    $0x0,%edx
c0001ca1:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0001ca5:	c1 e0 10             	shl    $0x10,%eax
c0001ca8:	89 c1                	mov    %eax,%ecx
c0001caa:	81 c9 07 04 00 00    	or     $0x407,%ecx
c0001cb0:	89 cb                	mov    %ecx,%ebx
c0001cb2:	89 d0                	mov    %edx,%eax
c0001cb4:	80 cc 00             	or     $0x0,%ah
c0001cb7:	89 c6                	mov    %eax,%esi
c0001cb9:	89 5d f0             	mov    %ebx,-0x10(%ebp)
c0001cbc:	89 75 f4             	mov    %esi,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:202
	asm volatile("lidt %0" : : "m" (idt_operand));
c0001cbf:	0f 01 5d f0          	lidtl  -0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:203
	put_str("idt_init done\n");
c0001cc3:	83 ec 0c             	sub    $0xc,%esp
c0001cc6:	68 a6 68 00 c0       	push   $0xc00068a6
c0001ccb:	e8 40 07 00 00       	call   c0002410 <put_str>
c0001cd0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:204
}
c0001cd3:	90                   	nop
c0001cd4:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001cd7:	5b                   	pop    %ebx
c0001cd8:	5e                   	pop    %esi
c0001cd9:	5d                   	pop    %ebp
c0001cda:	c3                   	ret    

c0001cdb <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c0001cdb:	55                   	push   %ebp
c0001cdc:	89 e5                	mov    %esp,%ebp
c0001cde:	83 ec 08             	sub    $0x8,%esp
c0001ce1:	8b 55 08             	mov    0x8(%ebp),%edx
c0001ce4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001ce7:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0001ceb:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c0001cee:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0001cf2:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0001cf6:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c0001cf7:	90                   	nop
c0001cf8:	c9                   	leave  
c0001cf9:	c3                   	ret    

c0001cfa <frequency_set>:
frequency_set():
/work/x86_os_my/device/timer.c:27
/* 把操作的计数器counter_no、读写锁属性rwl、计数器模式counter_mode写入模式控制寄存器并赋予初始值counter_value */
static void frequency_set(uint8_t counter_port, \
		uint8_t counter_no, \
		uint8_t rwl, \
		uint8_t counter_mode, \
		uint16_t counter_value) {
c0001cfa:	55                   	push   %ebp
c0001cfb:	89 e5                	mov    %esp,%ebp
c0001cfd:	56                   	push   %esi
c0001cfe:	53                   	push   %ebx
c0001cff:	83 ec 14             	sub    $0x14,%esp
c0001d02:	8b 45 08             	mov    0x8(%ebp),%eax
c0001d05:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c0001d08:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001d0b:	8b 55 14             	mov    0x14(%ebp),%edx
c0001d0e:	8b 75 18             	mov    0x18(%ebp),%esi
c0001d11:	88 45 f4             	mov    %al,-0xc(%ebp)
c0001d14:	88 5d f0             	mov    %bl,-0x10(%ebp)
c0001d17:	88 4d ec             	mov    %cl,-0x14(%ebp)
c0001d1a:	88 55 e8             	mov    %dl,-0x18(%ebp)
c0001d1d:	66 89 75 e4          	mov    %si,-0x1c(%ebp)
/work/x86_os_my/device/timer.c:29
	/* 往控制字寄存器端口0x43中写入控制字 */
	outb(PIT_CONTROL_PORT, (uint8_t)(counter_no << 6 | rwl << 4 | counter_mode << 1));
c0001d21:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0001d25:	c1 e0 06             	shl    $0x6,%eax
c0001d28:	89 c2                	mov    %eax,%edx
c0001d2a:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0001d2e:	c1 e0 04             	shl    $0x4,%eax
c0001d31:	09 c2                	or     %eax,%edx
c0001d33:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0001d37:	01 c0                	add    %eax,%eax
c0001d39:	09 d0                	or     %edx,%eax
c0001d3b:	0f b6 c0             	movzbl %al,%eax
c0001d3e:	50                   	push   %eax
c0001d3f:	6a 43                	push   $0x43
c0001d41:	e8 95 ff ff ff       	call   c0001cdb <outb>
c0001d46:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:31
	/* 先写入counter_value的低8位 */
	outb(counter_port, (uint8_t)counter_value);
c0001d49:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0001d4d:	0f b6 d0             	movzbl %al,%edx
c0001d50:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001d54:	52                   	push   %edx
c0001d55:	50                   	push   %eax
c0001d56:	e8 80 ff ff ff       	call   c0001cdb <outb>
c0001d5b:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:33
	/* 再写入counter_value的高8位 */
	outb(counter_port, (uint8_t)counter_value >> 8);
c0001d5e:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001d62:	6a 00                	push   $0x0
c0001d64:	50                   	push   %eax
c0001d65:	e8 71 ff ff ff       	call   c0001cdb <outb>
c0001d6a:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:34
}
c0001d6d:	90                   	nop
c0001d6e:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001d71:	5b                   	pop    %ebx
c0001d72:	5e                   	pop    %esi
c0001d73:	5d                   	pop    %ebp
c0001d74:	c3                   	ret    

c0001d75 <intr_timer_handler>:
intr_timer_handler():
/work/x86_os_my/device/timer.c:37

/* 时钟的中断处理函数 */
static void intr_timer_handler(void) {
c0001d75:	55                   	push   %ebp
c0001d76:	89 e5                	mov    %esp,%ebp
c0001d78:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/timer.c:38
	struct task_struct* cur_thread = running_thread();		// 返回线程PCB
c0001d7b:	e8 01 20 00 00       	call   c0003d81 <running_thread>
c0001d80:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/timer.c:40

	ASSERT(cur_thread->stack_magic == 0x19870916);			// 检查栈是否溢出
c0001d83:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001d86:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c0001d8c:	3d 16 09 87 19       	cmp    $0x19870916,%eax
c0001d91:	74 19                	je     c0001dac <intr_timer_handler+0x37>
/work/x86_os_my/device/timer.c:40 (discriminator 1)
c0001d93:	68 b8 68 00 c0       	push   $0xc00068b8
c0001d98:	68 20 69 00 c0       	push   $0xc0006920
c0001d9d:	6a 28                	push   $0x28
c0001d9f:	68 de 68 00 c0       	push   $0xc00068de
c0001da4:	e8 d9 07 00 00       	call   c0002582 <panic_spin>
c0001da9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:42

	cur_thread->elapsed_ticks++;// 记录此线程占用的cpu时间
c0001dac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001daf:	8b 40 20             	mov    0x20(%eax),%eax
c0001db2:	8d 50 01             	lea    0x1(%eax),%edx
c0001db5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001db8:	89 50 20             	mov    %edx,0x20(%eax)
/work/x86_os_my/device/timer.c:43
	ticks++;	//从内核第一次处理时间中断开始,至今的滴哒数,是内核态和用户态总共的嘀哒数
c0001dbb:	a1 44 9a 00 c0       	mov    0xc0009a44,%eax
c0001dc0:	83 c0 01             	add    $0x1,%eax
c0001dc3:	a3 44 9a 00 c0       	mov    %eax,0xc0009a44
/work/x86_os_my/device/timer.c:45

	if (cur_thread->ticks == 0) {
c0001dc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001dcb:	0f b6 40 1d          	movzbl 0x1d(%eax),%eax
c0001dcf:	84 c0                	test   %al,%al
c0001dd1:	75 07                	jne    c0001dda <intr_timer_handler+0x65>
/work/x86_os_my/device/timer.c:46
		schedule();				// 若进程时间片用完就开始调度新的进程上cpu
c0001dd3:	e8 8d 22 00 00       	call   c0004065 <schedule>
/work/x86_os_my/device/timer.c:50
	} else {
		cur_thread->ticks--;	// 将当前进程的时间片-1
	}
}
c0001dd8:	eb 10                	jmp    c0001dea <intr_timer_handler+0x75>
/work/x86_os_my/device/timer.c:48
	ticks++;	//从内核第一次处理时间中断开始,至今的滴哒数,是内核态和用户态总共的嘀哒数

	if (cur_thread->ticks == 0) {
		schedule();				// 若进程时间片用完就开始调度新的进程上cpu
	} else {
		cur_thread->ticks--;	// 将当前进程的时间片-1
c0001dda:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001ddd:	0f b6 40 1d          	movzbl 0x1d(%eax),%eax
c0001de1:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001de4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001de7:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/device/timer.c:50
	}
}
c0001dea:	90                   	nop
c0001deb:	c9                   	leave  
c0001dec:	c3                   	ret    

c0001ded <ticks_to_sleep>:
ticks_to_sleep():
/work/x86_os_my/device/timer.c:53

/* 以tick为单位的sleep,任何时间形式的sleep会转换此ticks形式 */
static void ticks_to_sleep(uint32_t sleep_ticks) {
c0001ded:	55                   	push   %ebp
c0001dee:	89 e5                	mov    %esp,%ebp
c0001df0:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/timer.c:54
	uint32_t start_tick = ticks;
c0001df3:	a1 44 9a 00 c0       	mov    0xc0009a44,%eax
c0001df8:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/timer.c:57

	/* 若间隔的ticks数不够便让出cpu */
	while (ticks - start_tick < sleep_ticks) {
c0001dfb:	eb 05                	jmp    c0001e02 <ticks_to_sleep+0x15>
/work/x86_os_my/device/timer.c:58
		thread_yield();
c0001dfd:	e8 0d 25 00 00       	call   c000430f <thread_yield>
/work/x86_os_my/device/timer.c:57
/* 以tick为单位的sleep,任何时间形式的sleep会转换此ticks形式 */
static void ticks_to_sleep(uint32_t sleep_ticks) {
	uint32_t start_tick = ticks;

	/* 若间隔的ticks数不够便让出cpu */
	while (ticks - start_tick < sleep_ticks) {
c0001e02:	a1 44 9a 00 c0       	mov    0xc0009a44,%eax
c0001e07:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0001e0a:	3b 45 08             	cmp    0x8(%ebp),%eax
c0001e0d:	72 ee                	jb     c0001dfd <ticks_to_sleep+0x10>
/work/x86_os_my/device/timer.c:60
		thread_yield();
	}
}
c0001e0f:	90                   	nop
c0001e10:	c9                   	leave  
c0001e11:	c3                   	ret    

c0001e12 <mtime_sleep>:
mtime_sleep():
/work/x86_os_my/device/timer.c:62

void mtime_sleep(uint32_t m_seconds) {
c0001e12:	55                   	push   %ebp
c0001e13:	89 e5                	mov    %esp,%ebp
c0001e15:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/timer.c:63
	uint32_t sleep_ticks = DIV_ROUND_UP(m_seconds, mil_seconds_per_intr);
c0001e18:	8b 45 08             	mov    0x8(%ebp),%eax
c0001e1b:	83 c0 09             	add    $0x9,%eax
c0001e1e:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
c0001e23:	f7 e2                	mul    %edx
c0001e25:	89 d0                	mov    %edx,%eax
c0001e27:	c1 e8 03             	shr    $0x3,%eax
c0001e2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/timer.c:64
	ASSERT(sleep_ticks > 0);
c0001e2d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0001e31:	75 19                	jne    c0001e4c <mtime_sleep+0x3a>
/work/x86_os_my/device/timer.c:64 (discriminator 1)
c0001e33:	68 ed 68 00 c0       	push   $0xc00068ed
c0001e38:	68 34 69 00 c0       	push   $0xc0006934
c0001e3d:	6a 40                	push   $0x40
c0001e3f:	68 de 68 00 c0       	push   $0xc00068de
c0001e44:	e8 39 07 00 00       	call   c0002582 <panic_spin>
c0001e49:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:65
	ticks_to_sleep(sleep_ticks); 
c0001e4c:	83 ec 0c             	sub    $0xc,%esp
c0001e4f:	ff 75 f4             	pushl  -0xc(%ebp)
c0001e52:	e8 96 ff ff ff       	call   c0001ded <ticks_to_sleep>
c0001e57:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:66
}
c0001e5a:	90                   	nop
c0001e5b:	c9                   	leave  
c0001e5c:	c3                   	ret    

c0001e5d <timer_init>:
timer_init():
/work/x86_os_my/device/timer.c:69

/* 初始化PIT8253 */
void timer_init() {
c0001e5d:	55                   	push   %ebp
c0001e5e:	89 e5                	mov    %esp,%ebp
c0001e60:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/timer.c:70
	put_str("timer_init start\n");
c0001e63:	83 ec 0c             	sub    $0xc,%esp
c0001e66:	68 fd 68 00 c0       	push   $0xc00068fd
c0001e6b:	e8 a0 05 00 00       	call   c0002410 <put_str>
c0001e70:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:72
	/* 设置8253的定时周期,也就是发中断的周期 */
	frequency_set(CONTRER0_PORT, COUNTER0_NO, READ_WRITE_LATCH, COUNTER_MODE, COUNTER0_VALUE);
c0001e73:	83 ec 0c             	sub    $0xc,%esp
c0001e76:	68 9b 2e 00 00       	push   $0x2e9b
c0001e7b:	6a 02                	push   $0x2
c0001e7d:	6a 03                	push   $0x3
c0001e7f:	6a 00                	push   $0x0
c0001e81:	6a 40                	push   $0x40
c0001e83:	e8 72 fe ff ff       	call   c0001cfa <frequency_set>
c0001e88:	83 c4 20             	add    $0x20,%esp
/work/x86_os_my/device/timer.c:73
	register_handler(0x20, intr_timer_handler);
c0001e8b:	83 ec 08             	sub    $0x8,%esp
c0001e8e:	68 75 1d 00 c0       	push   $0xc0001d75
c0001e93:	6a 20                	push   $0x20
c0001e95:	e8 b9 fd ff ff       	call   c0001c53 <register_handler>
c0001e9a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:74
	put_str("timer_init done\n");
c0001e9d:	83 ec 0c             	sub    $0xc,%esp
c0001ea0:	68 0f 69 00 c0       	push   $0xc000690f
c0001ea5:	e8 66 05 00 00       	call   c0002410 <put_str>
c0001eaa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:75
}
c0001ead:	90                   	nop
c0001eae:	c9                   	leave  
c0001eaf:	c3                   	ret    

c0001eb0 <intr_exit>:
intr_exit():
c0001eb0:	83 c4 04             	add    $0x4,%esp
c0001eb3:	61                   	popa   
c0001eb4:	0f a9                	pop    %gs
c0001eb6:	0f a1                	pop    %fs
c0001eb8:	07                   	pop    %es
c0001eb9:	1f                   	pop    %ds
c0001eba:	83 c4 04             	add    $0x4,%esp
c0001ebd:	cf                   	iret   

c0001ebe <intr0x00entry>:
intr0x00entry():
c0001ebe:	6a 00                	push   $0x0
c0001ec0:	1e                   	push   %ds
c0001ec1:	06                   	push   %es
c0001ec2:	0f a0                	push   %fs
c0001ec4:	0f a8                	push   %gs
c0001ec6:	60                   	pusha  
c0001ec7:	b0 20                	mov    $0x20,%al
c0001ec9:	e6 a0                	out    %al,$0xa0
c0001ecb:	e6 20                	out    %al,$0x20
c0001ecd:	6a 00                	push   $0x0
c0001ecf:	ff 15 40 98 00 c0    	call   *0xc0009840
c0001ed5:	eb d9                	jmp    c0001eb0 <intr_exit>

c0001ed7 <intr0x01entry>:
intr0x01entry():
c0001ed7:	6a 00                	push   $0x0
c0001ed9:	1e                   	push   %ds
c0001eda:	06                   	push   %es
c0001edb:	0f a0                	push   %fs
c0001edd:	0f a8                	push   %gs
c0001edf:	60                   	pusha  
c0001ee0:	b0 20                	mov    $0x20,%al
c0001ee2:	e6 a0                	out    %al,$0xa0
c0001ee4:	e6 20                	out    %al,$0x20
c0001ee6:	6a 01                	push   $0x1
c0001ee8:	ff 15 44 98 00 c0    	call   *0xc0009844
c0001eee:	eb c0                	jmp    c0001eb0 <intr_exit>

c0001ef0 <intr0x02entry>:
intr0x02entry():
c0001ef0:	6a 00                	push   $0x0
c0001ef2:	1e                   	push   %ds
c0001ef3:	06                   	push   %es
c0001ef4:	0f a0                	push   %fs
c0001ef6:	0f a8                	push   %gs
c0001ef8:	60                   	pusha  
c0001ef9:	b0 20                	mov    $0x20,%al
c0001efb:	e6 a0                	out    %al,$0xa0
c0001efd:	e6 20                	out    %al,$0x20
c0001eff:	6a 02                	push   $0x2
c0001f01:	ff 15 48 98 00 c0    	call   *0xc0009848
c0001f07:	eb a7                	jmp    c0001eb0 <intr_exit>

c0001f09 <intr0x03entry>:
intr0x03entry():
c0001f09:	6a 00                	push   $0x0
c0001f0b:	1e                   	push   %ds
c0001f0c:	06                   	push   %es
c0001f0d:	0f a0                	push   %fs
c0001f0f:	0f a8                	push   %gs
c0001f11:	60                   	pusha  
c0001f12:	b0 20                	mov    $0x20,%al
c0001f14:	e6 a0                	out    %al,$0xa0
c0001f16:	e6 20                	out    %al,$0x20
c0001f18:	6a 03                	push   $0x3
c0001f1a:	ff 15 4c 98 00 c0    	call   *0xc000984c
c0001f20:	eb 8e                	jmp    c0001eb0 <intr_exit>

c0001f22 <intr0x04entry>:
intr0x04entry():
c0001f22:	6a 00                	push   $0x0
c0001f24:	1e                   	push   %ds
c0001f25:	06                   	push   %es
c0001f26:	0f a0                	push   %fs
c0001f28:	0f a8                	push   %gs
c0001f2a:	60                   	pusha  
c0001f2b:	b0 20                	mov    $0x20,%al
c0001f2d:	e6 a0                	out    %al,$0xa0
c0001f2f:	e6 20                	out    %al,$0x20
c0001f31:	6a 04                	push   $0x4
c0001f33:	ff 15 50 98 00 c0    	call   *0xc0009850
c0001f39:	e9 72 ff ff ff       	jmp    c0001eb0 <intr_exit>

c0001f3e <intr0x05entry>:
intr0x05entry():
c0001f3e:	6a 00                	push   $0x0
c0001f40:	1e                   	push   %ds
c0001f41:	06                   	push   %es
c0001f42:	0f a0                	push   %fs
c0001f44:	0f a8                	push   %gs
c0001f46:	60                   	pusha  
c0001f47:	b0 20                	mov    $0x20,%al
c0001f49:	e6 a0                	out    %al,$0xa0
c0001f4b:	e6 20                	out    %al,$0x20
c0001f4d:	6a 05                	push   $0x5
c0001f4f:	ff 15 54 98 00 c0    	call   *0xc0009854
c0001f55:	e9 56 ff ff ff       	jmp    c0001eb0 <intr_exit>

c0001f5a <intr0x06entry>:
intr0x06entry():
c0001f5a:	6a 00                	push   $0x0
c0001f5c:	1e                   	push   %ds
c0001f5d:	06                   	push   %es
c0001f5e:	0f a0                	push   %fs
c0001f60:	0f a8                	push   %gs
c0001f62:	60                   	pusha  
c0001f63:	b0 20                	mov    $0x20,%al
c0001f65:	e6 a0                	out    %al,$0xa0
c0001f67:	e6 20                	out    %al,$0x20
c0001f69:	6a 06                	push   $0x6
c0001f6b:	ff 15 58 98 00 c0    	call   *0xc0009858
c0001f71:	e9 3a ff ff ff       	jmp    c0001eb0 <intr_exit>

c0001f76 <intr0x07entry>:
intr0x07entry():
c0001f76:	6a 00                	push   $0x0
c0001f78:	1e                   	push   %ds
c0001f79:	06                   	push   %es
c0001f7a:	0f a0                	push   %fs
c0001f7c:	0f a8                	push   %gs
c0001f7e:	60                   	pusha  
c0001f7f:	b0 20                	mov    $0x20,%al
c0001f81:	e6 a0                	out    %al,$0xa0
c0001f83:	e6 20                	out    %al,$0x20
c0001f85:	6a 07                	push   $0x7
c0001f87:	ff 15 5c 98 00 c0    	call   *0xc000985c
c0001f8d:	e9 1e ff ff ff       	jmp    c0001eb0 <intr_exit>

c0001f92 <intr0x08entry>:
intr0x08entry():
c0001f92:	90                   	nop
c0001f93:	1e                   	push   %ds
c0001f94:	06                   	push   %es
c0001f95:	0f a0                	push   %fs
c0001f97:	0f a8                	push   %gs
c0001f99:	60                   	pusha  
c0001f9a:	b0 20                	mov    $0x20,%al
c0001f9c:	e6 a0                	out    %al,$0xa0
c0001f9e:	e6 20                	out    %al,$0x20
c0001fa0:	6a 08                	push   $0x8
c0001fa2:	ff 15 60 98 00 c0    	call   *0xc0009860
c0001fa8:	e9 03 ff ff ff       	jmp    c0001eb0 <intr_exit>

c0001fad <intr0x09entry>:
intr0x09entry():
c0001fad:	6a 00                	push   $0x0
c0001faf:	1e                   	push   %ds
c0001fb0:	06                   	push   %es
c0001fb1:	0f a0                	push   %fs
c0001fb3:	0f a8                	push   %gs
c0001fb5:	60                   	pusha  
c0001fb6:	b0 20                	mov    $0x20,%al
c0001fb8:	e6 a0                	out    %al,$0xa0
c0001fba:	e6 20                	out    %al,$0x20
c0001fbc:	6a 09                	push   $0x9
c0001fbe:	ff 15 64 98 00 c0    	call   *0xc0009864
c0001fc4:	e9 e7 fe ff ff       	jmp    c0001eb0 <intr_exit>

c0001fc9 <intr0x0aentry>:
intr0x0aentry():
c0001fc9:	90                   	nop
c0001fca:	1e                   	push   %ds
c0001fcb:	06                   	push   %es
c0001fcc:	0f a0                	push   %fs
c0001fce:	0f a8                	push   %gs
c0001fd0:	60                   	pusha  
c0001fd1:	b0 20                	mov    $0x20,%al
c0001fd3:	e6 a0                	out    %al,$0xa0
c0001fd5:	e6 20                	out    %al,$0x20
c0001fd7:	6a 0a                	push   $0xa
c0001fd9:	ff 15 68 98 00 c0    	call   *0xc0009868
c0001fdf:	e9 cc fe ff ff       	jmp    c0001eb0 <intr_exit>

c0001fe4 <intr0x0bentry>:
intr0x0bentry():
c0001fe4:	90                   	nop
c0001fe5:	1e                   	push   %ds
c0001fe6:	06                   	push   %es
c0001fe7:	0f a0                	push   %fs
c0001fe9:	0f a8                	push   %gs
c0001feb:	60                   	pusha  
c0001fec:	b0 20                	mov    $0x20,%al
c0001fee:	e6 a0                	out    %al,$0xa0
c0001ff0:	e6 20                	out    %al,$0x20
c0001ff2:	6a 0b                	push   $0xb
c0001ff4:	ff 15 6c 98 00 c0    	call   *0xc000986c
c0001ffa:	e9 b1 fe ff ff       	jmp    c0001eb0 <intr_exit>

c0001fff <intr0x0centry>:
intr0x0centry():
c0001fff:	6a 00                	push   $0x0
c0002001:	1e                   	push   %ds
c0002002:	06                   	push   %es
c0002003:	0f a0                	push   %fs
c0002005:	0f a8                	push   %gs
c0002007:	60                   	pusha  
c0002008:	b0 20                	mov    $0x20,%al
c000200a:	e6 a0                	out    %al,$0xa0
c000200c:	e6 20                	out    %al,$0x20
c000200e:	6a 0c                	push   $0xc
c0002010:	ff 15 70 98 00 c0    	call   *0xc0009870
c0002016:	e9 95 fe ff ff       	jmp    c0001eb0 <intr_exit>

c000201b <intr0x0dentry>:
intr0x0dentry():
c000201b:	90                   	nop
c000201c:	1e                   	push   %ds
c000201d:	06                   	push   %es
c000201e:	0f a0                	push   %fs
c0002020:	0f a8                	push   %gs
c0002022:	60                   	pusha  
c0002023:	b0 20                	mov    $0x20,%al
c0002025:	e6 a0                	out    %al,$0xa0
c0002027:	e6 20                	out    %al,$0x20
c0002029:	6a 0d                	push   $0xd
c000202b:	ff 15 74 98 00 c0    	call   *0xc0009874
c0002031:	e9 7a fe ff ff       	jmp    c0001eb0 <intr_exit>

c0002036 <intr0x0eentry>:
intr0x0eentry():
c0002036:	90                   	nop
c0002037:	1e                   	push   %ds
c0002038:	06                   	push   %es
c0002039:	0f a0                	push   %fs
c000203b:	0f a8                	push   %gs
c000203d:	60                   	pusha  
c000203e:	b0 20                	mov    $0x20,%al
c0002040:	e6 a0                	out    %al,$0xa0
c0002042:	e6 20                	out    %al,$0x20
c0002044:	6a 0e                	push   $0xe
c0002046:	ff 15 78 98 00 c0    	call   *0xc0009878
c000204c:	e9 5f fe ff ff       	jmp    c0001eb0 <intr_exit>

c0002051 <intr0x0fentry>:
intr0x0fentry():
c0002051:	6a 00                	push   $0x0
c0002053:	1e                   	push   %ds
c0002054:	06                   	push   %es
c0002055:	0f a0                	push   %fs
c0002057:	0f a8                	push   %gs
c0002059:	60                   	pusha  
c000205a:	b0 20                	mov    $0x20,%al
c000205c:	e6 a0                	out    %al,$0xa0
c000205e:	e6 20                	out    %al,$0x20
c0002060:	6a 0f                	push   $0xf
c0002062:	ff 15 7c 98 00 c0    	call   *0xc000987c
c0002068:	e9 43 fe ff ff       	jmp    c0001eb0 <intr_exit>

c000206d <intr0x10entry>:
intr0x10entry():
c000206d:	6a 00                	push   $0x0
c000206f:	1e                   	push   %ds
c0002070:	06                   	push   %es
c0002071:	0f a0                	push   %fs
c0002073:	0f a8                	push   %gs
c0002075:	60                   	pusha  
c0002076:	b0 20                	mov    $0x20,%al
c0002078:	e6 a0                	out    %al,$0xa0
c000207a:	e6 20                	out    %al,$0x20
c000207c:	6a 10                	push   $0x10
c000207e:	ff 15 80 98 00 c0    	call   *0xc0009880
c0002084:	e9 27 fe ff ff       	jmp    c0001eb0 <intr_exit>

c0002089 <intr0x11entry>:
intr0x11entry():
c0002089:	90                   	nop
c000208a:	1e                   	push   %ds
c000208b:	06                   	push   %es
c000208c:	0f a0                	push   %fs
c000208e:	0f a8                	push   %gs
c0002090:	60                   	pusha  
c0002091:	b0 20                	mov    $0x20,%al
c0002093:	e6 a0                	out    %al,$0xa0
c0002095:	e6 20                	out    %al,$0x20
c0002097:	6a 11                	push   $0x11
c0002099:	ff 15 84 98 00 c0    	call   *0xc0009884
c000209f:	e9 0c fe ff ff       	jmp    c0001eb0 <intr_exit>

c00020a4 <intr0x12entry>:
intr0x12entry():
c00020a4:	6a 00                	push   $0x0
c00020a6:	1e                   	push   %ds
c00020a7:	06                   	push   %es
c00020a8:	0f a0                	push   %fs
c00020aa:	0f a8                	push   %gs
c00020ac:	60                   	pusha  
c00020ad:	b0 20                	mov    $0x20,%al
c00020af:	e6 a0                	out    %al,$0xa0
c00020b1:	e6 20                	out    %al,$0x20
c00020b3:	6a 12                	push   $0x12
c00020b5:	ff 15 88 98 00 c0    	call   *0xc0009888
c00020bb:	e9 f0 fd ff ff       	jmp    c0001eb0 <intr_exit>

c00020c0 <intr0x13entry>:
intr0x13entry():
c00020c0:	6a 00                	push   $0x0
c00020c2:	1e                   	push   %ds
c00020c3:	06                   	push   %es
c00020c4:	0f a0                	push   %fs
c00020c6:	0f a8                	push   %gs
c00020c8:	60                   	pusha  
c00020c9:	b0 20                	mov    $0x20,%al
c00020cb:	e6 a0                	out    %al,$0xa0
c00020cd:	e6 20                	out    %al,$0x20
c00020cf:	6a 13                	push   $0x13
c00020d1:	ff 15 8c 98 00 c0    	call   *0xc000988c
c00020d7:	e9 d4 fd ff ff       	jmp    c0001eb0 <intr_exit>

c00020dc <intr0x14entry>:
intr0x14entry():
c00020dc:	6a 00                	push   $0x0
c00020de:	1e                   	push   %ds
c00020df:	06                   	push   %es
c00020e0:	0f a0                	push   %fs
c00020e2:	0f a8                	push   %gs
c00020e4:	60                   	pusha  
c00020e5:	b0 20                	mov    $0x20,%al
c00020e7:	e6 a0                	out    %al,$0xa0
c00020e9:	e6 20                	out    %al,$0x20
c00020eb:	6a 14                	push   $0x14
c00020ed:	ff 15 90 98 00 c0    	call   *0xc0009890
c00020f3:	e9 b8 fd ff ff       	jmp    c0001eb0 <intr_exit>

c00020f8 <intr0x15entry>:
intr0x15entry():
c00020f8:	6a 00                	push   $0x0
c00020fa:	1e                   	push   %ds
c00020fb:	06                   	push   %es
c00020fc:	0f a0                	push   %fs
c00020fe:	0f a8                	push   %gs
c0002100:	60                   	pusha  
c0002101:	b0 20                	mov    $0x20,%al
c0002103:	e6 a0                	out    %al,$0xa0
c0002105:	e6 20                	out    %al,$0x20
c0002107:	6a 15                	push   $0x15
c0002109:	ff 15 94 98 00 c0    	call   *0xc0009894
c000210f:	e9 9c fd ff ff       	jmp    c0001eb0 <intr_exit>

c0002114 <intr0x16entry>:
intr0x16entry():
c0002114:	6a 00                	push   $0x0
c0002116:	1e                   	push   %ds
c0002117:	06                   	push   %es
c0002118:	0f a0                	push   %fs
c000211a:	0f a8                	push   %gs
c000211c:	60                   	pusha  
c000211d:	b0 20                	mov    $0x20,%al
c000211f:	e6 a0                	out    %al,$0xa0
c0002121:	e6 20                	out    %al,$0x20
c0002123:	6a 16                	push   $0x16
c0002125:	ff 15 98 98 00 c0    	call   *0xc0009898
c000212b:	e9 80 fd ff ff       	jmp    c0001eb0 <intr_exit>

c0002130 <intr0x17entry>:
intr0x17entry():
c0002130:	6a 00                	push   $0x0
c0002132:	1e                   	push   %ds
c0002133:	06                   	push   %es
c0002134:	0f a0                	push   %fs
c0002136:	0f a8                	push   %gs
c0002138:	60                   	pusha  
c0002139:	b0 20                	mov    $0x20,%al
c000213b:	e6 a0                	out    %al,$0xa0
c000213d:	e6 20                	out    %al,$0x20
c000213f:	6a 17                	push   $0x17
c0002141:	ff 15 9c 98 00 c0    	call   *0xc000989c
c0002147:	e9 64 fd ff ff       	jmp    c0001eb0 <intr_exit>

c000214c <intr0x18entry>:
intr0x18entry():
c000214c:	90                   	nop
c000214d:	1e                   	push   %ds
c000214e:	06                   	push   %es
c000214f:	0f a0                	push   %fs
c0002151:	0f a8                	push   %gs
c0002153:	60                   	pusha  
c0002154:	b0 20                	mov    $0x20,%al
c0002156:	e6 a0                	out    %al,$0xa0
c0002158:	e6 20                	out    %al,$0x20
c000215a:	6a 18                	push   $0x18
c000215c:	ff 15 a0 98 00 c0    	call   *0xc00098a0
c0002162:	e9 49 fd ff ff       	jmp    c0001eb0 <intr_exit>

c0002167 <intr0x19entry>:
intr0x19entry():
c0002167:	6a 00                	push   $0x0
c0002169:	1e                   	push   %ds
c000216a:	06                   	push   %es
c000216b:	0f a0                	push   %fs
c000216d:	0f a8                	push   %gs
c000216f:	60                   	pusha  
c0002170:	b0 20                	mov    $0x20,%al
c0002172:	e6 a0                	out    %al,$0xa0
c0002174:	e6 20                	out    %al,$0x20
c0002176:	6a 19                	push   $0x19
c0002178:	ff 15 a4 98 00 c0    	call   *0xc00098a4
c000217e:	e9 2d fd ff ff       	jmp    c0001eb0 <intr_exit>

c0002183 <intr0x1aentry>:
intr0x1aentry():
c0002183:	90                   	nop
c0002184:	1e                   	push   %ds
c0002185:	06                   	push   %es
c0002186:	0f a0                	push   %fs
c0002188:	0f a8                	push   %gs
c000218a:	60                   	pusha  
c000218b:	b0 20                	mov    $0x20,%al
c000218d:	e6 a0                	out    %al,$0xa0
c000218f:	e6 20                	out    %al,$0x20
c0002191:	6a 1a                	push   $0x1a
c0002193:	ff 15 a8 98 00 c0    	call   *0xc00098a8
c0002199:	e9 12 fd ff ff       	jmp    c0001eb0 <intr_exit>

c000219e <intr0x1bentry>:
intr0x1bentry():
c000219e:	90                   	nop
c000219f:	1e                   	push   %ds
c00021a0:	06                   	push   %es
c00021a1:	0f a0                	push   %fs
c00021a3:	0f a8                	push   %gs
c00021a5:	60                   	pusha  
c00021a6:	b0 20                	mov    $0x20,%al
c00021a8:	e6 a0                	out    %al,$0xa0
c00021aa:	e6 20                	out    %al,$0x20
c00021ac:	6a 1b                	push   $0x1b
c00021ae:	ff 15 ac 98 00 c0    	call   *0xc00098ac
c00021b4:	e9 f7 fc ff ff       	jmp    c0001eb0 <intr_exit>

c00021b9 <intr0x1centry>:
intr0x1centry():
c00021b9:	6a 00                	push   $0x0
c00021bb:	1e                   	push   %ds
c00021bc:	06                   	push   %es
c00021bd:	0f a0                	push   %fs
c00021bf:	0f a8                	push   %gs
c00021c1:	60                   	pusha  
c00021c2:	b0 20                	mov    $0x20,%al
c00021c4:	e6 a0                	out    %al,$0xa0
c00021c6:	e6 20                	out    %al,$0x20
c00021c8:	6a 1c                	push   $0x1c
c00021ca:	ff 15 b0 98 00 c0    	call   *0xc00098b0
c00021d0:	e9 db fc ff ff       	jmp    c0001eb0 <intr_exit>

c00021d5 <intr0x1dentry>:
intr0x1dentry():
c00021d5:	90                   	nop
c00021d6:	1e                   	push   %ds
c00021d7:	06                   	push   %es
c00021d8:	0f a0                	push   %fs
c00021da:	0f a8                	push   %gs
c00021dc:	60                   	pusha  
c00021dd:	b0 20                	mov    $0x20,%al
c00021df:	e6 a0                	out    %al,$0xa0
c00021e1:	e6 20                	out    %al,$0x20
c00021e3:	6a 1d                	push   $0x1d
c00021e5:	ff 15 b4 98 00 c0    	call   *0xc00098b4
c00021eb:	e9 c0 fc ff ff       	jmp    c0001eb0 <intr_exit>

c00021f0 <intr0x1eentry>:
intr0x1eentry():
c00021f0:	90                   	nop
c00021f1:	1e                   	push   %ds
c00021f2:	06                   	push   %es
c00021f3:	0f a0                	push   %fs
c00021f5:	0f a8                	push   %gs
c00021f7:	60                   	pusha  
c00021f8:	b0 20                	mov    $0x20,%al
c00021fa:	e6 a0                	out    %al,$0xa0
c00021fc:	e6 20                	out    %al,$0x20
c00021fe:	6a 1e                	push   $0x1e
c0002200:	ff 15 b8 98 00 c0    	call   *0xc00098b8
c0002206:	e9 a5 fc ff ff       	jmp    c0001eb0 <intr_exit>

c000220b <intr0x1fentry>:
intr0x1fentry():
c000220b:	6a 00                	push   $0x0
c000220d:	1e                   	push   %ds
c000220e:	06                   	push   %es
c000220f:	0f a0                	push   %fs
c0002211:	0f a8                	push   %gs
c0002213:	60                   	pusha  
c0002214:	b0 20                	mov    $0x20,%al
c0002216:	e6 a0                	out    %al,$0xa0
c0002218:	e6 20                	out    %al,$0x20
c000221a:	6a 1f                	push   $0x1f
c000221c:	ff 15 bc 98 00 c0    	call   *0xc00098bc
c0002222:	e9 89 fc ff ff       	jmp    c0001eb0 <intr_exit>

c0002227 <intr0x20entry>:
intr0x20entry():
c0002227:	6a 00                	push   $0x0
c0002229:	1e                   	push   %ds
c000222a:	06                   	push   %es
c000222b:	0f a0                	push   %fs
c000222d:	0f a8                	push   %gs
c000222f:	60                   	pusha  
c0002230:	b0 20                	mov    $0x20,%al
c0002232:	e6 a0                	out    %al,$0xa0
c0002234:	e6 20                	out    %al,$0x20
c0002236:	6a 20                	push   $0x20
c0002238:	ff 15 c0 98 00 c0    	call   *0xc00098c0
c000223e:	e9 6d fc ff ff       	jmp    c0001eb0 <intr_exit>

c0002243 <intr0x21entry>:
intr0x21entry():
c0002243:	6a 00                	push   $0x0
c0002245:	1e                   	push   %ds
c0002246:	06                   	push   %es
c0002247:	0f a0                	push   %fs
c0002249:	0f a8                	push   %gs
c000224b:	60                   	pusha  
c000224c:	b0 20                	mov    $0x20,%al
c000224e:	e6 a0                	out    %al,$0xa0
c0002250:	e6 20                	out    %al,$0x20
c0002252:	6a 21                	push   $0x21
c0002254:	ff 15 c4 98 00 c0    	call   *0xc00098c4
c000225a:	e9 51 fc ff ff       	jmp    c0001eb0 <intr_exit>

c000225f <intr0x22entry>:
intr0x22entry():
c000225f:	6a 00                	push   $0x0
c0002261:	1e                   	push   %ds
c0002262:	06                   	push   %es
c0002263:	0f a0                	push   %fs
c0002265:	0f a8                	push   %gs
c0002267:	60                   	pusha  
c0002268:	b0 20                	mov    $0x20,%al
c000226a:	e6 a0                	out    %al,$0xa0
c000226c:	e6 20                	out    %al,$0x20
c000226e:	6a 22                	push   $0x22
c0002270:	ff 15 c8 98 00 c0    	call   *0xc00098c8
c0002276:	e9 35 fc ff ff       	jmp    c0001eb0 <intr_exit>

c000227b <intr0x23entry>:
intr0x23entry():
c000227b:	6a 00                	push   $0x0
c000227d:	1e                   	push   %ds
c000227e:	06                   	push   %es
c000227f:	0f a0                	push   %fs
c0002281:	0f a8                	push   %gs
c0002283:	60                   	pusha  
c0002284:	b0 20                	mov    $0x20,%al
c0002286:	e6 a0                	out    %al,$0xa0
c0002288:	e6 20                	out    %al,$0x20
c000228a:	6a 23                	push   $0x23
c000228c:	ff 15 cc 98 00 c0    	call   *0xc00098cc
c0002292:	e9 19 fc ff ff       	jmp    c0001eb0 <intr_exit>

c0002297 <intr0x24entry>:
intr0x24entry():
c0002297:	6a 00                	push   $0x0
c0002299:	1e                   	push   %ds
c000229a:	06                   	push   %es
c000229b:	0f a0                	push   %fs
c000229d:	0f a8                	push   %gs
c000229f:	60                   	pusha  
c00022a0:	b0 20                	mov    $0x20,%al
c00022a2:	e6 a0                	out    %al,$0xa0
c00022a4:	e6 20                	out    %al,$0x20
c00022a6:	6a 24                	push   $0x24
c00022a8:	ff 15 d0 98 00 c0    	call   *0xc00098d0
c00022ae:	e9 fd fb ff ff       	jmp    c0001eb0 <intr_exit>

c00022b3 <intr0x25entry>:
intr0x25entry():
c00022b3:	6a 00                	push   $0x0
c00022b5:	1e                   	push   %ds
c00022b6:	06                   	push   %es
c00022b7:	0f a0                	push   %fs
c00022b9:	0f a8                	push   %gs
c00022bb:	60                   	pusha  
c00022bc:	b0 20                	mov    $0x20,%al
c00022be:	e6 a0                	out    %al,$0xa0
c00022c0:	e6 20                	out    %al,$0x20
c00022c2:	6a 25                	push   $0x25
c00022c4:	ff 15 d4 98 00 c0    	call   *0xc00098d4
c00022ca:	e9 e1 fb ff ff       	jmp    c0001eb0 <intr_exit>

c00022cf <intr0x26entry>:
intr0x26entry():
c00022cf:	6a 00                	push   $0x0
c00022d1:	1e                   	push   %ds
c00022d2:	06                   	push   %es
c00022d3:	0f a0                	push   %fs
c00022d5:	0f a8                	push   %gs
c00022d7:	60                   	pusha  
c00022d8:	b0 20                	mov    $0x20,%al
c00022da:	e6 a0                	out    %al,$0xa0
c00022dc:	e6 20                	out    %al,$0x20
c00022de:	6a 26                	push   $0x26
c00022e0:	ff 15 d8 98 00 c0    	call   *0xc00098d8
c00022e6:	e9 c5 fb ff ff       	jmp    c0001eb0 <intr_exit>

c00022eb <intr0x27entry>:
intr0x27entry():
c00022eb:	6a 00                	push   $0x0
c00022ed:	1e                   	push   %ds
c00022ee:	06                   	push   %es
c00022ef:	0f a0                	push   %fs
c00022f1:	0f a8                	push   %gs
c00022f3:	60                   	pusha  
c00022f4:	b0 20                	mov    $0x20,%al
c00022f6:	e6 a0                	out    %al,$0xa0
c00022f8:	e6 20                	out    %al,$0x20
c00022fa:	6a 27                	push   $0x27
c00022fc:	ff 15 dc 98 00 c0    	call   *0xc00098dc
c0002302:	e9 a9 fb ff ff       	jmp    c0001eb0 <intr_exit>

c0002307 <intr0x28entry>:
intr0x28entry():
c0002307:	6a 00                	push   $0x0
c0002309:	1e                   	push   %ds
c000230a:	06                   	push   %es
c000230b:	0f a0                	push   %fs
c000230d:	0f a8                	push   %gs
c000230f:	60                   	pusha  
c0002310:	b0 20                	mov    $0x20,%al
c0002312:	e6 a0                	out    %al,$0xa0
c0002314:	e6 20                	out    %al,$0x20
c0002316:	6a 28                	push   $0x28
c0002318:	ff 15 e0 98 00 c0    	call   *0xc00098e0
c000231e:	e9 8d fb ff ff       	jmp    c0001eb0 <intr_exit>

c0002323 <intr0x29entry>:
intr0x29entry():
c0002323:	6a 00                	push   $0x0
c0002325:	1e                   	push   %ds
c0002326:	06                   	push   %es
c0002327:	0f a0                	push   %fs
c0002329:	0f a8                	push   %gs
c000232b:	60                   	pusha  
c000232c:	b0 20                	mov    $0x20,%al
c000232e:	e6 a0                	out    %al,$0xa0
c0002330:	e6 20                	out    %al,$0x20
c0002332:	6a 29                	push   $0x29
c0002334:	ff 15 e4 98 00 c0    	call   *0xc00098e4
c000233a:	e9 71 fb ff ff       	jmp    c0001eb0 <intr_exit>

c000233f <intr0x2aentry>:
intr0x2aentry():
c000233f:	6a 00                	push   $0x0
c0002341:	1e                   	push   %ds
c0002342:	06                   	push   %es
c0002343:	0f a0                	push   %fs
c0002345:	0f a8                	push   %gs
c0002347:	60                   	pusha  
c0002348:	b0 20                	mov    $0x20,%al
c000234a:	e6 a0                	out    %al,$0xa0
c000234c:	e6 20                	out    %al,$0x20
c000234e:	6a 2a                	push   $0x2a
c0002350:	ff 15 e8 98 00 c0    	call   *0xc00098e8
c0002356:	e9 55 fb ff ff       	jmp    c0001eb0 <intr_exit>

c000235b <intr0x2bentry>:
intr0x2bentry():
c000235b:	6a 00                	push   $0x0
c000235d:	1e                   	push   %ds
c000235e:	06                   	push   %es
c000235f:	0f a0                	push   %fs
c0002361:	0f a8                	push   %gs
c0002363:	60                   	pusha  
c0002364:	b0 20                	mov    $0x20,%al
c0002366:	e6 a0                	out    %al,$0xa0
c0002368:	e6 20                	out    %al,$0x20
c000236a:	6a 2b                	push   $0x2b
c000236c:	ff 15 ec 98 00 c0    	call   *0xc00098ec
c0002372:	e9 39 fb ff ff       	jmp    c0001eb0 <intr_exit>

c0002377 <intr0x2centry>:
intr0x2centry():
c0002377:	6a 00                	push   $0x0
c0002379:	1e                   	push   %ds
c000237a:	06                   	push   %es
c000237b:	0f a0                	push   %fs
c000237d:	0f a8                	push   %gs
c000237f:	60                   	pusha  
c0002380:	b0 20                	mov    $0x20,%al
c0002382:	e6 a0                	out    %al,$0xa0
c0002384:	e6 20                	out    %al,$0x20
c0002386:	6a 2c                	push   $0x2c
c0002388:	ff 15 f0 98 00 c0    	call   *0xc00098f0
c000238e:	e9 1d fb ff ff       	jmp    c0001eb0 <intr_exit>

c0002393 <intr0x2dentry>:
intr0x2dentry():
c0002393:	6a 00                	push   $0x0
c0002395:	1e                   	push   %ds
c0002396:	06                   	push   %es
c0002397:	0f a0                	push   %fs
c0002399:	0f a8                	push   %gs
c000239b:	60                   	pusha  
c000239c:	b0 20                	mov    $0x20,%al
c000239e:	e6 a0                	out    %al,$0xa0
c00023a0:	e6 20                	out    %al,$0x20
c00023a2:	6a 2d                	push   $0x2d
c00023a4:	ff 15 f4 98 00 c0    	call   *0xc00098f4
c00023aa:	e9 01 fb ff ff       	jmp    c0001eb0 <intr_exit>

c00023af <intr0x2eentry>:
intr0x2eentry():
c00023af:	6a 00                	push   $0x0
c00023b1:	1e                   	push   %ds
c00023b2:	06                   	push   %es
c00023b3:	0f a0                	push   %fs
c00023b5:	0f a8                	push   %gs
c00023b7:	60                   	pusha  
c00023b8:	b0 20                	mov    $0x20,%al
c00023ba:	e6 a0                	out    %al,$0xa0
c00023bc:	e6 20                	out    %al,$0x20
c00023be:	6a 2e                	push   $0x2e
c00023c0:	ff 15 f8 98 00 c0    	call   *0xc00098f8
c00023c6:	e9 e5 fa ff ff       	jmp    c0001eb0 <intr_exit>

c00023cb <intr0x2fentry>:
intr0x2fentry():
c00023cb:	6a 00                	push   $0x0
c00023cd:	1e                   	push   %ds
c00023ce:	06                   	push   %es
c00023cf:	0f a0                	push   %fs
c00023d1:	0f a8                	push   %gs
c00023d3:	60                   	pusha  
c00023d4:	b0 20                	mov    $0x20,%al
c00023d6:	e6 a0                	out    %al,$0xa0
c00023d8:	e6 20                	out    %al,$0x20
c00023da:	6a 2f                	push   $0x2f
c00023dc:	ff 15 fc 98 00 c0    	call   *0xc00098fc
c00023e2:	e9 c9 fa ff ff       	jmp    c0001eb0 <intr_exit>

c00023e7 <syscall_handler>:
syscall_handler():
c00023e7:	6a 00                	push   $0x0
c00023e9:	1e                   	push   %ds
c00023ea:	06                   	push   %es
c00023eb:	0f a0                	push   %fs
c00023ed:	0f a8                	push   %gs
c00023ef:	60                   	pusha  
c00023f0:	68 80 00 00 00       	push   $0x80
c00023f5:	52                   	push   %edx
c00023f6:	51                   	push   %ecx
c00023f7:	53                   	push   %ebx
c00023f8:	ff 14 85 60 9c 00 c0 	call   *-0x3fff63a0(,%eax,4)
c00023ff:	83 c4 0c             	add    $0xc,%esp
c0002402:	89 44 24 20          	mov    %eax,0x20(%esp)
c0002406:	e9 a5 fa ff ff       	jmp    c0001eb0 <intr_exit>
c000240b:	66 90                	xchg   %ax,%ax
c000240d:	66 90                	xchg   %ax,%ax
c000240f:	90                   	nop

c0002410 <put_str>:
put_str():
c0002410:	53                   	push   %ebx
c0002411:	51                   	push   %ecx
c0002412:	31 c9                	xor    %ecx,%ecx
c0002414:	8b 5c 24 0c          	mov    0xc(%esp),%ebx

c0002418 <put_str.goon>:
put_str.goon():
c0002418:	8a 0b                	mov    (%ebx),%cl
c000241a:	80 f9 00             	cmp    $0x0,%cl
c000241d:	74 0c                	je     c000242b <put_str.str_over>
c000241f:	51                   	push   %ecx
c0002420:	e8 09 00 00 00       	call   c000242e <put_char>
c0002425:	83 c4 04             	add    $0x4,%esp
c0002428:	43                   	inc    %ebx
c0002429:	eb ed                	jmp    c0002418 <put_str.goon>

c000242b <put_str.str_over>:
put_str.str_over():
c000242b:	59                   	pop    %ecx
c000242c:	5b                   	pop    %ebx
c000242d:	c3                   	ret    

c000242e <put_char>:
put_char():
c000242e:	60                   	pusha  
c000242f:	66 b8 18 00          	mov    $0x18,%ax
c0002433:	8e e8                	mov    %eax,%gs
c0002435:	66 ba d4 03          	mov    $0x3d4,%dx
c0002439:	b0 0e                	mov    $0xe,%al
c000243b:	ee                   	out    %al,(%dx)
c000243c:	66 ba d5 03          	mov    $0x3d5,%dx
c0002440:	ec                   	in     (%dx),%al
c0002441:	88 c4                	mov    %al,%ah
c0002443:	66 ba d4 03          	mov    $0x3d4,%dx
c0002447:	b0 0f                	mov    $0xf,%al
c0002449:	ee                   	out    %al,(%dx)
c000244a:	66 ba d5 03          	mov    $0x3d5,%dx
c000244e:	ec                   	in     (%dx),%al
c000244f:	66 89 c3             	mov    %ax,%bx
c0002452:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0002456:	80 f9 0d             	cmp    $0xd,%cl
c0002459:	74 3c                	je     c0002497 <put_char.is_carriage_return>
c000245b:	80 f9 0a             	cmp    $0xa,%cl
c000245e:	74 37                	je     c0002497 <put_char.is_carriage_return>
c0002460:	80 f9 08             	cmp    $0x8,%cl
c0002463:	74 02                	je     c0002467 <put_char.is_backspace>
c0002465:	eb 16                	jmp    c000247d <put_char.put_other>

c0002467 <put_char.is_backspace>:
put_char.is_backspace():
c0002467:	66 4b                	dec    %bx
c0002469:	66 d1 e3             	shl    %bx
c000246c:	65 67 c6 07 20       	movb   $0x20,%gs:(%bx)
c0002471:	66 43                	inc    %bx
c0002473:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c0002478:	66 d1 eb             	shr    %bx
c000247b:	eb 60                	jmp    c00024dd <put_char.set_cursor>

c000247d <put_char.put_other>:
put_char.put_other():
c000247d:	66 d1 e3             	shl    %bx
c0002480:	65 67 88 0f          	mov    %cl,%gs:(%bx)
c0002484:	66 43                	inc    %bx
c0002486:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c000248b:	66 d1 eb             	shr    %bx
c000248e:	66 43                	inc    %bx
c0002490:	66 81 fb d0 07       	cmp    $0x7d0,%bx
c0002495:	7c 46                	jl     c00024dd <put_char.set_cursor>

c0002497 <put_char.is_carriage_return>:
put_char.is_line_feed():
c0002497:	66 31 d2             	xor    %dx,%dx
c000249a:	66 89 d8             	mov    %bx,%ax
c000249d:	66 be 50 00          	mov    $0x50,%si
c00024a1:	66 f7 f6             	div    %si
c00024a4:	66 29 d3             	sub    %dx,%bx

c00024a7 <put_char.is_carriage_return_end>:
put_char.is_carriage_return_end():
c00024a7:	66 83 c3 50          	add    $0x50,%bx
c00024ab:	66 81 fb d0 07       	cmp    $0x7d0,%bx

c00024b0 <put_char.is_line_feed_end>:
put_char.is_line_feed_end():
c00024b0:	7c 2b                	jl     c00024dd <put_char.set_cursor>

c00024b2 <put_char.roll_screen>:
put_char.roll_screen():
c00024b2:	fc                   	cld    
c00024b3:	b9 c0 03 00 00       	mov    $0x3c0,%ecx
c00024b8:	be a0 80 0b c0       	mov    $0xc00b80a0,%esi
c00024bd:	bf 00 80 0b c0       	mov    $0xc00b8000,%edi
c00024c2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
c00024c4:	bb 00 0f 00 00       	mov    $0xf00,%ebx
c00024c9:	b9 50 00 00 00       	mov    $0x50,%ecx

c00024ce <put_char.cls>:
put_char.cls():
c00024ce:	65 66 c7 03 20 07    	movw   $0x720,%gs:(%ebx)
c00024d4:	83 c3 02             	add    $0x2,%ebx
c00024d7:	e2 f5                	loop   c00024ce <put_char.cls>
c00024d9:	66 bb 80 07          	mov    $0x780,%bx

c00024dd <put_char.set_cursor>:
put_char.set_cursor():
c00024dd:	66 ba d4 03          	mov    $0x3d4,%dx
c00024e1:	b0 0e                	mov    $0xe,%al
c00024e3:	ee                   	out    %al,(%dx)
c00024e4:	66 ba d5 03          	mov    $0x3d5,%dx
c00024e8:	88 f8                	mov    %bh,%al
c00024ea:	ee                   	out    %al,(%dx)
c00024eb:	66 ba d4 03          	mov    $0x3d4,%dx
c00024ef:	b0 0f                	mov    $0xf,%al
c00024f1:	ee                   	out    %al,(%dx)
c00024f2:	66 ba d5 03          	mov    $0x3d5,%dx
c00024f6:	88 d8                	mov    %bl,%al
c00024f8:	ee                   	out    %al,(%dx)

c00024f9 <put_char.put_char_done>:
put_char.put_char_done():
c00024f9:	61                   	popa   
c00024fa:	c3                   	ret    

c00024fb <put_int>:
put_int():
c00024fb:	60                   	pusha  
c00024fc:	89 e5                	mov    %esp,%ebp
c00024fe:	8b 45 24             	mov    0x24(%ebp),%eax
c0002501:	89 c2                	mov    %eax,%edx
c0002503:	bf 07 00 00 00       	mov    $0x7,%edi
c0002508:	b9 08 00 00 00       	mov    $0x8,%ecx
c000250d:	bb c0 90 00 c0       	mov    $0xc00090c0,%ebx

c0002512 <put_int.16based_4bits>:
put_int.16based_4bits():
c0002512:	83 e2 0f             	and    $0xf,%edx
c0002515:	83 fa 09             	cmp    $0x9,%edx
c0002518:	7f 05                	jg     c000251f <put_int.is_A2F>
c000251a:	83 c2 30             	add    $0x30,%edx
c000251d:	eb 06                	jmp    c0002525 <put_int.store>

c000251f <put_int.is_A2F>:
put_int.is_A2F():
c000251f:	83 ea 0a             	sub    $0xa,%edx
c0002522:	83 c2 41             	add    $0x41,%edx

c0002525 <put_int.store>:
put_int.store():
c0002525:	88 14 3b             	mov    %dl,(%ebx,%edi,1)
c0002528:	4f                   	dec    %edi
c0002529:	c1 e8 04             	shr    $0x4,%eax
c000252c:	89 c2                	mov    %eax,%edx
c000252e:	e2 e2                	loop   c0002512 <put_int.16based_4bits>

c0002530 <put_int.ready_to_print>:
put_int.ready_to_print():
c0002530:	47                   	inc    %edi

c0002531 <put_int.skip_prefix_0>:
put_int.skip_prefix_0():
c0002531:	83 ff 08             	cmp    $0x8,%edi
c0002534:	74 0f                	je     c0002545 <put_int.full0>

c0002536 <put_int.go_on_skip>:
put_int.go_on_skip():
c0002536:	8a 8f c0 90 00 c0    	mov    -0x3fff6f40(%edi),%cl
c000253c:	47                   	inc    %edi
c000253d:	80 f9 30             	cmp    $0x30,%cl
c0002540:	74 ef                	je     c0002531 <put_int.skip_prefix_0>
c0002542:	4f                   	dec    %edi
c0002543:	eb 02                	jmp    c0002547 <put_int.put_each_num>

c0002545 <put_int.full0>:
put_int.full0():
c0002545:	b1 30                	mov    $0x30,%cl

c0002547 <put_int.put_each_num>:
put_int.put_each_num():
c0002547:	51                   	push   %ecx
c0002548:	e8 e1 fe ff ff       	call   c000242e <put_char>
c000254d:	83 c4 04             	add    $0x4,%esp
c0002550:	47                   	inc    %edi
c0002551:	8a 8f c0 90 00 c0    	mov    -0x3fff6f40(%edi),%cl
c0002557:	83 ff 08             	cmp    $0x8,%edi
c000255a:	7c eb                	jl     c0002547 <put_int.put_each_num>
c000255c:	61                   	popa   
c000255d:	c3                   	ret    

c000255e <set_cursor>:
set_cursor():
c000255e:	60                   	pusha  
c000255f:	66 8b 5c 24 24       	mov    0x24(%esp),%bx
c0002564:	66 ba d4 03          	mov    $0x3d4,%dx
c0002568:	b0 0e                	mov    $0xe,%al
c000256a:	ee                   	out    %al,(%dx)
c000256b:	66 ba d5 03          	mov    $0x3d5,%dx
c000256f:	88 f8                	mov    %bh,%al
c0002571:	ee                   	out    %al,(%dx)
c0002572:	66 ba d4 03          	mov    $0x3d4,%dx
c0002576:	b0 0f                	mov    $0xf,%al
c0002578:	ee                   	out    %al,(%dx)
c0002579:	66 ba d5 03          	mov    $0x3d5,%dx
c000257d:	88 d8                	mov    %bl,%al
c000257f:	ee                   	out    %al,(%dx)
c0002580:	61                   	popa   
c0002581:	c3                   	ret    

c0002582 <panic_spin>:
panic_spin():
/work/x86_os_my/kernel/debug.c:10
/* 打印文件名,行号,函数名,条件并使程序悬停 */
void panic_spin(char* filename,	       \
	        int line,	       \
		const char* func,      \
		const char* condition) \
{
c0002582:	55                   	push   %ebp
c0002583:	89 e5                	mov    %esp,%ebp
c0002585:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/debug.c:11
   intr_disable();	// 因为有时候会单独调用panic_spin,所以在此处关中断。
c0002588:	e8 5b f6 ff ff       	call   c0001be8 <intr_disable>
/work/x86_os_my/kernel/debug.c:12
   put_str("\n\n\n!!!!! error !!!!!\n");
c000258d:	83 ec 0c             	sub    $0xc,%esp
c0002590:	68 40 69 00 c0       	push   $0xc0006940
c0002595:	e8 76 fe ff ff       	call   c0002410 <put_str>
c000259a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:13
   put_str("filename:");put_str(filename);put_str("\n");
c000259d:	83 ec 0c             	sub    $0xc,%esp
c00025a0:	68 56 69 00 c0       	push   $0xc0006956
c00025a5:	e8 66 fe ff ff       	call   c0002410 <put_str>
c00025aa:	83 c4 10             	add    $0x10,%esp
c00025ad:	83 ec 0c             	sub    $0xc,%esp
c00025b0:	ff 75 08             	pushl  0x8(%ebp)
c00025b3:	e8 58 fe ff ff       	call   c0002410 <put_str>
c00025b8:	83 c4 10             	add    $0x10,%esp
c00025bb:	83 ec 0c             	sub    $0xc,%esp
c00025be:	68 60 69 00 c0       	push   $0xc0006960
c00025c3:	e8 48 fe ff ff       	call   c0002410 <put_str>
c00025c8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:14
   put_str("line:0x");put_int(line);put_str("\n");
c00025cb:	83 ec 0c             	sub    $0xc,%esp
c00025ce:	68 62 69 00 c0       	push   $0xc0006962
c00025d3:	e8 38 fe ff ff       	call   c0002410 <put_str>
c00025d8:	83 c4 10             	add    $0x10,%esp
c00025db:	8b 45 0c             	mov    0xc(%ebp),%eax
c00025de:	83 ec 0c             	sub    $0xc,%esp
c00025e1:	50                   	push   %eax
c00025e2:	e8 14 ff ff ff       	call   c00024fb <put_int>
c00025e7:	83 c4 10             	add    $0x10,%esp
c00025ea:	83 ec 0c             	sub    $0xc,%esp
c00025ed:	68 60 69 00 c0       	push   $0xc0006960
c00025f2:	e8 19 fe ff ff       	call   c0002410 <put_str>
c00025f7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:15
   put_str("function:");put_str((char*)func);put_str("\n");
c00025fa:	83 ec 0c             	sub    $0xc,%esp
c00025fd:	68 6a 69 00 c0       	push   $0xc000696a
c0002602:	e8 09 fe ff ff       	call   c0002410 <put_str>
c0002607:	83 c4 10             	add    $0x10,%esp
c000260a:	83 ec 0c             	sub    $0xc,%esp
c000260d:	ff 75 10             	pushl  0x10(%ebp)
c0002610:	e8 fb fd ff ff       	call   c0002410 <put_str>
c0002615:	83 c4 10             	add    $0x10,%esp
c0002618:	83 ec 0c             	sub    $0xc,%esp
c000261b:	68 60 69 00 c0       	push   $0xc0006960
c0002620:	e8 eb fd ff ff       	call   c0002410 <put_str>
c0002625:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:16
   put_str("condition:");put_str((char*)condition);put_str("\n");
c0002628:	83 ec 0c             	sub    $0xc,%esp
c000262b:	68 74 69 00 c0       	push   $0xc0006974
c0002630:	e8 db fd ff ff       	call   c0002410 <put_str>
c0002635:	83 c4 10             	add    $0x10,%esp
c0002638:	83 ec 0c             	sub    $0xc,%esp
c000263b:	ff 75 14             	pushl  0x14(%ebp)
c000263e:	e8 cd fd ff ff       	call   c0002410 <put_str>
c0002643:	83 c4 10             	add    $0x10,%esp
c0002646:	83 ec 0c             	sub    $0xc,%esp
c0002649:	68 60 69 00 c0       	push   $0xc0006960
c000264e:	e8 bd fd ff ff       	call   c0002410 <put_str>
c0002653:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:17 (discriminator 1)
   while(1);
c0002656:	eb fe                	jmp    c0002656 <panic_spin+0xd4>

c0002658 <bitmap_init>:
bitmap_init():
/work/x86_os_my/lib/kernel/bitmap.c:16
	uint8_t* bits;				位图空间
};
*/

/* 将位图btmp初始化 */
void bitmap_init(struct bitmap* btmp) {
c0002658:	55                   	push   %ebp
c0002659:	89 e5                	mov    %esp,%ebp
c000265b:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/bitmap.c:17
	memset(btmp->bits, 0, btmp->btmp_bytes_len);   
c000265e:	8b 45 08             	mov    0x8(%ebp),%eax
c0002661:	8b 10                	mov    (%eax),%edx
c0002663:	8b 45 08             	mov    0x8(%ebp),%eax
c0002666:	8b 40 04             	mov    0x4(%eax),%eax
c0002669:	83 ec 04             	sub    $0x4,%esp
c000266c:	52                   	push   %edx
c000266d:	6a 00                	push   $0x0
c000266f:	50                   	push   %eax
c0002670:	e8 25 13 00 00       	call   c000399a <memset>
c0002675:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:18
}
c0002678:	90                   	nop
c0002679:	c9                   	leave  
c000267a:	c3                   	ret    

c000267b <bitmap_scan_test>:
bitmap_scan_test():
/work/x86_os_my/lib/kernel/bitmap.c:23

/* 判断bit_idx位是否为1
若为1则返回true
否则返回false */
bool bitmap_scan_test(struct bitmap* btmp, uint32_t bit_idx) {
c000267b:	55                   	push   %ebp
c000267c:	89 e5                	mov    %esp,%ebp
c000267e:	53                   	push   %ebx
c000267f:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:24
	uint32_t byte_idx = bit_idx / 8;    // 向下取整用于索引数组下标
c0002682:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002685:	c1 e8 03             	shr    $0x3,%eax
c0002688:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:25
	uint32_t bit_odd  = bit_idx % 8;    // 取余用于索引数组内的位
c000268b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000268e:	83 e0 07             	and    $0x7,%eax
c0002691:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:26
	return (btmp->bits[byte_idx] & (BITMAP_MASK << bit_odd));
c0002694:	8b 45 08             	mov    0x8(%ebp),%eax
c0002697:	8b 50 04             	mov    0x4(%eax),%edx
c000269a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000269d:	01 d0                	add    %edx,%eax
c000269f:	0f b6 00             	movzbl (%eax),%eax
c00026a2:	0f b6 d0             	movzbl %al,%edx
c00026a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00026a8:	bb 01 00 00 00       	mov    $0x1,%ebx
c00026ad:	89 c1                	mov    %eax,%ecx
c00026af:	d3 e3                	shl    %cl,%ebx
c00026b1:	89 d8                	mov    %ebx,%eax
c00026b3:	21 d0                	and    %edx,%eax
/work/x86_os_my/lib/kernel/bitmap.c:27
}
c00026b5:	83 c4 10             	add    $0x10,%esp
c00026b8:	5b                   	pop    %ebx
c00026b9:	5d                   	pop    %ebp
c00026ba:	c3                   	ret    

c00026bb <bitmap_scan>:
bitmap_scan():
/work/x86_os_my/lib/kernel/bitmap.c:32

/* 在位图中申请连续cnt个位
成功：返回其起始位下标
失败：返回-1 */
int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {
c00026bb:	55                   	push   %ebp
c00026bc:	89 e5                	mov    %esp,%ebp
c00026be:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/lib/kernel/bitmap.c:33
	uint32_t idx_byte = 0;	 // 用于记录空闲位所在的字节
c00026c1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:35
	/* 先逐字节比较,蛮力法 */
	while (( 0xff == btmp->bits[idx_byte]) && (idx_byte < btmp->btmp_bytes_len)) {
c00026c8:	eb 04                	jmp    c00026ce <bitmap_scan+0x13>
/work/x86_os_my/lib/kernel/bitmap.c:37
		/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */
		idx_byte++;
c00026ca:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:35
成功：返回其起始位下标
失败：返回-1 */
int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {
	uint32_t idx_byte = 0;	 // 用于记录空闲位所在的字节
	/* 先逐字节比较,蛮力法 */
	while (( 0xff == btmp->bits[idx_byte]) && (idx_byte < btmp->btmp_bytes_len)) {
c00026ce:	8b 45 08             	mov    0x8(%ebp),%eax
c00026d1:	8b 50 04             	mov    0x4(%eax),%edx
c00026d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00026d7:	01 d0                	add    %edx,%eax
c00026d9:	0f b6 00             	movzbl (%eax),%eax
c00026dc:	3c ff                	cmp    $0xff,%al
c00026de:	75 0a                	jne    c00026ea <bitmap_scan+0x2f>
/work/x86_os_my/lib/kernel/bitmap.c:35 (discriminator 1)
c00026e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00026e3:	8b 00                	mov    (%eax),%eax
c00026e5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00026e8:	77 e0                	ja     c00026ca <bitmap_scan+0xf>
/work/x86_os_my/lib/kernel/bitmap.c:39
		/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */
		idx_byte++;
	}
	ASSERT(idx_byte < btmp->btmp_bytes_len);	//这里应该是"<="
c00026ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00026ed:	8b 00                	mov    (%eax),%eax
c00026ef:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00026f2:	77 19                	ja     c000270d <bitmap_scan+0x52>
/work/x86_os_my/lib/kernel/bitmap.c:39 (discriminator 1)
c00026f4:	68 80 69 00 c0       	push   $0xc0006980
c00026f9:	68 d4 69 00 c0       	push   $0xc00069d4
c00026fe:	6a 27                	push   $0x27
c0002700:	68 a0 69 00 c0       	push   $0xc00069a0
c0002705:	e8 78 fe ff ff       	call   c0002582 <panic_spin>
c000270a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:40
	if (idx_byte == btmp->btmp_bytes_len) {		// 若该内存池找不到可用空间		
c000270d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002710:	8b 00                	mov    (%eax),%eax
c0002712:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0002715:	75 0a                	jne    c0002721 <bitmap_scan+0x66>
/work/x86_os_my/lib/kernel/bitmap.c:41
		return -1;
c0002717:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000271c:	e9 cd 00 00 00       	jmp    c00027ee <bitmap_scan+0x133>
/work/x86_os_my/lib/kernel/bitmap.c:46
	}

	/* 若在位图数组范围内的某字节内找到了空闲位，
	 * 在该字节内逐位比对,返回空闲位的索引。*/
	int idx_bit = 0;
c0002721:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:48
	/* 和btmp->bits[idx_byte]这个字节逐位对比 */
	while ((uint8_t)(BITMAP_MASK << idx_bit) & btmp->bits[idx_byte]) { 
c0002728:	eb 04                	jmp    c000272e <bitmap_scan+0x73>
/work/x86_os_my/lib/kernel/bitmap.c:49
		idx_bit++;
c000272a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:48

	/* 若在位图数组范围内的某字节内找到了空闲位，
	 * 在该字节内逐位比对,返回空闲位的索引。*/
	int idx_bit = 0;
	/* 和btmp->bits[idx_byte]这个字节逐位对比 */
	while ((uint8_t)(BITMAP_MASK << idx_bit) & btmp->bits[idx_byte]) { 
c000272e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002731:	ba 01 00 00 00       	mov    $0x1,%edx
c0002736:	89 c1                	mov    %eax,%ecx
c0002738:	d3 e2                	shl    %cl,%edx
c000273a:	89 d0                	mov    %edx,%eax
c000273c:	0f b6 d0             	movzbl %al,%edx
c000273f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002742:	8b 48 04             	mov    0x4(%eax),%ecx
c0002745:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002748:	01 c8                	add    %ecx,%eax
c000274a:	0f b6 00             	movzbl (%eax),%eax
c000274d:	0f b6 c0             	movzbl %al,%eax
c0002750:	21 d0                	and    %edx,%eax
c0002752:	85 c0                	test   %eax,%eax
c0002754:	75 d4                	jne    c000272a <bitmap_scan+0x6f>
/work/x86_os_my/lib/kernel/bitmap.c:52
		idx_bit++;
	}
	
	int bit_idx_start = idx_byte * 8 + idx_bit;		// 空闲位在位图内的下标
c0002756:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002759:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c0002760:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002763:	01 d0                	add    %edx,%eax
c0002765:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:53
	if (cnt == 1) {
c0002768:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
c000276c:	75 05                	jne    c0002773 <bitmap_scan+0xb8>
/work/x86_os_my/lib/kernel/bitmap.c:54
		return bit_idx_start;
c000276e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002771:	eb 7b                	jmp    c00027ee <bitmap_scan+0x133>
/work/x86_os_my/lib/kernel/bitmap.c:57
	}

	uint32_t bit_left = (btmp->btmp_bytes_len * 8 - bit_idx_start);	// 记录还有多少位可以判断
c0002773:	8b 45 08             	mov    0x8(%ebp),%eax
c0002776:	8b 00                	mov    (%eax),%eax
c0002778:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c000277f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002782:	29 c2                	sub    %eax,%edx
c0002784:	89 d0                	mov    %edx,%eax
c0002786:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:58
	uint32_t next_bit = bit_idx_start + 1;
c0002789:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000278c:	83 c0 01             	add    $0x1,%eax
c000278f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:59
	uint32_t count = 1;			// 用于记录找到的空闲位的个数
c0002792:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:61

	bit_idx_start = -1;			// 初始化为-1，若找不到连续的位就直接返回-1
c0002799:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:62
	while (bit_left-- > 0) {
c00027a0:	eb 3c                	jmp    c00027de <bitmap_scan+0x123>
/work/x86_os_my/lib/kernel/bitmap.c:63
		if (!(bitmap_scan_test(btmp, next_bit))) {	// 判断next_bit位是否为1,=1返回true，=0返回false
c00027a2:	83 ec 08             	sub    $0x8,%esp
c00027a5:	ff 75 e4             	pushl  -0x1c(%ebp)
c00027a8:	ff 75 08             	pushl  0x8(%ebp)
c00027ab:	e8 cb fe ff ff       	call   c000267b <bitmap_scan_test>
c00027b0:	83 c4 10             	add    $0x10,%esp
c00027b3:	85 c0                	test   %eax,%eax
c00027b5:	75 06                	jne    c00027bd <bitmap_scan+0x102>
/work/x86_os_my/lib/kernel/bitmap.c:64
			count++;
c00027b7:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
c00027bb:	eb 07                	jmp    c00027c4 <bitmap_scan+0x109>
/work/x86_os_my/lib/kernel/bitmap.c:66
		} else {
			count = 0;			// 重新从0找cnt个连续的bit
c00027bd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:69
		}
		
		if (count == cnt) {		// 已找到连续的cnt个空位
c00027c4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00027c7:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00027ca:	75 0e                	jne    c00027da <bitmap_scan+0x11f>
/work/x86_os_my/lib/kernel/bitmap.c:70
			bit_idx_start = next_bit - cnt + 1;
c00027cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00027cf:	2b 45 0c             	sub    0xc(%ebp),%eax
c00027d2:	83 c0 01             	add    $0x1,%eax
c00027d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:71
			break;
c00027d8:	eb 11                	jmp    c00027eb <bitmap_scan+0x130>
/work/x86_os_my/lib/kernel/bitmap.c:73
		}
		next_bit++;
c00027da:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:62
	uint32_t bit_left = (btmp->btmp_bytes_len * 8 - bit_idx_start);	// 记录还有多少位可以判断
	uint32_t next_bit = bit_idx_start + 1;
	uint32_t count = 1;			// 用于记录找到的空闲位的个数

	bit_idx_start = -1;			// 初始化为-1，若找不到连续的位就直接返回-1
	while (bit_left-- > 0) {
c00027de:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00027e1:	8d 50 ff             	lea    -0x1(%eax),%edx
c00027e4:	89 55 e8             	mov    %edx,-0x18(%ebp)
c00027e7:	85 c0                	test   %eax,%eax
c00027e9:	75 b7                	jne    c00027a2 <bitmap_scan+0xe7>
/work/x86_os_my/lib/kernel/bitmap.c:75
			bit_idx_start = next_bit - cnt + 1;
			break;
		}
		next_bit++;
	}
	return bit_idx_start;
c00027eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/lib/kernel/bitmap.c:76
}
c00027ee:	c9                   	leave  
c00027ef:	c3                   	ret    

c00027f0 <bitmap_set>:
bitmap_set():
/work/x86_os_my/lib/kernel/bitmap.c:79

/* 将位图btmp的bit_idx位设置为value */
void bitmap_set(struct bitmap* btmp, uint32_t bit_idx, int8_t value) {
c00027f0:	55                   	push   %ebp
c00027f1:	89 e5                	mov    %esp,%ebp
c00027f3:	56                   	push   %esi
c00027f4:	53                   	push   %ebx
c00027f5:	83 ec 20             	sub    $0x20,%esp
c00027f8:	8b 45 10             	mov    0x10(%ebp),%eax
c00027fb:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:80
	ASSERT((value == 0) || (value == 1));
c00027fe:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c0002802:	74 1f                	je     c0002823 <bitmap_set+0x33>
/work/x86_os_my/lib/kernel/bitmap.c:80 (discriminator 1)
c0002804:	80 7d e4 01          	cmpb   $0x1,-0x1c(%ebp)
c0002808:	74 19                	je     c0002823 <bitmap_set+0x33>
/work/x86_os_my/lib/kernel/bitmap.c:80 (discriminator 2)
c000280a:	68 b4 69 00 c0       	push   $0xc00069b4
c000280f:	68 e0 69 00 c0       	push   $0xc00069e0
c0002814:	6a 50                	push   $0x50
c0002816:	68 a0 69 00 c0       	push   $0xc00069a0
c000281b:	e8 62 fd ff ff       	call   c0002582 <panic_spin>
c0002820:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:81
	uint32_t byte_idx = bit_idx / 8;    // 向下取整用于索引数组下标
c0002823:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002826:	c1 e8 03             	shr    $0x3,%eax
c0002829:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:82
	uint32_t bit_odd  = bit_idx % 8;    // 取余用于索引数组内的位
c000282c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000282f:	83 e0 07             	and    $0x7,%eax
c0002832:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:86

	/* 一般都会用个0x1这样的数对字节中的位操作,
	* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/
	if (value) {
c0002835:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c0002839:	74 2f                	je     c000286a <bitmap_set+0x7a>
/work/x86_os_my/lib/kernel/bitmap.c:87
		btmp->bits[byte_idx] |= (BITMAP_MASK << bit_odd);
c000283b:	8b 45 08             	mov    0x8(%ebp),%eax
c000283e:	8b 50 04             	mov    0x4(%eax),%edx
c0002841:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002844:	01 c2                	add    %eax,%edx
c0002846:	8b 45 08             	mov    0x8(%ebp),%eax
c0002849:	8b 48 04             	mov    0x4(%eax),%ecx
c000284c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000284f:	01 c8                	add    %ecx,%eax
c0002851:	0f b6 00             	movzbl (%eax),%eax
c0002854:	89 c6                	mov    %eax,%esi
c0002856:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002859:	bb 01 00 00 00       	mov    $0x1,%ebx
c000285e:	89 c1                	mov    %eax,%ecx
c0002860:	d3 e3                	shl    %cl,%ebx
c0002862:	89 d8                	mov    %ebx,%eax
c0002864:	09 f0                	or     %esi,%eax
c0002866:	88 02                	mov    %al,(%edx)
/work/x86_os_my/lib/kernel/bitmap.c:91
	} else {
		btmp->bits[byte_idx] &= ~(BITMAP_MASK << bit_odd);
	}
}
c0002868:	eb 2f                	jmp    c0002899 <bitmap_set+0xa9>
/work/x86_os_my/lib/kernel/bitmap.c:89
	/* 一般都会用个0x1这样的数对字节中的位操作,
	* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/
	if (value) {
		btmp->bits[byte_idx] |= (BITMAP_MASK << bit_odd);
	} else {
		btmp->bits[byte_idx] &= ~(BITMAP_MASK << bit_odd);
c000286a:	8b 45 08             	mov    0x8(%ebp),%eax
c000286d:	8b 50 04             	mov    0x4(%eax),%edx
c0002870:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002873:	01 c2                	add    %eax,%edx
c0002875:	8b 45 08             	mov    0x8(%ebp),%eax
c0002878:	8b 48 04             	mov    0x4(%eax),%ecx
c000287b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000287e:	01 c8                	add    %ecx,%eax
c0002880:	0f b6 00             	movzbl (%eax),%eax
c0002883:	89 c3                	mov    %eax,%ebx
c0002885:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002888:	be 01 00 00 00       	mov    $0x1,%esi
c000288d:	89 c1                	mov    %eax,%ecx
c000288f:	d3 e6                	shl    %cl,%esi
c0002891:	89 f0                	mov    %esi,%eax
c0002893:	f7 d0                	not    %eax
c0002895:	21 d8                	and    %ebx,%eax
c0002897:	88 02                	mov    %al,(%edx)
/work/x86_os_my/lib/kernel/bitmap.c:91
	}
}
c0002899:	90                   	nop
c000289a:	8d 65 f8             	lea    -0x8(%ebp),%esp
c000289d:	5b                   	pop    %ebx
c000289e:	5e                   	pop    %esi
c000289f:	5d                   	pop    %ebp
c00028a0:	c3                   	ret    

c00028a1 <vaddr_get>:
vaddr_get():
/work/x86_os_my/kernel/memory.c:66
struct pool kernel_pool, user_pool;		// 生成内核内存池和用户内存池
struct virtual_addr kernel_vaddr;		// 此结构是用来给内核分配虚拟地址

/* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页,
 * 成功则返回虚拟页的起始地址, 失败则返回NULL */
static void* vaddr_get(enum pool_flags pf, uint32_t pg_cnt) {
c00028a1:	55                   	push   %ebp
c00028a2:	89 e5                	mov    %esp,%ebp
c00028a4:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:67
	int vaddr_start = 0, bit_idx_start = -1;
c00028a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00028ae:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:68
	uint32_t cnt = 0;
c00028b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:69
	if (pf == PF_KERNEL) {
c00028bc:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c00028c0:	75 64                	jne    c0002926 <vaddr_get+0x85>
/work/x86_os_my/kernel/memory.c:71
		// 在位图中申请连续cnt个位 成功：返回其起始位下标
		bit_idx_start  = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
c00028c2:	83 ec 08             	sub    $0x8,%esp
c00028c5:	ff 75 0c             	pushl  0xc(%ebp)
c00028c8:	68 48 9b 00 c0       	push   $0xc0009b48
c00028cd:	e8 e9 fd ff ff       	call   c00026bb <bitmap_scan>
c00028d2:	83 c4 10             	add    $0x10,%esp
c00028d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:72
		if (bit_idx_start == -1) {	//失败
c00028d8:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c00028dc:	75 2b                	jne    c0002909 <vaddr_get+0x68>
/work/x86_os_my/kernel/memory.c:73
			return NULL;
c00028de:	b8 00 00 00 00       	mov    $0x0,%eax
c00028e3:	e9 cd 00 00 00       	jmp    c00029b5 <vaddr_get+0x114>
/work/x86_os_my/kernel/memory.c:77
		}
		while(cnt < pg_cnt) {
			// 设置位图中的位，表示内存已被占用
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
c00028e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00028eb:	8d 50 01             	lea    0x1(%eax),%edx
c00028ee:	89 55 f0             	mov    %edx,-0x10(%ebp)
c00028f1:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00028f4:	01 d0                	add    %edx,%eax
c00028f6:	83 ec 04             	sub    $0x4,%esp
c00028f9:	6a 01                	push   $0x1
c00028fb:	50                   	push   %eax
c00028fc:	68 48 9b 00 c0       	push   $0xc0009b48
c0002901:	e8 ea fe ff ff       	call   c00027f0 <bitmap_set>
c0002906:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:75
		// 在位图中申请连续cnt个位 成功：返回其起始位下标
		bit_idx_start  = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
		if (bit_idx_start == -1) {	//失败
			return NULL;
		}
		while(cnt < pg_cnt) {
c0002909:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000290c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000290f:	72 d7                	jb     c00028e8 <vaddr_get+0x47>
/work/x86_os_my/kernel/memory.c:79
			// 设置位图中的位，表示内存已被占用
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
		}
		vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
c0002911:	a1 50 9b 00 c0       	mov    0xc0009b50,%eax
c0002916:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002919:	c1 e2 0c             	shl    $0xc,%edx
c000291c:	01 d0                	add    %edx,%eax
c000291e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002921:	e9 8c 00 00 00       	jmp    c00029b2 <vaddr_get+0x111>
/work/x86_os_my/kernel/memory.c:81
	} else {
		struct task_struct* cur = running_thread();
c0002926:	e8 56 14 00 00       	call   c0003d81 <running_thread>
c000292b:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:82
		bit_idx_start  = bitmap_scan(&cur->userprog_vaddr.vaddr_bitmap, pg_cnt);
c000292e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002931:	83 c0 38             	add    $0x38,%eax
c0002934:	83 ec 08             	sub    $0x8,%esp
c0002937:	ff 75 0c             	pushl  0xc(%ebp)
c000293a:	50                   	push   %eax
c000293b:	e8 7b fd ff ff       	call   c00026bb <bitmap_scan>
c0002940:	83 c4 10             	add    $0x10,%esp
c0002943:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:83
		if (bit_idx_start == -1) {
c0002946:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c000294a:	75 2a                	jne    c0002976 <vaddr_get+0xd5>
/work/x86_os_my/kernel/memory.c:84
			return NULL;
c000294c:	b8 00 00 00 00       	mov    $0x0,%eax
c0002951:	eb 62                	jmp    c00029b5 <vaddr_get+0x114>
/work/x86_os_my/kernel/memory.c:87
		}
		while(cnt < pg_cnt) {
			bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
c0002953:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002956:	8d 50 01             	lea    0x1(%eax),%edx
c0002959:	89 55 f0             	mov    %edx,-0x10(%ebp)
c000295c:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000295f:	01 c2                	add    %eax,%edx
c0002961:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002964:	83 c0 38             	add    $0x38,%eax
c0002967:	83 ec 04             	sub    $0x4,%esp
c000296a:	6a 01                	push   $0x1
c000296c:	52                   	push   %edx
c000296d:	50                   	push   %eax
c000296e:	e8 7d fe ff ff       	call   c00027f0 <bitmap_set>
c0002973:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:86
		struct task_struct* cur = running_thread();
		bit_idx_start  = bitmap_scan(&cur->userprog_vaddr.vaddr_bitmap, pg_cnt);
		if (bit_idx_start == -1) {
			return NULL;
		}
		while(cnt < pg_cnt) {
c0002976:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002979:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000297c:	72 d5                	jb     c0002953 <vaddr_get+0xb2>
/work/x86_os_my/kernel/memory.c:89
			bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
		}
		vaddr_start = cur->userprog_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
c000297e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002981:	8b 40 40             	mov    0x40(%eax),%eax
c0002984:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002987:	c1 e2 0c             	shl    $0xc,%edx
c000298a:	01 d0                	add    %edx,%eax
c000298c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:92

		/* (0xc0000000 - PG_SIZE)做为用户3级栈已经在start_process被分配 */
		ASSERT((uint32_t)vaddr_start < (0xc0000000 - PG_SIZE));
c000298f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002992:	3d ff ef ff bf       	cmp    $0xbfffefff,%eax
c0002997:	76 19                	jbe    c00029b2 <vaddr_get+0x111>
/work/x86_os_my/kernel/memory.c:92 (discriminator 1)
c0002999:	68 ec 69 00 c0       	push   $0xc00069ec
c000299e:	68 54 6d 00 c0       	push   $0xc0006d54
c00029a3:	6a 5c                	push   $0x5c
c00029a5:	68 1b 6a 00 c0       	push   $0xc0006a1b
c00029aa:	e8 d3 fb ff ff       	call   c0002582 <panic_spin>
c00029af:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:95
		
	}
	return (void*)vaddr_start;
c00029b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:96
}
c00029b5:	c9                   	leave  
c00029b6:	c3                   	ret    

c00029b7 <pte_ptr>:
pte_ptr():
/work/x86_os_my/kernel/memory.c:103
// 页表项 page table
/* 得到虚拟地址vaddr对应的pte指针*/
// 虚拟地址 vaddr 所在 pte 的"虚拟地址"!!!
// *pte 代表的是 pte 页表项的内容,
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页表项"属性
uint32_t* pte_ptr(uint32_t vaddr) {
c00029b7:	55                   	push   %ebp
c00029b8:	89 e5                	mov    %esp,%ebp
c00029ba:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:108
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
					((vaddr & 0xffc00000) >> 10) + \
c00029bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00029c0:	25 00 00 c0 ff       	and    $0xffc00000,%eax
c00029c5:	c1 e8 0a             	shr    $0xa,%eax
c00029c8:	89 c2                	mov    %eax,%edx
/work/x86_os_my/kernel/memory.c:109
					PTE_IDX(vaddr) * 4);
c00029ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00029cd:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c00029d2:	c1 e8 0c             	shr    $0xc,%eax
c00029d5:	c1 e0 02             	shl    $0x2,%eax
/work/x86_os_my/kernel/memory.c:108
uint32_t* pte_ptr(uint32_t vaddr) {
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
					((vaddr & 0xffc00000) >> 10) + \
c00029d8:	01 d0                	add    %edx,%eax
c00029da:	2d 00 00 40 00       	sub    $0x400000,%eax
/work/x86_os_my/kernel/memory.c:107
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页表项"属性
uint32_t* pte_ptr(uint32_t vaddr) {
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
c00029df:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:110
					((vaddr & 0xffc00000) >> 10) + \
					PTE_IDX(vaddr) * 4);
	return pte;
c00029e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/kernel/memory.c:111
}
c00029e5:	c9                   	leave  
c00029e6:	c3                   	ret    

c00029e7 <pde_ptr>:
pde_ptr():
/work/x86_os_my/kernel/memory.c:118
// 页目录表项 page Directory table entry
/* 得到虚拟地址vaddr对应的pde的指针 */
// 虚拟地址 vaddr 所在 pde 的"虚拟地址"!!!
// *pde 代表的是 pde 页目录项的内容
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页目录项"属性
uint32_t* pde_ptr(uint32_t vaddr) {
c00029e7:	55                   	push   %ebp
c00029e8:	89 e5                	mov    %esp,%ebp
c00029ea:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:120
	/* 0xfffff是用来访问到页目录表本身所在的地址 */
	uint32_t* pde = (uint32_t*)((0xfffff000) + PDE_IDX(vaddr) * 4);
c00029ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00029f0:	c1 e8 16             	shr    $0x16,%eax
c00029f3:	05 00 fc ff 3f       	add    $0x3ffffc00,%eax
c00029f8:	c1 e0 02             	shl    $0x2,%eax
c00029fb:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:121
	return pde;
c00029fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/kernel/memory.c:122
}
c0002a01:	c9                   	leave  
c0002a02:	c3                   	ret    

c0002a03 <palloc>:
palloc():
/work/x86_os_my/kernel/memory.c:126

/* 在m_pool指向的物理内存池中分配1个物理页,
 * 成功则返回页框的物理地址,失败则返回NULL */
static void* palloc(struct pool* m_pool) {
c0002a03:	55                   	push   %ebp
c0002a04:	89 e5                	mov    %esp,%ebp
c0002a06:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:128
	/* 扫描或设置位图要保证原子操作 */
	int bit_idx = bitmap_scan(&m_pool->pool_bitmap, 1);    // 找一个物理页面
c0002a09:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a0c:	83 ec 08             	sub    $0x8,%esp
c0002a0f:	6a 01                	push   $0x1
c0002a11:	50                   	push   %eax
c0002a12:	e8 a4 fc ff ff       	call   c00026bb <bitmap_scan>
c0002a17:	83 c4 10             	add    $0x10,%esp
c0002a1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:129
	if (bit_idx == -1 ) {
c0002a1d:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0002a21:	75 07                	jne    c0002a2a <palloc+0x27>
/work/x86_os_my/kernel/memory.c:130
		return NULL;
c0002a23:	b8 00 00 00 00       	mov    $0x0,%eax
c0002a28:	eb 2b                	jmp    c0002a55 <palloc+0x52>
/work/x86_os_my/kernel/memory.c:132
	}
	bitmap_set(&m_pool->pool_bitmap, bit_idx, 1);	// 将此位bit_idx置1
c0002a2a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002a2d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a30:	83 ec 04             	sub    $0x4,%esp
c0002a33:	6a 01                	push   $0x1
c0002a35:	52                   	push   %edx
c0002a36:	50                   	push   %eax
c0002a37:	e8 b4 fd ff ff       	call   c00027f0 <bitmap_set>
c0002a3c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:133
	uint32_t page_phyaddr = ((bit_idx * PG_SIZE) + m_pool->phy_addr_start);
c0002a3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002a42:	c1 e0 0c             	shl    $0xc,%eax
c0002a45:	89 c2                	mov    %eax,%edx
c0002a47:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a4a:	8b 40 08             	mov    0x8(%eax),%eax
c0002a4d:	01 d0                	add    %edx,%eax
c0002a4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:134
	return (void*)page_phyaddr;
c0002a52:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/kernel/memory.c:135
}
c0002a55:	c9                   	leave  
c0002a56:	c3                   	ret    

c0002a57 <page_table_add>:
page_table_add():
/work/x86_os_my/kernel/memory.c:138

/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */
static void page_table_add(void* _vaddr, void* _page_phyaddr) {
c0002a57:	55                   	push   %ebp
c0002a58:	89 e5                	mov    %esp,%ebp
c0002a5a:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:139
	uint32_t vaddr = (uint32_t)_vaddr, page_phyaddr = (uint32_t)_page_phyaddr;
c0002a5d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a60:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002a63:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002a66:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:140
	uint32_t* pde = pde_ptr(vaddr);	//变量pde是虚拟地址!!!
c0002a69:	ff 75 f4             	pushl  -0xc(%ebp)
c0002a6c:	e8 76 ff ff ff       	call   c00029e7 <pde_ptr>
c0002a71:	83 c4 04             	add    $0x4,%esp
c0002a74:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:141
	uint32_t* pte = pte_ptr(vaddr);	//变量pte是虚拟地址!!!
c0002a77:	ff 75 f4             	pushl  -0xc(%ebp)
c0002a7a:	e8 38 ff ff ff       	call   c00029b7 <pte_ptr>
c0002a7f:	83 c4 04             	add    $0x4,%esp
c0002a82:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:149
	* pde页目录项 pte页表项
	* 执行*pte可能会访问到空的pde。所以确保pde创建完成后才能执行*pte，否则会引发page_fault。
	* 因此在*pde为0时，*pte只能出现在下面else语句块中的*pde后面。
	* *********************************************************/
	/* 先在页目录内判断目录项的P位，若为1,则表示该表已存在 */
	if (*pde & 0x00000001) {			// 页目录项 存在
c0002a85:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002a88:	8b 00                	mov    (%eax),%eax
c0002a8a:	83 e0 01             	and    $0x1,%eax
c0002a8d:	85 c0                	test   %eax,%eax
c0002a8f:	74 64                	je     c0002af5 <page_table_add+0x9e>
/work/x86_os_my/kernel/memory.c:150
		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
c0002a91:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002a94:	8b 00                	mov    (%eax),%eax
c0002a96:	83 e0 01             	and    $0x1,%eax
c0002a99:	85 c0                	test   %eax,%eax
c0002a9b:	74 1c                	je     c0002ab9 <page_table_add+0x62>
/work/x86_os_my/kernel/memory.c:150 (discriminator 1)
c0002a9d:	68 2b 6a 00 c0       	push   $0xc0006a2b
c0002aa2:	68 60 6d 00 c0       	push   $0xc0006d60
c0002aa7:	68 96 00 00 00       	push   $0x96
c0002aac:	68 1b 6a 00 c0       	push   $0xc0006a1b
c0002ab1:	e8 cc fa ff ff       	call   c0002582 <panic_spin>
c0002ab6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:152

		if (!(*pte & 0x00000001)) {		// 页表项pte不存在，创建PTE
c0002ab9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002abc:	8b 00                	mov    (%eax),%eax
c0002abe:	83 e0 01             	and    $0x1,%eax
c0002ac1:	85 c0                	test   %eax,%eax
c0002ac3:	75 12                	jne    c0002ad7 <page_table_add+0x80>
/work/x86_os_my/kernel/memory.c:153
			*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);		// 物理地址 | US=1,RW=1,P=1
c0002ac5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002ac8:	83 c8 07             	or     $0x7,%eax
c0002acb:	89 c2                	mov    %eax,%edx
c0002acd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002ad0:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:173
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
	}
}
c0002ad2:	e9 8e 00 00 00       	jmp    c0002b65 <page_table_add+0x10e>
/work/x86_os_my/kernel/memory.c:155
		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic

		if (!(*pte & 0x00000001)) {		// 页表项pte不存在，创建PTE
			*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);		// 物理地址 | US=1,RW=1,P=1
		} else {						// 不会执行到这，因为上面的ASSERT
			PANIC("pte repeat");
c0002ad7:	68 40 6a 00 c0       	push   $0xc0006a40
c0002adc:	68 60 6d 00 c0       	push   $0xc0006d60
c0002ae1:	68 9b 00 00 00       	push   $0x9b
c0002ae6:	68 1b 6a 00 c0       	push   $0xc0006a1b
c0002aeb:	e8 92 fa ff ff       	call   c0002582 <panic_spin>
c0002af0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:173
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
	}
}
c0002af3:	eb 70                	jmp    c0002b65 <page_table_add+0x10e>
/work/x86_os_my/kernel/memory.c:159
		} else {						// 不会执行到这，因为上面的ASSERT
			PANIC("pte repeat");
		}
	} else {							// 页目录项不存在，先创建页目录，再创建页表项
		/* 页表中用到的页一律从内核空间分配 */
		uint32_t pde_phyaddr = (uint32_t)palloc(&kernel_pool);
c0002af5:	83 ec 0c             	sub    $0xc,%esp
c0002af8:	68 60 9b 00 c0       	push   $0xc0009b60
c0002afd:	e8 01 ff ff ff       	call   c0002a03 <palloc>
c0002b02:	83 c4 10             	add    $0x10,%esp
c0002b05:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:160
		*pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 注意这行是pde_phyaddr，不是page_phyaddr!!!
c0002b08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0002b0b:	83 c8 07             	or     $0x7,%eax
c0002b0e:	89 c2                	mov    %eax,%edx
c0002b10:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002b13:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:168
		 * 访问物理地址 pde_phyaddr，需要找到它的虚拟地址！
		 * 只要用_vaddr的 PTE 取高20位即可。
		   搞得这么难理解，其实就是0xffc00000找到页目录表，然后加上vaddr的PDE在页目录表中的索引
		   (uint32_t*)(0xffc00000 + ((vaddr & 0xffc00000) >> 10))
		 */
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);
c0002b15:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002b18:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002b1d:	83 ec 04             	sub    $0x4,%esp
c0002b20:	68 00 10 00 00       	push   $0x1000
c0002b25:	6a 00                	push   $0x0
c0002b27:	50                   	push   %eax
c0002b28:	e8 6d 0e 00 00       	call   c000399a <memset>
c0002b2d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:170

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
c0002b30:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002b33:	8b 00                	mov    (%eax),%eax
c0002b35:	83 e0 01             	and    $0x1,%eax
c0002b38:	85 c0                	test   %eax,%eax
c0002b3a:	74 1c                	je     c0002b58 <page_table_add+0x101>
/work/x86_os_my/kernel/memory.c:170 (discriminator 1)
c0002b3c:	68 2b 6a 00 c0       	push   $0xc0006a2b
c0002b41:	68 60 6d 00 c0       	push   $0xc0006d60
c0002b46:	68 aa 00 00 00       	push   $0xaa
c0002b4b:	68 1b 6a 00 c0       	push   $0xc0006a1b
c0002b50:	e8 2d fa ff ff       	call   c0002582 <panic_spin>
c0002b55:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:171
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
c0002b58:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002b5b:	83 c8 07             	or     $0x7,%eax
c0002b5e:	89 c2                	mov    %eax,%edx
c0002b60:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002b63:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:173
	}
}
c0002b65:	90                   	nop
c0002b66:	c9                   	leave  
c0002b67:	c3                   	ret    

c0002b68 <malloc_page>:
malloc_page():
/work/x86_os_my/kernel/memory.c:176

/* 分配pg_cnt个页空间,成功则返回起始虚拟地址,失败时返回NULL */
void* malloc_page(enum pool_flags pf, uint32_t pg_cnt) {
c0002b68:	55                   	push   %ebp
c0002b69:	89 e5                	mov    %esp,%ebp
c0002b6b:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:177
	ASSERT(pg_cnt > 0 && pg_cnt < 3840);
c0002b6e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002b72:	74 09                	je     c0002b7d <malloc_page+0x15>
/work/x86_os_my/kernel/memory.c:177 (discriminator 1)
c0002b74:	81 7d 0c ff 0e 00 00 	cmpl   $0xeff,0xc(%ebp)
c0002b7b:	76 1c                	jbe    c0002b99 <malloc_page+0x31>
/work/x86_os_my/kernel/memory.c:177 (discriminator 3)
c0002b7d:	68 4b 6a 00 c0       	push   $0xc0006a4b
c0002b82:	68 70 6d 00 c0       	push   $0xc0006d70
c0002b87:	68 b1 00 00 00       	push   $0xb1
c0002b8c:	68 1b 6a 00 c0       	push   $0xc0006a1b
c0002b91:	e8 ec f9 ff ff       	call   c0002582 <panic_spin>
c0002b96:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:183
	/***********   malloc_page的原理是三个动作的合成:   ***********
		1 通过vaddr_get在虚拟内存池中申请虚拟地址
		2 通过palloc在物理内存池中申请物理页
		3 通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射
	***************************************************************/
	void* vaddr_start = vaddr_get(pf, pg_cnt);
c0002b99:	83 ec 08             	sub    $0x8,%esp
c0002b9c:	ff 75 0c             	pushl  0xc(%ebp)
c0002b9f:	ff 75 08             	pushl  0x8(%ebp)
c0002ba2:	e8 fa fc ff ff       	call   c00028a1 <vaddr_get>
c0002ba7:	83 c4 10             	add    $0x10,%esp
c0002baa:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:184
	if (vaddr_start == NULL) {
c0002bad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002bb1:	75 07                	jne    c0002bba <malloc_page+0x52>
/work/x86_os_my/kernel/memory.c:185
		return NULL;
c0002bb3:	b8 00 00 00 00       	mov    $0x0,%eax
c0002bb8:	eb 6e                	jmp    c0002c28 <malloc_page+0xc0>
/work/x86_os_my/kernel/memory.c:188
	}

	uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
c0002bba:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002bbd:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002bc0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002bc3:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:189
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c0002bc6:	8b 45 08             	mov    0x8(%ebp),%eax
c0002bc9:	83 e0 01             	and    $0x1,%eax
c0002bcc:	85 c0                	test   %eax,%eax
c0002bce:	74 07                	je     c0002bd7 <malloc_page+0x6f>
/work/x86_os_my/kernel/memory.c:189 (discriminator 1)
c0002bd0:	b8 60 9b 00 c0       	mov    $0xc0009b60,%eax
c0002bd5:	eb 05                	jmp    c0002bdc <malloc_page+0x74>
/work/x86_os_my/kernel/memory.c:189 (discriminator 2)
c0002bd7:	b8 60 9a 00 c0       	mov    $0xc0009a60,%eax
/work/x86_os_my/kernel/memory.c:189 (discriminator 4)
c0002bdc:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:192 (discriminator 4)

	/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
	while (cnt-- > 0) {
c0002bdf:	eb 37                	jmp    c0002c18 <malloc_page+0xb0>
/work/x86_os_my/kernel/memory.c:193
		void* page_phyaddr = palloc(mem_pool);
c0002be1:	83 ec 0c             	sub    $0xc,%esp
c0002be4:	ff 75 e8             	pushl  -0x18(%ebp)
c0002be7:	e8 17 fe ff ff       	call   c0002a03 <palloc>
c0002bec:	83 c4 10             	add    $0x10,%esp
c0002bef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:194
		if (page_phyaddr == NULL) {  // 失败时要将曾经已申请的虚拟地址和物理页全部回滚，在将来完成内存回收时再补充
c0002bf2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0002bf6:	75 07                	jne    c0002bff <malloc_page+0x97>
/work/x86_os_my/kernel/memory.c:195
			return NULL;
c0002bf8:	b8 00 00 00 00       	mov    $0x0,%eax
c0002bfd:	eb 29                	jmp    c0002c28 <malloc_page+0xc0>
/work/x86_os_my/kernel/memory.c:197
		}
		page_table_add((void*)vaddr, page_phyaddr); // 在页表中做映射 
c0002bff:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002c02:	83 ec 08             	sub    $0x8,%esp
c0002c05:	ff 75 e4             	pushl  -0x1c(%ebp)
c0002c08:	50                   	push   %eax
c0002c09:	e8 49 fe ff ff       	call   c0002a57 <page_table_add>
c0002c0e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:198
		vaddr += PG_SIZE;		 // 下一个虚拟页
c0002c11:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:192

	uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;

	/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
	while (cnt-- > 0) {
c0002c18:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002c1b:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002c1e:	89 55 f0             	mov    %edx,-0x10(%ebp)
c0002c21:	85 c0                	test   %eax,%eax
c0002c23:	75 bc                	jne    c0002be1 <malloc_page+0x79>
/work/x86_os_my/kernel/memory.c:200
			return NULL;
		}
		page_table_add((void*)vaddr, page_phyaddr); // 在页表中做映射 
		vaddr += PG_SIZE;		 // 下一个虚拟页
	}
	return vaddr_start;
c0002c25:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/kernel/memory.c:201
}
c0002c28:	c9                   	leave  
c0002c29:	c3                   	ret    

c0002c2a <get_kernel_pages>:
get_kernel_pages():
/work/x86_os_my/kernel/memory.c:204

/* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */
void* get_kernel_pages(uint32_t pg_cnt) {
c0002c2a:	55                   	push   %ebp
c0002c2b:	89 e5                	mov    %esp,%ebp
c0002c2d:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:205
	lock_acquire(&kernel_pool.lock);
c0002c30:	83 ec 0c             	sub    $0xc,%esp
c0002c33:	68 70 9b 00 c0       	push   $0xc0009b70
c0002c38:	e8 92 1c 00 00       	call   c00048cf <lock_acquire>
c0002c3d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:206
	void* vaddr =  malloc_page(PF_KERNEL, pg_cnt);
c0002c40:	83 ec 08             	sub    $0x8,%esp
c0002c43:	ff 75 08             	pushl  0x8(%ebp)
c0002c46:	6a 01                	push   $0x1
c0002c48:	e8 1b ff ff ff       	call   c0002b68 <malloc_page>
c0002c4d:	83 c4 10             	add    $0x10,%esp
c0002c50:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:207
	if (vaddr != NULL) {
c0002c53:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002c57:	74 17                	je     c0002c70 <get_kernel_pages+0x46>
/work/x86_os_my/kernel/memory.c:208
		memset(vaddr, 0, pg_cnt * PG_SIZE);
c0002c59:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c5c:	c1 e0 0c             	shl    $0xc,%eax
c0002c5f:	83 ec 04             	sub    $0x4,%esp
c0002c62:	50                   	push   %eax
c0002c63:	6a 00                	push   $0x0
c0002c65:	ff 75 f4             	pushl  -0xc(%ebp)
c0002c68:	e8 2d 0d 00 00       	call   c000399a <memset>
c0002c6d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:210
	}
	lock_release(&kernel_pool.lock);
c0002c70:	83 ec 0c             	sub    $0xc,%esp
c0002c73:	68 70 9b 00 c0       	push   $0xc0009b70
c0002c78:	e8 c9 1c 00 00       	call   c0004946 <lock_release>
c0002c7d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:211
	return vaddr;
c0002c80:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:212
}
c0002c83:	c9                   	leave  
c0002c84:	c3                   	ret    

c0002c85 <get_user_pages>:
get_user_pages():
/work/x86_os_my/kernel/memory.c:215

/* 在用户空间中申请4k内存,并返回其虚拟地址 */
void* get_user_pages(uint32_t pg_cnt) {
c0002c85:	55                   	push   %ebp
c0002c86:	89 e5                	mov    %esp,%ebp
c0002c88:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:216
	lock_acquire(&user_pool.lock);
c0002c8b:	83 ec 0c             	sub    $0xc,%esp
c0002c8e:	68 70 9a 00 c0       	push   $0xc0009a70
c0002c93:	e8 37 1c 00 00       	call   c00048cf <lock_acquire>
c0002c98:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:217
	void* vaddr = malloc_page(PF_USER, pg_cnt);
c0002c9b:	83 ec 08             	sub    $0x8,%esp
c0002c9e:	ff 75 08             	pushl  0x8(%ebp)
c0002ca1:	6a 02                	push   $0x2
c0002ca3:	e8 c0 fe ff ff       	call   c0002b68 <malloc_page>
c0002ca8:	83 c4 10             	add    $0x10,%esp
c0002cab:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:218
	if (vaddr != NULL) {
c0002cae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002cb2:	74 17                	je     c0002ccb <get_user_pages+0x46>
/work/x86_os_my/kernel/memory.c:219
		memset(vaddr, 0, pg_cnt * PG_SIZE);
c0002cb4:	8b 45 08             	mov    0x8(%ebp),%eax
c0002cb7:	c1 e0 0c             	shl    $0xc,%eax
c0002cba:	83 ec 04             	sub    $0x4,%esp
c0002cbd:	50                   	push   %eax
c0002cbe:	6a 00                	push   $0x0
c0002cc0:	ff 75 f4             	pushl  -0xc(%ebp)
c0002cc3:	e8 d2 0c 00 00       	call   c000399a <memset>
c0002cc8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:221
	}
	lock_release(&user_pool.lock);
c0002ccb:	83 ec 0c             	sub    $0xc,%esp
c0002cce:	68 70 9a 00 c0       	push   $0xc0009a70
c0002cd3:	e8 6e 1c 00 00       	call   c0004946 <lock_release>
c0002cd8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:222
	return vaddr;
c0002cdb:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:223
}
c0002cde:	c9                   	leave  
c0002cdf:	c3                   	ret    

c0002ce0 <get_a_page>:
get_a_page():
/work/x86_os_my/kernel/memory.c:227

/* 将虚拟地址vaddr与pf池中的物理地址关联,仅支持一页空间分配
 * 功能是，可以指定虚拟地址的内存分配 */
void* get_a_page(enum pool_flags pf, uint32_t vaddr) {
c0002ce0:	55                   	push   %ebp
c0002ce1:	89 e5                	mov    %esp,%ebp
c0002ce3:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:228
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c0002ce6:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ce9:	83 e0 01             	and    $0x1,%eax
c0002cec:	85 c0                	test   %eax,%eax
c0002cee:	74 07                	je     c0002cf7 <get_a_page+0x17>
/work/x86_os_my/kernel/memory.c:228 (discriminator 1)
c0002cf0:	b8 60 9b 00 c0       	mov    $0xc0009b60,%eax
c0002cf5:	eb 05                	jmp    c0002cfc <get_a_page+0x1c>
/work/x86_os_my/kernel/memory.c:228 (discriminator 2)
c0002cf7:	b8 60 9a 00 c0       	mov    $0xc0009a60,%eax
/work/x86_os_my/kernel/memory.c:228 (discriminator 4)
c0002cfc:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:229 (discriminator 4)
	lock_acquire(&mem_pool->lock);
c0002cff:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002d02:	83 c0 10             	add    $0x10,%eax
c0002d05:	83 ec 0c             	sub    $0xc,%esp
c0002d08:	50                   	push   %eax
c0002d09:	e8 c1 1b 00 00       	call   c00048cf <lock_acquire>
c0002d0e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:232 (discriminator 4)

	/* 先将虚拟地址对应的位图置1 */
	struct task_struct* cur = running_thread();
c0002d11:	e8 6b 10 00 00       	call   c0003d81 <running_thread>
c0002d16:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:233 (discriminator 4)
	int32_t bit_idx = -1;
c0002d19:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:235 (discriminator 4)

	if (cur->pgdir != NULL && pf == PF_USER) {
c0002d20:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002d23:	8b 40 34             	mov    0x34(%eax),%eax
c0002d26:	85 c0                	test   %eax,%eax
c0002d28:	74 55                	je     c0002d7f <get_a_page+0x9f>
/work/x86_os_my/kernel/memory.c:235 (discriminator 1)
c0002d2a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0002d2e:	75 4f                	jne    c0002d7f <get_a_page+0x9f>
/work/x86_os_my/kernel/memory.c:237
		/* 若当前是用户进程申请用户内存,就修改用户进程自己的虚拟地址池的 位图 */
		bit_idx = (vaddr - cur->userprog_vaddr.vaddr_start) / PG_SIZE;
c0002d30:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002d33:	8b 40 40             	mov    0x40(%eax),%eax
c0002d36:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002d39:	29 c2                	sub    %eax,%edx
c0002d3b:	89 d0                	mov    %edx,%eax
c0002d3d:	c1 e8 0c             	shr    $0xc,%eax
c0002d40:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:238
		ASSERT(bit_idx > 0);
c0002d43:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002d47:	7f 1c                	jg     c0002d65 <get_a_page+0x85>
/work/x86_os_my/kernel/memory.c:238 (discriminator 1)
c0002d49:	68 67 6a 00 c0       	push   $0xc0006a67
c0002d4e:	68 7c 6d 00 c0       	push   $0xc0006d7c
c0002d53:	68 ee 00 00 00       	push   $0xee
c0002d58:	68 1b 6a 00 c0       	push   $0xc0006a1b
c0002d5d:	e8 20 f8 ff ff       	call   c0002582 <panic_spin>
c0002d62:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:239
		bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx, 1);
c0002d65:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002d68:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002d6b:	83 c2 38             	add    $0x38,%edx
c0002d6e:	83 ec 04             	sub    $0x4,%esp
c0002d71:	6a 01                	push   $0x1
c0002d73:	50                   	push   %eax
c0002d74:	52                   	push   %edx
c0002d75:	e8 76 fa ff ff       	call   c00027f0 <bitmap_set>
c0002d7a:	83 c4 10             	add    $0x10,%esp
c0002d7d:	eb 78                	jmp    c0002df7 <get_a_page+0x117>
/work/x86_os_my/kernel/memory.c:241

	} else if (cur->pgdir == NULL && pf == PF_KERNEL) {
c0002d7f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002d82:	8b 40 34             	mov    0x34(%eax),%eax
c0002d85:	85 c0                	test   %eax,%eax
c0002d87:	75 52                	jne    c0002ddb <get_a_page+0xfb>
/work/x86_os_my/kernel/memory.c:241 (discriminator 1)
c0002d89:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0002d8d:	75 4c                	jne    c0002ddb <get_a_page+0xfb>
/work/x86_os_my/kernel/memory.c:243
		/* 如果是内核线程申请内核内存,就修改 kernel_vaddr */
		bit_idx = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
c0002d8f:	a1 50 9b 00 c0       	mov    0xc0009b50,%eax
c0002d94:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002d97:	29 c2                	sub    %eax,%edx
c0002d99:	89 d0                	mov    %edx,%eax
c0002d9b:	c1 e8 0c             	shr    $0xc,%eax
c0002d9e:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:244
		ASSERT(bit_idx > 0);
c0002da1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002da5:	7f 1c                	jg     c0002dc3 <get_a_page+0xe3>
/work/x86_os_my/kernel/memory.c:244 (discriminator 1)
c0002da7:	68 67 6a 00 c0       	push   $0xc0006a67
c0002dac:	68 7c 6d 00 c0       	push   $0xc0006d7c
c0002db1:	68 f4 00 00 00       	push   $0xf4
c0002db6:	68 1b 6a 00 c0       	push   $0xc0006a1b
c0002dbb:	e8 c2 f7 ff ff       	call   c0002582 <panic_spin>
c0002dc0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:245
		bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx, 1);
c0002dc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002dc6:	83 ec 04             	sub    $0x4,%esp
c0002dc9:	6a 01                	push   $0x1
c0002dcb:	50                   	push   %eax
c0002dcc:	68 48 9b 00 c0       	push   $0xc0009b48
c0002dd1:	e8 1a fa ff ff       	call   c00027f0 <bitmap_set>
c0002dd6:	83 c4 10             	add    $0x10,%esp
c0002dd9:	eb 1c                	jmp    c0002df7 <get_a_page+0x117>
/work/x86_os_my/kernel/memory.c:248

	} else {
		PANIC("get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page");
c0002ddb:	68 74 6a 00 c0       	push   $0xc0006a74
c0002de0:	68 7c 6d 00 c0       	push   $0xc0006d7c
c0002de5:	68 f8 00 00 00       	push   $0xf8
c0002dea:	68 1b 6a 00 c0       	push   $0xc0006a1b
c0002def:	e8 8e f7 ff ff       	call   c0002582 <panic_spin>
c0002df4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:251
	}

	void* page_phyaddr = palloc(mem_pool);
c0002df7:	83 ec 0c             	sub    $0xc,%esp
c0002dfa:	ff 75 f4             	pushl  -0xc(%ebp)
c0002dfd:	e8 01 fc ff ff       	call   c0002a03 <palloc>
c0002e02:	83 c4 10             	add    $0x10,%esp
c0002e05:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:252
	if (page_phyaddr == NULL) {
c0002e08:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0002e0c:	75 19                	jne    c0002e27 <get_a_page+0x147>
/work/x86_os_my/kernel/memory.c:253
		lock_release(&mem_pool->lock);	//哈哈
c0002e0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002e11:	83 c0 10             	add    $0x10,%eax
c0002e14:	83 ec 0c             	sub    $0xc,%esp
c0002e17:	50                   	push   %eax
c0002e18:	e8 29 1b 00 00       	call   c0004946 <lock_release>
c0002e1d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:254
		return NULL;
c0002e20:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e25:	eb 27                	jmp    c0002e4e <get_a_page+0x16e>
/work/x86_os_my/kernel/memory.c:256
	}
	page_table_add((void*)vaddr, page_phyaddr);
c0002e27:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002e2a:	83 ec 08             	sub    $0x8,%esp
c0002e2d:	ff 75 e8             	pushl  -0x18(%ebp)
c0002e30:	50                   	push   %eax
c0002e31:	e8 21 fc ff ff       	call   c0002a57 <page_table_add>
c0002e36:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:258
	
	lock_release(&mem_pool->lock);
c0002e39:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002e3c:	83 c0 10             	add    $0x10,%eax
c0002e3f:	83 ec 0c             	sub    $0xc,%esp
c0002e42:	50                   	push   %eax
c0002e43:	e8 fe 1a 00 00       	call   c0004946 <lock_release>
c0002e48:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:259
	return (void*)vaddr;
c0002e4b:	8b 45 0c             	mov    0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:260
}
c0002e4e:	c9                   	leave  
c0002e4f:	c3                   	ret    

c0002e50 <addr_v2p>:
addr_v2p():
/work/x86_os_my/kernel/memory.c:263

/* 得到虚拟地址映射到的物理地址 */
uint32_t addr_v2p(uint32_t vaddr) {
c0002e50:	55                   	push   %ebp
c0002e51:	89 e5                	mov    %esp,%ebp
c0002e53:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:264
	uint32_t* pte = pte_ptr(vaddr);
c0002e56:	ff 75 08             	pushl  0x8(%ebp)
c0002e59:	e8 59 fb ff ff       	call   c00029b7 <pte_ptr>
c0002e5e:	83 c4 04             	add    $0x4,%esp
c0002e61:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:268
	/* (*pte)的内容是 vaddr 所在 pte 的内容，也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的页表项属性，
	 * 因为页框都是自然页，低 12 位地址是 0，所以页表项 pte（和页目录项 pde）中只需要记录页框的高 20 位地址即可。
	 */
	return ((*pte & 0xfffff000) + (vaddr & 0x00000fff));
c0002e64:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002e67:	8b 00                	mov    (%eax),%eax
c0002e69:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002e6e:	89 c2                	mov    %eax,%edx
c0002e70:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e73:	25 ff 0f 00 00       	and    $0xfff,%eax
c0002e78:	01 d0                	add    %edx,%eax
/work/x86_os_my/kernel/memory.c:269
}
c0002e7a:	c9                   	leave  
c0002e7b:	c3                   	ret    

c0002e7c <arena2block>:
arena2block():
/work/x86_os_my/kernel/memory.c:283
|                     |
| +-----------------+ |
+-+  mem_block_desc |←+
  +-----------------+
*/
static struct mem_block* arena2block(struct arena* a, uint32_t idx) {
c0002e7c:	55                   	push   %ebp
c0002e7d:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/kernel/memory.c:284
	return (struct mem_block*)((uint32_t)a + sizeof(struct arena) + idx * a->desc->block_size);
c0002e7f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e82:	8b 00                	mov    (%eax),%eax
c0002e84:	8b 00                	mov    (%eax),%eax
c0002e86:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0002e8a:	89 c2                	mov    %eax,%edx
c0002e8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e8f:	01 d0                	add    %edx,%eax
c0002e91:	83 c0 0c             	add    $0xc,%eax
/work/x86_os_my/kernel/memory.c:285
}
c0002e94:	5d                   	pop    %ebp
c0002e95:	c3                   	ret    

c0002e96 <block2arena>:
block2arena():
/work/x86_os_my/kernel/memory.c:290

/* 返回内存块mem_block所在的arena地址
 * 取到了虚拟地址mem_block那一整页的地址
 */
static struct arena* block2arena(struct mem_block* b) {
c0002e96:	55                   	push   %ebp
c0002e97:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/kernel/memory.c:291
	return (struct arena*)((uint32_t)b & 0xfffff000);
c0002e99:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e9c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
/work/x86_os_my/kernel/memory.c:292
}
c0002ea1:	5d                   	pop    %ebp
c0002ea2:	c3                   	ret    

c0002ea3 <sys_malloc>:
sys_malloc():
/work/x86_os_my/kernel/memory.c:303
 * 3.内存块地址被返回给用户后，用户可以自由使用此内存块 mem_block
 *   会把此内存块中的 list_elem 型变量 free_elem 覆盖
 *   不过 arena->mem_block_desc->free_list 中的元素已经记录了 mem_block->list_elem 的地址
 *   使用时覆盖的，只是 mem_block 的内容。
 */
void* sys_malloc(uint32_t size) {
c0002ea3:	55                   	push   %ebp
c0002ea4:	89 e5                	mov    %esp,%ebp
c0002ea6:	83 ec 38             	sub    $0x38,%esp
/work/x86_os_my/kernel/memory.c:308
	enum pool_flags PF;
	struct pool* mem_pool;
	uint32_t pool_size;
	struct mem_block_desc* descs;
	struct task_struct* cur_thread = running_thread();
c0002ea9:	e8 d3 0e 00 00       	call   c0003d81 <running_thread>
c0002eae:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/kernel/memory.c:311

	/* 判断用哪个内存池*/
	if (cur_thread->pgdir == NULL) {	// 是内核线程
c0002eb1:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0002eb4:	8b 40 34             	mov    0x34(%eax),%eax
c0002eb7:	85 c0                	test   %eax,%eax
c0002eb9:	75 1f                	jne    c0002eda <sys_malloc+0x37>
/work/x86_os_my/kernel/memory.c:312
		PF = PF_KERNEL;
c0002ebb:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:313
		pool_size = kernel_pool.pool_size;
c0002ec2:	a1 6c 9b 00 c0       	mov    0xc0009b6c,%eax
c0002ec7:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:314
		mem_pool = &kernel_pool;
c0002eca:	c7 45 f0 60 9b 00 c0 	movl   $0xc0009b60,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:315
		descs = k_block_descs;
c0002ed1:	c7 45 e8 a0 9a 00 c0 	movl   $0xc0009aa0,-0x18(%ebp)
c0002ed8:	eb 1f                	jmp    c0002ef9 <sys_malloc+0x56>
/work/x86_os_my/kernel/memory.c:317
	} else {							// 用户进程pcb中的pgdir（页目录表）会在为其分配页表时创建【create_page_dir】
		PF = PF_USER;
c0002eda:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:318
		pool_size = user_pool.pool_size;
c0002ee1:	a1 6c 9a 00 c0       	mov    0xc0009a6c,%eax
c0002ee6:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:319
		mem_pool = &user_pool;
c0002ee9:	c7 45 f0 60 9a 00 c0 	movl   $0xc0009a60,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:320
		descs = cur_thread->u_block_desc;
c0002ef0:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0002ef3:	83 c0 44             	add    $0x44,%eax
c0002ef6:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:324
	}

	/* 若申请的内存不在内存池容量范围内则直接返回NULL */
	if (!(size > 0 && size < pool_size)) {
c0002ef9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002efd:	74 08                	je     c0002f07 <sys_malloc+0x64>
/work/x86_os_my/kernel/memory.c:324 (discriminator 1)
c0002eff:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f02:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0002f05:	72 0a                	jb     c0002f11 <sys_malloc+0x6e>
/work/x86_os_my/kernel/memory.c:325
		return NULL;
c0002f07:	b8 00 00 00 00       	mov    $0x0,%eax
c0002f0c:	e9 c5 02 00 00       	jmp    c00031d6 <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:330
	}

	struct arena* a;
	struct mem_block* b;
	lock_acquire(&mem_pool->lock);
c0002f11:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002f14:	83 c0 10             	add    $0x10,%eax
c0002f17:	83 ec 0c             	sub    $0xc,%esp
c0002f1a:	50                   	push   %eax
c0002f1b:	e8 af 19 00 00       	call   c00048cf <lock_acquire>
c0002f20:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:333

	/* 超过最大内存块1024, 就分配页框 */
	if (size > 1024) {
c0002f23:	81 7d 08 00 04 00 00 	cmpl   $0x400,0x8(%ebp)
c0002f2a:	0f 86 94 00 00 00    	jbe    c0002fc4 <sys_malloc+0x121>
/work/x86_os_my/kernel/memory.c:334
		uint32_t page_cnt = DIV_ROUND_UP(size + sizeof(struct arena), PG_SIZE);	// 向上取整需要的页框数
c0002f30:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f33:	05 0b 10 00 00       	add    $0x100b,%eax
c0002f38:	c1 e8 0c             	shr    $0xc,%eax
c0002f3b:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/kernel/memory.c:336

		a = malloc_page(PF, page_cnt);
c0002f3e:	83 ec 08             	sub    $0x8,%esp
c0002f41:	ff 75 d8             	pushl  -0x28(%ebp)
c0002f44:	ff 75 f4             	pushl  -0xc(%ebp)
c0002f47:	e8 1c fc ff ff       	call   c0002b68 <malloc_page>
c0002f4c:	83 c4 10             	add    $0x10,%esp
c0002f4f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:337
		if (a != NULL) {
c0002f52:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0002f56:	74 50                	je     c0002fa8 <sys_malloc+0x105>
/work/x86_os_my/kernel/memory.c:338
			memset(a, 0, page_cnt * PG_SIZE);
c0002f58:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0002f5b:	c1 e0 0c             	shl    $0xc,%eax
c0002f5e:	83 ec 04             	sub    $0x4,%esp
c0002f61:	50                   	push   %eax
c0002f62:	6a 00                	push   $0x0
c0002f64:	ff 75 d4             	pushl  -0x2c(%ebp)
c0002f67:	e8 2e 0a 00 00       	call   c000399a <memset>
c0002f6c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:342

			// 【arena结构体初始化，情况1】
			/* 对于分配的大块页框,将desc置为NULL, cnt置为页框数, large置为true */
			a->desc = NULL;
c0002f6f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002f72:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/kernel/memory.c:343
			a->cnt = page_cnt;
c0002f78:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002f7b:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0002f7e:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/kernel/memory.c:344
			a->large = true;
c0002f81:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002f84:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/kernel/memory.c:346

			lock_release(&mem_pool->lock);
c0002f8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002f8e:	83 c0 10             	add    $0x10,%eax
c0002f91:	83 ec 0c             	sub    $0xc,%esp
c0002f94:	50                   	push   %eax
c0002f95:	e8 ac 19 00 00       	call   c0004946 <lock_release>
c0002f9a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:347
			return (void*)(a + 1);	// 跨过arena大小，把剩下的内存返回
c0002f9d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002fa0:	83 c0 0c             	add    $0xc,%eax
c0002fa3:	e9 2e 02 00 00       	jmp    c00031d6 <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:349
		} else {
			lock_release(&mem_pool->lock);
c0002fa8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002fab:	83 c0 10             	add    $0x10,%eax
c0002fae:	83 ec 0c             	sub    $0xc,%esp
c0002fb1:	50                   	push   %eax
c0002fb2:	e8 8f 19 00 00       	call   c0004946 <lock_release>
c0002fb7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:350
			return NULL;
c0002fba:	b8 00 00 00 00       	mov    $0x0,%eax
c0002fbf:	e9 12 02 00 00       	jmp    c00031d6 <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:358
	} else {
	/* 若申请的内存小于等于1024,可在各种规格的mem_block_desc中去适配 */
		uint8_t desc_idx;

		/* 从内存块描述符中匹配合适的内存块规格 */
		for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c0002fc4:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
c0002fc8:	eb 25                	jmp    c0002fef <sys_malloc+0x14c>
/work/x86_os_my/kernel/memory.c:359
			if (size <= descs[desc_idx].block_size) {	// 从小往大后,找到后退出
c0002fca:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0002fce:	89 d0                	mov    %edx,%eax
c0002fd0:	01 c0                	add    %eax,%eax
c0002fd2:	01 d0                	add    %edx,%eax
c0002fd4:	c1 e0 03             	shl    $0x3,%eax
c0002fd7:	89 c2                	mov    %eax,%edx
c0002fd9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002fdc:	01 d0                	add    %edx,%eax
c0002fde:	8b 00                	mov    (%eax),%eax
c0002fe0:	3b 45 08             	cmp    0x8(%ebp),%eax
c0002fe3:	73 12                	jae    c0002ff7 <sys_malloc+0x154>
/work/x86_os_my/kernel/memory.c:358 (discriminator 2)
	} else {
	/* 若申请的内存小于等于1024,可在各种规格的mem_block_desc中去适配 */
		uint8_t desc_idx;

		/* 从内存块描述符中匹配合适的内存块规格 */
		for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c0002fe5:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
c0002fe9:	83 c0 01             	add    $0x1,%eax
c0002fec:	88 45 e7             	mov    %al,-0x19(%ebp)
/work/x86_os_my/kernel/memory.c:358 (discriminator 1)
c0002fef:	80 7d e7 06          	cmpb   $0x6,-0x19(%ebp)
c0002ff3:	76 d5                	jbe    c0002fca <sys_malloc+0x127>
c0002ff5:	eb 01                	jmp    c0002ff8 <sys_malloc+0x155>
/work/x86_os_my/kernel/memory.c:360
			if (size <= descs[desc_idx].block_size) {	// 从小往大后,找到后退出
				break;
c0002ff7:	90                   	nop
/work/x86_os_my/kernel/memory.c:366
			}
		}

		/* 若mem_block_desc的free_list中已经没有可用的mem_block,
		 * 就创建新的arena提供mem_block */
		if (list_empty(&descs[desc_idx].free_list)) {
c0002ff8:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0002ffc:	89 d0                	mov    %edx,%eax
c0002ffe:	01 c0                	add    %eax,%eax
c0003000:	01 d0                	add    %edx,%eax
c0003002:	c1 e0 03             	shl    $0x3,%eax
c0003005:	89 c2                	mov    %eax,%edx
c0003007:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000300a:	01 d0                	add    %edx,%eax
c000300c:	83 c0 08             	add    $0x8,%eax
c000300f:	83 ec 0c             	sub    $0xc,%esp
c0003012:	50                   	push   %eax
c0003013:	e8 cc 15 00 00       	call   c00045e4 <list_empty>
c0003018:	83 c4 10             	add    $0x10,%esp
c000301b:	85 c0                	test   %eax,%eax
c000301d:	0f 84 31 01 00 00    	je     c0003154 <sys_malloc+0x2b1>
/work/x86_os_my/kernel/memory.c:367
			a = malloc_page(PF, 1);       // 分配1页框做为arena
c0003023:	83 ec 08             	sub    $0x8,%esp
c0003026:	6a 01                	push   $0x1
c0003028:	ff 75 f4             	pushl  -0xc(%ebp)
c000302b:	e8 38 fb ff ff       	call   c0002b68 <malloc_page>
c0003030:	83 c4 10             	add    $0x10,%esp
c0003033:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:368
			if (a == NULL) {
c0003036:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c000303a:	75 1c                	jne    c0003058 <sys_malloc+0x1b5>
/work/x86_os_my/kernel/memory.c:369
				lock_release(&mem_pool->lock);
c000303c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000303f:	83 c0 10             	add    $0x10,%eax
c0003042:	83 ec 0c             	sub    $0xc,%esp
c0003045:	50                   	push   %eax
c0003046:	e8 fb 18 00 00       	call   c0004946 <lock_release>
c000304b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:370
				return NULL;
c000304e:	b8 00 00 00 00       	mov    $0x0,%eax
c0003053:	e9 7e 01 00 00       	jmp    c00031d6 <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:372
			}
			memset(a, 0, PG_SIZE);
c0003058:	83 ec 04             	sub    $0x4,%esp
c000305b:	68 00 10 00 00       	push   $0x1000
c0003060:	6a 00                	push   $0x0
c0003062:	ff 75 d4             	pushl  -0x2c(%ebp)
c0003065:	e8 30 09 00 00       	call   c000399a <memset>
c000306a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:376

			// 【arena结构体初始化，情况2】
			/* 对于分配的小块内存,将desc置为相应内存块描述符, cnt置为此arena可用的内存块数, large置为false */
			a->desc = &descs[desc_idx];
c000306d:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0003071:	89 d0                	mov    %edx,%eax
c0003073:	01 c0                	add    %eax,%eax
c0003075:	01 d0                	add    %edx,%eax
c0003077:	c1 e0 03             	shl    $0x3,%eax
c000307a:	89 c2                	mov    %eax,%edx
c000307c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000307f:	01 c2                	add    %eax,%edx
c0003081:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0003084:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:377
			a->large = false;
c0003086:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0003089:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/kernel/memory.c:378
			a->cnt = descs[desc_idx].blocks_per_arena;
c0003090:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0003094:	89 d0                	mov    %edx,%eax
c0003096:	01 c0                	add    %eax,%eax
c0003098:	01 d0                	add    %edx,%eax
c000309a:	c1 e0 03             	shl    $0x3,%eax
c000309d:	89 c2                	mov    %eax,%edx
c000309f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00030a2:	01 d0                	add    %edx,%eax
c00030a4:	8b 50 04             	mov    0x4(%eax),%edx
c00030a7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00030aa:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/kernel/memory.c:380

			enum intr_status old_status = intr_disable();
c00030ad:	e8 36 eb ff ff       	call   c0001be8 <intr_disable>
c00030b2:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/kernel/memory.c:383
			/* 开始将arena拆分成内存块,并添加到内存块描述符的free_list中 */
			uint32_t block_idx;
			for (block_idx = 0; block_idx < descs[desc_idx].blocks_per_arena; block_idx++) {
c00030b5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c00030bc:	eb 68                	jmp    c0003126 <sys_malloc+0x283>
/work/x86_os_my/kernel/memory.c:384
				b = arena2block(a, block_idx);
c00030be:	83 ec 08             	sub    $0x8,%esp
c00030c1:	ff 75 e0             	pushl  -0x20(%ebp)
c00030c4:	ff 75 d4             	pushl  -0x2c(%ebp)
c00030c7:	e8 b0 fd ff ff       	call   c0002e7c <arena2block>
c00030cc:	83 c4 10             	add    $0x10,%esp
c00030cf:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/kernel/memory.c:385
				ASSERT(!elem_find(&a->desc->free_list, &b->free_elem));
c00030d2:	8b 45 cc             	mov    -0x34(%ebp),%eax
c00030d5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c00030d8:	8b 12                	mov    (%edx),%edx
c00030da:	83 c2 08             	add    $0x8,%edx
c00030dd:	83 ec 08             	sub    $0x8,%esp
c00030e0:	50                   	push   %eax
c00030e1:	52                   	push   %edx
c00030e2:	e8 30 14 00 00       	call   c0004517 <elem_find>
c00030e7:	83 c4 10             	add    $0x10,%esp
c00030ea:	85 c0                	test   %eax,%eax
c00030ec:	74 1c                	je     c000310a <sys_malloc+0x267>
/work/x86_os_my/kernel/memory.c:385 (discriminator 1)
c00030ee:	68 c8 6a 00 c0       	push   $0xc0006ac8
c00030f3:	68 88 6d 00 c0       	push   $0xc0006d88
c00030f8:	68 81 01 00 00       	push   $0x181
c00030fd:	68 1b 6a 00 c0       	push   $0xc0006a1b
c0003102:	e8 7b f4 ff ff       	call   c0002582 <panic_spin>
c0003107:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:386 (discriminator 2)
				list_append(&a->desc->free_list, &b->free_elem);
c000310a:	8b 45 cc             	mov    -0x34(%ebp),%eax
c000310d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0003110:	8b 12                	mov    (%edx),%edx
c0003112:	83 c2 08             	add    $0x8,%edx
c0003115:	83 ec 08             	sub    $0x8,%esp
c0003118:	50                   	push   %eax
c0003119:	52                   	push   %edx
c000311a:	e8 7e 13 00 00       	call   c000449d <list_append>
c000311f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:383 (discriminator 2)
			a->cnt = descs[desc_idx].blocks_per_arena;

			enum intr_status old_status = intr_disable();
			/* 开始将arena拆分成内存块,并添加到内存块描述符的free_list中 */
			uint32_t block_idx;
			for (block_idx = 0; block_idx < descs[desc_idx].blocks_per_arena; block_idx++) {
c0003122:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
/work/x86_os_my/kernel/memory.c:383 (discriminator 1)
c0003126:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c000312a:	89 d0                	mov    %edx,%eax
c000312c:	01 c0                	add    %eax,%eax
c000312e:	01 d0                	add    %edx,%eax
c0003130:	c1 e0 03             	shl    $0x3,%eax
c0003133:	89 c2                	mov    %eax,%edx
c0003135:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0003138:	01 d0                	add    %edx,%eax
c000313a:	8b 40 04             	mov    0x4(%eax),%eax
c000313d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0003140:	0f 87 78 ff ff ff    	ja     c00030be <sys_malloc+0x21b>
/work/x86_os_my/kernel/memory.c:388
				b = arena2block(a, block_idx);
				ASSERT(!elem_find(&a->desc->free_list, &b->free_elem));
				list_append(&a->desc->free_list, &b->free_elem);
			}
			intr_set_status(old_status);
c0003146:	83 ec 0c             	sub    $0xc,%esp
c0003149:	ff 75 d0             	pushl  -0x30(%ebp)
c000314c:	e8 c0 ea ff ff       	call   c0001c11 <intr_set_status>
c0003151:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:392
		}

		/* 开始分配内存块 */
		b = elem2entry(struct mem_block, free_elem, list_pop(&(descs[desc_idx].free_list)));
c0003154:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0003158:	89 d0                	mov    %edx,%eax
c000315a:	01 c0                	add    %eax,%eax
c000315c:	01 d0                	add    %edx,%eax
c000315e:	c1 e0 03             	shl    $0x3,%eax
c0003161:	89 c2                	mov    %eax,%edx
c0003163:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0003166:	01 d0                	add    %edx,%eax
c0003168:	83 c0 08             	add    $0x8,%eax
c000316b:	83 ec 0c             	sub    $0xc,%esp
c000316e:	50                   	push   %eax
c000316f:	e8 81 13 00 00       	call   c00044f5 <list_pop>
c0003174:	83 c4 10             	add    $0x10,%esp
c0003177:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/kernel/memory.c:393
		memset(b, 0, descs[desc_idx].block_size);
c000317a:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c000317e:	89 d0                	mov    %edx,%eax
c0003180:	01 c0                	add    %eax,%eax
c0003182:	01 d0                	add    %edx,%eax
c0003184:	c1 e0 03             	shl    $0x3,%eax
c0003187:	89 c2                	mov    %eax,%edx
c0003189:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000318c:	01 d0                	add    %edx,%eax
c000318e:	8b 00                	mov    (%eax),%eax
c0003190:	83 ec 04             	sub    $0x4,%esp
c0003193:	50                   	push   %eax
c0003194:	6a 00                	push   $0x0
c0003196:	ff 75 cc             	pushl  -0x34(%ebp)
c0003199:	e8 fc 07 00 00       	call   c000399a <memset>
c000319e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:395

		a = block2arena(b);	// 获取内存块b所在的arena
c00031a1:	83 ec 0c             	sub    $0xc,%esp
c00031a4:	ff 75 cc             	pushl  -0x34(%ebp)
c00031a7:	e8 ea fc ff ff       	call   c0002e96 <block2arena>
c00031ac:	83 c4 10             	add    $0x10,%esp
c00031af:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:396
		a->cnt--;			// 将此arena中的空闲内存块数减1
c00031b2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00031b5:	8b 40 04             	mov    0x4(%eax),%eax
c00031b8:	8d 50 ff             	lea    -0x1(%eax),%edx
c00031bb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00031be:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/kernel/memory.c:398

		lock_release(&mem_pool->lock);
c00031c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00031c4:	83 c0 10             	add    $0x10,%eax
c00031c7:	83 ec 0c             	sub    $0xc,%esp
c00031ca:	50                   	push   %eax
c00031cb:	e8 76 17 00 00       	call   c0004946 <lock_release>
c00031d0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:399
		return (void*)b;
c00031d3:	8b 45 cc             	mov    -0x34(%ebp),%eax
/work/x86_os_my/kernel/memory.c:401
	}
}
c00031d6:	c9                   	leave  
c00031d7:	c3                   	ret    

c00031d8 <pfree>:
pfree():
/work/x86_os_my/kernel/memory.c:406

/* 将物理地址pg_phy_addr回收到物理内存池
 * 清理物理地址池位图
 */
void pfree(uint32_t pg_phy_addr) {
c00031d8:	55                   	push   %ebp
c00031d9:	89 e5                	mov    %esp,%ebp
c00031db:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:408
	struct pool* mem_pool;
	uint32_t bit_idx = 0;
c00031de:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:409
	if (pg_phy_addr >= user_pool.phy_addr_start) {	// 用户物理内存池
c00031e5:	a1 68 9a 00 c0       	mov    0xc0009a68,%eax
c00031ea:	3b 45 08             	cmp    0x8(%ebp),%eax
c00031ed:	77 1b                	ja     c000320a <pfree+0x32>
/work/x86_os_my/kernel/memory.c:410
		mem_pool = &user_pool;
c00031ef:	c7 45 f4 60 9a 00 c0 	movl   $0xc0009a60,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:411
		bit_idx = (pg_phy_addr - user_pool.phy_addr_start) / PG_SIZE;
c00031f6:	a1 68 9a 00 c0       	mov    0xc0009a68,%eax
c00031fb:	8b 55 08             	mov    0x8(%ebp),%edx
c00031fe:	29 c2                	sub    %eax,%edx
c0003200:	89 d0                	mov    %edx,%eax
c0003202:	c1 e8 0c             	shr    $0xc,%eax
c0003205:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0003208:	eb 19                	jmp    c0003223 <pfree+0x4b>
/work/x86_os_my/kernel/memory.c:413
	} else {	// 内核物理内存池
		mem_pool = &kernel_pool;
c000320a:	c7 45 f4 60 9b 00 c0 	movl   $0xc0009b60,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:414
		bit_idx = (pg_phy_addr - kernel_pool.phy_addr_start) / PG_SIZE;
c0003211:	a1 68 9b 00 c0       	mov    0xc0009b68,%eax
c0003216:	8b 55 08             	mov    0x8(%ebp),%edx
c0003219:	29 c2                	sub    %eax,%edx
c000321b:	89 d0                	mov    %edx,%eax
c000321d:	c1 e8 0c             	shr    $0xc,%eax
c0003220:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:416
	}
	bitmap_set(&mem_pool->pool_bitmap, bit_idx, 0);	// 将位图中该位清0
c0003223:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003226:	83 ec 04             	sub    $0x4,%esp
c0003229:	6a 00                	push   $0x0
c000322b:	ff 75 f0             	pushl  -0x10(%ebp)
c000322e:	50                   	push   %eax
c000322f:	e8 bc f5 ff ff       	call   c00027f0 <bitmap_set>
c0003234:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:417
}
c0003237:	90                   	nop
c0003238:	c9                   	leave  
c0003239:	c3                   	ret    

c000323a <page_table_pte_remove>:
page_table_pte_remove():
/work/x86_os_my/kernel/memory.c:420

/* 去掉页表中虚拟地址vaddr的映射,只去掉vaddr对应的pte */
static void page_table_pte_remove(uint32_t vaddr) {
c000323a:	55                   	push   %ebp
c000323b:	89 e5                	mov    %esp,%ebp
c000323d:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:421
	uint32_t* pte = pte_ptr(vaddr);
c0003240:	8b 45 08             	mov    0x8(%ebp),%eax
c0003243:	50                   	push   %eax
c0003244:	e8 6e f7 ff ff       	call   c00029b7 <pte_ptr>
c0003249:	83 c4 04             	add    $0x4,%esp
c000324c:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:422
	*pte &= ~PG_P_1;	// 将页表项pte的P位置0
c000324f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003252:	8b 00                	mov    (%eax),%eax
c0003254:	83 e0 fe             	and    $0xfffffffe,%eax
c0003257:	89 c2                	mov    %eax,%edx
c0003259:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000325c:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:423
	asm volatile ("invlpg %0"::"m" (vaddr):"memory");	//更新tlb
c000325e:	0f 01 7d 08          	invlpg 0x8(%ebp)
/work/x86_os_my/kernel/memory.c:426
	/*更新 TLB 有两种方式，一是用 invlpg 指令更新单条虚拟地址条目，
	另外一个是重新加载 cr3 寄存器，这将直接清空 TLB，相当于更新整个页表。*/
}
c0003262:	90                   	nop
c0003263:	c9                   	leave  
c0003264:	c3                   	ret    

c0003265 <vaddr_remove>:
vaddr_remove():
/work/x86_os_my/kernel/memory.c:431

/* 在虚拟地址池中释放以_vaddr起始的连续pg_cnt个虚拟页地址
 * 清理虚拟地址池位图
 */
static void vaddr_remove(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {
c0003265:	55                   	push   %ebp
c0003266:	89 e5                	mov    %esp,%ebp
c0003268:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:432
	uint32_t bit_idx_start = 0, vaddr = (uint32_t)_vaddr, cnt = 0;
c000326b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0003272:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003275:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0003278:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:434

	if (pf == PF_KERNEL) {	// 内核虚拟内存池
c000327f:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0003283:	75 3f                	jne    c00032c4 <vaddr_remove+0x5f>
/work/x86_os_my/kernel/memory.c:435
		bit_idx_start = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
c0003285:	a1 50 9b 00 c0       	mov    0xc0009b50,%eax
c000328a:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000328d:	29 c2                	sub    %eax,%edx
c000328f:	89 d0                	mov    %edx,%eax
c0003291:	c1 e8 0c             	shr    $0xc,%eax
c0003294:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:436
		while(cnt < pg_cnt) {
c0003297:	eb 21                	jmp    c00032ba <vaddr_remove+0x55>
/work/x86_os_my/kernel/memory.c:437
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
c0003299:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000329c:	8d 50 01             	lea    0x1(%eax),%edx
c000329f:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00032a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00032a5:	01 d0                	add    %edx,%eax
c00032a7:	83 ec 04             	sub    $0x4,%esp
c00032aa:	6a 00                	push   $0x0
c00032ac:	50                   	push   %eax
c00032ad:	68 48 9b 00 c0       	push   $0xc0009b48
c00032b2:	e8 39 f5 ff ff       	call   c00027f0 <bitmap_set>
c00032b7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:436
static void vaddr_remove(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {
	uint32_t bit_idx_start = 0, vaddr = (uint32_t)_vaddr, cnt = 0;

	if (pf == PF_KERNEL) {	// 内核虚拟内存池
		bit_idx_start = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
c00032ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00032bd:	3b 45 10             	cmp    0x10(%ebp),%eax
c00032c0:	72 d7                	jb     c0003299 <vaddr_remove+0x34>
/work/x86_os_my/kernel/memory.c:446
		bit_idx_start = (vaddr - cur_thread->userprog_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
			bitmap_set(&cur_thread->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	}
}
c00032c2:	eb 48                	jmp    c000330c <vaddr_remove+0xa7>
/work/x86_os_my/kernel/memory.c:440
		bit_idx_start = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	} else {	// 用户虚拟内存池
		struct task_struct* cur_thread = running_thread();
c00032c4:	e8 b8 0a 00 00       	call   c0003d81 <running_thread>
c00032c9:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:441
		bit_idx_start = (vaddr - cur_thread->userprog_vaddr.vaddr_start) / PG_SIZE;
c00032cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00032cf:	8b 40 40             	mov    0x40(%eax),%eax
c00032d2:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00032d5:	29 c2                	sub    %eax,%edx
c00032d7:	89 d0                	mov    %edx,%eax
c00032d9:	c1 e8 0c             	shr    $0xc,%eax
c00032dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:442
		while(cnt < pg_cnt) {
c00032df:	eb 23                	jmp    c0003304 <vaddr_remove+0x9f>
/work/x86_os_my/kernel/memory.c:443
			bitmap_set(&cur_thread->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
c00032e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00032e4:	8d 50 01             	lea    0x1(%eax),%edx
c00032e7:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00032ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00032ed:	01 c2                	add    %eax,%edx
c00032ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00032f2:	83 c0 38             	add    $0x38,%eax
c00032f5:	83 ec 04             	sub    $0x4,%esp
c00032f8:	6a 00                	push   $0x0
c00032fa:	52                   	push   %edx
c00032fb:	50                   	push   %eax
c00032fc:	e8 ef f4 ff ff       	call   c00027f0 <bitmap_set>
c0003301:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:442
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	} else {	// 用户虚拟内存池
		struct task_struct* cur_thread = running_thread();
		bit_idx_start = (vaddr - cur_thread->userprog_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
c0003304:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003307:	3b 45 10             	cmp    0x10(%ebp),%eax
c000330a:	72 d5                	jb     c00032e1 <vaddr_remove+0x7c>
/work/x86_os_my/kernel/memory.c:446
			bitmap_set(&cur_thread->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	}
}
c000330c:	90                   	nop
c000330d:	c9                   	leave  
c000330e:	c3                   	ret    

c000330f <mfree_page>:
mfree_page():
/work/x86_os_my/kernel/memory.c:449

/* 释放以虚拟地址vaddr为起始的cnt个物理页框 */
void mfree_page(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {
c000330f:	55                   	push   %ebp
c0003310:	89 e5                	mov    %esp,%ebp
c0003312:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:451
	uint32_t pg_phy_addr;
	uint32_t vaddr = (int32_t)_vaddr, page_cnt = 0;
c0003315:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003318:	89 45 f4             	mov    %eax,-0xc(%ebp)
c000331b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:452
	ASSERT(pg_cnt >=1 && vaddr % PG_SIZE == 0);
c0003322:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0003326:	74 0c                	je     c0003334 <mfree_page+0x25>
/work/x86_os_my/kernel/memory.c:452 (discriminator 1)
c0003328:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000332b:	25 ff 0f 00 00       	and    $0xfff,%eax
c0003330:	85 c0                	test   %eax,%eax
c0003332:	74 1c                	je     c0003350 <mfree_page+0x41>
/work/x86_os_my/kernel/memory.c:452 (discriminator 3)
c0003334:	68 f8 6a 00 c0       	push   $0xc0006af8
c0003339:	68 94 6d 00 c0       	push   $0xc0006d94
c000333e:	68 c4 01 00 00       	push   $0x1c4
c0003343:	68 1b 6a 00 c0       	push   $0xc0006a1b
c0003348:	e8 35 f2 ff ff       	call   c0002582 <panic_spin>
c000334d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:453
	pg_phy_addr = addr_v2p(vaddr);
c0003350:	83 ec 0c             	sub    $0xc,%esp
c0003353:	ff 75 f4             	pushl  -0xc(%ebp)
c0003356:	e8 f5 fa ff ff       	call   c0002e50 <addr_v2p>
c000335b:	83 c4 10             	add    $0x10,%esp
c000335e:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:456

	/* 确保待释放的物理内存在低端1M+1k大小的页目录+1k大小的页表地址范围外【内核空间】 */
	ASSERT((pg_phy_addr % PG_SIZE) == 0 && pg_phy_addr >= 0x102000);
c0003361:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0003364:	25 ff 0f 00 00       	and    $0xfff,%eax
c0003369:	85 c0                	test   %eax,%eax
c000336b:	75 09                	jne    c0003376 <mfree_page+0x67>
/work/x86_os_my/kernel/memory.c:456 (discriminator 1)
c000336d:	81 7d ec ff 1f 10 00 	cmpl   $0x101fff,-0x14(%ebp)
c0003374:	77 1c                	ja     c0003392 <mfree_page+0x83>
/work/x86_os_my/kernel/memory.c:456 (discriminator 3)
c0003376:	68 1c 6b 00 c0       	push   $0xc0006b1c
c000337b:	68 94 6d 00 c0       	push   $0xc0006d94
c0003380:	68 c8 01 00 00       	push   $0x1c8
c0003385:	68 1b 6a 00 c0       	push   $0xc0006a1b
c000338a:	e8 f3 f1 ff ff       	call   c0002582 <panic_spin>
c000338f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:460

	/* 判断pg_phy_addr属于用户物理内存池还是内核物理内存池 */
	/* 位于user_pool内存池 */
	if (pg_phy_addr >= user_pool.phy_addr_start) {
c0003392:	a1 68 9a 00 c0       	mov    0xc0009a68,%eax
c0003397:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c000339a:	0f 87 94 00 00 00    	ja     c0003434 <mfree_page+0x125>
/work/x86_os_my/kernel/memory.c:461
		vaddr -= PG_SIZE;
c00033a0:	81 6d f4 00 10 00 00 	subl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:462
		while (page_cnt < pg_cnt) {
c00033a7:	eb 6a                	jmp    c0003413 <mfree_page+0x104>
/work/x86_os_my/kernel/memory.c:463
			vaddr += PG_SIZE;
c00033a9:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:464
			pg_phy_addr = addr_v2p(vaddr);
c00033b0:	83 ec 0c             	sub    $0xc,%esp
c00033b3:	ff 75 f4             	pushl  -0xc(%ebp)
c00033b6:	e8 95 fa ff ff       	call   c0002e50 <addr_v2p>
c00033bb:	83 c4 10             	add    $0x10,%esp
c00033be:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:467

			/* 确保物理地址属于用户物理内存池 */
			ASSERT((pg_phy_addr % PG_SIZE) == 0 && pg_phy_addr >= user_pool.phy_addr_start);
c00033c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00033c4:	25 ff 0f 00 00       	and    $0xfff,%eax
c00033c9:	85 c0                	test   %eax,%eax
c00033cb:	75 0a                	jne    c00033d7 <mfree_page+0xc8>
/work/x86_os_my/kernel/memory.c:467 (discriminator 1)
c00033cd:	a1 68 9a 00 c0       	mov    0xc0009a68,%eax
c00033d2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00033d5:	76 1c                	jbe    c00033f3 <mfree_page+0xe4>
/work/x86_os_my/kernel/memory.c:467 (discriminator 3)
c00033d7:	68 54 6b 00 c0       	push   $0xc0006b54
c00033dc:	68 94 6d 00 c0       	push   $0xc0006d94
c00033e1:	68 d3 01 00 00       	push   $0x1d3
c00033e6:	68 1b 6a 00 c0       	push   $0xc0006a1b
c00033eb:	e8 92 f1 ff ff       	call   c0002582 <panic_spin>
c00033f0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:470

			/* 先将对应的物理页框归还到内存池 */
			pfree(pg_phy_addr);
c00033f3:	83 ec 0c             	sub    $0xc,%esp
c00033f6:	ff 75 ec             	pushl  -0x14(%ebp)
c00033f9:	e8 da fd ff ff       	call   c00031d8 <pfree>
c00033fe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:473

			/* 再从页表中清除此虚拟地址所在的页表项pte */
			page_table_pte_remove(vaddr);
c0003401:	83 ec 0c             	sub    $0xc,%esp
c0003404:	ff 75 f4             	pushl  -0xc(%ebp)
c0003407:	e8 2e fe ff ff       	call   c000323a <page_table_pte_remove>
c000340c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:475

			page_cnt++;
c000340f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:462

	/* 判断pg_phy_addr属于用户物理内存池还是内核物理内存池 */
	/* 位于user_pool内存池 */
	if (pg_phy_addr >= user_pool.phy_addr_start) {
		vaddr -= PG_SIZE;
		while (page_cnt < pg_cnt) {
c0003413:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003416:	3b 45 10             	cmp    0x10(%ebp),%eax
c0003419:	72 8e                	jb     c00033a9 <mfree_page+0x9a>
/work/x86_os_my/kernel/memory.c:478
			page_table_pte_remove(vaddr);

			page_cnt++;
		}
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);
c000341b:	83 ec 04             	sub    $0x4,%esp
c000341e:	ff 75 10             	pushl  0x10(%ebp)
c0003421:	ff 75 0c             	pushl  0xc(%ebp)
c0003424:	ff 75 08             	pushl  0x8(%ebp)
c0003427:	e8 39 fe ff ff       	call   c0003265 <vaddr_remove>
c000342c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:502
			page_cnt++;
		}
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);
	}
}
c000342f:	e9 99 00 00 00       	jmp    c00034cd <mfree_page+0x1be>
/work/x86_os_my/kernel/memory.c:482
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);

	} else {
		/* 位于kernel_pool内存池 */
		vaddr -= PG_SIZE;
c0003434:	81 6d f4 00 10 00 00 	subl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:483
		while (page_cnt < pg_cnt) {
c000343b:	eb 74                	jmp    c00034b1 <mfree_page+0x1a2>
/work/x86_os_my/kernel/memory.c:484
			vaddr += PG_SIZE;
c000343d:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:485
			pg_phy_addr = addr_v2p(vaddr);
c0003444:	83 ec 0c             	sub    $0xc,%esp
c0003447:	ff 75 f4             	pushl  -0xc(%ebp)
c000344a:	e8 01 fa ff ff       	call   c0002e50 <addr_v2p>
c000344f:	83 c4 10             	add    $0x10,%esp
c0003452:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:488

			/* 确保待释放的物理内存只属于内核物理内存池 */
			ASSERT((pg_phy_addr % PG_SIZE) == 0 && pg_phy_addr >= kernel_pool.phy_addr_start && \
c0003455:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0003458:	25 ff 0f 00 00       	and    $0xfff,%eax
c000345d:	85 c0                	test   %eax,%eax
c000345f:	75 14                	jne    c0003475 <mfree_page+0x166>
/work/x86_os_my/kernel/memory.c:488 (discriminator 1)
c0003461:	a1 68 9b 00 c0       	mov    0xc0009b68,%eax
c0003466:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0003469:	77 0a                	ja     c0003475 <mfree_page+0x166>
/work/x86_os_my/kernel/memory.c:488 (discriminator 3)
c000346b:	a1 68 9a 00 c0       	mov    0xc0009a68,%eax
c0003470:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0003473:	77 1c                	ja     c0003491 <mfree_page+0x182>
/work/x86_os_my/kernel/memory.c:488 (discriminator 5)
c0003475:	68 9c 6b 00 c0       	push   $0xc0006b9c
c000347a:	68 94 6d 00 c0       	push   $0xc0006d94
c000347f:	68 e9 01 00 00       	push   $0x1e9
c0003484:	68 1b 6a 00 c0       	push   $0xc0006a1b
c0003489:	e8 f4 f0 ff ff       	call   c0002582 <panic_spin>
c000348e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:492
					pg_phy_addr < user_pool.phy_addr_start);

			/* 先将对应的物理页框归还到内存池 */
			pfree(pg_phy_addr);
c0003491:	83 ec 0c             	sub    $0xc,%esp
c0003494:	ff 75 ec             	pushl  -0x14(%ebp)
c0003497:	e8 3c fd ff ff       	call   c00031d8 <pfree>
c000349c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:495

			/* 再从页表中清除此虚拟地址所在的页表项pte */
			page_table_pte_remove(vaddr);
c000349f:	83 ec 0c             	sub    $0xc,%esp
c00034a2:	ff 75 f4             	pushl  -0xc(%ebp)
c00034a5:	e8 90 fd ff ff       	call   c000323a <page_table_pte_remove>
c00034aa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:497

			page_cnt++;
c00034ad:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:483
		vaddr_remove(pf, _vaddr, pg_cnt);

	} else {
		/* 位于kernel_pool内存池 */
		vaddr -= PG_SIZE;
		while (page_cnt < pg_cnt) {
c00034b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00034b4:	3b 45 10             	cmp    0x10(%ebp),%eax
c00034b7:	72 84                	jb     c000343d <mfree_page+0x12e>
/work/x86_os_my/kernel/memory.c:500
			page_table_pte_remove(vaddr);

			page_cnt++;
		}
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);
c00034b9:	83 ec 04             	sub    $0x4,%esp
c00034bc:	ff 75 10             	pushl  0x10(%ebp)
c00034bf:	ff 75 0c             	pushl  0xc(%ebp)
c00034c2:	ff 75 08             	pushl  0x8(%ebp)
c00034c5:	e8 9b fd ff ff       	call   c0003265 <vaddr_remove>
c00034ca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:502
	}
}
c00034cd:	90                   	nop
c00034ce:	c9                   	leave  
c00034cf:	c3                   	ret    

c00034d0 <sys_free>:
sys_free():
/work/x86_os_my/kernel/memory.c:505

/* 回收内存ptr */
void sys_free(void* ptr) {
c00034d0:	55                   	push   %ebp
c00034d1:	89 e5                	mov    %esp,%ebp
c00034d3:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:506
	ASSERT(ptr != NULL);
c00034d6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00034da:	75 1c                	jne    c00034f8 <sys_free+0x28>
/work/x86_os_my/kernel/memory.c:506 (discriminator 1)
c00034dc:	68 10 6c 00 c0       	push   $0xc0006c10
c00034e1:	68 a0 6d 00 c0       	push   $0xc0006da0
c00034e6:	68 fa 01 00 00       	push   $0x1fa
c00034eb:	68 1b 6a 00 c0       	push   $0xc0006a1b
c00034f0:	e8 8d f0 ff ff       	call   c0002582 <panic_spin>
c00034f5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:507
	if (ptr != NULL) {
c00034f8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00034fc:	0f 84 b2 01 00 00    	je     c00036b4 <sys_free+0x1e4>
/work/x86_os_my/kernel/memory.c:512
		enum pool_flags PF;
		struct pool* mem_pool;

		/* 判断是线程还是进程 */
		if (running_thread()->pgdir == NULL) {
c0003502:	e8 7a 08 00 00       	call   c0003d81 <running_thread>
c0003507:	8b 40 34             	mov    0x34(%eax),%eax
c000350a:	85 c0                	test   %eax,%eax
c000350c:	75 36                	jne    c0003544 <sys_free+0x74>
/work/x86_os_my/kernel/memory.c:513
			ASSERT((uint32_t)ptr >= K_HEAP_START);
c000350e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003511:	3d ff ff 0f c0       	cmp    $0xc00fffff,%eax
c0003516:	77 1c                	ja     c0003534 <sys_free+0x64>
/work/x86_os_my/kernel/memory.c:513 (discriminator 1)
c0003518:	68 1c 6c 00 c0       	push   $0xc0006c1c
c000351d:	68 a0 6d 00 c0       	push   $0xc0006da0
c0003522:	68 01 02 00 00       	push   $0x201
c0003527:	68 1b 6a 00 c0       	push   $0xc0006a1b
c000352c:	e8 51 f0 ff ff       	call   c0002582 <panic_spin>
c0003531:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:514
			PF = PF_KERNEL;
c0003534:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:515
			mem_pool = &kernel_pool;
c000353b:	c7 45 f0 60 9b 00 c0 	movl   $0xc0009b60,-0x10(%ebp)
c0003542:	eb 0e                	jmp    c0003552 <sys_free+0x82>
/work/x86_os_my/kernel/memory.c:517
		} else {
			PF = PF_USER;
c0003544:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:518
			mem_pool = &user_pool;
c000354b:	c7 45 f0 60 9a 00 c0 	movl   $0xc0009a60,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:521
		}

		lock_acquire(&mem_pool->lock);
c0003552:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003555:	83 c0 10             	add    $0x10,%eax
c0003558:	83 ec 0c             	sub    $0xc,%esp
c000355b:	50                   	push   %eax
c000355c:	e8 6e 13 00 00       	call   c00048cf <lock_acquire>
c0003561:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:522
		struct mem_block* b = ptr;
c0003564:	8b 45 08             	mov    0x8(%ebp),%eax
c0003567:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:523
		struct arena* a = block2arena(b);			// 把mem_block转换成arena,获取元信息
c000356a:	83 ec 0c             	sub    $0xc,%esp
c000356d:	ff 75 e8             	pushl  -0x18(%ebp)
c0003570:	e8 21 f9 ff ff       	call   c0002e96 <block2arena>
c0003575:	83 c4 10             	add    $0x10,%esp
c0003578:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:524
		ASSERT(a->large == 0 || a->large == 1);
c000357b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000357e:	8b 40 08             	mov    0x8(%eax),%eax
c0003581:	85 c0                	test   %eax,%eax
c0003583:	74 27                	je     c00035ac <sys_free+0xdc>
/work/x86_os_my/kernel/memory.c:524 (discriminator 1)
c0003585:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003588:	8b 40 08             	mov    0x8(%eax),%eax
c000358b:	83 f8 01             	cmp    $0x1,%eax
c000358e:	74 1c                	je     c00035ac <sys_free+0xdc>
/work/x86_os_my/kernel/memory.c:524 (discriminator 2)
c0003590:	68 3c 6c 00 c0       	push   $0xc0006c3c
c0003595:	68 a0 6d 00 c0       	push   $0xc0006da0
c000359a:	68 0c 02 00 00       	push   $0x20c
c000359f:	68 1b 6a 00 c0       	push   $0xc0006a1b
c00035a4:	e8 d9 ef ff ff       	call   c0002582 <panic_spin>
c00035a9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:525
		if (a->desc == NULL && a->large == true) {	// 大于1024的内存
c00035ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00035af:	8b 00                	mov    (%eax),%eax
c00035b1:	85 c0                	test   %eax,%eax
c00035b3:	75 28                	jne    c00035dd <sys_free+0x10d>
/work/x86_os_my/kernel/memory.c:525 (discriminator 1)
c00035b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00035b8:	8b 40 08             	mov    0x8(%eax),%eax
c00035bb:	83 f8 01             	cmp    $0x1,%eax
c00035be:	75 1d                	jne    c00035dd <sys_free+0x10d>
/work/x86_os_my/kernel/memory.c:526
			mfree_page(PF, a, a->cnt);
c00035c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00035c3:	8b 40 04             	mov    0x4(%eax),%eax
c00035c6:	83 ec 04             	sub    $0x4,%esp
c00035c9:	50                   	push   %eax
c00035ca:	ff 75 e4             	pushl  -0x1c(%ebp)
c00035cd:	ff 75 f4             	pushl  -0xc(%ebp)
c00035d0:	e8 3a fd ff ff       	call   c000330f <mfree_page>
c00035d5:	83 c4 10             	add    $0x10,%esp
c00035d8:	e9 c5 00 00 00       	jmp    c00036a2 <sys_free+0x1d2>
/work/x86_os_my/kernel/memory.c:530
		} else {									// 小于等于1024的内存块
			/* 先将内存块回收到free_list */
			// &b->free_elem == &b
			list_append(&a->desc->free_list, &b->free_elem);
c00035dd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00035e0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00035e3:	8b 12                	mov    (%edx),%edx
c00035e5:	83 c2 08             	add    $0x8,%edx
c00035e8:	83 ec 08             	sub    $0x8,%esp
c00035eb:	50                   	push   %eax
c00035ec:	52                   	push   %edx
c00035ed:	e8 ab 0e 00 00       	call   c000449d <list_append>
c00035f2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:533

			/* 再判断此arena中的内存块是否都是空闲,如果是就释放arena */
			if (++a->cnt == a->desc->blocks_per_arena) {
c00035f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00035f8:	8b 40 04             	mov    0x4(%eax),%eax
c00035fb:	8d 50 01             	lea    0x1(%eax),%edx
c00035fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003601:	89 50 04             	mov    %edx,0x4(%eax)
c0003604:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003607:	8b 50 04             	mov    0x4(%eax),%edx
c000360a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000360d:	8b 00                	mov    (%eax),%eax
c000360f:	8b 40 04             	mov    0x4(%eax),%eax
c0003612:	39 c2                	cmp    %eax,%edx
c0003614:	0f 85 88 00 00 00    	jne    c00036a2 <sys_free+0x1d2>
/work/x86_os_my/kernel/memory.c:535
				uint32_t block_idx;
				for (block_idx = 0; block_idx < a->desc->blocks_per_arena; block_idx++) {
c000361a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0003621:	eb 5f                	jmp    c0003682 <sys_free+0x1b2>
/work/x86_os_my/kernel/memory.c:536
					struct mem_block*  b = arena2block(a, block_idx);
c0003623:	83 ec 08             	sub    $0x8,%esp
c0003626:	ff 75 ec             	pushl  -0x14(%ebp)
c0003629:	ff 75 e4             	pushl  -0x1c(%ebp)
c000362c:	e8 4b f8 ff ff       	call   c0002e7c <arena2block>
c0003631:	83 c4 10             	add    $0x10,%esp
c0003634:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/kernel/memory.c:537
					ASSERT(elem_find(&a->desc->free_list, &b->free_elem));
c0003637:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000363a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c000363d:	8b 12                	mov    (%edx),%edx
c000363f:	83 c2 08             	add    $0x8,%edx
c0003642:	83 ec 08             	sub    $0x8,%esp
c0003645:	50                   	push   %eax
c0003646:	52                   	push   %edx
c0003647:	e8 cb 0e 00 00       	call   c0004517 <elem_find>
c000364c:	83 c4 10             	add    $0x10,%esp
c000364f:	85 c0                	test   %eax,%eax
c0003651:	75 1c                	jne    c000366f <sys_free+0x19f>
/work/x86_os_my/kernel/memory.c:537 (discriminator 1)
c0003653:	68 5c 6c 00 c0       	push   $0xc0006c5c
c0003658:	68 a0 6d 00 c0       	push   $0xc0006da0
c000365d:	68 19 02 00 00       	push   $0x219
c0003662:	68 1b 6a 00 c0       	push   $0xc0006a1b
c0003667:	e8 16 ef ff ff       	call   c0002582 <panic_spin>
c000366c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:538 (discriminator 2)
					list_remove(&b->free_elem);
c000366f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0003672:	83 ec 0c             	sub    $0xc,%esp
c0003675:	50                   	push   %eax
c0003676:	e8 40 0e 00 00       	call   c00044bb <list_remove>
c000367b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:535 (discriminator 2)
			list_append(&a->desc->free_list, &b->free_elem);

			/* 再判断此arena中的内存块是否都是空闲,如果是就释放arena */
			if (++a->cnt == a->desc->blocks_per_arena) {
				uint32_t block_idx;
				for (block_idx = 0; block_idx < a->desc->blocks_per_arena; block_idx++) {
c000367e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:535 (discriminator 1)
c0003682:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003685:	8b 00                	mov    (%eax),%eax
c0003687:	8b 40 04             	mov    0x4(%eax),%eax
c000368a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c000368d:	77 94                	ja     c0003623 <sys_free+0x153>
/work/x86_os_my/kernel/memory.c:540
					struct mem_block*  b = arena2block(a, block_idx);
					ASSERT(elem_find(&a->desc->free_list, &b->free_elem));
					list_remove(&b->free_elem);
				}
				mfree_page(PF, a, 1);
c000368f:	83 ec 04             	sub    $0x4,%esp
c0003692:	6a 01                	push   $0x1
c0003694:	ff 75 e4             	pushl  -0x1c(%ebp)
c0003697:	ff 75 f4             	pushl  -0xc(%ebp)
c000369a:	e8 70 fc ff ff       	call   c000330f <mfree_page>
c000369f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:543
			}
		}
		lock_release(&mem_pool->lock);
c00036a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00036a5:	83 c0 10             	add    $0x10,%eax
c00036a8:	83 ec 0c             	sub    $0xc,%esp
c00036ab:	50                   	push   %eax
c00036ac:	e8 95 12 00 00       	call   c0004946 <lock_release>
c00036b1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:545
	}
}
c00036b4:	90                   	nop
c00036b5:	c9                   	leave  
c00036b6:	c3                   	ret    

c00036b7 <mem_pool_init>:
mem_pool_init():
/work/x86_os_my/kernel/memory.c:548

/* 初始化内存池 */
static void mem_pool_init(uint32_t all_mem) {
c00036b7:	55                   	push   %ebp
c00036b8:	89 e5                	mov    %esp,%ebp
c00036ba:	83 ec 38             	sub    $0x38,%esp
/work/x86_os_my/kernel/memory.c:549
	put_str("   mem_pool_init start\n");
c00036bd:	83 ec 0c             	sub    $0xc,%esp
c00036c0:	68 8a 6c 00 c0       	push   $0xc0006c8a
c00036c5:	e8 46 ed ff ff       	call   c0002410 <put_str>
c00036ca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:550
	uint32_t page_table_size = PG_SIZE * 256;		// 页表大小= 1页的页目录表+第0和第768个页目录项指向同一个页表+
c00036cd:	c7 45 f4 00 00 10 00 	movl   $0x100000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:552
													// 第769~1022个页目录项共指向254个页表,共256个页框
	uint32_t used_mem = page_table_size + 0x100000;	// 0x100000为低端1M内存
c00036d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00036d7:	05 00 00 10 00       	add    $0x100000,%eax
c00036dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:553
	uint32_t free_mem = all_mem - used_mem;
c00036df:	8b 45 08             	mov    0x8(%ebp),%eax
c00036e2:	2b 45 f0             	sub    -0x10(%ebp),%eax
c00036e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:554
	uint16_t all_free_pages = free_mem / PG_SIZE;	// 1页为4k,不管总内存是不是4k的倍数,
c00036e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00036eb:	c1 e8 0c             	shr    $0xc,%eax
c00036ee:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
/work/x86_os_my/kernel/memory.c:556
													// 对于以页为单位的内存分配策略，不足1页的内存不用考虑了。
	uint16_t kernel_free_pages = all_free_pages / 2;
c00036f2:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c00036f6:	66 d1 e8             	shr    %ax
c00036f9:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:557
	uint16_t user_free_pages = all_free_pages - kernel_free_pages;
c00036fd:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c0003701:	66 2b 45 e8          	sub    -0x18(%ebp),%ax
c0003705:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
/work/x86_os_my/kernel/memory.c:561

	/* 为简化位图操作，余数不处理，坏处是这样做会丢内存。
	好处是不用做内存的越界检查,因为位图表示的内存少于实际物理内存*/
	uint32_t kbm_length = kernel_free_pages / 8;	// Kernel BitMap的长度,位图中的一位表示一页,以字节为单位
c0003709:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c000370d:	66 c1 e8 03          	shr    $0x3,%ax
c0003711:	0f b7 c0             	movzwl %ax,%eax
c0003714:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/kernel/memory.c:562
	uint32_t ubm_length = user_free_pages / 8;		// User BitMap的长度.
c0003717:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c000371b:	66 c1 e8 03          	shr    $0x3,%ax
c000371f:	0f b7 c0             	movzwl %ax,%eax
c0003722:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/kernel/memory.c:564

	uint32_t kp_start = used_mem;								// Kernel Pool start,内核内存池的起始地址
c0003725:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003728:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/kernel/memory.c:565
	uint32_t up_start = kp_start + kernel_free_pages * PG_SIZE;	// User Pool start,用户内存池的起始地址
c000372b:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c000372f:	c1 e0 0c             	shl    $0xc,%eax
c0003732:	89 c2                	mov    %eax,%edx
c0003734:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0003737:	01 d0                	add    %edx,%eax
c0003739:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:567

	kernel_pool.phy_addr_start = kp_start;
c000373c:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000373f:	a3 68 9b 00 c0       	mov    %eax,0xc0009b68
/work/x86_os_my/kernel/memory.c:568
	user_pool.phy_addr_start   = up_start;
c0003744:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0003747:	a3 68 9a 00 c0       	mov    %eax,0xc0009a68
/work/x86_os_my/kernel/memory.c:570

	kernel_pool.pool_size = kernel_free_pages * PG_SIZE;
c000374c:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0003750:	c1 e0 0c             	shl    $0xc,%eax
c0003753:	a3 6c 9b 00 c0       	mov    %eax,0xc0009b6c
/work/x86_os_my/kernel/memory.c:571
	user_pool.pool_size	 = user_free_pages * PG_SIZE;
c0003758:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c000375c:	c1 e0 0c             	shl    $0xc,%eax
c000375f:	a3 6c 9a 00 c0       	mov    %eax,0xc0009a6c
/work/x86_os_my/kernel/memory.c:573

	kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;
c0003764:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0003767:	a3 60 9b 00 c0       	mov    %eax,0xc0009b60
/work/x86_os_my/kernel/memory.c:574
	user_pool.pool_bitmap.btmp_bytes_len	  = ubm_length;
c000376c:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000376f:	a3 60 9a 00 c0       	mov    %eax,0xc0009a60
/work/x86_os_my/kernel/memory.c:583
	*	而我们需要根据总内存大小在运行时，计算出位图的数组需要多少字节。
	*   所以改为指定一块内存来生成位图.
	*   ************************************************/
	// 内核使用的最高地址是0xc009f000,这是主线程的栈地址.(内核的大小预计为70K左右)
	// 32M内存占用的位图是2k.内核内存池的位图先定在MEM_BITMAP_BASE(0xc009a000)处.
	kernel_pool.pool_bitmap.bits = (void*)MEM_BITMAP_BASE;
c0003774:	c7 05 64 9b 00 c0 00 	movl   $0xc009a000,0xc0009b64
c000377b:	a0 09 c0 
/work/x86_os_my/kernel/memory.c:585
	/* 用户内存池的位图紧跟在内核内存池位图之后 */
	user_pool.pool_bitmap.bits = (void*)(MEM_BITMAP_BASE + kbm_length);
c000377e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0003781:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c0003786:	a3 64 9a 00 c0       	mov    %eax,0xc0009a64
/work/x86_os_my/kernel/memory.c:588
	
	/******************** 输出内存池信息 **********************/
	put_str("      kernel_pool_bitmap_start:");put_int((int)kernel_pool.pool_bitmap.bits);
c000378b:	83 ec 0c             	sub    $0xc,%esp
c000378e:	68 a4 6c 00 c0       	push   $0xc0006ca4
c0003793:	e8 78 ec ff ff       	call   c0002410 <put_str>
c0003798:	83 c4 10             	add    $0x10,%esp
c000379b:	a1 64 9b 00 c0       	mov    0xc0009b64,%eax
c00037a0:	83 ec 0c             	sub    $0xc,%esp
c00037a3:	50                   	push   %eax
c00037a4:	e8 52 ed ff ff       	call   c00024fb <put_int>
c00037a9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:589
	put_str(" kernel_pool_phy_addr_start:");put_int(kernel_pool.phy_addr_start);
c00037ac:	83 ec 0c             	sub    $0xc,%esp
c00037af:	68 c4 6c 00 c0       	push   $0xc0006cc4
c00037b4:	e8 57 ec ff ff       	call   c0002410 <put_str>
c00037b9:	83 c4 10             	add    $0x10,%esp
c00037bc:	a1 68 9b 00 c0       	mov    0xc0009b68,%eax
c00037c1:	83 ec 0c             	sub    $0xc,%esp
c00037c4:	50                   	push   %eax
c00037c5:	e8 31 ed ff ff       	call   c00024fb <put_int>
c00037ca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:590
	put_str("\n");
c00037cd:	83 ec 0c             	sub    $0xc,%esp
c00037d0:	68 e1 6c 00 c0       	push   $0xc0006ce1
c00037d5:	e8 36 ec ff ff       	call   c0002410 <put_str>
c00037da:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:591
	put_str("      user_pool_bitmap_start:");put_int((int)user_pool.pool_bitmap.bits);
c00037dd:	83 ec 0c             	sub    $0xc,%esp
c00037e0:	68 e3 6c 00 c0       	push   $0xc0006ce3
c00037e5:	e8 26 ec ff ff       	call   c0002410 <put_str>
c00037ea:	83 c4 10             	add    $0x10,%esp
c00037ed:	a1 64 9a 00 c0       	mov    0xc0009a64,%eax
c00037f2:	83 ec 0c             	sub    $0xc,%esp
c00037f5:	50                   	push   %eax
c00037f6:	e8 00 ed ff ff       	call   c00024fb <put_int>
c00037fb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:592
	put_str(" user_pool_phy_addr_start:");put_int(user_pool.phy_addr_start);
c00037fe:	83 ec 0c             	sub    $0xc,%esp
c0003801:	68 01 6d 00 c0       	push   $0xc0006d01
c0003806:	e8 05 ec ff ff       	call   c0002410 <put_str>
c000380b:	83 c4 10             	add    $0x10,%esp
c000380e:	a1 68 9a 00 c0       	mov    0xc0009a68,%eax
c0003813:	83 ec 0c             	sub    $0xc,%esp
c0003816:	50                   	push   %eax
c0003817:	e8 df ec ff ff       	call   c00024fb <put_int>
c000381c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:593
	put_str("\n");
c000381f:	83 ec 0c             	sub    $0xc,%esp
c0003822:	68 e1 6c 00 c0       	push   $0xc0006ce1
c0003827:	e8 e4 eb ff ff       	call   c0002410 <put_str>
c000382c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:596

	/* 将位图置0*/
	bitmap_init(&kernel_pool.pool_bitmap);
c000382f:	83 ec 0c             	sub    $0xc,%esp
c0003832:	68 60 9b 00 c0       	push   $0xc0009b60
c0003837:	e8 1c ee ff ff       	call   c0002658 <bitmap_init>
c000383c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:597
	bitmap_init(&user_pool.pool_bitmap);
c000383f:	83 ec 0c             	sub    $0xc,%esp
c0003842:	68 60 9a 00 c0       	push   $0xc0009a60
c0003847:	e8 0c ee ff ff       	call   c0002658 <bitmap_init>
c000384c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:599

	lock_init(&kernel_pool.lock);
c000384f:	83 ec 0c             	sub    $0xc,%esp
c0003852:	68 70 9b 00 c0       	push   $0xc0009b70
c0003857:	e8 99 0e 00 00       	call   c00046f5 <lock_init>
c000385c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:600
	lock_init(&user_pool.lock);
c000385f:	83 ec 0c             	sub    $0xc,%esp
c0003862:	68 70 9a 00 c0       	push   $0xc0009a70
c0003867:	e8 89 0e 00 00       	call   c00046f5 <lock_init>
c000386c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:604
	
	/* 下面初始化内核虚拟地址的位图(bp_len + bits数组),按实际物理内存大小生成数组。*/
	// 用于维护内核堆的虚拟地址,所以要和内核内存池大小一致
	kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;
c000386f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0003872:	a3 48 9b 00 c0       	mov    %eax,0xc0009b48
/work/x86_os_my/kernel/memory.c:606
	/* 位图的数组指向一块未使用的内存,目前定位在内核内存池和用户内存池之外*/
	kernel_vaddr.vaddr_bitmap.bits = (void*)(MEM_BITMAP_BASE + kbm_length + ubm_length);
c0003877:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000387a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000387d:	01 d0                	add    %edx,%eax
c000387f:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c0003884:	a3 4c 9b 00 c0       	mov    %eax,0xc0009b4c
/work/x86_os_my/kernel/memory.c:608

	kernel_vaddr.vaddr_start = K_HEAP_START;
c0003889:	c7 05 50 9b 00 c0 00 	movl   $0xc0100000,0xc0009b50
c0003890:	00 10 c0 
/work/x86_os_my/kernel/memory.c:609
	bitmap_init(&kernel_vaddr.vaddr_bitmap);
c0003893:	83 ec 0c             	sub    $0xc,%esp
c0003896:	68 48 9b 00 c0       	push   $0xc0009b48
c000389b:	e8 b8 ed ff ff       	call   c0002658 <bitmap_init>
c00038a0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:610
	put_str("   mem_pool_init done\n");
c00038a3:	83 ec 0c             	sub    $0xc,%esp
c00038a6:	68 1c 6d 00 c0       	push   $0xc0006d1c
c00038ab:	e8 60 eb ff ff       	call   c0002410 <put_str>
c00038b0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:611
}
c00038b3:	90                   	nop
c00038b4:	c9                   	leave  
c00038b5:	c3                   	ret    

c00038b6 <block_desc_init>:
block_desc_init():
/work/x86_os_my/kernel/memory.c:614

/* 为malloc做准备 */
void block_desc_init(struct mem_block_desc* desc_array) {
c00038b6:	55                   	push   %ebp
c00038b7:	89 e5                	mov    %esp,%ebp
c00038b9:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:615
   uint16_t desc_idx, block_size = 16;
c00038bc:	66 c7 45 f4 10 00    	movw   $0x10,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:618

   /* 初始化每个mem_block_desc描述符 */
   for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c00038c2:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
c00038c8:	eb 75                	jmp    c000393f <block_desc_init+0x89>
/work/x86_os_my/kernel/memory.c:619 (discriminator 3)
      desc_array[desc_idx].block_size = block_size;
c00038ca:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c00038ce:	89 d0                	mov    %edx,%eax
c00038d0:	01 c0                	add    %eax,%eax
c00038d2:	01 d0                	add    %edx,%eax
c00038d4:	c1 e0 03             	shl    $0x3,%eax
c00038d7:	89 c2                	mov    %eax,%edx
c00038d9:	8b 45 08             	mov    0x8(%ebp),%eax
c00038dc:	01 c2                	add    %eax,%edx
c00038de:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c00038e2:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/kernel/memory.c:622 (discriminator 3)

      /* 初始化arena中的内存块数量【注意计算方法】 */
      desc_array[desc_idx].blocks_per_arena = (PG_SIZE - sizeof(struct arena)) / block_size;
c00038e4:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c00038e8:	89 d0                	mov    %edx,%eax
c00038ea:	01 c0                	add    %eax,%eax
c00038ec:	01 d0                	add    %edx,%eax
c00038ee:	c1 e0 03             	shl    $0x3,%eax
c00038f1:	89 c2                	mov    %eax,%edx
c00038f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00038f6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c00038f9:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c00038fe:	ba 00 00 00 00       	mov    $0x0,%edx
c0003903:	66 f7 75 f4          	divw   -0xc(%ebp)
c0003907:	0f b7 c0             	movzwl %ax,%eax
c000390a:	89 41 04             	mov    %eax,0x4(%ecx)
/work/x86_os_my/kernel/memory.c:624 (discriminator 3)

      list_init(&desc_array[desc_idx].free_list);
c000390d:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c0003911:	89 d0                	mov    %edx,%eax
c0003913:	01 c0                	add    %eax,%eax
c0003915:	01 d0                	add    %edx,%eax
c0003917:	c1 e0 03             	shl    $0x3,%eax
c000391a:	89 c2                	mov    %eax,%edx
c000391c:	8b 45 08             	mov    0x8(%ebp),%eax
c000391f:	01 d0                	add    %edx,%eax
c0003921:	83 c0 08             	add    $0x8,%eax
c0003924:	83 ec 0c             	sub    $0xc,%esp
c0003927:	50                   	push   %eax
c0003928:	e8 df 0a 00 00       	call   c000440c <list_init>
c000392d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:626 (discriminator 3)

      block_size *= 2;		// 下一个规格内存块！
c0003930:	66 d1 65 f4          	shlw   -0xc(%ebp)
/work/x86_os_my/kernel/memory.c:618 (discriminator 3)
/* 为malloc做准备 */
void block_desc_init(struct mem_block_desc* desc_array) {
   uint16_t desc_idx, block_size = 16;

   /* 初始化每个mem_block_desc描述符 */
   for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c0003934:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0003938:	83 c0 01             	add    $0x1,%eax
c000393b:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/kernel/memory.c:618 (discriminator 1)
c000393f:	66 83 7d f6 06       	cmpw   $0x6,-0xa(%ebp)
c0003944:	76 84                	jbe    c00038ca <block_desc_init+0x14>
/work/x86_os_my/kernel/memory.c:629
      list_init(&desc_array[desc_idx].free_list);

      block_size *= 2;		// 下一个规格内存块！
	  // 16/32/64/128/256/512/1024 总共 7 种规格
   }
}
c0003946:	90                   	nop
c0003947:	c9                   	leave  
c0003948:	c3                   	ret    

c0003949 <mem_init>:
mem_init():
/work/x86_os_my/kernel/memory.c:632

/* 内存管理部分初始化入口 */
void mem_init() {
c0003949:	55                   	push   %ebp
c000394a:	89 e5                	mov    %esp,%ebp
c000394c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:633
	put_str("mem_init start\n");
c000394f:	83 ec 0c             	sub    $0xc,%esp
c0003952:	68 33 6d 00 c0       	push   $0xc0006d33
c0003957:	e8 b4 ea ff ff       	call   c0002410 <put_str>
c000395c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:634
	uint32_t mem_bytes_total = (*(uint32_t*)(0xb00));	//内存总数在汇编中获取，放到了地址0xb00处。
c000395f:	b8 00 0b 00 00       	mov    $0xb00,%eax
c0003964:	8b 00                	mov    (%eax),%eax
c0003966:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:635
	mem_pool_init(mem_bytes_total);	// 初始化内存池
c0003969:	83 ec 0c             	sub    $0xc,%esp
c000396c:	ff 75 f4             	pushl  -0xc(%ebp)
c000396f:	e8 43 fd ff ff       	call   c00036b7 <mem_pool_init>
c0003974:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:636
	block_desc_init(k_block_descs);	// 初始化mem_block_desc数组descs,为malloc做准备
c0003977:	83 ec 0c             	sub    $0xc,%esp
c000397a:	68 a0 9a 00 c0       	push   $0xc0009aa0
c000397f:	e8 32 ff ff ff       	call   c00038b6 <block_desc_init>
c0003984:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:637
	put_str("mem_init done\n");
c0003987:	83 ec 0c             	sub    $0xc,%esp
c000398a:	68 43 6d 00 c0       	push   $0xc0006d43
c000398f:	e8 7c ea ff ff       	call   c0002410 <put_str>
c0003994:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:638
}
c0003997:	90                   	nop
c0003998:	c9                   	leave  
c0003999:	c3                   	ret    

c000399a <memset>:
memset():
/work/x86_os_my/lib/string.c:6
#include "string.h"
#include "global.h"
#include "debug.h"

/* 将dst_起始的size个字节置为value */
void memset(void* dst_, uint8_t value, uint32_t size) {
c000399a:	55                   	push   %ebp
c000399b:	89 e5                	mov    %esp,%ebp
c000399d:	83 ec 28             	sub    $0x28,%esp
c00039a0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00039a3:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:7
   ASSERT(dst_ != NULL);
c00039a6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00039aa:	75 19                	jne    c00039c5 <memset+0x2b>
/work/x86_os_my/lib/string.c:7 (discriminator 1)
c00039ac:	68 ac 6d 00 c0       	push   $0xc0006dac
c00039b1:	68 20 6e 00 c0       	push   $0xc0006e20
c00039b6:	6a 07                	push   $0x7
c00039b8:	68 b9 6d 00 c0       	push   $0xc0006db9
c00039bd:	e8 c0 eb ff ff       	call   c0002582 <panic_spin>
c00039c2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:8
   uint8_t* dst = (uint8_t*)dst_;
c00039c5:	8b 45 08             	mov    0x8(%ebp),%eax
c00039c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:9
   while (size-- > 0)
c00039cb:	eb 0f                	jmp    c00039dc <memset+0x42>
/work/x86_os_my/lib/string.c:10
      *dst++ = value;
c00039cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00039d0:	8d 50 01             	lea    0x1(%eax),%edx
c00039d3:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00039d6:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c00039da:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/string.c:9

/* 将dst_起始的size个字节置为value */
void memset(void* dst_, uint8_t value, uint32_t size) {
   ASSERT(dst_ != NULL);
   uint8_t* dst = (uint8_t*)dst_;
   while (size-- > 0)
c00039dc:	8b 45 10             	mov    0x10(%ebp),%eax
c00039df:	8d 50 ff             	lea    -0x1(%eax),%edx
c00039e2:	89 55 10             	mov    %edx,0x10(%ebp)
c00039e5:	85 c0                	test   %eax,%eax
c00039e7:	75 e4                	jne    c00039cd <memset+0x33>
/work/x86_os_my/lib/string.c:11
      *dst++ = value;
}
c00039e9:	90                   	nop
c00039ea:	c9                   	leave  
c00039eb:	c3                   	ret    

c00039ec <memcpy>:
memcpy():
/work/x86_os_my/lib/string.c:14

/* 将src_起始的size个字节复制到dst_ */
void memcpy(void* dst_, const void* src_, uint32_t size) {
c00039ec:	55                   	push   %ebp
c00039ed:	89 e5                	mov    %esp,%ebp
c00039ef:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:15
   ASSERT(dst_ != NULL && src_ != NULL);
c00039f2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00039f6:	74 06                	je     c00039fe <memcpy+0x12>
/work/x86_os_my/lib/string.c:15 (discriminator 1)
c00039f8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00039fc:	75 19                	jne    c0003a17 <memcpy+0x2b>
/work/x86_os_my/lib/string.c:15 (discriminator 3)
c00039fe:	68 c6 6d 00 c0       	push   $0xc0006dc6
c0003a03:	68 28 6e 00 c0       	push   $0xc0006e28
c0003a08:	6a 0f                	push   $0xf
c0003a0a:	68 b9 6d 00 c0       	push   $0xc0006db9
c0003a0f:	e8 6e eb ff ff       	call   c0002582 <panic_spin>
c0003a14:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:16
   uint8_t* dst = dst_;
c0003a17:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:17
   const uint8_t* src = src_;
c0003a1d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003a20:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:18
   while (size-- > 0)
c0003a23:	eb 17                	jmp    c0003a3c <memcpy+0x50>
/work/x86_os_my/lib/string.c:19
      *dst++ = *src++;
c0003a25:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003a28:	8d 50 01             	lea    0x1(%eax),%edx
c0003a2b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003a2e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0003a31:	8d 4a 01             	lea    0x1(%edx),%ecx
c0003a34:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0003a37:	0f b6 12             	movzbl (%edx),%edx
c0003a3a:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/string.c:18
/* 将src_起始的size个字节复制到dst_ */
void memcpy(void* dst_, const void* src_, uint32_t size) {
   ASSERT(dst_ != NULL && src_ != NULL);
   uint8_t* dst = dst_;
   const uint8_t* src = src_;
   while (size-- > 0)
c0003a3c:	8b 45 10             	mov    0x10(%ebp),%eax
c0003a3f:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003a42:	89 55 10             	mov    %edx,0x10(%ebp)
c0003a45:	85 c0                	test   %eax,%eax
c0003a47:	75 dc                	jne    c0003a25 <memcpy+0x39>
/work/x86_os_my/lib/string.c:20
      *dst++ = *src++;
}
c0003a49:	90                   	nop
c0003a4a:	c9                   	leave  
c0003a4b:	c3                   	ret    

c0003a4c <memcmp>:
memcmp():
/work/x86_os_my/lib/string.c:23

/* 连续比较以地址a_和地址b_开头的size个字节,若相等则返回0,若a_大于b_返回+1,否则返回-1 */
int memcmp(const void* a_, const void* b_, uint32_t size) {
c0003a4c:	55                   	push   %ebp
c0003a4d:	89 e5                	mov    %esp,%ebp
c0003a4f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:24
   const char* a = a_;
c0003a52:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a55:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:25
   const char* b = b_;
c0003a58:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003a5b:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:26
   ASSERT(a != NULL || b != NULL);
c0003a5e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0003a62:	75 57                	jne    c0003abb <memcmp+0x6f>
/work/x86_os_my/lib/string.c:26 (discriminator 1)
c0003a64:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0003a68:	75 51                	jne    c0003abb <memcmp+0x6f>
/work/x86_os_my/lib/string.c:26 (discriminator 2)
c0003a6a:	68 e3 6d 00 c0       	push   $0xc0006de3
c0003a6f:	68 30 6e 00 c0       	push   $0xc0006e30
c0003a74:	6a 1a                	push   $0x1a
c0003a76:	68 b9 6d 00 c0       	push   $0xc0006db9
c0003a7b:	e8 02 eb ff ff       	call   c0002582 <panic_spin>
c0003a80:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:27 (discriminator 2)
   while (size-- > 0) {
c0003a83:	eb 36                	jmp    c0003abb <memcmp+0x6f>
/work/x86_os_my/lib/string.c:28
      if(*a != *b) {
c0003a85:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003a88:	0f b6 10             	movzbl (%eax),%edx
c0003a8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003a8e:	0f b6 00             	movzbl (%eax),%eax
c0003a91:	38 c2                	cmp    %al,%dl
c0003a93:	74 1e                	je     c0003ab3 <memcmp+0x67>
/work/x86_os_my/lib/string.c:29
	 return *a > *b ? 1 : -1; 
c0003a95:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003a98:	0f b6 10             	movzbl (%eax),%edx
c0003a9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003a9e:	0f b6 00             	movzbl (%eax),%eax
c0003aa1:	38 c2                	cmp    %al,%dl
c0003aa3:	7e 07                	jle    c0003aac <memcmp+0x60>
/work/x86_os_my/lib/string.c:29 (discriminator 1)
c0003aa5:	b8 01 00 00 00       	mov    $0x1,%eax
c0003aaa:	eb 21                	jmp    c0003acd <memcmp+0x81>
/work/x86_os_my/lib/string.c:29 (discriminator 2)
c0003aac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0003ab1:	eb 1a                	jmp    c0003acd <memcmp+0x81>
/work/x86_os_my/lib/string.c:31
      }
      a++;
c0003ab3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:32
      b++;
c0003ab7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/string.c:27
/* 连续比较以地址a_和地址b_开头的size个字节,若相等则返回0,若a_大于b_返回+1,否则返回-1 */
int memcmp(const void* a_, const void* b_, uint32_t size) {
   const char* a = a_;
   const char* b = b_;
   ASSERT(a != NULL || b != NULL);
   while (size-- > 0) {
c0003abb:	8b 45 10             	mov    0x10(%ebp),%eax
c0003abe:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003ac1:	89 55 10             	mov    %edx,0x10(%ebp)
c0003ac4:	85 c0                	test   %eax,%eax
c0003ac6:	75 bd                	jne    c0003a85 <memcmp+0x39>
/work/x86_os_my/lib/string.c:34
	 return *a > *b ? 1 : -1; 
      }
      a++;
      b++;
   }
   return 0;
c0003ac8:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/string.c:35
}
c0003acd:	c9                   	leave  
c0003ace:	c3                   	ret    

c0003acf <strcpy>:
strcpy():
/work/x86_os_my/lib/string.c:38

/* 将字符串从src_复制到dst_ */
char* strcpy(char* dst_, const char* src_) {
c0003acf:	55                   	push   %ebp
c0003ad0:	89 e5                	mov    %esp,%ebp
c0003ad2:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:39
   ASSERT(dst_ != NULL && src_ != NULL);
c0003ad5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003ad9:	74 06                	je     c0003ae1 <strcpy+0x12>
/work/x86_os_my/lib/string.c:39 (discriminator 1)
c0003adb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0003adf:	75 19                	jne    c0003afa <strcpy+0x2b>
/work/x86_os_my/lib/string.c:39 (discriminator 3)
c0003ae1:	68 c6 6d 00 c0       	push   $0xc0006dc6
c0003ae6:	68 38 6e 00 c0       	push   $0xc0006e38
c0003aeb:	6a 27                	push   $0x27
c0003aed:	68 b9 6d 00 c0       	push   $0xc0006db9
c0003af2:	e8 8b ea ff ff       	call   c0002582 <panic_spin>
c0003af7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:40
   char* r = dst_;		       // 用来返回目的字符串起始地址
c0003afa:	8b 45 08             	mov    0x8(%ebp),%eax
c0003afd:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:41
   while((*dst_++ = *src_++));
c0003b00:	90                   	nop
/work/x86_os_my/lib/string.c:41 (discriminator 1)
c0003b01:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b04:	8d 50 01             	lea    0x1(%eax),%edx
c0003b07:	89 55 08             	mov    %edx,0x8(%ebp)
c0003b0a:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003b0d:	8d 4a 01             	lea    0x1(%edx),%ecx
c0003b10:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c0003b13:	0f b6 12             	movzbl (%edx),%edx
c0003b16:	88 10                	mov    %dl,(%eax)
c0003b18:	0f b6 00             	movzbl (%eax),%eax
c0003b1b:	84 c0                	test   %al,%al
c0003b1d:	75 e2                	jne    c0003b01 <strcpy+0x32>
/work/x86_os_my/lib/string.c:42
   return r;
c0003b1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:43
}
c0003b22:	c9                   	leave  
c0003b23:	c3                   	ret    

c0003b24 <strlen>:
strlen():
/work/x86_os_my/lib/string.c:46

/* 返回字符串长度 */
uint32_t strlen(const char* str) {
c0003b24:	55                   	push   %ebp
c0003b25:	89 e5                	mov    %esp,%ebp
c0003b27:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:47
   ASSERT(str != NULL);
c0003b2a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003b2e:	75 19                	jne    c0003b49 <strlen+0x25>
/work/x86_os_my/lib/string.c:47 (discriminator 1)
c0003b30:	68 fa 6d 00 c0       	push   $0xc0006dfa
c0003b35:	68 40 6e 00 c0       	push   $0xc0006e40
c0003b3a:	6a 2f                	push   $0x2f
c0003b3c:	68 b9 6d 00 c0       	push   $0xc0006db9
c0003b41:	e8 3c ea ff ff       	call   c0002582 <panic_spin>
c0003b46:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:48
   const char* p = str;
c0003b49:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:49
   while(*p++);
c0003b4f:	90                   	nop
/work/x86_os_my/lib/string.c:49 (discriminator 1)
c0003b50:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003b53:	8d 50 01             	lea    0x1(%eax),%edx
c0003b56:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003b59:	0f b6 00             	movzbl (%eax),%eax
c0003b5c:	84 c0                	test   %al,%al
c0003b5e:	75 f0                	jne    c0003b50 <strlen+0x2c>
/work/x86_os_my/lib/string.c:50
   return (p - str - 1);
c0003b60:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0003b63:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b66:	29 c2                	sub    %eax,%edx
c0003b68:	89 d0                	mov    %edx,%eax
c0003b6a:	83 e8 01             	sub    $0x1,%eax
/work/x86_os_my/lib/string.c:51
}
c0003b6d:	c9                   	leave  
c0003b6e:	c3                   	ret    

c0003b6f <strcmp>:
strcmp():
/work/x86_os_my/lib/string.c:54

/* 比较两个字符串,若a_中的字符大于b_中的字符返回1,相等时返回0,否则返回-1. */
int8_t strcmp (const char* a, const char* b) {
c0003b6f:	55                   	push   %ebp
c0003b70:	89 e5                	mov    %esp,%ebp
c0003b72:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/string.c:55
   ASSERT(a != NULL && b != NULL);
c0003b75:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003b79:	74 06                	je     c0003b81 <strcmp+0x12>
/work/x86_os_my/lib/string.c:55 (discriminator 1)
c0003b7b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0003b7f:	75 19                	jne    c0003b9a <strcmp+0x2b>
/work/x86_os_my/lib/string.c:55 (discriminator 3)
c0003b81:	68 06 6e 00 c0       	push   $0xc0006e06
c0003b86:	68 48 6e 00 c0       	push   $0xc0006e48
c0003b8b:	6a 37                	push   $0x37
c0003b8d:	68 b9 6d 00 c0       	push   $0xc0006db9
c0003b92:	e8 eb e9 ff ff       	call   c0002582 <panic_spin>
c0003b97:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:56 (discriminator 1)
   while (*a != 0 && *a == *b) {
c0003b9a:	eb 08                	jmp    c0003ba4 <strcmp+0x35>
/work/x86_os_my/lib/string.c:57
      a++;
c0003b9c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:58
      b++;
c0003ba0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
/work/x86_os_my/lib/string.c:56
}

/* 比较两个字符串,若a_中的字符大于b_中的字符返回1,相等时返回0,否则返回-1. */
int8_t strcmp (const char* a, const char* b) {
   ASSERT(a != NULL && b != NULL);
   while (*a != 0 && *a == *b) {
c0003ba4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ba7:	0f b6 00             	movzbl (%eax),%eax
c0003baa:	84 c0                	test   %al,%al
c0003bac:	74 10                	je     c0003bbe <strcmp+0x4f>
/work/x86_os_my/lib/string.c:56 (discriminator 1)
c0003bae:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bb1:	0f b6 10             	movzbl (%eax),%edx
c0003bb4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003bb7:	0f b6 00             	movzbl (%eax),%eax
c0003bba:	38 c2                	cmp    %al,%dl
c0003bbc:	74 de                	je     c0003b9c <strcmp+0x2d>
/work/x86_os_my/lib/string.c:62
      a++;
      b++;
   }
/* 如果*a小于*b就返回-1,否则就属于*a大于等于*b的情况。在后面的布尔表达式"*a > *b"中,
 * 若*a大于*b,表达式就等于1,否则就表达式不成立,也就是布尔值为0,恰恰表示*a等于*b */
   return *a < *b ? -1 : *a > *b;
c0003bbe:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bc1:	0f b6 10             	movzbl (%eax),%edx
c0003bc4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003bc7:	0f b6 00             	movzbl (%eax),%eax
c0003bca:	38 c2                	cmp    %al,%dl
c0003bcc:	7c 13                	jl     c0003be1 <strcmp+0x72>
/work/x86_os_my/lib/string.c:62 (discriminator 1)
c0003bce:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bd1:	0f b6 10             	movzbl (%eax),%edx
c0003bd4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003bd7:	0f b6 00             	movzbl (%eax),%eax
c0003bda:	38 c2                	cmp    %al,%dl
c0003bdc:	0f 9f c0             	setg   %al
c0003bdf:	eb 05                	jmp    c0003be6 <strcmp+0x77>
/work/x86_os_my/lib/string.c:62 (discriminator 2)
c0003be1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/lib/string.c:63 (discriminator 5)
}
c0003be6:	c9                   	leave  
c0003be7:	c3                   	ret    

c0003be8 <strchr>:
strchr():
/work/x86_os_my/lib/string.c:66

/* 从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strchr(const char* str, const uint8_t ch) {
c0003be8:	55                   	push   %ebp
c0003be9:	89 e5                	mov    %esp,%ebp
c0003beb:	83 ec 18             	sub    $0x18,%esp
c0003bee:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003bf1:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/lib/string.c:67
   ASSERT(str != NULL);
c0003bf4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003bf8:	75 35                	jne    c0003c2f <strchr+0x47>
/work/x86_os_my/lib/string.c:67 (discriminator 1)
c0003bfa:	68 fa 6d 00 c0       	push   $0xc0006dfa
c0003bff:	68 50 6e 00 c0       	push   $0xc0006e50
c0003c04:	6a 43                	push   $0x43
c0003c06:	68 b9 6d 00 c0       	push   $0xc0006db9
c0003c0b:	e8 72 e9 ff ff       	call   c0002582 <panic_spin>
c0003c10:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:68 (discriminator 1)
   while (*str != 0) {
c0003c13:	eb 1a                	jmp    c0003c2f <strchr+0x47>
/work/x86_os_my/lib/string.c:69
      if (*str == ch) {
c0003c15:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c18:	0f b6 00             	movzbl (%eax),%eax
c0003c1b:	0f be d0             	movsbl %al,%edx
c0003c1e:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0003c22:	39 c2                	cmp    %eax,%edx
c0003c24:	75 05                	jne    c0003c2b <strchr+0x43>
/work/x86_os_my/lib/string.c:70
	 return (char*)str;	    // 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.
c0003c26:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c29:	eb 13                	jmp    c0003c3e <strchr+0x56>
/work/x86_os_my/lib/string.c:72
      }
      str++;
c0003c2b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:68
}

/* 从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strchr(const char* str, const uint8_t ch) {
   ASSERT(str != NULL);
   while (*str != 0) {
c0003c2f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c32:	0f b6 00             	movzbl (%eax),%eax
c0003c35:	84 c0                	test   %al,%al
c0003c37:	75 dc                	jne    c0003c15 <strchr+0x2d>
/work/x86_os_my/lib/string.c:74
      if (*str == ch) {
	 return (char*)str;	    // 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.
      }
      str++;
   }
   return NULL;
c0003c39:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/string.c:75
}
c0003c3e:	c9                   	leave  
c0003c3f:	c3                   	ret    

c0003c40 <strrchr>:
strrchr():
/work/x86_os_my/lib/string.c:78

/* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strrchr(const char* str, const uint8_t ch) {
c0003c40:	55                   	push   %ebp
c0003c41:	89 e5                	mov    %esp,%ebp
c0003c43:	83 ec 28             	sub    $0x28,%esp
c0003c46:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003c49:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:79
   ASSERT(str != NULL);
c0003c4c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003c50:	75 19                	jne    c0003c6b <strrchr+0x2b>
/work/x86_os_my/lib/string.c:79 (discriminator 1)
c0003c52:	68 fa 6d 00 c0       	push   $0xc0006dfa
c0003c57:	68 58 6e 00 c0       	push   $0xc0006e58
c0003c5c:	6a 4f                	push   $0x4f
c0003c5e:	68 b9 6d 00 c0       	push   $0xc0006db9
c0003c63:	e8 1a e9 ff ff       	call   c0002582 <panic_spin>
c0003c68:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:80
   const char* last_char = NULL;
c0003c6b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/string.c:82
   /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/
   while (*str != 0) {
c0003c72:	eb 1b                	jmp    c0003c8f <strrchr+0x4f>
/work/x86_os_my/lib/string.c:83
      if (*str == ch) {
c0003c74:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c77:	0f b6 00             	movzbl (%eax),%eax
c0003c7a:	0f be d0             	movsbl %al,%edx
c0003c7d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0003c81:	39 c2                	cmp    %eax,%edx
c0003c83:	75 06                	jne    c0003c8b <strrchr+0x4b>
/work/x86_os_my/lib/string.c:84
	 last_char = str;
c0003c85:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c88:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:86
      }
      str++;
c0003c8b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:82
/* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strrchr(const char* str, const uint8_t ch) {
   ASSERT(str != NULL);
   const char* last_char = NULL;
   /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/
   while (*str != 0) {
c0003c8f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c92:	0f b6 00             	movzbl (%eax),%eax
c0003c95:	84 c0                	test   %al,%al
c0003c97:	75 db                	jne    c0003c74 <strrchr+0x34>
/work/x86_os_my/lib/string.c:88
      if (*str == ch) {
	 last_char = str;
      }
      str++;
   }
   return (char*)last_char;
c0003c99:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:89
}
c0003c9c:	c9                   	leave  
c0003c9d:	c3                   	ret    

c0003c9e <strcat>:
strcat():
/work/x86_os_my/lib/string.c:92

/* 将字符串src_拼接到dst_后,将回拼接的串地址 */
char* strcat(char* dst_, const char* src_) {
c0003c9e:	55                   	push   %ebp
c0003c9f:	89 e5                	mov    %esp,%ebp
c0003ca1:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:93
   ASSERT(dst_ != NULL && src_ != NULL);
c0003ca4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003ca8:	74 06                	je     c0003cb0 <strcat+0x12>
/work/x86_os_my/lib/string.c:93 (discriminator 1)
c0003caa:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0003cae:	75 19                	jne    c0003cc9 <strcat+0x2b>
/work/x86_os_my/lib/string.c:93 (discriminator 3)
c0003cb0:	68 c6 6d 00 c0       	push   $0xc0006dc6
c0003cb5:	68 60 6e 00 c0       	push   $0xc0006e60
c0003cba:	6a 5d                	push   $0x5d
c0003cbc:	68 b9 6d 00 c0       	push   $0xc0006db9
c0003cc1:	e8 bc e8 ff ff       	call   c0002582 <panic_spin>
c0003cc6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:94
   char* str = dst_;
c0003cc9:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ccc:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:95
   while (*str++);
c0003ccf:	90                   	nop
/work/x86_os_my/lib/string.c:95 (discriminator 1)
c0003cd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003cd3:	8d 50 01             	lea    0x1(%eax),%edx
c0003cd6:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003cd9:	0f b6 00             	movzbl (%eax),%eax
c0003cdc:	84 c0                	test   %al,%al
c0003cde:	75 f0                	jne    c0003cd0 <strcat+0x32>
/work/x86_os_my/lib/string.c:96
   --str;      // 别看错了，--str是独立的一句，并不是while的循环体
c0003ce0:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:97
   while((*str++ = *src_++));	 // 当*str被赋值为0时,此时表达式不成立,正好添加了字符串结尾的0.
c0003ce4:	90                   	nop
/work/x86_os_my/lib/string.c:97 (discriminator 1)
c0003ce5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003ce8:	8d 50 01             	lea    0x1(%eax),%edx
c0003ceb:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003cee:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003cf1:	8d 4a 01             	lea    0x1(%edx),%ecx
c0003cf4:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c0003cf7:	0f b6 12             	movzbl (%edx),%edx
c0003cfa:	88 10                	mov    %dl,(%eax)
c0003cfc:	0f b6 00             	movzbl (%eax),%eax
c0003cff:	84 c0                	test   %al,%al
c0003d01:	75 e2                	jne    c0003ce5 <strcat+0x47>
/work/x86_os_my/lib/string.c:98
   return dst_;
c0003d03:	8b 45 08             	mov    0x8(%ebp),%eax
/work/x86_os_my/lib/string.c:99
}
c0003d06:	c9                   	leave  
c0003d07:	c3                   	ret    

c0003d08 <strchrs>:
strchrs():
/work/x86_os_my/lib/string.c:102

/* 在字符串str中查找指定字符ch出现的次数 */
uint32_t strchrs(const char* str, uint8_t ch) {
c0003d08:	55                   	push   %ebp
c0003d09:	89 e5                	mov    %esp,%ebp
c0003d0b:	83 ec 28             	sub    $0x28,%esp
c0003d0e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003d11:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:103
   ASSERT(str != NULL);
c0003d14:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003d18:	75 19                	jne    c0003d33 <strchrs+0x2b>
/work/x86_os_my/lib/string.c:103 (discriminator 1)
c0003d1a:	68 fa 6d 00 c0       	push   $0xc0006dfa
c0003d1f:	68 68 6e 00 c0       	push   $0xc0006e68
c0003d24:	6a 67                	push   $0x67
c0003d26:	68 b9 6d 00 c0       	push   $0xc0006db9
c0003d2b:	e8 52 e8 ff ff       	call   c0002582 <panic_spin>
c0003d30:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:104
   uint32_t ch_cnt = 0;
c0003d33:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/string.c:105
   const char* p = str;
c0003d3a:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d3d:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:106
   while(*p != 0) {
c0003d40:	eb 19                	jmp    c0003d5b <strchrs+0x53>
/work/x86_os_my/lib/string.c:107
      if (*p == ch) {
c0003d42:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003d45:	0f b6 00             	movzbl (%eax),%eax
c0003d48:	0f be d0             	movsbl %al,%edx
c0003d4b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0003d4f:	39 c2                	cmp    %eax,%edx
c0003d51:	75 04                	jne    c0003d57 <strchrs+0x4f>
/work/x86_os_my/lib/string.c:108
	 ch_cnt++;
c0003d53:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:110
      }
      p++;
c0003d57:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/string.c:106
/* 在字符串str中查找指定字符ch出现的次数 */
uint32_t strchrs(const char* str, uint8_t ch) {
   ASSERT(str != NULL);
   uint32_t ch_cnt = 0;
   const char* p = str;
   while(*p != 0) {
c0003d5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003d5e:	0f b6 00             	movzbl (%eax),%eax
c0003d61:	84 c0                	test   %al,%al
c0003d63:	75 dd                	jne    c0003d42 <strchrs+0x3a>
/work/x86_os_my/lib/string.c:112
      if (*p == ch) {
	 ch_cnt++;
      }
      p++;
   }
   return ch_cnt;
c0003d65:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:113
}
c0003d68:	c9                   	leave  
c0003d69:	c3                   	ret    

c0003d6a <idle>:
idle():
/work/x86_os_my/thread/thread.c:22
static struct list_elem* g_thread_tag;// 用于临时保存队列中的线程结点

extern void switch_to(struct task_struct* cur, struct task_struct* next);

/* idle线程 */
static void idle(void* arg UNUSED) {
c0003d6a:	55                   	push   %ebp
c0003d6b:	89 e5                	mov    %esp,%ebp
c0003d6d:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:24 (discriminator 1)
	while(1) {
		thread_block(TASK_BLOCKED);
c0003d70:	83 ec 0c             	sub    $0xc,%esp
c0003d73:	6a 02                	push   $0x2
c0003d75:	e8 38 04 00 00       	call   c00041b2 <thread_block>
c0003d7a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:28 (discriminator 1)
		//CPU停机
		//唯一能唤醒处理器的就是外部中断
		//执行hlt时必须要保证目前处在开中断的情况下
		asm volatile ("sti; hlt" : : : "memory");
c0003d7d:	fb                   	sti    
c0003d7e:	f4                   	hlt    
/work/x86_os_my/thread/thread.c:29 (discriminator 1)
	}
c0003d7f:	eb ef                	jmp    c0003d70 <idle+0x6>

c0003d81 <running_thread>:
running_thread():
/work/x86_os_my/thread/thread.c:36

/* 返回线程 PCB 地址。
 * 各个线程所用的 0 级栈都是在自己的 PCB 当中，
 * 取当前栈指针的高 20 位，就是当前运行线程的 PCB（PCB是在自然页的起始地址！）
 */
struct task_struct* running_thread() {
c0003d81:	55                   	push   %ebp
c0003d82:	89 e5                	mov    %esp,%ebp
c0003d84:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:38
	uint32_t esp;
	asm ("mov %%esp, %0" : "=g" (esp));	//esp寄存器的值，放入变量esp
c0003d87:	89 e0                	mov    %esp,%eax
c0003d89:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:39
	return (struct task_struct*)(esp & 0xfffff000);
c0003d8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003d8f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
/work/x86_os_my/thread/thread.c:40
}
c0003d94:	c9                   	leave  
c0003d95:	c3                   	ret    

c0003d96 <kernel_thread>:
kernel_thread():
/work/x86_os_my/thread/thread.c:43

/* 由kernel_thread去执行function(func_arg) */
static void kernel_thread(thread_func* function, void* func_arg) {
c0003d96:	55                   	push   %ebp
c0003d97:	89 e5                	mov    %esp,%ebp
c0003d99:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:49
	/* 线程的首次运行是由时钟中断处理函数调用任务调度器 schedule 完成的，
	 * 进入中断后处理器会自动关中断，
	 * 因此在执行 function 前要打开中断，否则 kernel_thread 中的 function 在关中断的情况下运行，
	 * 也就是时钟中断被屏蔽了，再也不会调度到新的线程，function 会独享处理器。
	 */
	intr_enable();
c0003d9c:	e8 1e de ff ff       	call   c0001bbf <intr_enable>
/work/x86_os_my/thread/thread.c:50
	function(func_arg); 
c0003da1:	83 ec 0c             	sub    $0xc,%esp
c0003da4:	ff 75 0c             	pushl  0xc(%ebp)
c0003da7:	8b 45 08             	mov    0x8(%ebp),%eax
c0003daa:	ff d0                	call   *%eax
c0003dac:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:51
}
c0003daf:	90                   	nop
c0003db0:	c9                   	leave  
c0003db1:	c3                   	ret    

c0003db2 <allocate_pid>:
allocate_pid():
/work/x86_os_my/thread/thread.c:54

/* 分配pid */
static pid_t allocate_pid(void) {
c0003db2:	55                   	push   %ebp
c0003db3:	89 e5                	mov    %esp,%ebp
c0003db5:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:56
   static pid_t next_pid = 0;
   lock_acquire(&pid_lock);
c0003db8:	83 ec 0c             	sub    $0xc,%esp
c0003dbb:	68 b4 9b 00 c0       	push   $0xc0009bb4
c0003dc0:	e8 0a 0b 00 00       	call   c00048cf <lock_acquire>
c0003dc5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:57
   next_pid++;
c0003dc8:	0f b7 05 6c 95 00 c0 	movzwl 0xc000956c,%eax
c0003dcf:	83 c0 01             	add    $0x1,%eax
c0003dd2:	66 a3 6c 95 00 c0    	mov    %ax,0xc000956c
/work/x86_os_my/thread/thread.c:58
   lock_release(&pid_lock);
c0003dd8:	83 ec 0c             	sub    $0xc,%esp
c0003ddb:	68 b4 9b 00 c0       	push   $0xc0009bb4
c0003de0:	e8 61 0b 00 00       	call   c0004946 <lock_release>
c0003de5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:59
   return next_pid;
c0003de8:	0f b7 05 6c 95 00 c0 	movzwl 0xc000956c,%eax
/work/x86_os_my/thread/thread.c:60
}
c0003def:	c9                   	leave  
c0003df0:	c3                   	ret    

c0003df1 <thread_create>:
thread_create():
/work/x86_os_my/thread/thread.c:63

/* 初始化线程栈结构体 struct thread_stack */
void thread_create(struct task_struct* pthread, thread_func function, void* func_arg) {
c0003df1:	55                   	push   %ebp
c0003df2:	89 e5                	mov    %esp,%ebp
c0003df4:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:67
	/* 先预留中断使用栈的空间 
	 *（1）将来线程进入中断后，位于 kernel.S 中的中断代码会通过此栈来保存上下文。
	 *（2）将来实现用户进程时，会将用户进程的初始信息放在中断栈中。*/
	pthread->self_kstack -= sizeof(struct intr_stack);
c0003df7:	8b 45 08             	mov    0x8(%ebp),%eax
c0003dfa:	8b 00                	mov    (%eax),%eax
c0003dfc:	8d 90 d0 fe ff ff    	lea    -0x130(%eax),%edx
c0003e02:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e05:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:70

	/* 再留出线程栈空间（unused_retaddr 所在的栈）*/
	pthread->self_kstack -= sizeof(struct thread_stack);
c0003e07:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e0a:	8b 00                	mov    (%eax),%eax
c0003e0c:	8d 50 80             	lea    -0x80(%eax),%edx
c0003e0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e12:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:71
	struct thread_stack* kthread_stack = (struct thread_stack*)pthread->self_kstack;
c0003e14:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e17:	8b 00                	mov    (%eax),%eax
c0003e19:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:79
	 * kernel_thread 并不是通过 call 指令调用的，而是通过 ret 来执行的，
	 * 因此无法按照正常的函数调用形式传递 kernel_thread 所需要的参数，
	 * 这样调用是不行的： kernel_thread(function, func_arg)，
	 * 只能将参数放在 kernel_thread 所用的栈中，即处理器进入 kernel_thread 函数体时，
	 * 栈顶为返回地址，栈顶+4 为参数function，栈顶+8 为参数func_arg */
	kthread_stack->eip = kernel_thread;
c0003e1c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003e1f:	c7 40 10 96 3d 00 c0 	movl   $0xc0003d96,0x10(%eax)
/work/x86_os_my/thread/thread.c:80
	kthread_stack->function = function;
c0003e26:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003e29:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003e2c:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/thread.c:81
	kthread_stack->func_arg = func_arg;
c0003e2f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003e32:	8b 55 10             	mov    0x10(%ebp),%edx
c0003e35:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/thread/thread.c:82
	kthread_stack->ebp = kthread_stack->ebx = kthread_stack->esi = kthread_stack->edi = 0;
c0003e38:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003e3b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c0003e42:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003e45:	8b 50 08             	mov    0x8(%eax),%edx
c0003e48:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003e4b:	89 50 0c             	mov    %edx,0xc(%eax)
c0003e4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003e51:	8b 50 0c             	mov    0xc(%eax),%edx
c0003e54:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003e57:	89 50 04             	mov    %edx,0x4(%eax)
c0003e5a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003e5d:	8b 50 04             	mov    0x4(%eax),%edx
c0003e60:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003e63:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:83
}
c0003e65:	90                   	nop
c0003e66:	c9                   	leave  
c0003e67:	c3                   	ret    

c0003e68 <init_thread>:
init_thread():
/work/x86_os_my/thread/thread.c:86

/* 初始化线程PCB结构体 struct task_struct */
void init_thread(struct task_struct* pthread, char* name, int prio) {
c0003e68:	55                   	push   %ebp
c0003e69:	89 e5                	mov    %esp,%ebp
c0003e6b:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:87
	memset(pthread, 0, sizeof(*pthread));	//清空PCB
c0003e6e:	83 ec 04             	sub    $0x4,%esp
c0003e71:	68 f0 00 00 00       	push   $0xf0
c0003e76:	6a 00                	push   $0x0
c0003e78:	ff 75 08             	pushl  0x8(%ebp)
c0003e7b:	e8 1a fb ff ff       	call   c000399a <memset>
c0003e80:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:88
	pthread->pid = allocate_pid();
c0003e83:	e8 2a ff ff ff       	call   c0003db2 <allocate_pid>
c0003e88:	89 c2                	mov    %eax,%edx
c0003e8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e8d:	66 89 50 04          	mov    %dx,0x4(%eax)
/work/x86_os_my/thread/thread.c:89
	strcpy(pthread->name, name);
c0003e91:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e94:	83 c0 0c             	add    $0xc,%eax
c0003e97:	83 ec 08             	sub    $0x8,%esp
c0003e9a:	ff 75 0c             	pushl  0xc(%ebp)
c0003e9d:	50                   	push   %eax
c0003e9e:	e8 2c fc ff ff       	call   c0003acf <strcpy>
c0003ea3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:91

	if (pthread == g_main_thread) {
c0003ea6:	a1 b0 9b 00 c0       	mov    0xc0009bb0,%eax
c0003eab:	39 45 08             	cmp    %eax,0x8(%ebp)
c0003eae:	75 0c                	jne    c0003ebc <init_thread+0x54>
/work/x86_os_my/thread/thread.c:93
		/* 由于把main函数也封装成一个线程,并且它一直是运行的,故将其直接设为TASK_RUNNING */
		pthread->status = TASK_RUNNING;
c0003eb0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003eb3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c0003eba:	eb 0a                	jmp    c0003ec6 <init_thread+0x5e>
/work/x86_os_my/thread/thread.c:95
	} else {
		pthread->status = TASK_READY;
c0003ebc:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ebf:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:101
	}

	/* self_kstack是线程自己在内核态下使用的栈顶地址 
	 * 线程自己在 0 特权级下所用的栈，在线程创建之初，
	 * 它被初始化为线程 PCB 的最顶端，即(uint32_t)pthread + PG_SIZE。*/
	pthread->self_kstack = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c0003ec6:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ec9:	05 00 10 00 00       	add    $0x1000,%eax
c0003ece:	89 c2                	mov    %eax,%edx
c0003ed0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ed3:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:102
	pthread->priority = prio;
c0003ed5:	8b 45 10             	mov    0x10(%ebp),%eax
c0003ed8:	89 c2                	mov    %eax,%edx
c0003eda:	8b 45 08             	mov    0x8(%ebp),%eax
c0003edd:	88 50 1c             	mov    %dl,0x1c(%eax)
/work/x86_os_my/thread/thread.c:103
	pthread->ticks = prio;
c0003ee0:	8b 45 10             	mov    0x10(%ebp),%eax
c0003ee3:	89 c2                	mov    %eax,%edx
c0003ee5:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ee8:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/thread/thread.c:104
	pthread->elapsed_ticks = 0;
c0003eeb:	8b 45 08             	mov    0x8(%ebp),%eax
c0003eee:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
/work/x86_os_my/thread/thread.c:105
	pthread->pgdir = NULL;
c0003ef5:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ef8:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
/work/x86_os_my/thread/thread.c:106
	pthread->stack_magic = 0x19870916;	  // 自定义的魔数
c0003eff:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f02:	c7 80 ec 00 00 00 16 	movl   $0x19870916,0xec(%eax)
c0003f09:	09 87 19 
/work/x86_os_my/thread/thread.c:107
}
c0003f0c:	90                   	nop
c0003f0d:	c9                   	leave  
c0003f0e:	c3                   	ret    

c0003f0f <thread_start>:
thread_start():
/work/x86_os_my/thread/thread.c:110

/* 创建线程 */
struct task_struct* thread_start(char* name, int prio, thread_func function, void* func_arg) {
c0003f0f:	55                   	push   %ebp
c0003f10:	89 e5                	mov    %esp,%ebp
c0003f12:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:112
	/* pcb都位于内核空间,包括用户进程的pcb也是在内核空间 */
	struct task_struct* thread = get_kernel_pages(1);
c0003f15:	83 ec 0c             	sub    $0xc,%esp
c0003f18:	6a 01                	push   $0x1
c0003f1a:	e8 0b ed ff ff       	call   c0002c2a <get_kernel_pages>
c0003f1f:	83 c4 10             	add    $0x10,%esp
c0003f22:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:114

	init_thread(thread, name, prio);			//初始化线程PCB
c0003f25:	83 ec 04             	sub    $0x4,%esp
c0003f28:	ff 75 0c             	pushl  0xc(%ebp)
c0003f2b:	ff 75 08             	pushl  0x8(%ebp)
c0003f2e:	ff 75 f4             	pushl  -0xc(%ebp)
c0003f31:	e8 32 ff ff ff       	call   c0003e68 <init_thread>
c0003f36:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:115
	thread_create(thread, function, func_arg);	//初始化线程栈结构体
c0003f39:	83 ec 04             	sub    $0x4,%esp
c0003f3c:	ff 75 14             	pushl  0x14(%ebp)
c0003f3f:	ff 75 10             	pushl  0x10(%ebp)
c0003f42:	ff 75 f4             	pushl  -0xc(%ebp)
c0003f45:	e8 a7 fe ff ff       	call   c0003df1 <thread_create>
c0003f4a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:117
	
	ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));	// 确保之前不在队列中
c0003f4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003f50:	83 c0 24             	add    $0x24,%eax
c0003f53:	83 ec 08             	sub    $0x8,%esp
c0003f56:	50                   	push   %eax
c0003f57:	68 8c 9b 00 c0       	push   $0xc0009b8c
c0003f5c:	e8 b6 05 00 00       	call   c0004517 <elem_find>
c0003f61:	83 c4 10             	add    $0x10,%esp
c0003f64:	85 c0                	test   %eax,%eax
c0003f66:	74 19                	je     c0003f81 <thread_start+0x72>
/work/x86_os_my/thread/thread.c:117 (discriminator 1)
c0003f68:	68 70 6e 00 c0       	push   $0xc0006e70
c0003f6d:	68 f4 70 00 c0       	push   $0xc00070f4
c0003f72:	6a 75                	push   $0x75
c0003f74:	68 a5 6e 00 c0       	push   $0xc0006ea5
c0003f79:	e8 04 e6 ff ff       	call   c0002582 <panic_spin>
c0003f7e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:118
	list_append(&thread_ready_list, &thread->general_tag);			// 加入就绪线程队列
c0003f81:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003f84:	83 c0 24             	add    $0x24,%eax
c0003f87:	83 ec 08             	sub    $0x8,%esp
c0003f8a:	50                   	push   %eax
c0003f8b:	68 8c 9b 00 c0       	push   $0xc0009b8c
c0003f90:	e8 08 05 00 00       	call   c000449d <list_append>
c0003f95:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:120

	ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
c0003f98:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003f9b:	83 c0 2c             	add    $0x2c,%eax
c0003f9e:	83 ec 08             	sub    $0x8,%esp
c0003fa1:	50                   	push   %eax
c0003fa2:	68 9c 9b 00 c0       	push   $0xc0009b9c
c0003fa7:	e8 6b 05 00 00       	call   c0004517 <elem_find>
c0003fac:	83 c4 10             	add    $0x10,%esp
c0003faf:	85 c0                	test   %eax,%eax
c0003fb1:	74 19                	je     c0003fcc <thread_start+0xbd>
/work/x86_os_my/thread/thread.c:120 (discriminator 1)
c0003fb3:	68 b8 6e 00 c0       	push   $0xc0006eb8
c0003fb8:	68 f4 70 00 c0       	push   $0xc00070f4
c0003fbd:	6a 78                	push   $0x78
c0003fbf:	68 a5 6e 00 c0       	push   $0xc0006ea5
c0003fc4:	e8 b9 e5 ff ff       	call   c0002582 <panic_spin>
c0003fc9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:121
	list_append(&thread_all_list, &thread->all_list_tag);			// 加入全部线程队列
c0003fcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003fcf:	83 c0 2c             	add    $0x2c,%eax
c0003fd2:	83 ec 08             	sub    $0x8,%esp
c0003fd5:	50                   	push   %eax
c0003fd6:	68 9c 9b 00 c0       	push   $0xc0009b9c
c0003fdb:	e8 bd 04 00 00       	call   c000449d <list_append>
c0003fe0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:137
	 * 在执行 ret 后，esp 指向的数值被弹岀到 eip。
	 * 处理器会去执行 kernel_thread 函数。
	 * 在执行 kernel_thread 时，处理器以为栈顶是返回地址，其实只是一个假的占位置的变量 unused_retaddr！
	 * 接着会调用函数 function(func_arg) */
	//asm volatile ("movl %0, %%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret" : : "g" (thread->self_kstack) : "memory");
	return thread;
c0003fe3:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/thread/thread.c:138
}
c0003fe6:	c9                   	leave  
c0003fe7:	c3                   	ret    

c0003fe8 <make_main_thread>:
make_main_thread():
/work/x86_os_my/thread/thread.c:142


/* 将kernel中的main函数完善为主线程 */
static void make_main_thread(void) {
c0003fe8:	55                   	push   %ebp
c0003fe9:	89 e5                	mov    %esp,%ebp
c0003feb:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:147
	/* 因为main线程早已运行,咱们在loader.S中进入内核时的mov esp, 0xc009f000设置了栈顶，也预留了pcb, 地址为0xc009e000
	 * 主线程不需要再为PCB申请页，只需要通过 init_thread 填充PCB成员：名称和优先级等。
	 * 也不需要再通过 thread_create 构造它的线程栈。
	 */
	g_main_thread = running_thread();	//用栈指针的高20位，当做当前线程的PCB
c0003fee:	e8 8e fd ff ff       	call   c0003d81 <running_thread>
c0003ff3:	a3 b0 9b 00 c0       	mov    %eax,0xc0009bb0
/work/x86_os_my/thread/thread.c:148
	init_thread(g_main_thread, "main", 31);
c0003ff8:	a1 b0 9b 00 c0       	mov    0xc0009bb0,%eax
c0003ffd:	83 ec 04             	sub    $0x4,%esp
c0004000:	6a 1f                	push   $0x1f
c0004002:	68 ec 6e 00 c0       	push   $0xc0006eec
c0004007:	50                   	push   %eax
c0004008:	e8 5b fe ff ff       	call   c0003e68 <init_thread>
c000400d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:152

	/* main函数是当前线程,当前线程不在thread_ready_list中,
	 * 所以只将其加在thread_all_list中. */
	ASSERT(!elem_find(&thread_all_list, &g_main_thread->all_list_tag));
c0004010:	a1 b0 9b 00 c0       	mov    0xc0009bb0,%eax
c0004015:	83 c0 2c             	add    $0x2c,%eax
c0004018:	83 ec 08             	sub    $0x8,%esp
c000401b:	50                   	push   %eax
c000401c:	68 9c 9b 00 c0       	push   $0xc0009b9c
c0004021:	e8 f1 04 00 00       	call   c0004517 <elem_find>
c0004026:	83 c4 10             	add    $0x10,%esp
c0004029:	85 c0                	test   %eax,%eax
c000402b:	74 1c                	je     c0004049 <make_main_thread+0x61>
/work/x86_os_my/thread/thread.c:152 (discriminator 1)
c000402d:	68 f4 6e 00 c0       	push   $0xc0006ef4
c0004032:	68 04 71 00 c0       	push   $0xc0007104
c0004037:	68 98 00 00 00       	push   $0x98
c000403c:	68 a5 6e 00 c0       	push   $0xc0006ea5
c0004041:	e8 3c e5 ff ff       	call   c0002582 <panic_spin>
c0004046:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:153
	list_append(&thread_all_list, &g_main_thread->all_list_tag);
c0004049:	a1 b0 9b 00 c0       	mov    0xc0009bb0,%eax
c000404e:	83 c0 2c             	add    $0x2c,%eax
c0004051:	83 ec 08             	sub    $0x8,%esp
c0004054:	50                   	push   %eax
c0004055:	68 9c 9b 00 c0       	push   $0xc0009b9c
c000405a:	e8 3e 04 00 00       	call   c000449d <list_append>
c000405f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:154
}
c0004062:	90                   	nop
c0004063:	c9                   	leave  
c0004064:	c3                   	ret    

c0004065 <schedule>:
schedule():
/work/x86_os_my/thread/thread.c:164
（2）调度器 schedule。
（3）任务切换函数 switch_to。
*/
/* 实现任务调度 */
void schedule()
{
c0004065:	55                   	push   %ebp
c0004066:	89 e5                	mov    %esp,%ebp
c0004068:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:165
	ASSERT(intr_get_status() == INTR_OFF);
c000406b:	e8 bf db ff ff       	call   c0001c2f <intr_get_status>
c0004070:	85 c0                	test   %eax,%eax
c0004072:	74 1c                	je     c0004090 <schedule+0x2b>
/work/x86_os_my/thread/thread.c:165 (discriminator 1)
c0004074:	68 2f 6f 00 c0       	push   $0xc0006f2f
c0004079:	68 18 71 00 c0       	push   $0xc0007118
c000407e:	68 a5 00 00 00       	push   $0xa5
c0004083:	68 a5 6e 00 c0       	push   $0xc0006ea5
c0004088:	e8 f5 e4 ff ff       	call   c0002582 <panic_spin>
c000408d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:168

	/* 换下 */
	struct task_struct* cur = running_thread(); 
c0004090:	e8 ec fc ff ff       	call   c0003d81 <running_thread>
c0004095:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:169
	if (cur->status == TASK_RUNNING) { // 若此线程只是cpu时间片到了,将其加入到就绪队列尾
c0004098:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000409b:	8b 40 08             	mov    0x8(%eax),%eax
c000409e:	85 c0                	test   %eax,%eax
c00040a0:	75 65                	jne    c0004107 <schedule+0xa2>
/work/x86_os_my/thread/thread.c:170
		ASSERT(!elem_find(&thread_ready_list, &cur->general_tag));
c00040a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00040a5:	83 c0 24             	add    $0x24,%eax
c00040a8:	83 ec 08             	sub    $0x8,%esp
c00040ab:	50                   	push   %eax
c00040ac:	68 8c 9b 00 c0       	push   $0xc0009b8c
c00040b1:	e8 61 04 00 00       	call   c0004517 <elem_find>
c00040b6:	83 c4 10             	add    $0x10,%esp
c00040b9:	85 c0                	test   %eax,%eax
c00040bb:	74 1c                	je     c00040d9 <schedule+0x74>
/work/x86_os_my/thread/thread.c:170 (discriminator 1)
c00040bd:	68 50 6f 00 c0       	push   $0xc0006f50
c00040c2:	68 18 71 00 c0       	push   $0xc0007118
c00040c7:	68 aa 00 00 00       	push   $0xaa
c00040cc:	68 a5 6e 00 c0       	push   $0xc0006ea5
c00040d1:	e8 ac e4 ff ff       	call   c0002582 <panic_spin>
c00040d6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:171
		list_append(&thread_ready_list, &cur->general_tag);
c00040d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00040dc:	83 c0 24             	add    $0x24,%eax
c00040df:	83 ec 08             	sub    $0x8,%esp
c00040e2:	50                   	push   %eax
c00040e3:	68 8c 9b 00 c0       	push   $0xc0009b8c
c00040e8:	e8 b0 03 00 00       	call   c000449d <list_append>
c00040ed:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:172
		cur->ticks = cur->priority;     // 重新将当前线程的ticks再重置为其priority;
c00040f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00040f3:	0f b6 50 1c          	movzbl 0x1c(%eax),%edx
c00040f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00040fa:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/thread/thread.c:173
		cur->status = TASK_READY;
c00040fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004100:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:180
		/* 若此线程需要某事件发生后才能继续上cpu运行,
		不需要将其加入队列,因为当前线程不在就绪队列中。*/
	}

	/* 如果就绪队列中没有可运行的任务,就唤醒idle */
	if (list_empty(&thread_ready_list)) {
c0004107:	83 ec 0c             	sub    $0xc,%esp
c000410a:	68 8c 9b 00 c0       	push   $0xc0009b8c
c000410f:	e8 d0 04 00 00       	call   c00045e4 <list_empty>
c0004114:	83 c4 10             	add    $0x10,%esp
c0004117:	85 c0                	test   %eax,%eax
c0004119:	74 11                	je     c000412c <schedule+0xc7>
/work/x86_os_my/thread/thread.c:181
		thread_unblock(idle_thread);
c000411b:	a1 ac 9b 00 c0       	mov    0xc0009bac,%eax
c0004120:	83 ec 0c             	sub    $0xc,%esp
c0004123:	50                   	push   %eax
c0004124:	e8 ec 00 00 00       	call   c0004215 <thread_unblock>
c0004129:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:185
	}
	
	/* 换上 */
	ASSERT(!list_empty(&thread_ready_list));
c000412c:	83 ec 0c             	sub    $0xc,%esp
c000412f:	68 8c 9b 00 c0       	push   $0xc0009b8c
c0004134:	e8 ab 04 00 00       	call   c00045e4 <list_empty>
c0004139:	83 c4 10             	add    $0x10,%esp
c000413c:	85 c0                	test   %eax,%eax
c000413e:	74 1c                	je     c000415c <schedule+0xf7>
/work/x86_os_my/thread/thread.c:185 (discriminator 1)
c0004140:	68 84 6f 00 c0       	push   $0xc0006f84
c0004145:	68 18 71 00 c0       	push   $0xc0007118
c000414a:	68 b9 00 00 00       	push   $0xb9
c000414f:	68 a5 6e 00 c0       	push   $0xc0006ea5
c0004154:	e8 29 e4 ff ff       	call   c0002582 <panic_spin>
c0004159:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:186
	g_thread_tag = NULL;	  // g_thread_tag清空
c000415c:	c7 05 68 95 00 c0 00 	movl   $0x0,0xc0009568
c0004163:	00 00 00 
/work/x86_os_my/thread/thread.c:188
	/* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */
	g_thread_tag = list_pop(&thread_ready_list);   
c0004166:	83 ec 0c             	sub    $0xc,%esp
c0004169:	68 8c 9b 00 c0       	push   $0xc0009b8c
c000416e:	e8 82 03 00 00       	call   c00044f5 <list_pop>
c0004173:	83 c4 10             	add    $0x10,%esp
c0004176:	a3 68 95 00 c0       	mov    %eax,0xc0009568
/work/x86_os_my/thread/thread.c:189
	struct task_struct* next = elem2entry(struct task_struct, general_tag, g_thread_tag);
c000417b:	a1 68 95 00 c0       	mov    0xc0009568,%eax
c0004180:	83 e8 24             	sub    $0x24,%eax
c0004183:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:190
	next->status = TASK_RUNNING;
c0004186:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0004189:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/thread/thread.c:194
	
	/* 1.激活线程或进程的页表,【更新CR3寄存器】
	 * 2.用户进程，更新tss中的esp0为进程的特权级0的栈 */
	process_activate(next);
c0004190:	83 ec 0c             	sub    $0xc,%esp
c0004193:	ff 75 f0             	pushl  -0x10(%ebp)
c0004196:	e8 f7 10 00 00       	call   c0005292 <process_activate>
c000419b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:196

	switch_to(cur, next);
c000419e:	83 ec 08             	sub    $0x8,%esp
c00041a1:	ff 75 f0             	pushl  -0x10(%ebp)
c00041a4:	ff 75 f4             	pushl  -0xc(%ebp)
c00041a7:	e8 54 04 00 00       	call   c0004600 <switch_to>
c00041ac:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:197
}
c00041af:	90                   	nop
c00041b0:	c9                   	leave  
c00041b1:	c3                   	ret    

c00041b2 <thread_block>:
thread_block():
/work/x86_os_my/thread/thread.c:200

/* 当前线程将自己阻塞,标志其状态为stat. */
void thread_block(enum task_status stat) {
c00041b2:	55                   	push   %ebp
c00041b3:	89 e5                	mov    %esp,%ebp
c00041b5:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:202
	/* stat取值为TASK_BLOCKED,TASK_WAITING,TASK_HANGING,也就是只有这三种状态才不会被调度*/
	ASSERT(((stat == TASK_BLOCKED) || (stat == TASK_WAITING) || (stat == TASK_HANGING)));
c00041b8:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c00041bc:	74 28                	je     c00041e6 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:202 (discriminator 1)
c00041be:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c00041c2:	74 22                	je     c00041e6 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:202 (discriminator 2)
c00041c4:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
c00041c8:	74 1c                	je     c00041e6 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:202 (discriminator 3)
c00041ca:	68 a4 6f 00 c0       	push   $0xc0006fa4
c00041cf:	68 24 71 00 c0       	push   $0xc0007124
c00041d4:	68 ca 00 00 00       	push   $0xca
c00041d9:	68 a5 6e 00 c0       	push   $0xc0006ea5
c00041de:	e8 9f e3 ff ff       	call   c0002582 <panic_spin>
c00041e3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:203
	enum intr_status old_status = intr_disable();
c00041e6:	e8 fd d9 ff ff       	call   c0001be8 <intr_disable>
c00041eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:205
	
	struct task_struct* cur_thread = running_thread();
c00041ee:	e8 8e fb ff ff       	call   c0003d81 <running_thread>
c00041f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:206
	cur_thread->status = stat;
c00041f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00041f9:	8b 55 08             	mov    0x8(%ebp),%edx
c00041fc:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/thread/thread.c:207
	schedule();
c00041ff:	e8 61 fe ff ff       	call   c0004065 <schedule>
/work/x86_os_my/thread/thread.c:210
	
	/* 待当前线程被解除阻塞后才继续运行下面的intr_set_status */
	intr_set_status(old_status);
c0004204:	83 ec 0c             	sub    $0xc,%esp
c0004207:	ff 75 f4             	pushl  -0xc(%ebp)
c000420a:	e8 02 da ff ff       	call   c0001c11 <intr_set_status>
c000420f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:211
}
c0004212:	90                   	nop
c0004213:	c9                   	leave  
c0004214:	c3                   	ret    

c0004215 <thread_unblock>:
thread_unblock():
/work/x86_os_my/thread/thread.c:214

/* 将线程pthread解除阻塞 */
void thread_unblock(struct task_struct* pthread) {
c0004215:	55                   	push   %ebp
c0004216:	89 e5                	mov    %esp,%ebp
c0004218:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:215
	enum intr_status old_status = intr_disable();
c000421b:	e8 c8 d9 ff ff       	call   c0001be8 <intr_disable>
c0004220:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:216
	ASSERT(((pthread->status == TASK_BLOCKED) || (pthread->status == TASK_WAITING) || (pthread->status == TASK_HANGING)));
c0004223:	8b 45 08             	mov    0x8(%ebp),%eax
c0004226:	8b 40 08             	mov    0x8(%eax),%eax
c0004229:	83 f8 02             	cmp    $0x2,%eax
c000422c:	74 32                	je     c0004260 <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:216 (discriminator 1)
c000422e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004231:	8b 40 08             	mov    0x8(%eax),%eax
c0004234:	83 f8 03             	cmp    $0x3,%eax
c0004237:	74 27                	je     c0004260 <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:216 (discriminator 2)
c0004239:	8b 45 08             	mov    0x8(%ebp),%eax
c000423c:	8b 40 08             	mov    0x8(%eax),%eax
c000423f:	83 f8 04             	cmp    $0x4,%eax
c0004242:	74 1c                	je     c0004260 <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:216 (discriminator 3)
c0004244:	68 f4 6f 00 c0       	push   $0xc0006ff4
c0004249:	68 34 71 00 c0       	push   $0xc0007134
c000424e:	68 d8 00 00 00       	push   $0xd8
c0004253:	68 a5 6e 00 c0       	push   $0xc0006ea5
c0004258:	e8 25 e3 ff ff       	call   c0002582 <panic_spin>
c000425d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:218
	
	if (pthread->status != TASK_READY) {
c0004260:	8b 45 08             	mov    0x8(%ebp),%eax
c0004263:	8b 40 08             	mov    0x8(%eax),%eax
c0004266:	83 f8 01             	cmp    $0x1,%eax
c0004269:	0f 84 8f 00 00 00    	je     c00042fe <thread_unblock+0xe9>
/work/x86_os_my/thread/thread.c:219
		ASSERT(!elem_find(&thread_ready_list, &pthread->general_tag));
c000426f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004272:	83 c0 24             	add    $0x24,%eax
c0004275:	83 ec 08             	sub    $0x8,%esp
c0004278:	50                   	push   %eax
c0004279:	68 8c 9b 00 c0       	push   $0xc0009b8c
c000427e:	e8 94 02 00 00       	call   c0004517 <elem_find>
c0004283:	83 c4 10             	add    $0x10,%esp
c0004286:	85 c0                	test   %eax,%eax
c0004288:	74 1c                	je     c00042a6 <thread_unblock+0x91>
/work/x86_os_my/thread/thread.c:219 (discriminator 1)
c000428a:	68 64 70 00 c0       	push   $0xc0007064
c000428f:	68 34 71 00 c0       	push   $0xc0007134
c0004294:	68 db 00 00 00       	push   $0xdb
c0004299:	68 a5 6e 00 c0       	push   $0xc0006ea5
c000429e:	e8 df e2 ff ff       	call   c0002582 <panic_spin>
c00042a3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:220
		if (elem_find(&thread_ready_list, &pthread->general_tag)) {
c00042a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00042a9:	83 c0 24             	add    $0x24,%eax
c00042ac:	83 ec 08             	sub    $0x8,%esp
c00042af:	50                   	push   %eax
c00042b0:	68 8c 9b 00 c0       	push   $0xc0009b8c
c00042b5:	e8 5d 02 00 00       	call   c0004517 <elem_find>
c00042ba:	83 c4 10             	add    $0x10,%esp
c00042bd:	85 c0                	test   %eax,%eax
c00042bf:	74 1c                	je     c00042dd <thread_unblock+0xc8>
/work/x86_os_my/thread/thread.c:221
			PANIC("thread_unblock: blocked thread in ready_list\n");
c00042c1:	68 9c 70 00 c0       	push   $0xc000709c
c00042c6:	68 34 71 00 c0       	push   $0xc0007134
c00042cb:	68 dd 00 00 00       	push   $0xdd
c00042d0:	68 a5 6e 00 c0       	push   $0xc0006ea5
c00042d5:	e8 a8 e2 ff ff       	call   c0002582 <panic_spin>
c00042da:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:223
		}
		list_push(&thread_ready_list, &pthread->general_tag);	// 放到队列的最前面,使其尽快得到调度
c00042dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00042e0:	83 c0 24             	add    $0x24,%eax
c00042e3:	83 ec 08             	sub    $0x8,%esp
c00042e6:	50                   	push   %eax
c00042e7:	68 8c 9b 00 c0       	push   $0xc0009b8c
c00042ec:	e8 8e 01 00 00       	call   c000447f <list_push>
c00042f1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:224
		pthread->status = TASK_READY;
c00042f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00042f7:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:227
	}
	
	intr_set_status(old_status);
c00042fe:	83 ec 0c             	sub    $0xc,%esp
c0004301:	ff 75 f4             	pushl  -0xc(%ebp)
c0004304:	e8 08 d9 ff ff       	call   c0001c11 <intr_set_status>
c0004309:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:228
}
c000430c:	90                   	nop
c000430d:	c9                   	leave  
c000430e:	c3                   	ret    

c000430f <thread_yield>:
thread_yield():
/work/x86_os_my/thread/thread.c:231

/* 主动让出cpu，换其它线程运行，但状态仍是ready */
void thread_yield(void) {
c000430f:	55                   	push   %ebp
c0004310:	89 e5                	mov    %esp,%ebp
c0004312:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:232
	struct task_struct* cur = running_thread();
c0004315:	e8 67 fa ff ff       	call   c0003d81 <running_thread>
c000431a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:233
	enum intr_status old_status = intr_disable();
c000431d:	e8 c6 d8 ff ff       	call   c0001be8 <intr_disable>
c0004322:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:234
	ASSERT(!elem_find(&thread_ready_list, &cur->general_tag));
c0004325:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004328:	83 c0 24             	add    $0x24,%eax
c000432b:	83 ec 08             	sub    $0x8,%esp
c000432e:	50                   	push   %eax
c000432f:	68 8c 9b 00 c0       	push   $0xc0009b8c
c0004334:	e8 de 01 00 00       	call   c0004517 <elem_find>
c0004339:	83 c4 10             	add    $0x10,%esp
c000433c:	85 c0                	test   %eax,%eax
c000433e:	74 1c                	je     c000435c <thread_yield+0x4d>
/work/x86_os_my/thread/thread.c:234 (discriminator 1)
c0004340:	68 50 6f 00 c0       	push   $0xc0006f50
c0004345:	68 44 71 00 c0       	push   $0xc0007144
c000434a:	68 ea 00 00 00       	push   $0xea
c000434f:	68 a5 6e 00 c0       	push   $0xc0006ea5
c0004354:	e8 29 e2 ff ff       	call   c0002582 <panic_spin>
c0004359:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:235
	list_append(&thread_ready_list, &cur->general_tag);
c000435c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000435f:	83 c0 24             	add    $0x24,%eax
c0004362:	83 ec 08             	sub    $0x8,%esp
c0004365:	50                   	push   %eax
c0004366:	68 8c 9b 00 c0       	push   $0xc0009b8c
c000436b:	e8 2d 01 00 00       	call   c000449d <list_append>
c0004370:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:236
	cur->status = TASK_READY;
c0004373:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004376:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:237
	schedule();
c000437d:	e8 e3 fc ff ff       	call   c0004065 <schedule>
/work/x86_os_my/thread/thread.c:238
	intr_set_status(old_status);
c0004382:	83 ec 0c             	sub    $0xc,%esp
c0004385:	ff 75 f0             	pushl  -0x10(%ebp)
c0004388:	e8 84 d8 ff ff       	call   c0001c11 <intr_set_status>
c000438d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:239
}
c0004390:	90                   	nop
c0004391:	c9                   	leave  
c0004392:	c3                   	ret    

c0004393 <thread_init>:
thread_init():
/work/x86_os_my/thread/thread.c:242

/* 初始化线程环境 */
void thread_init(void) {
c0004393:	55                   	push   %ebp
c0004394:	89 e5                	mov    %esp,%ebp
c0004396:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:243
	put_str("thread_init start\n");
c0004399:	83 ec 0c             	sub    $0xc,%esp
c000439c:	68 ca 70 00 c0       	push   $0xc00070ca
c00043a1:	e8 6a e0 ff ff       	call   c0002410 <put_str>
c00043a6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:244
	list_init(&thread_ready_list);
c00043a9:	83 ec 0c             	sub    $0xc,%esp
c00043ac:	68 8c 9b 00 c0       	push   $0xc0009b8c
c00043b1:	e8 56 00 00 00       	call   c000440c <list_init>
c00043b6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:245
	list_init(&thread_all_list);
c00043b9:	83 ec 0c             	sub    $0xc,%esp
c00043bc:	68 9c 9b 00 c0       	push   $0xc0009b9c
c00043c1:	e8 46 00 00 00       	call   c000440c <list_init>
c00043c6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:246
	lock_init(&pid_lock);
c00043c9:	83 ec 0c             	sub    $0xc,%esp
c00043cc:	68 b4 9b 00 c0       	push   $0xc0009bb4
c00043d1:	e8 1f 03 00 00       	call   c00046f5 <lock_init>
c00043d6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:248
	/* 将当前main函数创建为线程 */
	make_main_thread();
c00043d9:	e8 0a fc ff ff       	call   c0003fe8 <make_main_thread>
/work/x86_os_my/thread/thread.c:250
	/* 创建idle线程 */
	idle_thread = thread_start("idle", 10, idle, NULL);
c00043de:	6a 00                	push   $0x0
c00043e0:	68 6a 3d 00 c0       	push   $0xc0003d6a
c00043e5:	6a 0a                	push   $0xa
c00043e7:	68 dd 70 00 c0       	push   $0xc00070dd
c00043ec:	e8 1e fb ff ff       	call   c0003f0f <thread_start>
c00043f1:	83 c4 10             	add    $0x10,%esp
c00043f4:	a3 ac 9b 00 c0       	mov    %eax,0xc0009bac
/work/x86_os_my/thread/thread.c:251
	put_str("thread_init done\n");
c00043f9:	83 ec 0c             	sub    $0xc,%esp
c00043fc:	68 e2 70 00 c0       	push   $0xc00070e2
c0004401:	e8 0a e0 ff ff       	call   c0002410 <put_str>
c0004406:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:252
}
c0004409:	90                   	nop
c000440a:	c9                   	leave  
c000440b:	c3                   	ret    

c000440c <list_init>:
list_init():
/work/x86_os_my/lib/kernel/list.c:6
#include "list.h"
#include "interrupt.h"
/* 注意关中断的操作：临界区 */

/* 初始化双向链表list */
void list_init (struct list* list) {
c000440c:	55                   	push   %ebp
c000440d:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/lib/kernel/list.c:7
	list->head.prev = NULL;
c000440f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004412:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/lib/kernel/list.c:8
	list->head.next = &list->tail;
c0004418:	8b 45 08             	mov    0x8(%ebp),%eax
c000441b:	8d 50 08             	lea    0x8(%eax),%edx
c000441e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004421:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:9
	list->tail.prev = &list->head;
c0004424:	8b 55 08             	mov    0x8(%ebp),%edx
c0004427:	8b 45 08             	mov    0x8(%ebp),%eax
c000442a:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/lib/kernel/list.c:10
	list->tail.next = NULL;
c000442d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004430:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/lib/kernel/list.c:11
}
c0004437:	90                   	nop
c0004438:	5d                   	pop    %ebp
c0004439:	c3                   	ret    

c000443a <list_insert_before>:
list_insert_before():
/work/x86_os_my/lib/kernel/list.c:14

/* 把链表元素elem插入在元素before之前 */
void list_insert_before(struct list_elem* before, struct list_elem* elem) { 
c000443a:	55                   	push   %ebp
c000443b:	89 e5                	mov    %esp,%ebp
c000443d:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:15
	enum intr_status old_status = intr_disable();
c0004440:	e8 a3 d7 ff ff       	call   c0001be8 <intr_disable>
c0004445:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:18

	/* 将before前驱元素的后继元素更新为elem, 暂时使before脱离链表*/ 
	before->prev->next = elem; 
c0004448:	8b 45 08             	mov    0x8(%ebp),%eax
c000444b:	8b 00                	mov    (%eax),%eax
c000444d:	8b 55 0c             	mov    0xc(%ebp),%edx
c0004450:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:22

	/* 更新elem自己的前驱结点为before的前驱,
	* 更新elem自己的后继结点为before, 于是before又回到链表 */
	elem->prev = before->prev;
c0004453:	8b 45 08             	mov    0x8(%ebp),%eax
c0004456:	8b 10                	mov    (%eax),%edx
c0004458:	8b 45 0c             	mov    0xc(%ebp),%eax
c000445b:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:23
	elem->next = before;
c000445d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004460:	8b 55 08             	mov    0x8(%ebp),%edx
c0004463:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:26

	/* 更新before的前驱结点为elem */
	before->prev = elem;
c0004466:	8b 45 08             	mov    0x8(%ebp),%eax
c0004469:	8b 55 0c             	mov    0xc(%ebp),%edx
c000446c:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:28

	intr_set_status(old_status);
c000446e:	83 ec 0c             	sub    $0xc,%esp
c0004471:	ff 75 f4             	pushl  -0xc(%ebp)
c0004474:	e8 98 d7 ff ff       	call   c0001c11 <intr_set_status>
c0004479:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:29
}
c000447c:	90                   	nop
c000447d:	c9                   	leave  
c000447e:	c3                   	ret    

c000447f <list_push>:
list_push():
/work/x86_os_my/lib/kernel/list.c:32

/* 添加元素到列表队首,类似栈push操作 */
void list_push(struct list* plist, struct list_elem* elem) {
c000447f:	55                   	push   %ebp
c0004480:	89 e5                	mov    %esp,%ebp
c0004482:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/list.c:33
	list_insert_before(plist->head.next, elem); // 在队头插入elem
c0004485:	8b 45 08             	mov    0x8(%ebp),%eax
c0004488:	8b 40 04             	mov    0x4(%eax),%eax
c000448b:	83 ec 08             	sub    $0x8,%esp
c000448e:	ff 75 0c             	pushl  0xc(%ebp)
c0004491:	50                   	push   %eax
c0004492:	e8 a3 ff ff ff       	call   c000443a <list_insert_before>
c0004497:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:34
}
c000449a:	90                   	nop
c000449b:	c9                   	leave  
c000449c:	c3                   	ret    

c000449d <list_append>:
list_append():
/work/x86_os_my/lib/kernel/list.c:37

/* 追加元素到链表队尾,类似队列的先进先出操作 */
void list_append(struct list* plist, struct list_elem* elem) {
c000449d:	55                   	push   %ebp
c000449e:	89 e5                	mov    %esp,%ebp
c00044a0:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/list.c:38
	list_insert_before(&plist->tail, elem);     // 在队尾的前面插入
c00044a3:	8b 45 08             	mov    0x8(%ebp),%eax
c00044a6:	83 c0 08             	add    $0x8,%eax
c00044a9:	83 ec 08             	sub    $0x8,%esp
c00044ac:	ff 75 0c             	pushl  0xc(%ebp)
c00044af:	50                   	push   %eax
c00044b0:	e8 85 ff ff ff       	call   c000443a <list_insert_before>
c00044b5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:39
}
c00044b8:	90                   	nop
c00044b9:	c9                   	leave  
c00044ba:	c3                   	ret    

c00044bb <list_remove>:
list_remove():
/work/x86_os_my/lib/kernel/list.c:42

/* 使元素pelem脱离链表 */
void list_remove(struct list_elem* pelem) {
c00044bb:	55                   	push   %ebp
c00044bc:	89 e5                	mov    %esp,%ebp
c00044be:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:43
	enum intr_status old_status = intr_disable();
c00044c1:	e8 22 d7 ff ff       	call   c0001be8 <intr_disable>
c00044c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:45

	pelem->prev->next = pelem->next;
c00044c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00044cc:	8b 00                	mov    (%eax),%eax
c00044ce:	8b 55 08             	mov    0x8(%ebp),%edx
c00044d1:	8b 52 04             	mov    0x4(%edx),%edx
c00044d4:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:46
	pelem->next->prev = pelem->prev;
c00044d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00044da:	8b 40 04             	mov    0x4(%eax),%eax
c00044dd:	8b 55 08             	mov    0x8(%ebp),%edx
c00044e0:	8b 12                	mov    (%edx),%edx
c00044e2:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:48

	intr_set_status(old_status);
c00044e4:	83 ec 0c             	sub    $0xc,%esp
c00044e7:	ff 75 f4             	pushl  -0xc(%ebp)
c00044ea:	e8 22 d7 ff ff       	call   c0001c11 <intr_set_status>
c00044ef:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:49
}
c00044f2:	90                   	nop
c00044f3:	c9                   	leave  
c00044f4:	c3                   	ret    

c00044f5 <list_pop>:
list_pop():
/work/x86_os_my/lib/kernel/list.c:52

/* 将链表第一个元素弹出并返回,类似栈的pop操作 */
struct list_elem* list_pop(struct list* plist) {
c00044f5:	55                   	push   %ebp
c00044f6:	89 e5                	mov    %esp,%ebp
c00044f8:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:53
	struct list_elem* elem = plist->head.next;
c00044fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00044fe:	8b 40 04             	mov    0x4(%eax),%eax
c0004501:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:54
	list_remove(elem);
c0004504:	83 ec 0c             	sub    $0xc,%esp
c0004507:	ff 75 f4             	pushl  -0xc(%ebp)
c000450a:	e8 ac ff ff ff       	call   c00044bb <list_remove>
c000450f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:55
	return elem;
c0004512:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/kernel/list.c:56
} 
c0004515:	c9                   	leave  
c0004516:	c3                   	ret    

c0004517 <elem_find>:
elem_find():
/work/x86_os_my/lib/kernel/list.c:59

/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */
bool elem_find(struct list* plist, struct list_elem* obj_elem) {
c0004517:	55                   	push   %ebp
c0004518:	89 e5                	mov    %esp,%ebp
c000451a:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:60
	struct list_elem* elem = plist->head.next;
c000451d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004520:	8b 40 04             	mov    0x4(%eax),%eax
c0004523:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:61
	while (elem != &plist->tail) {
c0004526:	eb 18                	jmp    c0004540 <elem_find+0x29>
/work/x86_os_my/lib/kernel/list.c:62
	if (elem == obj_elem) {
c0004528:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000452b:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000452e:	75 07                	jne    c0004537 <elem_find+0x20>
/work/x86_os_my/lib/kernel/list.c:63
		return true;
c0004530:	b8 01 00 00 00       	mov    $0x1,%eax
c0004535:	eb 19                	jmp    c0004550 <elem_find+0x39>
/work/x86_os_my/lib/kernel/list.c:65
	}
		elem = elem->next;
c0004537:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000453a:	8b 40 04             	mov    0x4(%eax),%eax
c000453d:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:61
} 

/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */
bool elem_find(struct list* plist, struct list_elem* obj_elem) {
	struct list_elem* elem = plist->head.next;
	while (elem != &plist->tail) {
c0004540:	8b 45 08             	mov    0x8(%ebp),%eax
c0004543:	83 c0 08             	add    $0x8,%eax
c0004546:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c0004549:	75 dd                	jne    c0004528 <elem_find+0x11>
/work/x86_os_my/lib/kernel/list.c:67
	if (elem == obj_elem) {
		return true;
	}
		elem = elem->next;
	}
	return false;
c000454b:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/kernel/list.c:68
}
c0004550:	c9                   	leave  
c0004551:	c3                   	ret    

c0004552 <list_traversal>:
list_traversal():
/work/x86_os_my/lib/kernel/list.c:74

/* 把列表plist中的每个元素elem和arg传给回调函数func,
 * arg给func用来判断elem是否符合条件.
 * 本函数的功能是遍历列表内所有元素,逐个判断是否有符合条件的元素。
 * 找到符合条件的元素返回元素指针,否则返回NULL. */
struct list_elem* list_traversal(struct list* plist, function func, int arg) {
c0004552:	55                   	push   %ebp
c0004553:	89 e5                	mov    %esp,%ebp
c0004555:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:75
	struct list_elem* elem = plist->head.next;
c0004558:	8b 45 08             	mov    0x8(%ebp),%eax
c000455b:	8b 40 04             	mov    0x4(%eax),%eax
c000455e:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:77
	/* 如果队列为空,就必然没有符合条件的结点,故直接返回NULL */
	if (list_empty(plist)) { 
c0004561:	83 ec 0c             	sub    $0xc,%esp
c0004564:	ff 75 08             	pushl  0x8(%ebp)
c0004567:	e8 78 00 00 00       	call   c00045e4 <list_empty>
c000456c:	83 c4 10             	add    $0x10,%esp
c000456f:	85 c0                	test   %eax,%eax
c0004571:	74 2a                	je     c000459d <list_traversal+0x4b>
/work/x86_os_my/lib/kernel/list.c:78
		return NULL;
c0004573:	b8 00 00 00 00       	mov    $0x0,%eax
c0004578:	eb 33                	jmp    c00045ad <list_traversal+0x5b>
/work/x86_os_my/lib/kernel/list.c:82
	}

	while (elem != &plist->tail) {
	if (func(elem, arg)) {		  // func返回ture则认为该元素在回调函数中符合条件,命中,故停止继续遍历
c000457a:	83 ec 08             	sub    $0x8,%esp
c000457d:	ff 75 10             	pushl  0x10(%ebp)
c0004580:	ff 75 f4             	pushl  -0xc(%ebp)
c0004583:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004586:	ff d0                	call   *%eax
c0004588:	83 c4 10             	add    $0x10,%esp
c000458b:	85 c0                	test   %eax,%eax
c000458d:	74 05                	je     c0004594 <list_traversal+0x42>
/work/x86_os_my/lib/kernel/list.c:83
		return elem;
c000458f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004592:	eb 19                	jmp    c00045ad <list_traversal+0x5b>
/work/x86_os_my/lib/kernel/list.c:85
	}					  // 若回调函数func返回true,则继续遍历
		elem = elem->next;	       
c0004594:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004597:	8b 40 04             	mov    0x4(%eax),%eax
c000459a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:81
	/* 如果队列为空,就必然没有符合条件的结点,故直接返回NULL */
	if (list_empty(plist)) { 
		return NULL;
	}

	while (elem != &plist->tail) {
c000459d:	8b 45 08             	mov    0x8(%ebp),%eax
c00045a0:	83 c0 08             	add    $0x8,%eax
c00045a3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00045a6:	75 d2                	jne    c000457a <list_traversal+0x28>
/work/x86_os_my/lib/kernel/list.c:87
	if (func(elem, arg)) {		  // func返回ture则认为该元素在回调函数中符合条件,命中,故停止继续遍历
		return elem;
	}					  // 若回调函数func返回true,则继续遍历
		elem = elem->next;	       
	}
	return NULL;
c00045a8:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/kernel/list.c:88
}
c00045ad:	c9                   	leave  
c00045ae:	c3                   	ret    

c00045af <list_len>:
list_len():
/work/x86_os_my/lib/kernel/list.c:91

/* 返回链表长度 */
uint32_t list_len(struct list* plist) {
c00045af:	55                   	push   %ebp
c00045b0:	89 e5                	mov    %esp,%ebp
c00045b2:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:92
	struct list_elem* elem = plist->head.next;
c00045b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00045b8:	8b 40 04             	mov    0x4(%eax),%eax
c00045bb:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:93
	uint32_t length = 0;
c00045be:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
/work/x86_os_my/lib/kernel/list.c:94
	while (elem != &plist->tail) {
c00045c5:	eb 0d                	jmp    c00045d4 <list_len+0x25>
/work/x86_os_my/lib/kernel/list.c:95
		length++; 
c00045c7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
/work/x86_os_my/lib/kernel/list.c:96
		elem = elem->next;
c00045cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00045ce:	8b 40 04             	mov    0x4(%eax),%eax
c00045d1:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:94

/* 返回链表长度 */
uint32_t list_len(struct list* plist) {
	struct list_elem* elem = plist->head.next;
	uint32_t length = 0;
	while (elem != &plist->tail) {
c00045d4:	8b 45 08             	mov    0x8(%ebp),%eax
c00045d7:	83 c0 08             	add    $0x8,%eax
c00045da:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c00045dd:	75 e8                	jne    c00045c7 <list_len+0x18>
/work/x86_os_my/lib/kernel/list.c:98
		length++; 
		elem = elem->next;
	}
	return length;
c00045df:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/kernel/list.c:99
}
c00045e2:	c9                   	leave  
c00045e3:	c3                   	ret    

c00045e4 <list_empty>:
list_empty():
/work/x86_os_my/lib/kernel/list.c:102

/* 判断链表是否为空,空时返回true,否则返回false */
bool list_empty(struct list* plist) {		// 判断队列是否为空
c00045e4:	55                   	push   %ebp
c00045e5:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/lib/kernel/list.c:103
	return (plist->head.next == &plist->tail ? true : false);
c00045e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00045ea:	8b 40 04             	mov    0x4(%eax),%eax
c00045ed:	8b 55 08             	mov    0x8(%ebp),%edx
c00045f0:	83 c2 08             	add    $0x8,%edx
c00045f3:	39 d0                	cmp    %edx,%eax
c00045f5:	0f 94 c0             	sete   %al
c00045f8:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/lib/kernel/list.c:104
}
c00045fb:	5d                   	pop    %ebp
c00045fc:	c3                   	ret    
c00045fd:	66 90                	xchg   %ax,%ax
c00045ff:	90                   	nop

c0004600 <switch_to>:
switch_to():
c0004600:	56                   	push   %esi
c0004601:	57                   	push   %edi
c0004602:	53                   	push   %ebx
c0004603:	55                   	push   %ebp
c0004604:	8b 44 24 14          	mov    0x14(%esp),%eax
c0004608:	89 20                	mov    %esp,(%eax)
c000460a:	8b 44 24 18          	mov    0x18(%esp),%eax
c000460e:	8b 20                	mov    (%eax),%esp
c0004610:	5d                   	pop    %ebp
c0004611:	5b                   	pop    %ebx
c0004612:	5f                   	pop    %edi
c0004613:	5e                   	pop    %esi
c0004614:	c3                   	ret    

c0004615 <console_init>:
console_init():
/work/x86_os_my/device/console.c:9
#include "sync.h"
#include "thread.h"
static struct lock console_lock;	// 控制台锁

/* 初始化终端 */
void console_init() {
c0004615:	55                   	push   %ebp
c0004616:	89 e5                	mov    %esp,%ebp
c0004618:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:10
	lock_init(&console_lock);
c000461b:	83 ec 0c             	sub    $0xc,%esp
c000461e:	68 70 95 00 c0       	push   $0xc0009570
c0004623:	e8 cd 00 00 00       	call   c00046f5 <lock_init>
c0004628:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:11
}
c000462b:	90                   	nop
c000462c:	c9                   	leave  
c000462d:	c3                   	ret    

c000462e <console_acquire>:
console_acquire():
/work/x86_os_my/device/console.c:14

/* 获取终端 */
void console_acquire() {
c000462e:	55                   	push   %ebp
c000462f:	89 e5                	mov    %esp,%ebp
c0004631:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:15
	lock_acquire(&console_lock);
c0004634:	83 ec 0c             	sub    $0xc,%esp
c0004637:	68 70 95 00 c0       	push   $0xc0009570
c000463c:	e8 8e 02 00 00       	call   c00048cf <lock_acquire>
c0004641:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:16
}
c0004644:	90                   	nop
c0004645:	c9                   	leave  
c0004646:	c3                   	ret    

c0004647 <console_release>:
console_release():
/work/x86_os_my/device/console.c:19

/* 释放终端 */
void console_release() {
c0004647:	55                   	push   %ebp
c0004648:	89 e5                	mov    %esp,%ebp
c000464a:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:20
	lock_release(&console_lock);
c000464d:	83 ec 0c             	sub    $0xc,%esp
c0004650:	68 70 95 00 c0       	push   $0xc0009570
c0004655:	e8 ec 02 00 00       	call   c0004946 <lock_release>
c000465a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:21
}
c000465d:	90                   	nop
c000465e:	c9                   	leave  
c000465f:	c3                   	ret    

c0004660 <console_put_str>:
console_put_str():
/work/x86_os_my/device/console.c:24

/* 终端中输出字符串 */
void console_put_str(char* str) {
c0004660:	55                   	push   %ebp
c0004661:	89 e5                	mov    %esp,%ebp
c0004663:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:25
	console_acquire();
c0004666:	e8 c3 ff ff ff       	call   c000462e <console_acquire>
/work/x86_os_my/device/console.c:26
	put_str(str);
c000466b:	83 ec 0c             	sub    $0xc,%esp
c000466e:	ff 75 08             	pushl  0x8(%ebp)
c0004671:	e8 9a dd ff ff       	call   c0002410 <put_str>
c0004676:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:27
	console_release();
c0004679:	e8 c9 ff ff ff       	call   c0004647 <console_release>
/work/x86_os_my/device/console.c:28
}
c000467e:	90                   	nop
c000467f:	c9                   	leave  
c0004680:	c3                   	ret    

c0004681 <console_put_char>:
console_put_char():
/work/x86_os_my/device/console.c:31

/* 终端中输出字符 */
void console_put_char(uint8_t char_asci) {
c0004681:	55                   	push   %ebp
c0004682:	89 e5                	mov    %esp,%ebp
c0004684:	83 ec 18             	sub    $0x18,%esp
c0004687:	8b 45 08             	mov    0x8(%ebp),%eax
c000468a:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/console.c:32
	console_acquire();
c000468d:	e8 9c ff ff ff       	call   c000462e <console_acquire>
/work/x86_os_my/device/console.c:33
	put_char(char_asci);
c0004692:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0004696:	83 ec 0c             	sub    $0xc,%esp
c0004699:	50                   	push   %eax
c000469a:	e8 8f dd ff ff       	call   c000242e <put_char>
c000469f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:34
	console_release();
c00046a2:	e8 a0 ff ff ff       	call   c0004647 <console_release>
/work/x86_os_my/device/console.c:35
}
c00046a7:	90                   	nop
c00046a8:	c9                   	leave  
c00046a9:	c3                   	ret    

c00046aa <console_put_int>:
console_put_int():
/work/x86_os_my/device/console.c:38

/* 终端中输出16进制整数 */
void console_put_int(uint32_t num) {
c00046aa:	55                   	push   %ebp
c00046ab:	89 e5                	mov    %esp,%ebp
c00046ad:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:39
	console_acquire();
c00046b0:	e8 79 ff ff ff       	call   c000462e <console_acquire>
/work/x86_os_my/device/console.c:40
	put_int(num);
c00046b5:	83 ec 0c             	sub    $0xc,%esp
c00046b8:	ff 75 08             	pushl  0x8(%ebp)
c00046bb:	e8 3b de ff ff       	call   c00024fb <put_int>
c00046c0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:41
	console_release();
c00046c3:	e8 7f ff ff ff       	call   c0004647 <console_release>
/work/x86_os_my/device/console.c:42
}
c00046c8:	90                   	nop
c00046c9:	c9                   	leave  
c00046ca:	c3                   	ret    

c00046cb <sema_init>:
sema_init():
/work/x86_os_my/thread/sync.c:8
#include "global.h"
#include "debug.h"
#include "interrupt.h"

/* 初始化信号量 */
void sema_init(struct semaphore* psema, uint8_t value) {
c00046cb:	55                   	push   %ebp
c00046cc:	89 e5                	mov    %esp,%ebp
c00046ce:	83 ec 18             	sub    $0x18,%esp
c00046d1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00046d4:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:9
	psema->value = value;       // 为信号量赋初值
c00046d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00046da:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c00046de:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:10
	list_init(&psema->waiters); //初始化信号量的等待队列
c00046e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00046e3:	83 c0 04             	add    $0x4,%eax
c00046e6:	83 ec 0c             	sub    $0xc,%esp
c00046e9:	50                   	push   %eax
c00046ea:	e8 1d fd ff ff       	call   c000440c <list_init>
c00046ef:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:11
}
c00046f2:	90                   	nop
c00046f3:	c9                   	leave  
c00046f4:	c3                   	ret    

c00046f5 <lock_init>:
lock_init():
/work/x86_os_my/thread/sync.c:14

/* 初始化锁plock */
void lock_init(struct lock* plock) {
c00046f5:	55                   	push   %ebp
c00046f6:	89 e5                	mov    %esp,%ebp
c00046f8:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/sync.c:15
	plock->holder = NULL;
c00046fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00046fe:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:16
	plock->holder_repeat_nr = 0;
c0004704:	8b 45 08             	mov    0x8(%ebp),%eax
c0004707:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:17
	sema_init(&plock->semaphore, 1);  // 信号量初值为1
c000470e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004711:	83 c0 04             	add    $0x4,%eax
c0004714:	83 ec 08             	sub    $0x8,%esp
c0004717:	6a 01                	push   $0x1
c0004719:	50                   	push   %eax
c000471a:	e8 ac ff ff ff       	call   c00046cb <sema_init>
c000471f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:18
}
c0004722:	90                   	nop
c0004723:	c9                   	leave  
c0004724:	c3                   	ret    

c0004725 <sema_down>:
sema_down():
/work/x86_os_my/thread/sync.c:21

/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
c0004725:	55                   	push   %ebp
c0004726:	89 e5                	mov    %esp,%ebp
c0004728:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:23
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
c000472b:	e8 b8 d4 ff ff       	call   c0001be8 <intr_disable>
c0004730:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:25
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c0004733:	e9 98 00 00 00       	jmp    c00047d0 <sema_down+0xab>
/work/x86_os_my/thread/sync.c:26
		ASSERT(!elem_find(&psema->waiters, &running_thread()->general_tag));
c0004738:	e8 44 f6 ff ff       	call   c0003d81 <running_thread>
c000473d:	8d 50 24             	lea    0x24(%eax),%edx
c0004740:	8b 45 08             	mov    0x8(%ebp),%eax
c0004743:	83 c0 04             	add    $0x4,%eax
c0004746:	83 ec 08             	sub    $0x8,%esp
c0004749:	52                   	push   %edx
c000474a:	50                   	push   %eax
c000474b:	e8 c7 fd ff ff       	call   c0004517 <elem_find>
c0004750:	83 c4 10             	add    $0x10,%esp
c0004753:	85 c0                	test   %eax,%eax
c0004755:	74 19                	je     c0004770 <sema_down+0x4b>
/work/x86_os_my/thread/sync.c:26 (discriminator 1)
c0004757:	68 54 71 00 c0       	push   $0xc0007154
c000475c:	68 58 72 00 c0       	push   $0xc0007258
c0004761:	6a 1a                	push   $0x1a
c0004763:	68 90 71 00 c0       	push   $0xc0007190
c0004768:	e8 15 de ff ff       	call   c0002582 <panic_spin>
c000476d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:28
		/* 当前线程不应该已在信号量的waiters队列中 */
		if (elem_find(&psema->waiters, &running_thread()->general_tag)) {
c0004770:	e8 0c f6 ff ff       	call   c0003d81 <running_thread>
c0004775:	8d 50 24             	lea    0x24(%eax),%edx
c0004778:	8b 45 08             	mov    0x8(%ebp),%eax
c000477b:	83 c0 04             	add    $0x4,%eax
c000477e:	83 ec 08             	sub    $0x8,%esp
c0004781:	52                   	push   %edx
c0004782:	50                   	push   %eax
c0004783:	e8 8f fd ff ff       	call   c0004517 <elem_find>
c0004788:	83 c4 10             	add    $0x10,%esp
c000478b:	85 c0                	test   %eax,%eax
c000478d:	74 19                	je     c00047a8 <sema_down+0x83>
/work/x86_os_my/thread/sync.c:29
			PANIC("sema_down: thread blocked has been in waiters_list\n");
c000478f:	68 a0 71 00 c0       	push   $0xc00071a0
c0004794:	68 58 72 00 c0       	push   $0xc0007258
c0004799:	6a 1d                	push   $0x1d
c000479b:	68 90 71 00 c0       	push   $0xc0007190
c00047a0:	e8 dd dd ff ff       	call   c0002582 <panic_spin>
c00047a5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:32
		}
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
c00047a8:	e8 d4 f5 ff ff       	call   c0003d81 <running_thread>
c00047ad:	8d 50 24             	lea    0x24(%eax),%edx
c00047b0:	8b 45 08             	mov    0x8(%ebp),%eax
c00047b3:	83 c0 04             	add    $0x4,%eax
c00047b6:	83 ec 08             	sub    $0x8,%esp
c00047b9:	52                   	push   %edx
c00047ba:	50                   	push   %eax
c00047bb:	e8 dd fc ff ff       	call   c000449d <list_append>
c00047c0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:33
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
c00047c3:	83 ec 0c             	sub    $0xc,%esp
c00047c6:	6a 02                	push   $0x2
c00047c8:	e8 e5 f9 ff ff       	call   c00041b2 <thread_block>
c00047cd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:25
/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c00047d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00047d3:	0f b6 00             	movzbl (%eax),%eax
c00047d6:	84 c0                	test   %al,%al
c00047d8:	0f 84 5a ff ff ff    	je     c0004738 <sema_down+0x13>
/work/x86_os_my/thread/sync.c:36
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
	}
	/* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*/
	psema->value--;
c00047de:	8b 45 08             	mov    0x8(%ebp),%eax
c00047e1:	0f b6 00             	movzbl (%eax),%eax
c00047e4:	8d 50 ff             	lea    -0x1(%eax),%edx
c00047e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00047ea:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:37
	ASSERT(psema->value == 0);
c00047ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00047ef:	0f b6 00             	movzbl (%eax),%eax
c00047f2:	84 c0                	test   %al,%al
c00047f4:	74 19                	je     c000480f <sema_down+0xea>
/work/x86_os_my/thread/sync.c:37 (discriminator 1)
c00047f6:	68 d4 71 00 c0       	push   $0xc00071d4
c00047fb:	68 58 72 00 c0       	push   $0xc0007258
c0004800:	6a 25                	push   $0x25
c0004802:	68 90 71 00 c0       	push   $0xc0007190
c0004807:	e8 76 dd ff ff       	call   c0002582 <panic_spin>
c000480c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:40
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c000480f:	83 ec 0c             	sub    $0xc,%esp
c0004812:	ff 75 f4             	pushl  -0xc(%ebp)
c0004815:	e8 f7 d3 ff ff       	call   c0001c11 <intr_set_status>
c000481a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:41
}
c000481d:	90                   	nop
c000481e:	c9                   	leave  
c000481f:	c3                   	ret    

c0004820 <sema_up>:
sema_up():
/work/x86_os_my/thread/sync.c:44

/* 信号量的up操作 */
void sema_up(struct semaphore* psema) {
c0004820:	55                   	push   %ebp
c0004821:	89 e5                	mov    %esp,%ebp
c0004823:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:46
	/* 关中断,保证原子操作 */
	enum intr_status old_status = intr_disable();
c0004826:	e8 bd d3 ff ff       	call   c0001be8 <intr_disable>
c000482b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:48
	
	ASSERT(psema->value == 0);
c000482e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004831:	0f b6 00             	movzbl (%eax),%eax
c0004834:	84 c0                	test   %al,%al
c0004836:	74 19                	je     c0004851 <sema_up+0x31>
/work/x86_os_my/thread/sync.c:48 (discriminator 1)
c0004838:	68 d4 71 00 c0       	push   $0xc00071d4
c000483d:	68 64 72 00 c0       	push   $0xc0007264
c0004842:	6a 30                	push   $0x30
c0004844:	68 90 71 00 c0       	push   $0xc0007190
c0004849:	e8 34 dd ff ff       	call   c0002582 <panic_spin>
c000484e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:49
	if (!list_empty(&psema->waiters)) {
c0004851:	8b 45 08             	mov    0x8(%ebp),%eax
c0004854:	83 c0 04             	add    $0x4,%eax
c0004857:	83 ec 0c             	sub    $0xc,%esp
c000485a:	50                   	push   %eax
c000485b:	e8 84 fd ff ff       	call   c00045e4 <list_empty>
c0004860:	83 c4 10             	add    $0x10,%esp
c0004863:	85 c0                	test   %eax,%eax
c0004865:	75 26                	jne    c000488d <sema_up+0x6d>
/work/x86_os_my/thread/sync.c:50
		struct task_struct* thread_blocked = elem2entry(struct task_struct, general_tag, list_pop(&psema->waiters));
c0004867:	8b 45 08             	mov    0x8(%ebp),%eax
c000486a:	83 c0 04             	add    $0x4,%eax
c000486d:	83 ec 0c             	sub    $0xc,%esp
c0004870:	50                   	push   %eax
c0004871:	e8 7f fc ff ff       	call   c00044f5 <list_pop>
c0004876:	83 c4 10             	add    $0x10,%esp
c0004879:	83 e8 24             	sub    $0x24,%eax
c000487c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/sync.c:51
		thread_unblock(thread_blocked);
c000487f:	83 ec 0c             	sub    $0xc,%esp
c0004882:	ff 75 f0             	pushl  -0x10(%ebp)
c0004885:	e8 8b f9 ff ff       	call   c0004215 <thread_unblock>
c000488a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:53
	}
	psema->value++;
c000488d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004890:	0f b6 00             	movzbl (%eax),%eax
c0004893:	8d 50 01             	lea    0x1(%eax),%edx
c0004896:	8b 45 08             	mov    0x8(%ebp),%eax
c0004899:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:54
	ASSERT(psema->value == 1);
c000489b:	8b 45 08             	mov    0x8(%ebp),%eax
c000489e:	0f b6 00             	movzbl (%eax),%eax
c00048a1:	3c 01                	cmp    $0x1,%al
c00048a3:	74 19                	je     c00048be <sema_up+0x9e>
/work/x86_os_my/thread/sync.c:54 (discriminator 1)
c00048a5:	68 e6 71 00 c0       	push   $0xc00071e6
c00048aa:	68 64 72 00 c0       	push   $0xc0007264
c00048af:	6a 36                	push   $0x36
c00048b1:	68 90 71 00 c0       	push   $0xc0007190
c00048b6:	e8 c7 dc ff ff       	call   c0002582 <panic_spin>
c00048bb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:57
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c00048be:	83 ec 0c             	sub    $0xc,%esp
c00048c1:	ff 75 f4             	pushl  -0xc(%ebp)
c00048c4:	e8 48 d3 ff ff       	call   c0001c11 <intr_set_status>
c00048c9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:58
}
c00048cc:	90                   	nop
c00048cd:	c9                   	leave  
c00048ce:	c3                   	ret    

c00048cf <lock_acquire>:
lock_acquire():
/work/x86_os_my/thread/sync.c:61

/* 获取锁plock */
void lock_acquire(struct lock* plock) {
c00048cf:	55                   	push   %ebp
c00048d0:	89 e5                	mov    %esp,%ebp
c00048d2:	53                   	push   %ebx
c00048d3:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:63
	/* 排除曾经自己已经持有锁但还未将其释放的情况。*/
	if (plock->holder != running_thread()) {
c00048d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00048d9:	8b 18                	mov    (%eax),%ebx
c00048db:	e8 a1 f4 ff ff       	call   c0003d81 <running_thread>
c00048e0:	39 c3                	cmp    %eax,%ebx
c00048e2:	74 4d                	je     c0004931 <lock_acquire+0x62>
/work/x86_os_my/thread/sync.c:64
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
c00048e4:	8b 45 08             	mov    0x8(%ebp),%eax
c00048e7:	83 c0 04             	add    $0x4,%eax
c00048ea:	83 ec 0c             	sub    $0xc,%esp
c00048ed:	50                   	push   %eax
c00048ee:	e8 32 fe ff ff       	call   c0004725 <sema_down>
c00048f3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:65
		plock->holder = running_thread();
c00048f6:	e8 86 f4 ff ff       	call   c0003d81 <running_thread>
c00048fb:	89 c2                	mov    %eax,%edx
c00048fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0004900:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/sync.c:66
		ASSERT(plock->holder_repeat_nr == 0);
c0004902:	8b 45 08             	mov    0x8(%ebp),%eax
c0004905:	8b 40 18             	mov    0x18(%eax),%eax
c0004908:	85 c0                	test   %eax,%eax
c000490a:	74 19                	je     c0004925 <lock_acquire+0x56>
/work/x86_os_my/thread/sync.c:66 (discriminator 1)
c000490c:	68 f8 71 00 c0       	push   $0xc00071f8
c0004911:	68 6c 72 00 c0       	push   $0xc000726c
c0004916:	6a 42                	push   $0x42
c0004918:	68 90 71 00 c0       	push   $0xc0007190
c000491d:	e8 60 dc ff ff       	call   c0002582 <panic_spin>
c0004922:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:67
		plock->holder_repeat_nr = 1;
c0004925:	8b 45 08             	mov    0x8(%ebp),%eax
c0004928:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	} else {
		plock->holder_repeat_nr++;
	}
}
c000492f:	eb 0f                	jmp    c0004940 <lock_acquire+0x71>
/work/x86_os_my/thread/sync.c:69
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
		plock->holder = running_thread();
		ASSERT(plock->holder_repeat_nr == 0);
		plock->holder_repeat_nr = 1;
	} else {
		plock->holder_repeat_nr++;
c0004931:	8b 45 08             	mov    0x8(%ebp),%eax
c0004934:	8b 40 18             	mov    0x18(%eax),%eax
c0004937:	8d 50 01             	lea    0x1(%eax),%edx
c000493a:	8b 45 08             	mov    0x8(%ebp),%eax
c000493d:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	}
}
c0004940:	90                   	nop
c0004941:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0004944:	c9                   	leave  
c0004945:	c3                   	ret    

c0004946 <lock_release>:
lock_release():
/work/x86_os_my/thread/sync.c:74

/* 释放锁plock */
void lock_release(struct lock* plock) {
c0004946:	55                   	push   %ebp
c0004947:	89 e5                	mov    %esp,%ebp
c0004949:	53                   	push   %ebx
c000494a:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:75
	ASSERT(plock->holder == running_thread());
c000494d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004950:	8b 18                	mov    (%eax),%ebx
c0004952:	e8 2a f4 ff ff       	call   c0003d81 <running_thread>
c0004957:	39 c3                	cmp    %eax,%ebx
c0004959:	74 19                	je     c0004974 <lock_release+0x2e>
/work/x86_os_my/thread/sync.c:75 (discriminator 1)
c000495b:	68 18 72 00 c0       	push   $0xc0007218
c0004960:	68 7c 72 00 c0       	push   $0xc000727c
c0004965:	6a 4b                	push   $0x4b
c0004967:	68 90 71 00 c0       	push   $0xc0007190
c000496c:	e8 11 dc ff ff       	call   c0002582 <panic_spin>
c0004971:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:76
	if (plock->holder_repeat_nr > 1) {
c0004974:	8b 45 08             	mov    0x8(%ebp),%eax
c0004977:	8b 40 18             	mov    0x18(%eax),%eax
c000497a:	83 f8 01             	cmp    $0x1,%eax
c000497d:	76 11                	jbe    c0004990 <lock_release+0x4a>
/work/x86_os_my/thread/sync.c:77
		plock->holder_repeat_nr--;
c000497f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004982:	8b 40 18             	mov    0x18(%eax),%eax
c0004985:	8d 50 ff             	lea    -0x1(%eax),%edx
c0004988:	8b 45 08             	mov    0x8(%ebp),%eax
c000498b:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:78
		return;
c000498e:	eb 49                	jmp    c00049d9 <lock_release+0x93>
/work/x86_os_my/thread/sync.c:80
	}
	ASSERT(plock->holder_repeat_nr == 1);
c0004990:	8b 45 08             	mov    0x8(%ebp),%eax
c0004993:	8b 40 18             	mov    0x18(%eax),%eax
c0004996:	83 f8 01             	cmp    $0x1,%eax
c0004999:	74 19                	je     c00049b4 <lock_release+0x6e>
/work/x86_os_my/thread/sync.c:80 (discriminator 1)
c000499b:	68 3a 72 00 c0       	push   $0xc000723a
c00049a0:	68 7c 72 00 c0       	push   $0xc000727c
c00049a5:	6a 50                	push   $0x50
c00049a7:	68 90 71 00 c0       	push   $0xc0007190
c00049ac:	e8 d1 db ff ff       	call   c0002582 <panic_spin>
c00049b1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:82

	plock->holder = NULL;			// 把锁的持有者置空放在V操作之前
c00049b4:	8b 45 08             	mov    0x8(%ebp),%eax
c00049b7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:83
	plock->holder_repeat_nr = 0;
c00049bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00049c0:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:84
	sema_up(&plock->semaphore);		// 信号量的V操作,也是原子操作
c00049c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00049ca:	83 c0 04             	add    $0x4,%eax
c00049cd:	83 ec 0c             	sub    $0xc,%esp
c00049d0:	50                   	push   %eax
c00049d1:	e8 4a fe ff ff       	call   c0004820 <sema_up>
c00049d6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:85
}
c00049d9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00049dc:	c9                   	leave  
c00049dd:	c3                   	ret    

c00049de <inb>:
inb():
/work/x86_os_my/lib/kernel/io.h:36
   asm volatile ("cld; rep outsw" : "+S" (addr), "+c" (word_cnt) : "d" (port));
/******************************************************/
}

/* 将从端口port读入的一个字节返回 */
static inline uint8_t inb(uint16_t port) {
c00049de:	55                   	push   %ebp
c00049df:	89 e5                	mov    %esp,%ebp
c00049e1:	83 ec 14             	sub    $0x14,%esp
c00049e4:	8b 45 08             	mov    0x8(%ebp),%eax
c00049e7:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/io.h:38
   uint8_t data;
   asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00049eb:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c00049ef:	89 c2                	mov    %eax,%edx
c00049f1:	ec                   	in     (%dx),%al
c00049f2:	88 45 ff             	mov    %al,-0x1(%ebp)
/work/x86_os_my/lib/kernel/io.h:39
   return data;
c00049f5:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
/work/x86_os_my/lib/kernel/io.h:40
}
c00049f9:	c9                   	leave  
c00049fa:	c3                   	ret    

c00049fb <intr_keyboard_handler>:
intr_keyboard_handler():
/work/x86_os_my/device/keyboard.c:111
/* 0x3A */	{caps_lock_char, caps_lock_char}
/*其它按键暂不处理*/
};

/* 键盘中断处理程序 */
static void intr_keyboard_handler(void) {
c00049fb:	55                   	push   %ebp
c00049fc:	89 e5                	mov    %esp,%ebp
c00049fe:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/device/keyboard.c:114

/* 这次中断发生前的上一次中断,以下任意三个键是否有按下 */
   bool ctrl_down_last = ctrl_status;	  
c0004a01:	a1 8c 95 00 c0       	mov    0xc000958c,%eax
c0004a06:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/device/keyboard.c:115
   bool shift_down_last = shift_status;
c0004a09:	a1 90 95 00 c0       	mov    0xc0009590,%eax
c0004a0e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/device/keyboard.c:116
   bool caps_lock_last = caps_lock_status;
c0004a11:	a1 98 95 00 c0       	mov    0xc0009598,%eax
c0004a16:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/device/keyboard.c:119

   bool break_code;
   uint16_t scancode = inb(KBD_BUF_PORT);
c0004a19:	6a 60                	push   $0x60
c0004a1b:	e8 be ff ff ff       	call   c00049de <inb>
c0004a20:	83 c4 04             	add    $0x4,%esp
c0004a23:	0f b6 c0             	movzbl %al,%eax
c0004a26:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:123

/* 若扫描码是e0开头的,表示此键的按下将产生多个扫描码,
 * 所以马上结束此次中断处理函数,等待下一个扫描码进来*/ 
   if (scancode == 0xe0) { 
c0004a2a:	66 81 7d f6 e0 00    	cmpw   $0xe0,-0xa(%ebp)
c0004a30:	75 0f                	jne    c0004a41 <intr_keyboard_handler+0x46>
/work/x86_os_my/device/keyboard.c:124
      ext_scancode = true;    // 打开e0标记
c0004a32:	c7 05 9c 95 00 c0 01 	movl   $0x1,0xc000959c
c0004a39:	00 00 00 
/work/x86_os_my/device/keyboard.c:125
      return;
c0004a3c:	e9 50 02 00 00       	jmp    c0004c91 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:129
   }

/* 如果上次是以0xe0开头,将扫描码合并 */
   if (ext_scancode) {
c0004a41:	a1 9c 95 00 c0       	mov    0xc000959c,%eax
c0004a46:	85 c0                	test   %eax,%eax
c0004a48:	74 10                	je     c0004a5a <intr_keyboard_handler+0x5f>
/work/x86_os_my/device/keyboard.c:130
      scancode = ((0xe000) | scancode);
c0004a4a:	66 81 4d f6 00 e0    	orw    $0xe000,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:131
      ext_scancode = false;   // 关闭e0标记
c0004a50:	c7 05 9c 95 00 c0 00 	movl   $0x0,0xc000959c
c0004a57:	00 00 00 
/work/x86_os_my/device/keyboard.c:134
   }   

   break_code = ((scancode & 0x0080) != 0);   // 获取break_code
c0004a5a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0004a5e:	25 80 00 00 00       	and    $0x80,%eax
c0004a63:	85 c0                	test   %eax,%eax
c0004a65:	0f 95 c0             	setne  %al
c0004a68:	0f b6 c0             	movzbl %al,%eax
c0004a6b:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/device/keyboard.c:136
   
   if (break_code) {   // 若是断码break_code(按键弹起时产生的扫描码)
c0004a6e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0004a72:	74 6a                	je     c0004ade <intr_keyboard_handler+0xe3>
/work/x86_os_my/device/keyboard.c:140

   /* 由于ctrl_r 和alt_r的make_code和break_code都是两字节,
   所以可用下面的方法取make_code,多字节的扫描码暂不处理 */
      uint16_t make_code = (scancode &= 0xff7f);   // 得到其make_code(按键按下时产生的扫描码)
c0004a74:	66 81 65 f6 7f ff    	andw   $0xff7f,-0xa(%ebp)
c0004a7a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0004a7e:	66 89 45 da          	mov    %ax,-0x26(%ebp)
/work/x86_os_my/device/keyboard.c:143

   /* 若是任意以下三个键弹起了,将状态置为false */
      if (make_code == ctrl_l_make || make_code == ctrl_r_make) {
c0004a82:	66 83 7d da 1d       	cmpw   $0x1d,-0x26(%ebp)
c0004a87:	74 08                	je     c0004a91 <intr_keyboard_handler+0x96>
/work/x86_os_my/device/keyboard.c:143 (discriminator 1)
c0004a89:	66 81 7d da 1d e0    	cmpw   $0xe01d,-0x26(%ebp)
c0004a8f:	75 0c                	jne    c0004a9d <intr_keyboard_handler+0xa2>
/work/x86_os_my/device/keyboard.c:144
	 ctrl_status = false;
c0004a91:	c7 05 8c 95 00 c0 00 	movl   $0x0,0xc000958c
c0004a98:	00 00 00 
c0004a9b:	eb 3c                	jmp    c0004ad9 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:145
      } else if (make_code == shift_l_make || make_code == shift_r_make) {
c0004a9d:	66 83 7d da 2a       	cmpw   $0x2a,-0x26(%ebp)
c0004aa2:	74 07                	je     c0004aab <intr_keyboard_handler+0xb0>
/work/x86_os_my/device/keyboard.c:145 (discriminator 1)
c0004aa4:	66 83 7d da 36       	cmpw   $0x36,-0x26(%ebp)
c0004aa9:	75 0c                	jne    c0004ab7 <intr_keyboard_handler+0xbc>
/work/x86_os_my/device/keyboard.c:146
	 shift_status = false;
c0004aab:	c7 05 90 95 00 c0 00 	movl   $0x0,0xc0009590
c0004ab2:	00 00 00 
c0004ab5:	eb 22                	jmp    c0004ad9 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:147
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
c0004ab7:	66 83 7d da 38       	cmpw   $0x38,-0x26(%ebp)
c0004abc:	74 0c                	je     c0004aca <intr_keyboard_handler+0xcf>
/work/x86_os_my/device/keyboard.c:147 (discriminator 1)
c0004abe:	66 81 7d da 38 e0    	cmpw   $0xe038,-0x26(%ebp)
c0004ac4:	0f 85 c0 01 00 00    	jne    c0004c8a <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:148
	 alt_status = false;
c0004aca:	c7 05 94 95 00 c0 00 	movl   $0x0,0xc0009594
c0004ad1:	00 00 00 
/work/x86_os_my/device/keyboard.c:151
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c0004ad4:	e9 b1 01 00 00       	jmp    c0004c8a <intr_keyboard_handler+0x28f>
c0004ad9:	e9 ac 01 00 00       	jmp    c0004c8a <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:155

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
c0004ade:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c0004ae3:	74 07                	je     c0004aec <intr_keyboard_handler+0xf1>
/work/x86_os_my/device/keyboard.c:155 (discriminator 1)
c0004ae5:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0004aea:	76 14                	jbe    c0004b00 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:155 (discriminator 3)
c0004aec:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c0004af2:	74 0c                	je     c0004b00 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:156
	       (scancode == alt_r_make) || \
c0004af4:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0004afa:	0f 85 78 01 00 00    	jne    c0004c78 <intr_keyboard_handler+0x27d>
/work/x86_os_my/device/keyboard.c:158
	       (scancode == ctrl_r_make)) {
      bool shift = false;  // 判断是否与shift组合,用来在一维数组中索引对应的字符
c0004b00:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:159
      if ((scancode < 0x0e) || (scancode == 0x29) || \
c0004b07:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%ebp)
c0004b0c:	76 3f                	jbe    c0004b4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 1)
c0004b0e:	66 83 7d f6 29       	cmpw   $0x29,-0xa(%ebp)
c0004b13:	74 38                	je     c0004b4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 2)
c0004b15:	66 83 7d f6 1a       	cmpw   $0x1a,-0xa(%ebp)
c0004b1a:	74 31                	je     c0004b4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160
	 (scancode == 0x1a) || (scancode == 0x1b) || \
c0004b1c:	66 83 7d f6 1b       	cmpw   $0x1b,-0xa(%ebp)
c0004b21:	74 2a                	je     c0004b4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160 (discriminator 1)
c0004b23:	66 83 7d f6 2b       	cmpw   $0x2b,-0xa(%ebp)
c0004b28:	74 23                	je     c0004b4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161
	 (scancode == 0x2b) || (scancode == 0x27) || \
c0004b2a:	66 83 7d f6 27       	cmpw   $0x27,-0xa(%ebp)
c0004b2f:	74 1c                	je     c0004b4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161 (discriminator 1)
c0004b31:	66 83 7d f6 28       	cmpw   $0x28,-0xa(%ebp)
c0004b36:	74 15                	je     c0004b4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162
	 (scancode == 0x28) || (scancode == 0x33) || \
c0004b38:	66 83 7d f6 33       	cmpw   $0x33,-0xa(%ebp)
c0004b3d:	74 0e                	je     c0004b4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162 (discriminator 1)
c0004b3f:	66 83 7d f6 34       	cmpw   $0x34,-0xa(%ebp)
c0004b44:	74 07                	je     c0004b4d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:163
	 (scancode == 0x34) || (scancode == 0x35)) {  
c0004b46:	66 83 7d f6 35       	cmpw   $0x35,-0xa(%ebp)
c0004b4b:	75 0f                	jne    c0004b5c <intr_keyboard_handler+0x161>
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c0004b4d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0004b51:	74 3a                	je     c0004b8d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:177
	    shift = true;
c0004b53:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c0004b5a:	eb 31                	jmp    c0004b8d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:180
	    shift = true;
	 }
      } else {	  // 默认为字母键
	 if (shift_down_last && caps_lock_last) {  // 如果shift和capslock同时按下
c0004b5c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0004b60:	74 0f                	je     c0004b71 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:180 (discriminator 1)
c0004b62:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0004b66:	74 09                	je     c0004b71 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:181
	    shift = false;
c0004b68:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0004b6f:	eb 1c                	jmp    c0004b8d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:182
	 } else if (shift_down_last || caps_lock_last) { // 如果shift和capslock任意被按下
c0004b71:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0004b75:	75 06                	jne    c0004b7d <intr_keyboard_handler+0x182>
/work/x86_os_my/device/keyboard.c:182 (discriminator 1)
c0004b77:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0004b7b:	74 09                	je     c0004b86 <intr_keyboard_handler+0x18b>
/work/x86_os_my/device/keyboard.c:183
	    shift = true;
c0004b7d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c0004b84:	eb 07                	jmp    c0004b8d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:185
	 } else {
	    shift = false;
c0004b86:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:189
	 }
      }

      uint8_t index = (scancode &= 0x00ff);  // 将扫描码的高字节置0,主要是针对高字节是e0的扫描码.
c0004b8d:	66 81 65 f6 ff 00    	andw   $0xff,-0xa(%ebp)
c0004b93:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0004b97:	88 45 d9             	mov    %al,-0x27(%ebp)
/work/x86_os_my/device/keyboard.c:190
      char cur_char = keymap[index][shift];  // 在数组中找到对应的字符
c0004b9a:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
c0004b9e:	8d 14 00             	lea    (%eax,%eax,1),%edx
c0004ba1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0004ba4:	01 d0                	add    %edx,%eax
c0004ba6:	05 e0 90 00 c0       	add    $0xc00090e0,%eax
c0004bab:	0f b6 00             	movzbl (%eax),%eax
c0004bae:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:193

   /* 如果cur_char不为0,也就是ascii码为除'\0'外的字符就加入键盘缓冲区中 */
      if (cur_char) {
c0004bb1:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c0004bb5:	74 54                	je     c0004c0b <intr_keyboard_handler+0x210>
/work/x86_os_my/device/keyboard.c:200
     /*****************  快捷键ctrl+l和ctrl+u的处理 *********************
      * 下面是把ctrl+l和ctrl+u这两种组合键产生的字符置为:
      * cur_char的asc码-字符a的asc码, 此差值比较小,
      * 属于asc码表中不可见的字符部分.故不会产生可见字符.
      * 我们在shell中将ascii值为l-a和u-a的分别处理为清屏和删除输入的快捷键*/
	 if ((ctrl_down_last && cur_char == 'l') || (ctrl_down_last && cur_char == 'u')) {
c0004bb7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0004bbb:	74 06                	je     c0004bc3 <intr_keyboard_handler+0x1c8>
/work/x86_os_my/device/keyboard.c:200 (discriminator 1)
c0004bbd:	80 7d ef 6c          	cmpb   $0x6c,-0x11(%ebp)
c0004bc1:	74 0c                	je     c0004bcf <intr_keyboard_handler+0x1d4>
/work/x86_os_my/device/keyboard.c:200 (discriminator 3)
c0004bc3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0004bc7:	74 10                	je     c0004bd9 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:200 (discriminator 4)
c0004bc9:	80 7d ef 75          	cmpb   $0x75,-0x11(%ebp)
c0004bcd:	75 0a                	jne    c0004bd9 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:201
	    cur_char -= 'a';
c0004bcf:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c0004bd3:	83 e8 61             	sub    $0x61,%eax
c0004bd6:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:207
	 }
      /****************************************************************/
      
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
c0004bd9:	83 ec 0c             	sub    $0xc,%esp
c0004bdc:	68 e0 9b 00 c0       	push   $0xc0009be0
c0004be1:	e8 58 01 00 00       	call   c0004d3e <ioq_full>
c0004be6:	83 c4 10             	add    $0x10,%esp
c0004be9:	85 c0                	test   %eax,%eax
c0004beb:	0f 85 9c 00 00 00    	jne    c0004c8d <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:208
	    ioq_putchar(&kbd_buf, cur_char);
c0004bf1:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
c0004bf5:	83 ec 08             	sub    $0x8,%esp
c0004bf8:	50                   	push   %eax
c0004bf9:	68 e0 9b 00 c0       	push   $0xc0009be0
c0004bfe:	e8 0d 03 00 00       	call   c0004f10 <ioq_putchar>
c0004c03:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:210
	 }
	 return;
c0004c06:	e9 82 00 00 00       	jmp    c0004c8d <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:214
      }

      /* 记录本次是否按下了下面几类控制键之一,供下次键入时判断组合键 */
      if (scancode == ctrl_l_make || scancode == ctrl_r_make) {
c0004c0b:	66 83 7d f6 1d       	cmpw   $0x1d,-0xa(%ebp)
c0004c10:	74 08                	je     c0004c1a <intr_keyboard_handler+0x21f>
/work/x86_os_my/device/keyboard.c:214 (discriminator 1)
c0004c12:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0004c18:	75 0c                	jne    c0004c26 <intr_keyboard_handler+0x22b>
/work/x86_os_my/device/keyboard.c:215
	 ctrl_status = true;
c0004c1a:	c7 05 8c 95 00 c0 01 	movl   $0x1,0xc000958c
c0004c21:	00 00 00 
c0004c24:	eb 50                	jmp    c0004c76 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:216
      } else if (scancode == shift_l_make || scancode == shift_r_make) {
c0004c26:	66 83 7d f6 2a       	cmpw   $0x2a,-0xa(%ebp)
c0004c2b:	74 07                	je     c0004c34 <intr_keyboard_handler+0x239>
/work/x86_os_my/device/keyboard.c:216 (discriminator 1)
c0004c2d:	66 83 7d f6 36       	cmpw   $0x36,-0xa(%ebp)
c0004c32:	75 0c                	jne    c0004c40 <intr_keyboard_handler+0x245>
/work/x86_os_my/device/keyboard.c:217
	 shift_status = true;
c0004c34:	c7 05 90 95 00 c0 01 	movl   $0x1,0xc0009590
c0004c3b:	00 00 00 
c0004c3e:	eb 36                	jmp    c0004c76 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:218
      } else if (scancode == alt_l_make || scancode == alt_r_make) {
c0004c40:	66 83 7d f6 38       	cmpw   $0x38,-0xa(%ebp)
c0004c45:	74 08                	je     c0004c4f <intr_keyboard_handler+0x254>
/work/x86_os_my/device/keyboard.c:218 (discriminator 1)
c0004c47:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c0004c4d:	75 0c                	jne    c0004c5b <intr_keyboard_handler+0x260>
/work/x86_os_my/device/keyboard.c:219
	 alt_status = true;
c0004c4f:	c7 05 94 95 00 c0 01 	movl   $0x1,0xc0009594
c0004c56:	00 00 00 
c0004c59:	eb 1b                	jmp    c0004c76 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:220
      } else if (scancode == caps_lock_make) {
c0004c5b:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0004c60:	75 2e                	jne    c0004c90 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:223
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
c0004c62:	a1 98 95 00 c0       	mov    0xc0009598,%eax
c0004c67:	85 c0                	test   %eax,%eax
c0004c69:	0f 94 c0             	sete   %al
c0004c6c:	0f b6 c0             	movzbl %al,%eax
c0004c6f:	a3 98 95 00 c0       	mov    %eax,0xc0009598
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c0004c74:	eb 1a                	jmp    c0004c90 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:157 (discriminator 3)
c0004c76:	eb 18                	jmp    c0004c90 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:226
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
c0004c78:	83 ec 0c             	sub    $0xc,%esp
c0004c7b:	68 89 72 00 c0       	push   $0xc0007289
c0004c80:	e8 8b d7 ff ff       	call   c0002410 <put_str>
c0004c85:	83 c4 10             	add    $0x10,%esp
c0004c88:	eb 07                	jmp    c0004c91 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:151
	 shift_status = false;
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
	 alt_status = false;
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c0004c8a:	90                   	nop
c0004c8b:	eb 04                	jmp    c0004c91 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:210
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
	    ioq_putchar(&kbd_buf, cur_char);
	 }
	 return;
c0004c8d:	90                   	nop
c0004c8e:	eb 01                	jmp    c0004c91 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c0004c90:	90                   	nop
/work/x86_os_my/device/keyboard.c:228
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
   }
}
c0004c91:	c9                   	leave  
c0004c92:	c3                   	ret    

c0004c93 <keyboard_init>:
keyboard_init():
/work/x86_os_my/device/keyboard.c:231

/* 键盘初始化 */
void keyboard_init() {
c0004c93:	55                   	push   %ebp
c0004c94:	89 e5                	mov    %esp,%ebp
c0004c96:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/keyboard.c:232
   put_str("keyboard init start\n");
c0004c99:	83 ec 0c             	sub    $0xc,%esp
c0004c9c:	68 96 72 00 c0       	push   $0xc0007296
c0004ca1:	e8 6a d7 ff ff       	call   c0002410 <put_str>
c0004ca6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:233
   ioqueue_init(&kbd_buf);
c0004ca9:	83 ec 0c             	sub    $0xc,%esp
c0004cac:	68 e0 9b 00 c0       	push   $0xc0009be0
c0004cb1:	e8 28 00 00 00       	call   c0004cde <ioqueue_init>
c0004cb6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:234
   register_handler(0x21, intr_keyboard_handler);
c0004cb9:	83 ec 08             	sub    $0x8,%esp
c0004cbc:	68 fb 49 00 c0       	push   $0xc00049fb
c0004cc1:	6a 21                	push   $0x21
c0004cc3:	e8 8b cf ff ff       	call   c0001c53 <register_handler>
c0004cc8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:235
   put_str("keyboard init done\n");
c0004ccb:	83 ec 0c             	sub    $0xc,%esp
c0004cce:	68 ab 72 00 c0       	push   $0xc00072ab
c0004cd3:	e8 38 d7 ff ff       	call   c0002410 <put_str>
c0004cd8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:236
}
c0004cdb:	90                   	nop
c0004cdc:	c9                   	leave  
c0004cdd:	c3                   	ret    

c0004cde <ioqueue_init>:
ioqueue_init():
/work/x86_os_my/device/ioqueue.c:7
#include "interrupt.h"
#include "global.h"
#include "debug.h"

/* 初始化io队列ioq */
void ioqueue_init(struct ioqueue* ioq) {
c0004cde:	55                   	push   %ebp
c0004cdf:	89 e5                	mov    %esp,%ebp
c0004ce1:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:8
   lock_init(&ioq->lock);     // 初始化io队列的锁
c0004ce4:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ce7:	83 ec 0c             	sub    $0xc,%esp
c0004cea:	50                   	push   %eax
c0004ceb:	e8 05 fa ff ff       	call   c00046f5 <lock_init>
c0004cf0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:9
   ioq->producer = ioq->consumer = NULL;  // 生产者和消费者置空
c0004cf3:	8b 45 08             	mov    0x8(%ebp),%eax
c0004cf6:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c0004cfd:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d00:	8b 50 20             	mov    0x20(%eax),%edx
c0004d03:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d06:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/device/ioqueue.c:10
   ioq->head = ioq->tail = 0; // 队列的首尾指针指向缓冲区数组第0个位置
c0004d09:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d0c:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)
c0004d13:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d16:	8b 50 68             	mov    0x68(%eax),%edx
c0004d19:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d1c:	89 50 64             	mov    %edx,0x64(%eax)
/work/x86_os_my/device/ioqueue.c:11
}
c0004d1f:	90                   	nop
c0004d20:	c9                   	leave  
c0004d21:	c3                   	ret    

c0004d22 <next_pos>:
next_pos():
/work/x86_os_my/device/ioqueue.c:14

/* 返回pos在缓冲区中的下一个位置值 */
static int32_t next_pos(int32_t pos) {
c0004d22:	55                   	push   %ebp
c0004d23:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/device/ioqueue.c:15
   return (pos + 1) % bufsize; 
c0004d25:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d28:	8d 50 01             	lea    0x1(%eax),%edx
c0004d2b:	89 d0                	mov    %edx,%eax
c0004d2d:	c1 f8 1f             	sar    $0x1f,%eax
c0004d30:	c1 e8 1a             	shr    $0x1a,%eax
c0004d33:	01 c2                	add    %eax,%edx
c0004d35:	83 e2 3f             	and    $0x3f,%edx
c0004d38:	29 c2                	sub    %eax,%edx
c0004d3a:	89 d0                	mov    %edx,%eax
/work/x86_os_my/device/ioqueue.c:16
}
c0004d3c:	5d                   	pop    %ebp
c0004d3d:	c3                   	ret    

c0004d3e <ioq_full>:
ioq_full():
/work/x86_os_my/device/ioqueue.c:19

/* 判断队列是否已满 */
bool ioq_full(struct ioqueue* ioq) {
c0004d3e:	55                   	push   %ebp
c0004d3f:	89 e5                	mov    %esp,%ebp
c0004d41:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:20
   ASSERT(intr_get_status() == INTR_OFF);
c0004d44:	e8 e6 ce ff ff       	call   c0001c2f <intr_get_status>
c0004d49:	85 c0                	test   %eax,%eax
c0004d4b:	74 19                	je     c0004d66 <ioq_full+0x28>
/work/x86_os_my/device/ioqueue.c:20 (discriminator 1)
c0004d4d:	68 c0 72 00 c0       	push   $0xc00072c0
c0004d52:	68 24 73 00 c0       	push   $0xc0007324
c0004d57:	6a 14                	push   $0x14
c0004d59:	68 de 72 00 c0       	push   $0xc00072de
c0004d5e:	e8 1f d8 ff ff       	call   c0002582 <panic_spin>
c0004d63:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:21
   return next_pos(ioq->head) == ioq->tail;
c0004d66:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d69:	8b 40 64             	mov    0x64(%eax),%eax
c0004d6c:	83 ec 0c             	sub    $0xc,%esp
c0004d6f:	50                   	push   %eax
c0004d70:	e8 ad ff ff ff       	call   c0004d22 <next_pos>
c0004d75:	83 c4 10             	add    $0x10,%esp
c0004d78:	89 c2                	mov    %eax,%edx
c0004d7a:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d7d:	8b 40 68             	mov    0x68(%eax),%eax
c0004d80:	39 c2                	cmp    %eax,%edx
c0004d82:	0f 94 c0             	sete   %al
c0004d85:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:22
}
c0004d88:	c9                   	leave  
c0004d89:	c3                   	ret    

c0004d8a <ioq_empty>:
ioq_empty():
/work/x86_os_my/device/ioqueue.c:25

/* 判断队列是否已空 */
static bool ioq_empty(struct ioqueue* ioq) {
c0004d8a:	55                   	push   %ebp
c0004d8b:	89 e5                	mov    %esp,%ebp
c0004d8d:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:26
   ASSERT(intr_get_status() == INTR_OFF);
c0004d90:	e8 9a ce ff ff       	call   c0001c2f <intr_get_status>
c0004d95:	85 c0                	test   %eax,%eax
c0004d97:	74 19                	je     c0004db2 <ioq_empty+0x28>
/work/x86_os_my/device/ioqueue.c:26 (discriminator 1)
c0004d99:	68 c0 72 00 c0       	push   $0xc00072c0
c0004d9e:	68 30 73 00 c0       	push   $0xc0007330
c0004da3:	6a 1a                	push   $0x1a
c0004da5:	68 de 72 00 c0       	push   $0xc00072de
c0004daa:	e8 d3 d7 ff ff       	call   c0002582 <panic_spin>
c0004daf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:27
   return ioq->head == ioq->tail;
c0004db2:	8b 45 08             	mov    0x8(%ebp),%eax
c0004db5:	8b 50 64             	mov    0x64(%eax),%edx
c0004db8:	8b 45 08             	mov    0x8(%ebp),%eax
c0004dbb:	8b 40 68             	mov    0x68(%eax),%eax
c0004dbe:	39 c2                	cmp    %eax,%edx
c0004dc0:	0f 94 c0             	sete   %al
c0004dc3:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:28
}
c0004dc6:	c9                   	leave  
c0004dc7:	c3                   	ret    

c0004dc8 <ioq_wait>:
ioq_wait():
/work/x86_os_my/device/ioqueue.c:31

/* 使当前生产者或消费者在此缓冲区上等待 */
static void ioq_wait(struct task_struct** waiter) {
c0004dc8:	55                   	push   %ebp
c0004dc9:	89 e5                	mov    %esp,%ebp
c0004dcb:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:32
   ASSERT(*waiter == NULL && waiter != NULL);
c0004dce:	8b 45 08             	mov    0x8(%ebp),%eax
c0004dd1:	8b 00                	mov    (%eax),%eax
c0004dd3:	85 c0                	test   %eax,%eax
c0004dd5:	75 06                	jne    c0004ddd <ioq_wait+0x15>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 1)
c0004dd7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0004ddb:	75 19                	jne    c0004df6 <ioq_wait+0x2e>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 3)
c0004ddd:	68 f0 72 00 c0       	push   $0xc00072f0
c0004de2:	68 3c 73 00 c0       	push   $0xc000733c
c0004de7:	6a 20                	push   $0x20
c0004de9:	68 de 72 00 c0       	push   $0xc00072de
c0004dee:	e8 8f d7 ff ff       	call   c0002582 <panic_spin>
c0004df3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:33
   *waiter = running_thread();
c0004df6:	e8 86 ef ff ff       	call   c0003d81 <running_thread>
c0004dfb:	89 c2                	mov    %eax,%edx
c0004dfd:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e00:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ioqueue.c:34
   thread_block(TASK_BLOCKED);
c0004e02:	83 ec 0c             	sub    $0xc,%esp
c0004e05:	6a 02                	push   $0x2
c0004e07:	e8 a6 f3 ff ff       	call   c00041b2 <thread_block>
c0004e0c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:35
}
c0004e0f:	90                   	nop
c0004e10:	c9                   	leave  
c0004e11:	c3                   	ret    

c0004e12 <wakeup>:
wakeup():
/work/x86_os_my/device/ioqueue.c:38

/* 唤醒waiter */
static void wakeup(struct task_struct** waiter) {
c0004e12:	55                   	push   %ebp
c0004e13:	89 e5                	mov    %esp,%ebp
c0004e15:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:39
   ASSERT(*waiter != NULL);
c0004e18:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e1b:	8b 00                	mov    (%eax),%eax
c0004e1d:	85 c0                	test   %eax,%eax
c0004e1f:	75 19                	jne    c0004e3a <wakeup+0x28>
/work/x86_os_my/device/ioqueue.c:39 (discriminator 1)
c0004e21:	68 12 73 00 c0       	push   $0xc0007312
c0004e26:	68 48 73 00 c0       	push   $0xc0007348
c0004e2b:	6a 27                	push   $0x27
c0004e2d:	68 de 72 00 c0       	push   $0xc00072de
c0004e32:	e8 4b d7 ff ff       	call   c0002582 <panic_spin>
c0004e37:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:40
   thread_unblock(*waiter); 
c0004e3a:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e3d:	8b 00                	mov    (%eax),%eax
c0004e3f:	83 ec 0c             	sub    $0xc,%esp
c0004e42:	50                   	push   %eax
c0004e43:	e8 cd f3 ff ff       	call   c0004215 <thread_unblock>
c0004e48:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:41
   *waiter = NULL;
c0004e4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e4e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/device/ioqueue.c:42
}
c0004e54:	90                   	nop
c0004e55:	c9                   	leave  
c0004e56:	c3                   	ret    

c0004e57 <ioq_getchar>:
ioq_getchar():
/work/x86_os_my/device/ioqueue.c:45

/* 消费者从ioq队列中获取一个字符 */
char ioq_getchar(struct ioqueue* ioq) {
c0004e57:	55                   	push   %ebp
c0004e58:	89 e5                	mov    %esp,%ebp
c0004e5a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ioqueue.c:46
   ASSERT(intr_get_status() == INTR_OFF);
c0004e5d:	e8 cd cd ff ff       	call   c0001c2f <intr_get_status>
c0004e62:	85 c0                	test   %eax,%eax
c0004e64:	74 4b                	je     c0004eb1 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:46 (discriminator 1)
c0004e66:	68 c0 72 00 c0       	push   $0xc00072c0
c0004e6b:	68 50 73 00 c0       	push   $0xc0007350
c0004e70:	6a 2e                	push   $0x2e
c0004e72:	68 de 72 00 c0       	push   $0xc00072de
c0004e77:	e8 06 d7 ff ff       	call   c0002582 <panic_spin>
c0004e7c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51 (discriminator 1)

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c0004e7f:	eb 30                	jmp    c0004eb1 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:52
      lock_acquire(&ioq->lock);	 
c0004e81:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e84:	83 ec 0c             	sub    $0xc,%esp
c0004e87:	50                   	push   %eax
c0004e88:	e8 42 fa ff ff       	call   c00048cf <lock_acquire>
c0004e8d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:53
      ioq_wait(&ioq->consumer);
c0004e90:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e93:	83 c0 20             	add    $0x20,%eax
c0004e96:	83 ec 0c             	sub    $0xc,%esp
c0004e99:	50                   	push   %eax
c0004e9a:	e8 29 ff ff ff       	call   c0004dc8 <ioq_wait>
c0004e9f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:54
      lock_release(&ioq->lock);
c0004ea2:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ea5:	83 ec 0c             	sub    $0xc,%esp
c0004ea8:	50                   	push   %eax
c0004ea9:	e8 98 fa ff ff       	call   c0004946 <lock_release>
c0004eae:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c0004eb1:	83 ec 0c             	sub    $0xc,%esp
c0004eb4:	ff 75 08             	pushl  0x8(%ebp)
c0004eb7:	e8 ce fe ff ff       	call   c0004d8a <ioq_empty>
c0004ebc:	83 c4 10             	add    $0x10,%esp
c0004ebf:	85 c0                	test   %eax,%eax
c0004ec1:	75 be                	jne    c0004e81 <ioq_getchar+0x2a>
/work/x86_os_my/device/ioqueue.c:57
      lock_acquire(&ioq->lock);	 
      ioq_wait(&ioq->consumer);
      lock_release(&ioq->lock);
   }

   char byte = ioq->buf[ioq->tail];	  // 从缓冲区中取出
c0004ec3:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ec6:	8b 40 68             	mov    0x68(%eax),%eax
c0004ec9:	8b 55 08             	mov    0x8(%ebp),%edx
c0004ecc:	0f b6 44 02 24       	movzbl 0x24(%edx,%eax,1),%eax
c0004ed1:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ioqueue.c:58
   ioq->tail = next_pos(ioq->tail);	  // 把读游标移到下一位置
c0004ed4:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ed7:	8b 40 68             	mov    0x68(%eax),%eax
c0004eda:	83 ec 0c             	sub    $0xc,%esp
c0004edd:	50                   	push   %eax
c0004ede:	e8 3f fe ff ff       	call   c0004d22 <next_pos>
c0004ee3:	83 c4 10             	add    $0x10,%esp
c0004ee6:	89 c2                	mov    %eax,%edx
c0004ee8:	8b 45 08             	mov    0x8(%ebp),%eax
c0004eeb:	89 50 68             	mov    %edx,0x68(%eax)
/work/x86_os_my/device/ioqueue.c:60

   if (ioq->producer != NULL) {
c0004eee:	8b 45 08             	mov    0x8(%ebp),%eax
c0004ef1:	8b 40 1c             	mov    0x1c(%eax),%eax
c0004ef4:	85 c0                	test   %eax,%eax
c0004ef6:	74 12                	je     c0004f0a <ioq_getchar+0xb3>
/work/x86_os_my/device/ioqueue.c:61
      wakeup(&ioq->producer);		  // 唤醒生产者
c0004ef8:	8b 45 08             	mov    0x8(%ebp),%eax
c0004efb:	83 c0 1c             	add    $0x1c,%eax
c0004efe:	83 ec 0c             	sub    $0xc,%esp
c0004f01:	50                   	push   %eax
c0004f02:	e8 0b ff ff ff       	call   c0004e12 <wakeup>
c0004f07:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:64
   }

   return byte; 
c0004f0a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
/work/x86_os_my/device/ioqueue.c:65
}
c0004f0e:	c9                   	leave  
c0004f0f:	c3                   	ret    

c0004f10 <ioq_putchar>:
ioq_putchar():
/work/x86_os_my/device/ioqueue.c:68

/* 生产者往ioq队列中写入一个字符byte */
void ioq_putchar(struct ioqueue* ioq, char byte) {
c0004f10:	55                   	push   %ebp
c0004f11:	89 e5                	mov    %esp,%ebp
c0004f13:	83 ec 18             	sub    $0x18,%esp
c0004f16:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004f19:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/ioqueue.c:69
   ASSERT(intr_get_status() == INTR_OFF);
c0004f1c:	e8 0e cd ff ff       	call   c0001c2f <intr_get_status>
c0004f21:	85 c0                	test   %eax,%eax
c0004f23:	74 4b                	je     c0004f70 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:69 (discriminator 1)
c0004f25:	68 c0 72 00 c0       	push   $0xc00072c0
c0004f2a:	68 5c 73 00 c0       	push   $0xc000735c
c0004f2f:	6a 45                	push   $0x45
c0004f31:	68 de 72 00 c0       	push   $0xc00072de
c0004f36:	e8 47 d6 ff ff       	call   c0002582 <panic_spin>
c0004f3b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74 (discriminator 1)

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c0004f3e:	eb 30                	jmp    c0004f70 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:75
      lock_acquire(&ioq->lock);
c0004f40:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f43:	83 ec 0c             	sub    $0xc,%esp
c0004f46:	50                   	push   %eax
c0004f47:	e8 83 f9 ff ff       	call   c00048cf <lock_acquire>
c0004f4c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:76
      ioq_wait(&ioq->producer);
c0004f4f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f52:	83 c0 1c             	add    $0x1c,%eax
c0004f55:	83 ec 0c             	sub    $0xc,%esp
c0004f58:	50                   	push   %eax
c0004f59:	e8 6a fe ff ff       	call   c0004dc8 <ioq_wait>
c0004f5e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:77
      lock_release(&ioq->lock);
c0004f61:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f64:	83 ec 0c             	sub    $0xc,%esp
c0004f67:	50                   	push   %eax
c0004f68:	e8 d9 f9 ff ff       	call   c0004946 <lock_release>
c0004f6d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c0004f70:	83 ec 0c             	sub    $0xc,%esp
c0004f73:	ff 75 08             	pushl  0x8(%ebp)
c0004f76:	e8 c3 fd ff ff       	call   c0004d3e <ioq_full>
c0004f7b:	83 c4 10             	add    $0x10,%esp
c0004f7e:	85 c0                	test   %eax,%eax
c0004f80:	75 be                	jne    c0004f40 <ioq_putchar+0x30>
/work/x86_os_my/device/ioqueue.c:79
      lock_acquire(&ioq->lock);
      ioq_wait(&ioq->producer);
      lock_release(&ioq->lock);
   }
   ioq->buf[ioq->head] = byte;      // 把字节放入缓冲区中
c0004f82:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f85:	8b 40 64             	mov    0x64(%eax),%eax
c0004f88:	8b 55 08             	mov    0x8(%ebp),%edx
c0004f8b:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
c0004f8f:	88 4c 02 24          	mov    %cl,0x24(%edx,%eax,1)
/work/x86_os_my/device/ioqueue.c:80
   ioq->head = next_pos(ioq->head); // 把写游标移到下一位置
c0004f93:	8b 45 08             	mov    0x8(%ebp),%eax
c0004f96:	8b 40 64             	mov    0x64(%eax),%eax
c0004f99:	83 ec 0c             	sub    $0xc,%esp
c0004f9c:	50                   	push   %eax
c0004f9d:	e8 80 fd ff ff       	call   c0004d22 <next_pos>
c0004fa2:	83 c4 10             	add    $0x10,%esp
c0004fa5:	89 c2                	mov    %eax,%edx
c0004fa7:	8b 45 08             	mov    0x8(%ebp),%eax
c0004faa:	89 50 64             	mov    %edx,0x64(%eax)
/work/x86_os_my/device/ioqueue.c:82

   if (ioq->consumer != NULL) {
c0004fad:	8b 45 08             	mov    0x8(%ebp),%eax
c0004fb0:	8b 40 20             	mov    0x20(%eax),%eax
c0004fb3:	85 c0                	test   %eax,%eax
c0004fb5:	74 12                	je     c0004fc9 <ioq_putchar+0xb9>
/work/x86_os_my/device/ioqueue.c:83
      wakeup(&ioq->consumer);          // 唤醒消费者
c0004fb7:	8b 45 08             	mov    0x8(%ebp),%eax
c0004fba:	83 c0 20             	add    $0x20,%eax
c0004fbd:	83 ec 0c             	sub    $0xc,%esp
c0004fc0:	50                   	push   %eax
c0004fc1:	e8 4c fe ff ff       	call   c0004e12 <wakeup>
c0004fc6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:85
   }
}
c0004fc9:	90                   	nop
c0004fca:	c9                   	leave  
c0004fcb:	c3                   	ret    

c0004fcc <update_tss_esp>:
update_tss_esp():
/work/x86_os_my/userprog/tss.c:40
	uint32_t io_base;
}; 
static struct tss g_tss;

/* 更新tss中esp0字段的值为pthread的0级栈 */
void update_tss_esp(struct task_struct* pthread) {
c0004fcc:	55                   	push   %ebp
c0004fcd:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/userprog/tss.c:41
	g_tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c0004fcf:	8b 45 08             	mov    0x8(%ebp),%eax
c0004fd2:	05 00 10 00 00       	add    $0x1000,%eax
c0004fd7:	a3 a4 95 00 c0       	mov    %eax,0xc00095a4
/work/x86_os_my/userprog/tss.c:42
}
c0004fdc:	90                   	nop
c0004fdd:	5d                   	pop    %ebp
c0004fde:	c3                   	ret    

c0004fdf <make_gdt_desc>:
make_gdt_desc():
/work/x86_os_my/userprog/tss.c:45

/* c语言方式，创建gdt描述符 */
static struct gdt_desc make_gdt_desc(uint32_t* desc_addr, uint32_t limit, uint8_t attr_low, uint8_t attr_high) {
c0004fdf:	55                   	push   %ebp
c0004fe0:	89 e5                	mov    %esp,%ebp
c0004fe2:	83 ec 18             	sub    $0x18,%esp
c0004fe5:	8b 55 14             	mov    0x14(%ebp),%edx
c0004fe8:	8b 45 18             	mov    0x18(%ebp),%eax
c0004feb:	88 55 ec             	mov    %dl,-0x14(%ebp)
c0004fee:	88 45 e8             	mov    %al,-0x18(%ebp)
/work/x86_os_my/userprog/tss.c:46
	uint32_t desc_base = (uint32_t)desc_addr;
c0004ff1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004ff4:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/userprog/tss.c:48
	struct gdt_desc desc;
	desc.limit_low_word = limit & 0x0000ffff;
c0004ff7:	8b 45 10             	mov    0x10(%ebp),%eax
c0004ffa:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/userprog/tss.c:49
	desc.base_low_word = desc_base & 0x0000ffff;
c0004ffe:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0005001:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/userprog/tss.c:50
	desc.base_mid_byte = ((desc_base & 0x00ff0000) >> 16);
c0005005:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0005008:	25 00 00 ff 00       	and    $0xff0000,%eax
c000500d:	c1 e8 10             	shr    $0x10,%eax
c0005010:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/userprog/tss.c:51
	desc.attr_low_byte = (uint8_t)(attr_low);
c0005013:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0005017:	88 45 f9             	mov    %al,-0x7(%ebp)
/work/x86_os_my/userprog/tss.c:52
	desc.limit_high_attr_high = (((limit & 0x000f0000) >> 16) + (uint8_t)(attr_high));
c000501a:	8b 45 10             	mov    0x10(%ebp),%eax
c000501d:	25 00 00 0f 00       	and    $0xf0000,%eax
c0005022:	c1 e8 10             	shr    $0x10,%eax
c0005025:	89 c2                	mov    %eax,%edx
c0005027:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c000502b:	01 d0                	add    %edx,%eax
c000502d:	88 45 fa             	mov    %al,-0x6(%ebp)
/work/x86_os_my/userprog/tss.c:53
	desc.base_high_byte = desc_base >> 24;
c0005030:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0005033:	c1 e8 18             	shr    $0x18,%eax
c0005036:	88 45 fb             	mov    %al,-0x5(%ebp)
/work/x86_os_my/userprog/tss.c:54
	return desc;
c0005039:	8b 4d 08             	mov    0x8(%ebp),%ecx
c000503c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000503f:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0005042:	89 01                	mov    %eax,(%ecx)
c0005044:	89 51 04             	mov    %edx,0x4(%ecx)
/work/x86_os_my/userprog/tss.c:55
}
c0005047:	8b 45 08             	mov    0x8(%ebp),%eax
c000504a:	c9                   	leave  
c000504b:	c2 04 00             	ret    $0x4

c000504e <tss_init>:
tss_init():
/work/x86_os_my/userprog/tss.c:61

/* 在gdt中创建tss描述符
 * 重新加载 gdt
 * 加载 tr
 */
void tss_init() {
c000504e:	55                   	push   %ebp
c000504f:	89 e5                	mov    %esp,%ebp
c0005051:	53                   	push   %ebx
c0005052:	83 ec 24             	sub    $0x24,%esp
/work/x86_os_my/userprog/tss.c:62
	put_str("tss_init start\n");
c0005055:	83 ec 0c             	sub    $0xc,%esp
c0005058:	68 68 73 00 c0       	push   $0xc0007368
c000505d:	e8 ae d3 ff ff       	call   c0002410 <put_str>
c0005062:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:63
	uint32_t tss_size = sizeof(g_tss);
c0005065:	c7 45 f4 6c 00 00 00 	movl   $0x6c,-0xc(%ebp)
/work/x86_os_my/userprog/tss.c:64
	memset(&g_tss, 0, tss_size);
c000506c:	83 ec 04             	sub    $0x4,%esp
c000506f:	ff 75 f4             	pushl  -0xc(%ebp)
c0005072:	6a 00                	push   $0x0
c0005074:	68 a0 95 00 c0       	push   $0xc00095a0
c0005079:	e8 1c e9 ff ff       	call   c000399a <memset>
c000507e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:66
	
	g_tss.ss0 = SELECTOR_K_STACK;	// 0 级栈段的选择子 
c0005081:	c7 05 a8 95 00 c0 10 	movl   $0x10,0xc00095a8
c0005088:	00 00 00 
/work/x86_os_my/userprog/tss.c:67
	g_tss.io_base = tss_size;		// 当 IO 位图的偏移地址大于等于 TSS 大小减 1 时，就表示没有 IO 位图。
c000508b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000508e:	a3 08 96 00 c0       	mov    %eax,0xc0009608
/work/x86_os_my/userprog/tss.c:75
	 * 内核地址 0xC000_0900 是映射到 0x900 的 
	 * 在GDT中，第 0 个段描述符不可用，第 1 个为代码段，第 2 个为数据段和栈，第 3 个为显存段
	 */

	/* 在gdt中添加dpl为0的TSS描述符 */
	*((struct gdt_desc*)0xc0000920) = make_gdt_desc((uint32_t*)&g_tss, tss_size - 1, TSS_ATTR_LOW, TSS_ATTR_HIGH);
c0005093:	bb 20 09 00 c0       	mov    $0xc0000920,%ebx
c0005098:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000509b:	8d 50 ff             	lea    -0x1(%eax),%edx
c000509e:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00050a1:	83 ec 0c             	sub    $0xc,%esp
c00050a4:	68 80 00 00 00       	push   $0x80
c00050a9:	68 89 00 00 00       	push   $0x89
c00050ae:	52                   	push   %edx
c00050af:	68 a0 95 00 c0       	push   $0xc00095a0
c00050b4:	50                   	push   %eax
c00050b5:	e8 25 ff ff ff       	call   c0004fdf <make_gdt_desc>
c00050ba:	83 c4 1c             	add    $0x1c,%esp
c00050bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00050c0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00050c3:	89 03                	mov    %eax,(%ebx)
c00050c5:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:78

	/* 在gdt中添加dpl为3的,用户级,数据段和代码段描述符 */
	*((struct gdt_desc*)0xc0000928) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
c00050c8:	bb 28 09 00 c0       	mov    $0xc0000928,%ebx
c00050cd:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00050d0:	83 ec 0c             	sub    $0xc,%esp
c00050d3:	68 c0 00 00 00       	push   $0xc0
c00050d8:	68 f8 00 00 00       	push   $0xf8
c00050dd:	68 ff ff 0f 00       	push   $0xfffff
c00050e2:	6a 00                	push   $0x0
c00050e4:	50                   	push   %eax
c00050e5:	e8 f5 fe ff ff       	call   c0004fdf <make_gdt_desc>
c00050ea:	83 c4 1c             	add    $0x1c,%esp
c00050ed:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00050f0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00050f3:	89 03                	mov    %eax,(%ebx)
c00050f5:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:79
	*((struct gdt_desc*)0xc0000930) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
c00050f8:	bb 30 09 00 c0       	mov    $0xc0000930,%ebx
c00050fd:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0005100:	83 ec 0c             	sub    $0xc,%esp
c0005103:	68 c0 00 00 00       	push   $0xc0
c0005108:	68 f2 00 00 00       	push   $0xf2
c000510d:	68 ff ff 0f 00       	push   $0xfffff
c0005112:	6a 00                	push   $0x0
c0005114:	50                   	push   %eax
c0005115:	e8 c5 fe ff ff       	call   c0004fdf <make_gdt_desc>
c000511a:	83 c4 1c             	add    $0x1c,%esp
c000511d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0005120:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0005123:	89 03                	mov    %eax,(%ebx)
c0005125:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:83

	/* GDTR 16位的limit、32位的段基址 */
	// 先转换成 uint32_t 后，再将其转换成 uint64_t 位（不可一步到位转为 uint64_t）
	uint64_t gdt_operand = ((8 * 7 - 1) | ((uint64_t)(uint32_t)0xc0000900 << 16));   // 7个描述符大小
c0005128:	c7 45 e8 37 00 00 09 	movl   $0x9000037,-0x18(%ebp)
c000512f:	c7 45 ec 00 c0 00 00 	movl   $0xc000,-0x14(%ebp)
/work/x86_os_my/userprog/tss.c:84
	asm volatile ("lgdt %0" : : "m" (gdt_operand));
c0005136:	0f 01 55 e8          	lgdtl  -0x18(%ebp)
/work/x86_os_my/userprog/tss.c:85
	asm volatile ("ltr %w0" : : "r" (SELECTOR_TSS));
c000513a:	b8 20 00 00 00       	mov    $0x20,%eax
c000513f:	0f 00 d8             	ltr    %ax
/work/x86_os_my/userprog/tss.c:86
	put_str("tss_init and ltr done\n");
c0005142:	83 ec 0c             	sub    $0xc,%esp
c0005145:	68 78 73 00 c0       	push   $0xc0007378
c000514a:	e8 c1 d2 ff ff       	call   c0002410 <put_str>
c000514f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:87
}
c0005152:	90                   	nop
c0005153:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0005156:	c9                   	leave  
c0005157:	c3                   	ret    

c0005158 <start_process>:
start_process():
/work/x86_os_my/userprog/process.c:17
extern void intr_exit(void);

/* 构建用户进程初始上下文信息
 * 填充用户进程的中断栈，并将中断栈的信息，利用iretd填充到 CPU 中
 */
void start_process(void* filename_) {
c0005158:	55                   	push   %ebp
c0005159:	89 e5                	mov    %esp,%ebp
c000515b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:18
	void* function = filename_;
c000515e:	8b 45 08             	mov    0x8(%ebp),%eax
c0005161:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:19
	struct task_struct* cur = running_thread();
c0005164:	e8 18 ec ff ff       	call   c0003d81 <running_thread>
c0005169:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:20
	cur->self_kstack += sizeof(struct thread_stack);
c000516c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000516f:	8b 00                	mov    (%eax),%eax
c0005171:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
c0005177:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000517a:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/process.c:21
	struct intr_stack* proc_stack = (struct intr_stack*)cur->self_kstack;	 
c000517c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000517f:	8b 00                	mov    (%eax),%eax
c0005181:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/userprog/process.c:22
	proc_stack->edi = proc_stack->esi = proc_stack->ebp = proc_stack->esp_dummy = 0;
c0005184:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005187:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
c000518e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005191:	8b 50 10             	mov    0x10(%eax),%edx
c0005194:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005197:	89 50 0c             	mov    %edx,0xc(%eax)
c000519a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000519d:	8b 50 0c             	mov    0xc(%eax),%edx
c00051a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00051a3:	89 50 08             	mov    %edx,0x8(%eax)
c00051a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00051a9:	8b 50 08             	mov    0x8(%eax),%edx
c00051ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00051af:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/userprog/process.c:23
	proc_stack->ebx = proc_stack->edx = proc_stack->ecx = proc_stack->eax = 0;
c00051b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00051b5:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c00051bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00051bf:	8b 50 20             	mov    0x20(%eax),%edx
c00051c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00051c5:	89 50 1c             	mov    %edx,0x1c(%eax)
c00051c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00051cb:	8b 50 1c             	mov    0x1c(%eax),%edx
c00051ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00051d1:	89 50 18             	mov    %edx,0x18(%eax)
c00051d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00051d7:	8b 50 18             	mov    0x18(%eax),%edx
c00051da:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00051dd:	89 50 14             	mov    %edx,0x14(%eax)
/work/x86_os_my/userprog/process.c:28
	/* 在iretd返回时，如果发现未来的 CPL（也就是内核栈中 CS.RPL，或者说是返回到的用户进程的代码段CS.CPL）
	 * 权限低于（数值上大于） CPU 中段寄存器（如 DS、 ES、 FS、 GS）中选择子指向的内存段的 DPL，
	 * CPU 会自动将相应段寄存器的选择子置为 0 
	 * 这里gs的选择子在iretd返回后，会被自动清零。*/
	proc_stack->gs = 0;					// 用户态用不上,直接初始为0
c00051e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00051e3:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
/work/x86_os_my/userprog/process.c:29
	proc_stack->ds = proc_stack->es = proc_stack->fs = SELECTOR_U_DATA;		// 用户级数据段
c00051ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00051ed:	c7 40 28 33 00 00 00 	movl   $0x33,0x28(%eax)
c00051f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00051f7:	8b 50 28             	mov    0x28(%eax),%edx
c00051fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00051fd:	89 50 2c             	mov    %edx,0x2c(%eax)
c0005200:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005203:	8b 50 2c             	mov    0x2c(%eax),%edx
c0005206:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005209:	89 50 30             	mov    %edx,0x30(%eax)
/work/x86_os_my/userprog/process.c:30
	proc_stack->eip = function;			// 待执行的用户程序地址
c000520c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000520f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005212:	89 50 38             	mov    %edx,0x38(%eax)
/work/x86_os_my/userprog/process.c:31
	proc_stack->cs = SELECTOR_U_CODE;	// 用户级代码段
c0005215:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005218:	c7 40 3c 2b 00 00 00 	movl   $0x2b,0x3c(%eax)
/work/x86_os_my/userprog/process.c:32
	proc_stack->eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);
c000521f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005222:	c7 40 40 02 02 00 00 	movl   $0x202,0x40(%eax)
/work/x86_os_my/userprog/process.c:41
	 * process_activate 使用户进程页表生效【已经把CR3寄存器 更新为 用户进程的页表了】
	 * start_process    为用户进程创建3特权级栈【所以申请的内存空间来自用户进程的页表】
	 * 
	 * USER_STACK3_VADDR=(0xc0000000 - 0x1000)
	 */
	proc_stack->esp = (void*)((uint32_t)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE) ;
c0005229:	83 ec 08             	sub    $0x8,%esp
c000522c:	68 00 f0 ff bf       	push   $0xbffff000
c0005231:	6a 02                	push   $0x2
c0005233:	e8 a8 da ff ff       	call   c0002ce0 <get_a_page>
c0005238:	83 c4 10             	add    $0x10,%esp
c000523b:	05 00 10 00 00       	add    $0x1000,%eax
c0005240:	89 c2                	mov    %eax,%edx
c0005242:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005245:	89 50 44             	mov    %edx,0x44(%eax)
/work/x86_os_my/userprog/process.c:42
	proc_stack->ss = SELECTOR_U_DATA;
c0005248:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000524b:	c7 40 48 33 00 00 00 	movl   $0x33,0x48(%eax)
/work/x86_os_my/userprog/process.c:49
	/* 将 esp 替换为 proc_stack
	 * 通过 jmp intr_exit 那里的一系列 pop 指令和 iretd 指令，
	 * 将 proc_stack 中的数据载入 CPU 的寄存器，
	 * 从而使程序“假装”退出中断，进入特权级 3
	 */
	asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (proc_stack) : "memory");
c0005252:	8b 65 ec             	mov    -0x14(%ebp),%esp
c0005255:	e9 56 cc ff ff       	jmp    c0001eb0 <intr_exit>
/work/x86_os_my/userprog/process.c:50
}
c000525a:	90                   	nop
c000525b:	c9                   	leave  
c000525c:	c3                   	ret    

c000525d <page_dir_activate>:
page_dir_activate():
/work/x86_os_my/userprog/process.c:53

/* 更新CR3寄存器，激活页目录表 */
void page_dir_activate(struct task_struct* p_thread) {
c000525d:	55                   	push   %ebp
c000525e:	89 e5                	mov    %esp,%ebp
c0005260:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:56
	
	/* 若为"内核线程",需要重新填充页表为0x100000 */
	uint32_t pagedir_phy_addr = 0x100000;	// 默认为内核的页目录物理地址,也就是内核线程所用的页目录表
c0005263:	c7 45 f4 00 00 10 00 	movl   $0x100000,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:59
	
	/* "用户态进程"有自己的页目录表 */
	if (p_thread->pgdir != NULL) {
c000526a:	8b 45 08             	mov    0x8(%ebp),%eax
c000526d:	8b 40 34             	mov    0x34(%eax),%eax
c0005270:	85 c0                	test   %eax,%eax
c0005272:	74 15                	je     c0005289 <page_dir_activate+0x2c>
/work/x86_os_my/userprog/process.c:60
		pagedir_phy_addr = addr_v2p((uint32_t)p_thread->pgdir);
c0005274:	8b 45 08             	mov    0x8(%ebp),%eax
c0005277:	8b 40 34             	mov    0x34(%eax),%eax
c000527a:	83 ec 0c             	sub    $0xc,%esp
c000527d:	50                   	push   %eax
c000527e:	e8 cd db ff ff       	call   c0002e50 <addr_v2p>
c0005283:	83 c4 10             	add    $0x10,%esp
c0005286:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:66
	}

	/* 更新页目录寄存器cr3,使新页表生效
	 * 实现进程间，虚拟地址空间的隔离。
	 */
	asm volatile ("movl %0, %%cr3" : : "r" (pagedir_phy_addr) : "memory");
c0005289:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000528c:	0f 22 d8             	mov    %eax,%cr3
/work/x86_os_my/userprog/process.c:67
}
c000528f:	90                   	nop
c0005290:	c9                   	leave  
c0005291:	c3                   	ret    

c0005292 <process_activate>:
process_activate():
/work/x86_os_my/userprog/process.c:73

/* 1.激活线程或进程的页表,【更新CR3寄存器】
 * 2.用户进程，更新tss中的esp0为进程的特权级0的栈
 * 【只有在任务调度时（中断时），才会切换页表及更新 0 级栈，因此 process_activate 是被"中断执行流"的 schedule 调用的！】
 */
void process_activate(struct task_struct* p_thread) {
c0005292:	55                   	push   %ebp
c0005293:	89 e5                	mov    %esp,%ebp
c0005295:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/process.c:74
	ASSERT(p_thread != NULL);
c0005298:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000529c:	75 19                	jne    c00052b7 <process_activate+0x25>
/work/x86_os_my/userprog/process.c:74 (discriminator 1)
c000529e:	68 90 73 00 c0       	push   $0xc0007390
c00052a3:	68 4c 74 00 c0       	push   $0xc000744c
c00052a8:	6a 4a                	push   $0x4a
c00052aa:	68 a1 73 00 c0       	push   $0xc00073a1
c00052af:	e8 ce d2 ff ff       	call   c0002582 <panic_spin>
c00052b4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:77
	
	/* 激活该进程或线程的页目录表【重新加载了CR3】 */
	page_dir_activate(p_thread);
c00052b7:	83 ec 0c             	sub    $0xc,%esp
c00052ba:	ff 75 08             	pushl  0x8(%ebp)
c00052bd:	e8 9b ff ff ff       	call   c000525d <page_dir_activate>
c00052c2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:80

	/* 内核线程特权级本身就是0,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */
	if (p_thread->pgdir != NULL) {
c00052c5:	8b 45 08             	mov    0x8(%ebp),%eax
c00052c8:	8b 40 34             	mov    0x34(%eax),%eax
c00052cb:	85 c0                	test   %eax,%eax
c00052cd:	74 0e                	je     c00052dd <process_activate+0x4b>
/work/x86_os_my/userprog/process.c:83
		/* 若为用户进程,更新该进程的esp0,用于此进程被中断时保留上下文 
		 * 需要从tss中获取0特权级栈地址 */
		update_tss_esp(p_thread);	//就一行：g_tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c00052cf:	83 ec 0c             	sub    $0xc,%esp
c00052d2:	ff 75 08             	pushl  0x8(%ebp)
c00052d5:	e8 f2 fc ff ff       	call   c0004fcc <update_tss_esp>
c00052da:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:85
	}
}
c00052dd:	90                   	nop
c00052de:	c9                   	leave  
c00052df:	c3                   	ret    

c00052e0 <create_page_dir>:
create_page_dir():
/work/x86_os_my/userprog/process.c:94
 * 
 * 要确保用户进程，在自己的地址空间中，能够访问到内核。
 * 即：任意进程的页目录表中，用户进程占第 0~767 个页目录项，内核占第 768~1023 个页目录项。
 * 0x300 = 768
 */
uint32_t* create_page_dir(void) {
c00052e0:	55                   	push   %ebp
c00052e1:	89 e5                	mov    %esp,%ebp
c00052e3:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:97

	/* 用户进程的页表不能让用户直接访问到,所以在内核空间来申请 */
	uint32_t* page_dir_vaddr = get_kernel_pages(1);
c00052e6:	83 ec 0c             	sub    $0xc,%esp
c00052e9:	6a 01                	push   $0x1
c00052eb:	e8 3a d9 ff ff       	call   c0002c2a <get_kernel_pages>
c00052f0:	83 c4 10             	add    $0x10,%esp
c00052f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:98
	if (page_dir_vaddr == NULL) {
c00052f6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00052fa:	75 17                	jne    c0005313 <create_page_dir+0x33>
/work/x86_os_my/userprog/process.c:99
		console_put_str("create_page_dir: get_kernel_page failed!");
c00052fc:	83 ec 0c             	sub    $0xc,%esp
c00052ff:	68 b4 73 00 c0       	push   $0xc00073b4
c0005304:	e8 57 f3 ff ff       	call   c0004660 <console_put_str>
c0005309:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:100
		return NULL;
c000530c:	b8 00 00 00 00       	mov    $0x0,%eax
c0005311:	eb 43                	jmp    c0005356 <create_page_dir+0x76>
/work/x86_os_my/userprog/process.c:106
	}

	/*** 1 复制内核的页目录表  ***/
	// page_dir_vaddr + 0x300*4 是内核页目录的第768项
	// 复制的页目录项个数=1024/4
	memcpy((uint32_t*)((uint32_t)page_dir_vaddr + 0x300*4), (uint32_t*)(0xfffff000+0x300*4), 1024);
c0005313:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005316:	05 00 0c 00 00       	add    $0xc00,%eax
c000531b:	83 ec 04             	sub    $0x4,%esp
c000531e:	68 00 04 00 00       	push   $0x400
c0005323:	68 00 fc ff ff       	push   $0xfffffc00
c0005328:	50                   	push   %eax
c0005329:	e8 be e6 ff ff       	call   c00039ec <memcpy>
c000532e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:110

	/*** 2 更新页目录表地址 ***/
	// 页目录表地址是页目录的最后一项
	uint32_t new_page_dir_phy_addr = addr_v2p((uint32_t)page_dir_vaddr);
c0005331:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005334:	83 ec 0c             	sub    $0xc,%esp
c0005337:	50                   	push   %eax
c0005338:	e8 13 db ff ff       	call   c0002e50 <addr_v2p>
c000533d:	83 c4 10             	add    $0x10,%esp
c0005340:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:111
	page_dir_vaddr[1023] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1;
c0005343:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005346:	05 fc 0f 00 00       	add    $0xffc,%eax
c000534b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000534e:	83 ca 07             	or     $0x7,%edx
c0005351:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/process.c:113

	return page_dir_vaddr;
c0005353:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/userprog/process.c:114
}
c0005356:	c9                   	leave  
c0005357:	c3                   	ret    

c0005358 <create_user_vaddr_bitmap>:
create_user_vaddr_bitmap():
/work/x86_os_my/userprog/process.c:117

/* 创建用户进程虚拟地址位图 */
void create_user_vaddr_bitmap(struct task_struct* user_prog) {
c0005358:	55                   	push   %ebp
c0005359:	89 e5                	mov    %esp,%ebp
c000535b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:118
   user_prog->userprog_vaddr.vaddr_start = USER_VADDR_START;	// linux用户程序入口地址 0x80480000
c000535e:	8b 45 08             	mov    0x8(%ebp),%eax
c0005361:	c7 40 40 00 80 04 08 	movl   $0x8048000,0x40(%eax)
/work/x86_os_my/userprog/process.c:119
   uint32_t bitmap_pg_cnt = DIV_ROUND_UP((0xc0000000 - USER_VADDR_START) / PG_SIZE / 8 , PG_SIZE);
c0005368:	c7 45 f4 17 00 00 00 	movl   $0x17,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:120
   user_prog->userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt);
c000536f:	83 ec 0c             	sub    $0xc,%esp
c0005372:	ff 75 f4             	pushl  -0xc(%ebp)
c0005375:	e8 b0 d8 ff ff       	call   c0002c2a <get_kernel_pages>
c000537a:	83 c4 10             	add    $0x10,%esp
c000537d:	89 c2                	mov    %eax,%edx
c000537f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005382:	89 50 3c             	mov    %edx,0x3c(%eax)
/work/x86_os_my/userprog/process.c:121
   user_prog->userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (0xc0000000 - USER_VADDR_START) / PG_SIZE / 8;
c0005385:	8b 45 08             	mov    0x8(%ebp),%eax
c0005388:	c7 40 38 f7 6f 01 00 	movl   $0x16ff7,0x38(%eax)
/work/x86_os_my/userprog/process.c:122
   bitmap_init(&user_prog->userprog_vaddr.vaddr_bitmap);
c000538f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005392:	83 c0 38             	add    $0x38,%eax
c0005395:	83 ec 0c             	sub    $0xc,%esp
c0005398:	50                   	push   %eax
c0005399:	e8 ba d2 ff ff       	call   c0002658 <bitmap_init>
c000539e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:123
}
c00053a1:	90                   	nop
c00053a2:	c9                   	leave  
c00053a3:	c3                   	ret    

c00053a4 <process_execute>:
process_execute():
/work/x86_os_my/userprog/process.c:126

/* 创建用户进程 */
void process_execute(void* filename, char* name) {
c00053a4:	55                   	push   %ebp
c00053a5:	89 e5                	mov    %esp,%ebp
c00053a7:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:128
   /* pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 */
   struct task_struct* thread = get_kernel_pages(1);
c00053aa:	83 ec 0c             	sub    $0xc,%esp
c00053ad:	6a 01                	push   $0x1
c00053af:	e8 76 d8 ff ff       	call   c0002c2a <get_kernel_pages>
c00053b4:	83 c4 10             	add    $0x10,%esp
c00053b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:129
   init_thread(thread, name, default_prio);			//初始化线程PCB结构体 struct task_struct
c00053ba:	83 ec 04             	sub    $0x4,%esp
c00053bd:	6a 1f                	push   $0x1f
c00053bf:	ff 75 0c             	pushl  0xc(%ebp)
c00053c2:	ff 75 f4             	pushl  -0xc(%ebp)
c00053c5:	e8 9e ea ff ff       	call   c0003e68 <init_thread>
c00053ca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:130
   create_user_vaddr_bitmap(thread);				//【进程新增】创建用户进程，虚拟地址空间位图
c00053cd:	83 ec 0c             	sub    $0xc,%esp
c00053d0:	ff 75 f4             	pushl  -0xc(%ebp)
c00053d3:	e8 80 ff ff ff       	call   c0005358 <create_user_vaddr_bitmap>
c00053d8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:131
   thread_create(thread, start_process, filename);	//初始化线程栈结构体 struct thread_stack
c00053db:	83 ec 04             	sub    $0x4,%esp
c00053de:	ff 75 08             	pushl  0x8(%ebp)
c00053e1:	68 58 51 00 c0       	push   $0xc0005158
c00053e6:	ff 75 f4             	pushl  -0xc(%ebp)
c00053e9:	e8 03 ea ff ff       	call   c0003df1 <thread_create>
c00053ee:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:132
   thread->pgdir = create_page_dir();				//【进程新增】创建用户进程，页目录表
c00053f1:	e8 ea fe ff ff       	call   c00052e0 <create_page_dir>
c00053f6:	89 c2                	mov    %eax,%edx
c00053f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00053fb:	89 50 34             	mov    %edx,0x34(%eax)
/work/x86_os_my/userprog/process.c:133
   block_desc_init(thread->u_block_desc);
c00053fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005401:	83 c0 44             	add    $0x44,%eax
c0005404:	83 ec 0c             	sub    $0xc,%esp
c0005407:	50                   	push   %eax
c0005408:	e8 a9 e4 ff ff       	call   c00038b6 <block_desc_init>
c000540d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:135
   
   enum intr_status old_status = intr_disable();
c0005410:	e8 d3 c7 ff ff       	call   c0001be8 <intr_disable>
c0005415:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:136
   ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));
c0005418:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000541b:	83 c0 24             	add    $0x24,%eax
c000541e:	83 ec 08             	sub    $0x8,%esp
c0005421:	50                   	push   %eax
c0005422:	68 8c 9b 00 c0       	push   $0xc0009b8c
c0005427:	e8 eb f0 ff ff       	call   c0004517 <elem_find>
c000542c:	83 c4 10             	add    $0x10,%esp
c000542f:	85 c0                	test   %eax,%eax
c0005431:	74 1c                	je     c000544f <process_execute+0xab>
/work/x86_os_my/userprog/process.c:136 (discriminator 1)
c0005433:	68 e0 73 00 c0       	push   $0xc00073e0
c0005438:	68 60 74 00 c0       	push   $0xc0007460
c000543d:	68 88 00 00 00       	push   $0x88
c0005442:	68 a1 73 00 c0       	push   $0xc00073a1
c0005447:	e8 36 d1 ff ff       	call   c0002582 <panic_spin>
c000544c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:137
   list_append(&thread_ready_list, &thread->general_tag);
c000544f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005452:	83 c0 24             	add    $0x24,%eax
c0005455:	83 ec 08             	sub    $0x8,%esp
c0005458:	50                   	push   %eax
c0005459:	68 8c 9b 00 c0       	push   $0xc0009b8c
c000545e:	e8 3a f0 ff ff       	call   c000449d <list_append>
c0005463:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:138
   ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
c0005466:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005469:	83 c0 2c             	add    $0x2c,%eax
c000546c:	83 ec 08             	sub    $0x8,%esp
c000546f:	50                   	push   %eax
c0005470:	68 9c 9b 00 c0       	push   $0xc0009b9c
c0005475:	e8 9d f0 ff ff       	call   c0004517 <elem_find>
c000547a:	83 c4 10             	add    $0x10,%esp
c000547d:	85 c0                	test   %eax,%eax
c000547f:	74 1c                	je     c000549d <process_execute+0xf9>
/work/x86_os_my/userprog/process.c:138 (discriminator 1)
c0005481:	68 18 74 00 c0       	push   $0xc0007418
c0005486:	68 60 74 00 c0       	push   $0xc0007460
c000548b:	68 8a 00 00 00       	push   $0x8a
c0005490:	68 a1 73 00 c0       	push   $0xc00073a1
c0005495:	e8 e8 d0 ff ff       	call   c0002582 <panic_spin>
c000549a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:139
   list_append(&thread_all_list, &thread->all_list_tag);
c000549d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00054a0:	83 c0 2c             	add    $0x2c,%eax
c00054a3:	83 ec 08             	sub    $0x8,%esp
c00054a6:	50                   	push   %eax
c00054a7:	68 9c 9b 00 c0       	push   $0xc0009b9c
c00054ac:	e8 ec ef ff ff       	call   c000449d <list_append>
c00054b1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:140
   intr_set_status(old_status);
c00054b4:	83 ec 0c             	sub    $0xc,%esp
c00054b7:	ff 75 f0             	pushl  -0x10(%ebp)
c00054ba:	e8 52 c7 ff ff       	call   c0001c11 <intr_set_status>
c00054bf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:141
}
c00054c2:	90                   	nop
c00054c3:	c9                   	leave  
c00054c4:	c3                   	ret    

c00054c5 <getpid>:
getpid():
/work/x86_os_my/lib/user/syscall.c:52
   );							       \
   retval;						       \
})

/* 返回当前任务pid */
uint32_t getpid() {
c00054c5:	55                   	push   %ebp
c00054c6:	89 e5                	mov    %esp,%ebp
c00054c8:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:53
   return _syscall0(SYS_GETPID);
c00054cb:	b8 00 00 00 00       	mov    $0x0,%eax
c00054d0:	cd 80                	int    $0x80
c00054d2:	89 45 fc             	mov    %eax,-0x4(%ebp)
c00054d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:54
}
c00054d8:	c9                   	leave  
c00054d9:	c3                   	ret    

c00054da <write>:
write():
/work/x86_os_my/lib/user/syscall.c:57

/* 打印字符串str */
uint32_t write(char* str) {
c00054da:	55                   	push   %ebp
c00054db:	89 e5                	mov    %esp,%ebp
c00054dd:	53                   	push   %ebx
c00054de:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:58
	return _syscall1(SYS_WRITE, str);
c00054e1:	b8 01 00 00 00       	mov    $0x1,%eax
c00054e6:	8b 55 08             	mov    0x8(%ebp),%edx
c00054e9:	89 d3                	mov    %edx,%ebx
c00054eb:	cd 80                	int    $0x80
c00054ed:	89 45 f8             	mov    %eax,-0x8(%ebp)
c00054f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:59
}
c00054f3:	83 c4 10             	add    $0x10,%esp
c00054f6:	5b                   	pop    %ebx
c00054f7:	5d                   	pop    %ebp
c00054f8:	c3                   	ret    

c00054f9 <malloc>:
malloc():
/work/x86_os_my/lib/user/syscall.c:62

/* 申请size字节大小的内存,并返回结果 */
void* malloc(uint32_t size) {
c00054f9:	55                   	push   %ebp
c00054fa:	89 e5                	mov    %esp,%ebp
c00054fc:	53                   	push   %ebx
c00054fd:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:63
	return (void*)_syscall1(SYS_MALLOC, size);
c0005500:	b8 02 00 00 00       	mov    $0x2,%eax
c0005505:	8b 55 08             	mov    0x8(%ebp),%edx
c0005508:	89 d3                	mov    %edx,%ebx
c000550a:	cd 80                	int    $0x80
c000550c:	89 45 f8             	mov    %eax,-0x8(%ebp)
c000550f:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:64
}
c0005512:	83 c4 10             	add    $0x10,%esp
c0005515:	5b                   	pop    %ebx
c0005516:	5d                   	pop    %ebp
c0005517:	c3                   	ret    

c0005518 <free>:
free():
/work/x86_os_my/lib/user/syscall.c:67

/* 释放ptr指向的内存 */
void free(void* ptr) {
c0005518:	55                   	push   %ebp
c0005519:	89 e5                	mov    %esp,%ebp
c000551b:	53                   	push   %ebx
c000551c:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:68
	_syscall1(SYS_FREE, ptr);
c000551f:	b8 03 00 00 00       	mov    $0x3,%eax
c0005524:	8b 55 08             	mov    0x8(%ebp),%edx
c0005527:	89 d3                	mov    %edx,%ebx
c0005529:	cd 80                	int    $0x80
c000552b:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/lib/user/syscall.c:69
}
c000552e:	90                   	nop
c000552f:	83 c4 10             	add    $0x10,%esp
c0005532:	5b                   	pop    %ebx
c0005533:	5d                   	pop    %ebp
c0005534:	c3                   	ret    

c0005535 <sys_getpid>:
sys_getpid():
/work/x86_os_my/userprog/syscall-init.c:15
#define syscall_nr 32 
typedef void* syscall;
syscall syscall_table[syscall_nr];

/* 返回当前任务的pid */
uint32_t sys_getpid(void) {
c0005535:	55                   	push   %ebp
c0005536:	89 e5                	mov    %esp,%ebp
c0005538:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/syscall-init.c:16
	return running_thread()->pid;
c000553b:	e8 41 e8 ff ff       	call   c0003d81 <running_thread>
c0005540:	0f b7 40 04          	movzwl 0x4(%eax),%eax
c0005544:	98                   	cwtl   
/work/x86_os_my/userprog/syscall-init.c:17
}
c0005545:	c9                   	leave  
c0005546:	c3                   	ret    

c0005547 <sys_write>:
sys_write():
/work/x86_os_my/userprog/syscall-init.c:20

/* 打印字符串str(未实现文件系统前的版本) */
uint32_t sys_write(char* str) {
c0005547:	55                   	push   %ebp
c0005548:	89 e5                	mov    %esp,%ebp
c000554a:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/syscall-init.c:21
	console_put_str(str);
c000554d:	83 ec 0c             	sub    $0xc,%esp
c0005550:	ff 75 08             	pushl  0x8(%ebp)
c0005553:	e8 08 f1 ff ff       	call   c0004660 <console_put_str>
c0005558:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:22
	return strlen(str);
c000555b:	83 ec 0c             	sub    $0xc,%esp
c000555e:	ff 75 08             	pushl  0x8(%ebp)
c0005561:	e8 be e5 ff ff       	call   c0003b24 <strlen>
c0005566:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:23
}
c0005569:	c9                   	leave  
c000556a:	c3                   	ret    

c000556b <syscall_init>:
syscall_init():
/work/x86_os_my/userprog/syscall-init.c:26

/* 初始化系统调用 */
void syscall_init(void) {
c000556b:	55                   	push   %ebp
c000556c:	89 e5                	mov    %esp,%ebp
c000556e:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/syscall-init.c:27
	put_str("syscall_init start\n");
c0005571:	83 ec 0c             	sub    $0xc,%esp
c0005574:	68 70 74 00 c0       	push   $0xc0007470
c0005579:	e8 92 ce ff ff       	call   c0002410 <put_str>
c000557e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:28
	syscall_table[SYS_GETPID] = sys_getpid;
c0005581:	c7 05 60 9c 00 c0 35 	movl   $0xc0005535,0xc0009c60
c0005588:	55 00 c0 
/work/x86_os_my/userprog/syscall-init.c:29
	syscall_table[SYS_WRITE] = sys_write;
c000558b:	c7 05 64 9c 00 c0 47 	movl   $0xc0005547,0xc0009c64
c0005592:	55 00 c0 
/work/x86_os_my/userprog/syscall-init.c:30
	syscall_table[SYS_MALLOC] = sys_malloc;
c0005595:	c7 05 68 9c 00 c0 a3 	movl   $0xc0002ea3,0xc0009c68
c000559c:	2e 00 c0 
/work/x86_os_my/userprog/syscall-init.c:31
	syscall_table[SYS_FREE] = sys_free;
c000559f:	c7 05 6c 9c 00 c0 d0 	movl   $0xc00034d0,0xc0009c6c
c00055a6:	34 00 c0 
/work/x86_os_my/userprog/syscall-init.c:32
	put_str("syscall_init done\n");
c00055a9:	83 ec 0c             	sub    $0xc,%esp
c00055ac:	68 84 74 00 c0       	push   $0xc0007484
c00055b1:	e8 5a ce ff ff       	call   c0002410 <put_str>
c00055b6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:33
}
c00055b9:	90                   	nop
c00055ba:	c9                   	leave  
c00055bb:	c3                   	ret    

c00055bc <itoa>:
itoa():
/work/x86_os_my/lib/stdio.c:13
#define va_start(ap, v) ap = (va_list)&v	// 把ap指向第一个固定参数v
#define va_arg(ap, t) *((t*)(ap += 4))		// ap指向下一个参数并返回其值
#define va_end(ap) ap = NULL				// 清除ap

/* 将整型转换成字符(integer to ascii) */
static void itoa(uint32_t value, char** buf_ptr_addr, uint8_t base) {
c00055bc:	55                   	push   %ebp
c00055bd:	89 e5                	mov    %esp,%ebp
c00055bf:	83 ec 28             	sub    $0x28,%esp
c00055c2:	8b 45 10             	mov    0x10(%ebp),%eax
c00055c5:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/stdio.c:14
	uint32_t m = value % base;	// 求模,最先掉下来的是最低位【比如base是16代表16进制】 
c00055c8:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c00055cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00055cf:	ba 00 00 00 00       	mov    $0x0,%edx
c00055d4:	f7 f1                	div    %ecx
c00055d6:	89 55 f4             	mov    %edx,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:15
	uint32_t i = value / base;	// 取整
c00055d9:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c00055dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00055e0:	ba 00 00 00 00       	mov    $0x0,%edx
c00055e5:	f7 f1                	div    %ecx
c00055e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/stdio.c:16
	if (i) {
c00055ea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00055ee:	74 16                	je     c0005606 <itoa+0x4a>
/work/x86_os_my/lib/stdio.c:17
		itoa(i, buf_ptr_addr, base);	// 如果倍数不为0则递归调用。
c00055f0:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c00055f4:	83 ec 04             	sub    $0x4,%esp
c00055f7:	50                   	push   %eax
c00055f8:	ff 75 0c             	pushl  0xc(%ebp)
c00055fb:	ff 75 f0             	pushl  -0x10(%ebp)
c00055fe:	e8 b9 ff ff ff       	call   c00055bc <itoa>
c0005603:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:19
	}
	if (m < 10) {	// 如果余数是0~9
c0005606:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c000560a:	77 17                	ja     c0005623 <itoa+0x67>
/work/x86_os_my/lib/stdio.c:20
		*((*buf_ptr_addr)++) = m + '0';			// 将数字0~9转换为字符'0'~'9'
c000560c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000560f:	8b 00                	mov    (%eax),%eax
c0005611:	8d 48 01             	lea    0x1(%eax),%ecx
c0005614:	8b 55 0c             	mov    0xc(%ebp),%edx
c0005617:	89 0a                	mov    %ecx,(%edx)
c0005619:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000561c:	83 c2 30             	add    $0x30,%edx
c000561f:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:24
	} else {		// 否则余数是A~F
		*((*buf_ptr_addr)++) = m - 10 + 'A';	// 将数字A~F转换为字符'A'~'F'
	}
}
c0005621:	eb 15                	jmp    c0005638 <itoa+0x7c>
/work/x86_os_my/lib/stdio.c:22
		itoa(i, buf_ptr_addr, base);	// 如果倍数不为0则递归调用。
	}
	if (m < 10) {	// 如果余数是0~9
		*((*buf_ptr_addr)++) = m + '0';			// 将数字0~9转换为字符'0'~'9'
	} else {		// 否则余数是A~F
		*((*buf_ptr_addr)++) = m - 10 + 'A';	// 将数字A~F转换为字符'A'~'F'
c0005623:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005626:	8b 00                	mov    (%eax),%eax
c0005628:	8d 48 01             	lea    0x1(%eax),%ecx
c000562b:	8b 55 0c             	mov    0xc(%ebp),%edx
c000562e:	89 0a                	mov    %ecx,(%edx)
c0005630:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0005633:	83 c2 37             	add    $0x37,%edx
c0005636:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:24
	}
}
c0005638:	90                   	nop
c0005639:	c9                   	leave  
c000563a:	c3                   	ret    

c000563b <vsprintf>:
vsprintf():
/work/x86_os_my/lib/stdio.c:27

/* 将参数ap按照格式format输出到字符串str,并返回替换后str长度 */
uint32_t vsprintf(char* str, const char* format, va_list ap) {
c000563b:	55                   	push   %ebp
c000563c:	89 e5                	mov    %esp,%ebp
c000563e:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/lib/stdio.c:28
	char* buf_ptr = str;
c0005641:	8b 45 08             	mov    0x8(%ebp),%eax
c0005644:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/stdio.c:29
	const char* index_ptr = format;
c0005647:	8b 45 0c             	mov    0xc(%ebp),%eax
c000564a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:30
	char index_char = *index_ptr;
c000564d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005650:	0f b6 00             	movzbl (%eax),%eax
c0005653:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:33
	int32_t arg_int;
	char* arg_str;
	while(index_char) {
c0005656:	e9 43 01 00 00       	jmp    c000579e <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:34
		if (index_char != '%') {
c000565b:	80 7d f3 25          	cmpb   $0x25,-0xd(%ebp)
c000565f:	74 21                	je     c0005682 <vsprintf+0x47>
/work/x86_os_my/lib/stdio.c:35
			*(buf_ptr++) = index_char;
c0005661:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0005664:	8d 50 01             	lea    0x1(%eax),%edx
c0005667:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c000566a:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
c000566e:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:36
			index_char = *(++index_ptr);
c0005670:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0005674:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005677:	0f b6 00             	movzbl (%eax),%eax
c000567a:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:37
			continue;
c000567d:	e9 1c 01 00 00       	jmp    c000579e <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:39
		}
		index_char = *(++index_ptr);	 // 得到%后面的字符
c0005682:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0005686:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005689:	0f b6 00             	movzbl (%eax),%eax
c000568c:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:40
		switch(index_char) {
c000568f:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
c0005693:	83 f8 64             	cmp    $0x64,%eax
c0005696:	0f 84 8e 00 00 00    	je     c000572a <vsprintf+0xef>
c000569c:	83 f8 64             	cmp    $0x64,%eax
c000569f:	7f 0a                	jg     c00056ab <vsprintf+0x70>
c00056a1:	83 f8 63             	cmp    $0x63,%eax
c00056a4:	74 60                	je     c0005706 <vsprintf+0xcb>
c00056a6:	e9 f3 00 00 00       	jmp    c000579e <vsprintf+0x163>
c00056ab:	83 f8 73             	cmp    $0x73,%eax
c00056ae:	74 0e                	je     c00056be <vsprintf+0x83>
c00056b0:	83 f8 78             	cmp    $0x78,%eax
c00056b3:	0f 84 b6 00 00 00    	je     c000576f <vsprintf+0x134>
c00056b9:	e9 e0 00 00 00       	jmp    c000579e <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:42
			case 's':
			arg_str = va_arg(ap, char*);
c00056be:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c00056c2:	8b 45 10             	mov    0x10(%ebp),%eax
c00056c5:	8b 00                	mov    (%eax),%eax
c00056c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/lib/stdio.c:43
			strcpy(buf_ptr, arg_str);
c00056ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00056cd:	83 ec 08             	sub    $0x8,%esp
c00056d0:	ff 75 e8             	pushl  -0x18(%ebp)
c00056d3:	50                   	push   %eax
c00056d4:	e8 f6 e3 ff ff       	call   c0003acf <strcpy>
c00056d9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:44
			buf_ptr += strlen(arg_str);
c00056dc:	83 ec 0c             	sub    $0xc,%esp
c00056df:	ff 75 e8             	pushl  -0x18(%ebp)
c00056e2:	e8 3d e4 ff ff       	call   c0003b24 <strlen>
c00056e7:	83 c4 10             	add    $0x10,%esp
c00056ea:	89 c2                	mov    %eax,%edx
c00056ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00056ef:	01 d0                	add    %edx,%eax
c00056f1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/stdio.c:45
			index_char = *(++index_ptr);
c00056f4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00056f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00056fb:	0f b6 00             	movzbl (%eax),%eax
c00056fe:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:46
			break;
c0005701:	e9 98 00 00 00       	jmp    c000579e <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:49

			case 'c':
			*(buf_ptr++) = va_arg(ap, char);
c0005706:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0005709:	8d 50 01             	lea    0x1(%eax),%edx
c000570c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c000570f:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c0005713:	8b 55 10             	mov    0x10(%ebp),%edx
c0005716:	0f b6 12             	movzbl (%edx),%edx
c0005719:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:50
			index_char = *(++index_ptr);
c000571b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c000571f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005722:	0f b6 00             	movzbl (%eax),%eax
c0005725:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:51
			break;
c0005728:	eb 74                	jmp    c000579e <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:54

			case 'd':
			arg_int = va_arg(ap, int);
c000572a:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c000572e:	8b 45 10             	mov    0x10(%ebp),%eax
c0005731:	8b 00                	mov    (%eax),%eax
c0005733:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/stdio.c:56
			/* 若是负数, 将其转为正数后,再正数前面输出个负号'-'. */
			if (arg_int < 0) {
c0005736:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c000573a:	79 0f                	jns    c000574b <vsprintf+0x110>
/work/x86_os_my/lib/stdio.c:57
				arg_int = 0 - arg_int;
c000573c:	f7 5d ec             	negl   -0x14(%ebp)
/work/x86_os_my/lib/stdio.c:58
				*buf_ptr++ = '-';
c000573f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0005742:	8d 50 01             	lea    0x1(%eax),%edx
c0005745:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0005748:	c6 00 2d             	movb   $0x2d,(%eax)
/work/x86_os_my/lib/stdio.c:60
			}
			itoa(arg_int, &buf_ptr, 10); 
c000574b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000574e:	83 ec 04             	sub    $0x4,%esp
c0005751:	6a 0a                	push   $0xa
c0005753:	8d 55 e4             	lea    -0x1c(%ebp),%edx
c0005756:	52                   	push   %edx
c0005757:	50                   	push   %eax
c0005758:	e8 5f fe ff ff       	call   c00055bc <itoa>
c000575d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:61
			index_char = *(++index_ptr);
c0005760:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0005764:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005767:	0f b6 00             	movzbl (%eax),%eax
c000576a:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:62
			break;
c000576d:	eb 2f                	jmp    c000579e <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:65

			case 'x':
			arg_int = va_arg(ap, int);
c000576f:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c0005773:	8b 45 10             	mov    0x10(%ebp),%eax
c0005776:	8b 00                	mov    (%eax),%eax
c0005778:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/stdio.c:66
			itoa(arg_int, &buf_ptr, 16); 
c000577b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000577e:	83 ec 04             	sub    $0x4,%esp
c0005781:	6a 10                	push   $0x10
c0005783:	8d 55 e4             	lea    -0x1c(%ebp),%edx
c0005786:	52                   	push   %edx
c0005787:	50                   	push   %eax
c0005788:	e8 2f fe ff ff       	call   c00055bc <itoa>
c000578d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:67
			index_char = *(++index_ptr); // 跳过格式字符并更新index_char
c0005790:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0005794:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005797:	0f b6 00             	movzbl (%eax),%eax
c000579a:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:68
			break;
c000579d:	90                   	nop
/work/x86_os_my/lib/stdio.c:33
	char* buf_ptr = str;
	const char* index_ptr = format;
	char index_char = *index_ptr;
	int32_t arg_int;
	char* arg_str;
	while(index_char) {
c000579e:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c00057a2:	0f 85 b3 fe ff ff    	jne    c000565b <vsprintf+0x20>
/work/x86_os_my/lib/stdio.c:71
			itoa(arg_int, &buf_ptr, 16); 
			index_char = *(++index_ptr); // 跳过格式字符并更新index_char
			break;
		}
	}
	return strlen(str);
c00057a8:	83 ec 0c             	sub    $0xc,%esp
c00057ab:	ff 75 08             	pushl  0x8(%ebp)
c00057ae:	e8 71 e3 ff ff       	call   c0003b24 <strlen>
c00057b3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:72
}
c00057b6:	c9                   	leave  
c00057b7:	c3                   	ret    

c00057b8 <sprintf>:
sprintf():
/work/x86_os_my/lib/stdio.c:75

/* 同printf不同的地方就是字符串不是写到终端,而是写到buf中 */
uint32_t sprintf(char* buf, const char* format, ...) {
c00057b8:	55                   	push   %ebp
c00057b9:	89 e5                	mov    %esp,%ebp
c00057bb:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/stdio.c:78
	va_list args;
	uint32_t retval;
	va_start(args, format);
c00057be:	8d 45 0c             	lea    0xc(%ebp),%eax
c00057c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:79
	retval = vsprintf(buf, format, args);
c00057c4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00057c7:	83 ec 04             	sub    $0x4,%esp
c00057ca:	ff 75 f4             	pushl  -0xc(%ebp)
c00057cd:	50                   	push   %eax
c00057ce:	ff 75 08             	pushl  0x8(%ebp)
c00057d1:	e8 65 fe ff ff       	call   c000563b <vsprintf>
c00057d6:	83 c4 10             	add    $0x10,%esp
c00057d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/stdio.c:80
	va_end(args);
c00057dc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:81
	return retval;
c00057e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/lib/stdio.c:82
}
c00057e6:	c9                   	leave  
c00057e7:	c3                   	ret    

c00057e8 <printf>:
printf():
/work/x86_os_my/lib/stdio.c:85

/* 格式化输出字符串format */
uint32_t printf(const char* format, ...) {
c00057e8:	55                   	push   %ebp
c00057e9:	89 e5                	mov    %esp,%ebp
c00057eb:	57                   	push   %edi
c00057ec:	81 ec 14 04 00 00    	sub    $0x414,%esp
/work/x86_os_my/lib/stdio.c:87
	va_list args;
	va_start(args, format);	       // 使args指向format
c00057f2:	8d 45 08             	lea    0x8(%ebp),%eax
c00057f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:88
	char buf[1024] = {0};	       // 用于存储拼接后的字符串
c00057f8:	8d 95 f4 fb ff ff    	lea    -0x40c(%ebp),%edx
c00057fe:	b8 00 00 00 00       	mov    $0x0,%eax
c0005803:	b9 00 01 00 00       	mov    $0x100,%ecx
c0005808:	89 d7                	mov    %edx,%edi
c000580a:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/lib/stdio.c:89
	vsprintf(buf, format, args);
c000580c:	8b 45 08             	mov    0x8(%ebp),%eax
c000580f:	83 ec 04             	sub    $0x4,%esp
c0005812:	ff 75 f4             	pushl  -0xc(%ebp)
c0005815:	50                   	push   %eax
c0005816:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c000581c:	50                   	push   %eax
c000581d:	e8 19 fe ff ff       	call   c000563b <vsprintf>
c0005822:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:90
	va_end(args);
c0005825:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:91
	return write(buf);
c000582c:	83 ec 0c             	sub    $0xc,%esp
c000582f:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c0005835:	50                   	push   %eax
c0005836:	e8 9f fc ff ff       	call   c00054da <write>
c000583b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:92
}
c000583e:	8b 7d fc             	mov    -0x4(%ebp),%edi
c0005841:	c9                   	leave  
c0005842:	c3                   	ret    

c0005843 <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c0005843:	55                   	push   %ebp
c0005844:	89 e5                	mov    %esp,%ebp
c0005846:	83 ec 08             	sub    $0x8,%esp
c0005849:	8b 55 08             	mov    0x8(%ebp),%edx
c000584c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000584f:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0005853:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c0005856:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c000585a:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c000585e:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c000585f:	90                   	nop
c0005860:	c9                   	leave  
c0005861:	c3                   	ret    

c0005862 <outsw>:
outsw():
/work/x86_os_my/lib/kernel/io.h:26

/* 将addr处起始的word_cnt个字写入端口port */
static inline void outsw(uint16_t port, const void* addr, uint32_t word_cnt) {
c0005862:	55                   	push   %ebp
c0005863:	89 e5                	mov    %esp,%ebp
c0005865:	56                   	push   %esi
c0005866:	53                   	push   %ebx
c0005867:	83 ec 04             	sub    $0x4,%esp
c000586a:	8b 45 08             	mov    0x8(%ebp),%eax
c000586d:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/io.h:31
/*********************************************************
   +表示此限制即做输入又做输出.
   outsw是把ds:esi处的16位的内容写入port端口, 我们在设置段描述符时, 
   已经将ds,es,ss段的选择子都设置为相同的值了,此时不用担心数据错乱。*/
   asm volatile ("cld; rep outsw" : "+S" (addr), "+c" (word_cnt) : "d" (port));
c0005871:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c0005875:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0005878:	8b 45 10             	mov    0x10(%ebp),%eax
c000587b:	89 cb                	mov    %ecx,%ebx
c000587d:	89 de                	mov    %ebx,%esi
c000587f:	89 c1                	mov    %eax,%ecx
c0005881:	fc                   	cld    
c0005882:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
c0005885:	89 c8                	mov    %ecx,%eax
c0005887:	89 f3                	mov    %esi,%ebx
c0005889:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c000588c:	89 45 10             	mov    %eax,0x10(%ebp)
/work/x86_os_my/lib/kernel/io.h:33
/******************************************************/
}
c000588f:	90                   	nop
c0005890:	83 c4 04             	add    $0x4,%esp
c0005893:	5b                   	pop    %ebx
c0005894:	5e                   	pop    %esi
c0005895:	5d                   	pop    %ebp
c0005896:	c3                   	ret    

c0005897 <inb>:
inb():
/work/x86_os_my/lib/kernel/io.h:36

/* 将从端口port读入的一个字节返回 */
static inline uint8_t inb(uint16_t port) {
c0005897:	55                   	push   %ebp
c0005898:	89 e5                	mov    %esp,%ebp
c000589a:	83 ec 14             	sub    $0x14,%esp
c000589d:	8b 45 08             	mov    0x8(%ebp),%eax
c00058a0:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/io.h:38
   uint8_t data;
   asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00058a4:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c00058a8:	89 c2                	mov    %eax,%edx
c00058aa:	ec                   	in     (%dx),%al
c00058ab:	88 45 ff             	mov    %al,-0x1(%ebp)
/work/x86_os_my/lib/kernel/io.h:39
   return data;
c00058ae:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
/work/x86_os_my/lib/kernel/io.h:40
}
c00058b2:	c9                   	leave  
c00058b3:	c3                   	ret    

c00058b4 <insw>:
insw():
/work/x86_os_my/lib/kernel/io.h:43

/* 将从端口port读入的word_cnt个字写入addr */
static inline void insw(uint16_t port, void* addr, uint32_t word_cnt) {
c00058b4:	55                   	push   %ebp
c00058b5:	89 e5                	mov    %esp,%ebp
c00058b7:	57                   	push   %edi
c00058b8:	53                   	push   %ebx
c00058b9:	83 ec 04             	sub    $0x4,%esp
c00058bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00058bf:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/io.h:48
/******************************************************
   insw是将从端口port处读入的16位内容写入es:edi指向的内存,
   我们在设置段描述符时, 已经将ds,es,ss段的选择子都设置为相同的值了,
   此时不用担心数据错乱。*/
   asm volatile ("cld; rep insw" : "+D" (addr), "+c" (word_cnt) : "d" (port) : "memory");
c00058c3:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c00058c7:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c00058ca:	8b 45 10             	mov    0x10(%ebp),%eax
c00058cd:	89 cb                	mov    %ecx,%ebx
c00058cf:	89 df                	mov    %ebx,%edi
c00058d1:	89 c1                	mov    %eax,%ecx
c00058d3:	fc                   	cld    
c00058d4:	66 f3 6d             	rep insw (%dx),%es:(%edi)
c00058d7:	89 c8                	mov    %ecx,%eax
c00058d9:	89 fb                	mov    %edi,%ebx
c00058db:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c00058de:	89 45 10             	mov    %eax,0x10(%ebp)
/work/x86_os_my/lib/kernel/io.h:50
/******************************************************/
}
c00058e1:	90                   	nop
c00058e2:	83 c4 04             	add    $0x4,%esp
c00058e5:	5b                   	pop    %ebx
c00058e6:	5f                   	pop    %edi
c00058e7:	5d                   	pop    %ebp
c00058e8:	c3                   	ret    

c00058e9 <select_disk>:
select_disk():
/work/x86_os_my/device/ide.c:78
} __attribute__ ((packed));


/////////////////////////////////////// ide驱动部分 ////////////////////////////////////////////////
/* 选择读写的硬盘 */
static void select_disk(struct disk* hd) {
c00058e9:	55                   	push   %ebp
c00058ea:	89 e5                	mov    %esp,%ebp
c00058ec:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/device/ide.c:79
	uint8_t reg_device = BIT_DEV_MBS | BIT_DEV_LBA;
c00058ef:	c6 45 ff e0          	movb   $0xe0,-0x1(%ebp)
/work/x86_os_my/device/ide.c:80
	if (hd->dev_no == 1) {	// 若是从盘就置DEV位为1
c00058f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00058f6:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
c00058fa:	3c 01                	cmp    $0x1,%al
c00058fc:	75 04                	jne    c0005902 <select_disk+0x19>
/work/x86_os_my/device/ide.c:81
		reg_device |= BIT_DEV_DEV;
c00058fe:	80 4d ff 10          	orb    $0x10,-0x1(%ebp)
/work/x86_os_my/device/ide.c:83
	}
	outb(reg_dev(hd->my_channel), reg_device);
c0005902:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c0005906:	8b 45 08             	mov    0x8(%ebp),%eax
c0005909:	8b 40 08             	mov    0x8(%eax),%eax
c000590c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005910:	83 c0 06             	add    $0x6,%eax
c0005913:	0f b7 c0             	movzwl %ax,%eax
c0005916:	52                   	push   %edx
c0005917:	50                   	push   %eax
c0005918:	e8 26 ff ff ff       	call   c0005843 <outb>
c000591d:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/ide.c:84
}
c0005920:	90                   	nop
c0005921:	c9                   	leave  
c0005922:	c3                   	ret    

c0005923 <select_sector>:
select_sector():
/work/x86_os_my/device/ide.c:87

/* 向硬盘控制器写入起始扇区地址及要读写的扇区数 */
static void select_sector(struct disk* hd, uint32_t lba, uint8_t sec_cnt) {
c0005923:	55                   	push   %ebp
c0005924:	89 e5                	mov    %esp,%ebp
c0005926:	83 ec 28             	sub    $0x28,%esp
c0005929:	8b 45 10             	mov    0x10(%ebp),%eax
c000592c:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/device/ide.c:88
	ASSERT(lba <= max_lba);
c000592f:	81 7d 0c ff 7f 02 00 	cmpl   $0x27fff,0xc(%ebp)
c0005936:	76 19                	jbe    c0005951 <select_sector+0x2e>
/work/x86_os_my/device/ide.c:88 (discriminator 1)
c0005938:	68 98 74 00 c0       	push   $0xc0007498
c000593d:	68 14 76 00 c0       	push   $0xc0007614
c0005942:	6a 58                	push   $0x58
c0005944:	68 a7 74 00 c0       	push   $0xc00074a7
c0005949:	e8 34 cc ff ff       	call   c0002582 <panic_spin>
c000594e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:89
	struct ide_channel* channel = hd->my_channel;
c0005951:	8b 45 08             	mov    0x8(%ebp),%eax
c0005954:	8b 40 08             	mov    0x8(%eax),%eax
c0005957:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:92

	/* 写入要读写的扇区数*/
	outb(reg_sect_cnt(channel), sec_cnt);	// 如果sec_cnt为0,则表示写入256个扇区
c000595a:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c000595e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005961:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005965:	83 c0 02             	add    $0x2,%eax
c0005968:	0f b7 c0             	movzwl %ax,%eax
c000596b:	83 ec 08             	sub    $0x8,%esp
c000596e:	52                   	push   %edx
c000596f:	50                   	push   %eax
c0005970:	e8 ce fe ff ff       	call   c0005843 <outb>
c0005975:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:95

	/* 写入lba地址(即扇区号) */
	outb(reg_lba_l(channel), lba);			// lba地址的低8位,不用单独取出低8位.outb函数中的汇编指令outb %b0, %w1会只用al。
c0005978:	8b 45 0c             	mov    0xc(%ebp),%eax
c000597b:	0f b6 d0             	movzbl %al,%edx
c000597e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005981:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005985:	83 c0 03             	add    $0x3,%eax
c0005988:	0f b7 c0             	movzwl %ax,%eax
c000598b:	83 ec 08             	sub    $0x8,%esp
c000598e:	52                   	push   %edx
c000598f:	50                   	push   %eax
c0005990:	e8 ae fe ff ff       	call   c0005843 <outb>
c0005995:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:96
	outb(reg_lba_m(channel), lba >> 8);		// lba地址的8~15位
c0005998:	8b 45 0c             	mov    0xc(%ebp),%eax
c000599b:	c1 e8 08             	shr    $0x8,%eax
c000599e:	0f b6 d0             	movzbl %al,%edx
c00059a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00059a4:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00059a8:	83 c0 04             	add    $0x4,%eax
c00059ab:	0f b7 c0             	movzwl %ax,%eax
c00059ae:	83 ec 08             	sub    $0x8,%esp
c00059b1:	52                   	push   %edx
c00059b2:	50                   	push   %eax
c00059b3:	e8 8b fe ff ff       	call   c0005843 <outb>
c00059b8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:97
	outb(reg_lba_h(channel), lba >> 16);	// lba地址的16~23位
c00059bb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00059be:	c1 e8 10             	shr    $0x10,%eax
c00059c1:	0f b6 d0             	movzbl %al,%edx
c00059c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00059c7:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00059cb:	83 c0 05             	add    $0x5,%eax
c00059ce:	0f b7 c0             	movzwl %ax,%eax
c00059d1:	83 ec 08             	sub    $0x8,%esp
c00059d4:	52                   	push   %edx
c00059d5:	50                   	push   %eax
c00059d6:	e8 68 fe ff ff       	call   c0005843 <outb>
c00059db:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:101

	/* 因为lba地址的24~27位要存储在device寄存器的0～3位,
	* 无法单独写入这4位,所以在此处把device寄存器再重新写入一次*/
	outb(reg_dev(channel), BIT_DEV_MBS | BIT_DEV_LBA | (hd->dev_no == 1 ? BIT_DEV_DEV : 0) | lba >> 24);
c00059de:	8b 45 08             	mov    0x8(%ebp),%eax
c00059e1:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
c00059e5:	3c 01                	cmp    $0x1,%al
c00059e7:	75 07                	jne    c00059f0 <select_sector+0xcd>
/work/x86_os_my/device/ide.c:101 (discriminator 1)
c00059e9:	ba f0 ff ff ff       	mov    $0xfffffff0,%edx
c00059ee:	eb 05                	jmp    c00059f5 <select_sector+0xd2>
/work/x86_os_my/device/ide.c:101 (discriminator 2)
c00059f0:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
/work/x86_os_my/device/ide.c:101 (discriminator 4)
c00059f5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00059f8:	c1 e8 18             	shr    $0x18,%eax
c00059fb:	09 d0                	or     %edx,%eax
c00059fd:	0f b6 d0             	movzbl %al,%edx
c0005a00:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005a03:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005a07:	83 c0 06             	add    $0x6,%eax
c0005a0a:	0f b7 c0             	movzwl %ax,%eax
c0005a0d:	83 ec 08             	sub    $0x8,%esp
c0005a10:	52                   	push   %edx
c0005a11:	50                   	push   %eax
c0005a12:	e8 2c fe ff ff       	call   c0005843 <outb>
c0005a17:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:102 (discriminator 4)
}
c0005a1a:	90                   	nop
c0005a1b:	c9                   	leave  
c0005a1c:	c3                   	ret    

c0005a1d <cmd_out>:
cmd_out():
/work/x86_os_my/device/ide.c:105

/* 向通道channel发命令cmd */
static void cmd_out(struct ide_channel* channel, uint8_t cmd) {
c0005a1d:	55                   	push   %ebp
c0005a1e:	89 e5                	mov    %esp,%ebp
c0005a20:	83 ec 04             	sub    $0x4,%esp
c0005a23:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005a26:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/device/ide.c:107
	/* 只要向硬盘发出了命令便将此标记置为true,硬盘中断处理程序需要根据它来判断 */
	channel->expecting_intr = true;
c0005a29:	8b 45 08             	mov    0x8(%ebp),%eax
c0005a2c:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
/work/x86_os_my/device/ide.c:108
	outb(reg_cmd(channel), cmd);
c0005a33:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0005a37:	8b 45 08             	mov    0x8(%ebp),%eax
c0005a3a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005a3e:	83 c0 07             	add    $0x7,%eax
c0005a41:	0f b7 c0             	movzwl %ax,%eax
c0005a44:	52                   	push   %edx
c0005a45:	50                   	push   %eax
c0005a46:	e8 f8 fd ff ff       	call   c0005843 <outb>
c0005a4b:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/ide.c:109
}
c0005a4e:	90                   	nop
c0005a4f:	c9                   	leave  
c0005a50:	c3                   	ret    

c0005a51 <read_from_sector>:
read_from_sector():
/work/x86_os_my/device/ide.c:112

/* 硬盘读入sec_cnt个扇区的数据到buf */
static void read_from_sector(struct disk* hd, void* buf, uint8_t sec_cnt) {
c0005a51:	55                   	push   %ebp
c0005a52:	89 e5                	mov    %esp,%ebp
c0005a54:	83 ec 14             	sub    $0x14,%esp
c0005a57:	8b 45 10             	mov    0x10(%ebp),%eax
c0005a5a:	88 45 ec             	mov    %al,-0x14(%ebp)
/work/x86_os_my/device/ide.c:114
	uint32_t size_in_byte;
	if (sec_cnt == 0) {
c0005a5d:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
c0005a61:	75 09                	jne    c0005a6c <read_from_sector+0x1b>
/work/x86_os_my/device/ide.c:116
		/* 因为sec_cnt是8位变量,由主调函数将其赋值时,若为256则会将最高位的1丢掉变为0 */
		size_in_byte = 256 * 512;
c0005a63:	c7 45 fc 00 00 02 00 	movl   $0x20000,-0x4(%ebp)
c0005a6a:	eb 0a                	jmp    c0005a76 <read_from_sector+0x25>
/work/x86_os_my/device/ide.c:118
	} else { 
		size_in_byte = sec_cnt * 512; 
c0005a6c:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0005a70:	c1 e0 09             	shl    $0x9,%eax
c0005a73:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/device/ide.c:120
	}
	insw(reg_data(hd->my_channel), buf, size_in_byte / 2);
c0005a76:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0005a79:	d1 e8                	shr    %eax
c0005a7b:	89 c2                	mov    %eax,%edx
c0005a7d:	8b 45 08             	mov    0x8(%ebp),%eax
c0005a80:	8b 40 08             	mov    0x8(%eax),%eax
c0005a83:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005a87:	0f b7 c0             	movzwl %ax,%eax
c0005a8a:	52                   	push   %edx
c0005a8b:	ff 75 0c             	pushl  0xc(%ebp)
c0005a8e:	50                   	push   %eax
c0005a8f:	e8 20 fe ff ff       	call   c00058b4 <insw>
c0005a94:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/device/ide.c:121
}
c0005a97:	90                   	nop
c0005a98:	c9                   	leave  
c0005a99:	c3                   	ret    

c0005a9a <write2sector>:
write2sector():
/work/x86_os_my/device/ide.c:124

/* 将buf中sec_cnt扇区的数据写入硬盘 */
static void write2sector(struct disk* hd, void* buf, uint8_t sec_cnt) {
c0005a9a:	55                   	push   %ebp
c0005a9b:	89 e5                	mov    %esp,%ebp
c0005a9d:	83 ec 14             	sub    $0x14,%esp
c0005aa0:	8b 45 10             	mov    0x10(%ebp),%eax
c0005aa3:	88 45 ec             	mov    %al,-0x14(%ebp)
/work/x86_os_my/device/ide.c:126
	uint32_t size_in_byte;
	if (sec_cnt == 0) {
c0005aa6:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
c0005aaa:	75 09                	jne    c0005ab5 <write2sector+0x1b>
/work/x86_os_my/device/ide.c:128
		/* 因为sec_cnt是8位变量,由主调函数将其赋值时,若为256则会将最高位的1丢掉变为0 */
		size_in_byte = 256 * 512;
c0005aac:	c7 45 fc 00 00 02 00 	movl   $0x20000,-0x4(%ebp)
c0005ab3:	eb 0a                	jmp    c0005abf <write2sector+0x25>
/work/x86_os_my/device/ide.c:130
	} else { 
		size_in_byte = sec_cnt * 512; 
c0005ab5:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0005ab9:	c1 e0 09             	shl    $0x9,%eax
c0005abc:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/device/ide.c:132
	}
	outsw(reg_data(hd->my_channel), buf, size_in_byte / 2);
c0005abf:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0005ac2:	d1 e8                	shr    %eax
c0005ac4:	89 c2                	mov    %eax,%edx
c0005ac6:	8b 45 08             	mov    0x8(%ebp),%eax
c0005ac9:	8b 40 08             	mov    0x8(%eax),%eax
c0005acc:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005ad0:	0f b7 c0             	movzwl %ax,%eax
c0005ad3:	52                   	push   %edx
c0005ad4:	ff 75 0c             	pushl  0xc(%ebp)
c0005ad7:	50                   	push   %eax
c0005ad8:	e8 85 fd ff ff       	call   c0005862 <outsw>
c0005add:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/device/ide.c:133
}
c0005ae0:	90                   	nop
c0005ae1:	c9                   	leave  
c0005ae2:	c3                   	ret    

c0005ae3 <busy_wait>:
busy_wait():
/work/x86_os_my/device/ide.c:136

/* 等待30秒 */
static bool busy_wait(struct disk* hd) {
c0005ae3:	55                   	push   %ebp
c0005ae4:	89 e5                	mov    %esp,%ebp
c0005ae6:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ide.c:137
	struct ide_channel* channel = hd->my_channel;
c0005ae9:	8b 45 08             	mov    0x8(%ebp),%eax
c0005aec:	8b 40 08             	mov    0x8(%eax),%eax
c0005aef:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:138
	uint16_t time_limit = 30 * 1000;	// 可以等待30000毫秒
c0005af2:	66 c7 45 f6 30 75    	movw   $0x7530,-0xa(%ebp)
/work/x86_os_my/device/ide.c:139
	while (time_limit -= 10 >= 0) {
c0005af8:	eb 45                	jmp    c0005b3f <busy_wait+0x5c>
/work/x86_os_my/device/ide.c:140
		if (!(inb(reg_status(channel)) & BIT_STAT_BSY)) {
c0005afa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005afd:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005b01:	83 c0 07             	add    $0x7,%eax
c0005b04:	0f b7 c0             	movzwl %ax,%eax
c0005b07:	50                   	push   %eax
c0005b08:	e8 8a fd ff ff       	call   c0005897 <inb>
c0005b0d:	83 c4 04             	add    $0x4,%esp
c0005b10:	84 c0                	test   %al,%al
c0005b12:	78 1e                	js     c0005b32 <busy_wait+0x4f>
/work/x86_os_my/device/ide.c:141
			return (inb(reg_status(channel)) & BIT_STAT_DRQ);
c0005b14:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005b17:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005b1b:	83 c0 07             	add    $0x7,%eax
c0005b1e:	0f b7 c0             	movzwl %ax,%eax
c0005b21:	50                   	push   %eax
c0005b22:	e8 70 fd ff ff       	call   c0005897 <inb>
c0005b27:	83 c4 04             	add    $0x4,%esp
c0005b2a:	0f b6 c0             	movzbl %al,%eax
c0005b2d:	83 e0 08             	and    $0x8,%eax
c0005b30:	eb 1e                	jmp    c0005b50 <busy_wait+0x6d>
/work/x86_os_my/device/ide.c:143
		} else {
			mtime_sleep(10);			// 睡眠10毫秒
c0005b32:	83 ec 0c             	sub    $0xc,%esp
c0005b35:	6a 0a                	push   $0xa
c0005b37:	e8 d6 c2 ff ff       	call   c0001e12 <mtime_sleep>
c0005b3c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:139

/* 等待30秒 */
static bool busy_wait(struct disk* hd) {
	struct ide_channel* channel = hd->my_channel;
	uint16_t time_limit = 30 * 1000;	// 可以等待30000毫秒
	while (time_limit -= 10 >= 0) {
c0005b3f:	66 83 6d f6 01       	subw   $0x1,-0xa(%ebp)
c0005b44:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c0005b49:	75 af                	jne    c0005afa <busy_wait+0x17>
/work/x86_os_my/device/ide.c:146
			return (inb(reg_status(channel)) & BIT_STAT_DRQ);
		} else {
			mtime_sleep(10);			// 睡眠10毫秒
		}
	}
	return false;
c0005b4b:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/device/ide.c:147
}
c0005b50:	c9                   	leave  
c0005b51:	c3                   	ret    

c0005b52 <ide_read>:
ide_read():
/work/x86_os_my/device/ide.c:150

/* 从硬盘读取sec_cnt个扇区到buf */
void ide_read(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt) { 
c0005b52:	55                   	push   %ebp
c0005b53:	89 e5                	mov    %esp,%ebp
c0005b55:	83 ec 58             	sub    $0x58,%esp
/work/x86_os_my/device/ide.c:151
	ASSERT(lba <= max_lba);
c0005b58:	81 7d 0c ff 7f 02 00 	cmpl   $0x27fff,0xc(%ebp)
c0005b5f:	76 1c                	jbe    c0005b7d <ide_read+0x2b>
/work/x86_os_my/device/ide.c:151 (discriminator 1)
c0005b61:	68 98 74 00 c0       	push   $0xc0007498
c0005b66:	68 24 76 00 c0       	push   $0xc0007624
c0005b6b:	68 97 00 00 00       	push   $0x97
c0005b70:	68 a7 74 00 c0       	push   $0xc00074a7
c0005b75:	e8 08 ca ff ff       	call   c0002582 <panic_spin>
c0005b7a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:152
	ASSERT(sec_cnt > 0);
c0005b7d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0005b81:	75 1c                	jne    c0005b9f <ide_read+0x4d>
/work/x86_os_my/device/ide.c:152 (discriminator 1)
c0005b83:	68 b4 74 00 c0       	push   $0xc00074b4
c0005b88:	68 24 76 00 c0       	push   $0xc0007624
c0005b8d:	68 98 00 00 00       	push   $0x98
c0005b92:	68 a7 74 00 c0       	push   $0xc00074a7
c0005b97:	e8 e6 c9 ff ff       	call   c0002582 <panic_spin>
c0005b9c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:153
	lock_acquire (&hd->my_channel->lock);
c0005b9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005ba2:	8b 40 08             	mov    0x8(%eax),%eax
c0005ba5:	83 c0 0c             	add    $0xc,%eax
c0005ba8:	83 ec 0c             	sub    $0xc,%esp
c0005bab:	50                   	push   %eax
c0005bac:	e8 1e ed ff ff       	call   c00048cf <lock_acquire>
c0005bb1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:156

	/* 1 先选择操作的硬盘 */
	select_disk(hd);
c0005bb4:	83 ec 0c             	sub    $0xc,%esp
c0005bb7:	ff 75 08             	pushl  0x8(%ebp)
c0005bba:	e8 2a fd ff ff       	call   c00058e9 <select_disk>
c0005bbf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:159

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
c0005bc2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/ide.c:160
	while(secs_done < sec_cnt) {
c0005bc9:	e9 d4 00 00 00       	jmp    c0005ca2 <ide_read+0x150>
/work/x86_os_my/device/ide.c:161
		if ((secs_done + 256) <= sec_cnt) {
c0005bce:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005bd1:	05 00 01 00 00       	add    $0x100,%eax
c0005bd6:	3b 45 14             	cmp    0x14(%ebp),%eax
c0005bd9:	77 09                	ja     c0005be4 <ide_read+0x92>
/work/x86_os_my/device/ide.c:162
			secs_op = 256;
c0005bdb:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
c0005be2:	eb 09                	jmp    c0005bed <ide_read+0x9b>
/work/x86_os_my/device/ide.c:164
		} else {
			secs_op = sec_cnt - secs_done;
c0005be4:	8b 45 14             	mov    0x14(%ebp),%eax
c0005be7:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0005bea:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:168
		}

		/* 2 写入待读入的扇区数和起始扇区号 */
		select_sector(hd, lba + secs_done, secs_op);
c0005bed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005bf0:	0f b6 c0             	movzbl %al,%eax
c0005bf3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0005bf6:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0005bf9:	01 ca                	add    %ecx,%edx
c0005bfb:	83 ec 04             	sub    $0x4,%esp
c0005bfe:	50                   	push   %eax
c0005bff:	52                   	push   %edx
c0005c00:	ff 75 08             	pushl  0x8(%ebp)
c0005c03:	e8 1b fd ff ff       	call   c0005923 <select_sector>
c0005c08:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:171

		/* 3 执行的命令写入reg_cmd寄存器 */
		cmd_out(hd->my_channel, CMD_READ_SECTOR);	// 准备开始读数据
c0005c0b:	8b 45 08             	mov    0x8(%ebp),%eax
c0005c0e:	8b 40 08             	mov    0x8(%eax),%eax
c0005c11:	83 ec 08             	sub    $0x8,%esp
c0005c14:	6a 20                	push   $0x20
c0005c16:	50                   	push   %eax
c0005c17:	e8 01 fe ff ff       	call   c0005a1d <cmd_out>
c0005c1c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:176

		/*********************   阻塞自己的时机  ***********************
		在硬盘已经开始工作(开始在内部读数据或写数据)后才能阻塞自己,现在硬盘已经开始忙了,
		将自己阻塞,等待硬盘完成读操作后通过中断处理程序唤醒自己*/
		sema_down(&hd->my_channel->disk_done);
c0005c1f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005c22:	8b 40 08             	mov    0x8(%eax),%eax
c0005c25:	83 c0 2c             	add    $0x2c,%eax
c0005c28:	83 ec 0c             	sub    $0xc,%esp
c0005c2b:	50                   	push   %eax
c0005c2c:	e8 f4 ea ff ff       	call   c0004725 <sema_down>
c0005c31:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:181
		/*************************************************************/

		/* 4 检测硬盘状态是否可读 */
		/* 醒来后开始执行下面代码*/
		if (!busy_wait(hd)) {	// 若失败
c0005c34:	83 ec 0c             	sub    $0xc,%esp
c0005c37:	ff 75 08             	pushl  0x8(%ebp)
c0005c3a:	e8 a4 fe ff ff       	call   c0005ae3 <busy_wait>
c0005c3f:	83 c4 10             	add    $0x10,%esp
c0005c42:	85 c0                	test   %eax,%eax
c0005c44:	75 33                	jne    c0005c79 <ide_read+0x127>
/work/x86_os_my/device/ide.c:183
			char error[64];
			sprintf(error, "%s read sector %d failed!!!!!!\n", hd->name, lba);
c0005c46:	8b 45 08             	mov    0x8(%ebp),%eax
c0005c49:	ff 75 0c             	pushl  0xc(%ebp)
c0005c4c:	50                   	push   %eax
c0005c4d:	68 c0 74 00 c0       	push   $0xc00074c0
c0005c52:	8d 45 b0             	lea    -0x50(%ebp),%eax
c0005c55:	50                   	push   %eax
c0005c56:	e8 5d fb ff ff       	call   c00057b8 <sprintf>
c0005c5b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:184
			PANIC(error);
c0005c5e:	8d 45 b0             	lea    -0x50(%ebp),%eax
c0005c61:	50                   	push   %eax
c0005c62:	68 24 76 00 c0       	push   $0xc0007624
c0005c67:	68 b8 00 00 00       	push   $0xb8
c0005c6c:	68 a7 74 00 c0       	push   $0xc00074a7
c0005c71:	e8 0c c9 ff ff       	call   c0002582 <panic_spin>
c0005c76:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:188
		}

		/* 5 把数据从硬盘的缓冲区中读出 */
		read_from_sector(hd, (void*)((uint32_t)buf + secs_done * 512), secs_op);
c0005c79:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005c7c:	0f b6 c0             	movzbl %al,%eax
c0005c7f:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0005c82:	89 d1                	mov    %edx,%ecx
c0005c84:	c1 e1 09             	shl    $0x9,%ecx
c0005c87:	8b 55 10             	mov    0x10(%ebp),%edx
c0005c8a:	01 ca                	add    %ecx,%edx
c0005c8c:	83 ec 04             	sub    $0x4,%esp
c0005c8f:	50                   	push   %eax
c0005c90:	52                   	push   %edx
c0005c91:	ff 75 08             	pushl  0x8(%ebp)
c0005c94:	e8 b8 fd ff ff       	call   c0005a51 <read_from_sector>
c0005c99:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:189
		secs_done += secs_op;
c0005c9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005c9f:	01 45 f0             	add    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:160
	/* 1 先选择操作的硬盘 */
	select_disk(hd);

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
	while(secs_done < sec_cnt) {
c0005ca2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005ca5:	3b 45 14             	cmp    0x14(%ebp),%eax
c0005ca8:	0f 82 20 ff ff ff    	jb     c0005bce <ide_read+0x7c>
/work/x86_os_my/device/ide.c:191

		/* 5 把数据从硬盘的缓冲区中读出 */
		read_from_sector(hd, (void*)((uint32_t)buf + secs_done * 512), secs_op);
		secs_done += secs_op;
	}
	lock_release(&hd->my_channel->lock);
c0005cae:	8b 45 08             	mov    0x8(%ebp),%eax
c0005cb1:	8b 40 08             	mov    0x8(%eax),%eax
c0005cb4:	83 c0 0c             	add    $0xc,%eax
c0005cb7:	83 ec 0c             	sub    $0xc,%esp
c0005cba:	50                   	push   %eax
c0005cbb:	e8 86 ec ff ff       	call   c0004946 <lock_release>
c0005cc0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:192
}
c0005cc3:	90                   	nop
c0005cc4:	c9                   	leave  
c0005cc5:	c3                   	ret    

c0005cc6 <ide_write>:
ide_write():
/work/x86_os_my/device/ide.c:195

/* 将buf中sec_cnt扇区数据写入硬盘 */
void ide_write(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt) {
c0005cc6:	55                   	push   %ebp
c0005cc7:	89 e5                	mov    %esp,%ebp
c0005cc9:	83 ec 58             	sub    $0x58,%esp
/work/x86_os_my/device/ide.c:196
	ASSERT(lba <= max_lba);
c0005ccc:	81 7d 0c ff 7f 02 00 	cmpl   $0x27fff,0xc(%ebp)
c0005cd3:	76 1c                	jbe    c0005cf1 <ide_write+0x2b>
/work/x86_os_my/device/ide.c:196 (discriminator 1)
c0005cd5:	68 98 74 00 c0       	push   $0xc0007498
c0005cda:	68 30 76 00 c0       	push   $0xc0007630
c0005cdf:	68 c4 00 00 00       	push   $0xc4
c0005ce4:	68 a7 74 00 c0       	push   $0xc00074a7
c0005ce9:	e8 94 c8 ff ff       	call   c0002582 <panic_spin>
c0005cee:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:197
	ASSERT(sec_cnt > 0);
c0005cf1:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0005cf5:	75 1c                	jne    c0005d13 <ide_write+0x4d>
/work/x86_os_my/device/ide.c:197 (discriminator 1)
c0005cf7:	68 b4 74 00 c0       	push   $0xc00074b4
c0005cfc:	68 30 76 00 c0       	push   $0xc0007630
c0005d01:	68 c5 00 00 00       	push   $0xc5
c0005d06:	68 a7 74 00 c0       	push   $0xc00074a7
c0005d0b:	e8 72 c8 ff ff       	call   c0002582 <panic_spin>
c0005d10:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:198
	lock_acquire (&hd->my_channel->lock);
c0005d13:	8b 45 08             	mov    0x8(%ebp),%eax
c0005d16:	8b 40 08             	mov    0x8(%eax),%eax
c0005d19:	83 c0 0c             	add    $0xc,%eax
c0005d1c:	83 ec 0c             	sub    $0xc,%esp
c0005d1f:	50                   	push   %eax
c0005d20:	e8 aa eb ff ff       	call   c00048cf <lock_acquire>
c0005d25:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:201

	/* 1 先选择操作的硬盘 */
	select_disk(hd);
c0005d28:	83 ec 0c             	sub    $0xc,%esp
c0005d2b:	ff 75 08             	pushl  0x8(%ebp)
c0005d2e:	e8 b6 fb ff ff       	call   c00058e9 <select_disk>
c0005d33:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:204

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
c0005d36:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/ide.c:205
	while(secs_done < sec_cnt) {
c0005d3d:	e9 d4 00 00 00       	jmp    c0005e16 <ide_write+0x150>
/work/x86_os_my/device/ide.c:206
		if ((secs_done + 256) <= sec_cnt) {
c0005d42:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005d45:	05 00 01 00 00       	add    $0x100,%eax
c0005d4a:	3b 45 14             	cmp    0x14(%ebp),%eax
c0005d4d:	77 09                	ja     c0005d58 <ide_write+0x92>
/work/x86_os_my/device/ide.c:207
			secs_op = 256;
c0005d4f:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
c0005d56:	eb 09                	jmp    c0005d61 <ide_write+0x9b>
/work/x86_os_my/device/ide.c:209
		} else {
			secs_op = sec_cnt - secs_done;
c0005d58:	8b 45 14             	mov    0x14(%ebp),%eax
c0005d5b:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0005d5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:213
		}

		/* 2 写入待写入的扇区数和起始扇区号 */
		select_sector(hd, lba + secs_done, secs_op);
c0005d61:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005d64:	0f b6 c0             	movzbl %al,%eax
c0005d67:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0005d6a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0005d6d:	01 ca                	add    %ecx,%edx
c0005d6f:	83 ec 04             	sub    $0x4,%esp
c0005d72:	50                   	push   %eax
c0005d73:	52                   	push   %edx
c0005d74:	ff 75 08             	pushl  0x8(%ebp)
c0005d77:	e8 a7 fb ff ff       	call   c0005923 <select_sector>
c0005d7c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:216

		/* 3 执行的命令写入reg_cmd寄存器 */
		cmd_out(hd->my_channel, CMD_WRITE_SECTOR);	// 准备开始写数据
c0005d7f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005d82:	8b 40 08             	mov    0x8(%eax),%eax
c0005d85:	83 ec 08             	sub    $0x8,%esp
c0005d88:	6a 30                	push   $0x30
c0005d8a:	50                   	push   %eax
c0005d8b:	e8 8d fc ff ff       	call   c0005a1d <cmd_out>
c0005d90:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:219

		/* 4 检测硬盘状态是否可读 */
		if (!busy_wait(hd)) {	// 若失败
c0005d93:	83 ec 0c             	sub    $0xc,%esp
c0005d96:	ff 75 08             	pushl  0x8(%ebp)
c0005d99:	e8 45 fd ff ff       	call   c0005ae3 <busy_wait>
c0005d9e:	83 c4 10             	add    $0x10,%esp
c0005da1:	85 c0                	test   %eax,%eax
c0005da3:	75 33                	jne    c0005dd8 <ide_write+0x112>
/work/x86_os_my/device/ide.c:221
			char error[64];
			sprintf(error, "%s write sector %d failed!!!!!!\n", hd->name, lba);
c0005da5:	8b 45 08             	mov    0x8(%ebp),%eax
c0005da8:	ff 75 0c             	pushl  0xc(%ebp)
c0005dab:	50                   	push   %eax
c0005dac:	68 e0 74 00 c0       	push   $0xc00074e0
c0005db1:	8d 45 b0             	lea    -0x50(%ebp),%eax
c0005db4:	50                   	push   %eax
c0005db5:	e8 fe f9 ff ff       	call   c00057b8 <sprintf>
c0005dba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:222
			PANIC(error);
c0005dbd:	8d 45 b0             	lea    -0x50(%ebp),%eax
c0005dc0:	50                   	push   %eax
c0005dc1:	68 30 76 00 c0       	push   $0xc0007630
c0005dc6:	68 de 00 00 00       	push   $0xde
c0005dcb:	68 a7 74 00 c0       	push   $0xc00074a7
c0005dd0:	e8 ad c7 ff ff       	call   c0002582 <panic_spin>
c0005dd5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:226
		}

		/* 5 将数据写入硬盘 */
		write2sector(hd, (void*)((uint32_t)buf + secs_done * 512), secs_op);
c0005dd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005ddb:	0f b6 c0             	movzbl %al,%eax
c0005dde:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0005de1:	89 d1                	mov    %edx,%ecx
c0005de3:	c1 e1 09             	shl    $0x9,%ecx
c0005de6:	8b 55 10             	mov    0x10(%ebp),%edx
c0005de9:	01 ca                	add    %ecx,%edx
c0005deb:	83 ec 04             	sub    $0x4,%esp
c0005dee:	50                   	push   %eax
c0005def:	52                   	push   %edx
c0005df0:	ff 75 08             	pushl  0x8(%ebp)
c0005df3:	e8 a2 fc ff ff       	call   c0005a9a <write2sector>
c0005df8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:229

		/* 在硬盘响应期间阻塞自己 */
		sema_down(&hd->my_channel->disk_done);
c0005dfb:	8b 45 08             	mov    0x8(%ebp),%eax
c0005dfe:	8b 40 08             	mov    0x8(%eax),%eax
c0005e01:	83 c0 2c             	add    $0x2c,%eax
c0005e04:	83 ec 0c             	sub    $0xc,%esp
c0005e07:	50                   	push   %eax
c0005e08:	e8 18 e9 ff ff       	call   c0004725 <sema_down>
c0005e0d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:230
		secs_done += secs_op;
c0005e10:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005e13:	01 45 f0             	add    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:205
	/* 1 先选择操作的硬盘 */
	select_disk(hd);

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
	while(secs_done < sec_cnt) {
c0005e16:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005e19:	3b 45 14             	cmp    0x14(%ebp),%eax
c0005e1c:	0f 82 20 ff ff ff    	jb     c0005d42 <ide_write+0x7c>
/work/x86_os_my/device/ide.c:233
		/* 在硬盘响应期间阻塞自己 */
		sema_down(&hd->my_channel->disk_done);
		secs_done += secs_op;
	}
	/* 醒来后开始释放锁*/
	lock_release(&hd->my_channel->lock);
c0005e22:	8b 45 08             	mov    0x8(%ebp),%eax
c0005e25:	8b 40 08             	mov    0x8(%eax),%eax
c0005e28:	83 c0 0c             	add    $0xc,%eax
c0005e2b:	83 ec 0c             	sub    $0xc,%esp
c0005e2e:	50                   	push   %eax
c0005e2f:	e8 12 eb ff ff       	call   c0004946 <lock_release>
c0005e34:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:234
}
c0005e37:	90                   	nop
c0005e38:	c9                   	leave  
c0005e39:	c3                   	ret    

c0005e3a <swap_pairs_bytes>:
swap_pairs_bytes():
/work/x86_os_my/device/ide.c:238

/////////////////////////////////////// 读取分区表部分 ////////////////////////////////////////////////
/* 将dst中len个相邻字节交换位置后存入buf */
static void swap_pairs_bytes(const char* dst, char* buf, uint32_t len) {
c0005e3a:	55                   	push   %ebp
c0005e3b:	89 e5                	mov    %esp,%ebp
c0005e3d:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/device/ide.c:240
	uint8_t idx;
	for (idx = 0; idx < len; idx += 2) {
c0005e40:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
c0005e44:	eb 37                	jmp    c0005e7d <swap_pairs_bytes+0x43>
/work/x86_os_my/device/ide.c:242 (discriminator 3)
		/* buf中存储dst中两相邻元素交换位置后的字符串*/
		buf[idx + 1] = *dst++;
c0005e46:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c0005e4a:	8d 50 01             	lea    0x1(%eax),%edx
c0005e4d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005e50:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c0005e53:	8b 45 08             	mov    0x8(%ebp),%eax
c0005e56:	8d 50 01             	lea    0x1(%eax),%edx
c0005e59:	89 55 08             	mov    %edx,0x8(%ebp)
c0005e5c:	0f b6 00             	movzbl (%eax),%eax
c0005e5f:	88 01                	mov    %al,(%ecx)
/work/x86_os_my/device/ide.c:243 (discriminator 3)
		buf[idx]     = *dst++;
c0005e61:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c0005e65:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005e68:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c0005e6b:	8b 45 08             	mov    0x8(%ebp),%eax
c0005e6e:	8d 50 01             	lea    0x1(%eax),%edx
c0005e71:	89 55 08             	mov    %edx,0x8(%ebp)
c0005e74:	0f b6 00             	movzbl (%eax),%eax
c0005e77:	88 01                	mov    %al,(%ecx)
/work/x86_os_my/device/ide.c:240 (discriminator 3)

/////////////////////////////////////// 读取分区表部分 ////////////////////////////////////////////////
/* 将dst中len个相邻字节交换位置后存入buf */
static void swap_pairs_bytes(const char* dst, char* buf, uint32_t len) {
	uint8_t idx;
	for (idx = 0; idx < len; idx += 2) {
c0005e79:	80 45 ff 02          	addb   $0x2,-0x1(%ebp)
/work/x86_os_my/device/ide.c:240 (discriminator 1)
c0005e7d:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c0005e81:	3b 45 10             	cmp    0x10(%ebp),%eax
c0005e84:	72 c0                	jb     c0005e46 <swap_pairs_bytes+0xc>
/work/x86_os_my/device/ide.c:245
		/* buf中存储dst中两相邻元素交换位置后的字符串*/
		buf[idx + 1] = *dst++;
		buf[idx]     = *dst++;
	}
	buf[idx] = '\0';
c0005e86:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c0005e8a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005e8d:	01 d0                	add    %edx,%eax
c0005e8f:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/device/ide.c:246
}
c0005e92:	90                   	nop
c0005e93:	c9                   	leave  
c0005e94:	c3                   	ret    

c0005e95 <identify_disk>:
identify_disk():
/work/x86_os_my/device/ide.c:249

/* 获得硬盘参数信息 */
static void identify_disk(struct disk* hd) {
c0005e95:	55                   	push   %ebp
c0005e96:	89 e5                	mov    %esp,%ebp
c0005e98:	81 ec 98 02 00 00    	sub    $0x298,%esp
/work/x86_os_my/device/ide.c:251
	char id_info[512];
	select_disk(hd);
c0005e9e:	ff 75 08             	pushl  0x8(%ebp)
c0005ea1:	e8 43 fa ff ff       	call   c00058e9 <select_disk>
c0005ea6:	83 c4 04             	add    $0x4,%esp
/work/x86_os_my/device/ide.c:252
	cmd_out(hd->my_channel, CMD_IDENTIFY);
c0005ea9:	8b 45 08             	mov    0x8(%ebp),%eax
c0005eac:	8b 40 08             	mov    0x8(%eax),%eax
c0005eaf:	68 ec 00 00 00       	push   $0xec
c0005eb4:	50                   	push   %eax
c0005eb5:	e8 63 fb ff ff       	call   c0005a1d <cmd_out>
c0005eba:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/ide.c:255
	/* 向硬盘发送指令后便通过信号量阻塞自己,
	* 待硬盘处理完成后,通过中断处理程序将自己唤醒 */
	sema_down(&hd->my_channel->disk_done);
c0005ebd:	8b 45 08             	mov    0x8(%ebp),%eax
c0005ec0:	8b 40 08             	mov    0x8(%eax),%eax
c0005ec3:	83 c0 2c             	add    $0x2c,%eax
c0005ec6:	83 ec 0c             	sub    $0xc,%esp
c0005ec9:	50                   	push   %eax
c0005eca:	e8 56 e8 ff ff       	call   c0004725 <sema_down>
c0005ecf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:258

	/* 醒来后开始执行下面代码*/
	if (!busy_wait(hd)) {     //  若失败
c0005ed2:	83 ec 0c             	sub    $0xc,%esp
c0005ed5:	ff 75 08             	pushl  0x8(%ebp)
c0005ed8:	e8 06 fc ff ff       	call   c0005ae3 <busy_wait>
c0005edd:	83 c4 10             	add    $0x10,%esp
c0005ee0:	85 c0                	test   %eax,%eax
c0005ee2:	75 39                	jne    c0005f1d <identify_disk+0x88>
/work/x86_os_my/device/ide.c:260
		char error[64];
		sprintf(error, "%s identify failed!!!!!!\n", hd->name);
c0005ee4:	8b 45 08             	mov    0x8(%ebp),%eax
c0005ee7:	83 ec 04             	sub    $0x4,%esp
c0005eea:	50                   	push   %eax
c0005eeb:	68 01 75 00 c0       	push   $0xc0007501
c0005ef0:	8d 85 70 fd ff ff    	lea    -0x290(%ebp),%eax
c0005ef6:	50                   	push   %eax
c0005ef7:	e8 bc f8 ff ff       	call   c00057b8 <sprintf>
c0005efc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:261
		PANIC(error);
c0005eff:	8d 85 70 fd ff ff    	lea    -0x290(%ebp),%eax
c0005f05:	50                   	push   %eax
c0005f06:	68 3c 76 00 c0       	push   $0xc000763c
c0005f0b:	68 05 01 00 00       	push   $0x105
c0005f10:	68 a7 74 00 c0       	push   $0xc00074a7
c0005f15:	e8 68 c6 ff ff       	call   c0002582 <panic_spin>
c0005f1a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:263
	}
	read_from_sector(hd, id_info, 1);
c0005f1d:	83 ec 04             	sub    $0x4,%esp
c0005f20:	6a 01                	push   $0x1
c0005f22:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c0005f28:	50                   	push   %eax
c0005f29:	ff 75 08             	pushl  0x8(%ebp)
c0005f2c:	e8 20 fb ff ff       	call   c0005a51 <read_from_sector>
c0005f31:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:266

	char buf[64];
	uint8_t sn_start = 10 * 2, sn_len = 20, md_start = 27 * 2, md_len = 40;
c0005f34:	c6 45 f7 14          	movb   $0x14,-0x9(%ebp)
c0005f38:	c6 45 f6 14          	movb   $0x14,-0xa(%ebp)
c0005f3c:	c6 45 f5 36          	movb   $0x36,-0xb(%ebp)
c0005f40:	c6 45 f4 28          	movb   $0x28,-0xc(%ebp)
/work/x86_os_my/device/ide.c:267
	swap_pairs_bytes(&id_info[sn_start], buf, sn_len);
c0005f44:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0005f48:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0005f4c:	8d 8d f0 fd ff ff    	lea    -0x210(%ebp),%ecx
c0005f52:	01 ca                	add    %ecx,%edx
c0005f54:	83 ec 04             	sub    $0x4,%esp
c0005f57:	50                   	push   %eax
c0005f58:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c0005f5e:	50                   	push   %eax
c0005f5f:	52                   	push   %edx
c0005f60:	e8 d5 fe ff ff       	call   c0005e3a <swap_pairs_bytes>
c0005f65:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:268
	printk("   disk %s info:\n      SN: %s\n", hd->name, buf);
c0005f68:	8b 45 08             	mov    0x8(%ebp),%eax
c0005f6b:	83 ec 04             	sub    $0x4,%esp
c0005f6e:	8d 95 b0 fd ff ff    	lea    -0x250(%ebp),%edx
c0005f74:	52                   	push   %edx
c0005f75:	50                   	push   %eax
c0005f76:	68 1c 75 00 c0       	push   $0xc000751c
c0005f7b:	e8 75 05 00 00       	call   c00064f5 <printk>
c0005f80:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:269
	memset(buf, 0, sizeof(buf));
c0005f83:	83 ec 04             	sub    $0x4,%esp
c0005f86:	6a 40                	push   $0x40
c0005f88:	6a 00                	push   $0x0
c0005f8a:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c0005f90:	50                   	push   %eax
c0005f91:	e8 04 da ff ff       	call   c000399a <memset>
c0005f96:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:270
	swap_pairs_bytes(&id_info[md_start], buf, md_len);
c0005f99:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0005f9d:	0f b6 55 f5          	movzbl -0xb(%ebp),%edx
c0005fa1:	8d 8d f0 fd ff ff    	lea    -0x210(%ebp),%ecx
c0005fa7:	01 ca                	add    %ecx,%edx
c0005fa9:	83 ec 04             	sub    $0x4,%esp
c0005fac:	50                   	push   %eax
c0005fad:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c0005fb3:	50                   	push   %eax
c0005fb4:	52                   	push   %edx
c0005fb5:	e8 80 fe ff ff       	call   c0005e3a <swap_pairs_bytes>
c0005fba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:271
	printk("      MODULE: %s\n", buf);
c0005fbd:	83 ec 08             	sub    $0x8,%esp
c0005fc0:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c0005fc6:	50                   	push   %eax
c0005fc7:	68 3b 75 00 c0       	push   $0xc000753b
c0005fcc:	e8 24 05 00 00       	call   c00064f5 <printk>
c0005fd1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:272
	uint32_t sectors = *(uint32_t*)&id_info[60 * 2];
c0005fd4:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c0005fda:	83 c0 78             	add    $0x78,%eax
c0005fdd:	8b 00                	mov    (%eax),%eax
c0005fdf:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:273
	printk("      SECTORS: %d\n", sectors);
c0005fe2:	83 ec 08             	sub    $0x8,%esp
c0005fe5:	ff 75 f0             	pushl  -0x10(%ebp)
c0005fe8:	68 4d 75 00 c0       	push   $0xc000754d
c0005fed:	e8 03 05 00 00       	call   c00064f5 <printk>
c0005ff2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:274
	printk("      CAPACITY: %dMB\n", sectors * 512 / 1024 / 1024);
c0005ff5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005ff8:	c1 e0 09             	shl    $0x9,%eax
c0005ffb:	c1 e8 14             	shr    $0x14,%eax
c0005ffe:	83 ec 08             	sub    $0x8,%esp
c0006001:	50                   	push   %eax
c0006002:	68 60 75 00 c0       	push   $0xc0007560
c0006007:	e8 e9 04 00 00       	call   c00064f5 <printk>
c000600c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:275
}
c000600f:	90                   	nop
c0006010:	c9                   	leave  
c0006011:	c3                   	ret    

c0006012 <partition_scan>:
partition_scan():
/work/x86_os_my/device/ide.c:278

/* 扫描硬盘hd中地址为ext_lba的扇区中的所有分区 */
static void partition_scan(struct disk* hd, uint32_t ext_lba) {
c0006012:	55                   	push   %ebp
c0006013:	89 e5                	mov    %esp,%ebp
c0006015:	53                   	push   %ebx
c0006016:	83 ec 14             	sub    $0x14,%esp
/work/x86_os_my/device/ide.c:279
	struct boot_sector* bs = sys_malloc(sizeof(struct boot_sector));
c0006019:	83 ec 0c             	sub    $0xc,%esp
c000601c:	68 00 02 00 00       	push   $0x200
c0006021:	e8 7d ce ff ff       	call   c0002ea3 <sys_malloc>
c0006026:	83 c4 10             	add    $0x10,%esp
c0006029:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/device/ide.c:280
	ide_read(hd, ext_lba, bs, 1);
c000602c:	6a 01                	push   $0x1
c000602e:	ff 75 ec             	pushl  -0x14(%ebp)
c0006031:	ff 75 0c             	pushl  0xc(%ebp)
c0006034:	ff 75 08             	pushl  0x8(%ebp)
c0006037:	e8 16 fb ff ff       	call   c0005b52 <ide_read>
c000603c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:281
	uint8_t part_idx = 0;
c000603f:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/device/ide.c:282
	struct partition_table_entry* p = bs->partition_table;
c0006043:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0006046:	05 be 01 00 00       	add    $0x1be,%eax
c000604b:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:285

	/* 遍历分区表4个分区表项 */
	while (part_idx++ < 4) {
c000604e:	e9 53 02 00 00       	jmp    c00062a6 <partition_scan+0x294>
/work/x86_os_my/device/ide.c:286
		if (p->fs_type == 0x5) {	// 若为扩展分区
c0006053:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006056:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c000605a:	3c 05                	cmp    $0x5,%al
c000605c:	75 50                	jne    c00060ae <partition_scan+0x9c>
/work/x86_os_my/device/ide.c:287
			if (ext_lba_base != 0) {
c000605e:	a1 0c 96 00 c0       	mov    0xc000960c,%eax
c0006063:	85 c0                	test   %eax,%eax
c0006065:	74 22                	je     c0006089 <partition_scan+0x77>
/work/x86_os_my/device/ide.c:289
				/* 子扩展分区的start_lba是相对于主引导扇区中的总扩展分区地址 */
				partition_scan(hd, p->start_lba + ext_lba_base);
c0006067:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000606a:	8b 40 08             	mov    0x8(%eax),%eax
c000606d:	8b 15 0c 96 00 c0    	mov    0xc000960c,%edx
c0006073:	01 d0                	add    %edx,%eax
c0006075:	83 ec 08             	sub    $0x8,%esp
c0006078:	50                   	push   %eax
c0006079:	ff 75 08             	pushl  0x8(%ebp)
c000607c:	e8 91 ff ff ff       	call   c0006012 <partition_scan>
c0006081:	83 c4 10             	add    $0x10,%esp
c0006084:	e9 19 02 00 00       	jmp    c00062a2 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:292
			} else {	// ext_lba_base为0表示是第一次读取引导块,也就是主引导记录所在的扇区
				/* 记录下扩展分区的起始lba地址,后面所有的扩展分区地址都相对于此 */
				ext_lba_base = p->start_lba;
c0006089:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000608c:	8b 40 08             	mov    0x8(%eax),%eax
c000608f:	a3 0c 96 00 c0       	mov    %eax,0xc000960c
/work/x86_os_my/device/ide.c:293
				partition_scan(hd, p->start_lba);
c0006094:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006097:	8b 40 08             	mov    0x8(%eax),%eax
c000609a:	83 ec 08             	sub    $0x8,%esp
c000609d:	50                   	push   %eax
c000609e:	ff 75 08             	pushl  0x8(%ebp)
c00060a1:	e8 6c ff ff ff       	call   c0006012 <partition_scan>
c00060a6:	83 c4 10             	add    $0x10,%esp
c00060a9:	e9 f4 01 00 00       	jmp    c00062a2 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:295
			}
		} else if (p->fs_type != 0) {	// 若是有效的分区类型
c00060ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00060b1:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c00060b5:	84 c0                	test   %al,%al
c00060b7:	0f 84 e5 01 00 00    	je     c00062a2 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:296
			if (ext_lba == 0) {	// 此时全是主分区
c00060bd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00060c1:	0f 85 f9 00 00 00    	jne    c00061c0 <partition_scan+0x1ae>
/work/x86_os_my/device/ide.c:297
				hd->prim_parts[p_no].start_lba = ext_lba + p->start_lba;
c00060c7:	0f b6 05 10 96 00 c0 	movzbl 0xc0009610,%eax
c00060ce:	0f b6 c8             	movzbl %al,%ecx
c00060d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00060d4:	8b 50 08             	mov    0x8(%eax),%edx
c00060d7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00060da:	01 c2                	add    %eax,%edx
c00060dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00060df:	c1 e1 06             	shl    $0x6,%ecx
c00060e2:	01 c8                	add    %ecx,%eax
c00060e4:	83 c0 10             	add    $0x10,%eax
c00060e7:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ide.c:298
				hd->prim_parts[p_no].sec_cnt = p->sec_cnt;
c00060e9:	0f b6 05 10 96 00 c0 	movzbl 0xc0009610,%eax
c00060f0:	0f b6 c8             	movzbl %al,%ecx
c00060f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00060f6:	8b 40 0c             	mov    0xc(%eax),%eax
c00060f9:	8b 55 08             	mov    0x8(%ebp),%edx
c00060fc:	c1 e1 06             	shl    $0x6,%ecx
c00060ff:	01 ca                	add    %ecx,%edx
c0006101:	83 c2 14             	add    $0x14,%edx
c0006104:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:299
				hd->prim_parts[p_no].my_disk = hd;
c0006106:	0f b6 05 10 96 00 c0 	movzbl 0xc0009610,%eax
c000610d:	0f b6 d0             	movzbl %al,%edx
c0006110:	8b 45 08             	mov    0x8(%ebp),%eax
c0006113:	c1 e2 06             	shl    $0x6,%edx
c0006116:	01 d0                	add    %edx,%eax
c0006118:	8d 50 18             	lea    0x18(%eax),%edx
c000611b:	8b 45 08             	mov    0x8(%ebp),%eax
c000611e:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:300
				list_append(&partition_list, &hd->prim_parts[p_no].part_tag);
c0006120:	0f b6 05 10 96 00 c0 	movzbl 0xc0009610,%eax
c0006127:	0f b6 c0             	movzbl %al,%eax
c000612a:	c1 e0 06             	shl    $0x6,%eax
c000612d:	8d 50 10             	lea    0x10(%eax),%edx
c0006130:	8b 45 08             	mov    0x8(%ebp),%eax
c0006133:	01 d0                	add    %edx,%eax
c0006135:	83 c0 0c             	add    $0xc,%eax
c0006138:	83 ec 08             	sub    $0x8,%esp
c000613b:	50                   	push   %eax
c000613c:	68 c0 a9 00 c0       	push   $0xc000a9c0
c0006141:	e8 57 e3 ff ff       	call   c000449d <list_append>
c0006146:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:301
				sprintf(hd->prim_parts[p_no].name, "%s%d", hd->name, p_no + 1);
c0006149:	0f b6 05 10 96 00 c0 	movzbl 0xc0009610,%eax
c0006150:	0f b6 c0             	movzbl %al,%eax
c0006153:	8d 48 01             	lea    0x1(%eax),%ecx
c0006156:	8b 45 08             	mov    0x8(%ebp),%eax
c0006159:	0f b6 15 10 96 00 c0 	movzbl 0xc0009610,%edx
c0006160:	0f b6 d2             	movzbl %dl,%edx
c0006163:	c1 e2 06             	shl    $0x6,%edx
c0006166:	8d 5a 20             	lea    0x20(%edx),%ebx
c0006169:	8b 55 08             	mov    0x8(%ebp),%edx
c000616c:	01 da                	add    %ebx,%edx
c000616e:	83 c2 04             	add    $0x4,%edx
c0006171:	51                   	push   %ecx
c0006172:	50                   	push   %eax
c0006173:	68 76 75 00 c0       	push   $0xc0007576
c0006178:	52                   	push   %edx
c0006179:	e8 3a f6 ff ff       	call   c00057b8 <sprintf>
c000617e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:302
				p_no++;
c0006181:	0f b6 05 10 96 00 c0 	movzbl 0xc0009610,%eax
c0006188:	83 c0 01             	add    $0x1,%eax
c000618b:	a2 10 96 00 c0       	mov    %al,0xc0009610
/work/x86_os_my/device/ide.c:303
				ASSERT(p_no < 4);	// 0,1,2,3
c0006190:	0f b6 05 10 96 00 c0 	movzbl 0xc0009610,%eax
c0006197:	3c 03                	cmp    $0x3,%al
c0006199:	0f 86 03 01 00 00    	jbe    c00062a2 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:303 (discriminator 1)
c000619f:	68 7b 75 00 c0       	push   $0xc000757b
c00061a4:	68 4c 76 00 c0       	push   $0xc000764c
c00061a9:	68 2f 01 00 00       	push   $0x12f
c00061ae:	68 a7 74 00 c0       	push   $0xc00074a7
c00061b3:	e8 ca c3 ff ff       	call   c0002582 <panic_spin>
c00061b8:	83 c4 10             	add    $0x10,%esp
c00061bb:	e9 e2 00 00 00       	jmp    c00062a2 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:305
			} else {
				hd->logic_parts[l_no].start_lba = ext_lba + p->start_lba;
c00061c0:	0f b6 05 11 96 00 c0 	movzbl 0xc0009611,%eax
c00061c7:	0f b6 c8             	movzbl %al,%ecx
c00061ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00061cd:	8b 50 08             	mov    0x8(%eax),%edx
c00061d0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00061d3:	01 c2                	add    %eax,%edx
c00061d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00061d8:	c1 e1 06             	shl    $0x6,%ecx
c00061db:	01 c8                	add    %ecx,%eax
c00061dd:	05 10 01 00 00       	add    $0x110,%eax
c00061e2:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ide.c:306
				hd->logic_parts[l_no].sec_cnt = p->sec_cnt;
c00061e4:	0f b6 05 11 96 00 c0 	movzbl 0xc0009611,%eax
c00061eb:	0f b6 c8             	movzbl %al,%ecx
c00061ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00061f1:	8b 40 0c             	mov    0xc(%eax),%eax
c00061f4:	8b 55 08             	mov    0x8(%ebp),%edx
c00061f7:	c1 e1 06             	shl    $0x6,%ecx
c00061fa:	01 ca                	add    %ecx,%edx
c00061fc:	81 c2 14 01 00 00    	add    $0x114,%edx
c0006202:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:307
				hd->logic_parts[l_no].my_disk = hd;
c0006204:	0f b6 05 11 96 00 c0 	movzbl 0xc0009611,%eax
c000620b:	0f b6 d0             	movzbl %al,%edx
c000620e:	8b 45 08             	mov    0x8(%ebp),%eax
c0006211:	c1 e2 06             	shl    $0x6,%edx
c0006214:	01 d0                	add    %edx,%eax
c0006216:	8d 90 18 01 00 00    	lea    0x118(%eax),%edx
c000621c:	8b 45 08             	mov    0x8(%ebp),%eax
c000621f:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:308
				list_append(&partition_list, &hd->logic_parts[l_no].part_tag);
c0006221:	0f b6 05 11 96 00 c0 	movzbl 0xc0009611,%eax
c0006228:	0f b6 c0             	movzbl %al,%eax
c000622b:	c1 e0 06             	shl    $0x6,%eax
c000622e:	8d 90 10 01 00 00    	lea    0x110(%eax),%edx
c0006234:	8b 45 08             	mov    0x8(%ebp),%eax
c0006237:	01 d0                	add    %edx,%eax
c0006239:	83 c0 0c             	add    $0xc,%eax
c000623c:	83 ec 08             	sub    $0x8,%esp
c000623f:	50                   	push   %eax
c0006240:	68 c0 a9 00 c0       	push   $0xc000a9c0
c0006245:	e8 53 e2 ff ff       	call   c000449d <list_append>
c000624a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:309
				sprintf(hd->logic_parts[l_no].name, "%s%d", hd->name, l_no + 5);	// 逻辑分区数字是从5开始,主分区是1～4.
c000624d:	0f b6 05 11 96 00 c0 	movzbl 0xc0009611,%eax
c0006254:	0f b6 c0             	movzbl %al,%eax
c0006257:	8d 48 05             	lea    0x5(%eax),%ecx
c000625a:	8b 45 08             	mov    0x8(%ebp),%eax
c000625d:	0f b6 15 11 96 00 c0 	movzbl 0xc0009611,%edx
c0006264:	0f b6 d2             	movzbl %dl,%edx
c0006267:	c1 e2 06             	shl    $0x6,%edx
c000626a:	8d 9a 20 01 00 00    	lea    0x120(%edx),%ebx
c0006270:	8b 55 08             	mov    0x8(%ebp),%edx
c0006273:	01 da                	add    %ebx,%edx
c0006275:	83 c2 04             	add    $0x4,%edx
c0006278:	51                   	push   %ecx
c0006279:	50                   	push   %eax
c000627a:	68 76 75 00 c0       	push   $0xc0007576
c000627f:	52                   	push   %edx
c0006280:	e8 33 f5 ff ff       	call   c00057b8 <sprintf>
c0006285:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:310
				l_no++;
c0006288:	0f b6 05 11 96 00 c0 	movzbl 0xc0009611,%eax
c000628f:	83 c0 01             	add    $0x1,%eax
c0006292:	a2 11 96 00 c0       	mov    %al,0xc0009611
/work/x86_os_my/device/ide.c:311
				if (l_no >= 8)	// 只支持8个逻辑分区,避免数组越界
c0006297:	0f b6 05 11 96 00 c0 	movzbl 0xc0009611,%eax
c000629e:	3c 07                	cmp    $0x7,%al
c00062a0:	77 26                	ja     c00062c8 <partition_scan+0x2b6>
/work/x86_os_my/device/ide.c:315
					return;
			}
		}
		p++;
c00062a2:	83 45 f0 10          	addl   $0x10,-0x10(%ebp)
/work/x86_os_my/device/ide.c:285
	ide_read(hd, ext_lba, bs, 1);
	uint8_t part_idx = 0;
	struct partition_table_entry* p = bs->partition_table;

	/* 遍历分区表4个分区表项 */
	while (part_idx++ < 4) {
c00062a6:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00062aa:	8d 50 01             	lea    0x1(%eax),%edx
c00062ad:	88 55 f7             	mov    %dl,-0x9(%ebp)
c00062b0:	3c 03                	cmp    $0x3,%al
c00062b2:	0f 86 9b fd ff ff    	jbe    c0006053 <partition_scan+0x41>
/work/x86_os_my/device/ide.c:317
					return;
			}
		}
		p++;
	}
	sys_free(bs);
c00062b8:	83 ec 0c             	sub    $0xc,%esp
c00062bb:	ff 75 ec             	pushl  -0x14(%ebp)
c00062be:	e8 0d d2 ff ff       	call   c00034d0 <sys_free>
c00062c3:	83 c4 10             	add    $0x10,%esp
c00062c6:	eb 01                	jmp    c00062c9 <partition_scan+0x2b7>
/work/x86_os_my/device/ide.c:312
				hd->logic_parts[l_no].my_disk = hd;
				list_append(&partition_list, &hd->logic_parts[l_no].part_tag);
				sprintf(hd->logic_parts[l_no].name, "%s%d", hd->name, l_no + 5);	// 逻辑分区数字是从5开始,主分区是1～4.
				l_no++;
				if (l_no >= 8)	// 只支持8个逻辑分区,避免数组越界
					return;
c00062c8:	90                   	nop
/work/x86_os_my/device/ide.c:318
			}
		}
		p++;
	}
	sys_free(bs);
}
c00062c9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00062cc:	c9                   	leave  
c00062cd:	c3                   	ret    

c00062ce <partition_info>:
partition_info():
/work/x86_os_my/device/ide.c:321

/* 打印分区信息 */
static bool partition_info(struct list_elem* pelem, int arg UNUSED) {
c00062ce:	55                   	push   %ebp
c00062cf:	89 e5                	mov    %esp,%ebp
c00062d1:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ide.c:322
	struct partition* part = elem2entry(struct partition, part_tag, pelem);
c00062d4:	8b 45 08             	mov    0x8(%ebp),%eax
c00062d7:	83 e8 0c             	sub    $0xc,%eax
c00062da:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:323
	printk("   %s start_lba:0x%x, sec_cnt:0x%x\n",part->name, part->start_lba, part->sec_cnt);
c00062dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00062e0:	8b 50 04             	mov    0x4(%eax),%edx
c00062e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00062e6:	8b 00                	mov    (%eax),%eax
c00062e8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c00062eb:	83 c1 14             	add    $0x14,%ecx
c00062ee:	52                   	push   %edx
c00062ef:	50                   	push   %eax
c00062f0:	51                   	push   %ecx
c00062f1:	68 84 75 00 c0       	push   $0xc0007584
c00062f6:	e8 fa 01 00 00       	call   c00064f5 <printk>
c00062fb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:327

	/* 在此处return false与函数本身功能无关,
	 * 只是为了让主调函数list_traversal继续向下遍历元素 */
	return false;
c00062fe:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/device/ide.c:328
}
c0006303:	c9                   	leave  
c0006304:	c3                   	ret    

c0006305 <intr_hd_handler>:
intr_hd_handler():
/work/x86_os_my/device/ide.c:331

/* 硬盘中断处理程序 */
void intr_hd_handler(uint8_t irq_no) {
c0006305:	55                   	push   %ebp
c0006306:	89 e5                	mov    %esp,%ebp
c0006308:	83 ec 28             	sub    $0x28,%esp
c000630b:	8b 45 08             	mov    0x8(%ebp),%eax
c000630e:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/device/ide.c:332
	ASSERT(irq_no == 0x2e || irq_no == 0x2f);
c0006311:	80 7d e4 2e          	cmpb   $0x2e,-0x1c(%ebp)
c0006315:	74 22                	je     c0006339 <intr_hd_handler+0x34>
/work/x86_os_my/device/ide.c:332 (discriminator 1)
c0006317:	80 7d e4 2f          	cmpb   $0x2f,-0x1c(%ebp)
c000631b:	74 1c                	je     c0006339 <intr_hd_handler+0x34>
/work/x86_os_my/device/ide.c:332 (discriminator 2)
c000631d:	68 a8 75 00 c0       	push   $0xc00075a8
c0006322:	68 5c 76 00 c0       	push   $0xc000765c
c0006327:	68 4c 01 00 00       	push   $0x14c
c000632c:	68 a7 74 00 c0       	push   $0xc00074a7
c0006331:	e8 4c c2 ff ff       	call   c0002582 <panic_spin>
c0006336:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:333
	uint8_t ch_no = irq_no - 0x2e;
c0006339:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c000633d:	83 e8 2e             	sub    $0x2e,%eax
c0006340:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ide.c:334
	struct ide_channel* channel = &channels[ch_no];
c0006343:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0006347:	69 c0 60 06 00 00    	imul   $0x660,%eax,%eax
c000634d:	05 00 9d 00 c0       	add    $0xc0009d00,%eax
c0006352:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:335
	ASSERT(channel->irq_no == irq_no);
c0006355:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006358:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c000635c:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c000635f:	74 1c                	je     c000637d <intr_hd_handler+0x78>
/work/x86_os_my/device/ide.c:335 (discriminator 1)
c0006361:	68 c9 75 00 c0       	push   $0xc00075c9
c0006366:	68 5c 76 00 c0       	push   $0xc000765c
c000636b:	68 4f 01 00 00       	push   $0x14f
c0006370:	68 a7 74 00 c0       	push   $0xc00074a7
c0006375:	e8 08 c2 ff ff       	call   c0002582 <panic_spin>
c000637a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:338
	/* 不必担心此中断是否对应的是这一次的expecting_intr,
	* 每次读写硬盘时会申请锁,从而保证了同步一致性 */
	if (channel->expecting_intr) {
c000637d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006380:	8b 40 28             	mov    0x28(%eax),%eax
c0006383:	85 c0                	test   %eax,%eax
c0006385:	74 35                	je     c00063bc <intr_hd_handler+0xb7>
/work/x86_os_my/device/ide.c:339
		channel->expecting_intr = false;
c0006387:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000638a:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
/work/x86_os_my/device/ide.c:340
		sema_up(&channel->disk_done);
c0006391:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006394:	83 c0 2c             	add    $0x2c,%eax
c0006397:	83 ec 0c             	sub    $0xc,%esp
c000639a:	50                   	push   %eax
c000639b:	e8 80 e4 ff ff       	call   c0004820 <sema_up>
c00063a0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:343

		/* 读取状态寄存器使硬盘控制器认为此次的中断已被处理,从而硬盘可以继续执行新的读写 */
		inb(reg_status(channel));
c00063a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00063a6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00063aa:	83 c0 07             	add    $0x7,%eax
c00063ad:	0f b7 c0             	movzwl %ax,%eax
c00063b0:	83 ec 0c             	sub    $0xc,%esp
c00063b3:	50                   	push   %eax
c00063b4:	e8 de f4 ff ff       	call   c0005897 <inb>
c00063b9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:345
	}
}
c00063bc:	90                   	nop
c00063bd:	c9                   	leave  
c00063be:	c3                   	ret    

c00063bf <ide_init>:
ide_init():
/work/x86_os_my/device/ide.c:348

/* 硬盘数据结构初始化 */
void ide_init() {
c00063bf:	55                   	push   %ebp
c00063c0:	89 e5                	mov    %esp,%ebp
c00063c2:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ide.c:349
	printk("ide_init start\n");
c00063c5:	83 ec 0c             	sub    $0xc,%esp
c00063c8:	68 e3 75 00 c0       	push   $0xc00075e3
c00063cd:	e8 23 01 00 00       	call   c00064f5 <printk>
c00063d2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:350
	uint8_t hd_cnt = *((uint8_t*)(0x475));	// 获取硬盘的数量
c00063d5:	b8 75 04 00 00       	mov    $0x475,%eax
c00063da:	0f b6 00             	movzbl (%eax),%eax
c00063dd:	88 45 f6             	mov    %al,-0xa(%ebp)
/work/x86_os_my/device/ide.c:351
	ASSERT(hd_cnt > 0);
c00063e0:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c00063e4:	75 1c                	jne    c0006402 <ide_init+0x43>
/work/x86_os_my/device/ide.c:351 (discriminator 1)
c00063e6:	68 f3 75 00 c0       	push   $0xc00075f3
c00063eb:	68 6c 76 00 c0       	push   $0xc000766c
c00063f0:	68 5f 01 00 00       	push   $0x15f
c00063f5:	68 a7 74 00 c0       	push   $0xc00074a7
c00063fa:	e8 83 c1 ff ff       	call   c0002582 <panic_spin>
c00063ff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:352
	channel_cnt = DIV_ROUND_UP(hd_cnt, 2);	// 一个ide通道上有两个硬盘,根据硬盘数量反推有几个ide通道
c0006402:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0006406:	83 c0 01             	add    $0x1,%eax
c0006409:	89 c2                	mov    %eax,%edx
c000640b:	c1 ea 1f             	shr    $0x1f,%edx
c000640e:	01 d0                	add    %edx,%eax
c0006410:	d1 f8                	sar    %eax
c0006412:	a2 e0 9c 00 c0       	mov    %al,0xc0009ce0
/work/x86_os_my/device/ide.c:354
	struct ide_channel* channel;
	uint8_t channel_no = 0;
c0006417:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/device/ide.c:357

	/* 处理每个通道上的硬盘 */
	while (channel_no < channel_cnt) {
c000641b:	e9 b2 00 00 00       	jmp    c00064d2 <ide_init+0x113>
/work/x86_os_my/device/ide.c:358
		channel = &channels[channel_no];
c0006420:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0006424:	69 c0 60 06 00 00    	imul   $0x660,%eax,%eax
c000642a:	05 00 9d 00 c0       	add    $0xc0009d00,%eax
c000642f:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:359
		sprintf(channel->name, "ide%d", channel_no);
c0006432:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0006436:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006439:	83 ec 04             	sub    $0x4,%esp
c000643c:	52                   	push   %edx
c000643d:	68 fe 75 00 c0       	push   $0xc00075fe
c0006442:	50                   	push   %eax
c0006443:	e8 70 f3 ff ff       	call   c00057b8 <sprintf>
c0006448:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:362

		/* 为每个ide通道初始化端口基址及中断向量 */
		switch (channel_no) {
c000644b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000644f:	85 c0                	test   %eax,%eax
c0006451:	74 07                	je     c000645a <ide_init+0x9b>
c0006453:	83 f8 01             	cmp    $0x1,%eax
c0006456:	74 14                	je     c000646c <ide_init+0xad>
c0006458:	eb 23                	jmp    c000647d <ide_init+0xbe>
/work/x86_os_my/device/ide.c:364
			case 0:
			channel->port_base	 = 0x1f0;	// ide0通道的起始端口号是0x1f0
c000645a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000645d:	66 c7 40 08 f0 01    	movw   $0x1f0,0x8(%eax)
/work/x86_os_my/device/ide.c:365
			channel->irq_no	 = 0x20 + 14;	// 从片8259a上倒数第二的中断引脚,温盘,也就是ide0通道的的中断向量号
c0006463:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006466:	c6 40 0a 2e          	movb   $0x2e,0xa(%eax)
/work/x86_os_my/device/ide.c:366
			break;
c000646a:	eb 11                	jmp    c000647d <ide_init+0xbe>
/work/x86_os_my/device/ide.c:369
			
			case 1:
			channel->port_base	 = 0x170;	// ide1通道的起始端口号是0x170
c000646c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000646f:	66 c7 40 08 70 01    	movw   $0x170,0x8(%eax)
/work/x86_os_my/device/ide.c:370
			channel->irq_no	 = 0x20 + 15;	// 从8259A上的最后一个中断引脚,我们用来响应ide1通道上的硬盘中断
c0006475:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006478:	c6 40 0a 2f          	movb   $0x2f,0xa(%eax)
/work/x86_os_my/device/ide.c:371
			break;
c000647c:	90                   	nop
/work/x86_os_my/device/ide.c:374
		}

		channel->expecting_intr = false;	// 未向硬盘写入指令时不期待硬盘的中断
c000647d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006480:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
/work/x86_os_my/device/ide.c:375
		lock_init(&channel->lock);
c0006487:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000648a:	83 c0 0c             	add    $0xc,%eax
c000648d:	83 ec 0c             	sub    $0xc,%esp
c0006490:	50                   	push   %eax
c0006491:	e8 5f e2 ff ff       	call   c00046f5 <lock_init>
c0006496:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:379

		/* 初始化为0,目的是向硬盘控制器请求数据后,硬盘驱动sema_down此信号量会阻塞线程,
		直到硬盘完成后通过发中断,由中断处理程序将此信号量sema_up,唤醒线程. */
		sema_init(&channel->disk_done, 0);
c0006499:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000649c:	83 c0 2c             	add    $0x2c,%eax
c000649f:	83 ec 08             	sub    $0x8,%esp
c00064a2:	6a 00                	push   $0x0
c00064a4:	50                   	push   %eax
c00064a5:	e8 21 e2 ff ff       	call   c00046cb <sema_init>
c00064aa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:380
		register_handler(channel->irq_no, intr_hd_handler);
c00064ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00064b0:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c00064b4:	0f b6 c0             	movzbl %al,%eax
c00064b7:	83 ec 08             	sub    $0x8,%esp
c00064ba:	68 05 63 00 c0       	push   $0xc0006305
c00064bf:	50                   	push   %eax
c00064c0:	e8 8e b7 ff ff       	call   c0001c53 <register_handler>
c00064c5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:381
		channel_no++;	// 下一个channel
c00064c8:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00064cc:	83 c0 01             	add    $0x1,%eax
c00064cf:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ide.c:357
	channel_cnt = DIV_ROUND_UP(hd_cnt, 2);	// 一个ide通道上有两个硬盘,根据硬盘数量反推有几个ide通道
	struct ide_channel* channel;
	uint8_t channel_no = 0;

	/* 处理每个通道上的硬盘 */
	while (channel_no < channel_cnt) {
c00064d2:	0f b6 05 e0 9c 00 c0 	movzbl 0xc0009ce0,%eax
c00064d9:	38 45 f7             	cmp    %al,-0x9(%ebp)
c00064dc:	0f 82 3e ff ff ff    	jb     c0006420 <ide_init+0x61>
/work/x86_os_my/device/ide.c:383
		直到硬盘完成后通过发中断,由中断处理程序将此信号量sema_up,唤醒线程. */
		sema_init(&channel->disk_done, 0);
		register_handler(channel->irq_no, intr_hd_handler);
		channel_no++;	// 下一个channel
	}
	printk("ide_init done\n");
c00064e2:	83 ec 0c             	sub    $0xc,%esp
c00064e5:	68 04 76 00 c0       	push   $0xc0007604
c00064ea:	e8 06 00 00 00       	call   c00064f5 <printk>
c00064ef:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:384
}
c00064f2:	90                   	nop
c00064f3:	c9                   	leave  
c00064f4:	c3                   	ret    

c00064f5 <printk>:
printk():
/work/x86_os_my/lib/kernel/stdio-kernel.c:11

#define va_start(args, first_fix) args = (va_list)&first_fix
#define va_end(args) args = NULL

/* 供内核使用的格式化输出函数 */
void printk(const char* format, ...) {
c00064f5:	55                   	push   %ebp
c00064f6:	89 e5                	mov    %esp,%ebp
c00064f8:	57                   	push   %edi
c00064f9:	81 ec 14 04 00 00    	sub    $0x414,%esp
/work/x86_os_my/lib/kernel/stdio-kernel.c:13
	va_list args;
	va_start(args, format);
c00064ff:	8d 45 08             	lea    0x8(%ebp),%eax
c0006502:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/stdio-kernel.c:14
	char buf[1024] = {0};
c0006505:	8d 95 f4 fb ff ff    	lea    -0x40c(%ebp),%edx
c000650b:	b8 00 00 00 00       	mov    $0x0,%eax
c0006510:	b9 00 01 00 00       	mov    $0x100,%ecx
c0006515:	89 d7                	mov    %edx,%edi
c0006517:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/lib/kernel/stdio-kernel.c:15
	vsprintf(buf, format, args);
c0006519:	8b 45 08             	mov    0x8(%ebp),%eax
c000651c:	83 ec 04             	sub    $0x4,%esp
c000651f:	ff 75 f4             	pushl  -0xc(%ebp)
c0006522:	50                   	push   %eax
c0006523:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c0006529:	50                   	push   %eax
c000652a:	e8 0c f1 ff ff       	call   c000563b <vsprintf>
c000652f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/stdio-kernel.c:16
	va_end(args);
c0006532:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/kernel/stdio-kernel.c:17
	console_put_str(buf);
c0006539:	83 ec 0c             	sub    $0xc,%esp
c000653c:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c0006542:	50                   	push   %eax
c0006543:	e8 18 e1 ff ff       	call   c0004660 <console_put_str>
c0006548:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/stdio-kernel.c:18
}
c000654b:	90                   	nop
c000654c:	8b 7d fc             	mov    -0x4(%ebp),%edi
c000654f:	c9                   	leave  
c0006550:	c3                   	ret    
