
./build/kernel.bin:     file format elf32-i386


Disassembly of section .text:

c0001500 <main>:
main():
/work/x86_os_my/kernel/main.c:29
*/
/*
用户进程
u_prog_a 的地址是在 0xc0000000 以上，位于内核空间，但这并不表示它无法模拟用户进程。
*/
int main(void) {
c0001500:	8d 4c 24 04          	lea    0x4(%esp),%ecx
c0001504:	83 e4 f0             	and    $0xfffffff0,%esp
c0001507:	ff 71 fc             	pushl  -0x4(%ecx)
c000150a:	55                   	push   %ebp
c000150b:	89 e5                	mov    %esp,%ebp
c000150d:	51                   	push   %ecx
c000150e:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/kernel/main.c:30
	put_str("I am kernel\n");
c0001511:	83 ec 0c             	sub    $0xc,%esp
c0001514:	68 a4 47 00 c0       	push   $0xc00047a4
c0001519:	e8 12 0c 00 00       	call   c0002130 <put_str>
c000151e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:31
	init_all();
c0001521:	e8 e5 00 00 00       	call   c000160b <init_all>
/work/x86_os_my/kernel/main.c:33
	
	thread_start("k_thread_a", 31, k_thread_a, "argA ");
c0001526:	68 b1 47 00 c0       	push   $0xc00047b1
c000152b:	68 89 15 00 c0       	push   $0xc0001589
c0001530:	6a 1f                	push   $0x1f
c0001532:	68 b7 47 00 c0       	push   $0xc00047b7
c0001537:	e8 99 1d 00 00       	call   c00032d5 <thread_start>
c000153c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:34
	thread_start("k_thread_b", 31, k_thread_b, "argB ");
c000153f:	68 c2 47 00 c0       	push   $0xc00047c2
c0001544:	68 b8 15 00 c0       	push   $0xc00015b8
c0001549:	6a 1f                	push   $0x1f
c000154b:	68 c8 47 00 c0       	push   $0xc00047c8
c0001550:	e8 80 1d 00 00       	call   c00032d5 <thread_start>
c0001555:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:35
	process_execute(u_prog_a, "user_prog_a");
c0001558:	83 ec 08             	sub    $0x8,%esp
c000155b:	68 d3 47 00 c0       	push   $0xc00047d3
c0001560:	68 e7 15 00 c0       	push   $0xc00015e7
c0001565:	e8 2a 31 00 00       	call   c0004694 <process_execute>
c000156a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:36
	process_execute(u_prog_b, "user_prog_b");
c000156d:	83 ec 08             	sub    $0x8,%esp
c0001570:	68 df 47 00 c0       	push   $0xc00047df
c0001575:	68 f9 15 00 c0       	push   $0xc00015f9
c000157a:	e8 15 31 00 00       	call   c0004694 <process_execute>
c000157f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:38

	intr_enable();
c0001582:	e8 e7 03 00 00       	call   c000196e <intr_enable>
/work/x86_os_my/kernel/main.c:39 (discriminator 1)
	while(1);
c0001587:	eb fe                	jmp    c0001587 <main+0x87>

c0001589 <k_thread_a>:
k_thread_a():
/work/x86_os_my/kernel/main.c:44
	return 0;
}

/* 在线程中运行的函数 */
void k_thread_a(void* arg) {     
c0001589:	55                   	push   %ebp
c000158a:	89 e5                	mov    %esp,%ebp
c000158c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:45
	char* para = arg;
c000158f:	8b 45 08             	mov    0x8(%ebp),%eax
c0001592:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:47 (discriminator 1)
	while(1) {
		console_put_str(" v_a:0x");
c0001595:	83 ec 0c             	sub    $0xc,%esp
c0001598:	68 eb 47 00 c0       	push   $0xc00047eb
c000159d:	e8 ae 23 00 00       	call   c0003950 <console_put_str>
c00015a2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:48 (discriminator 1)
		console_put_int(test_var_a);
c00015a5:	a1 c0 72 00 c0       	mov    0xc00072c0,%eax
c00015aa:	83 ec 0c             	sub    $0xc,%esp
c00015ad:	50                   	push   %eax
c00015ae:	e8 e7 23 00 00       	call   c000399a <console_put_int>
c00015b3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:49 (discriminator 1)
	}
c00015b6:	eb dd                	jmp    c0001595 <k_thread_a+0xc>

c00015b8 <k_thread_b>:
k_thread_b():
/work/x86_os_my/kernel/main.c:53
}

/* 在线程中运行的函数 */
void k_thread_b(void* arg) {     
c00015b8:	55                   	push   %ebp
c00015b9:	89 e5                	mov    %esp,%ebp
c00015bb:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:54
	char* para = arg;
c00015be:	8b 45 08             	mov    0x8(%ebp),%eax
c00015c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:56 (discriminator 1)
	while(1) {
		console_put_str(" v_b:0x");
c00015c4:	83 ec 0c             	sub    $0xc,%esp
c00015c7:	68 f3 47 00 c0       	push   $0xc00047f3
c00015cc:	e8 7f 23 00 00       	call   c0003950 <console_put_str>
c00015d1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:57 (discriminator 1)
		console_put_int(test_var_b);
c00015d4:	a1 c4 72 00 c0       	mov    0xc00072c4,%eax
c00015d9:	83 ec 0c             	sub    $0xc,%esp
c00015dc:	50                   	push   %eax
c00015dd:	e8 b8 23 00 00       	call   c000399a <console_put_int>
c00015e2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:58 (discriminator 1)
	}
c00015e5:	eb dd                	jmp    c00015c4 <k_thread_b+0xc>

c00015e7 <u_prog_a>:
u_prog_a():
/work/x86_os_my/kernel/main.c:62
}

/* 测试用户进程 */
void u_prog_a(void) {
c00015e7:	55                   	push   %ebp
c00015e8:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/kernel/main.c:64 (discriminator 1)
	while(1) {
		test_var_a++;
c00015ea:	a1 c0 72 00 c0       	mov    0xc00072c0,%eax
c00015ef:	83 c0 01             	add    $0x1,%eax
c00015f2:	a3 c0 72 00 c0       	mov    %eax,0xc00072c0
/work/x86_os_my/kernel/main.c:65 (discriminator 1)
	}
c00015f7:	eb f1                	jmp    c00015ea <u_prog_a+0x3>

c00015f9 <u_prog_b>:
u_prog_b():
/work/x86_os_my/kernel/main.c:69
}

/* 测试用户进程 */
void u_prog_b(void) {
c00015f9:	55                   	push   %ebp
c00015fa:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/kernel/main.c:71 (discriminator 1)
	while(1) {
		test_var_b++;
c00015fc:	a1 c4 72 00 c0       	mov    0xc00072c4,%eax
c0001601:	83 c0 01             	add    $0x1,%eax
c0001604:	a3 c4 72 00 c0       	mov    %eax,0xc00072c4
/work/x86_os_my/kernel/main.c:72 (discriminator 1)
	}
c0001609:	eb f1                	jmp    c00015fc <u_prog_b+0x3>

c000160b <init_all>:
init_all():
/work/x86_os_my/kernel/init.c:12
#include "console.h"
#include "keyboard.h"
#include "tss.h"

/*负责初始化所有模块 */
void init_all() {
c000160b:	55                   	push   %ebp
c000160c:	89 e5                	mov    %esp,%ebp
c000160e:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/init.c:13
	put_str("init_all\n");
c0001611:	83 ec 0c             	sub    $0xc,%esp
c0001614:	68 fb 47 00 c0       	push   $0xc00047fb
c0001619:	e8 12 0b 00 00       	call   c0002130 <put_str>
c000161e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/init.c:14
	idt_init();			// 初始化中断
c0001621:	e8 f9 03 00 00       	call   c0001a1f <idt_init>
/work/x86_os_my/kernel/init.c:15
	mem_init();			// 初始化内存管理系统
c0001626:	e8 5e 17 00 00       	call   c0002d89 <mem_init>
/work/x86_os_my/kernel/init.c:16
	thread_init();		// 初始化线程相关结构
c000162b:	e8 80 20 00 00       	call   c00036b0 <thread_init>
/work/x86_os_my/kernel/init.c:17
	timer_init();		// 初始化PIT
c0001630:	e8 64 05 00 00       	call   c0001b99 <timer_init>
/work/x86_os_my/kernel/init.c:18
	console_init();		// 控制台初始化最好放在开中断之前
c0001635:	e8 cb 22 00 00       	call   c0003905 <console_init>
/work/x86_os_my/kernel/init.c:19
	keyboard_init();	// 键盘初始化
c000163a:	e8 44 29 00 00       	call   c0003f83 <keyboard_init>
/work/x86_os_my/kernel/init.c:20
	tss_init();			// tss初始化
c000163f:	e8 fa 2c 00 00       	call   c000433e <tss_init>
/work/x86_os_my/kernel/init.c:21
}
c0001644:	90                   	nop
c0001645:	c9                   	leave  
c0001646:	c3                   	ret    

c0001647 <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c0001647:	55                   	push   %ebp
c0001648:	89 e5                	mov    %esp,%ebp
c000164a:	83 ec 08             	sub    $0x8,%esp
c000164d:	8b 55 08             	mov    0x8(%ebp),%edx
c0001650:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001653:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0001657:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c000165a:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c000165e:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0001662:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c0001663:	90                   	nop
c0001664:	c9                   	leave  
c0001665:	c3                   	ret    

c0001666 <pic_init>:
pic_init():
/work/x86_os_my/kernel/interrupt.c:39
//自定义类型 intr_handler = void*
extern intr_handler intr_entry_table[IDT_DESC_CNT];	    // 声明引用汇编kernel.S中的中断处理函数入口数组

/* 初始化可编程中断控制器8259A */
// outb 来着 lib/kernel/io.h 内联汇编写法
static void pic_init(void) {
c0001666:	55                   	push   %ebp
c0001667:	89 e5                	mov    %esp,%ebp
c0001669:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:41
	/* 初始化主片 */
	outb (PIC_M_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c000166c:	6a 11                	push   $0x11
c000166e:	6a 20                	push   $0x20
c0001670:	e8 d2 ff ff ff       	call   c0001647 <outb>
c0001675:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:42
	outb (PIC_M_DATA, 0x20);	// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.
c0001678:	6a 20                	push   $0x20
c000167a:	6a 21                	push   $0x21
c000167c:	e8 c6 ff ff ff       	call   c0001647 <outb>
c0001681:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:43
	outb (PIC_M_DATA, 0x04);	// ICW3: IR2接从片. 
c0001684:	6a 04                	push   $0x4
c0001686:	6a 21                	push   $0x21
c0001688:	e8 ba ff ff ff       	call   c0001647 <outb>
c000168d:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:44
	outb (PIC_M_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c0001690:	6a 01                	push   $0x1
c0001692:	6a 21                	push   $0x21
c0001694:	e8 ae ff ff ff       	call   c0001647 <outb>
c0001699:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:47

	/* 初始化从片 */
	outb (PIC_S_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c000169c:	6a 11                	push   $0x11
c000169e:	68 a0 00 00 00       	push   $0xa0
c00016a3:	e8 9f ff ff ff       	call   c0001647 <outb>
c00016a8:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:48
	outb (PIC_S_DATA, 0x28);	// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.
c00016ab:	6a 28                	push   $0x28
c00016ad:	68 a1 00 00 00       	push   $0xa1
c00016b2:	e8 90 ff ff ff       	call   c0001647 <outb>
c00016b7:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:49
	outb (PIC_S_DATA, 0x02);	// ICW3: 设置从片连接到主片的IR2引脚
c00016ba:	6a 02                	push   $0x2
c00016bc:	68 a1 00 00 00       	push   $0xa1
c00016c1:	e8 81 ff ff ff       	call   c0001647 <outb>
c00016c6:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:50
	outb (PIC_S_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c00016c9:	6a 01                	push   $0x1
c00016cb:	68 a1 00 00 00       	push   $0xa1
c00016d0:	e8 72 ff ff ff       	call   c0001647 <outb>
c00016d5:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:53

	/* 打开主片上IR0,也就是目前只接受 时钟0xfe、时钟和键盘0xfc 产生的中断 */
	outb (PIC_M_DATA, 0xfe);
c00016d8:	68 fe 00 00 00       	push   $0xfe
c00016dd:	6a 21                	push   $0x21
c00016df:	e8 63 ff ff ff       	call   c0001647 <outb>
c00016e4:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:54
	outb (PIC_S_DATA, 0xff);
c00016e7:	68 ff 00 00 00       	push   $0xff
c00016ec:	68 a1 00 00 00       	push   $0xa1
c00016f1:	e8 51 ff ff ff       	call   c0001647 <outb>
c00016f6:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:56

	put_str("   pic_init done\n");
c00016f9:	83 ec 0c             	sub    $0xc,%esp
c00016fc:	68 08 48 00 c0       	push   $0xc0004808
c0001701:	e8 2a 0a 00 00       	call   c0002130 <put_str>
c0001706:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:57
}
c0001709:	90                   	nop
c000170a:	c9                   	leave  
c000170b:	c3                   	ret    

c000170c <make_idt_desc>:
make_idt_desc():
/work/x86_os_my/kernel/interrupt.c:60

/* 创建中断门描述符 */
static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function) { 
c000170c:	55                   	push   %ebp
c000170d:	89 e5                	mov    %esp,%ebp
c000170f:	83 ec 04             	sub    $0x4,%esp
c0001712:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001715:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:61
	p_gdesc->func_offset_low_word = (uint32_t)function & 0x0000FFFF;
c0001718:	8b 45 10             	mov    0x10(%ebp),%eax
c000171b:	89 c2                	mov    %eax,%edx
c000171d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001720:	66 89 10             	mov    %dx,(%eax)
/work/x86_os_my/kernel/interrupt.c:62
	p_gdesc->selector = SELECTOR_K_CODE;
c0001723:	8b 45 08             	mov    0x8(%ebp),%eax
c0001726:	66 c7 40 02 08 00    	movw   $0x8,0x2(%eax)
/work/x86_os_my/kernel/interrupt.c:63
	p_gdesc->dcount = 0;
c000172c:	8b 45 08             	mov    0x8(%ebp),%eax
c000172f:	c6 40 04 00          	movb   $0x0,0x4(%eax)
/work/x86_os_my/kernel/interrupt.c:64
	p_gdesc->attribute = attr;
c0001733:	8b 45 08             	mov    0x8(%ebp),%eax
c0001736:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c000173a:	88 50 05             	mov    %dl,0x5(%eax)
/work/x86_os_my/kernel/interrupt.c:65
	p_gdesc->func_offset_high_word = ((uint32_t)function & 0xFFFF0000) >> 16;
c000173d:	8b 45 10             	mov    0x10(%ebp),%eax
c0001740:	c1 e8 10             	shr    $0x10,%eax
c0001743:	89 c2                	mov    %eax,%edx
c0001745:	8b 45 08             	mov    0x8(%ebp),%eax
c0001748:	66 89 50 06          	mov    %dx,0x6(%eax)
/work/x86_os_my/kernel/interrupt.c:66
}
c000174c:	90                   	nop
c000174d:	c9                   	leave  
c000174e:	c3                   	ret    

c000174f <idt_desc_init>:
idt_desc_init():
/work/x86_os_my/kernel/interrupt.c:69

/*初始化中断描述符表*/
static void idt_desc_init(void) {
c000174f:	55                   	push   %ebp
c0001750:	89 e5                	mov    %esp,%ebp
c0001752:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:71
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001755:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000175c:	eb 29                	jmp    c0001787 <idt_desc_init+0x38>
/work/x86_os_my/kernel/interrupt.c:72 (discriminator 3)
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
c000175e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001761:	8b 04 85 60 71 00 c0 	mov    -0x3fff8ea0(,%eax,4),%eax
c0001768:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000176b:	c1 e2 03             	shl    $0x3,%edx
c000176e:	81 c2 e0 72 00 c0    	add    $0xc00072e0,%edx
c0001774:	50                   	push   %eax
c0001775:	68 8e 00 00 00       	push   $0x8e
c000177a:	52                   	push   %edx
c000177b:	e8 8c ff ff ff       	call   c000170c <make_idt_desc>
c0001780:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/kernel/interrupt.c:71 (discriminator 3)
}

/*初始化中断描述符表*/
static void idt_desc_init(void) {
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001783:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:71 (discriminator 1)
c0001787:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
c000178b:	7e d1                	jle    c000175e <idt_desc_init+0xf>
/work/x86_os_my/kernel/interrupt.c:74
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
	}
	put_str("   idt_desc_init done\n");
c000178d:	83 ec 0c             	sub    $0xc,%esp
c0001790:	68 1a 48 00 c0       	push   $0xc000481a
c0001795:	e8 96 09 00 00       	call   c0002130 <put_str>
c000179a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:75
}
c000179d:	90                   	nop
c000179e:	c9                   	leave  
c000179f:	c3                   	ret    

c00017a0 <general_intr_handler>:
general_intr_handler():
/work/x86_os_my/kernel/interrupt.c:78

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
c00017a0:	55                   	push   %ebp
c00017a1:	89 e5                	mov    %esp,%ebp
c00017a3:	83 ec 28             	sub    $0x28,%esp
c00017a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00017a9:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/kernel/interrupt.c:79
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
c00017ac:	80 7d e4 27          	cmpb   $0x27,-0x1c(%ebp)
c00017b0:	0f 84 bf 00 00 00    	je     c0001875 <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:79 (discriminator 1)
c00017b6:	80 7d e4 2f          	cmpb   $0x2f,-0x1c(%ebp)
c00017ba:	0f 84 b5 00 00 00    	je     c0001875 <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:84
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
c00017c0:	83 ec 0c             	sub    $0xc,%esp
c00017c3:	6a 00                	push   $0x0
c00017c5:	e8 b4 0a 00 00       	call   c000227e <set_cursor>
c00017ca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:85
	int cursor_pos = 0;
c00017cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:86
	while(cursor_pos < 320) {
c00017d4:	eb 11                	jmp    c00017e7 <general_intr_handler+0x47>
/work/x86_os_my/kernel/interrupt.c:87
		put_char(' ');
c00017d6:	83 ec 0c             	sub    $0xc,%esp
c00017d9:	6a 20                	push   $0x20
c00017db:	e8 6e 09 00 00       	call   c000214e <put_char>
c00017e0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:88
		cursor_pos++;
c00017e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:86
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
	int cursor_pos = 0;
	while(cursor_pos < 320) {
c00017e7:	81 7d f4 3f 01 00 00 	cmpl   $0x13f,-0xc(%ebp)
c00017ee:	7e e6                	jle    c00017d6 <general_intr_handler+0x36>
/work/x86_os_my/kernel/interrupt.c:92
		put_char(' ');
		cursor_pos++;
	}

	/* 将光标置为左上角 打印信息 */
	set_cursor(0);
c00017f0:	83 ec 0c             	sub    $0xc,%esp
c00017f3:	6a 00                	push   $0x0
c00017f5:	e8 84 0a 00 00       	call   c000227e <set_cursor>
c00017fa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:93
	put_str("!!!!!!!      excetion message begin  !!!!!!!!\n");
c00017fd:	83 ec 0c             	sub    $0xc,%esp
c0001800:	68 34 48 00 c0       	push   $0xc0004834
c0001805:	e8 26 09 00 00       	call   c0002130 <put_str>
c000180a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:94
	set_cursor(88);			// 第2行第8个字符
c000180d:	83 ec 0c             	sub    $0xc,%esp
c0001810:	6a 58                	push   $0x58
c0001812:	e8 67 0a 00 00       	call   c000227e <set_cursor>
c0001817:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:95
	put_str(intr_name[vec_nr]);
c000181a:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c000181e:	8b 04 85 20 75 00 c0 	mov    -0x3fff8ae0(,%eax,4),%eax
c0001825:	83 ec 0c             	sub    $0xc,%esp
c0001828:	50                   	push   %eax
c0001829:	e8 02 09 00 00       	call   c0002130 <put_str>
c000182e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:96
	if (vec_nr == 14) {		// 若为Pagefault,将缺失的地址打印出来并悬停
c0001831:	80 7d e4 0e          	cmpb   $0xe,-0x1c(%ebp)
c0001835:	75 2c                	jne    c0001863 <general_intr_handler+0xc3>
/work/x86_os_my/kernel/interrupt.c:97
		int page_fault_vaddr = 0; 
c0001837:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:98
		asm ("movl %%cr2, %0" : "=r" (page_fault_vaddr));	  // cr2是存放造成page_fault的地址
c000183e:	0f 20 d0             	mov    %cr2,%eax
c0001841:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:99
		put_str("\npage fault addr is ");
c0001844:	83 ec 0c             	sub    $0xc,%esp
c0001847:	68 63 48 00 c0       	push   $0xc0004863
c000184c:	e8 df 08 00 00       	call   c0002130 <put_str>
c0001851:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:100
		put_int(page_fault_vaddr); 
c0001854:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001857:	83 ec 0c             	sub    $0xc,%esp
c000185a:	50                   	push   %eax
c000185b:	e8 bb 09 00 00       	call   c000221b <put_int>
c0001860:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:102
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
c0001863:	83 ec 0c             	sub    $0xc,%esp
c0001866:	68 78 48 00 c0       	push   $0xc0004878
c000186b:	e8 c0 08 00 00       	call   c0002130 <put_str>
c0001870:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:105 (discriminator 1)
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
c0001873:	eb fe                	jmp    c0001873 <general_intr_handler+0xd3>
/work/x86_os_my/kernel/interrupt.c:80
}

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
c0001875:	90                   	nop
/work/x86_os_my/kernel/interrupt.c:106
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
}
c0001876:	c9                   	leave  
c0001877:	c3                   	ret    

c0001878 <exception_init>:
exception_init():
/work/x86_os_my/kernel/interrupt.c:109

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
c0001878:	55                   	push   %ebp
c0001879:	89 e5                	mov    %esp,%ebp
c000187b:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:111
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c000187e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0001885:	eb 20                	jmp    c00018a7 <exception_init+0x2f>
/work/x86_os_my/kernel/interrupt.c:114 (discriminator 3)
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
c0001887:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000188a:	c7 04 85 e0 75 00 c0 	movl   $0xc00017a0,-0x3fff8a20(,%eax,4)
c0001891:	a0 17 00 c0 
/work/x86_os_my/kernel/interrupt.c:115 (discriminator 3)
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
c0001895:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001898:	c7 04 85 20 75 00 c0 	movl   $0xc00048a8,-0x3fff8ae0(,%eax,4)
c000189f:	a8 48 00 c0 
/work/x86_os_my/kernel/interrupt.c:111 (discriminator 3)
}

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c00018a3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:111 (discriminator 1)
c00018a7:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%ebp)
c00018ab:	7e da                	jle    c0001887 <exception_init+0xf>
/work/x86_os_my/kernel/interrupt.c:117
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
	}
	intr_name[0] = "#DE Divide Error";
c00018ad:	c7 05 20 75 00 c0 b0 	movl   $0xc00048b0,0xc0007520
c00018b4:	48 00 c0 
/work/x86_os_my/kernel/interrupt.c:118
	intr_name[1] = "#DB Debug Exception";
c00018b7:	c7 05 24 75 00 c0 c1 	movl   $0xc00048c1,0xc0007524
c00018be:	48 00 c0 
/work/x86_os_my/kernel/interrupt.c:119
	intr_name[2] = "NMI Interrupt";
c00018c1:	c7 05 28 75 00 c0 d5 	movl   $0xc00048d5,0xc0007528
c00018c8:	48 00 c0 
/work/x86_os_my/kernel/interrupt.c:120
	intr_name[3] = "#BP Breakpoint Exception";
c00018cb:	c7 05 2c 75 00 c0 e3 	movl   $0xc00048e3,0xc000752c
c00018d2:	48 00 c0 
/work/x86_os_my/kernel/interrupt.c:121
	intr_name[4] = "#OF Overflow Exception";
c00018d5:	c7 05 30 75 00 c0 fc 	movl   $0xc00048fc,0xc0007530
c00018dc:	48 00 c0 
/work/x86_os_my/kernel/interrupt.c:122
	intr_name[5] = "#BR BOUND Range Exceeded Exception";
c00018df:	c7 05 34 75 00 c0 14 	movl   $0xc0004914,0xc0007534
c00018e6:	49 00 c0 
/work/x86_os_my/kernel/interrupt.c:123
	intr_name[6] = "#UD Invalid Opcode Exception";
c00018e9:	c7 05 38 75 00 c0 37 	movl   $0xc0004937,0xc0007538
c00018f0:	49 00 c0 
/work/x86_os_my/kernel/interrupt.c:124
	intr_name[7] = "#NM Device Not Available Exception";
c00018f3:	c7 05 3c 75 00 c0 54 	movl   $0xc0004954,0xc000753c
c00018fa:	49 00 c0 
/work/x86_os_my/kernel/interrupt.c:125
	intr_name[8] = "#DF Double Fault Exception";
c00018fd:	c7 05 40 75 00 c0 77 	movl   $0xc0004977,0xc0007540
c0001904:	49 00 c0 
/work/x86_os_my/kernel/interrupt.c:126
	intr_name[9] = "Coprocessor Segment Overrun";
c0001907:	c7 05 44 75 00 c0 92 	movl   $0xc0004992,0xc0007544
c000190e:	49 00 c0 
/work/x86_os_my/kernel/interrupt.c:127
	intr_name[10] = "#TS Invalid TSS Exception";
c0001911:	c7 05 48 75 00 c0 ae 	movl   $0xc00049ae,0xc0007548
c0001918:	49 00 c0 
/work/x86_os_my/kernel/interrupt.c:128
	intr_name[11] = "#NP Segment Not Present";
c000191b:	c7 05 4c 75 00 c0 c8 	movl   $0xc00049c8,0xc000754c
c0001922:	49 00 c0 
/work/x86_os_my/kernel/interrupt.c:129
	intr_name[12] = "#SS Stack Fault Exception";
c0001925:	c7 05 50 75 00 c0 e0 	movl   $0xc00049e0,0xc0007550
c000192c:	49 00 c0 
/work/x86_os_my/kernel/interrupt.c:130
	intr_name[13] = "#GP General Protection Exception";
c000192f:	c7 05 54 75 00 c0 fc 	movl   $0xc00049fc,0xc0007554
c0001936:	49 00 c0 
/work/x86_os_my/kernel/interrupt.c:131
	intr_name[14] = "#PF Page-Fault Exception";
c0001939:	c7 05 58 75 00 c0 1d 	movl   $0xc0004a1d,0xc0007558
c0001940:	4a 00 c0 
/work/x86_os_my/kernel/interrupt.c:133
	// intr_name[15] 第15项是intel保留项，未使用
	intr_name[16] = "#MF x87 FPU Floating-Point Error";
c0001943:	c7 05 60 75 00 c0 38 	movl   $0xc0004a38,0xc0007560
c000194a:	4a 00 c0 
/work/x86_os_my/kernel/interrupt.c:134
	intr_name[17] = "#AC Alignment Check Exception";
c000194d:	c7 05 64 75 00 c0 59 	movl   $0xc0004a59,0xc0007564
c0001954:	4a 00 c0 
/work/x86_os_my/kernel/interrupt.c:135
	intr_name[18] = "#MC Machine-Check Exception";
c0001957:	c7 05 68 75 00 c0 77 	movl   $0xc0004a77,0xc0007568
c000195e:	4a 00 c0 
/work/x86_os_my/kernel/interrupt.c:136
	intr_name[19] = "#XF SIMD Floating-Point Exception";
c0001961:	c7 05 6c 75 00 c0 94 	movl   $0xc0004a94,0xc000756c
c0001968:	4a 00 c0 
/work/x86_os_my/kernel/interrupt.c:137
}
c000196b:	90                   	nop
c000196c:	c9                   	leave  
c000196d:	c3                   	ret    

c000196e <intr_enable>:
intr_enable():
/work/x86_os_my/kernel/interrupt.c:140

/* 开中断并返回开中断前的状态*/
enum intr_status intr_enable() {
c000196e:	55                   	push   %ebp
c000196f:	89 e5                	mov    %esp,%ebp
c0001971:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:142
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c0001974:	e8 65 00 00 00       	call   c00019de <intr_get_status>
c0001979:	83 f8 01             	cmp    $0x1,%eax
c000197c:	75 0c                	jne    c000198a <intr_enable+0x1c>
/work/x86_os_my/kernel/interrupt.c:143
		old_status = INTR_ON;
c000197e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:144
		return old_status;
c0001985:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001988:	eb 0b                	jmp    c0001995 <intr_enable+0x27>
/work/x86_os_my/kernel/interrupt.c:146
	} else {
		old_status = INTR_OFF;
c000198a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:147
		asm volatile("sti");	 // 开中断,sti指令将IF位置1
c0001991:	fb                   	sti    
/work/x86_os_my/kernel/interrupt.c:148
		return old_status;
c0001992:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:150
	}
}
c0001995:	c9                   	leave  
c0001996:	c3                   	ret    

c0001997 <intr_disable>:
intr_disable():
/work/x86_os_my/kernel/interrupt.c:153

/* 关中断,并且返回关中断前的状态 */
enum intr_status intr_disable() {     
c0001997:	55                   	push   %ebp
c0001998:	89 e5                	mov    %esp,%ebp
c000199a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:155
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c000199d:	e8 3c 00 00 00       	call   c00019de <intr_get_status>
c00019a2:	83 f8 01             	cmp    $0x1,%eax
c00019a5:	75 0d                	jne    c00019b4 <intr_disable+0x1d>
/work/x86_os_my/kernel/interrupt.c:156
		old_status = INTR_ON;
c00019a7:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:157
		asm volatile("cli" : : : "memory"); // 关中断,cli指令将IF位置0
c00019ae:	fa                   	cli    
/work/x86_os_my/kernel/interrupt.c:158
		return old_status;
c00019af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00019b2:	eb 0a                	jmp    c00019be <intr_disable+0x27>
/work/x86_os_my/kernel/interrupt.c:160
	} else {
		old_status = INTR_OFF;
c00019b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:161
		return old_status;
c00019bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:163
	}
}
c00019be:	c9                   	leave  
c00019bf:	c3                   	ret    

c00019c0 <intr_set_status>:
intr_set_status():
/work/x86_os_my/kernel/interrupt.c:166

/* 将中断状态设置为status */
enum intr_status intr_set_status(enum intr_status status) {
c00019c0:	55                   	push   %ebp
c00019c1:	89 e5                	mov    %esp,%ebp
c00019c3:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:167
	return status & INTR_ON ? intr_enable() : intr_disable();
c00019c6:	8b 45 08             	mov    0x8(%ebp),%eax
c00019c9:	83 e0 01             	and    $0x1,%eax
c00019cc:	85 c0                	test   %eax,%eax
c00019ce:	74 07                	je     c00019d7 <intr_set_status+0x17>
/work/x86_os_my/kernel/interrupt.c:167 (discriminator 1)
c00019d0:	e8 99 ff ff ff       	call   c000196e <intr_enable>
c00019d5:	eb 05                	jmp    c00019dc <intr_set_status+0x1c>
/work/x86_os_my/kernel/interrupt.c:167 (discriminator 2)
c00019d7:	e8 bb ff ff ff       	call   c0001997 <intr_disable>
/work/x86_os_my/kernel/interrupt.c:168 (discriminator 5)
}
c00019dc:	c9                   	leave  
c00019dd:	c3                   	ret    

c00019de <intr_get_status>:
intr_get_status():
/work/x86_os_my/kernel/interrupt.c:171

/* 获取当前中断状态 */
enum intr_status intr_get_status() {
c00019de:	55                   	push   %ebp
c00019df:	89 e5                	mov    %esp,%ebp
c00019e1:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:172
	uint32_t eflags = 0; 
c00019e4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:173
	GET_EFLAGS(eflags);
c00019eb:	9c                   	pushf  
c00019ec:	58                   	pop    %eax
c00019ed:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:174
	return (EFLAGS_IF & eflags) ? INTR_ON : INTR_OFF;
c00019f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00019f3:	25 00 02 00 00       	and    $0x200,%eax
c00019f8:	85 c0                	test   %eax,%eax
c00019fa:	0f 95 c0             	setne  %al
c00019fd:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/kernel/interrupt.c:175
}
c0001a00:	c9                   	leave  
c0001a01:	c3                   	ret    

c0001a02 <register_handler>:
register_handler():
/work/x86_os_my/kernel/interrupt.c:178

/* 在中断处理程序数组第vector_no个元素中注册安装中断处理程序function */
void register_handler(uint8_t vector_no, intr_handler function) {
c0001a02:	55                   	push   %ebp
c0001a03:	89 e5                	mov    %esp,%ebp
c0001a05:	83 ec 04             	sub    $0x4,%esp
c0001a08:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a0b:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:181
/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
 * 见kernel/kernel.S的call [idt_table + %1*4] */
   idt_table[vector_no] = function; 
c0001a0e:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0001a12:	8b 55 0c             	mov    0xc(%ebp),%edx
c0001a15:	89 14 85 e0 75 00 c0 	mov    %edx,-0x3fff8a20(,%eax,4)
/work/x86_os_my/kernel/interrupt.c:182
}
c0001a1c:	90                   	nop
c0001a1d:	c9                   	leave  
c0001a1e:	c3                   	ret    

c0001a1f <idt_init>:
idt_init():
/work/x86_os_my/kernel/interrupt.c:185

/*完成有关中断的所有初始化工作*/
void idt_init() {
c0001a1f:	55                   	push   %ebp
c0001a20:	89 e5                	mov    %esp,%ebp
c0001a22:	56                   	push   %esi
c0001a23:	53                   	push   %ebx
c0001a24:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:186
	put_str("idt_init start\n");
c0001a27:	83 ec 0c             	sub    $0xc,%esp
c0001a2a:	68 b6 4a 00 c0       	push   $0xc0004ab6
c0001a2f:	e8 fc 06 00 00       	call   c0002130 <put_str>
c0001a34:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:187
	idt_desc_init();	// 初始化中断描述符表
c0001a37:	e8 13 fd ff ff       	call   c000174f <idt_desc_init>
/work/x86_os_my/kernel/interrupt.c:188
	exception_init();	// 异常名初始化并注册通常的中断处理函数
c0001a3c:	e8 37 fe ff ff       	call   c0001878 <exception_init>
/work/x86_os_my/kernel/interrupt.c:189
	pic_init();			// 初始化8259A
c0001a41:	e8 20 fc ff ff       	call   c0001666 <pic_init>
/work/x86_os_my/kernel/interrupt.c:193

	/* 加载idt */
	// IDTR 是 48 位的寄存器，低 16 位是 IDT 的界限 = IDT 尺寸大小-1，高 32 位是 IDT 的线性基地址
	uint64_t idt_operand = ((sizeof(idt) - 1) | ((uint64_t)(uint32_t)idt << 16));
c0001a46:	b8 e0 72 00 c0       	mov    $0xc00072e0,%eax
c0001a4b:	ba 00 00 00 00       	mov    $0x0,%edx
c0001a50:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0001a54:	c1 e0 10             	shl    $0x10,%eax
c0001a57:	89 c1                	mov    %eax,%ecx
c0001a59:	81 c9 7f 01 00 00    	or     $0x17f,%ecx
c0001a5f:	89 cb                	mov    %ecx,%ebx
c0001a61:	89 d0                	mov    %edx,%eax
c0001a63:	80 cc 00             	or     $0x0,%ah
c0001a66:	89 c6                	mov    %eax,%esi
c0001a68:	89 5d f0             	mov    %ebx,-0x10(%ebp)
c0001a6b:	89 75 f4             	mov    %esi,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:194
	asm volatile("lidt %0" : : "m" (idt_operand));
c0001a6e:	0f 01 5d f0          	lidtl  -0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:195
	put_str("idt_init done\n");
c0001a72:	83 ec 0c             	sub    $0xc,%esp
c0001a75:	68 c6 4a 00 c0       	push   $0xc0004ac6
c0001a7a:	e8 b1 06 00 00       	call   c0002130 <put_str>
c0001a7f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:196
}
c0001a82:	90                   	nop
c0001a83:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001a86:	5b                   	pop    %ebx
c0001a87:	5e                   	pop    %esi
c0001a88:	5d                   	pop    %ebp
c0001a89:	c3                   	ret    

c0001a8a <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c0001a8a:	55                   	push   %ebp
c0001a8b:	89 e5                	mov    %esp,%ebp
c0001a8d:	83 ec 08             	sub    $0x8,%esp
c0001a90:	8b 55 08             	mov    0x8(%ebp),%edx
c0001a93:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001a96:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0001a9a:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c0001a9d:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0001aa1:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0001aa5:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c0001aa6:	90                   	nop
c0001aa7:	c9                   	leave  
c0001aa8:	c3                   	ret    

c0001aa9 <frequency_set>:
frequency_set():
/work/x86_os_my/device/timer.c:25
/* 把操作的计数器counter_no、读写锁属性rwl、计数器模式counter_mode写入模式控制寄存器并赋予初始值counter_value */
static void frequency_set(uint8_t counter_port, \
		uint8_t counter_no, \
		uint8_t rwl, \
		uint8_t counter_mode, \
		uint16_t counter_value) {
c0001aa9:	55                   	push   %ebp
c0001aaa:	89 e5                	mov    %esp,%ebp
c0001aac:	56                   	push   %esi
c0001aad:	53                   	push   %ebx
c0001aae:	83 ec 14             	sub    $0x14,%esp
c0001ab1:	8b 45 08             	mov    0x8(%ebp),%eax
c0001ab4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c0001ab7:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001aba:	8b 55 14             	mov    0x14(%ebp),%edx
c0001abd:	8b 75 18             	mov    0x18(%ebp),%esi
c0001ac0:	88 45 f4             	mov    %al,-0xc(%ebp)
c0001ac3:	88 5d f0             	mov    %bl,-0x10(%ebp)
c0001ac6:	88 4d ec             	mov    %cl,-0x14(%ebp)
c0001ac9:	88 55 e8             	mov    %dl,-0x18(%ebp)
c0001acc:	66 89 75 e4          	mov    %si,-0x1c(%ebp)
/work/x86_os_my/device/timer.c:27
	/* 往控制字寄存器端口0x43中写入控制字 */
	outb(PIT_CONTROL_PORT, (uint8_t)(counter_no << 6 | rwl << 4 | counter_mode << 1));
c0001ad0:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0001ad4:	c1 e0 06             	shl    $0x6,%eax
c0001ad7:	89 c2                	mov    %eax,%edx
c0001ad9:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0001add:	c1 e0 04             	shl    $0x4,%eax
c0001ae0:	09 c2                	or     %eax,%edx
c0001ae2:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0001ae6:	01 c0                	add    %eax,%eax
c0001ae8:	09 d0                	or     %edx,%eax
c0001aea:	0f b6 c0             	movzbl %al,%eax
c0001aed:	50                   	push   %eax
c0001aee:	6a 43                	push   $0x43
c0001af0:	e8 95 ff ff ff       	call   c0001a8a <outb>
c0001af5:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:29
	/* 先写入counter_value的低8位 */
	outb(counter_port, (uint8_t)counter_value);
c0001af8:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0001afc:	0f b6 d0             	movzbl %al,%edx
c0001aff:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001b03:	52                   	push   %edx
c0001b04:	50                   	push   %eax
c0001b05:	e8 80 ff ff ff       	call   c0001a8a <outb>
c0001b0a:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:31
	/* 再写入counter_value的高8位 */
	outb(counter_port, (uint8_t)counter_value >> 8);
c0001b0d:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001b11:	6a 00                	push   $0x0
c0001b13:	50                   	push   %eax
c0001b14:	e8 71 ff ff ff       	call   c0001a8a <outb>
c0001b19:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:32
}
c0001b1c:	90                   	nop
c0001b1d:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001b20:	5b                   	pop    %ebx
c0001b21:	5e                   	pop    %esi
c0001b22:	5d                   	pop    %ebp
c0001b23:	c3                   	ret    

c0001b24 <intr_timer_handler>:
intr_timer_handler():
/work/x86_os_my/device/timer.c:35

/* 时钟的中断处理函数 */
static void intr_timer_handler(void) {
c0001b24:	55                   	push   %ebp
c0001b25:	89 e5                	mov    %esp,%ebp
c0001b27:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/timer.c:36
	struct task_struct* cur_thread = running_thread();		// 返回线程PCB
c0001b2a:	e8 6b 16 00 00       	call   c000319a <running_thread>
c0001b2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/timer.c:38

	ASSERT(cur_thread->stack_magic == 0x19870916);			// 检查栈是否溢出
c0001b32:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b35:	8b 40 40             	mov    0x40(%eax),%eax
c0001b38:	3d 16 09 87 19       	cmp    $0x19870916,%eax
c0001b3d:	74 19                	je     c0001b58 <intr_timer_handler+0x34>
/work/x86_os_my/device/timer.c:38 (discriminator 1)
c0001b3f:	68 d8 4a 00 c0       	push   $0xc0004ad8
c0001b44:	68 30 4b 00 c0       	push   $0xc0004b30
c0001b49:	6a 26                	push   $0x26
c0001b4b:	68 fe 4a 00 c0       	push   $0xc0004afe
c0001b50:	e8 4d 07 00 00       	call   c00022a2 <panic_spin>
c0001b55:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:40

	cur_thread->elapsed_ticks++;// 记录此线程占用的cpu时间
c0001b58:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b5b:	8b 40 1c             	mov    0x1c(%eax),%eax
c0001b5e:	8d 50 01             	lea    0x1(%eax),%edx
c0001b61:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b64:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/device/timer.c:41
	ticks++;	//从内核第一次处理时间中断开始,至今的滴哒数,是内核态和用户态总共的嘀哒数
c0001b67:	a1 a0 76 00 c0       	mov    0xc00076a0,%eax
c0001b6c:	83 c0 01             	add    $0x1,%eax
c0001b6f:	a3 a0 76 00 c0       	mov    %eax,0xc00076a0
/work/x86_os_my/device/timer.c:43

	if (cur_thread->ticks == 0) {
c0001b74:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b77:	0f b6 40 19          	movzbl 0x19(%eax),%eax
c0001b7b:	84 c0                	test   %al,%al
c0001b7d:	75 07                	jne    c0001b86 <intr_timer_handler+0x62>
/work/x86_os_my/device/timer.c:44
		schedule();				// 若进程时间片用完就开始调度新的进程上cpu
c0001b7f:	e8 a7 18 00 00       	call   c000342b <schedule>
/work/x86_os_my/device/timer.c:48
	} else {
		cur_thread->ticks--;	// 将当前进程的时间片-1
	}
}
c0001b84:	eb 10                	jmp    c0001b96 <intr_timer_handler+0x72>
/work/x86_os_my/device/timer.c:46
	ticks++;	//从内核第一次处理时间中断开始,至今的滴哒数,是内核态和用户态总共的嘀哒数

	if (cur_thread->ticks == 0) {
		schedule();				// 若进程时间片用完就开始调度新的进程上cpu
	} else {
		cur_thread->ticks--;	// 将当前进程的时间片-1
c0001b86:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b89:	0f b6 40 19          	movzbl 0x19(%eax),%eax
c0001b8d:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001b90:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b93:	88 50 19             	mov    %dl,0x19(%eax)
/work/x86_os_my/device/timer.c:48
	}
}
c0001b96:	90                   	nop
c0001b97:	c9                   	leave  
c0001b98:	c3                   	ret    

c0001b99 <timer_init>:
timer_init():
/work/x86_os_my/device/timer.c:51

/* 初始化PIT8253 */
void timer_init() {
c0001b99:	55                   	push   %ebp
c0001b9a:	89 e5                	mov    %esp,%ebp
c0001b9c:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/timer.c:52
	put_str("timer_init start\n");
c0001b9f:	83 ec 0c             	sub    $0xc,%esp
c0001ba2:	68 0d 4b 00 c0       	push   $0xc0004b0d
c0001ba7:	e8 84 05 00 00       	call   c0002130 <put_str>
c0001bac:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:54
	/* 设置8253的定时周期,也就是发中断的周期 */
	frequency_set(CONTRER0_PORT, COUNTER0_NO, READ_WRITE_LATCH, COUNTER_MODE, COUNTER0_VALUE);
c0001baf:	83 ec 0c             	sub    $0xc,%esp
c0001bb2:	68 9b 2e 00 00       	push   $0x2e9b
c0001bb7:	6a 02                	push   $0x2
c0001bb9:	6a 03                	push   $0x3
c0001bbb:	6a 00                	push   $0x0
c0001bbd:	6a 40                	push   $0x40
c0001bbf:	e8 e5 fe ff ff       	call   c0001aa9 <frequency_set>
c0001bc4:	83 c4 20             	add    $0x20,%esp
/work/x86_os_my/device/timer.c:55
	register_handler(0x20, intr_timer_handler);
c0001bc7:	83 ec 08             	sub    $0x8,%esp
c0001bca:	68 24 1b 00 c0       	push   $0xc0001b24
c0001bcf:	6a 20                	push   $0x20
c0001bd1:	e8 2c fe ff ff       	call   c0001a02 <register_handler>
c0001bd6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:56
	put_str("timer_init done\n");
c0001bd9:	83 ec 0c             	sub    $0xc,%esp
c0001bdc:	68 1f 4b 00 c0       	push   $0xc0004b1f
c0001be1:	e8 4a 05 00 00       	call   c0002130 <put_str>
c0001be6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:57
}
c0001be9:	90                   	nop
c0001bea:	c9                   	leave  
c0001beb:	c3                   	ret    
c0001bec:	66 90                	xchg   %ax,%ax
c0001bee:	66 90                	xchg   %ax,%ax

c0001bf0 <intr_exit>:
intr_exit():
c0001bf0:	83 c4 04             	add    $0x4,%esp
c0001bf3:	61                   	popa   
c0001bf4:	0f a9                	pop    %gs
c0001bf6:	0f a1                	pop    %fs
c0001bf8:	07                   	pop    %es
c0001bf9:	1f                   	pop    %ds
c0001bfa:	83 c4 04             	add    $0x4,%esp
c0001bfd:	cf                   	iret   

c0001bfe <intr0x00entry>:
intr0x00entry():
c0001bfe:	6a 00                	push   $0x0
c0001c00:	1e                   	push   %ds
c0001c01:	06                   	push   %es
c0001c02:	0f a0                	push   %fs
c0001c04:	0f a8                	push   %gs
c0001c06:	60                   	pusha  
c0001c07:	b0 20                	mov    $0x20,%al
c0001c09:	e6 a0                	out    %al,$0xa0
c0001c0b:	e6 20                	out    %al,$0x20
c0001c0d:	6a 00                	push   $0x0
c0001c0f:	ff 15 e0 75 00 c0    	call   *0xc00075e0
c0001c15:	eb d9                	jmp    c0001bf0 <intr_exit>

c0001c17 <intr0x01entry>:
intr0x01entry():
c0001c17:	6a 00                	push   $0x0
c0001c19:	1e                   	push   %ds
c0001c1a:	06                   	push   %es
c0001c1b:	0f a0                	push   %fs
c0001c1d:	0f a8                	push   %gs
c0001c1f:	60                   	pusha  
c0001c20:	b0 20                	mov    $0x20,%al
c0001c22:	e6 a0                	out    %al,$0xa0
c0001c24:	e6 20                	out    %al,$0x20
c0001c26:	6a 01                	push   $0x1
c0001c28:	ff 15 e4 75 00 c0    	call   *0xc00075e4
c0001c2e:	eb c0                	jmp    c0001bf0 <intr_exit>

c0001c30 <intr0x02entry>:
intr0x02entry():
c0001c30:	6a 00                	push   $0x0
c0001c32:	1e                   	push   %ds
c0001c33:	06                   	push   %es
c0001c34:	0f a0                	push   %fs
c0001c36:	0f a8                	push   %gs
c0001c38:	60                   	pusha  
c0001c39:	b0 20                	mov    $0x20,%al
c0001c3b:	e6 a0                	out    %al,$0xa0
c0001c3d:	e6 20                	out    %al,$0x20
c0001c3f:	6a 02                	push   $0x2
c0001c41:	ff 15 e8 75 00 c0    	call   *0xc00075e8
c0001c47:	eb a7                	jmp    c0001bf0 <intr_exit>

c0001c49 <intr0x03entry>:
intr0x03entry():
c0001c49:	6a 00                	push   $0x0
c0001c4b:	1e                   	push   %ds
c0001c4c:	06                   	push   %es
c0001c4d:	0f a0                	push   %fs
c0001c4f:	0f a8                	push   %gs
c0001c51:	60                   	pusha  
c0001c52:	b0 20                	mov    $0x20,%al
c0001c54:	e6 a0                	out    %al,$0xa0
c0001c56:	e6 20                	out    %al,$0x20
c0001c58:	6a 03                	push   $0x3
c0001c5a:	ff 15 ec 75 00 c0    	call   *0xc00075ec
c0001c60:	eb 8e                	jmp    c0001bf0 <intr_exit>

c0001c62 <intr0x04entry>:
intr0x04entry():
c0001c62:	6a 00                	push   $0x0
c0001c64:	1e                   	push   %ds
c0001c65:	06                   	push   %es
c0001c66:	0f a0                	push   %fs
c0001c68:	0f a8                	push   %gs
c0001c6a:	60                   	pusha  
c0001c6b:	b0 20                	mov    $0x20,%al
c0001c6d:	e6 a0                	out    %al,$0xa0
c0001c6f:	e6 20                	out    %al,$0x20
c0001c71:	6a 04                	push   $0x4
c0001c73:	ff 15 f0 75 00 c0    	call   *0xc00075f0
c0001c79:	e9 72 ff ff ff       	jmp    c0001bf0 <intr_exit>

c0001c7e <intr0x05entry>:
intr0x05entry():
c0001c7e:	6a 00                	push   $0x0
c0001c80:	1e                   	push   %ds
c0001c81:	06                   	push   %es
c0001c82:	0f a0                	push   %fs
c0001c84:	0f a8                	push   %gs
c0001c86:	60                   	pusha  
c0001c87:	b0 20                	mov    $0x20,%al
c0001c89:	e6 a0                	out    %al,$0xa0
c0001c8b:	e6 20                	out    %al,$0x20
c0001c8d:	6a 05                	push   $0x5
c0001c8f:	ff 15 f4 75 00 c0    	call   *0xc00075f4
c0001c95:	e9 56 ff ff ff       	jmp    c0001bf0 <intr_exit>

c0001c9a <intr0x06entry>:
intr0x06entry():
c0001c9a:	6a 00                	push   $0x0
c0001c9c:	1e                   	push   %ds
c0001c9d:	06                   	push   %es
c0001c9e:	0f a0                	push   %fs
c0001ca0:	0f a8                	push   %gs
c0001ca2:	60                   	pusha  
c0001ca3:	b0 20                	mov    $0x20,%al
c0001ca5:	e6 a0                	out    %al,$0xa0
c0001ca7:	e6 20                	out    %al,$0x20
c0001ca9:	6a 06                	push   $0x6
c0001cab:	ff 15 f8 75 00 c0    	call   *0xc00075f8
c0001cb1:	e9 3a ff ff ff       	jmp    c0001bf0 <intr_exit>

c0001cb6 <intr0x07entry>:
intr0x07entry():
c0001cb6:	6a 00                	push   $0x0
c0001cb8:	1e                   	push   %ds
c0001cb9:	06                   	push   %es
c0001cba:	0f a0                	push   %fs
c0001cbc:	0f a8                	push   %gs
c0001cbe:	60                   	pusha  
c0001cbf:	b0 20                	mov    $0x20,%al
c0001cc1:	e6 a0                	out    %al,$0xa0
c0001cc3:	e6 20                	out    %al,$0x20
c0001cc5:	6a 07                	push   $0x7
c0001cc7:	ff 15 fc 75 00 c0    	call   *0xc00075fc
c0001ccd:	e9 1e ff ff ff       	jmp    c0001bf0 <intr_exit>

c0001cd2 <intr0x08entry>:
intr0x08entry():
c0001cd2:	90                   	nop
c0001cd3:	1e                   	push   %ds
c0001cd4:	06                   	push   %es
c0001cd5:	0f a0                	push   %fs
c0001cd7:	0f a8                	push   %gs
c0001cd9:	60                   	pusha  
c0001cda:	b0 20                	mov    $0x20,%al
c0001cdc:	e6 a0                	out    %al,$0xa0
c0001cde:	e6 20                	out    %al,$0x20
c0001ce0:	6a 08                	push   $0x8
c0001ce2:	ff 15 00 76 00 c0    	call   *0xc0007600
c0001ce8:	e9 03 ff ff ff       	jmp    c0001bf0 <intr_exit>

c0001ced <intr0x09entry>:
intr0x09entry():
c0001ced:	6a 00                	push   $0x0
c0001cef:	1e                   	push   %ds
c0001cf0:	06                   	push   %es
c0001cf1:	0f a0                	push   %fs
c0001cf3:	0f a8                	push   %gs
c0001cf5:	60                   	pusha  
c0001cf6:	b0 20                	mov    $0x20,%al
c0001cf8:	e6 a0                	out    %al,$0xa0
c0001cfa:	e6 20                	out    %al,$0x20
c0001cfc:	6a 09                	push   $0x9
c0001cfe:	ff 15 04 76 00 c0    	call   *0xc0007604
c0001d04:	e9 e7 fe ff ff       	jmp    c0001bf0 <intr_exit>

c0001d09 <intr0x0aentry>:
intr0x0aentry():
c0001d09:	90                   	nop
c0001d0a:	1e                   	push   %ds
c0001d0b:	06                   	push   %es
c0001d0c:	0f a0                	push   %fs
c0001d0e:	0f a8                	push   %gs
c0001d10:	60                   	pusha  
c0001d11:	b0 20                	mov    $0x20,%al
c0001d13:	e6 a0                	out    %al,$0xa0
c0001d15:	e6 20                	out    %al,$0x20
c0001d17:	6a 0a                	push   $0xa
c0001d19:	ff 15 08 76 00 c0    	call   *0xc0007608
c0001d1f:	e9 cc fe ff ff       	jmp    c0001bf0 <intr_exit>

c0001d24 <intr0x0bentry>:
intr0x0bentry():
c0001d24:	90                   	nop
c0001d25:	1e                   	push   %ds
c0001d26:	06                   	push   %es
c0001d27:	0f a0                	push   %fs
c0001d29:	0f a8                	push   %gs
c0001d2b:	60                   	pusha  
c0001d2c:	b0 20                	mov    $0x20,%al
c0001d2e:	e6 a0                	out    %al,$0xa0
c0001d30:	e6 20                	out    %al,$0x20
c0001d32:	6a 0b                	push   $0xb
c0001d34:	ff 15 0c 76 00 c0    	call   *0xc000760c
c0001d3a:	e9 b1 fe ff ff       	jmp    c0001bf0 <intr_exit>

c0001d3f <intr0x0centry>:
intr0x0centry():
c0001d3f:	6a 00                	push   $0x0
c0001d41:	1e                   	push   %ds
c0001d42:	06                   	push   %es
c0001d43:	0f a0                	push   %fs
c0001d45:	0f a8                	push   %gs
c0001d47:	60                   	pusha  
c0001d48:	b0 20                	mov    $0x20,%al
c0001d4a:	e6 a0                	out    %al,$0xa0
c0001d4c:	e6 20                	out    %al,$0x20
c0001d4e:	6a 0c                	push   $0xc
c0001d50:	ff 15 10 76 00 c0    	call   *0xc0007610
c0001d56:	e9 95 fe ff ff       	jmp    c0001bf0 <intr_exit>

c0001d5b <intr0x0dentry>:
intr0x0dentry():
c0001d5b:	90                   	nop
c0001d5c:	1e                   	push   %ds
c0001d5d:	06                   	push   %es
c0001d5e:	0f a0                	push   %fs
c0001d60:	0f a8                	push   %gs
c0001d62:	60                   	pusha  
c0001d63:	b0 20                	mov    $0x20,%al
c0001d65:	e6 a0                	out    %al,$0xa0
c0001d67:	e6 20                	out    %al,$0x20
c0001d69:	6a 0d                	push   $0xd
c0001d6b:	ff 15 14 76 00 c0    	call   *0xc0007614
c0001d71:	e9 7a fe ff ff       	jmp    c0001bf0 <intr_exit>

c0001d76 <intr0x0eentry>:
intr0x0eentry():
c0001d76:	90                   	nop
c0001d77:	1e                   	push   %ds
c0001d78:	06                   	push   %es
c0001d79:	0f a0                	push   %fs
c0001d7b:	0f a8                	push   %gs
c0001d7d:	60                   	pusha  
c0001d7e:	b0 20                	mov    $0x20,%al
c0001d80:	e6 a0                	out    %al,$0xa0
c0001d82:	e6 20                	out    %al,$0x20
c0001d84:	6a 0e                	push   $0xe
c0001d86:	ff 15 18 76 00 c0    	call   *0xc0007618
c0001d8c:	e9 5f fe ff ff       	jmp    c0001bf0 <intr_exit>

c0001d91 <intr0x0fentry>:
intr0x0fentry():
c0001d91:	6a 00                	push   $0x0
c0001d93:	1e                   	push   %ds
c0001d94:	06                   	push   %es
c0001d95:	0f a0                	push   %fs
c0001d97:	0f a8                	push   %gs
c0001d99:	60                   	pusha  
c0001d9a:	b0 20                	mov    $0x20,%al
c0001d9c:	e6 a0                	out    %al,$0xa0
c0001d9e:	e6 20                	out    %al,$0x20
c0001da0:	6a 0f                	push   $0xf
c0001da2:	ff 15 1c 76 00 c0    	call   *0xc000761c
c0001da8:	e9 43 fe ff ff       	jmp    c0001bf0 <intr_exit>

c0001dad <intr0x10entry>:
intr0x10entry():
c0001dad:	6a 00                	push   $0x0
c0001daf:	1e                   	push   %ds
c0001db0:	06                   	push   %es
c0001db1:	0f a0                	push   %fs
c0001db3:	0f a8                	push   %gs
c0001db5:	60                   	pusha  
c0001db6:	b0 20                	mov    $0x20,%al
c0001db8:	e6 a0                	out    %al,$0xa0
c0001dba:	e6 20                	out    %al,$0x20
c0001dbc:	6a 10                	push   $0x10
c0001dbe:	ff 15 20 76 00 c0    	call   *0xc0007620
c0001dc4:	e9 27 fe ff ff       	jmp    c0001bf0 <intr_exit>

c0001dc9 <intr0x11entry>:
intr0x11entry():
c0001dc9:	90                   	nop
c0001dca:	1e                   	push   %ds
c0001dcb:	06                   	push   %es
c0001dcc:	0f a0                	push   %fs
c0001dce:	0f a8                	push   %gs
c0001dd0:	60                   	pusha  
c0001dd1:	b0 20                	mov    $0x20,%al
c0001dd3:	e6 a0                	out    %al,$0xa0
c0001dd5:	e6 20                	out    %al,$0x20
c0001dd7:	6a 11                	push   $0x11
c0001dd9:	ff 15 24 76 00 c0    	call   *0xc0007624
c0001ddf:	e9 0c fe ff ff       	jmp    c0001bf0 <intr_exit>

c0001de4 <intr0x12entry>:
intr0x12entry():
c0001de4:	6a 00                	push   $0x0
c0001de6:	1e                   	push   %ds
c0001de7:	06                   	push   %es
c0001de8:	0f a0                	push   %fs
c0001dea:	0f a8                	push   %gs
c0001dec:	60                   	pusha  
c0001ded:	b0 20                	mov    $0x20,%al
c0001def:	e6 a0                	out    %al,$0xa0
c0001df1:	e6 20                	out    %al,$0x20
c0001df3:	6a 12                	push   $0x12
c0001df5:	ff 15 28 76 00 c0    	call   *0xc0007628
c0001dfb:	e9 f0 fd ff ff       	jmp    c0001bf0 <intr_exit>

c0001e00 <intr0x13entry>:
intr0x13entry():
c0001e00:	6a 00                	push   $0x0
c0001e02:	1e                   	push   %ds
c0001e03:	06                   	push   %es
c0001e04:	0f a0                	push   %fs
c0001e06:	0f a8                	push   %gs
c0001e08:	60                   	pusha  
c0001e09:	b0 20                	mov    $0x20,%al
c0001e0b:	e6 a0                	out    %al,$0xa0
c0001e0d:	e6 20                	out    %al,$0x20
c0001e0f:	6a 13                	push   $0x13
c0001e11:	ff 15 2c 76 00 c0    	call   *0xc000762c
c0001e17:	e9 d4 fd ff ff       	jmp    c0001bf0 <intr_exit>

c0001e1c <intr0x14entry>:
intr0x14entry():
c0001e1c:	6a 00                	push   $0x0
c0001e1e:	1e                   	push   %ds
c0001e1f:	06                   	push   %es
c0001e20:	0f a0                	push   %fs
c0001e22:	0f a8                	push   %gs
c0001e24:	60                   	pusha  
c0001e25:	b0 20                	mov    $0x20,%al
c0001e27:	e6 a0                	out    %al,$0xa0
c0001e29:	e6 20                	out    %al,$0x20
c0001e2b:	6a 14                	push   $0x14
c0001e2d:	ff 15 30 76 00 c0    	call   *0xc0007630
c0001e33:	e9 b8 fd ff ff       	jmp    c0001bf0 <intr_exit>

c0001e38 <intr0x15entry>:
intr0x15entry():
c0001e38:	6a 00                	push   $0x0
c0001e3a:	1e                   	push   %ds
c0001e3b:	06                   	push   %es
c0001e3c:	0f a0                	push   %fs
c0001e3e:	0f a8                	push   %gs
c0001e40:	60                   	pusha  
c0001e41:	b0 20                	mov    $0x20,%al
c0001e43:	e6 a0                	out    %al,$0xa0
c0001e45:	e6 20                	out    %al,$0x20
c0001e47:	6a 15                	push   $0x15
c0001e49:	ff 15 34 76 00 c0    	call   *0xc0007634
c0001e4f:	e9 9c fd ff ff       	jmp    c0001bf0 <intr_exit>

c0001e54 <intr0x16entry>:
intr0x16entry():
c0001e54:	6a 00                	push   $0x0
c0001e56:	1e                   	push   %ds
c0001e57:	06                   	push   %es
c0001e58:	0f a0                	push   %fs
c0001e5a:	0f a8                	push   %gs
c0001e5c:	60                   	pusha  
c0001e5d:	b0 20                	mov    $0x20,%al
c0001e5f:	e6 a0                	out    %al,$0xa0
c0001e61:	e6 20                	out    %al,$0x20
c0001e63:	6a 16                	push   $0x16
c0001e65:	ff 15 38 76 00 c0    	call   *0xc0007638
c0001e6b:	e9 80 fd ff ff       	jmp    c0001bf0 <intr_exit>

c0001e70 <intr0x17entry>:
intr0x17entry():
c0001e70:	6a 00                	push   $0x0
c0001e72:	1e                   	push   %ds
c0001e73:	06                   	push   %es
c0001e74:	0f a0                	push   %fs
c0001e76:	0f a8                	push   %gs
c0001e78:	60                   	pusha  
c0001e79:	b0 20                	mov    $0x20,%al
c0001e7b:	e6 a0                	out    %al,$0xa0
c0001e7d:	e6 20                	out    %al,$0x20
c0001e7f:	6a 17                	push   $0x17
c0001e81:	ff 15 3c 76 00 c0    	call   *0xc000763c
c0001e87:	e9 64 fd ff ff       	jmp    c0001bf0 <intr_exit>

c0001e8c <intr0x18entry>:
intr0x18entry():
c0001e8c:	90                   	nop
c0001e8d:	1e                   	push   %ds
c0001e8e:	06                   	push   %es
c0001e8f:	0f a0                	push   %fs
c0001e91:	0f a8                	push   %gs
c0001e93:	60                   	pusha  
c0001e94:	b0 20                	mov    $0x20,%al
c0001e96:	e6 a0                	out    %al,$0xa0
c0001e98:	e6 20                	out    %al,$0x20
c0001e9a:	6a 18                	push   $0x18
c0001e9c:	ff 15 40 76 00 c0    	call   *0xc0007640
c0001ea2:	e9 49 fd ff ff       	jmp    c0001bf0 <intr_exit>

c0001ea7 <intr0x19entry>:
intr0x19entry():
c0001ea7:	6a 00                	push   $0x0
c0001ea9:	1e                   	push   %ds
c0001eaa:	06                   	push   %es
c0001eab:	0f a0                	push   %fs
c0001ead:	0f a8                	push   %gs
c0001eaf:	60                   	pusha  
c0001eb0:	b0 20                	mov    $0x20,%al
c0001eb2:	e6 a0                	out    %al,$0xa0
c0001eb4:	e6 20                	out    %al,$0x20
c0001eb6:	6a 19                	push   $0x19
c0001eb8:	ff 15 44 76 00 c0    	call   *0xc0007644
c0001ebe:	e9 2d fd ff ff       	jmp    c0001bf0 <intr_exit>

c0001ec3 <intr0x1aentry>:
intr0x1aentry():
c0001ec3:	90                   	nop
c0001ec4:	1e                   	push   %ds
c0001ec5:	06                   	push   %es
c0001ec6:	0f a0                	push   %fs
c0001ec8:	0f a8                	push   %gs
c0001eca:	60                   	pusha  
c0001ecb:	b0 20                	mov    $0x20,%al
c0001ecd:	e6 a0                	out    %al,$0xa0
c0001ecf:	e6 20                	out    %al,$0x20
c0001ed1:	6a 1a                	push   $0x1a
c0001ed3:	ff 15 48 76 00 c0    	call   *0xc0007648
c0001ed9:	e9 12 fd ff ff       	jmp    c0001bf0 <intr_exit>

c0001ede <intr0x1bentry>:
intr0x1bentry():
c0001ede:	90                   	nop
c0001edf:	1e                   	push   %ds
c0001ee0:	06                   	push   %es
c0001ee1:	0f a0                	push   %fs
c0001ee3:	0f a8                	push   %gs
c0001ee5:	60                   	pusha  
c0001ee6:	b0 20                	mov    $0x20,%al
c0001ee8:	e6 a0                	out    %al,$0xa0
c0001eea:	e6 20                	out    %al,$0x20
c0001eec:	6a 1b                	push   $0x1b
c0001eee:	ff 15 4c 76 00 c0    	call   *0xc000764c
c0001ef4:	e9 f7 fc ff ff       	jmp    c0001bf0 <intr_exit>

c0001ef9 <intr0x1centry>:
intr0x1centry():
c0001ef9:	6a 00                	push   $0x0
c0001efb:	1e                   	push   %ds
c0001efc:	06                   	push   %es
c0001efd:	0f a0                	push   %fs
c0001eff:	0f a8                	push   %gs
c0001f01:	60                   	pusha  
c0001f02:	b0 20                	mov    $0x20,%al
c0001f04:	e6 a0                	out    %al,$0xa0
c0001f06:	e6 20                	out    %al,$0x20
c0001f08:	6a 1c                	push   $0x1c
c0001f0a:	ff 15 50 76 00 c0    	call   *0xc0007650
c0001f10:	e9 db fc ff ff       	jmp    c0001bf0 <intr_exit>

c0001f15 <intr0x1dentry>:
intr0x1dentry():
c0001f15:	90                   	nop
c0001f16:	1e                   	push   %ds
c0001f17:	06                   	push   %es
c0001f18:	0f a0                	push   %fs
c0001f1a:	0f a8                	push   %gs
c0001f1c:	60                   	pusha  
c0001f1d:	b0 20                	mov    $0x20,%al
c0001f1f:	e6 a0                	out    %al,$0xa0
c0001f21:	e6 20                	out    %al,$0x20
c0001f23:	6a 1d                	push   $0x1d
c0001f25:	ff 15 54 76 00 c0    	call   *0xc0007654
c0001f2b:	e9 c0 fc ff ff       	jmp    c0001bf0 <intr_exit>

c0001f30 <intr0x1eentry>:
intr0x1eentry():
c0001f30:	90                   	nop
c0001f31:	1e                   	push   %ds
c0001f32:	06                   	push   %es
c0001f33:	0f a0                	push   %fs
c0001f35:	0f a8                	push   %gs
c0001f37:	60                   	pusha  
c0001f38:	b0 20                	mov    $0x20,%al
c0001f3a:	e6 a0                	out    %al,$0xa0
c0001f3c:	e6 20                	out    %al,$0x20
c0001f3e:	6a 1e                	push   $0x1e
c0001f40:	ff 15 58 76 00 c0    	call   *0xc0007658
c0001f46:	e9 a5 fc ff ff       	jmp    c0001bf0 <intr_exit>

c0001f4b <intr0x1fentry>:
intr0x1fentry():
c0001f4b:	6a 00                	push   $0x0
c0001f4d:	1e                   	push   %ds
c0001f4e:	06                   	push   %es
c0001f4f:	0f a0                	push   %fs
c0001f51:	0f a8                	push   %gs
c0001f53:	60                   	pusha  
c0001f54:	b0 20                	mov    $0x20,%al
c0001f56:	e6 a0                	out    %al,$0xa0
c0001f58:	e6 20                	out    %al,$0x20
c0001f5a:	6a 1f                	push   $0x1f
c0001f5c:	ff 15 5c 76 00 c0    	call   *0xc000765c
c0001f62:	e9 89 fc ff ff       	jmp    c0001bf0 <intr_exit>

c0001f67 <intr0x20entry>:
intr0x20entry():
c0001f67:	6a 00                	push   $0x0
c0001f69:	1e                   	push   %ds
c0001f6a:	06                   	push   %es
c0001f6b:	0f a0                	push   %fs
c0001f6d:	0f a8                	push   %gs
c0001f6f:	60                   	pusha  
c0001f70:	b0 20                	mov    $0x20,%al
c0001f72:	e6 a0                	out    %al,$0xa0
c0001f74:	e6 20                	out    %al,$0x20
c0001f76:	6a 20                	push   $0x20
c0001f78:	ff 15 60 76 00 c0    	call   *0xc0007660
c0001f7e:	e9 6d fc ff ff       	jmp    c0001bf0 <intr_exit>

c0001f83 <intr0x21entry>:
intr0x21entry():
c0001f83:	6a 00                	push   $0x0
c0001f85:	1e                   	push   %ds
c0001f86:	06                   	push   %es
c0001f87:	0f a0                	push   %fs
c0001f89:	0f a8                	push   %gs
c0001f8b:	60                   	pusha  
c0001f8c:	b0 20                	mov    $0x20,%al
c0001f8e:	e6 a0                	out    %al,$0xa0
c0001f90:	e6 20                	out    %al,$0x20
c0001f92:	6a 21                	push   $0x21
c0001f94:	ff 15 64 76 00 c0    	call   *0xc0007664
c0001f9a:	e9 51 fc ff ff       	jmp    c0001bf0 <intr_exit>

c0001f9f <intr0x22entry>:
intr0x22entry():
c0001f9f:	6a 00                	push   $0x0
c0001fa1:	1e                   	push   %ds
c0001fa2:	06                   	push   %es
c0001fa3:	0f a0                	push   %fs
c0001fa5:	0f a8                	push   %gs
c0001fa7:	60                   	pusha  
c0001fa8:	b0 20                	mov    $0x20,%al
c0001faa:	e6 a0                	out    %al,$0xa0
c0001fac:	e6 20                	out    %al,$0x20
c0001fae:	6a 22                	push   $0x22
c0001fb0:	ff 15 68 76 00 c0    	call   *0xc0007668
c0001fb6:	e9 35 fc ff ff       	jmp    c0001bf0 <intr_exit>

c0001fbb <intr0x23entry>:
intr0x23entry():
c0001fbb:	6a 00                	push   $0x0
c0001fbd:	1e                   	push   %ds
c0001fbe:	06                   	push   %es
c0001fbf:	0f a0                	push   %fs
c0001fc1:	0f a8                	push   %gs
c0001fc3:	60                   	pusha  
c0001fc4:	b0 20                	mov    $0x20,%al
c0001fc6:	e6 a0                	out    %al,$0xa0
c0001fc8:	e6 20                	out    %al,$0x20
c0001fca:	6a 23                	push   $0x23
c0001fcc:	ff 15 6c 76 00 c0    	call   *0xc000766c
c0001fd2:	e9 19 fc ff ff       	jmp    c0001bf0 <intr_exit>

c0001fd7 <intr0x24entry>:
intr0x24entry():
c0001fd7:	6a 00                	push   $0x0
c0001fd9:	1e                   	push   %ds
c0001fda:	06                   	push   %es
c0001fdb:	0f a0                	push   %fs
c0001fdd:	0f a8                	push   %gs
c0001fdf:	60                   	pusha  
c0001fe0:	b0 20                	mov    $0x20,%al
c0001fe2:	e6 a0                	out    %al,$0xa0
c0001fe4:	e6 20                	out    %al,$0x20
c0001fe6:	6a 24                	push   $0x24
c0001fe8:	ff 15 70 76 00 c0    	call   *0xc0007670
c0001fee:	e9 fd fb ff ff       	jmp    c0001bf0 <intr_exit>

c0001ff3 <intr0x25entry>:
intr0x25entry():
c0001ff3:	6a 00                	push   $0x0
c0001ff5:	1e                   	push   %ds
c0001ff6:	06                   	push   %es
c0001ff7:	0f a0                	push   %fs
c0001ff9:	0f a8                	push   %gs
c0001ffb:	60                   	pusha  
c0001ffc:	b0 20                	mov    $0x20,%al
c0001ffe:	e6 a0                	out    %al,$0xa0
c0002000:	e6 20                	out    %al,$0x20
c0002002:	6a 25                	push   $0x25
c0002004:	ff 15 74 76 00 c0    	call   *0xc0007674
c000200a:	e9 e1 fb ff ff       	jmp    c0001bf0 <intr_exit>

c000200f <intr0x26entry>:
intr0x26entry():
c000200f:	6a 00                	push   $0x0
c0002011:	1e                   	push   %ds
c0002012:	06                   	push   %es
c0002013:	0f a0                	push   %fs
c0002015:	0f a8                	push   %gs
c0002017:	60                   	pusha  
c0002018:	b0 20                	mov    $0x20,%al
c000201a:	e6 a0                	out    %al,$0xa0
c000201c:	e6 20                	out    %al,$0x20
c000201e:	6a 26                	push   $0x26
c0002020:	ff 15 78 76 00 c0    	call   *0xc0007678
c0002026:	e9 c5 fb ff ff       	jmp    c0001bf0 <intr_exit>

c000202b <intr0x27entry>:
intr0x27entry():
c000202b:	6a 00                	push   $0x0
c000202d:	1e                   	push   %ds
c000202e:	06                   	push   %es
c000202f:	0f a0                	push   %fs
c0002031:	0f a8                	push   %gs
c0002033:	60                   	pusha  
c0002034:	b0 20                	mov    $0x20,%al
c0002036:	e6 a0                	out    %al,$0xa0
c0002038:	e6 20                	out    %al,$0x20
c000203a:	6a 27                	push   $0x27
c000203c:	ff 15 7c 76 00 c0    	call   *0xc000767c
c0002042:	e9 a9 fb ff ff       	jmp    c0001bf0 <intr_exit>

c0002047 <intr0x28entry>:
intr0x28entry():
c0002047:	6a 00                	push   $0x0
c0002049:	1e                   	push   %ds
c000204a:	06                   	push   %es
c000204b:	0f a0                	push   %fs
c000204d:	0f a8                	push   %gs
c000204f:	60                   	pusha  
c0002050:	b0 20                	mov    $0x20,%al
c0002052:	e6 a0                	out    %al,$0xa0
c0002054:	e6 20                	out    %al,$0x20
c0002056:	6a 28                	push   $0x28
c0002058:	ff 15 80 76 00 c0    	call   *0xc0007680
c000205e:	e9 8d fb ff ff       	jmp    c0001bf0 <intr_exit>

c0002063 <intr0x29entry>:
intr0x29entry():
c0002063:	6a 00                	push   $0x0
c0002065:	1e                   	push   %ds
c0002066:	06                   	push   %es
c0002067:	0f a0                	push   %fs
c0002069:	0f a8                	push   %gs
c000206b:	60                   	pusha  
c000206c:	b0 20                	mov    $0x20,%al
c000206e:	e6 a0                	out    %al,$0xa0
c0002070:	e6 20                	out    %al,$0x20
c0002072:	6a 29                	push   $0x29
c0002074:	ff 15 84 76 00 c0    	call   *0xc0007684
c000207a:	e9 71 fb ff ff       	jmp    c0001bf0 <intr_exit>

c000207f <intr0x2aentry>:
intr0x2aentry():
c000207f:	6a 00                	push   $0x0
c0002081:	1e                   	push   %ds
c0002082:	06                   	push   %es
c0002083:	0f a0                	push   %fs
c0002085:	0f a8                	push   %gs
c0002087:	60                   	pusha  
c0002088:	b0 20                	mov    $0x20,%al
c000208a:	e6 a0                	out    %al,$0xa0
c000208c:	e6 20                	out    %al,$0x20
c000208e:	6a 2a                	push   $0x2a
c0002090:	ff 15 88 76 00 c0    	call   *0xc0007688
c0002096:	e9 55 fb ff ff       	jmp    c0001bf0 <intr_exit>

c000209b <intr0x2bentry>:
intr0x2bentry():
c000209b:	6a 00                	push   $0x0
c000209d:	1e                   	push   %ds
c000209e:	06                   	push   %es
c000209f:	0f a0                	push   %fs
c00020a1:	0f a8                	push   %gs
c00020a3:	60                   	pusha  
c00020a4:	b0 20                	mov    $0x20,%al
c00020a6:	e6 a0                	out    %al,$0xa0
c00020a8:	e6 20                	out    %al,$0x20
c00020aa:	6a 2b                	push   $0x2b
c00020ac:	ff 15 8c 76 00 c0    	call   *0xc000768c
c00020b2:	e9 39 fb ff ff       	jmp    c0001bf0 <intr_exit>

c00020b7 <intr0x2centry>:
intr0x2centry():
c00020b7:	6a 00                	push   $0x0
c00020b9:	1e                   	push   %ds
c00020ba:	06                   	push   %es
c00020bb:	0f a0                	push   %fs
c00020bd:	0f a8                	push   %gs
c00020bf:	60                   	pusha  
c00020c0:	b0 20                	mov    $0x20,%al
c00020c2:	e6 a0                	out    %al,$0xa0
c00020c4:	e6 20                	out    %al,$0x20
c00020c6:	6a 2c                	push   $0x2c
c00020c8:	ff 15 90 76 00 c0    	call   *0xc0007690
c00020ce:	e9 1d fb ff ff       	jmp    c0001bf0 <intr_exit>

c00020d3 <intr0x2dentry>:
intr0x2dentry():
c00020d3:	6a 00                	push   $0x0
c00020d5:	1e                   	push   %ds
c00020d6:	06                   	push   %es
c00020d7:	0f a0                	push   %fs
c00020d9:	0f a8                	push   %gs
c00020db:	60                   	pusha  
c00020dc:	b0 20                	mov    $0x20,%al
c00020de:	e6 a0                	out    %al,$0xa0
c00020e0:	e6 20                	out    %al,$0x20
c00020e2:	6a 2d                	push   $0x2d
c00020e4:	ff 15 94 76 00 c0    	call   *0xc0007694
c00020ea:	e9 01 fb ff ff       	jmp    c0001bf0 <intr_exit>

c00020ef <intr0x2eentry>:
intr0x2eentry():
c00020ef:	6a 00                	push   $0x0
c00020f1:	1e                   	push   %ds
c00020f2:	06                   	push   %es
c00020f3:	0f a0                	push   %fs
c00020f5:	0f a8                	push   %gs
c00020f7:	60                   	pusha  
c00020f8:	b0 20                	mov    $0x20,%al
c00020fa:	e6 a0                	out    %al,$0xa0
c00020fc:	e6 20                	out    %al,$0x20
c00020fe:	6a 2e                	push   $0x2e
c0002100:	ff 15 98 76 00 c0    	call   *0xc0007698
c0002106:	e9 e5 fa ff ff       	jmp    c0001bf0 <intr_exit>

c000210b <intr0x2fentry>:
intr0x2fentry():
c000210b:	6a 00                	push   $0x0
c000210d:	1e                   	push   %ds
c000210e:	06                   	push   %es
c000210f:	0f a0                	push   %fs
c0002111:	0f a8                	push   %gs
c0002113:	60                   	pusha  
c0002114:	b0 20                	mov    $0x20,%al
c0002116:	e6 a0                	out    %al,$0xa0
c0002118:	e6 20                	out    %al,$0x20
c000211a:	6a 2f                	push   $0x2f
c000211c:	ff 15 9c 76 00 c0    	call   *0xc000769c
c0002122:	e9 c9 fa ff ff       	jmp    c0001bf0 <intr_exit>
c0002127:	66 90                	xchg   %ax,%ax
c0002129:	66 90                	xchg   %ax,%ax
c000212b:	66 90                	xchg   %ax,%ax
c000212d:	66 90                	xchg   %ax,%ax
c000212f:	90                   	nop

c0002130 <put_str>:
put_str():
c0002130:	53                   	push   %ebx
c0002131:	51                   	push   %ecx
c0002132:	31 c9                	xor    %ecx,%ecx
c0002134:	8b 5c 24 0c          	mov    0xc(%esp),%ebx

c0002138 <put_str.goon>:
put_str.goon():
c0002138:	8a 0b                	mov    (%ebx),%cl
c000213a:	80 f9 00             	cmp    $0x0,%cl
c000213d:	74 0c                	je     c000214b <put_str.str_over>
c000213f:	51                   	push   %ecx
c0002140:	e8 09 00 00 00       	call   c000214e <put_char>
c0002145:	83 c4 04             	add    $0x4,%esp
c0002148:	43                   	inc    %ebx
c0002149:	eb ed                	jmp    c0002138 <put_str.goon>

c000214b <put_str.str_over>:
put_str.str_over():
c000214b:	59                   	pop    %ecx
c000214c:	5b                   	pop    %ebx
c000214d:	c3                   	ret    

c000214e <put_char>:
put_char():
c000214e:	60                   	pusha  
c000214f:	66 b8 18 00          	mov    $0x18,%ax
c0002153:	8e e8                	mov    %eax,%gs
c0002155:	66 ba d4 03          	mov    $0x3d4,%dx
c0002159:	b0 0e                	mov    $0xe,%al
c000215b:	ee                   	out    %al,(%dx)
c000215c:	66 ba d5 03          	mov    $0x3d5,%dx
c0002160:	ec                   	in     (%dx),%al
c0002161:	88 c4                	mov    %al,%ah
c0002163:	66 ba d4 03          	mov    $0x3d4,%dx
c0002167:	b0 0f                	mov    $0xf,%al
c0002169:	ee                   	out    %al,(%dx)
c000216a:	66 ba d5 03          	mov    $0x3d5,%dx
c000216e:	ec                   	in     (%dx),%al
c000216f:	66 89 c3             	mov    %ax,%bx
c0002172:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0002176:	80 f9 0d             	cmp    $0xd,%cl
c0002179:	74 3c                	je     c00021b7 <put_char.is_carriage_return>
c000217b:	80 f9 0a             	cmp    $0xa,%cl
c000217e:	74 37                	je     c00021b7 <put_char.is_carriage_return>
c0002180:	80 f9 08             	cmp    $0x8,%cl
c0002183:	74 02                	je     c0002187 <put_char.is_backspace>
c0002185:	eb 16                	jmp    c000219d <put_char.put_other>

c0002187 <put_char.is_backspace>:
put_char.is_backspace():
c0002187:	66 4b                	dec    %bx
c0002189:	66 d1 e3             	shl    %bx
c000218c:	65 67 c6 07 20       	movb   $0x20,%gs:(%bx)
c0002191:	66 43                	inc    %bx
c0002193:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c0002198:	66 d1 eb             	shr    %bx
c000219b:	eb 60                	jmp    c00021fd <put_char.set_cursor>

c000219d <put_char.put_other>:
put_char.put_other():
c000219d:	66 d1 e3             	shl    %bx
c00021a0:	65 67 88 0f          	mov    %cl,%gs:(%bx)
c00021a4:	66 43                	inc    %bx
c00021a6:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c00021ab:	66 d1 eb             	shr    %bx
c00021ae:	66 43                	inc    %bx
c00021b0:	66 81 fb d0 07       	cmp    $0x7d0,%bx
c00021b5:	7c 46                	jl     c00021fd <put_char.set_cursor>

c00021b7 <put_char.is_carriage_return>:
put_char.is_line_feed():
c00021b7:	66 31 d2             	xor    %dx,%dx
c00021ba:	66 89 d8             	mov    %bx,%ax
c00021bd:	66 be 50 00          	mov    $0x50,%si
c00021c1:	66 f7 f6             	div    %si
c00021c4:	66 29 d3             	sub    %dx,%bx

c00021c7 <put_char.is_carriage_return_end>:
put_char.is_carriage_return_end():
c00021c7:	66 83 c3 50          	add    $0x50,%bx
c00021cb:	66 81 fb d0 07       	cmp    $0x7d0,%bx

c00021d0 <put_char.is_line_feed_end>:
put_char.is_line_feed_end():
c00021d0:	7c 2b                	jl     c00021fd <put_char.set_cursor>

c00021d2 <put_char.roll_screen>:
put_char.roll_screen():
c00021d2:	fc                   	cld    
c00021d3:	b9 c0 03 00 00       	mov    $0x3c0,%ecx
c00021d8:	be a0 80 0b 00       	mov    $0xb80a0,%esi
c00021dd:	bf 00 80 0b 00       	mov    $0xb8000,%edi
c00021e2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
c00021e4:	bb 00 0f 00 00       	mov    $0xf00,%ebx
c00021e9:	b9 50 00 00 00       	mov    $0x50,%ecx

c00021ee <put_char.cls>:
put_char.cls():
c00021ee:	65 66 c7 03 20 07    	movw   $0x720,%gs:(%ebx)
c00021f4:	83 c3 02             	add    $0x2,%ebx
c00021f7:	e2 f5                	loop   c00021ee <put_char.cls>
c00021f9:	66 bb 80 07          	mov    $0x780,%bx

c00021fd <put_char.set_cursor>:
put_char.set_cursor():
c00021fd:	66 ba d4 03          	mov    $0x3d4,%dx
c0002201:	b0 0e                	mov    $0xe,%al
c0002203:	ee                   	out    %al,(%dx)
c0002204:	66 ba d5 03          	mov    $0x3d5,%dx
c0002208:	88 f8                	mov    %bh,%al
c000220a:	ee                   	out    %al,(%dx)
c000220b:	66 ba d4 03          	mov    $0x3d4,%dx
c000220f:	b0 0f                	mov    $0xf,%al
c0002211:	ee                   	out    %al,(%dx)
c0002212:	66 ba d5 03          	mov    $0x3d5,%dx
c0002216:	88 d8                	mov    %bl,%al
c0002218:	ee                   	out    %al,(%dx)

c0002219 <put_char.put_char_done>:
put_char.put_char_done():
c0002219:	61                   	popa   
c000221a:	c3                   	ret    

c000221b <put_int>:
put_int():
c000221b:	60                   	pusha  
c000221c:	89 e5                	mov    %esp,%ebp
c000221e:	8b 45 24             	mov    0x24(%ebp),%eax
c0002221:	89 c2                	mov    %eax,%edx
c0002223:	bf 07 00 00 00       	mov    $0x7,%edi
c0002228:	b9 08 00 00 00       	mov    $0x8,%ecx
c000222d:	bb 20 72 00 c0       	mov    $0xc0007220,%ebx

c0002232 <put_int.16based_4bits>:
put_int.16based_4bits():
c0002232:	83 e2 0f             	and    $0xf,%edx
c0002235:	83 fa 09             	cmp    $0x9,%edx
c0002238:	7f 05                	jg     c000223f <put_int.is_A2F>
c000223a:	83 c2 30             	add    $0x30,%edx
c000223d:	eb 06                	jmp    c0002245 <put_int.store>

c000223f <put_int.is_A2F>:
put_int.is_A2F():
c000223f:	83 ea 0a             	sub    $0xa,%edx
c0002242:	83 c2 41             	add    $0x41,%edx

c0002245 <put_int.store>:
put_int.store():
c0002245:	88 14 3b             	mov    %dl,(%ebx,%edi,1)
c0002248:	4f                   	dec    %edi
c0002249:	c1 e8 04             	shr    $0x4,%eax
c000224c:	89 c2                	mov    %eax,%edx
c000224e:	e2 e2                	loop   c0002232 <put_int.16based_4bits>

c0002250 <put_int.ready_to_print>:
put_int.ready_to_print():
c0002250:	47                   	inc    %edi

c0002251 <put_int.skip_prefix_0>:
put_int.skip_prefix_0():
c0002251:	83 ff 08             	cmp    $0x8,%edi
c0002254:	74 0f                	je     c0002265 <put_int.full0>

c0002256 <put_int.go_on_skip>:
put_int.go_on_skip():
c0002256:	8a 8f 20 72 00 c0    	mov    -0x3fff8de0(%edi),%cl
c000225c:	47                   	inc    %edi
c000225d:	80 f9 30             	cmp    $0x30,%cl
c0002260:	74 ef                	je     c0002251 <put_int.skip_prefix_0>
c0002262:	4f                   	dec    %edi
c0002263:	eb 02                	jmp    c0002267 <put_int.put_each_num>

c0002265 <put_int.full0>:
put_int.full0():
c0002265:	b1 30                	mov    $0x30,%cl

c0002267 <put_int.put_each_num>:
put_int.put_each_num():
c0002267:	51                   	push   %ecx
c0002268:	e8 e1 fe ff ff       	call   c000214e <put_char>
c000226d:	83 c4 04             	add    $0x4,%esp
c0002270:	47                   	inc    %edi
c0002271:	8a 8f 20 72 00 c0    	mov    -0x3fff8de0(%edi),%cl
c0002277:	83 ff 08             	cmp    $0x8,%edi
c000227a:	7c eb                	jl     c0002267 <put_int.put_each_num>
c000227c:	61                   	popa   
c000227d:	c3                   	ret    

c000227e <set_cursor>:
set_cursor():
c000227e:	60                   	pusha  
c000227f:	66 8b 5c 24 24       	mov    0x24(%esp),%bx
c0002284:	66 ba d4 03          	mov    $0x3d4,%dx
c0002288:	b0 0e                	mov    $0xe,%al
c000228a:	ee                   	out    %al,(%dx)
c000228b:	66 ba d5 03          	mov    $0x3d5,%dx
c000228f:	88 f8                	mov    %bh,%al
c0002291:	ee                   	out    %al,(%dx)
c0002292:	66 ba d4 03          	mov    $0x3d4,%dx
c0002296:	b0 0f                	mov    $0xf,%al
c0002298:	ee                   	out    %al,(%dx)
c0002299:	66 ba d5 03          	mov    $0x3d5,%dx
c000229d:	88 d8                	mov    %bl,%al
c000229f:	ee                   	out    %al,(%dx)
c00022a0:	61                   	popa   
c00022a1:	c3                   	ret    

c00022a2 <panic_spin>:
panic_spin():
/work/x86_os_my/kernel/debug.c:10
/* 打印文件名,行号,函数名,条件并使程序悬停 */
void panic_spin(char* filename,	       \
	        int line,	       \
		const char* func,      \
		const char* condition) \
{
c00022a2:	55                   	push   %ebp
c00022a3:	89 e5                	mov    %esp,%ebp
c00022a5:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/debug.c:11
   intr_disable();	// 因为有时候会单独调用panic_spin,所以在此处关中断。
c00022a8:	e8 ea f6 ff ff       	call   c0001997 <intr_disable>
/work/x86_os_my/kernel/debug.c:12
   put_str("\n\n\n!!!!! error !!!!!\n");
c00022ad:	83 ec 0c             	sub    $0xc,%esp
c00022b0:	68 43 4b 00 c0       	push   $0xc0004b43
c00022b5:	e8 76 fe ff ff       	call   c0002130 <put_str>
c00022ba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:13
   put_str("filename:");put_str(filename);put_str("\n");
c00022bd:	83 ec 0c             	sub    $0xc,%esp
c00022c0:	68 59 4b 00 c0       	push   $0xc0004b59
c00022c5:	e8 66 fe ff ff       	call   c0002130 <put_str>
c00022ca:	83 c4 10             	add    $0x10,%esp
c00022cd:	83 ec 0c             	sub    $0xc,%esp
c00022d0:	ff 75 08             	pushl  0x8(%ebp)
c00022d3:	e8 58 fe ff ff       	call   c0002130 <put_str>
c00022d8:	83 c4 10             	add    $0x10,%esp
c00022db:	83 ec 0c             	sub    $0xc,%esp
c00022de:	68 63 4b 00 c0       	push   $0xc0004b63
c00022e3:	e8 48 fe ff ff       	call   c0002130 <put_str>
c00022e8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:14
   put_str("line:0x");put_int(line);put_str("\n");
c00022eb:	83 ec 0c             	sub    $0xc,%esp
c00022ee:	68 65 4b 00 c0       	push   $0xc0004b65
c00022f3:	e8 38 fe ff ff       	call   c0002130 <put_str>
c00022f8:	83 c4 10             	add    $0x10,%esp
c00022fb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00022fe:	83 ec 0c             	sub    $0xc,%esp
c0002301:	50                   	push   %eax
c0002302:	e8 14 ff ff ff       	call   c000221b <put_int>
c0002307:	83 c4 10             	add    $0x10,%esp
c000230a:	83 ec 0c             	sub    $0xc,%esp
c000230d:	68 63 4b 00 c0       	push   $0xc0004b63
c0002312:	e8 19 fe ff ff       	call   c0002130 <put_str>
c0002317:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:15
   put_str("function:");put_str((char*)func);put_str("\n");
c000231a:	83 ec 0c             	sub    $0xc,%esp
c000231d:	68 6d 4b 00 c0       	push   $0xc0004b6d
c0002322:	e8 09 fe ff ff       	call   c0002130 <put_str>
c0002327:	83 c4 10             	add    $0x10,%esp
c000232a:	83 ec 0c             	sub    $0xc,%esp
c000232d:	ff 75 10             	pushl  0x10(%ebp)
c0002330:	e8 fb fd ff ff       	call   c0002130 <put_str>
c0002335:	83 c4 10             	add    $0x10,%esp
c0002338:	83 ec 0c             	sub    $0xc,%esp
c000233b:	68 63 4b 00 c0       	push   $0xc0004b63
c0002340:	e8 eb fd ff ff       	call   c0002130 <put_str>
c0002345:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:16
   put_str("condition:");put_str((char*)condition);put_str("\n");
c0002348:	83 ec 0c             	sub    $0xc,%esp
c000234b:	68 77 4b 00 c0       	push   $0xc0004b77
c0002350:	e8 db fd ff ff       	call   c0002130 <put_str>
c0002355:	83 c4 10             	add    $0x10,%esp
c0002358:	83 ec 0c             	sub    $0xc,%esp
c000235b:	ff 75 14             	pushl  0x14(%ebp)
c000235e:	e8 cd fd ff ff       	call   c0002130 <put_str>
c0002363:	83 c4 10             	add    $0x10,%esp
c0002366:	83 ec 0c             	sub    $0xc,%esp
c0002369:	68 63 4b 00 c0       	push   $0xc0004b63
c000236e:	e8 bd fd ff ff       	call   c0002130 <put_str>
c0002373:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:17 (discriminator 1)
   while(1);
c0002376:	eb fe                	jmp    c0002376 <panic_spin+0xd4>

c0002378 <bitmap_init>:
bitmap_init():
/work/x86_os_my/lib/kernel/bitmap.c:16
	uint8_t* bits;				位图空间
};
*/

/* 将位图btmp初始化 */
void bitmap_init(struct bitmap* btmp) {
c0002378:	55                   	push   %ebp
c0002379:	89 e5                	mov    %esp,%ebp
c000237b:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/bitmap.c:17
	memset(btmp->bits, 0, btmp->btmp_bytes_len);   
c000237e:	8b 45 08             	mov    0x8(%ebp),%eax
c0002381:	8b 10                	mov    (%eax),%edx
c0002383:	8b 45 08             	mov    0x8(%ebp),%eax
c0002386:	8b 40 04             	mov    0x4(%eax),%eax
c0002389:	83 ec 04             	sub    $0x4,%esp
c000238c:	52                   	push   %edx
c000238d:	6a 00                	push   $0x0
c000238f:	50                   	push   %eax
c0002390:	e8 35 0a 00 00       	call   c0002dca <memset>
c0002395:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:18
}
c0002398:	90                   	nop
c0002399:	c9                   	leave  
c000239a:	c3                   	ret    

c000239b <bitmap_scan_test>:
bitmap_scan_test():
/work/x86_os_my/lib/kernel/bitmap.c:23

/* 判断bit_idx位是否为1
若为1则返回true
否则返回false */
bool bitmap_scan_test(struct bitmap* btmp, uint32_t bit_idx) {
c000239b:	55                   	push   %ebp
c000239c:	89 e5                	mov    %esp,%ebp
c000239e:	53                   	push   %ebx
c000239f:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:24
	uint32_t byte_idx = bit_idx / 8;    // 向下取整用于索引数组下标
c00023a2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00023a5:	c1 e8 03             	shr    $0x3,%eax
c00023a8:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:25
	uint32_t bit_odd  = bit_idx % 8;    // 取余用于索引数组内的位
c00023ab:	8b 45 0c             	mov    0xc(%ebp),%eax
c00023ae:	83 e0 07             	and    $0x7,%eax
c00023b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:26
	return (btmp->bits[byte_idx] & (BITMAP_MASK << bit_odd));
c00023b4:	8b 45 08             	mov    0x8(%ebp),%eax
c00023b7:	8b 50 04             	mov    0x4(%eax),%edx
c00023ba:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00023bd:	01 d0                	add    %edx,%eax
c00023bf:	0f b6 00             	movzbl (%eax),%eax
c00023c2:	0f b6 d0             	movzbl %al,%edx
c00023c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00023c8:	bb 01 00 00 00       	mov    $0x1,%ebx
c00023cd:	89 c1                	mov    %eax,%ecx
c00023cf:	d3 e3                	shl    %cl,%ebx
c00023d1:	89 d8                	mov    %ebx,%eax
c00023d3:	21 d0                	and    %edx,%eax
/work/x86_os_my/lib/kernel/bitmap.c:27
}
c00023d5:	83 c4 10             	add    $0x10,%esp
c00023d8:	5b                   	pop    %ebx
c00023d9:	5d                   	pop    %ebp
c00023da:	c3                   	ret    

c00023db <bitmap_scan>:
bitmap_scan():
/work/x86_os_my/lib/kernel/bitmap.c:32

/* 在位图中申请连续cnt个位
成功：返回其起始位下标
失败：返回-1 */
int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {
c00023db:	55                   	push   %ebp
c00023dc:	89 e5                	mov    %esp,%ebp
c00023de:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/lib/kernel/bitmap.c:33
	uint32_t idx_byte = 0;	 // 用于记录空闲位所在的字节
c00023e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:35
	/* 先逐字节比较,蛮力法 */
	while (( 0xff == btmp->bits[idx_byte]) && (idx_byte < btmp->btmp_bytes_len)) {
c00023e8:	eb 04                	jmp    c00023ee <bitmap_scan+0x13>
/work/x86_os_my/lib/kernel/bitmap.c:37
		/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */
		idx_byte++;
c00023ea:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:35
成功：返回其起始位下标
失败：返回-1 */
int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {
	uint32_t idx_byte = 0;	 // 用于记录空闲位所在的字节
	/* 先逐字节比较,蛮力法 */
	while (( 0xff == btmp->bits[idx_byte]) && (idx_byte < btmp->btmp_bytes_len)) {
c00023ee:	8b 45 08             	mov    0x8(%ebp),%eax
c00023f1:	8b 50 04             	mov    0x4(%eax),%edx
c00023f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00023f7:	01 d0                	add    %edx,%eax
c00023f9:	0f b6 00             	movzbl (%eax),%eax
c00023fc:	3c ff                	cmp    $0xff,%al
c00023fe:	75 0a                	jne    c000240a <bitmap_scan+0x2f>
/work/x86_os_my/lib/kernel/bitmap.c:35 (discriminator 1)
c0002400:	8b 45 08             	mov    0x8(%ebp),%eax
c0002403:	8b 00                	mov    (%eax),%eax
c0002405:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0002408:	77 e0                	ja     c00023ea <bitmap_scan+0xf>
/work/x86_os_my/lib/kernel/bitmap.c:39
		/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */
		idx_byte++;
	}
	ASSERT(idx_byte < btmp->btmp_bytes_len);	//这里应该是"<="
c000240a:	8b 45 08             	mov    0x8(%ebp),%eax
c000240d:	8b 00                	mov    (%eax),%eax
c000240f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0002412:	77 19                	ja     c000242d <bitmap_scan+0x52>
/work/x86_os_my/lib/kernel/bitmap.c:39 (discriminator 1)
c0002414:	68 84 4b 00 c0       	push   $0xc0004b84
c0002419:	68 d8 4b 00 c0       	push   $0xc0004bd8
c000241e:	6a 27                	push   $0x27
c0002420:	68 a4 4b 00 c0       	push   $0xc0004ba4
c0002425:	e8 78 fe ff ff       	call   c00022a2 <panic_spin>
c000242a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:40
	if (idx_byte == btmp->btmp_bytes_len) {		// 若该内存池找不到可用空间		
c000242d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002430:	8b 00                	mov    (%eax),%eax
c0002432:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0002435:	75 0a                	jne    c0002441 <bitmap_scan+0x66>
/work/x86_os_my/lib/kernel/bitmap.c:41
		return -1;
c0002437:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000243c:	e9 cd 00 00 00       	jmp    c000250e <bitmap_scan+0x133>
/work/x86_os_my/lib/kernel/bitmap.c:46
	}

	/* 若在位图数组范围内的某字节内找到了空闲位，
	 * 在该字节内逐位比对,返回空闲位的索引。*/
	int idx_bit = 0;
c0002441:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:48
	/* 和btmp->bits[idx_byte]这个字节逐位对比 */
	while ((uint8_t)(BITMAP_MASK << idx_bit) & btmp->bits[idx_byte]) { 
c0002448:	eb 04                	jmp    c000244e <bitmap_scan+0x73>
/work/x86_os_my/lib/kernel/bitmap.c:49
		idx_bit++;
c000244a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:48

	/* 若在位图数组范围内的某字节内找到了空闲位，
	 * 在该字节内逐位比对,返回空闲位的索引。*/
	int idx_bit = 0;
	/* 和btmp->bits[idx_byte]这个字节逐位对比 */
	while ((uint8_t)(BITMAP_MASK << idx_bit) & btmp->bits[idx_byte]) { 
c000244e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002451:	ba 01 00 00 00       	mov    $0x1,%edx
c0002456:	89 c1                	mov    %eax,%ecx
c0002458:	d3 e2                	shl    %cl,%edx
c000245a:	89 d0                	mov    %edx,%eax
c000245c:	0f b6 d0             	movzbl %al,%edx
c000245f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002462:	8b 48 04             	mov    0x4(%eax),%ecx
c0002465:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002468:	01 c8                	add    %ecx,%eax
c000246a:	0f b6 00             	movzbl (%eax),%eax
c000246d:	0f b6 c0             	movzbl %al,%eax
c0002470:	21 d0                	and    %edx,%eax
c0002472:	85 c0                	test   %eax,%eax
c0002474:	75 d4                	jne    c000244a <bitmap_scan+0x6f>
/work/x86_os_my/lib/kernel/bitmap.c:52
		idx_bit++;
	}
	
	int bit_idx_start = idx_byte * 8 + idx_bit;		// 空闲位在位图内的下标
c0002476:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002479:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c0002480:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002483:	01 d0                	add    %edx,%eax
c0002485:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:53
	if (cnt == 1) {
c0002488:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
c000248c:	75 05                	jne    c0002493 <bitmap_scan+0xb8>
/work/x86_os_my/lib/kernel/bitmap.c:54
		return bit_idx_start;
c000248e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002491:	eb 7b                	jmp    c000250e <bitmap_scan+0x133>
/work/x86_os_my/lib/kernel/bitmap.c:57
	}

	uint32_t bit_left = (btmp->btmp_bytes_len * 8 - bit_idx_start);	// 记录还有多少位可以判断
c0002493:	8b 45 08             	mov    0x8(%ebp),%eax
c0002496:	8b 00                	mov    (%eax),%eax
c0002498:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c000249f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00024a2:	29 c2                	sub    %eax,%edx
c00024a4:	89 d0                	mov    %edx,%eax
c00024a6:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:58
	uint32_t next_bit = bit_idx_start + 1;
c00024a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00024ac:	83 c0 01             	add    $0x1,%eax
c00024af:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:59
	uint32_t count = 1;			// 用于记录找到的空闲位的个数
c00024b2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:61

	bit_idx_start = -1;			// 初始化为-1，若找不到连续的位就直接返回-1
c00024b9:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:62
	while (bit_left-- > 0) {
c00024c0:	eb 3c                	jmp    c00024fe <bitmap_scan+0x123>
/work/x86_os_my/lib/kernel/bitmap.c:63
		if (!(bitmap_scan_test(btmp, next_bit))) {	// 判断next_bit位是否为1,=1返回true，=0返回false
c00024c2:	83 ec 08             	sub    $0x8,%esp
c00024c5:	ff 75 e4             	pushl  -0x1c(%ebp)
c00024c8:	ff 75 08             	pushl  0x8(%ebp)
c00024cb:	e8 cb fe ff ff       	call   c000239b <bitmap_scan_test>
c00024d0:	83 c4 10             	add    $0x10,%esp
c00024d3:	85 c0                	test   %eax,%eax
c00024d5:	75 06                	jne    c00024dd <bitmap_scan+0x102>
/work/x86_os_my/lib/kernel/bitmap.c:64
			count++;
c00024d7:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
c00024db:	eb 07                	jmp    c00024e4 <bitmap_scan+0x109>
/work/x86_os_my/lib/kernel/bitmap.c:66
		} else {
			count = 0;			// 重新从0找cnt个连续的bit
c00024dd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:69
		}
		
		if (count == cnt) {		// 已找到连续的cnt个空位
c00024e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00024e7:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00024ea:	75 0e                	jne    c00024fa <bitmap_scan+0x11f>
/work/x86_os_my/lib/kernel/bitmap.c:70
			bit_idx_start = next_bit - cnt + 1;
c00024ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00024ef:	2b 45 0c             	sub    0xc(%ebp),%eax
c00024f2:	83 c0 01             	add    $0x1,%eax
c00024f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:71
			break;
c00024f8:	eb 11                	jmp    c000250b <bitmap_scan+0x130>
/work/x86_os_my/lib/kernel/bitmap.c:73
		}
		next_bit++;
c00024fa:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:62
	uint32_t bit_left = (btmp->btmp_bytes_len * 8 - bit_idx_start);	// 记录还有多少位可以判断
	uint32_t next_bit = bit_idx_start + 1;
	uint32_t count = 1;			// 用于记录找到的空闲位的个数

	bit_idx_start = -1;			// 初始化为-1，若找不到连续的位就直接返回-1
	while (bit_left-- > 0) {
c00024fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002501:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002504:	89 55 e8             	mov    %edx,-0x18(%ebp)
c0002507:	85 c0                	test   %eax,%eax
c0002509:	75 b7                	jne    c00024c2 <bitmap_scan+0xe7>
/work/x86_os_my/lib/kernel/bitmap.c:75
			bit_idx_start = next_bit - cnt + 1;
			break;
		}
		next_bit++;
	}
	return bit_idx_start;
c000250b:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/lib/kernel/bitmap.c:76
}
c000250e:	c9                   	leave  
c000250f:	c3                   	ret    

c0002510 <bitmap_set>:
bitmap_set():
/work/x86_os_my/lib/kernel/bitmap.c:79

/* 将位图btmp的bit_idx位设置为value */
void bitmap_set(struct bitmap* btmp, uint32_t bit_idx, int8_t value) {
c0002510:	55                   	push   %ebp
c0002511:	89 e5                	mov    %esp,%ebp
c0002513:	56                   	push   %esi
c0002514:	53                   	push   %ebx
c0002515:	83 ec 20             	sub    $0x20,%esp
c0002518:	8b 45 10             	mov    0x10(%ebp),%eax
c000251b:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:80
	ASSERT((value == 0) || (value == 1));
c000251e:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c0002522:	74 1f                	je     c0002543 <bitmap_set+0x33>
/work/x86_os_my/lib/kernel/bitmap.c:80 (discriminator 1)
c0002524:	80 7d e4 01          	cmpb   $0x1,-0x1c(%ebp)
c0002528:	74 19                	je     c0002543 <bitmap_set+0x33>
/work/x86_os_my/lib/kernel/bitmap.c:80 (discriminator 2)
c000252a:	68 b8 4b 00 c0       	push   $0xc0004bb8
c000252f:	68 e4 4b 00 c0       	push   $0xc0004be4
c0002534:	6a 50                	push   $0x50
c0002536:	68 a4 4b 00 c0       	push   $0xc0004ba4
c000253b:	e8 62 fd ff ff       	call   c00022a2 <panic_spin>
c0002540:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:81
	uint32_t byte_idx = bit_idx / 8;    // 向下取整用于索引数组下标
c0002543:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002546:	c1 e8 03             	shr    $0x3,%eax
c0002549:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:82
	uint32_t bit_odd  = bit_idx % 8;    // 取余用于索引数组内的位
c000254c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000254f:	83 e0 07             	and    $0x7,%eax
c0002552:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:86

	/* 一般都会用个0x1这样的数对字节中的位操作,
	* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/
	if (value) {
c0002555:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c0002559:	74 2f                	je     c000258a <bitmap_set+0x7a>
/work/x86_os_my/lib/kernel/bitmap.c:87
		btmp->bits[byte_idx] |= (BITMAP_MASK << bit_odd);
c000255b:	8b 45 08             	mov    0x8(%ebp),%eax
c000255e:	8b 50 04             	mov    0x4(%eax),%edx
c0002561:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002564:	01 c2                	add    %eax,%edx
c0002566:	8b 45 08             	mov    0x8(%ebp),%eax
c0002569:	8b 48 04             	mov    0x4(%eax),%ecx
c000256c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000256f:	01 c8                	add    %ecx,%eax
c0002571:	0f b6 00             	movzbl (%eax),%eax
c0002574:	89 c6                	mov    %eax,%esi
c0002576:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002579:	bb 01 00 00 00       	mov    $0x1,%ebx
c000257e:	89 c1                	mov    %eax,%ecx
c0002580:	d3 e3                	shl    %cl,%ebx
c0002582:	89 d8                	mov    %ebx,%eax
c0002584:	09 f0                	or     %esi,%eax
c0002586:	88 02                	mov    %al,(%edx)
/work/x86_os_my/lib/kernel/bitmap.c:91
	} else {
		btmp->bits[byte_idx] &= ~(BITMAP_MASK << bit_odd);
	}
}
c0002588:	eb 2f                	jmp    c00025b9 <bitmap_set+0xa9>
/work/x86_os_my/lib/kernel/bitmap.c:89
	/* 一般都会用个0x1这样的数对字节中的位操作,
	* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/
	if (value) {
		btmp->bits[byte_idx] |= (BITMAP_MASK << bit_odd);
	} else {
		btmp->bits[byte_idx] &= ~(BITMAP_MASK << bit_odd);
c000258a:	8b 45 08             	mov    0x8(%ebp),%eax
c000258d:	8b 50 04             	mov    0x4(%eax),%edx
c0002590:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002593:	01 c2                	add    %eax,%edx
c0002595:	8b 45 08             	mov    0x8(%ebp),%eax
c0002598:	8b 48 04             	mov    0x4(%eax),%ecx
c000259b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000259e:	01 c8                	add    %ecx,%eax
c00025a0:	0f b6 00             	movzbl (%eax),%eax
c00025a3:	89 c3                	mov    %eax,%ebx
c00025a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00025a8:	be 01 00 00 00       	mov    $0x1,%esi
c00025ad:	89 c1                	mov    %eax,%ecx
c00025af:	d3 e6                	shl    %cl,%esi
c00025b1:	89 f0                	mov    %esi,%eax
c00025b3:	f7 d0                	not    %eax
c00025b5:	21 d8                	and    %ebx,%eax
c00025b7:	88 02                	mov    %al,(%edx)
/work/x86_os_my/lib/kernel/bitmap.c:91
	}
}
c00025b9:	90                   	nop
c00025ba:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00025bd:	5b                   	pop    %ebx
c00025be:	5e                   	pop    %esi
c00025bf:	5d                   	pop    %ebp
c00025c0:	c3                   	ret    

c00025c1 <vaddr_get>:
vaddr_get():
/work/x86_os_my/kernel/memory.c:55
struct pool kernel_pool, user_pool;		// 生成内核内存池和用户内存池
struct virtual_addr kernel_vaddr;		// 此结构是用来给内核分配虚拟地址

/* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页,
 * 成功则返回虚拟页的起始地址, 失败则返回NULL */
static void* vaddr_get(enum pool_flags pf, uint32_t pg_cnt) {
c00025c1:	55                   	push   %ebp
c00025c2:	89 e5                	mov    %esp,%ebp
c00025c4:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:56
	int vaddr_start = 0, bit_idx_start = -1;
c00025c7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00025ce:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:57
	uint32_t cnt = 0;
c00025d5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:58
	if (pf == PF_KERNEL) {
c00025dc:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c00025e0:	75 64                	jne    c0002646 <vaddr_get+0x85>
/work/x86_os_my/kernel/memory.c:60
		// 在位图中申请连续cnt个位 成功：返回其起始位下标
		bit_idx_start  = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
c00025e2:	83 ec 08             	sub    $0x8,%esp
c00025e5:	ff 75 0c             	pushl  0xc(%ebp)
c00025e8:	68 ec 76 00 c0       	push   $0xc00076ec
c00025ed:	e8 e9 fd ff ff       	call   c00023db <bitmap_scan>
c00025f2:	83 c4 10             	add    $0x10,%esp
c00025f5:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:61
		if (bit_idx_start == -1) {	//失败
c00025f8:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c00025fc:	75 2b                	jne    c0002629 <vaddr_get+0x68>
/work/x86_os_my/kernel/memory.c:62
			return NULL;
c00025fe:	b8 00 00 00 00       	mov    $0x0,%eax
c0002603:	e9 cd 00 00 00       	jmp    c00026d5 <vaddr_get+0x114>
/work/x86_os_my/kernel/memory.c:66
		}
		while(cnt < pg_cnt) {
			// 设置位图中的位，表示内存已被占用
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
c0002608:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000260b:	8d 50 01             	lea    0x1(%eax),%edx
c000260e:	89 55 f0             	mov    %edx,-0x10(%ebp)
c0002611:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002614:	01 d0                	add    %edx,%eax
c0002616:	83 ec 04             	sub    $0x4,%esp
c0002619:	6a 01                	push   $0x1
c000261b:	50                   	push   %eax
c000261c:	68 ec 76 00 c0       	push   $0xc00076ec
c0002621:	e8 ea fe ff ff       	call   c0002510 <bitmap_set>
c0002626:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:64
		// 在位图中申请连续cnt个位 成功：返回其起始位下标
		bit_idx_start  = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
		if (bit_idx_start == -1) {	//失败
			return NULL;
		}
		while(cnt < pg_cnt) {
c0002629:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000262c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000262f:	72 d7                	jb     c0002608 <vaddr_get+0x47>
/work/x86_os_my/kernel/memory.c:68
			// 设置位图中的位，表示内存已被占用
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
		}
		vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
c0002631:	a1 f4 76 00 c0       	mov    0xc00076f4,%eax
c0002636:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002639:	c1 e2 0c             	shl    $0xc,%edx
c000263c:	01 d0                	add    %edx,%eax
c000263e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002641:	e9 8c 00 00 00       	jmp    c00026d2 <vaddr_get+0x111>
/work/x86_os_my/kernel/memory.c:70
	} else {
		struct task_struct* cur = running_thread();
c0002646:	e8 4f 0b 00 00       	call   c000319a <running_thread>
c000264b:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:71
		bit_idx_start  = bitmap_scan(&cur->userprog_vaddr.vaddr_bitmap, pg_cnt);
c000264e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002651:	83 c0 34             	add    $0x34,%eax
c0002654:	83 ec 08             	sub    $0x8,%esp
c0002657:	ff 75 0c             	pushl  0xc(%ebp)
c000265a:	50                   	push   %eax
c000265b:	e8 7b fd ff ff       	call   c00023db <bitmap_scan>
c0002660:	83 c4 10             	add    $0x10,%esp
c0002663:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:72
		if (bit_idx_start == -1) {
c0002666:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c000266a:	75 2a                	jne    c0002696 <vaddr_get+0xd5>
/work/x86_os_my/kernel/memory.c:73
			return NULL;
c000266c:	b8 00 00 00 00       	mov    $0x0,%eax
c0002671:	eb 62                	jmp    c00026d5 <vaddr_get+0x114>
/work/x86_os_my/kernel/memory.c:76
		}
		while(cnt < pg_cnt) {
			bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
c0002673:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002676:	8d 50 01             	lea    0x1(%eax),%edx
c0002679:	89 55 f0             	mov    %edx,-0x10(%ebp)
c000267c:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000267f:	01 c2                	add    %eax,%edx
c0002681:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002684:	83 c0 34             	add    $0x34,%eax
c0002687:	83 ec 04             	sub    $0x4,%esp
c000268a:	6a 01                	push   $0x1
c000268c:	52                   	push   %edx
c000268d:	50                   	push   %eax
c000268e:	e8 7d fe ff ff       	call   c0002510 <bitmap_set>
c0002693:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:75
		struct task_struct* cur = running_thread();
		bit_idx_start  = bitmap_scan(&cur->userprog_vaddr.vaddr_bitmap, pg_cnt);
		if (bit_idx_start == -1) {
			return NULL;
		}
		while(cnt < pg_cnt) {
c0002696:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002699:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000269c:	72 d5                	jb     c0002673 <vaddr_get+0xb2>
/work/x86_os_my/kernel/memory.c:78
			bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
		}
		vaddr_start = cur->userprog_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
c000269e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00026a1:	8b 40 3c             	mov    0x3c(%eax),%eax
c00026a4:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00026a7:	c1 e2 0c             	shl    $0xc,%edx
c00026aa:	01 d0                	add    %edx,%eax
c00026ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:81

		/* (0xc0000000 - PG_SIZE)做为用户3级栈已经在start_process被分配 */
		ASSERT((uint32_t)vaddr_start < (0xc0000000 - PG_SIZE));
c00026af:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00026b2:	3d ff ef ff bf       	cmp    $0xbfffefff,%eax
c00026b7:	76 19                	jbe    c00026d2 <vaddr_get+0x111>
/work/x86_os_my/kernel/memory.c:81 (discriminator 1)
c00026b9:	68 f0 4b 00 c0       	push   $0xc0004bf0
c00026be:	68 94 4d 00 c0       	push   $0xc0004d94
c00026c3:	6a 51                	push   $0x51
c00026c5:	68 1f 4c 00 c0       	push   $0xc0004c1f
c00026ca:	e8 d3 fb ff ff       	call   c00022a2 <panic_spin>
c00026cf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:84
		
	}
	return (void*)vaddr_start;
c00026d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:85
}
c00026d5:	c9                   	leave  
c00026d6:	c3                   	ret    

c00026d7 <pte_ptr>:
pte_ptr():
/work/x86_os_my/kernel/memory.c:92
// 页表项 page table
/* 得到虚拟地址vaddr对应的pte指针*/
// 虚拟地址 vaddr 所在 pte 的"虚拟地址"!!!
// *pte 代表的是 pte 页表项的内容,
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页表项"属性
uint32_t* pte_ptr(uint32_t vaddr) {
c00026d7:	55                   	push   %ebp
c00026d8:	89 e5                	mov    %esp,%ebp
c00026da:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:97
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
					((vaddr & 0xffc00000) >> 10) + \
c00026dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00026e0:	25 00 00 c0 ff       	and    $0xffc00000,%eax
c00026e5:	c1 e8 0a             	shr    $0xa,%eax
c00026e8:	89 c2                	mov    %eax,%edx
/work/x86_os_my/kernel/memory.c:98
					PTE_IDX(vaddr) * 4);
c00026ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00026ed:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c00026f2:	c1 e8 0c             	shr    $0xc,%eax
c00026f5:	c1 e0 02             	shl    $0x2,%eax
/work/x86_os_my/kernel/memory.c:97
uint32_t* pte_ptr(uint32_t vaddr) {
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
					((vaddr & 0xffc00000) >> 10) + \
c00026f8:	01 d0                	add    %edx,%eax
c00026fa:	2d 00 00 40 00       	sub    $0x400000,%eax
/work/x86_os_my/kernel/memory.c:96
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页表项"属性
uint32_t* pte_ptr(uint32_t vaddr) {
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
c00026ff:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:99
					((vaddr & 0xffc00000) >> 10) + \
					PTE_IDX(vaddr) * 4);
	return pte;
c0002702:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/kernel/memory.c:100
}
c0002705:	c9                   	leave  
c0002706:	c3                   	ret    

c0002707 <pde_ptr>:
pde_ptr():
/work/x86_os_my/kernel/memory.c:107
// 页目录表项 page Directory table entry
/* 得到虚拟地址vaddr对应的pde的指针 */
// 虚拟地址 vaddr 所在 pde 的"虚拟地址"!!!
// *pde 代表的是 pde 页目录项的内容
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页目录项"属性
uint32_t* pde_ptr(uint32_t vaddr) {
c0002707:	55                   	push   %ebp
c0002708:	89 e5                	mov    %esp,%ebp
c000270a:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:109
	/* 0xfffff是用来访问到页目录表本身所在的地址 */
	uint32_t* pde = (uint32_t*)((0xfffff000) + PDE_IDX(vaddr) * 4);
c000270d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002710:	c1 e8 16             	shr    $0x16,%eax
c0002713:	05 00 fc ff 3f       	add    $0x3ffffc00,%eax
c0002718:	c1 e0 02             	shl    $0x2,%eax
c000271b:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:110
	return pde;
c000271e:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/kernel/memory.c:111
}
c0002721:	c9                   	leave  
c0002722:	c3                   	ret    

c0002723 <palloc>:
palloc():
/work/x86_os_my/kernel/memory.c:115

/* 在m_pool指向的物理内存池中分配1个物理页,
 * 成功则返回页框的物理地址,失败则返回NULL */
static void* palloc(struct pool* m_pool) {
c0002723:	55                   	push   %ebp
c0002724:	89 e5                	mov    %esp,%ebp
c0002726:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:117
	/* 扫描或设置位图要保证原子操作 */
	int bit_idx = bitmap_scan(&m_pool->pool_bitmap, 1);    // 找一个物理页面
c0002729:	8b 45 08             	mov    0x8(%ebp),%eax
c000272c:	83 ec 08             	sub    $0x8,%esp
c000272f:	6a 01                	push   $0x1
c0002731:	50                   	push   %eax
c0002732:	e8 a4 fc ff ff       	call   c00023db <bitmap_scan>
c0002737:	83 c4 10             	add    $0x10,%esp
c000273a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:118
	if (bit_idx == -1 ) {
c000273d:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0002741:	75 07                	jne    c000274a <palloc+0x27>
/work/x86_os_my/kernel/memory.c:119
		return NULL;
c0002743:	b8 00 00 00 00       	mov    $0x0,%eax
c0002748:	eb 2b                	jmp    c0002775 <palloc+0x52>
/work/x86_os_my/kernel/memory.c:121
	}
	bitmap_set(&m_pool->pool_bitmap, bit_idx, 1);	// 将此位bit_idx置1
c000274a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000274d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002750:	83 ec 04             	sub    $0x4,%esp
c0002753:	6a 01                	push   $0x1
c0002755:	52                   	push   %edx
c0002756:	50                   	push   %eax
c0002757:	e8 b4 fd ff ff       	call   c0002510 <bitmap_set>
c000275c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:122
	uint32_t page_phyaddr = ((bit_idx * PG_SIZE) + m_pool->phy_addr_start);
c000275f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002762:	c1 e0 0c             	shl    $0xc,%eax
c0002765:	89 c2                	mov    %eax,%edx
c0002767:	8b 45 08             	mov    0x8(%ebp),%eax
c000276a:	8b 40 08             	mov    0x8(%eax),%eax
c000276d:	01 d0                	add    %edx,%eax
c000276f:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:123
	return (void*)page_phyaddr;
c0002772:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/kernel/memory.c:124
}
c0002775:	c9                   	leave  
c0002776:	c3                   	ret    

c0002777 <page_table_add>:
page_table_add():
/work/x86_os_my/kernel/memory.c:127

/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */
static void page_table_add(void* _vaddr, void* _page_phyaddr) {
c0002777:	55                   	push   %ebp
c0002778:	89 e5                	mov    %esp,%ebp
c000277a:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:128
	uint32_t vaddr = (uint32_t)_vaddr, page_phyaddr = (uint32_t)_page_phyaddr;
c000277d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002780:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002783:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002786:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:129
	uint32_t* pde = pde_ptr(vaddr);	//变量pde是虚拟地址!!!
c0002789:	ff 75 f4             	pushl  -0xc(%ebp)
c000278c:	e8 76 ff ff ff       	call   c0002707 <pde_ptr>
c0002791:	83 c4 04             	add    $0x4,%esp
c0002794:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:130
	uint32_t* pte = pte_ptr(vaddr);	//变量pte是虚拟地址!!!
c0002797:	ff 75 f4             	pushl  -0xc(%ebp)
c000279a:	e8 38 ff ff ff       	call   c00026d7 <pte_ptr>
c000279f:	83 c4 04             	add    $0x4,%esp
c00027a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:138
	* pde页目录项 pte页表项
	* 执行*pte可能会访问到空的pde。所以确保pde创建完成后才能执行*pte，否则会引发page_fault。
	* 因此在*pde为0时，*pte只能出现在下面else语句块中的*pde后面。
	* *********************************************************/
	/* 先在页目录内判断目录项的P位，若为1,则表示该表已存在 */
	if (*pde & 0x00000001) {			// 页目录项 存在
c00027a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00027a8:	8b 00                	mov    (%eax),%eax
c00027aa:	83 e0 01             	and    $0x1,%eax
c00027ad:	85 c0                	test   %eax,%eax
c00027af:	74 64                	je     c0002815 <page_table_add+0x9e>
/work/x86_os_my/kernel/memory.c:139
		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
c00027b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00027b4:	8b 00                	mov    (%eax),%eax
c00027b6:	83 e0 01             	and    $0x1,%eax
c00027b9:	85 c0                	test   %eax,%eax
c00027bb:	74 1c                	je     c00027d9 <page_table_add+0x62>
/work/x86_os_my/kernel/memory.c:139 (discriminator 1)
c00027bd:	68 2f 4c 00 c0       	push   $0xc0004c2f
c00027c2:	68 a0 4d 00 c0       	push   $0xc0004da0
c00027c7:	68 8b 00 00 00       	push   $0x8b
c00027cc:	68 1f 4c 00 c0       	push   $0xc0004c1f
c00027d1:	e8 cc fa ff ff       	call   c00022a2 <panic_spin>
c00027d6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:141

		if (!(*pte & 0x00000001)) {		// 页表项pte不存在，创建PTE
c00027d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00027dc:	8b 00                	mov    (%eax),%eax
c00027de:	83 e0 01             	and    $0x1,%eax
c00027e1:	85 c0                	test   %eax,%eax
c00027e3:	75 12                	jne    c00027f7 <page_table_add+0x80>
/work/x86_os_my/kernel/memory.c:142
			*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);		// 物理地址 | US=1,RW=1,P=1
c00027e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00027e8:	83 c8 07             	or     $0x7,%eax
c00027eb:	89 c2                	mov    %eax,%edx
c00027ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00027f0:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:162
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
	}
}
c00027f2:	e9 8e 00 00 00       	jmp    c0002885 <page_table_add+0x10e>
/work/x86_os_my/kernel/memory.c:144
		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic

		if (!(*pte & 0x00000001)) {		// 页表项pte不存在，创建PTE
			*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);		// 物理地址 | US=1,RW=1,P=1
		} else {						// 不会执行到这，因为上面的ASSERT
			PANIC("pte repeat");
c00027f7:	68 44 4c 00 c0       	push   $0xc0004c44
c00027fc:	68 a0 4d 00 c0       	push   $0xc0004da0
c0002801:	68 90 00 00 00       	push   $0x90
c0002806:	68 1f 4c 00 c0       	push   $0xc0004c1f
c000280b:	e8 92 fa ff ff       	call   c00022a2 <panic_spin>
c0002810:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:162
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
	}
}
c0002813:	eb 70                	jmp    c0002885 <page_table_add+0x10e>
/work/x86_os_my/kernel/memory.c:148
		} else {						// 不会执行到这，因为上面的ASSERT
			PANIC("pte repeat");
		}
	} else {							// 页目录项不存在，先创建页目录，再创建页表项
		/* 页表中用到的页一律从内核空间分配 */
		uint32_t pde_phyaddr = (uint32_t)palloc(&kernel_pool);
c0002815:	83 ec 0c             	sub    $0xc,%esp
c0002818:	68 00 77 00 c0       	push   $0xc0007700
c000281d:	e8 01 ff ff ff       	call   c0002723 <palloc>
c0002822:	83 c4 10             	add    $0x10,%esp
c0002825:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:149
		*pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 注意这行是pde_phyaddr，不是page_phyaddr!!!
c0002828:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000282b:	83 c8 07             	or     $0x7,%eax
c000282e:	89 c2                	mov    %eax,%edx
c0002830:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002833:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:157
		 * 访问物理地址 pde_phyaddr，需要找到它的虚拟地址！
		 * 只要用_vaddr的 PTE 取高20位即可。
		   搞得这么难理解，其实就是0xffc00000找到页目录表，然后加上vaddr的PDE在页目录表中的索引
		   (uint32_t*)(0xffc00000 + ((vaddr & 0xffc00000) >> 10))
		 */
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);
c0002835:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002838:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000283d:	83 ec 04             	sub    $0x4,%esp
c0002840:	68 00 10 00 00       	push   $0x1000
c0002845:	6a 00                	push   $0x0
c0002847:	50                   	push   %eax
c0002848:	e8 7d 05 00 00       	call   c0002dca <memset>
c000284d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:159

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
c0002850:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002853:	8b 00                	mov    (%eax),%eax
c0002855:	83 e0 01             	and    $0x1,%eax
c0002858:	85 c0                	test   %eax,%eax
c000285a:	74 1c                	je     c0002878 <page_table_add+0x101>
/work/x86_os_my/kernel/memory.c:159 (discriminator 1)
c000285c:	68 2f 4c 00 c0       	push   $0xc0004c2f
c0002861:	68 a0 4d 00 c0       	push   $0xc0004da0
c0002866:	68 9f 00 00 00       	push   $0x9f
c000286b:	68 1f 4c 00 c0       	push   $0xc0004c1f
c0002870:	e8 2d fa ff ff       	call   c00022a2 <panic_spin>
c0002875:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:160
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
c0002878:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000287b:	83 c8 07             	or     $0x7,%eax
c000287e:	89 c2                	mov    %eax,%edx
c0002880:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002883:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:162
	}
}
c0002885:	90                   	nop
c0002886:	c9                   	leave  
c0002887:	c3                   	ret    

c0002888 <malloc_page>:
malloc_page():
/work/x86_os_my/kernel/memory.c:165

/* 分配pg_cnt个页空间,成功则返回起始虚拟地址,失败时返回NULL */
void* malloc_page(enum pool_flags pf, uint32_t pg_cnt) {
c0002888:	55                   	push   %ebp
c0002889:	89 e5                	mov    %esp,%ebp
c000288b:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:166
	ASSERT(pg_cnt > 0 && pg_cnt < 3840);
c000288e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002892:	74 09                	je     c000289d <malloc_page+0x15>
/work/x86_os_my/kernel/memory.c:166 (discriminator 1)
c0002894:	81 7d 0c ff 0e 00 00 	cmpl   $0xeff,0xc(%ebp)
c000289b:	76 1c                	jbe    c00028b9 <malloc_page+0x31>
/work/x86_os_my/kernel/memory.c:166 (discriminator 3)
c000289d:	68 4f 4c 00 c0       	push   $0xc0004c4f
c00028a2:	68 b0 4d 00 c0       	push   $0xc0004db0
c00028a7:	68 a6 00 00 00       	push   $0xa6
c00028ac:	68 1f 4c 00 c0       	push   $0xc0004c1f
c00028b1:	e8 ec f9 ff ff       	call   c00022a2 <panic_spin>
c00028b6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:172
	/***********   malloc_page的原理是三个动作的合成:   ***********
		1 通过vaddr_get在虚拟内存池中申请虚拟地址
		2 通过palloc在物理内存池中申请物理页
		3 通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射
	***************************************************************/
	void* vaddr_start = vaddr_get(pf, pg_cnt);
c00028b9:	83 ec 08             	sub    $0x8,%esp
c00028bc:	ff 75 0c             	pushl  0xc(%ebp)
c00028bf:	ff 75 08             	pushl  0x8(%ebp)
c00028c2:	e8 fa fc ff ff       	call   c00025c1 <vaddr_get>
c00028c7:	83 c4 10             	add    $0x10,%esp
c00028ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:173
	if (vaddr_start == NULL) {
c00028cd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00028d1:	75 07                	jne    c00028da <malloc_page+0x52>
/work/x86_os_my/kernel/memory.c:174
		return NULL;
c00028d3:	b8 00 00 00 00       	mov    $0x0,%eax
c00028d8:	eb 6e                	jmp    c0002948 <malloc_page+0xc0>
/work/x86_os_my/kernel/memory.c:177
	}

	uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
c00028da:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00028dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00028e0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00028e3:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:178
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c00028e6:	8b 45 08             	mov    0x8(%ebp),%eax
c00028e9:	83 e0 01             	and    $0x1,%eax
c00028ec:	85 c0                	test   %eax,%eax
c00028ee:	74 07                	je     c00028f7 <malloc_page+0x6f>
/work/x86_os_my/kernel/memory.c:178 (discriminator 1)
c00028f0:	b8 00 77 00 c0       	mov    $0xc0007700,%eax
c00028f5:	eb 05                	jmp    c00028fc <malloc_page+0x74>
/work/x86_os_my/kernel/memory.c:178 (discriminator 2)
c00028f7:	b8 c0 76 00 c0       	mov    $0xc00076c0,%eax
/work/x86_os_my/kernel/memory.c:178 (discriminator 4)
c00028fc:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:181 (discriminator 4)

	/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
	while (cnt-- > 0) {
c00028ff:	eb 37                	jmp    c0002938 <malloc_page+0xb0>
/work/x86_os_my/kernel/memory.c:182
		void* page_phyaddr = palloc(mem_pool);
c0002901:	83 ec 0c             	sub    $0xc,%esp
c0002904:	ff 75 e8             	pushl  -0x18(%ebp)
c0002907:	e8 17 fe ff ff       	call   c0002723 <palloc>
c000290c:	83 c4 10             	add    $0x10,%esp
c000290f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:183
		if (page_phyaddr == NULL) {  // 失败时要将曾经已申请的虚拟地址和物理页全部回滚，在将来完成内存回收时再补充
c0002912:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0002916:	75 07                	jne    c000291f <malloc_page+0x97>
/work/x86_os_my/kernel/memory.c:184
			return NULL;
c0002918:	b8 00 00 00 00       	mov    $0x0,%eax
c000291d:	eb 29                	jmp    c0002948 <malloc_page+0xc0>
/work/x86_os_my/kernel/memory.c:186
		}
		page_table_add((void*)vaddr, page_phyaddr); // 在页表中做映射 
c000291f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002922:	83 ec 08             	sub    $0x8,%esp
c0002925:	ff 75 e4             	pushl  -0x1c(%ebp)
c0002928:	50                   	push   %eax
c0002929:	e8 49 fe ff ff       	call   c0002777 <page_table_add>
c000292e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:187
		vaddr += PG_SIZE;		 // 下一个虚拟页
c0002931:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:181

	uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;

	/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
	while (cnt-- > 0) {
c0002938:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000293b:	8d 50 ff             	lea    -0x1(%eax),%edx
c000293e:	89 55 f0             	mov    %edx,-0x10(%ebp)
c0002941:	85 c0                	test   %eax,%eax
c0002943:	75 bc                	jne    c0002901 <malloc_page+0x79>
/work/x86_os_my/kernel/memory.c:189
			return NULL;
		}
		page_table_add((void*)vaddr, page_phyaddr); // 在页表中做映射 
		vaddr += PG_SIZE;		 // 下一个虚拟页
	}
	return vaddr_start;
c0002945:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/kernel/memory.c:190
}
c0002948:	c9                   	leave  
c0002949:	c3                   	ret    

c000294a <get_kernel_pages>:
get_kernel_pages():
/work/x86_os_my/kernel/memory.c:193

/* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */
void* get_kernel_pages(uint32_t pg_cnt) {
c000294a:	55                   	push   %ebp
c000294b:	89 e5                	mov    %esp,%ebp
c000294d:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:194
	lock_acquire(&kernel_pool.lock);
c0002950:	83 ec 0c             	sub    $0xc,%esp
c0002953:	68 10 77 00 c0       	push   $0xc0007710
c0002958:	e8 62 12 00 00       	call   c0003bbf <lock_acquire>
c000295d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:195
	void* vaddr =  malloc_page(PF_KERNEL, pg_cnt);
c0002960:	83 ec 08             	sub    $0x8,%esp
c0002963:	ff 75 08             	pushl  0x8(%ebp)
c0002966:	6a 01                	push   $0x1
c0002968:	e8 1b ff ff ff       	call   c0002888 <malloc_page>
c000296d:	83 c4 10             	add    $0x10,%esp
c0002970:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:196
	if (vaddr != NULL) {
c0002973:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002977:	74 17                	je     c0002990 <get_kernel_pages+0x46>
/work/x86_os_my/kernel/memory.c:197
		memset(vaddr, 0, pg_cnt * PG_SIZE);
c0002979:	8b 45 08             	mov    0x8(%ebp),%eax
c000297c:	c1 e0 0c             	shl    $0xc,%eax
c000297f:	83 ec 04             	sub    $0x4,%esp
c0002982:	50                   	push   %eax
c0002983:	6a 00                	push   $0x0
c0002985:	ff 75 f4             	pushl  -0xc(%ebp)
c0002988:	e8 3d 04 00 00       	call   c0002dca <memset>
c000298d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:199
	}
	lock_release(&kernel_pool.lock);
c0002990:	83 ec 0c             	sub    $0xc,%esp
c0002993:	68 10 77 00 c0       	push   $0xc0007710
c0002998:	e8 99 12 00 00       	call   c0003c36 <lock_release>
c000299d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:200
	return vaddr;
c00029a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:201
}
c00029a3:	c9                   	leave  
c00029a4:	c3                   	ret    

c00029a5 <get_user_pages>:
get_user_pages():
/work/x86_os_my/kernel/memory.c:204

/* 在用户空间中申请4k内存,并返回其虚拟地址 */
void* get_user_pages(uint32_t pg_cnt) {
c00029a5:	55                   	push   %ebp
c00029a6:	89 e5                	mov    %esp,%ebp
c00029a8:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:205
	lock_acquire(&user_pool.lock);
c00029ab:	83 ec 0c             	sub    $0xc,%esp
c00029ae:	68 d0 76 00 c0       	push   $0xc00076d0
c00029b3:	e8 07 12 00 00       	call   c0003bbf <lock_acquire>
c00029b8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:206
	void* vaddr = malloc_page(PF_USER, pg_cnt);
c00029bb:	83 ec 08             	sub    $0x8,%esp
c00029be:	ff 75 08             	pushl  0x8(%ebp)
c00029c1:	6a 02                	push   $0x2
c00029c3:	e8 c0 fe ff ff       	call   c0002888 <malloc_page>
c00029c8:	83 c4 10             	add    $0x10,%esp
c00029cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:207
	if (vaddr != NULL) {
c00029ce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00029d2:	74 17                	je     c00029eb <get_user_pages+0x46>
/work/x86_os_my/kernel/memory.c:208
		memset(vaddr, 0, pg_cnt * PG_SIZE);
c00029d4:	8b 45 08             	mov    0x8(%ebp),%eax
c00029d7:	c1 e0 0c             	shl    $0xc,%eax
c00029da:	83 ec 04             	sub    $0x4,%esp
c00029dd:	50                   	push   %eax
c00029de:	6a 00                	push   $0x0
c00029e0:	ff 75 f4             	pushl  -0xc(%ebp)
c00029e3:	e8 e2 03 00 00       	call   c0002dca <memset>
c00029e8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:210
	}
	lock_release(&user_pool.lock);
c00029eb:	83 ec 0c             	sub    $0xc,%esp
c00029ee:	68 d0 76 00 c0       	push   $0xc00076d0
c00029f3:	e8 3e 12 00 00       	call   c0003c36 <lock_release>
c00029f8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:211
	return vaddr;
c00029fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:212
}
c00029fe:	c9                   	leave  
c00029ff:	c3                   	ret    

c0002a00 <get_a_page>:
get_a_page():
/work/x86_os_my/kernel/memory.c:216

/* 将虚拟地址vaddr与pf池中的物理地址关联,仅支持一页空间分配
 * 功能是，可以指定虚拟地址的内存分配 */
void* get_a_page(enum pool_flags pf, uint32_t vaddr) {
c0002a00:	55                   	push   %ebp
c0002a01:	89 e5                	mov    %esp,%ebp
c0002a03:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:217
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c0002a06:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a09:	83 e0 01             	and    $0x1,%eax
c0002a0c:	85 c0                	test   %eax,%eax
c0002a0e:	74 07                	je     c0002a17 <get_a_page+0x17>
/work/x86_os_my/kernel/memory.c:217 (discriminator 1)
c0002a10:	b8 00 77 00 c0       	mov    $0xc0007700,%eax
c0002a15:	eb 05                	jmp    c0002a1c <get_a_page+0x1c>
/work/x86_os_my/kernel/memory.c:217 (discriminator 2)
c0002a17:	b8 c0 76 00 c0       	mov    $0xc00076c0,%eax
/work/x86_os_my/kernel/memory.c:217 (discriminator 4)
c0002a1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:218 (discriminator 4)
	lock_acquire(&mem_pool->lock);
c0002a1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002a22:	83 c0 10             	add    $0x10,%eax
c0002a25:	83 ec 0c             	sub    $0xc,%esp
c0002a28:	50                   	push   %eax
c0002a29:	e8 91 11 00 00       	call   c0003bbf <lock_acquire>
c0002a2e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:221 (discriminator 4)

	/* 先将虚拟地址对应的位图置1 */
	struct task_struct* cur = running_thread();
c0002a31:	e8 64 07 00 00       	call   c000319a <running_thread>
c0002a36:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:222 (discriminator 4)
	int32_t bit_idx = -1;
c0002a39:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:224 (discriminator 4)

	if (cur->pgdir != NULL && pf == PF_USER) {
c0002a40:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002a43:	8b 40 30             	mov    0x30(%eax),%eax
c0002a46:	85 c0                	test   %eax,%eax
c0002a48:	74 55                	je     c0002a9f <get_a_page+0x9f>
/work/x86_os_my/kernel/memory.c:224 (discriminator 1)
c0002a4a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0002a4e:	75 4f                	jne    c0002a9f <get_a_page+0x9f>
/work/x86_os_my/kernel/memory.c:226
		/* 若当前是用户进程申请用户内存,就修改用户进程自己的虚拟地址池的 位图 */
		bit_idx = (vaddr - cur->userprog_vaddr.vaddr_start) / PG_SIZE;
c0002a50:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002a53:	8b 40 3c             	mov    0x3c(%eax),%eax
c0002a56:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002a59:	29 c2                	sub    %eax,%edx
c0002a5b:	89 d0                	mov    %edx,%eax
c0002a5d:	c1 e8 0c             	shr    $0xc,%eax
c0002a60:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:227
		ASSERT(bit_idx > 0);
c0002a63:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002a67:	7f 1c                	jg     c0002a85 <get_a_page+0x85>
/work/x86_os_my/kernel/memory.c:227 (discriminator 1)
c0002a69:	68 6b 4c 00 c0       	push   $0xc0004c6b
c0002a6e:	68 bc 4d 00 c0       	push   $0xc0004dbc
c0002a73:	68 e3 00 00 00       	push   $0xe3
c0002a78:	68 1f 4c 00 c0       	push   $0xc0004c1f
c0002a7d:	e8 20 f8 ff ff       	call   c00022a2 <panic_spin>
c0002a82:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:228
		bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx, 1);
c0002a85:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002a88:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002a8b:	83 c2 34             	add    $0x34,%edx
c0002a8e:	83 ec 04             	sub    $0x4,%esp
c0002a91:	6a 01                	push   $0x1
c0002a93:	50                   	push   %eax
c0002a94:	52                   	push   %edx
c0002a95:	e8 76 fa ff ff       	call   c0002510 <bitmap_set>
c0002a9a:	83 c4 10             	add    $0x10,%esp
c0002a9d:	eb 78                	jmp    c0002b17 <get_a_page+0x117>
/work/x86_os_my/kernel/memory.c:230

	} else if (cur->pgdir == NULL && pf == PF_KERNEL) {
c0002a9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002aa2:	8b 40 30             	mov    0x30(%eax),%eax
c0002aa5:	85 c0                	test   %eax,%eax
c0002aa7:	75 52                	jne    c0002afb <get_a_page+0xfb>
/work/x86_os_my/kernel/memory.c:230 (discriminator 1)
c0002aa9:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0002aad:	75 4c                	jne    c0002afb <get_a_page+0xfb>
/work/x86_os_my/kernel/memory.c:232
		/* 如果是内核线程申请内核内存,就修改 kernel_vaddr */
		bit_idx = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
c0002aaf:	a1 f4 76 00 c0       	mov    0xc00076f4,%eax
c0002ab4:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002ab7:	29 c2                	sub    %eax,%edx
c0002ab9:	89 d0                	mov    %edx,%eax
c0002abb:	c1 e8 0c             	shr    $0xc,%eax
c0002abe:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:233
		ASSERT(bit_idx > 0);
c0002ac1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002ac5:	7f 1c                	jg     c0002ae3 <get_a_page+0xe3>
/work/x86_os_my/kernel/memory.c:233 (discriminator 1)
c0002ac7:	68 6b 4c 00 c0       	push   $0xc0004c6b
c0002acc:	68 bc 4d 00 c0       	push   $0xc0004dbc
c0002ad1:	68 e9 00 00 00       	push   $0xe9
c0002ad6:	68 1f 4c 00 c0       	push   $0xc0004c1f
c0002adb:	e8 c2 f7 ff ff       	call   c00022a2 <panic_spin>
c0002ae0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:234
		bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx, 1);
c0002ae3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002ae6:	83 ec 04             	sub    $0x4,%esp
c0002ae9:	6a 01                	push   $0x1
c0002aeb:	50                   	push   %eax
c0002aec:	68 ec 76 00 c0       	push   $0xc00076ec
c0002af1:	e8 1a fa ff ff       	call   c0002510 <bitmap_set>
c0002af6:	83 c4 10             	add    $0x10,%esp
c0002af9:	eb 1c                	jmp    c0002b17 <get_a_page+0x117>
/work/x86_os_my/kernel/memory.c:237

	} else {
		PANIC("get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page");
c0002afb:	68 78 4c 00 c0       	push   $0xc0004c78
c0002b00:	68 bc 4d 00 c0       	push   $0xc0004dbc
c0002b05:	68 ed 00 00 00       	push   $0xed
c0002b0a:	68 1f 4c 00 c0       	push   $0xc0004c1f
c0002b0f:	e8 8e f7 ff ff       	call   c00022a2 <panic_spin>
c0002b14:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:240
	}

	void* page_phyaddr = palloc(mem_pool);
c0002b17:	83 ec 0c             	sub    $0xc,%esp
c0002b1a:	ff 75 f4             	pushl  -0xc(%ebp)
c0002b1d:	e8 01 fc ff ff       	call   c0002723 <palloc>
c0002b22:	83 c4 10             	add    $0x10,%esp
c0002b25:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:241
	if (page_phyaddr == NULL) {
c0002b28:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0002b2c:	75 07                	jne    c0002b35 <get_a_page+0x135>
/work/x86_os_my/kernel/memory.c:242
		return NULL;
c0002b2e:	b8 00 00 00 00       	mov    $0x0,%eax
c0002b33:	eb 27                	jmp    c0002b5c <get_a_page+0x15c>
/work/x86_os_my/kernel/memory.c:244
	}
	page_table_add((void*)vaddr, page_phyaddr);
c0002b35:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002b38:	83 ec 08             	sub    $0x8,%esp
c0002b3b:	ff 75 e8             	pushl  -0x18(%ebp)
c0002b3e:	50                   	push   %eax
c0002b3f:	e8 33 fc ff ff       	call   c0002777 <page_table_add>
c0002b44:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:246
	
	lock_release(&mem_pool->lock);
c0002b47:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002b4a:	83 c0 10             	add    $0x10,%eax
c0002b4d:	83 ec 0c             	sub    $0xc,%esp
c0002b50:	50                   	push   %eax
c0002b51:	e8 e0 10 00 00       	call   c0003c36 <lock_release>
c0002b56:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:247
	return (void*)vaddr;
c0002b59:	8b 45 0c             	mov    0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:248
}
c0002b5c:	c9                   	leave  
c0002b5d:	c3                   	ret    

c0002b5e <addr_v2p>:
addr_v2p():
/work/x86_os_my/kernel/memory.c:251

/* 得到虚拟地址映射到的物理地址 */
uint32_t addr_v2p(uint32_t vaddr) {
c0002b5e:	55                   	push   %ebp
c0002b5f:	89 e5                	mov    %esp,%ebp
c0002b61:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:252
	uint32_t* pte = pte_ptr(vaddr);
c0002b64:	ff 75 08             	pushl  0x8(%ebp)
c0002b67:	e8 6b fb ff ff       	call   c00026d7 <pte_ptr>
c0002b6c:	83 c4 04             	add    $0x4,%esp
c0002b6f:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:256
	/* (*pte)的内容是 vaddr 所在 pte 的内容，也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的页表项属性，
	 * 因为页框都是自然页，低 12 位地址是 0，所以页表项 pte（和页目录项 pde）中只需要记录页框的高 20 位地址即可。
	 */
	return ((*pte & 0xfffff000) + (vaddr & 0x00000fff));
c0002b72:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002b75:	8b 00                	mov    (%eax),%eax
c0002b77:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002b7c:	89 c2                	mov    %eax,%edx
c0002b7e:	8b 45 08             	mov    0x8(%ebp),%eax
c0002b81:	25 ff 0f 00 00       	and    $0xfff,%eax
c0002b86:	01 d0                	add    %edx,%eax
/work/x86_os_my/kernel/memory.c:257
}
c0002b88:	c9                   	leave  
c0002b89:	c3                   	ret    

c0002b8a <mem_pool_init>:
mem_pool_init():
/work/x86_os_my/kernel/memory.c:260

/* 初始化内存池 */
static void mem_pool_init(uint32_t all_mem) {
c0002b8a:	55                   	push   %ebp
c0002b8b:	89 e5                	mov    %esp,%ebp
c0002b8d:	83 ec 38             	sub    $0x38,%esp
/work/x86_os_my/kernel/memory.c:261
	put_str("   mem_pool_init start\n");
c0002b90:	83 ec 0c             	sub    $0xc,%esp
c0002b93:	68 cc 4c 00 c0       	push   $0xc0004ccc
c0002b98:	e8 93 f5 ff ff       	call   c0002130 <put_str>
c0002b9d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:262
	uint32_t page_table_size = PG_SIZE * 256;		// 页表大小= 1页的页目录表+第0和第768个页目录项指向同一个页表+
c0002ba0:	c7 45 f4 00 00 10 00 	movl   $0x100000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:264
													// 第769~1022个页目录项共指向254个页表,共256个页框
	uint32_t used_mem = page_table_size + 0x100000;	// 0x100000为低端1M内存
c0002ba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002baa:	05 00 00 10 00       	add    $0x100000,%eax
c0002baf:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:265
	uint32_t free_mem = all_mem - used_mem;
c0002bb2:	8b 45 08             	mov    0x8(%ebp),%eax
c0002bb5:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0002bb8:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:266
	uint16_t all_free_pages = free_mem / PG_SIZE;	// 1页为4k,不管总内存是不是4k的倍数,
c0002bbb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002bbe:	c1 e8 0c             	shr    $0xc,%eax
c0002bc1:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
/work/x86_os_my/kernel/memory.c:268
													// 对于以页为单位的内存分配策略，不足1页的内存不用考虑了。
	uint16_t kernel_free_pages = all_free_pages / 2;
c0002bc5:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c0002bc9:	66 d1 e8             	shr    %ax
c0002bcc:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:269
	uint16_t user_free_pages = all_free_pages - kernel_free_pages;
c0002bd0:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c0002bd4:	66 2b 45 e8          	sub    -0x18(%ebp),%ax
c0002bd8:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
/work/x86_os_my/kernel/memory.c:273

	/* 为简化位图操作，余数不处理，坏处是这样做会丢内存。
	好处是不用做内存的越界检查,因为位图表示的内存少于实际物理内存*/
	uint32_t kbm_length = kernel_free_pages / 8;	// Kernel BitMap的长度,位图中的一位表示一页,以字节为单位
c0002bdc:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0002be0:	66 c1 e8 03          	shr    $0x3,%ax
c0002be4:	0f b7 c0             	movzwl %ax,%eax
c0002be7:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/kernel/memory.c:274
	uint32_t ubm_length = user_free_pages / 8;		// User BitMap的长度.
c0002bea:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c0002bee:	66 c1 e8 03          	shr    $0x3,%ax
c0002bf2:	0f b7 c0             	movzwl %ax,%eax
c0002bf5:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/kernel/memory.c:276

	uint32_t kp_start = used_mem;								// Kernel Pool start,内核内存池的起始地址
c0002bf8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002bfb:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/kernel/memory.c:277
	uint32_t up_start = kp_start + kernel_free_pages * PG_SIZE;	// User Pool start,用户内存池的起始地址
c0002bfe:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0002c02:	c1 e0 0c             	shl    $0xc,%eax
c0002c05:	89 c2                	mov    %eax,%edx
c0002c07:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0002c0a:	01 d0                	add    %edx,%eax
c0002c0c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:279

	kernel_pool.phy_addr_start = kp_start;
c0002c0f:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0002c12:	a3 08 77 00 c0       	mov    %eax,0xc0007708
/work/x86_os_my/kernel/memory.c:280
	user_pool.phy_addr_start   = up_start;
c0002c17:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002c1a:	a3 c8 76 00 c0       	mov    %eax,0xc00076c8
/work/x86_os_my/kernel/memory.c:282

	kernel_pool.pool_size = kernel_free_pages * PG_SIZE;
c0002c1f:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0002c23:	c1 e0 0c             	shl    $0xc,%eax
c0002c26:	a3 0c 77 00 c0       	mov    %eax,0xc000770c
/work/x86_os_my/kernel/memory.c:283
	user_pool.pool_size	 = user_free_pages * PG_SIZE;
c0002c2b:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c0002c2f:	c1 e0 0c             	shl    $0xc,%eax
c0002c32:	a3 cc 76 00 c0       	mov    %eax,0xc00076cc
/work/x86_os_my/kernel/memory.c:285

	kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;
c0002c37:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002c3a:	a3 00 77 00 c0       	mov    %eax,0xc0007700
/work/x86_os_my/kernel/memory.c:286
	user_pool.pool_bitmap.btmp_bytes_len	  = ubm_length;
c0002c3f:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0002c42:	a3 c0 76 00 c0       	mov    %eax,0xc00076c0
/work/x86_os_my/kernel/memory.c:295
	*	而我们需要根据总内存大小在运行时，计算出位图的数组需要多少字节。
	*   所以改为指定一块内存来生成位图.
	*   ************************************************/
	// 内核使用的最高地址是0xc009f000,这是主线程的栈地址.(内核的大小预计为70K左右)
	// 32M内存占用的位图是2k.内核内存池的位图先定在MEM_BITMAP_BASE(0xc009a000)处.
	kernel_pool.pool_bitmap.bits = (void*)MEM_BITMAP_BASE;
c0002c47:	c7 05 04 77 00 c0 00 	movl   $0xc009a000,0xc0007704
c0002c4e:	a0 09 c0 
/work/x86_os_my/kernel/memory.c:297
	/* 用户内存池的位图紧跟在内核内存池位图之后 */
	user_pool.pool_bitmap.bits = (void*)(MEM_BITMAP_BASE + kbm_length);
c0002c51:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002c54:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c0002c59:	a3 c4 76 00 c0       	mov    %eax,0xc00076c4
/work/x86_os_my/kernel/memory.c:300
	
	/******************** 输出内存池信息 **********************/
	put_str("      kernel_pool_bitmap_start:");put_int((int)kernel_pool.pool_bitmap.bits);
c0002c5e:	83 ec 0c             	sub    $0xc,%esp
c0002c61:	68 e4 4c 00 c0       	push   $0xc0004ce4
c0002c66:	e8 c5 f4 ff ff       	call   c0002130 <put_str>
c0002c6b:	83 c4 10             	add    $0x10,%esp
c0002c6e:	a1 04 77 00 c0       	mov    0xc0007704,%eax
c0002c73:	83 ec 0c             	sub    $0xc,%esp
c0002c76:	50                   	push   %eax
c0002c77:	e8 9f f5 ff ff       	call   c000221b <put_int>
c0002c7c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:301
	put_str(" kernel_pool_phy_addr_start:");put_int(kernel_pool.phy_addr_start);
c0002c7f:	83 ec 0c             	sub    $0xc,%esp
c0002c82:	68 04 4d 00 c0       	push   $0xc0004d04
c0002c87:	e8 a4 f4 ff ff       	call   c0002130 <put_str>
c0002c8c:	83 c4 10             	add    $0x10,%esp
c0002c8f:	a1 08 77 00 c0       	mov    0xc0007708,%eax
c0002c94:	83 ec 0c             	sub    $0xc,%esp
c0002c97:	50                   	push   %eax
c0002c98:	e8 7e f5 ff ff       	call   c000221b <put_int>
c0002c9d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:302
	put_str("\n");
c0002ca0:	83 ec 0c             	sub    $0xc,%esp
c0002ca3:	68 21 4d 00 c0       	push   $0xc0004d21
c0002ca8:	e8 83 f4 ff ff       	call   c0002130 <put_str>
c0002cad:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:303
	put_str("      user_pool_bitmap_start:");put_int((int)user_pool.pool_bitmap.bits);
c0002cb0:	83 ec 0c             	sub    $0xc,%esp
c0002cb3:	68 23 4d 00 c0       	push   $0xc0004d23
c0002cb8:	e8 73 f4 ff ff       	call   c0002130 <put_str>
c0002cbd:	83 c4 10             	add    $0x10,%esp
c0002cc0:	a1 c4 76 00 c0       	mov    0xc00076c4,%eax
c0002cc5:	83 ec 0c             	sub    $0xc,%esp
c0002cc8:	50                   	push   %eax
c0002cc9:	e8 4d f5 ff ff       	call   c000221b <put_int>
c0002cce:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:304
	put_str(" user_pool_phy_addr_start:");put_int(user_pool.phy_addr_start);
c0002cd1:	83 ec 0c             	sub    $0xc,%esp
c0002cd4:	68 41 4d 00 c0       	push   $0xc0004d41
c0002cd9:	e8 52 f4 ff ff       	call   c0002130 <put_str>
c0002cde:	83 c4 10             	add    $0x10,%esp
c0002ce1:	a1 c8 76 00 c0       	mov    0xc00076c8,%eax
c0002ce6:	83 ec 0c             	sub    $0xc,%esp
c0002ce9:	50                   	push   %eax
c0002cea:	e8 2c f5 ff ff       	call   c000221b <put_int>
c0002cef:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:305
	put_str("\n");
c0002cf2:	83 ec 0c             	sub    $0xc,%esp
c0002cf5:	68 21 4d 00 c0       	push   $0xc0004d21
c0002cfa:	e8 31 f4 ff ff       	call   c0002130 <put_str>
c0002cff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:308

	/* 将位图置0*/
	bitmap_init(&kernel_pool.pool_bitmap);
c0002d02:	83 ec 0c             	sub    $0xc,%esp
c0002d05:	68 00 77 00 c0       	push   $0xc0007700
c0002d0a:	e8 69 f6 ff ff       	call   c0002378 <bitmap_init>
c0002d0f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:309
	bitmap_init(&user_pool.pool_bitmap);
c0002d12:	83 ec 0c             	sub    $0xc,%esp
c0002d15:	68 c0 76 00 c0       	push   $0xc00076c0
c0002d1a:	e8 59 f6 ff ff       	call   c0002378 <bitmap_init>
c0002d1f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:311

	lock_init(&kernel_pool.lock);
c0002d22:	83 ec 0c             	sub    $0xc,%esp
c0002d25:	68 10 77 00 c0       	push   $0xc0007710
c0002d2a:	e8 b6 0c 00 00       	call   c00039e5 <lock_init>
c0002d2f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:312
	lock_init(&user_pool.lock);
c0002d32:	83 ec 0c             	sub    $0xc,%esp
c0002d35:	68 d0 76 00 c0       	push   $0xc00076d0
c0002d3a:	e8 a6 0c 00 00       	call   c00039e5 <lock_init>
c0002d3f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:316
	
	/* 下面初始化内核虚拟地址的位图(bp_len + bits数组),按实际物理内存大小生成数组。*/
	// 用于维护内核堆的虚拟地址,所以要和内核内存池大小一致
	kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;
c0002d42:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002d45:	a3 ec 76 00 c0       	mov    %eax,0xc00076ec
/work/x86_os_my/kernel/memory.c:318
	/* 位图的数组指向一块未使用的内存,目前定位在内核内存池和用户内存池之外*/
	kernel_vaddr.vaddr_bitmap.bits = (void*)(MEM_BITMAP_BASE + kbm_length + ubm_length);
c0002d4a:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0002d4d:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0002d50:	01 d0                	add    %edx,%eax
c0002d52:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c0002d57:	a3 f0 76 00 c0       	mov    %eax,0xc00076f0
/work/x86_os_my/kernel/memory.c:320

	kernel_vaddr.vaddr_start = K_HEAP_START;
c0002d5c:	c7 05 f4 76 00 c0 00 	movl   $0xc0100000,0xc00076f4
c0002d63:	00 10 c0 
/work/x86_os_my/kernel/memory.c:321
	bitmap_init(&kernel_vaddr.vaddr_bitmap);
c0002d66:	83 ec 0c             	sub    $0xc,%esp
c0002d69:	68 ec 76 00 c0       	push   $0xc00076ec
c0002d6e:	e8 05 f6 ff ff       	call   c0002378 <bitmap_init>
c0002d73:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:322
	put_str("   mem_pool_init done\n");
c0002d76:	83 ec 0c             	sub    $0xc,%esp
c0002d79:	68 5c 4d 00 c0       	push   $0xc0004d5c
c0002d7e:	e8 ad f3 ff ff       	call   c0002130 <put_str>
c0002d83:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:323
}
c0002d86:	90                   	nop
c0002d87:	c9                   	leave  
c0002d88:	c3                   	ret    

c0002d89 <mem_init>:
mem_init():
/work/x86_os_my/kernel/memory.c:326

/* 内存管理部分初始化入口 */
void mem_init() {
c0002d89:	55                   	push   %ebp
c0002d8a:	89 e5                	mov    %esp,%ebp
c0002d8c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:327
	put_str("mem_init start\n");
c0002d8f:	83 ec 0c             	sub    $0xc,%esp
c0002d92:	68 73 4d 00 c0       	push   $0xc0004d73
c0002d97:	e8 94 f3 ff ff       	call   c0002130 <put_str>
c0002d9c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:328
	uint32_t mem_bytes_total = (*(uint32_t*)(0xb00));	//内存总数在汇编中获取，放到了地址0xb00处。
c0002d9f:	b8 00 0b 00 00       	mov    $0xb00,%eax
c0002da4:	8b 00                	mov    (%eax),%eax
c0002da6:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:329
	mem_pool_init(mem_bytes_total);	  // 初始化内存池
c0002da9:	83 ec 0c             	sub    $0xc,%esp
c0002dac:	ff 75 f4             	pushl  -0xc(%ebp)
c0002daf:	e8 d6 fd ff ff       	call   c0002b8a <mem_pool_init>
c0002db4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:330
	put_str("mem_init done\n");
c0002db7:	83 ec 0c             	sub    $0xc,%esp
c0002dba:	68 83 4d 00 c0       	push   $0xc0004d83
c0002dbf:	e8 6c f3 ff ff       	call   c0002130 <put_str>
c0002dc4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:331
}
c0002dc7:	90                   	nop
c0002dc8:	c9                   	leave  
c0002dc9:	c3                   	ret    

c0002dca <memset>:
memset():
/work/x86_os_my/lib/string.c:6
#include "string.h"
#include "global.h"
#include "debug.h"

/* 将dst_起始的size个字节置为value */
void memset(void* dst_, uint8_t value, uint32_t size) {
c0002dca:	55                   	push   %ebp
c0002dcb:	89 e5                	mov    %esp,%ebp
c0002dcd:	83 ec 28             	sub    $0x28,%esp
c0002dd0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002dd3:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:7
   ASSERT(dst_ != NULL);
c0002dd6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002dda:	75 19                	jne    c0002df5 <memset+0x2b>
/work/x86_os_my/lib/string.c:7 (discriminator 1)
c0002ddc:	68 c8 4d 00 c0       	push   $0xc0004dc8
c0002de1:	68 3c 4e 00 c0       	push   $0xc0004e3c
c0002de6:	6a 07                	push   $0x7
c0002de8:	68 d5 4d 00 c0       	push   $0xc0004dd5
c0002ded:	e8 b0 f4 ff ff       	call   c00022a2 <panic_spin>
c0002df2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:8
   uint8_t* dst = (uint8_t*)dst_;
c0002df5:	8b 45 08             	mov    0x8(%ebp),%eax
c0002df8:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:9
   while (size-- > 0)
c0002dfb:	eb 0f                	jmp    c0002e0c <memset+0x42>
/work/x86_os_my/lib/string.c:10
      *dst++ = value;
c0002dfd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002e00:	8d 50 01             	lea    0x1(%eax),%edx
c0002e03:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0002e06:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c0002e0a:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/string.c:9

/* 将dst_起始的size个字节置为value */
void memset(void* dst_, uint8_t value, uint32_t size) {
   ASSERT(dst_ != NULL);
   uint8_t* dst = (uint8_t*)dst_;
   while (size-- > 0)
c0002e0c:	8b 45 10             	mov    0x10(%ebp),%eax
c0002e0f:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002e12:	89 55 10             	mov    %edx,0x10(%ebp)
c0002e15:	85 c0                	test   %eax,%eax
c0002e17:	75 e4                	jne    c0002dfd <memset+0x33>
/work/x86_os_my/lib/string.c:11
      *dst++ = value;
}
c0002e19:	90                   	nop
c0002e1a:	c9                   	leave  
c0002e1b:	c3                   	ret    

c0002e1c <memcpy>:
memcpy():
/work/x86_os_my/lib/string.c:14

/* 将src_起始的size个字节复制到dst_ */
void memcpy(void* dst_, const void* src_, uint32_t size) {
c0002e1c:	55                   	push   %ebp
c0002e1d:	89 e5                	mov    %esp,%ebp
c0002e1f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:15
   ASSERT(dst_ != NULL && src_ != NULL);
c0002e22:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002e26:	74 06                	je     c0002e2e <memcpy+0x12>
/work/x86_os_my/lib/string.c:15 (discriminator 1)
c0002e28:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002e2c:	75 19                	jne    c0002e47 <memcpy+0x2b>
/work/x86_os_my/lib/string.c:15 (discriminator 3)
c0002e2e:	68 e2 4d 00 c0       	push   $0xc0004de2
c0002e33:	68 44 4e 00 c0       	push   $0xc0004e44
c0002e38:	6a 0f                	push   $0xf
c0002e3a:	68 d5 4d 00 c0       	push   $0xc0004dd5
c0002e3f:	e8 5e f4 ff ff       	call   c00022a2 <panic_spin>
c0002e44:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:16
   uint8_t* dst = dst_;
c0002e47:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:17
   const uint8_t* src = src_;
c0002e4d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002e50:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:18
   while (size-- > 0)
c0002e53:	eb 17                	jmp    c0002e6c <memcpy+0x50>
/work/x86_os_my/lib/string.c:19
      *dst++ = *src++;
c0002e55:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002e58:	8d 50 01             	lea    0x1(%eax),%edx
c0002e5b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0002e5e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002e61:	8d 4a 01             	lea    0x1(%edx),%ecx
c0002e64:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0002e67:	0f b6 12             	movzbl (%edx),%edx
c0002e6a:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/string.c:18
/* 将src_起始的size个字节复制到dst_ */
void memcpy(void* dst_, const void* src_, uint32_t size) {
   ASSERT(dst_ != NULL && src_ != NULL);
   uint8_t* dst = dst_;
   const uint8_t* src = src_;
   while (size-- > 0)
c0002e6c:	8b 45 10             	mov    0x10(%ebp),%eax
c0002e6f:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002e72:	89 55 10             	mov    %edx,0x10(%ebp)
c0002e75:	85 c0                	test   %eax,%eax
c0002e77:	75 dc                	jne    c0002e55 <memcpy+0x39>
/work/x86_os_my/lib/string.c:20
      *dst++ = *src++;
}
c0002e79:	90                   	nop
c0002e7a:	c9                   	leave  
c0002e7b:	c3                   	ret    

c0002e7c <memcmp>:
memcmp():
/work/x86_os_my/lib/string.c:23

/* 连续比较以地址a_和地址b_开头的size个字节,若相等则返回0,若a_大于b_返回+1,否则返回-1 */
int memcmp(const void* a_, const void* b_, uint32_t size) {
c0002e7c:	55                   	push   %ebp
c0002e7d:	89 e5                	mov    %esp,%ebp
c0002e7f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:24
   const char* a = a_;
c0002e82:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e85:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:25
   const char* b = b_;
c0002e88:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002e8b:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:26
   ASSERT(a != NULL || b != NULL);
c0002e8e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002e92:	75 57                	jne    c0002eeb <memcmp+0x6f>
/work/x86_os_my/lib/string.c:26 (discriminator 1)
c0002e94:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0002e98:	75 51                	jne    c0002eeb <memcmp+0x6f>
/work/x86_os_my/lib/string.c:26 (discriminator 2)
c0002e9a:	68 ff 4d 00 c0       	push   $0xc0004dff
c0002e9f:	68 4c 4e 00 c0       	push   $0xc0004e4c
c0002ea4:	6a 1a                	push   $0x1a
c0002ea6:	68 d5 4d 00 c0       	push   $0xc0004dd5
c0002eab:	e8 f2 f3 ff ff       	call   c00022a2 <panic_spin>
c0002eb0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:27 (discriminator 2)
   while (size-- > 0) {
c0002eb3:	eb 36                	jmp    c0002eeb <memcmp+0x6f>
/work/x86_os_my/lib/string.c:28
      if(*a != *b) {
c0002eb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002eb8:	0f b6 10             	movzbl (%eax),%edx
c0002ebb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002ebe:	0f b6 00             	movzbl (%eax),%eax
c0002ec1:	38 c2                	cmp    %al,%dl
c0002ec3:	74 1e                	je     c0002ee3 <memcmp+0x67>
/work/x86_os_my/lib/string.c:29
	 return *a > *b ? 1 : -1; 
c0002ec5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002ec8:	0f b6 10             	movzbl (%eax),%edx
c0002ecb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002ece:	0f b6 00             	movzbl (%eax),%eax
c0002ed1:	38 c2                	cmp    %al,%dl
c0002ed3:	7e 07                	jle    c0002edc <memcmp+0x60>
/work/x86_os_my/lib/string.c:29 (discriminator 1)
c0002ed5:	b8 01 00 00 00       	mov    $0x1,%eax
c0002eda:	eb 21                	jmp    c0002efd <memcmp+0x81>
/work/x86_os_my/lib/string.c:29 (discriminator 2)
c0002edc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002ee1:	eb 1a                	jmp    c0002efd <memcmp+0x81>
/work/x86_os_my/lib/string.c:31
      }
      a++;
c0002ee3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:32
      b++;
c0002ee7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/string.c:27
/* 连续比较以地址a_和地址b_开头的size个字节,若相等则返回0,若a_大于b_返回+1,否则返回-1 */
int memcmp(const void* a_, const void* b_, uint32_t size) {
   const char* a = a_;
   const char* b = b_;
   ASSERT(a != NULL || b != NULL);
   while (size-- > 0) {
c0002eeb:	8b 45 10             	mov    0x10(%ebp),%eax
c0002eee:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002ef1:	89 55 10             	mov    %edx,0x10(%ebp)
c0002ef4:	85 c0                	test   %eax,%eax
c0002ef6:	75 bd                	jne    c0002eb5 <memcmp+0x39>
/work/x86_os_my/lib/string.c:34
	 return *a > *b ? 1 : -1; 
      }
      a++;
      b++;
   }
   return 0;
c0002ef8:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/string.c:35
}
c0002efd:	c9                   	leave  
c0002efe:	c3                   	ret    

c0002eff <strcpy>:
strcpy():
/work/x86_os_my/lib/string.c:38

/* 将字符串从src_复制到dst_ */
char* strcpy(char* dst_, const char* src_) {
c0002eff:	55                   	push   %ebp
c0002f00:	89 e5                	mov    %esp,%ebp
c0002f02:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:39
   ASSERT(dst_ != NULL && src_ != NULL);
c0002f05:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002f09:	74 06                	je     c0002f11 <strcpy+0x12>
/work/x86_os_my/lib/string.c:39 (discriminator 1)
c0002f0b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002f0f:	75 19                	jne    c0002f2a <strcpy+0x2b>
/work/x86_os_my/lib/string.c:39 (discriminator 3)
c0002f11:	68 e2 4d 00 c0       	push   $0xc0004de2
c0002f16:	68 54 4e 00 c0       	push   $0xc0004e54
c0002f1b:	6a 27                	push   $0x27
c0002f1d:	68 d5 4d 00 c0       	push   $0xc0004dd5
c0002f22:	e8 7b f3 ff ff       	call   c00022a2 <panic_spin>
c0002f27:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:40
   char* r = dst_;		       // 用来返回目的字符串起始地址
c0002f2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f2d:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:41
   while((*dst_++ = *src_++));
c0002f30:	90                   	nop
/work/x86_os_my/lib/string.c:41 (discriminator 1)
c0002f31:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f34:	8d 50 01             	lea    0x1(%eax),%edx
c0002f37:	89 55 08             	mov    %edx,0x8(%ebp)
c0002f3a:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002f3d:	8d 4a 01             	lea    0x1(%edx),%ecx
c0002f40:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c0002f43:	0f b6 12             	movzbl (%edx),%edx
c0002f46:	88 10                	mov    %dl,(%eax)
c0002f48:	0f b6 00             	movzbl (%eax),%eax
c0002f4b:	84 c0                	test   %al,%al
c0002f4d:	75 e2                	jne    c0002f31 <strcpy+0x32>
/work/x86_os_my/lib/string.c:42
   return r;
c0002f4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:43
}
c0002f52:	c9                   	leave  
c0002f53:	c3                   	ret    

c0002f54 <strlen>:
strlen():
/work/x86_os_my/lib/string.c:46

/* 返回字符串长度 */
uint32_t strlen(const char* str) {
c0002f54:	55                   	push   %ebp
c0002f55:	89 e5                	mov    %esp,%ebp
c0002f57:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:47
   ASSERT(str != NULL);
c0002f5a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002f5e:	75 19                	jne    c0002f79 <strlen+0x25>
/work/x86_os_my/lib/string.c:47 (discriminator 1)
c0002f60:	68 16 4e 00 c0       	push   $0xc0004e16
c0002f65:	68 5c 4e 00 c0       	push   $0xc0004e5c
c0002f6a:	6a 2f                	push   $0x2f
c0002f6c:	68 d5 4d 00 c0       	push   $0xc0004dd5
c0002f71:	e8 2c f3 ff ff       	call   c00022a2 <panic_spin>
c0002f76:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:48
   const char* p = str;
c0002f79:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f7c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:49
   while(*p++);
c0002f7f:	90                   	nop
/work/x86_os_my/lib/string.c:49 (discriminator 1)
c0002f80:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002f83:	8d 50 01             	lea    0x1(%eax),%edx
c0002f86:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0002f89:	0f b6 00             	movzbl (%eax),%eax
c0002f8c:	84 c0                	test   %al,%al
c0002f8e:	75 f0                	jne    c0002f80 <strlen+0x2c>
/work/x86_os_my/lib/string.c:50
   return (p - str - 1);
c0002f90:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002f93:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f96:	29 c2                	sub    %eax,%edx
c0002f98:	89 d0                	mov    %edx,%eax
c0002f9a:	83 e8 01             	sub    $0x1,%eax
/work/x86_os_my/lib/string.c:51
}
c0002f9d:	c9                   	leave  
c0002f9e:	c3                   	ret    

c0002f9f <strcmp>:
strcmp():
/work/x86_os_my/lib/string.c:54

/* 比较两个字符串,若a_中的字符大于b_中的字符返回1,相等时返回0,否则返回-1. */
int8_t strcmp (const char* a, const char* b) {
c0002f9f:	55                   	push   %ebp
c0002fa0:	89 e5                	mov    %esp,%ebp
c0002fa2:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/string.c:55
   ASSERT(a != NULL && b != NULL);
c0002fa5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002fa9:	74 06                	je     c0002fb1 <strcmp+0x12>
/work/x86_os_my/lib/string.c:55 (discriminator 1)
c0002fab:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002faf:	75 19                	jne    c0002fca <strcmp+0x2b>
/work/x86_os_my/lib/string.c:55 (discriminator 3)
c0002fb1:	68 22 4e 00 c0       	push   $0xc0004e22
c0002fb6:	68 64 4e 00 c0       	push   $0xc0004e64
c0002fbb:	6a 37                	push   $0x37
c0002fbd:	68 d5 4d 00 c0       	push   $0xc0004dd5
c0002fc2:	e8 db f2 ff ff       	call   c00022a2 <panic_spin>
c0002fc7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:56 (discriminator 1)
   while (*a != 0 && *a == *b) {
c0002fca:	eb 08                	jmp    c0002fd4 <strcmp+0x35>
/work/x86_os_my/lib/string.c:57
      a++;
c0002fcc:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:58
      b++;
c0002fd0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
/work/x86_os_my/lib/string.c:56
}

/* 比较两个字符串,若a_中的字符大于b_中的字符返回1,相等时返回0,否则返回-1. */
int8_t strcmp (const char* a, const char* b) {
   ASSERT(a != NULL && b != NULL);
   while (*a != 0 && *a == *b) {
c0002fd4:	8b 45 08             	mov    0x8(%ebp),%eax
c0002fd7:	0f b6 00             	movzbl (%eax),%eax
c0002fda:	84 c0                	test   %al,%al
c0002fdc:	74 10                	je     c0002fee <strcmp+0x4f>
/work/x86_os_my/lib/string.c:56 (discriminator 1)
c0002fde:	8b 45 08             	mov    0x8(%ebp),%eax
c0002fe1:	0f b6 10             	movzbl (%eax),%edx
c0002fe4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002fe7:	0f b6 00             	movzbl (%eax),%eax
c0002fea:	38 c2                	cmp    %al,%dl
c0002fec:	74 de                	je     c0002fcc <strcmp+0x2d>
/work/x86_os_my/lib/string.c:62
      a++;
      b++;
   }
/* 如果*a小于*b就返回-1,否则就属于*a大于等于*b的情况。在后面的布尔表达式"*a > *b"中,
 * 若*a大于*b,表达式就等于1,否则就表达式不成立,也就是布尔值为0,恰恰表示*a等于*b */
   return *a < *b ? -1 : *a > *b;
c0002fee:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ff1:	0f b6 10             	movzbl (%eax),%edx
c0002ff4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002ff7:	0f b6 00             	movzbl (%eax),%eax
c0002ffa:	38 c2                	cmp    %al,%dl
c0002ffc:	7c 13                	jl     c0003011 <strcmp+0x72>
/work/x86_os_my/lib/string.c:62 (discriminator 1)
c0002ffe:	8b 45 08             	mov    0x8(%ebp),%eax
c0003001:	0f b6 10             	movzbl (%eax),%edx
c0003004:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003007:	0f b6 00             	movzbl (%eax),%eax
c000300a:	38 c2                	cmp    %al,%dl
c000300c:	0f 9f c0             	setg   %al
c000300f:	eb 05                	jmp    c0003016 <strcmp+0x77>
/work/x86_os_my/lib/string.c:62 (discriminator 2)
c0003011:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/lib/string.c:63 (discriminator 5)
}
c0003016:	c9                   	leave  
c0003017:	c3                   	ret    

c0003018 <strchr>:
strchr():
/work/x86_os_my/lib/string.c:66

/* 从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strchr(const char* str, const uint8_t ch) {
c0003018:	55                   	push   %ebp
c0003019:	89 e5                	mov    %esp,%ebp
c000301b:	83 ec 18             	sub    $0x18,%esp
c000301e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003021:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/lib/string.c:67
   ASSERT(str != NULL);
c0003024:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003028:	75 35                	jne    c000305f <strchr+0x47>
/work/x86_os_my/lib/string.c:67 (discriminator 1)
c000302a:	68 16 4e 00 c0       	push   $0xc0004e16
c000302f:	68 6c 4e 00 c0       	push   $0xc0004e6c
c0003034:	6a 43                	push   $0x43
c0003036:	68 d5 4d 00 c0       	push   $0xc0004dd5
c000303b:	e8 62 f2 ff ff       	call   c00022a2 <panic_spin>
c0003040:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:68 (discriminator 1)
   while (*str != 0) {
c0003043:	eb 1a                	jmp    c000305f <strchr+0x47>
/work/x86_os_my/lib/string.c:69
      if (*str == ch) {
c0003045:	8b 45 08             	mov    0x8(%ebp),%eax
c0003048:	0f b6 00             	movzbl (%eax),%eax
c000304b:	0f be d0             	movsbl %al,%edx
c000304e:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0003052:	39 c2                	cmp    %eax,%edx
c0003054:	75 05                	jne    c000305b <strchr+0x43>
/work/x86_os_my/lib/string.c:70
	 return (char*)str;	    // 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.
c0003056:	8b 45 08             	mov    0x8(%ebp),%eax
c0003059:	eb 13                	jmp    c000306e <strchr+0x56>
/work/x86_os_my/lib/string.c:72
      }
      str++;
c000305b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:68
}

/* 从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strchr(const char* str, const uint8_t ch) {
   ASSERT(str != NULL);
   while (*str != 0) {
c000305f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003062:	0f b6 00             	movzbl (%eax),%eax
c0003065:	84 c0                	test   %al,%al
c0003067:	75 dc                	jne    c0003045 <strchr+0x2d>
/work/x86_os_my/lib/string.c:74
      if (*str == ch) {
	 return (char*)str;	    // 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.
      }
      str++;
   }
   return NULL;
c0003069:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/string.c:75
}
c000306e:	c9                   	leave  
c000306f:	c3                   	ret    

c0003070 <strrchr>:
strrchr():
/work/x86_os_my/lib/string.c:78

/* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strrchr(const char* str, const uint8_t ch) {
c0003070:	55                   	push   %ebp
c0003071:	89 e5                	mov    %esp,%ebp
c0003073:	83 ec 28             	sub    $0x28,%esp
c0003076:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003079:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:79
   ASSERT(str != NULL);
c000307c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003080:	75 19                	jne    c000309b <strrchr+0x2b>
/work/x86_os_my/lib/string.c:79 (discriminator 1)
c0003082:	68 16 4e 00 c0       	push   $0xc0004e16
c0003087:	68 74 4e 00 c0       	push   $0xc0004e74
c000308c:	6a 4f                	push   $0x4f
c000308e:	68 d5 4d 00 c0       	push   $0xc0004dd5
c0003093:	e8 0a f2 ff ff       	call   c00022a2 <panic_spin>
c0003098:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:80
   const char* last_char = NULL;
c000309b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/string.c:82
   /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/
   while (*str != 0) {
c00030a2:	eb 1b                	jmp    c00030bf <strrchr+0x4f>
/work/x86_os_my/lib/string.c:83
      if (*str == ch) {
c00030a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00030a7:	0f b6 00             	movzbl (%eax),%eax
c00030aa:	0f be d0             	movsbl %al,%edx
c00030ad:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c00030b1:	39 c2                	cmp    %eax,%edx
c00030b3:	75 06                	jne    c00030bb <strrchr+0x4b>
/work/x86_os_my/lib/string.c:84
	 last_char = str;
c00030b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00030b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:86
      }
      str++;
c00030bb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:82
/* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strrchr(const char* str, const uint8_t ch) {
   ASSERT(str != NULL);
   const char* last_char = NULL;
   /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/
   while (*str != 0) {
c00030bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00030c2:	0f b6 00             	movzbl (%eax),%eax
c00030c5:	84 c0                	test   %al,%al
c00030c7:	75 db                	jne    c00030a4 <strrchr+0x34>
/work/x86_os_my/lib/string.c:88
      if (*str == ch) {
	 last_char = str;
      }
      str++;
   }
   return (char*)last_char;
c00030c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:89
}
c00030cc:	c9                   	leave  
c00030cd:	c3                   	ret    

c00030ce <strcat>:
strcat():
/work/x86_os_my/lib/string.c:92

/* 将字符串src_拼接到dst_后,将回拼接的串地址 */
char* strcat(char* dst_, const char* src_) {
c00030ce:	55                   	push   %ebp
c00030cf:	89 e5                	mov    %esp,%ebp
c00030d1:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:93
   ASSERT(dst_ != NULL && src_ != NULL);
c00030d4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00030d8:	74 06                	je     c00030e0 <strcat+0x12>
/work/x86_os_my/lib/string.c:93 (discriminator 1)
c00030da:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00030de:	75 19                	jne    c00030f9 <strcat+0x2b>
/work/x86_os_my/lib/string.c:93 (discriminator 3)
c00030e0:	68 e2 4d 00 c0       	push   $0xc0004de2
c00030e5:	68 7c 4e 00 c0       	push   $0xc0004e7c
c00030ea:	6a 5d                	push   $0x5d
c00030ec:	68 d5 4d 00 c0       	push   $0xc0004dd5
c00030f1:	e8 ac f1 ff ff       	call   c00022a2 <panic_spin>
c00030f6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:94
   char* str = dst_;
c00030f9:	8b 45 08             	mov    0x8(%ebp),%eax
c00030fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:95
   while (*str++);
c00030ff:	90                   	nop
/work/x86_os_my/lib/string.c:95 (discriminator 1)
c0003100:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003103:	8d 50 01             	lea    0x1(%eax),%edx
c0003106:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003109:	0f b6 00             	movzbl (%eax),%eax
c000310c:	84 c0                	test   %al,%al
c000310e:	75 f0                	jne    c0003100 <strcat+0x32>
/work/x86_os_my/lib/string.c:96
   --str;      // 别看错了，--str是独立的一句，并不是while的循环体
c0003110:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:97
   while((*str++ = *src_++));	 // 当*str被赋值为0时,此时表达式不成立,正好添加了字符串结尾的0.
c0003114:	90                   	nop
/work/x86_os_my/lib/string.c:97 (discriminator 1)
c0003115:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003118:	8d 50 01             	lea    0x1(%eax),%edx
c000311b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000311e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003121:	8d 4a 01             	lea    0x1(%edx),%ecx
c0003124:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c0003127:	0f b6 12             	movzbl (%edx),%edx
c000312a:	88 10                	mov    %dl,(%eax)
c000312c:	0f b6 00             	movzbl (%eax),%eax
c000312f:	84 c0                	test   %al,%al
c0003131:	75 e2                	jne    c0003115 <strcat+0x47>
/work/x86_os_my/lib/string.c:98
   return dst_;
c0003133:	8b 45 08             	mov    0x8(%ebp),%eax
/work/x86_os_my/lib/string.c:99
}
c0003136:	c9                   	leave  
c0003137:	c3                   	ret    

c0003138 <strchrs>:
strchrs():
/work/x86_os_my/lib/string.c:102

/* 在字符串str中查找指定字符ch出现的次数 */
uint32_t strchrs(const char* str, uint8_t ch) {
c0003138:	55                   	push   %ebp
c0003139:	89 e5                	mov    %esp,%ebp
c000313b:	83 ec 28             	sub    $0x28,%esp
c000313e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003141:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:103
   ASSERT(str != NULL);
c0003144:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003148:	75 19                	jne    c0003163 <strchrs+0x2b>
/work/x86_os_my/lib/string.c:103 (discriminator 1)
c000314a:	68 16 4e 00 c0       	push   $0xc0004e16
c000314f:	68 84 4e 00 c0       	push   $0xc0004e84
c0003154:	6a 67                	push   $0x67
c0003156:	68 d5 4d 00 c0       	push   $0xc0004dd5
c000315b:	e8 42 f1 ff ff       	call   c00022a2 <panic_spin>
c0003160:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:104
   uint32_t ch_cnt = 0;
c0003163:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/string.c:105
   const char* p = str;
c000316a:	8b 45 08             	mov    0x8(%ebp),%eax
c000316d:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:106
   while(*p != 0) {
c0003170:	eb 19                	jmp    c000318b <strchrs+0x53>
/work/x86_os_my/lib/string.c:107
      if (*p == ch) {
c0003172:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003175:	0f b6 00             	movzbl (%eax),%eax
c0003178:	0f be d0             	movsbl %al,%edx
c000317b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c000317f:	39 c2                	cmp    %eax,%edx
c0003181:	75 04                	jne    c0003187 <strchrs+0x4f>
/work/x86_os_my/lib/string.c:108
	 ch_cnt++;
c0003183:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:110
      }
      p++;
c0003187:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/string.c:106
/* 在字符串str中查找指定字符ch出现的次数 */
uint32_t strchrs(const char* str, uint8_t ch) {
   ASSERT(str != NULL);
   uint32_t ch_cnt = 0;
   const char* p = str;
   while(*p != 0) {
c000318b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000318e:	0f b6 00             	movzbl (%eax),%eax
c0003191:	84 c0                	test   %al,%al
c0003193:	75 dd                	jne    c0003172 <strchrs+0x3a>
/work/x86_os_my/lib/string.c:112
      if (*p == ch) {
	 ch_cnt++;
      }
      p++;
   }
   return ch_cnt;
c0003195:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:113
}
c0003198:	c9                   	leave  
c0003199:	c3                   	ret    

c000319a <running_thread>:
running_thread():
/work/x86_os_my/thread/thread.c:22

/* 返回线程 PCB 地址。
 * 各个线程所用的 0 级栈都是在自己的 PCB 当中，
 * 取当前栈指针的高 20 位，就是当前运行线程的 PCB（PCB是在自然页的起始地址！）
 */
struct task_struct* running_thread() {
c000319a:	55                   	push   %ebp
c000319b:	89 e5                	mov    %esp,%ebp
c000319d:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:24
	uint32_t esp;
	asm ("mov %%esp, %0" : "=g" (esp));	//esp寄存器的值，放入变量esp
c00031a0:	89 e0                	mov    %esp,%eax
c00031a2:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:25
	return (struct task_struct*)(esp & 0xfffff000);
c00031a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00031a8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
/work/x86_os_my/thread/thread.c:26
}
c00031ad:	c9                   	leave  
c00031ae:	c3                   	ret    

c00031af <kernel_thread>:
kernel_thread():
/work/x86_os_my/thread/thread.c:29

/* 由kernel_thread去执行function(func_arg) */
static void kernel_thread(thread_func* function, void* func_arg) {
c00031af:	55                   	push   %ebp
c00031b0:	89 e5                	mov    %esp,%ebp
c00031b2:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:35
	/* 线程的首次运行是由时钟中断处理函数调用任务调度器 schedule 完成的，
	 * 进入中断后处理器会自动关中断，
	 * 因此在执行 function 前要打开中断，否则 kernel_thread 中的 function 在关中断的情况下运行，
	 * 也就是时钟中断被屏蔽了，再也不会调度到新的线程，function 会独享处理器。
	 */
	intr_enable();
c00031b5:	e8 b4 e7 ff ff       	call   c000196e <intr_enable>
/work/x86_os_my/thread/thread.c:36
	function(func_arg); 
c00031ba:	83 ec 0c             	sub    $0xc,%esp
c00031bd:	ff 75 0c             	pushl  0xc(%ebp)
c00031c0:	8b 45 08             	mov    0x8(%ebp),%eax
c00031c3:	ff d0                	call   *%eax
c00031c5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:37
}
c00031c8:	90                   	nop
c00031c9:	c9                   	leave  
c00031ca:	c3                   	ret    

c00031cb <thread_create>:
thread_create():
/work/x86_os_my/thread/thread.c:40

/* 初始化线程栈结构体 struct thread_stack */
void thread_create(struct task_struct* pthread, thread_func function, void* func_arg) {
c00031cb:	55                   	push   %ebp
c00031cc:	89 e5                	mov    %esp,%ebp
c00031ce:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:44
	/* 先预留中断使用栈的空间 
	 *（1）将来线程进入中断后，位于 kernel.S 中的中断代码会通过此栈来保存上下文。
	 *（2）将来实现用户进程时，会将用户进程的初始信息放在中断栈中。*/
	pthread->self_kstack -= sizeof(struct intr_stack);
c00031d1:	8b 45 08             	mov    0x8(%ebp),%eax
c00031d4:	8b 00                	mov    (%eax),%eax
c00031d6:	8d 90 d0 fe ff ff    	lea    -0x130(%eax),%edx
c00031dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00031df:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:47

	/* 再留出线程栈空间（unused_retaddr 所在的栈）*/
	pthread->self_kstack -= sizeof(struct thread_stack);
c00031e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00031e4:	8b 00                	mov    (%eax),%eax
c00031e6:	8d 50 80             	lea    -0x80(%eax),%edx
c00031e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00031ec:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:48
	struct thread_stack* kthread_stack = (struct thread_stack*)pthread->self_kstack;
c00031ee:	8b 45 08             	mov    0x8(%ebp),%eax
c00031f1:	8b 00                	mov    (%eax),%eax
c00031f3:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:56
	 * kernel_thread 并不是通过 call 指令调用的，而是通过 ret 来执行的，
	 * 因此无法按照正常的函数调用形式传递 kernel_thread 所需要的参数，
	 * 这样调用是不行的： kernel_thread(function, func_arg)，
	 * 只能将参数放在 kernel_thread 所用的栈中，即处理器进入 kernel_thread 函数体时，
	 * 栈顶为返回地址，栈顶+4 为参数function，栈顶+8 为参数func_arg */
	kthread_stack->eip = kernel_thread;
c00031f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00031f9:	c7 40 10 af 31 00 c0 	movl   $0xc00031af,0x10(%eax)
/work/x86_os_my/thread/thread.c:57
	kthread_stack->function = function;
c0003200:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003203:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003206:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/thread.c:58
	kthread_stack->func_arg = func_arg;
c0003209:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000320c:	8b 55 10             	mov    0x10(%ebp),%edx
c000320f:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/thread/thread.c:59
	kthread_stack->ebp = kthread_stack->ebx = kthread_stack->esi = kthread_stack->edi = 0;
c0003212:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003215:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c000321c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000321f:	8b 50 08             	mov    0x8(%eax),%edx
c0003222:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003225:	89 50 0c             	mov    %edx,0xc(%eax)
c0003228:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000322b:	8b 50 0c             	mov    0xc(%eax),%edx
c000322e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003231:	89 50 04             	mov    %edx,0x4(%eax)
c0003234:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003237:	8b 50 04             	mov    0x4(%eax),%edx
c000323a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000323d:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:60
}
c000323f:	90                   	nop
c0003240:	c9                   	leave  
c0003241:	c3                   	ret    

c0003242 <init_thread>:
init_thread():
/work/x86_os_my/thread/thread.c:63

/* 初始化线程PCB结构体 struct task_struct */
void init_thread(struct task_struct* pthread, char* name, int prio) {
c0003242:	55                   	push   %ebp
c0003243:	89 e5                	mov    %esp,%ebp
c0003245:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:64
	memset(pthread, 0, sizeof(*pthread));	//清空PCB
c0003248:	83 ec 04             	sub    $0x4,%esp
c000324b:	6a 44                	push   $0x44
c000324d:	6a 00                	push   $0x0
c000324f:	ff 75 08             	pushl  0x8(%ebp)
c0003252:	e8 73 fb ff ff       	call   c0002dca <memset>
c0003257:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:65
	strcpy(pthread->name, name);
c000325a:	8b 45 08             	mov    0x8(%ebp),%eax
c000325d:	83 c0 08             	add    $0x8,%eax
c0003260:	83 ec 08             	sub    $0x8,%esp
c0003263:	ff 75 0c             	pushl  0xc(%ebp)
c0003266:	50                   	push   %eax
c0003267:	e8 93 fc ff ff       	call   c0002eff <strcpy>
c000326c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:67

	if (pthread == g_main_thread) {
c000326f:	a1 4c 77 00 c0       	mov    0xc000774c,%eax
c0003274:	39 45 08             	cmp    %eax,0x8(%ebp)
c0003277:	75 0c                	jne    c0003285 <init_thread+0x43>
/work/x86_os_my/thread/thread.c:69
		/* 由于把main函数也封装成一个线程,并且它一直是运行的,故将其直接设为TASK_RUNNING */
		pthread->status = TASK_RUNNING;
c0003279:	8b 45 08             	mov    0x8(%ebp),%eax
c000327c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c0003283:	eb 0a                	jmp    c000328f <init_thread+0x4d>
/work/x86_os_my/thread/thread.c:71
	} else {
		pthread->status = TASK_READY;
c0003285:	8b 45 08             	mov    0x8(%ebp),%eax
c0003288:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
/work/x86_os_my/thread/thread.c:77
	}

	/* self_kstack是线程自己在内核态下使用的栈顶地址 
	 * 线程自己在 0 特权级下所用的栈，在线程创建之初，
	 * 它被初始化为线程 PCB 的最顶端，即(uint32_t)pthread + PG_SIZE。*/
	pthread->self_kstack = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c000328f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003292:	05 00 10 00 00       	add    $0x1000,%eax
c0003297:	89 c2                	mov    %eax,%edx
c0003299:	8b 45 08             	mov    0x8(%ebp),%eax
c000329c:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:78
	pthread->priority = prio;
c000329e:	8b 45 10             	mov    0x10(%ebp),%eax
c00032a1:	89 c2                	mov    %eax,%edx
c00032a3:	8b 45 08             	mov    0x8(%ebp),%eax
c00032a6:	88 50 18             	mov    %dl,0x18(%eax)
/work/x86_os_my/thread/thread.c:79
	pthread->ticks = prio;
c00032a9:	8b 45 10             	mov    0x10(%ebp),%eax
c00032ac:	89 c2                	mov    %eax,%edx
c00032ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00032b1:	88 50 19             	mov    %dl,0x19(%eax)
/work/x86_os_my/thread/thread.c:80
	pthread->elapsed_ticks = 0;
c00032b4:	8b 45 08             	mov    0x8(%ebp),%eax
c00032b7:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
/work/x86_os_my/thread/thread.c:81
	pthread->pgdir = NULL;
c00032be:	8b 45 08             	mov    0x8(%ebp),%eax
c00032c1:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
/work/x86_os_my/thread/thread.c:82
	pthread->stack_magic = 0x19870916;	  // 自定义的魔数
c00032c8:	8b 45 08             	mov    0x8(%ebp),%eax
c00032cb:	c7 40 40 16 09 87 19 	movl   $0x19870916,0x40(%eax)
/work/x86_os_my/thread/thread.c:83
}
c00032d2:	90                   	nop
c00032d3:	c9                   	leave  
c00032d4:	c3                   	ret    

c00032d5 <thread_start>:
thread_start():
/work/x86_os_my/thread/thread.c:86

/* 创建线程 */
struct task_struct* thread_start(char* name, int prio, thread_func function, void* func_arg) {
c00032d5:	55                   	push   %ebp
c00032d6:	89 e5                	mov    %esp,%ebp
c00032d8:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:88
	/* pcb都位于内核空间,包括用户进程的pcb也是在内核空间 */
	struct task_struct* thread = get_kernel_pages(1);
c00032db:	83 ec 0c             	sub    $0xc,%esp
c00032de:	6a 01                	push   $0x1
c00032e0:	e8 65 f6 ff ff       	call   c000294a <get_kernel_pages>
c00032e5:	83 c4 10             	add    $0x10,%esp
c00032e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:90

	init_thread(thread, name, prio);			//初始化线程PCB
c00032eb:	83 ec 04             	sub    $0x4,%esp
c00032ee:	ff 75 0c             	pushl  0xc(%ebp)
c00032f1:	ff 75 08             	pushl  0x8(%ebp)
c00032f4:	ff 75 f4             	pushl  -0xc(%ebp)
c00032f7:	e8 46 ff ff ff       	call   c0003242 <init_thread>
c00032fc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:91
	thread_create(thread, function, func_arg);	//初始化线程栈结构体
c00032ff:	83 ec 04             	sub    $0x4,%esp
c0003302:	ff 75 14             	pushl  0x14(%ebp)
c0003305:	ff 75 10             	pushl  0x10(%ebp)
c0003308:	ff 75 f4             	pushl  -0xc(%ebp)
c000330b:	e8 bb fe ff ff       	call   c00031cb <thread_create>
c0003310:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:93
	
	ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));	// 确保之前不在队列中
c0003313:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003316:	83 c0 20             	add    $0x20,%eax
c0003319:	83 ec 08             	sub    $0x8,%esp
c000331c:	50                   	push   %eax
c000331d:	68 2c 77 00 c0       	push   $0xc000772c
c0003322:	e8 e2 04 00 00       	call   c0003809 <elem_find>
c0003327:	83 c4 10             	add    $0x10,%esp
c000332a:	85 c0                	test   %eax,%eax
c000332c:	74 19                	je     c0003347 <thread_start+0x72>
/work/x86_os_my/thread/thread.c:93 (discriminator 1)
c000332e:	68 8c 4e 00 c0       	push   $0xc0004e8c
c0003333:	68 0c 51 00 c0       	push   $0xc000510c
c0003338:	6a 5d                	push   $0x5d
c000333a:	68 c1 4e 00 c0       	push   $0xc0004ec1
c000333f:	e8 5e ef ff ff       	call   c00022a2 <panic_spin>
c0003344:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:94
	list_append(&thread_ready_list, &thread->general_tag);			// 加入就绪线程队列
c0003347:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000334a:	83 c0 20             	add    $0x20,%eax
c000334d:	83 ec 08             	sub    $0x8,%esp
c0003350:	50                   	push   %eax
c0003351:	68 2c 77 00 c0       	push   $0xc000772c
c0003356:	e8 34 04 00 00       	call   c000378f <list_append>
c000335b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:96

	ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
c000335e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003361:	83 c0 28             	add    $0x28,%eax
c0003364:	83 ec 08             	sub    $0x8,%esp
c0003367:	50                   	push   %eax
c0003368:	68 3c 77 00 c0       	push   $0xc000773c
c000336d:	e8 97 04 00 00       	call   c0003809 <elem_find>
c0003372:	83 c4 10             	add    $0x10,%esp
c0003375:	85 c0                	test   %eax,%eax
c0003377:	74 19                	je     c0003392 <thread_start+0xbd>
/work/x86_os_my/thread/thread.c:96 (discriminator 1)
c0003379:	68 d4 4e 00 c0       	push   $0xc0004ed4
c000337e:	68 0c 51 00 c0       	push   $0xc000510c
c0003383:	6a 60                	push   $0x60
c0003385:	68 c1 4e 00 c0       	push   $0xc0004ec1
c000338a:	e8 13 ef ff ff       	call   c00022a2 <panic_spin>
c000338f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:97
	list_append(&thread_all_list, &thread->all_list_tag);			// 加入全部线程队列
c0003392:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003395:	83 c0 28             	add    $0x28,%eax
c0003398:	83 ec 08             	sub    $0x8,%esp
c000339b:	50                   	push   %eax
c000339c:	68 3c 77 00 c0       	push   $0xc000773c
c00033a1:	e8 e9 03 00 00       	call   c000378f <list_append>
c00033a6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:113
	 * 在执行 ret 后，esp 指向的数值被弹岀到 eip。
	 * 处理器会去执行 kernel_thread 函数。
	 * 在执行 kernel_thread 时，处理器以为栈顶是返回地址，其实只是一个假的占位置的变量 unused_retaddr！
	 * 接着会调用函数 function(func_arg) */
	//asm volatile ("movl %0, %%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret" : : "g" (thread->self_kstack) : "memory");
	return thread;
c00033a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/thread/thread.c:114
}
c00033ac:	c9                   	leave  
c00033ad:	c3                   	ret    

c00033ae <make_main_thread>:
make_main_thread():
/work/x86_os_my/thread/thread.c:118


/* 将kernel中的main函数完善为主线程 */
static void make_main_thread(void) {
c00033ae:	55                   	push   %ebp
c00033af:	89 e5                	mov    %esp,%ebp
c00033b1:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:123
	/* 因为main线程早已运行,咱们在loader.S中进入内核时的mov esp, 0xc009f000设置了栈顶，也预留了pcb, 地址为0xc009e000
	 * 主线程不需要再为PCB申请页，只需要通过 init_thread 填充PCB成员：名称和优先级等。
	 * 也不需要再通过 thread_create 构造它的线程栈。
	 */
	g_main_thread = running_thread();	//用栈指针的高20位，当做当前线程的PCB
c00033b4:	e8 e1 fd ff ff       	call   c000319a <running_thread>
c00033b9:	a3 4c 77 00 c0       	mov    %eax,0xc000774c
/work/x86_os_my/thread/thread.c:124
	init_thread(g_main_thread, "main", 31);
c00033be:	a1 4c 77 00 c0       	mov    0xc000774c,%eax
c00033c3:	83 ec 04             	sub    $0x4,%esp
c00033c6:	6a 1f                	push   $0x1f
c00033c8:	68 08 4f 00 c0       	push   $0xc0004f08
c00033cd:	50                   	push   %eax
c00033ce:	e8 6f fe ff ff       	call   c0003242 <init_thread>
c00033d3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:128

	/* main函数是当前线程,当前线程不在thread_ready_list中,
	 * 所以只将其加在thread_all_list中. */
	ASSERT(!elem_find(&thread_all_list, &g_main_thread->all_list_tag));
c00033d6:	a1 4c 77 00 c0       	mov    0xc000774c,%eax
c00033db:	83 c0 28             	add    $0x28,%eax
c00033de:	83 ec 08             	sub    $0x8,%esp
c00033e1:	50                   	push   %eax
c00033e2:	68 3c 77 00 c0       	push   $0xc000773c
c00033e7:	e8 1d 04 00 00       	call   c0003809 <elem_find>
c00033ec:	83 c4 10             	add    $0x10,%esp
c00033ef:	85 c0                	test   %eax,%eax
c00033f1:	74 1c                	je     c000340f <make_main_thread+0x61>
/work/x86_os_my/thread/thread.c:128 (discriminator 1)
c00033f3:	68 10 4f 00 c0       	push   $0xc0004f10
c00033f8:	68 1c 51 00 c0       	push   $0xc000511c
c00033fd:	68 80 00 00 00       	push   $0x80
c0003402:	68 c1 4e 00 c0       	push   $0xc0004ec1
c0003407:	e8 96 ee ff ff       	call   c00022a2 <panic_spin>
c000340c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:129
	list_append(&thread_all_list, &g_main_thread->all_list_tag);
c000340f:	a1 4c 77 00 c0       	mov    0xc000774c,%eax
c0003414:	83 c0 28             	add    $0x28,%eax
c0003417:	83 ec 08             	sub    $0x8,%esp
c000341a:	50                   	push   %eax
c000341b:	68 3c 77 00 c0       	push   $0xc000773c
c0003420:	e8 6a 03 00 00       	call   c000378f <list_append>
c0003425:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:130
}
c0003428:	90                   	nop
c0003429:	c9                   	leave  
c000342a:	c3                   	ret    

c000342b <schedule>:
schedule():
/work/x86_os_my/thread/thread.c:140
（2）调度器 schedule。
（3）任务切换函数 switch_to。
*/
/* 实现任务调度 */
void schedule()
{
c000342b:	55                   	push   %ebp
c000342c:	89 e5                	mov    %esp,%ebp
c000342e:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:141
	ASSERT(intr_get_status() == INTR_OFF);
c0003431:	e8 a8 e5 ff ff       	call   c00019de <intr_get_status>
c0003436:	85 c0                	test   %eax,%eax
c0003438:	74 1c                	je     c0003456 <schedule+0x2b>
/work/x86_os_my/thread/thread.c:141 (discriminator 1)
c000343a:	68 4b 4f 00 c0       	push   $0xc0004f4b
c000343f:	68 30 51 00 c0       	push   $0xc0005130
c0003444:	68 8d 00 00 00       	push   $0x8d
c0003449:	68 c1 4e 00 c0       	push   $0xc0004ec1
c000344e:	e8 4f ee ff ff       	call   c00022a2 <panic_spin>
c0003453:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:144

	/* 换下 */
	struct task_struct* cur = running_thread(); 
c0003456:	e8 3f fd ff ff       	call   c000319a <running_thread>
c000345b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:145
	if (cur->status == TASK_RUNNING) { // 若此线程只是cpu时间片到了,将其加入到就绪队列尾
c000345e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003461:	8b 40 04             	mov    0x4(%eax),%eax
c0003464:	85 c0                	test   %eax,%eax
c0003466:	75 65                	jne    c00034cd <schedule+0xa2>
/work/x86_os_my/thread/thread.c:146
		ASSERT(!elem_find(&thread_ready_list, &cur->general_tag));
c0003468:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000346b:	83 c0 20             	add    $0x20,%eax
c000346e:	83 ec 08             	sub    $0x8,%esp
c0003471:	50                   	push   %eax
c0003472:	68 2c 77 00 c0       	push   $0xc000772c
c0003477:	e8 8d 03 00 00       	call   c0003809 <elem_find>
c000347c:	83 c4 10             	add    $0x10,%esp
c000347f:	85 c0                	test   %eax,%eax
c0003481:	74 1c                	je     c000349f <schedule+0x74>
/work/x86_os_my/thread/thread.c:146 (discriminator 1)
c0003483:	68 6c 4f 00 c0       	push   $0xc0004f6c
c0003488:	68 30 51 00 c0       	push   $0xc0005130
c000348d:	68 92 00 00 00       	push   $0x92
c0003492:	68 c1 4e 00 c0       	push   $0xc0004ec1
c0003497:	e8 06 ee ff ff       	call   c00022a2 <panic_spin>
c000349c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:147
		list_append(&thread_ready_list, &cur->general_tag);
c000349f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00034a2:	83 c0 20             	add    $0x20,%eax
c00034a5:	83 ec 08             	sub    $0x8,%esp
c00034a8:	50                   	push   %eax
c00034a9:	68 2c 77 00 c0       	push   $0xc000772c
c00034ae:	e8 dc 02 00 00       	call   c000378f <list_append>
c00034b3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:148
		cur->ticks = cur->priority;     // 重新将当前线程的ticks再重置为其priority;
c00034b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00034b9:	0f b6 50 18          	movzbl 0x18(%eax),%edx
c00034bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00034c0:	88 50 19             	mov    %dl,0x19(%eax)
/work/x86_os_my/thread/thread.c:149
		cur->status = TASK_READY;
c00034c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00034c6:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
/work/x86_os_my/thread/thread.c:156
		/* 若此线程需要某事件发生后才能继续上cpu运行,
		不需要将其加入队列,因为当前线程不在就绪队列中。*/
	}

	/* 换上 */
	ASSERT(!list_empty(&thread_ready_list));
c00034cd:	83 ec 0c             	sub    $0xc,%esp
c00034d0:	68 2c 77 00 c0       	push   $0xc000772c
c00034d5:	e8 fc 03 00 00       	call   c00038d6 <list_empty>
c00034da:	83 c4 10             	add    $0x10,%esp
c00034dd:	85 c0                	test   %eax,%eax
c00034df:	74 1c                	je     c00034fd <schedule+0xd2>
/work/x86_os_my/thread/thread.c:156 (discriminator 1)
c00034e1:	68 a0 4f 00 c0       	push   $0xc0004fa0
c00034e6:	68 30 51 00 c0       	push   $0xc0005130
c00034eb:	68 9c 00 00 00       	push   $0x9c
c00034f0:	68 c1 4e 00 c0       	push   $0xc0004ec1
c00034f5:	e8 a8 ed ff ff       	call   c00022a2 <panic_spin>
c00034fa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:157
	g_thread_tag = NULL;	  // g_thread_tag清空
c00034fd:	c7 05 60 74 00 c0 00 	movl   $0x0,0xc0007460
c0003504:	00 00 00 
/work/x86_os_my/thread/thread.c:159
	/* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */
	g_thread_tag = list_pop(&thread_ready_list);   
c0003507:	83 ec 0c             	sub    $0xc,%esp
c000350a:	68 2c 77 00 c0       	push   $0xc000772c
c000350f:	e8 d3 02 00 00       	call   c00037e7 <list_pop>
c0003514:	83 c4 10             	add    $0x10,%esp
c0003517:	a3 60 74 00 c0       	mov    %eax,0xc0007460
/work/x86_os_my/thread/thread.c:160
	struct task_struct* next = elem2entry(struct task_struct, general_tag, g_thread_tag);
c000351c:	a1 60 74 00 c0       	mov    0xc0007460,%eax
c0003521:	83 e8 20             	sub    $0x20,%eax
c0003524:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:161
	next->status = TASK_RUNNING;
c0003527:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000352a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
/work/x86_os_my/thread/thread.c:165
	
	/* 1.激活线程或进程的页表,【更新CR3寄存器】
	 * 2.用户进程，更新tss中的esp0为进程的特权级0的栈 */
	process_activate(next);
c0003531:	83 ec 0c             	sub    $0xc,%esp
c0003534:	ff 75 f0             	pushl  -0x10(%ebp)
c0003537:	e8 46 10 00 00       	call   c0004582 <process_activate>
c000353c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:167

	switch_to(cur, next);
c000353f:	83 ec 08             	sub    $0x8,%esp
c0003542:	ff 75 f0             	pushl  -0x10(%ebp)
c0003545:	ff 75 f4             	pushl  -0xc(%ebp)
c0003548:	e8 a3 03 00 00       	call   c00038f0 <switch_to>
c000354d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:168
}
c0003550:	90                   	nop
c0003551:	c9                   	leave  
c0003552:	c3                   	ret    

c0003553 <thread_block>:
thread_block():
/work/x86_os_my/thread/thread.c:171

/* 当前线程将自己阻塞,标志其状态为stat. */
void thread_block(enum task_status stat) {
c0003553:	55                   	push   %ebp
c0003554:	89 e5                	mov    %esp,%ebp
c0003556:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:173
	/* stat取值为TASK_BLOCKED,TASK_WAITING,TASK_HANGING,也就是只有这三种状态才不会被调度*/
	ASSERT(((stat == TASK_BLOCKED) || (stat == TASK_WAITING) || (stat == TASK_HANGING)));
c0003559:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c000355d:	74 28                	je     c0003587 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:173 (discriminator 1)
c000355f:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c0003563:	74 22                	je     c0003587 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:173 (discriminator 2)
c0003565:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
c0003569:	74 1c                	je     c0003587 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:173 (discriminator 3)
c000356b:	68 c0 4f 00 c0       	push   $0xc0004fc0
c0003570:	68 3c 51 00 c0       	push   $0xc000513c
c0003575:	68 ad 00 00 00       	push   $0xad
c000357a:	68 c1 4e 00 c0       	push   $0xc0004ec1
c000357f:	e8 1e ed ff ff       	call   c00022a2 <panic_spin>
c0003584:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:174
	enum intr_status old_status = intr_disable();
c0003587:	e8 0b e4 ff ff       	call   c0001997 <intr_disable>
c000358c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:176
	
	struct task_struct* cur_thread = running_thread();
c000358f:	e8 06 fc ff ff       	call   c000319a <running_thread>
c0003594:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:177
	cur_thread->status = stat;
c0003597:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000359a:	8b 55 08             	mov    0x8(%ebp),%edx
c000359d:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/thread/thread.c:178
	schedule();
c00035a0:	e8 86 fe ff ff       	call   c000342b <schedule>
/work/x86_os_my/thread/thread.c:181
	
	/* 待当前线程被解除阻塞后才继续运行下面的intr_set_status */
	intr_set_status(old_status);
c00035a5:	83 ec 0c             	sub    $0xc,%esp
c00035a8:	ff 75 f4             	pushl  -0xc(%ebp)
c00035ab:	e8 10 e4 ff ff       	call   c00019c0 <intr_set_status>
c00035b0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:182
}
c00035b3:	90                   	nop
c00035b4:	c9                   	leave  
c00035b5:	c3                   	ret    

c00035b6 <thread_unblock>:
thread_unblock():
/work/x86_os_my/thread/thread.c:185

/* 将线程pthread解除阻塞 */
void thread_unblock(struct task_struct* pthread) {
c00035b6:	55                   	push   %ebp
c00035b7:	89 e5                	mov    %esp,%ebp
c00035b9:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:186
	enum intr_status old_status = intr_disable();
c00035bc:	e8 d6 e3 ff ff       	call   c0001997 <intr_disable>
c00035c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:187
	ASSERT(((pthread->status == TASK_BLOCKED) || (pthread->status == TASK_WAITING) || (pthread->status == TASK_HANGING)));
c00035c4:	8b 45 08             	mov    0x8(%ebp),%eax
c00035c7:	8b 40 04             	mov    0x4(%eax),%eax
c00035ca:	83 f8 02             	cmp    $0x2,%eax
c00035cd:	74 32                	je     c0003601 <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:187 (discriminator 1)
c00035cf:	8b 45 08             	mov    0x8(%ebp),%eax
c00035d2:	8b 40 04             	mov    0x4(%eax),%eax
c00035d5:	83 f8 03             	cmp    $0x3,%eax
c00035d8:	74 27                	je     c0003601 <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:187 (discriminator 2)
c00035da:	8b 45 08             	mov    0x8(%ebp),%eax
c00035dd:	8b 40 04             	mov    0x4(%eax),%eax
c00035e0:	83 f8 04             	cmp    $0x4,%eax
c00035e3:	74 1c                	je     c0003601 <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:187 (discriminator 3)
c00035e5:	68 10 50 00 c0       	push   $0xc0005010
c00035ea:	68 4c 51 00 c0       	push   $0xc000514c
c00035ef:	68 bb 00 00 00       	push   $0xbb
c00035f4:	68 c1 4e 00 c0       	push   $0xc0004ec1
c00035f9:	e8 a4 ec ff ff       	call   c00022a2 <panic_spin>
c00035fe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:189
	
	if (pthread->status != TASK_READY) {
c0003601:	8b 45 08             	mov    0x8(%ebp),%eax
c0003604:	8b 40 04             	mov    0x4(%eax),%eax
c0003607:	83 f8 01             	cmp    $0x1,%eax
c000360a:	0f 84 8f 00 00 00    	je     c000369f <thread_unblock+0xe9>
/work/x86_os_my/thread/thread.c:190
		ASSERT(!elem_find(&thread_ready_list, &pthread->general_tag));
c0003610:	8b 45 08             	mov    0x8(%ebp),%eax
c0003613:	83 c0 20             	add    $0x20,%eax
c0003616:	83 ec 08             	sub    $0x8,%esp
c0003619:	50                   	push   %eax
c000361a:	68 2c 77 00 c0       	push   $0xc000772c
c000361f:	e8 e5 01 00 00       	call   c0003809 <elem_find>
c0003624:	83 c4 10             	add    $0x10,%esp
c0003627:	85 c0                	test   %eax,%eax
c0003629:	74 1c                	je     c0003647 <thread_unblock+0x91>
/work/x86_os_my/thread/thread.c:190 (discriminator 1)
c000362b:	68 80 50 00 c0       	push   $0xc0005080
c0003630:	68 4c 51 00 c0       	push   $0xc000514c
c0003635:	68 be 00 00 00       	push   $0xbe
c000363a:	68 c1 4e 00 c0       	push   $0xc0004ec1
c000363f:	e8 5e ec ff ff       	call   c00022a2 <panic_spin>
c0003644:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:191
		if (elem_find(&thread_ready_list, &pthread->general_tag)) {
c0003647:	8b 45 08             	mov    0x8(%ebp),%eax
c000364a:	83 c0 20             	add    $0x20,%eax
c000364d:	83 ec 08             	sub    $0x8,%esp
c0003650:	50                   	push   %eax
c0003651:	68 2c 77 00 c0       	push   $0xc000772c
c0003656:	e8 ae 01 00 00       	call   c0003809 <elem_find>
c000365b:	83 c4 10             	add    $0x10,%esp
c000365e:	85 c0                	test   %eax,%eax
c0003660:	74 1c                	je     c000367e <thread_unblock+0xc8>
/work/x86_os_my/thread/thread.c:192
			PANIC("thread_unblock: blocked thread in ready_list\n");
c0003662:	68 b8 50 00 c0       	push   $0xc00050b8
c0003667:	68 4c 51 00 c0       	push   $0xc000514c
c000366c:	68 c0 00 00 00       	push   $0xc0
c0003671:	68 c1 4e 00 c0       	push   $0xc0004ec1
c0003676:	e8 27 ec ff ff       	call   c00022a2 <panic_spin>
c000367b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:194
		}
		list_push(&thread_ready_list, &pthread->general_tag);	// 放到队列的最前面,使其尽快得到调度
c000367e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003681:	83 c0 20             	add    $0x20,%eax
c0003684:	83 ec 08             	sub    $0x8,%esp
c0003687:	50                   	push   %eax
c0003688:	68 2c 77 00 c0       	push   $0xc000772c
c000368d:	e8 df 00 00 00       	call   c0003771 <list_push>
c0003692:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:195
		pthread->status = TASK_READY;
c0003695:	8b 45 08             	mov    0x8(%ebp),%eax
c0003698:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
/work/x86_os_my/thread/thread.c:198
	}
	
	intr_set_status(old_status);
c000369f:	83 ec 0c             	sub    $0xc,%esp
c00036a2:	ff 75 f4             	pushl  -0xc(%ebp)
c00036a5:	e8 16 e3 ff ff       	call   c00019c0 <intr_set_status>
c00036aa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:199
}
c00036ad:	90                   	nop
c00036ae:	c9                   	leave  
c00036af:	c3                   	ret    

c00036b0 <thread_init>:
thread_init():
/work/x86_os_my/thread/thread.c:202

/* 初始化线程环境 */
void thread_init(void) {
c00036b0:	55                   	push   %ebp
c00036b1:	89 e5                	mov    %esp,%ebp
c00036b3:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:203
	put_str("thread_init start\n");
c00036b6:	83 ec 0c             	sub    $0xc,%esp
c00036b9:	68 e6 50 00 c0       	push   $0xc00050e6
c00036be:	e8 6d ea ff ff       	call   c0002130 <put_str>
c00036c3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:204
	list_init(&thread_ready_list);
c00036c6:	83 ec 0c             	sub    $0xc,%esp
c00036c9:	68 2c 77 00 c0       	push   $0xc000772c
c00036ce:	e8 2b 00 00 00       	call   c00036fe <list_init>
c00036d3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:205
	list_init(&thread_all_list);
c00036d6:	83 ec 0c             	sub    $0xc,%esp
c00036d9:	68 3c 77 00 c0       	push   $0xc000773c
c00036de:	e8 1b 00 00 00       	call   c00036fe <list_init>
c00036e3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:207
	/* 将当前main函数创建为线程 */
	make_main_thread();
c00036e6:	e8 c3 fc ff ff       	call   c00033ae <make_main_thread>
/work/x86_os_my/thread/thread.c:208
	put_str("thread_init done\n");
c00036eb:	83 ec 0c             	sub    $0xc,%esp
c00036ee:	68 f9 50 00 c0       	push   $0xc00050f9
c00036f3:	e8 38 ea ff ff       	call   c0002130 <put_str>
c00036f8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:209
}
c00036fb:	90                   	nop
c00036fc:	c9                   	leave  
c00036fd:	c3                   	ret    

c00036fe <list_init>:
list_init():
/work/x86_os_my/lib/kernel/list.c:6
#include "list.h"
#include "interrupt.h"
/* 注意关中断的操作：临界区 */

/* 初始化双向链表list */
void list_init (struct list* list) {
c00036fe:	55                   	push   %ebp
c00036ff:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/lib/kernel/list.c:7
	list->head.prev = NULL;
c0003701:	8b 45 08             	mov    0x8(%ebp),%eax
c0003704:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/lib/kernel/list.c:8
	list->head.next = &list->tail;
c000370a:	8b 45 08             	mov    0x8(%ebp),%eax
c000370d:	8d 50 08             	lea    0x8(%eax),%edx
c0003710:	8b 45 08             	mov    0x8(%ebp),%eax
c0003713:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:9
	list->tail.prev = &list->head;
c0003716:	8b 55 08             	mov    0x8(%ebp),%edx
c0003719:	8b 45 08             	mov    0x8(%ebp),%eax
c000371c:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/lib/kernel/list.c:10
	list->tail.next = NULL;
c000371f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003722:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/lib/kernel/list.c:11
}
c0003729:	90                   	nop
c000372a:	5d                   	pop    %ebp
c000372b:	c3                   	ret    

c000372c <list_insert_before>:
list_insert_before():
/work/x86_os_my/lib/kernel/list.c:14

/* 把链表元素elem插入在元素before之前 */
void list_insert_before(struct list_elem* before, struct list_elem* elem) { 
c000372c:	55                   	push   %ebp
c000372d:	89 e5                	mov    %esp,%ebp
c000372f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:15
	enum intr_status old_status = intr_disable();
c0003732:	e8 60 e2 ff ff       	call   c0001997 <intr_disable>
c0003737:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:18

	/* 将before前驱元素的后继元素更新为elem, 暂时使before脱离链表*/ 
	before->prev->next = elem; 
c000373a:	8b 45 08             	mov    0x8(%ebp),%eax
c000373d:	8b 00                	mov    (%eax),%eax
c000373f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003742:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:22

	/* 更新elem自己的前驱结点为before的前驱,
	* 更新elem自己的后继结点为before, 于是before又回到链表 */
	elem->prev = before->prev;
c0003745:	8b 45 08             	mov    0x8(%ebp),%eax
c0003748:	8b 10                	mov    (%eax),%edx
c000374a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000374d:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:23
	elem->next = before;
c000374f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003752:	8b 55 08             	mov    0x8(%ebp),%edx
c0003755:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:26

	/* 更新before的前驱结点为elem */
	before->prev = elem;
c0003758:	8b 45 08             	mov    0x8(%ebp),%eax
c000375b:	8b 55 0c             	mov    0xc(%ebp),%edx
c000375e:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:28

	intr_set_status(old_status);
c0003760:	83 ec 0c             	sub    $0xc,%esp
c0003763:	ff 75 f4             	pushl  -0xc(%ebp)
c0003766:	e8 55 e2 ff ff       	call   c00019c0 <intr_set_status>
c000376b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:29
}
c000376e:	90                   	nop
c000376f:	c9                   	leave  
c0003770:	c3                   	ret    

c0003771 <list_push>:
list_push():
/work/x86_os_my/lib/kernel/list.c:32

/* 添加元素到列表队首,类似栈push操作 */
void list_push(struct list* plist, struct list_elem* elem) {
c0003771:	55                   	push   %ebp
c0003772:	89 e5                	mov    %esp,%ebp
c0003774:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/list.c:33
	list_insert_before(plist->head.next, elem); // 在队头插入elem
c0003777:	8b 45 08             	mov    0x8(%ebp),%eax
c000377a:	8b 40 04             	mov    0x4(%eax),%eax
c000377d:	83 ec 08             	sub    $0x8,%esp
c0003780:	ff 75 0c             	pushl  0xc(%ebp)
c0003783:	50                   	push   %eax
c0003784:	e8 a3 ff ff ff       	call   c000372c <list_insert_before>
c0003789:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:34
}
c000378c:	90                   	nop
c000378d:	c9                   	leave  
c000378e:	c3                   	ret    

c000378f <list_append>:
list_append():
/work/x86_os_my/lib/kernel/list.c:37

/* 追加元素到链表队尾,类似队列的先进先出操作 */
void list_append(struct list* plist, struct list_elem* elem) {
c000378f:	55                   	push   %ebp
c0003790:	89 e5                	mov    %esp,%ebp
c0003792:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/list.c:38
	list_insert_before(&plist->tail, elem);     // 在队尾的前面插入
c0003795:	8b 45 08             	mov    0x8(%ebp),%eax
c0003798:	83 c0 08             	add    $0x8,%eax
c000379b:	83 ec 08             	sub    $0x8,%esp
c000379e:	ff 75 0c             	pushl  0xc(%ebp)
c00037a1:	50                   	push   %eax
c00037a2:	e8 85 ff ff ff       	call   c000372c <list_insert_before>
c00037a7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:39
}
c00037aa:	90                   	nop
c00037ab:	c9                   	leave  
c00037ac:	c3                   	ret    

c00037ad <list_remove>:
list_remove():
/work/x86_os_my/lib/kernel/list.c:42

/* 使元素pelem脱离链表 */
void list_remove(struct list_elem* pelem) {
c00037ad:	55                   	push   %ebp
c00037ae:	89 e5                	mov    %esp,%ebp
c00037b0:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:43
	enum intr_status old_status = intr_disable();
c00037b3:	e8 df e1 ff ff       	call   c0001997 <intr_disable>
c00037b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:45

	pelem->prev->next = pelem->next;
c00037bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00037be:	8b 00                	mov    (%eax),%eax
c00037c0:	8b 55 08             	mov    0x8(%ebp),%edx
c00037c3:	8b 52 04             	mov    0x4(%edx),%edx
c00037c6:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:46
	pelem->next->prev = pelem->prev;
c00037c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00037cc:	8b 40 04             	mov    0x4(%eax),%eax
c00037cf:	8b 55 08             	mov    0x8(%ebp),%edx
c00037d2:	8b 12                	mov    (%edx),%edx
c00037d4:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:48

	intr_set_status(old_status);
c00037d6:	83 ec 0c             	sub    $0xc,%esp
c00037d9:	ff 75 f4             	pushl  -0xc(%ebp)
c00037dc:	e8 df e1 ff ff       	call   c00019c0 <intr_set_status>
c00037e1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:49
}
c00037e4:	90                   	nop
c00037e5:	c9                   	leave  
c00037e6:	c3                   	ret    

c00037e7 <list_pop>:
list_pop():
/work/x86_os_my/lib/kernel/list.c:52

/* 将链表第一个元素弹出并返回,类似栈的pop操作 */
struct list_elem* list_pop(struct list* plist) {
c00037e7:	55                   	push   %ebp
c00037e8:	89 e5                	mov    %esp,%ebp
c00037ea:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:53
	struct list_elem* elem = plist->head.next;
c00037ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00037f0:	8b 40 04             	mov    0x4(%eax),%eax
c00037f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:54
	list_remove(elem);
c00037f6:	83 ec 0c             	sub    $0xc,%esp
c00037f9:	ff 75 f4             	pushl  -0xc(%ebp)
c00037fc:	e8 ac ff ff ff       	call   c00037ad <list_remove>
c0003801:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:55
	return elem;
c0003804:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/kernel/list.c:56
} 
c0003807:	c9                   	leave  
c0003808:	c3                   	ret    

c0003809 <elem_find>:
elem_find():
/work/x86_os_my/lib/kernel/list.c:59

/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */
bool elem_find(struct list* plist, struct list_elem* obj_elem) {
c0003809:	55                   	push   %ebp
c000380a:	89 e5                	mov    %esp,%ebp
c000380c:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:60
	struct list_elem* elem = plist->head.next;
c000380f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003812:	8b 40 04             	mov    0x4(%eax),%eax
c0003815:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:61
	while (elem != &plist->tail) {
c0003818:	eb 18                	jmp    c0003832 <elem_find+0x29>
/work/x86_os_my/lib/kernel/list.c:62
	if (elem == obj_elem) {
c000381a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000381d:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0003820:	75 07                	jne    c0003829 <elem_find+0x20>
/work/x86_os_my/lib/kernel/list.c:63
		return true;
c0003822:	b8 01 00 00 00       	mov    $0x1,%eax
c0003827:	eb 19                	jmp    c0003842 <elem_find+0x39>
/work/x86_os_my/lib/kernel/list.c:65
	}
		elem = elem->next;
c0003829:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000382c:	8b 40 04             	mov    0x4(%eax),%eax
c000382f:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:61
} 

/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */
bool elem_find(struct list* plist, struct list_elem* obj_elem) {
	struct list_elem* elem = plist->head.next;
	while (elem != &plist->tail) {
c0003832:	8b 45 08             	mov    0x8(%ebp),%eax
c0003835:	83 c0 08             	add    $0x8,%eax
c0003838:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c000383b:	75 dd                	jne    c000381a <elem_find+0x11>
/work/x86_os_my/lib/kernel/list.c:67
	if (elem == obj_elem) {
		return true;
	}
		elem = elem->next;
	}
	return false;
c000383d:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/kernel/list.c:68
}
c0003842:	c9                   	leave  
c0003843:	c3                   	ret    

c0003844 <list_traversal>:
list_traversal():
/work/x86_os_my/lib/kernel/list.c:74

/* 把列表plist中的每个元素elem和arg传给回调函数func,
 * arg给func用来判断elem是否符合条件.
 * 本函数的功能是遍历列表内所有元素,逐个判断是否有符合条件的元素。
 * 找到符合条件的元素返回元素指针,否则返回NULL. */
struct list_elem* list_traversal(struct list* plist, function func, int arg) {
c0003844:	55                   	push   %ebp
c0003845:	89 e5                	mov    %esp,%ebp
c0003847:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:75
	struct list_elem* elem = plist->head.next;
c000384a:	8b 45 08             	mov    0x8(%ebp),%eax
c000384d:	8b 40 04             	mov    0x4(%eax),%eax
c0003850:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:77
	/* 如果队列为空,就必然没有符合条件的结点,故直接返回NULL */
	if (list_empty(plist)) { 
c0003853:	83 ec 0c             	sub    $0xc,%esp
c0003856:	ff 75 08             	pushl  0x8(%ebp)
c0003859:	e8 78 00 00 00       	call   c00038d6 <list_empty>
c000385e:	83 c4 10             	add    $0x10,%esp
c0003861:	85 c0                	test   %eax,%eax
c0003863:	74 2a                	je     c000388f <list_traversal+0x4b>
/work/x86_os_my/lib/kernel/list.c:78
		return NULL;
c0003865:	b8 00 00 00 00       	mov    $0x0,%eax
c000386a:	eb 33                	jmp    c000389f <list_traversal+0x5b>
/work/x86_os_my/lib/kernel/list.c:82
	}

	while (elem != &plist->tail) {
	if (func(elem, arg)) {		  // func返回ture则认为该元素在回调函数中符合条件,命中,故停止继续遍历
c000386c:	83 ec 08             	sub    $0x8,%esp
c000386f:	ff 75 10             	pushl  0x10(%ebp)
c0003872:	ff 75 f4             	pushl  -0xc(%ebp)
c0003875:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003878:	ff d0                	call   *%eax
c000387a:	83 c4 10             	add    $0x10,%esp
c000387d:	85 c0                	test   %eax,%eax
c000387f:	74 05                	je     c0003886 <list_traversal+0x42>
/work/x86_os_my/lib/kernel/list.c:83
		return elem;
c0003881:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003884:	eb 19                	jmp    c000389f <list_traversal+0x5b>
/work/x86_os_my/lib/kernel/list.c:85
	}					  // 若回调函数func返回true,则继续遍历
		elem = elem->next;	       
c0003886:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003889:	8b 40 04             	mov    0x4(%eax),%eax
c000388c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:81
	/* 如果队列为空,就必然没有符合条件的结点,故直接返回NULL */
	if (list_empty(plist)) { 
		return NULL;
	}

	while (elem != &plist->tail) {
c000388f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003892:	83 c0 08             	add    $0x8,%eax
c0003895:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0003898:	75 d2                	jne    c000386c <list_traversal+0x28>
/work/x86_os_my/lib/kernel/list.c:87
	if (func(elem, arg)) {		  // func返回ture则认为该元素在回调函数中符合条件,命中,故停止继续遍历
		return elem;
	}					  // 若回调函数func返回true,则继续遍历
		elem = elem->next;	       
	}
	return NULL;
c000389a:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/kernel/list.c:88
}
c000389f:	c9                   	leave  
c00038a0:	c3                   	ret    

c00038a1 <list_len>:
list_len():
/work/x86_os_my/lib/kernel/list.c:91

/* 返回链表长度 */
uint32_t list_len(struct list* plist) {
c00038a1:	55                   	push   %ebp
c00038a2:	89 e5                	mov    %esp,%ebp
c00038a4:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:92
	struct list_elem* elem = plist->head.next;
c00038a7:	8b 45 08             	mov    0x8(%ebp),%eax
c00038aa:	8b 40 04             	mov    0x4(%eax),%eax
c00038ad:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:93
	uint32_t length = 0;
c00038b0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
/work/x86_os_my/lib/kernel/list.c:94
	while (elem != &plist->tail) {
c00038b7:	eb 0d                	jmp    c00038c6 <list_len+0x25>
/work/x86_os_my/lib/kernel/list.c:95
		length++; 
c00038b9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
/work/x86_os_my/lib/kernel/list.c:96
		elem = elem->next;
c00038bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00038c0:	8b 40 04             	mov    0x4(%eax),%eax
c00038c3:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:94

/* 返回链表长度 */
uint32_t list_len(struct list* plist) {
	struct list_elem* elem = plist->head.next;
	uint32_t length = 0;
	while (elem != &plist->tail) {
c00038c6:	8b 45 08             	mov    0x8(%ebp),%eax
c00038c9:	83 c0 08             	add    $0x8,%eax
c00038cc:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c00038cf:	75 e8                	jne    c00038b9 <list_len+0x18>
/work/x86_os_my/lib/kernel/list.c:98
		length++; 
		elem = elem->next;
	}
	return length;
c00038d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/kernel/list.c:99
}
c00038d4:	c9                   	leave  
c00038d5:	c3                   	ret    

c00038d6 <list_empty>:
list_empty():
/work/x86_os_my/lib/kernel/list.c:102

/* 判断链表是否为空,空时返回true,否则返回false */
bool list_empty(struct list* plist) {		// 判断队列是否为空
c00038d6:	55                   	push   %ebp
c00038d7:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/lib/kernel/list.c:103
	return (plist->head.next == &plist->tail ? true : false);
c00038d9:	8b 45 08             	mov    0x8(%ebp),%eax
c00038dc:	8b 40 04             	mov    0x4(%eax),%eax
c00038df:	8b 55 08             	mov    0x8(%ebp),%edx
c00038e2:	83 c2 08             	add    $0x8,%edx
c00038e5:	39 d0                	cmp    %edx,%eax
c00038e7:	0f 94 c0             	sete   %al
c00038ea:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/lib/kernel/list.c:104
}
c00038ed:	5d                   	pop    %ebp
c00038ee:	c3                   	ret    
c00038ef:	90                   	nop

c00038f0 <switch_to>:
switch_to():
c00038f0:	56                   	push   %esi
c00038f1:	57                   	push   %edi
c00038f2:	53                   	push   %ebx
c00038f3:	55                   	push   %ebp
c00038f4:	8b 44 24 14          	mov    0x14(%esp),%eax
c00038f8:	89 20                	mov    %esp,(%eax)
c00038fa:	8b 44 24 18          	mov    0x18(%esp),%eax
c00038fe:	8b 20                	mov    (%eax),%esp
c0003900:	5d                   	pop    %ebp
c0003901:	5b                   	pop    %ebx
c0003902:	5f                   	pop    %edi
c0003903:	5e                   	pop    %esi
c0003904:	c3                   	ret    

c0003905 <console_init>:
console_init():
/work/x86_os_my/device/console.c:9
#include "sync.h"
#include "thread.h"
static struct lock console_lock;	// 控制台锁

/* 初始化终端 */
void console_init() {
c0003905:	55                   	push   %ebp
c0003906:	89 e5                	mov    %esp,%ebp
c0003908:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:10
	lock_init(&console_lock);
c000390b:	83 ec 0c             	sub    $0xc,%esp
c000390e:	68 64 74 00 c0       	push   $0xc0007464
c0003913:	e8 cd 00 00 00       	call   c00039e5 <lock_init>
c0003918:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:11
}
c000391b:	90                   	nop
c000391c:	c9                   	leave  
c000391d:	c3                   	ret    

c000391e <console_acquire>:
console_acquire():
/work/x86_os_my/device/console.c:14

/* 获取终端 */
void console_acquire() {
c000391e:	55                   	push   %ebp
c000391f:	89 e5                	mov    %esp,%ebp
c0003921:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:15
	lock_acquire(&console_lock);
c0003924:	83 ec 0c             	sub    $0xc,%esp
c0003927:	68 64 74 00 c0       	push   $0xc0007464
c000392c:	e8 8e 02 00 00       	call   c0003bbf <lock_acquire>
c0003931:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:16
}
c0003934:	90                   	nop
c0003935:	c9                   	leave  
c0003936:	c3                   	ret    

c0003937 <console_release>:
console_release():
/work/x86_os_my/device/console.c:19

/* 释放终端 */
void console_release() {
c0003937:	55                   	push   %ebp
c0003938:	89 e5                	mov    %esp,%ebp
c000393a:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:20
	lock_release(&console_lock);
c000393d:	83 ec 0c             	sub    $0xc,%esp
c0003940:	68 64 74 00 c0       	push   $0xc0007464
c0003945:	e8 ec 02 00 00       	call   c0003c36 <lock_release>
c000394a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:21
}
c000394d:	90                   	nop
c000394e:	c9                   	leave  
c000394f:	c3                   	ret    

c0003950 <console_put_str>:
console_put_str():
/work/x86_os_my/device/console.c:24

/* 终端中输出字符串 */
void console_put_str(char* str) {
c0003950:	55                   	push   %ebp
c0003951:	89 e5                	mov    %esp,%ebp
c0003953:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:25
	console_acquire();
c0003956:	e8 c3 ff ff ff       	call   c000391e <console_acquire>
/work/x86_os_my/device/console.c:26
	put_str(str);
c000395b:	83 ec 0c             	sub    $0xc,%esp
c000395e:	ff 75 08             	pushl  0x8(%ebp)
c0003961:	e8 ca e7 ff ff       	call   c0002130 <put_str>
c0003966:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:27
	console_release();
c0003969:	e8 c9 ff ff ff       	call   c0003937 <console_release>
/work/x86_os_my/device/console.c:28
}
c000396e:	90                   	nop
c000396f:	c9                   	leave  
c0003970:	c3                   	ret    

c0003971 <console_put_char>:
console_put_char():
/work/x86_os_my/device/console.c:31

/* 终端中输出字符 */
void console_put_char(uint8_t char_asci) {
c0003971:	55                   	push   %ebp
c0003972:	89 e5                	mov    %esp,%ebp
c0003974:	83 ec 18             	sub    $0x18,%esp
c0003977:	8b 45 08             	mov    0x8(%ebp),%eax
c000397a:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/console.c:32
	console_acquire();
c000397d:	e8 9c ff ff ff       	call   c000391e <console_acquire>
/work/x86_os_my/device/console.c:33
	put_char(char_asci);
c0003982:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0003986:	83 ec 0c             	sub    $0xc,%esp
c0003989:	50                   	push   %eax
c000398a:	e8 bf e7 ff ff       	call   c000214e <put_char>
c000398f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:34
	console_release();
c0003992:	e8 a0 ff ff ff       	call   c0003937 <console_release>
/work/x86_os_my/device/console.c:35
}
c0003997:	90                   	nop
c0003998:	c9                   	leave  
c0003999:	c3                   	ret    

c000399a <console_put_int>:
console_put_int():
/work/x86_os_my/device/console.c:38

/* 终端中输出16进制整数 */
void console_put_int(uint32_t num) {
c000399a:	55                   	push   %ebp
c000399b:	89 e5                	mov    %esp,%ebp
c000399d:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:39
	console_acquire();
c00039a0:	e8 79 ff ff ff       	call   c000391e <console_acquire>
/work/x86_os_my/device/console.c:40
	put_int(num);
c00039a5:	83 ec 0c             	sub    $0xc,%esp
c00039a8:	ff 75 08             	pushl  0x8(%ebp)
c00039ab:	e8 6b e8 ff ff       	call   c000221b <put_int>
c00039b0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:41
	console_release();
c00039b3:	e8 7f ff ff ff       	call   c0003937 <console_release>
/work/x86_os_my/device/console.c:42
}
c00039b8:	90                   	nop
c00039b9:	c9                   	leave  
c00039ba:	c3                   	ret    

c00039bb <sema_init>:
sema_init():
/work/x86_os_my/thread/sync.c:8
#include "global.h"
#include "debug.h"
#include "interrupt.h"

/* 初始化信号量 */
void sema_init(struct semaphore* psema, uint8_t value) {
c00039bb:	55                   	push   %ebp
c00039bc:	89 e5                	mov    %esp,%ebp
c00039be:	83 ec 18             	sub    $0x18,%esp
c00039c1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00039c4:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:9
	psema->value = value;       // 为信号量赋初值
c00039c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00039ca:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c00039ce:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:10
	list_init(&psema->waiters); //初始化信号量的等待队列
c00039d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00039d3:	83 c0 04             	add    $0x4,%eax
c00039d6:	83 ec 0c             	sub    $0xc,%esp
c00039d9:	50                   	push   %eax
c00039da:	e8 1f fd ff ff       	call   c00036fe <list_init>
c00039df:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:11
}
c00039e2:	90                   	nop
c00039e3:	c9                   	leave  
c00039e4:	c3                   	ret    

c00039e5 <lock_init>:
lock_init():
/work/x86_os_my/thread/sync.c:14

/* 初始化锁plock */
void lock_init(struct lock* plock) {
c00039e5:	55                   	push   %ebp
c00039e6:	89 e5                	mov    %esp,%ebp
c00039e8:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/sync.c:15
	plock->holder = NULL;
c00039eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00039ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:16
	plock->holder_repeat_nr = 0;
c00039f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00039f7:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:17
	sema_init(&plock->semaphore, 1);  // 信号量初值为1
c00039fe:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a01:	83 c0 04             	add    $0x4,%eax
c0003a04:	83 ec 08             	sub    $0x8,%esp
c0003a07:	6a 01                	push   $0x1
c0003a09:	50                   	push   %eax
c0003a0a:	e8 ac ff ff ff       	call   c00039bb <sema_init>
c0003a0f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:18
}
c0003a12:	90                   	nop
c0003a13:	c9                   	leave  
c0003a14:	c3                   	ret    

c0003a15 <sema_down>:
sema_down():
/work/x86_os_my/thread/sync.c:21

/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
c0003a15:	55                   	push   %ebp
c0003a16:	89 e5                	mov    %esp,%ebp
c0003a18:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:23
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
c0003a1b:	e8 77 df ff ff       	call   c0001997 <intr_disable>
c0003a20:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:25
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c0003a23:	e9 98 00 00 00       	jmp    c0003ac0 <sema_down+0xab>
/work/x86_os_my/thread/sync.c:26
		ASSERT(!elem_find(&psema->waiters, &running_thread()->general_tag));
c0003a28:	e8 6d f7 ff ff       	call   c000319a <running_thread>
c0003a2d:	8d 50 20             	lea    0x20(%eax),%edx
c0003a30:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a33:	83 c0 04             	add    $0x4,%eax
c0003a36:	83 ec 08             	sub    $0x8,%esp
c0003a39:	52                   	push   %edx
c0003a3a:	50                   	push   %eax
c0003a3b:	e8 c9 fd ff ff       	call   c0003809 <elem_find>
c0003a40:	83 c4 10             	add    $0x10,%esp
c0003a43:	85 c0                	test   %eax,%eax
c0003a45:	74 19                	je     c0003a60 <sema_down+0x4b>
/work/x86_os_my/thread/sync.c:26 (discriminator 1)
c0003a47:	68 5c 51 00 c0       	push   $0xc000515c
c0003a4c:	68 60 52 00 c0       	push   $0xc0005260
c0003a51:	6a 1a                	push   $0x1a
c0003a53:	68 98 51 00 c0       	push   $0xc0005198
c0003a58:	e8 45 e8 ff ff       	call   c00022a2 <panic_spin>
c0003a5d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:28
		/* 当前线程不应该已在信号量的waiters队列中 */
		if (elem_find(&psema->waiters, &running_thread()->general_tag)) {
c0003a60:	e8 35 f7 ff ff       	call   c000319a <running_thread>
c0003a65:	8d 50 20             	lea    0x20(%eax),%edx
c0003a68:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a6b:	83 c0 04             	add    $0x4,%eax
c0003a6e:	83 ec 08             	sub    $0x8,%esp
c0003a71:	52                   	push   %edx
c0003a72:	50                   	push   %eax
c0003a73:	e8 91 fd ff ff       	call   c0003809 <elem_find>
c0003a78:	83 c4 10             	add    $0x10,%esp
c0003a7b:	85 c0                	test   %eax,%eax
c0003a7d:	74 19                	je     c0003a98 <sema_down+0x83>
/work/x86_os_my/thread/sync.c:29
			PANIC("sema_down: thread blocked has been in waiters_list\n");
c0003a7f:	68 a8 51 00 c0       	push   $0xc00051a8
c0003a84:	68 60 52 00 c0       	push   $0xc0005260
c0003a89:	6a 1d                	push   $0x1d
c0003a8b:	68 98 51 00 c0       	push   $0xc0005198
c0003a90:	e8 0d e8 ff ff       	call   c00022a2 <panic_spin>
c0003a95:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:32
		}
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
c0003a98:	e8 fd f6 ff ff       	call   c000319a <running_thread>
c0003a9d:	8d 50 20             	lea    0x20(%eax),%edx
c0003aa0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003aa3:	83 c0 04             	add    $0x4,%eax
c0003aa6:	83 ec 08             	sub    $0x8,%esp
c0003aa9:	52                   	push   %edx
c0003aaa:	50                   	push   %eax
c0003aab:	e8 df fc ff ff       	call   c000378f <list_append>
c0003ab0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:33
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
c0003ab3:	83 ec 0c             	sub    $0xc,%esp
c0003ab6:	6a 02                	push   $0x2
c0003ab8:	e8 96 fa ff ff       	call   c0003553 <thread_block>
c0003abd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:25
/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c0003ac0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ac3:	0f b6 00             	movzbl (%eax),%eax
c0003ac6:	84 c0                	test   %al,%al
c0003ac8:	0f 84 5a ff ff ff    	je     c0003a28 <sema_down+0x13>
/work/x86_os_my/thread/sync.c:36
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
	}
	/* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*/
	psema->value--;
c0003ace:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ad1:	0f b6 00             	movzbl (%eax),%eax
c0003ad4:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003ad7:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ada:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:37
	ASSERT(psema->value == 0);
c0003adc:	8b 45 08             	mov    0x8(%ebp),%eax
c0003adf:	0f b6 00             	movzbl (%eax),%eax
c0003ae2:	84 c0                	test   %al,%al
c0003ae4:	74 19                	je     c0003aff <sema_down+0xea>
/work/x86_os_my/thread/sync.c:37 (discriminator 1)
c0003ae6:	68 dc 51 00 c0       	push   $0xc00051dc
c0003aeb:	68 60 52 00 c0       	push   $0xc0005260
c0003af0:	6a 25                	push   $0x25
c0003af2:	68 98 51 00 c0       	push   $0xc0005198
c0003af7:	e8 a6 e7 ff ff       	call   c00022a2 <panic_spin>
c0003afc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:40
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c0003aff:	83 ec 0c             	sub    $0xc,%esp
c0003b02:	ff 75 f4             	pushl  -0xc(%ebp)
c0003b05:	e8 b6 de ff ff       	call   c00019c0 <intr_set_status>
c0003b0a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:41
}
c0003b0d:	90                   	nop
c0003b0e:	c9                   	leave  
c0003b0f:	c3                   	ret    

c0003b10 <sema_up>:
sema_up():
/work/x86_os_my/thread/sync.c:44

/* 信号量的up操作 */
void sema_up(struct semaphore* psema) {
c0003b10:	55                   	push   %ebp
c0003b11:	89 e5                	mov    %esp,%ebp
c0003b13:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:46
	/* 关中断,保证原子操作 */
	enum intr_status old_status = intr_disable();
c0003b16:	e8 7c de ff ff       	call   c0001997 <intr_disable>
c0003b1b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:48
	
	ASSERT(psema->value == 0);
c0003b1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b21:	0f b6 00             	movzbl (%eax),%eax
c0003b24:	84 c0                	test   %al,%al
c0003b26:	74 19                	je     c0003b41 <sema_up+0x31>
/work/x86_os_my/thread/sync.c:48 (discriminator 1)
c0003b28:	68 dc 51 00 c0       	push   $0xc00051dc
c0003b2d:	68 6c 52 00 c0       	push   $0xc000526c
c0003b32:	6a 30                	push   $0x30
c0003b34:	68 98 51 00 c0       	push   $0xc0005198
c0003b39:	e8 64 e7 ff ff       	call   c00022a2 <panic_spin>
c0003b3e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:49
	if (!list_empty(&psema->waiters)) {
c0003b41:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b44:	83 c0 04             	add    $0x4,%eax
c0003b47:	83 ec 0c             	sub    $0xc,%esp
c0003b4a:	50                   	push   %eax
c0003b4b:	e8 86 fd ff ff       	call   c00038d6 <list_empty>
c0003b50:	83 c4 10             	add    $0x10,%esp
c0003b53:	85 c0                	test   %eax,%eax
c0003b55:	75 26                	jne    c0003b7d <sema_up+0x6d>
/work/x86_os_my/thread/sync.c:50
		struct task_struct* thread_blocked = elem2entry(struct task_struct, general_tag, list_pop(&psema->waiters));
c0003b57:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b5a:	83 c0 04             	add    $0x4,%eax
c0003b5d:	83 ec 0c             	sub    $0xc,%esp
c0003b60:	50                   	push   %eax
c0003b61:	e8 81 fc ff ff       	call   c00037e7 <list_pop>
c0003b66:	83 c4 10             	add    $0x10,%esp
c0003b69:	83 e8 20             	sub    $0x20,%eax
c0003b6c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/sync.c:51
		thread_unblock(thread_blocked);
c0003b6f:	83 ec 0c             	sub    $0xc,%esp
c0003b72:	ff 75 f0             	pushl  -0x10(%ebp)
c0003b75:	e8 3c fa ff ff       	call   c00035b6 <thread_unblock>
c0003b7a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:53
	}
	psema->value++;
c0003b7d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b80:	0f b6 00             	movzbl (%eax),%eax
c0003b83:	8d 50 01             	lea    0x1(%eax),%edx
c0003b86:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b89:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:54
	ASSERT(psema->value == 1);
c0003b8b:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b8e:	0f b6 00             	movzbl (%eax),%eax
c0003b91:	3c 01                	cmp    $0x1,%al
c0003b93:	74 19                	je     c0003bae <sema_up+0x9e>
/work/x86_os_my/thread/sync.c:54 (discriminator 1)
c0003b95:	68 ee 51 00 c0       	push   $0xc00051ee
c0003b9a:	68 6c 52 00 c0       	push   $0xc000526c
c0003b9f:	6a 36                	push   $0x36
c0003ba1:	68 98 51 00 c0       	push   $0xc0005198
c0003ba6:	e8 f7 e6 ff ff       	call   c00022a2 <panic_spin>
c0003bab:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:57
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c0003bae:	83 ec 0c             	sub    $0xc,%esp
c0003bb1:	ff 75 f4             	pushl  -0xc(%ebp)
c0003bb4:	e8 07 de ff ff       	call   c00019c0 <intr_set_status>
c0003bb9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:58
}
c0003bbc:	90                   	nop
c0003bbd:	c9                   	leave  
c0003bbe:	c3                   	ret    

c0003bbf <lock_acquire>:
lock_acquire():
/work/x86_os_my/thread/sync.c:61

/* 获取锁plock */
void lock_acquire(struct lock* plock) {
c0003bbf:	55                   	push   %ebp
c0003bc0:	89 e5                	mov    %esp,%ebp
c0003bc2:	53                   	push   %ebx
c0003bc3:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:63
	/* 排除曾经自己已经持有锁但还未将其释放的情况。*/
	if (plock->holder != running_thread()) {
c0003bc6:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bc9:	8b 18                	mov    (%eax),%ebx
c0003bcb:	e8 ca f5 ff ff       	call   c000319a <running_thread>
c0003bd0:	39 c3                	cmp    %eax,%ebx
c0003bd2:	74 4d                	je     c0003c21 <lock_acquire+0x62>
/work/x86_os_my/thread/sync.c:64
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
c0003bd4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bd7:	83 c0 04             	add    $0x4,%eax
c0003bda:	83 ec 0c             	sub    $0xc,%esp
c0003bdd:	50                   	push   %eax
c0003bde:	e8 32 fe ff ff       	call   c0003a15 <sema_down>
c0003be3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:65
		plock->holder = running_thread();
c0003be6:	e8 af f5 ff ff       	call   c000319a <running_thread>
c0003beb:	89 c2                	mov    %eax,%edx
c0003bed:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bf0:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/sync.c:66
		ASSERT(plock->holder_repeat_nr == 0);
c0003bf2:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bf5:	8b 40 18             	mov    0x18(%eax),%eax
c0003bf8:	85 c0                	test   %eax,%eax
c0003bfa:	74 19                	je     c0003c15 <lock_acquire+0x56>
/work/x86_os_my/thread/sync.c:66 (discriminator 1)
c0003bfc:	68 00 52 00 c0       	push   $0xc0005200
c0003c01:	68 74 52 00 c0       	push   $0xc0005274
c0003c06:	6a 42                	push   $0x42
c0003c08:	68 98 51 00 c0       	push   $0xc0005198
c0003c0d:	e8 90 e6 ff ff       	call   c00022a2 <panic_spin>
c0003c12:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:67
		plock->holder_repeat_nr = 1;
c0003c15:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c18:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	} else {
		plock->holder_repeat_nr++;
	}
}
c0003c1f:	eb 0f                	jmp    c0003c30 <lock_acquire+0x71>
/work/x86_os_my/thread/sync.c:69
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
		plock->holder = running_thread();
		ASSERT(plock->holder_repeat_nr == 0);
		plock->holder_repeat_nr = 1;
	} else {
		plock->holder_repeat_nr++;
c0003c21:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c24:	8b 40 18             	mov    0x18(%eax),%eax
c0003c27:	8d 50 01             	lea    0x1(%eax),%edx
c0003c2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c2d:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	}
}
c0003c30:	90                   	nop
c0003c31:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0003c34:	c9                   	leave  
c0003c35:	c3                   	ret    

c0003c36 <lock_release>:
lock_release():
/work/x86_os_my/thread/sync.c:74

/* 释放锁plock */
void lock_release(struct lock* plock) {
c0003c36:	55                   	push   %ebp
c0003c37:	89 e5                	mov    %esp,%ebp
c0003c39:	53                   	push   %ebx
c0003c3a:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:75
	ASSERT(plock->holder == running_thread());
c0003c3d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c40:	8b 18                	mov    (%eax),%ebx
c0003c42:	e8 53 f5 ff ff       	call   c000319a <running_thread>
c0003c47:	39 c3                	cmp    %eax,%ebx
c0003c49:	74 19                	je     c0003c64 <lock_release+0x2e>
/work/x86_os_my/thread/sync.c:75 (discriminator 1)
c0003c4b:	68 20 52 00 c0       	push   $0xc0005220
c0003c50:	68 84 52 00 c0       	push   $0xc0005284
c0003c55:	6a 4b                	push   $0x4b
c0003c57:	68 98 51 00 c0       	push   $0xc0005198
c0003c5c:	e8 41 e6 ff ff       	call   c00022a2 <panic_spin>
c0003c61:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:76
	if (plock->holder_repeat_nr > 1) {
c0003c64:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c67:	8b 40 18             	mov    0x18(%eax),%eax
c0003c6a:	83 f8 01             	cmp    $0x1,%eax
c0003c6d:	76 11                	jbe    c0003c80 <lock_release+0x4a>
/work/x86_os_my/thread/sync.c:77
		plock->holder_repeat_nr--;
c0003c6f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c72:	8b 40 18             	mov    0x18(%eax),%eax
c0003c75:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003c78:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c7b:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:78
		return;
c0003c7e:	eb 49                	jmp    c0003cc9 <lock_release+0x93>
/work/x86_os_my/thread/sync.c:80
	}
	ASSERT(plock->holder_repeat_nr == 1);
c0003c80:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c83:	8b 40 18             	mov    0x18(%eax),%eax
c0003c86:	83 f8 01             	cmp    $0x1,%eax
c0003c89:	74 19                	je     c0003ca4 <lock_release+0x6e>
/work/x86_os_my/thread/sync.c:80 (discriminator 1)
c0003c8b:	68 42 52 00 c0       	push   $0xc0005242
c0003c90:	68 84 52 00 c0       	push   $0xc0005284
c0003c95:	6a 50                	push   $0x50
c0003c97:	68 98 51 00 c0       	push   $0xc0005198
c0003c9c:	e8 01 e6 ff ff       	call   c00022a2 <panic_spin>
c0003ca1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:82

	plock->holder = NULL;			// 把锁的持有者置空放在V操作之前
c0003ca4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ca7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:83
	plock->holder_repeat_nr = 0;
c0003cad:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cb0:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:84
	sema_up(&plock->semaphore);		// 信号量的V操作,也是原子操作
c0003cb7:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cba:	83 c0 04             	add    $0x4,%eax
c0003cbd:	83 ec 0c             	sub    $0xc,%esp
c0003cc0:	50                   	push   %eax
c0003cc1:	e8 4a fe ff ff       	call   c0003b10 <sema_up>
c0003cc6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:85
}
c0003cc9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0003ccc:	c9                   	leave  
c0003ccd:	c3                   	ret    

c0003cce <inb>:
inb():
/work/x86_os_my/lib/kernel/io.h:36
   asm volatile ("cld; rep outsw" : "+S" (addr), "+c" (word_cnt) : "d" (port));
/******************************************************/
}

/* 将从端口port读入的一个字节返回 */
static inline uint8_t inb(uint16_t port) {
c0003cce:	55                   	push   %ebp
c0003ccf:	89 e5                	mov    %esp,%ebp
c0003cd1:	83 ec 14             	sub    $0x14,%esp
c0003cd4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cd7:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/io.h:38
   uint8_t data;
   asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0003cdb:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0003cdf:	89 c2                	mov    %eax,%edx
c0003ce1:	ec                   	in     (%dx),%al
c0003ce2:	88 45 ff             	mov    %al,-0x1(%ebp)
/work/x86_os_my/lib/kernel/io.h:39
   return data;
c0003ce5:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
/work/x86_os_my/lib/kernel/io.h:40
}
c0003ce9:	c9                   	leave  
c0003cea:	c3                   	ret    

c0003ceb <intr_keyboard_handler>:
intr_keyboard_handler():
/work/x86_os_my/device/keyboard.c:111
/* 0x3A */	{caps_lock_char, caps_lock_char}
/*其它按键暂不处理*/
};

/* 键盘中断处理程序 */
static void intr_keyboard_handler(void) {
c0003ceb:	55                   	push   %ebp
c0003cec:	89 e5                	mov    %esp,%ebp
c0003cee:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/device/keyboard.c:114

/* 这次中断发生前的上一次中断,以下任意三个键是否有按下 */
   bool ctrl_down_last = ctrl_status;	  
c0003cf1:	a1 80 74 00 c0       	mov    0xc0007480,%eax
c0003cf6:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/device/keyboard.c:115
   bool shift_down_last = shift_status;
c0003cf9:	a1 84 74 00 c0       	mov    0xc0007484,%eax
c0003cfe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/device/keyboard.c:116
   bool caps_lock_last = caps_lock_status;
c0003d01:	a1 8c 74 00 c0       	mov    0xc000748c,%eax
c0003d06:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/device/keyboard.c:119

   bool break_code;
   uint16_t scancode = inb(KBD_BUF_PORT);
c0003d09:	6a 60                	push   $0x60
c0003d0b:	e8 be ff ff ff       	call   c0003cce <inb>
c0003d10:	83 c4 04             	add    $0x4,%esp
c0003d13:	0f b6 c0             	movzbl %al,%eax
c0003d16:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:123

/* 若扫描码是e0开头的,表示此键的按下将产生多个扫描码,
 * 所以马上结束此次中断处理函数,等待下一个扫描码进来*/ 
   if (scancode == 0xe0) { 
c0003d1a:	66 81 7d f6 e0 00    	cmpw   $0xe0,-0xa(%ebp)
c0003d20:	75 0f                	jne    c0003d31 <intr_keyboard_handler+0x46>
/work/x86_os_my/device/keyboard.c:124
      ext_scancode = true;    // 打开e0标记
c0003d22:	c7 05 90 74 00 c0 01 	movl   $0x1,0xc0007490
c0003d29:	00 00 00 
/work/x86_os_my/device/keyboard.c:125
      return;
c0003d2c:	e9 50 02 00 00       	jmp    c0003f81 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:129
   }

/* 如果上次是以0xe0开头,将扫描码合并 */
   if (ext_scancode) {
c0003d31:	a1 90 74 00 c0       	mov    0xc0007490,%eax
c0003d36:	85 c0                	test   %eax,%eax
c0003d38:	74 10                	je     c0003d4a <intr_keyboard_handler+0x5f>
/work/x86_os_my/device/keyboard.c:130
      scancode = ((0xe000) | scancode);
c0003d3a:	66 81 4d f6 00 e0    	orw    $0xe000,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:131
      ext_scancode = false;   // 关闭e0标记
c0003d40:	c7 05 90 74 00 c0 00 	movl   $0x0,0xc0007490
c0003d47:	00 00 00 
/work/x86_os_my/device/keyboard.c:134
   }   

   break_code = ((scancode & 0x0080) != 0);   // 获取break_code
c0003d4a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0003d4e:	25 80 00 00 00       	and    $0x80,%eax
c0003d53:	85 c0                	test   %eax,%eax
c0003d55:	0f 95 c0             	setne  %al
c0003d58:	0f b6 c0             	movzbl %al,%eax
c0003d5b:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/device/keyboard.c:136
   
   if (break_code) {   // 若是断码break_code(按键弹起时产生的扫描码)
c0003d5e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0003d62:	74 6a                	je     c0003dce <intr_keyboard_handler+0xe3>
/work/x86_os_my/device/keyboard.c:140

   /* 由于ctrl_r 和alt_r的make_code和break_code都是两字节,
   所以可用下面的方法取make_code,多字节的扫描码暂不处理 */
      uint16_t make_code = (scancode &= 0xff7f);   // 得到其make_code(按键按下时产生的扫描码)
c0003d64:	66 81 65 f6 7f ff    	andw   $0xff7f,-0xa(%ebp)
c0003d6a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0003d6e:	66 89 45 da          	mov    %ax,-0x26(%ebp)
/work/x86_os_my/device/keyboard.c:143

   /* 若是任意以下三个键弹起了,将状态置为false */
      if (make_code == ctrl_l_make || make_code == ctrl_r_make) {
c0003d72:	66 83 7d da 1d       	cmpw   $0x1d,-0x26(%ebp)
c0003d77:	74 08                	je     c0003d81 <intr_keyboard_handler+0x96>
/work/x86_os_my/device/keyboard.c:143 (discriminator 1)
c0003d79:	66 81 7d da 1d e0    	cmpw   $0xe01d,-0x26(%ebp)
c0003d7f:	75 0c                	jne    c0003d8d <intr_keyboard_handler+0xa2>
/work/x86_os_my/device/keyboard.c:144
	 ctrl_status = false;
c0003d81:	c7 05 80 74 00 c0 00 	movl   $0x0,0xc0007480
c0003d88:	00 00 00 
c0003d8b:	eb 3c                	jmp    c0003dc9 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:145
      } else if (make_code == shift_l_make || make_code == shift_r_make) {
c0003d8d:	66 83 7d da 2a       	cmpw   $0x2a,-0x26(%ebp)
c0003d92:	74 07                	je     c0003d9b <intr_keyboard_handler+0xb0>
/work/x86_os_my/device/keyboard.c:145 (discriminator 1)
c0003d94:	66 83 7d da 36       	cmpw   $0x36,-0x26(%ebp)
c0003d99:	75 0c                	jne    c0003da7 <intr_keyboard_handler+0xbc>
/work/x86_os_my/device/keyboard.c:146
	 shift_status = false;
c0003d9b:	c7 05 84 74 00 c0 00 	movl   $0x0,0xc0007484
c0003da2:	00 00 00 
c0003da5:	eb 22                	jmp    c0003dc9 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:147
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
c0003da7:	66 83 7d da 38       	cmpw   $0x38,-0x26(%ebp)
c0003dac:	74 0c                	je     c0003dba <intr_keyboard_handler+0xcf>
/work/x86_os_my/device/keyboard.c:147 (discriminator 1)
c0003dae:	66 81 7d da 38 e0    	cmpw   $0xe038,-0x26(%ebp)
c0003db4:	0f 85 c0 01 00 00    	jne    c0003f7a <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:148
	 alt_status = false;
c0003dba:	c7 05 88 74 00 c0 00 	movl   $0x0,0xc0007488
c0003dc1:	00 00 00 
/work/x86_os_my/device/keyboard.c:151
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c0003dc4:	e9 b1 01 00 00       	jmp    c0003f7a <intr_keyboard_handler+0x28f>
c0003dc9:	e9 ac 01 00 00       	jmp    c0003f7a <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:155

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
c0003dce:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c0003dd3:	74 07                	je     c0003ddc <intr_keyboard_handler+0xf1>
/work/x86_os_my/device/keyboard.c:155 (discriminator 1)
c0003dd5:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0003dda:	76 14                	jbe    c0003df0 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:155 (discriminator 3)
c0003ddc:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c0003de2:	74 0c                	je     c0003df0 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:156
	       (scancode == alt_r_make) || \
c0003de4:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0003dea:	0f 85 78 01 00 00    	jne    c0003f68 <intr_keyboard_handler+0x27d>
/work/x86_os_my/device/keyboard.c:158
	       (scancode == ctrl_r_make)) {
      bool shift = false;  // 判断是否与shift组合,用来在一维数组中索引对应的字符
c0003df0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:159
      if ((scancode < 0x0e) || (scancode == 0x29) || \
c0003df7:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%ebp)
c0003dfc:	76 3f                	jbe    c0003e3d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 1)
c0003dfe:	66 83 7d f6 29       	cmpw   $0x29,-0xa(%ebp)
c0003e03:	74 38                	je     c0003e3d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 2)
c0003e05:	66 83 7d f6 1a       	cmpw   $0x1a,-0xa(%ebp)
c0003e0a:	74 31                	je     c0003e3d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160
	 (scancode == 0x1a) || (scancode == 0x1b) || \
c0003e0c:	66 83 7d f6 1b       	cmpw   $0x1b,-0xa(%ebp)
c0003e11:	74 2a                	je     c0003e3d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160 (discriminator 1)
c0003e13:	66 83 7d f6 2b       	cmpw   $0x2b,-0xa(%ebp)
c0003e18:	74 23                	je     c0003e3d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161
	 (scancode == 0x2b) || (scancode == 0x27) || \
c0003e1a:	66 83 7d f6 27       	cmpw   $0x27,-0xa(%ebp)
c0003e1f:	74 1c                	je     c0003e3d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161 (discriminator 1)
c0003e21:	66 83 7d f6 28       	cmpw   $0x28,-0xa(%ebp)
c0003e26:	74 15                	je     c0003e3d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162
	 (scancode == 0x28) || (scancode == 0x33) || \
c0003e28:	66 83 7d f6 33       	cmpw   $0x33,-0xa(%ebp)
c0003e2d:	74 0e                	je     c0003e3d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162 (discriminator 1)
c0003e2f:	66 83 7d f6 34       	cmpw   $0x34,-0xa(%ebp)
c0003e34:	74 07                	je     c0003e3d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:163
	 (scancode == 0x34) || (scancode == 0x35)) {  
c0003e36:	66 83 7d f6 35       	cmpw   $0x35,-0xa(%ebp)
c0003e3b:	75 0f                	jne    c0003e4c <intr_keyboard_handler+0x161>
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c0003e3d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0003e41:	74 3a                	je     c0003e7d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:177
	    shift = true;
c0003e43:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c0003e4a:	eb 31                	jmp    c0003e7d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:180
	    shift = true;
	 }
      } else {	  // 默认为字母键
	 if (shift_down_last && caps_lock_last) {  // 如果shift和capslock同时按下
c0003e4c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0003e50:	74 0f                	je     c0003e61 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:180 (discriminator 1)
c0003e52:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0003e56:	74 09                	je     c0003e61 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:181
	    shift = false;
c0003e58:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0003e5f:	eb 1c                	jmp    c0003e7d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:182
	 } else if (shift_down_last || caps_lock_last) { // 如果shift和capslock任意被按下
c0003e61:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0003e65:	75 06                	jne    c0003e6d <intr_keyboard_handler+0x182>
/work/x86_os_my/device/keyboard.c:182 (discriminator 1)
c0003e67:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0003e6b:	74 09                	je     c0003e76 <intr_keyboard_handler+0x18b>
/work/x86_os_my/device/keyboard.c:183
	    shift = true;
c0003e6d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c0003e74:	eb 07                	jmp    c0003e7d <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:185
	 } else {
	    shift = false;
c0003e76:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:189
	 }
      }

      uint8_t index = (scancode &= 0x00ff);  // 将扫描码的高字节置0,主要是针对高字节是e0的扫描码.
c0003e7d:	66 81 65 f6 ff 00    	andw   $0xff,-0xa(%ebp)
c0003e83:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0003e87:	88 45 d9             	mov    %al,-0x27(%ebp)
/work/x86_os_my/device/keyboard.c:190
      char cur_char = keymap[index][shift];  // 在数组中找到对应的字符
c0003e8a:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
c0003e8e:	8d 14 00             	lea    (%eax,%eax,1),%edx
c0003e91:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003e94:	01 d0                	add    %edx,%eax
c0003e96:	05 40 72 00 c0       	add    $0xc0007240,%eax
c0003e9b:	0f b6 00             	movzbl (%eax),%eax
c0003e9e:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:193

   /* 如果cur_char不为0,也就是ascii码为除'\0'外的字符就加入键盘缓冲区中 */
      if (cur_char) {
c0003ea1:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c0003ea5:	74 54                	je     c0003efb <intr_keyboard_handler+0x210>
/work/x86_os_my/device/keyboard.c:200
     /*****************  快捷键ctrl+l和ctrl+u的处理 *********************
      * 下面是把ctrl+l和ctrl+u这两种组合键产生的字符置为:
      * cur_char的asc码-字符a的asc码, 此差值比较小,
      * 属于asc码表中不可见的字符部分.故不会产生可见字符.
      * 我们在shell中将ascii值为l-a和u-a的分别处理为清屏和删除输入的快捷键*/
	 if ((ctrl_down_last && cur_char == 'l') || (ctrl_down_last && cur_char == 'u')) {
c0003ea7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0003eab:	74 06                	je     c0003eb3 <intr_keyboard_handler+0x1c8>
/work/x86_os_my/device/keyboard.c:200 (discriminator 1)
c0003ead:	80 7d ef 6c          	cmpb   $0x6c,-0x11(%ebp)
c0003eb1:	74 0c                	je     c0003ebf <intr_keyboard_handler+0x1d4>
/work/x86_os_my/device/keyboard.c:200 (discriminator 3)
c0003eb3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0003eb7:	74 10                	je     c0003ec9 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:200 (discriminator 4)
c0003eb9:	80 7d ef 75          	cmpb   $0x75,-0x11(%ebp)
c0003ebd:	75 0a                	jne    c0003ec9 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:201
	    cur_char -= 'a';
c0003ebf:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c0003ec3:	83 e8 61             	sub    $0x61,%eax
c0003ec6:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:207
	 }
      /****************************************************************/
      
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
c0003ec9:	83 ec 0c             	sub    $0xc,%esp
c0003ecc:	68 60 77 00 c0       	push   $0xc0007760
c0003ed1:	e8 58 01 00 00       	call   c000402e <ioq_full>
c0003ed6:	83 c4 10             	add    $0x10,%esp
c0003ed9:	85 c0                	test   %eax,%eax
c0003edb:	0f 85 9c 00 00 00    	jne    c0003f7d <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:208
	    ioq_putchar(&kbd_buf, cur_char);
c0003ee1:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
c0003ee5:	83 ec 08             	sub    $0x8,%esp
c0003ee8:	50                   	push   %eax
c0003ee9:	68 60 77 00 c0       	push   $0xc0007760
c0003eee:	e8 0d 03 00 00       	call   c0004200 <ioq_putchar>
c0003ef3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:210
	 }
	 return;
c0003ef6:	e9 82 00 00 00       	jmp    c0003f7d <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:214
      }

      /* 记录本次是否按下了下面几类控制键之一,供下次键入时判断组合键 */
      if (scancode == ctrl_l_make || scancode == ctrl_r_make) {
c0003efb:	66 83 7d f6 1d       	cmpw   $0x1d,-0xa(%ebp)
c0003f00:	74 08                	je     c0003f0a <intr_keyboard_handler+0x21f>
/work/x86_os_my/device/keyboard.c:214 (discriminator 1)
c0003f02:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0003f08:	75 0c                	jne    c0003f16 <intr_keyboard_handler+0x22b>
/work/x86_os_my/device/keyboard.c:215
	 ctrl_status = true;
c0003f0a:	c7 05 80 74 00 c0 01 	movl   $0x1,0xc0007480
c0003f11:	00 00 00 
c0003f14:	eb 50                	jmp    c0003f66 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:216
      } else if (scancode == shift_l_make || scancode == shift_r_make) {
c0003f16:	66 83 7d f6 2a       	cmpw   $0x2a,-0xa(%ebp)
c0003f1b:	74 07                	je     c0003f24 <intr_keyboard_handler+0x239>
/work/x86_os_my/device/keyboard.c:216 (discriminator 1)
c0003f1d:	66 83 7d f6 36       	cmpw   $0x36,-0xa(%ebp)
c0003f22:	75 0c                	jne    c0003f30 <intr_keyboard_handler+0x245>
/work/x86_os_my/device/keyboard.c:217
	 shift_status = true;
c0003f24:	c7 05 84 74 00 c0 01 	movl   $0x1,0xc0007484
c0003f2b:	00 00 00 
c0003f2e:	eb 36                	jmp    c0003f66 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:218
      } else if (scancode == alt_l_make || scancode == alt_r_make) {
c0003f30:	66 83 7d f6 38       	cmpw   $0x38,-0xa(%ebp)
c0003f35:	74 08                	je     c0003f3f <intr_keyboard_handler+0x254>
/work/x86_os_my/device/keyboard.c:218 (discriminator 1)
c0003f37:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c0003f3d:	75 0c                	jne    c0003f4b <intr_keyboard_handler+0x260>
/work/x86_os_my/device/keyboard.c:219
	 alt_status = true;
c0003f3f:	c7 05 88 74 00 c0 01 	movl   $0x1,0xc0007488
c0003f46:	00 00 00 
c0003f49:	eb 1b                	jmp    c0003f66 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:220
      } else if (scancode == caps_lock_make) {
c0003f4b:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0003f50:	75 2e                	jne    c0003f80 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:223
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
c0003f52:	a1 8c 74 00 c0       	mov    0xc000748c,%eax
c0003f57:	85 c0                	test   %eax,%eax
c0003f59:	0f 94 c0             	sete   %al
c0003f5c:	0f b6 c0             	movzbl %al,%eax
c0003f5f:	a3 8c 74 00 c0       	mov    %eax,0xc000748c
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c0003f64:	eb 1a                	jmp    c0003f80 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:157 (discriminator 3)
c0003f66:	eb 18                	jmp    c0003f80 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:226
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
c0003f68:	83 ec 0c             	sub    $0xc,%esp
c0003f6b:	68 91 52 00 c0       	push   $0xc0005291
c0003f70:	e8 bb e1 ff ff       	call   c0002130 <put_str>
c0003f75:	83 c4 10             	add    $0x10,%esp
c0003f78:	eb 07                	jmp    c0003f81 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:151
	 shift_status = false;
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
	 alt_status = false;
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c0003f7a:	90                   	nop
c0003f7b:	eb 04                	jmp    c0003f81 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:210
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
	    ioq_putchar(&kbd_buf, cur_char);
	 }
	 return;
c0003f7d:	90                   	nop
c0003f7e:	eb 01                	jmp    c0003f81 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c0003f80:	90                   	nop
/work/x86_os_my/device/keyboard.c:228
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
   }
}
c0003f81:	c9                   	leave  
c0003f82:	c3                   	ret    

c0003f83 <keyboard_init>:
keyboard_init():
/work/x86_os_my/device/keyboard.c:231

/* 键盘初始化 */
void keyboard_init() {
c0003f83:	55                   	push   %ebp
c0003f84:	89 e5                	mov    %esp,%ebp
c0003f86:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/keyboard.c:232
   put_str("keyboard init start\n");
c0003f89:	83 ec 0c             	sub    $0xc,%esp
c0003f8c:	68 9e 52 00 c0       	push   $0xc000529e
c0003f91:	e8 9a e1 ff ff       	call   c0002130 <put_str>
c0003f96:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:233
   ioqueue_init(&kbd_buf);
c0003f99:	83 ec 0c             	sub    $0xc,%esp
c0003f9c:	68 60 77 00 c0       	push   $0xc0007760
c0003fa1:	e8 28 00 00 00       	call   c0003fce <ioqueue_init>
c0003fa6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:234
   register_handler(0x21, intr_keyboard_handler);
c0003fa9:	83 ec 08             	sub    $0x8,%esp
c0003fac:	68 eb 3c 00 c0       	push   $0xc0003ceb
c0003fb1:	6a 21                	push   $0x21
c0003fb3:	e8 4a da ff ff       	call   c0001a02 <register_handler>
c0003fb8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:235
   put_str("keyboard init done\n");
c0003fbb:	83 ec 0c             	sub    $0xc,%esp
c0003fbe:	68 b3 52 00 c0       	push   $0xc00052b3
c0003fc3:	e8 68 e1 ff ff       	call   c0002130 <put_str>
c0003fc8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:236
}
c0003fcb:	90                   	nop
c0003fcc:	c9                   	leave  
c0003fcd:	c3                   	ret    

c0003fce <ioqueue_init>:
ioqueue_init():
/work/x86_os_my/device/ioqueue.c:7
#include "interrupt.h"
#include "global.h"
#include "debug.h"

/* 初始化io队列ioq */
void ioqueue_init(struct ioqueue* ioq) {
c0003fce:	55                   	push   %ebp
c0003fcf:	89 e5                	mov    %esp,%ebp
c0003fd1:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:8
   lock_init(&ioq->lock);     // 初始化io队列的锁
c0003fd4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003fd7:	83 ec 0c             	sub    $0xc,%esp
c0003fda:	50                   	push   %eax
c0003fdb:	e8 05 fa ff ff       	call   c00039e5 <lock_init>
c0003fe0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:9
   ioq->producer = ioq->consumer = NULL;  // 生产者和消费者置空
c0003fe3:	8b 45 08             	mov    0x8(%ebp),%eax
c0003fe6:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c0003fed:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ff0:	8b 50 20             	mov    0x20(%eax),%edx
c0003ff3:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ff6:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/device/ioqueue.c:10
   ioq->head = ioq->tail = 0; // 队列的首尾指针指向缓冲区数组第0个位置
c0003ff9:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ffc:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)
c0004003:	8b 45 08             	mov    0x8(%ebp),%eax
c0004006:	8b 50 68             	mov    0x68(%eax),%edx
c0004009:	8b 45 08             	mov    0x8(%ebp),%eax
c000400c:	89 50 64             	mov    %edx,0x64(%eax)
/work/x86_os_my/device/ioqueue.c:11
}
c000400f:	90                   	nop
c0004010:	c9                   	leave  
c0004011:	c3                   	ret    

c0004012 <next_pos>:
next_pos():
/work/x86_os_my/device/ioqueue.c:14

/* 返回pos在缓冲区中的下一个位置值 */
static int32_t next_pos(int32_t pos) {
c0004012:	55                   	push   %ebp
c0004013:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/device/ioqueue.c:15
   return (pos + 1) % bufsize; 
c0004015:	8b 45 08             	mov    0x8(%ebp),%eax
c0004018:	8d 50 01             	lea    0x1(%eax),%edx
c000401b:	89 d0                	mov    %edx,%eax
c000401d:	c1 f8 1f             	sar    $0x1f,%eax
c0004020:	c1 e8 1a             	shr    $0x1a,%eax
c0004023:	01 c2                	add    %eax,%edx
c0004025:	83 e2 3f             	and    $0x3f,%edx
c0004028:	29 c2                	sub    %eax,%edx
c000402a:	89 d0                	mov    %edx,%eax
/work/x86_os_my/device/ioqueue.c:16
}
c000402c:	5d                   	pop    %ebp
c000402d:	c3                   	ret    

c000402e <ioq_full>:
ioq_full():
/work/x86_os_my/device/ioqueue.c:19

/* 判断队列是否已满 */
bool ioq_full(struct ioqueue* ioq) {
c000402e:	55                   	push   %ebp
c000402f:	89 e5                	mov    %esp,%ebp
c0004031:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:20
   ASSERT(intr_get_status() == INTR_OFF);
c0004034:	e8 a5 d9 ff ff       	call   c00019de <intr_get_status>
c0004039:	85 c0                	test   %eax,%eax
c000403b:	74 19                	je     c0004056 <ioq_full+0x28>
/work/x86_os_my/device/ioqueue.c:20 (discriminator 1)
c000403d:	68 c8 52 00 c0       	push   $0xc00052c8
c0004042:	68 2c 53 00 c0       	push   $0xc000532c
c0004047:	6a 14                	push   $0x14
c0004049:	68 e6 52 00 c0       	push   $0xc00052e6
c000404e:	e8 4f e2 ff ff       	call   c00022a2 <panic_spin>
c0004053:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:21
   return next_pos(ioq->head) == ioq->tail;
c0004056:	8b 45 08             	mov    0x8(%ebp),%eax
c0004059:	8b 40 64             	mov    0x64(%eax),%eax
c000405c:	83 ec 0c             	sub    $0xc,%esp
c000405f:	50                   	push   %eax
c0004060:	e8 ad ff ff ff       	call   c0004012 <next_pos>
c0004065:	83 c4 10             	add    $0x10,%esp
c0004068:	89 c2                	mov    %eax,%edx
c000406a:	8b 45 08             	mov    0x8(%ebp),%eax
c000406d:	8b 40 68             	mov    0x68(%eax),%eax
c0004070:	39 c2                	cmp    %eax,%edx
c0004072:	0f 94 c0             	sete   %al
c0004075:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:22
}
c0004078:	c9                   	leave  
c0004079:	c3                   	ret    

c000407a <ioq_empty>:
ioq_empty():
/work/x86_os_my/device/ioqueue.c:25

/* 判断队列是否已空 */
static bool ioq_empty(struct ioqueue* ioq) {
c000407a:	55                   	push   %ebp
c000407b:	89 e5                	mov    %esp,%ebp
c000407d:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:26
   ASSERT(intr_get_status() == INTR_OFF);
c0004080:	e8 59 d9 ff ff       	call   c00019de <intr_get_status>
c0004085:	85 c0                	test   %eax,%eax
c0004087:	74 19                	je     c00040a2 <ioq_empty+0x28>
/work/x86_os_my/device/ioqueue.c:26 (discriminator 1)
c0004089:	68 c8 52 00 c0       	push   $0xc00052c8
c000408e:	68 38 53 00 c0       	push   $0xc0005338
c0004093:	6a 1a                	push   $0x1a
c0004095:	68 e6 52 00 c0       	push   $0xc00052e6
c000409a:	e8 03 e2 ff ff       	call   c00022a2 <panic_spin>
c000409f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:27
   return ioq->head == ioq->tail;
c00040a2:	8b 45 08             	mov    0x8(%ebp),%eax
c00040a5:	8b 50 64             	mov    0x64(%eax),%edx
c00040a8:	8b 45 08             	mov    0x8(%ebp),%eax
c00040ab:	8b 40 68             	mov    0x68(%eax),%eax
c00040ae:	39 c2                	cmp    %eax,%edx
c00040b0:	0f 94 c0             	sete   %al
c00040b3:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:28
}
c00040b6:	c9                   	leave  
c00040b7:	c3                   	ret    

c00040b8 <ioq_wait>:
ioq_wait():
/work/x86_os_my/device/ioqueue.c:31

/* 使当前生产者或消费者在此缓冲区上等待 */
static void ioq_wait(struct task_struct** waiter) {
c00040b8:	55                   	push   %ebp
c00040b9:	89 e5                	mov    %esp,%ebp
c00040bb:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:32
   ASSERT(*waiter == NULL && waiter != NULL);
c00040be:	8b 45 08             	mov    0x8(%ebp),%eax
c00040c1:	8b 00                	mov    (%eax),%eax
c00040c3:	85 c0                	test   %eax,%eax
c00040c5:	75 06                	jne    c00040cd <ioq_wait+0x15>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 1)
c00040c7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00040cb:	75 19                	jne    c00040e6 <ioq_wait+0x2e>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 3)
c00040cd:	68 f8 52 00 c0       	push   $0xc00052f8
c00040d2:	68 44 53 00 c0       	push   $0xc0005344
c00040d7:	6a 20                	push   $0x20
c00040d9:	68 e6 52 00 c0       	push   $0xc00052e6
c00040de:	e8 bf e1 ff ff       	call   c00022a2 <panic_spin>
c00040e3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:33
   *waiter = running_thread();
c00040e6:	e8 af f0 ff ff       	call   c000319a <running_thread>
c00040eb:	89 c2                	mov    %eax,%edx
c00040ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00040f0:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ioqueue.c:34
   thread_block(TASK_BLOCKED);
c00040f2:	83 ec 0c             	sub    $0xc,%esp
c00040f5:	6a 02                	push   $0x2
c00040f7:	e8 57 f4 ff ff       	call   c0003553 <thread_block>
c00040fc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:35
}
c00040ff:	90                   	nop
c0004100:	c9                   	leave  
c0004101:	c3                   	ret    

c0004102 <wakeup>:
wakeup():
/work/x86_os_my/device/ioqueue.c:38

/* 唤醒waiter */
static void wakeup(struct task_struct** waiter) {
c0004102:	55                   	push   %ebp
c0004103:	89 e5                	mov    %esp,%ebp
c0004105:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:39
   ASSERT(*waiter != NULL);
c0004108:	8b 45 08             	mov    0x8(%ebp),%eax
c000410b:	8b 00                	mov    (%eax),%eax
c000410d:	85 c0                	test   %eax,%eax
c000410f:	75 19                	jne    c000412a <wakeup+0x28>
/work/x86_os_my/device/ioqueue.c:39 (discriminator 1)
c0004111:	68 1a 53 00 c0       	push   $0xc000531a
c0004116:	68 50 53 00 c0       	push   $0xc0005350
c000411b:	6a 27                	push   $0x27
c000411d:	68 e6 52 00 c0       	push   $0xc00052e6
c0004122:	e8 7b e1 ff ff       	call   c00022a2 <panic_spin>
c0004127:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:40
   thread_unblock(*waiter); 
c000412a:	8b 45 08             	mov    0x8(%ebp),%eax
c000412d:	8b 00                	mov    (%eax),%eax
c000412f:	83 ec 0c             	sub    $0xc,%esp
c0004132:	50                   	push   %eax
c0004133:	e8 7e f4 ff ff       	call   c00035b6 <thread_unblock>
c0004138:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:41
   *waiter = NULL;
c000413b:	8b 45 08             	mov    0x8(%ebp),%eax
c000413e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/device/ioqueue.c:42
}
c0004144:	90                   	nop
c0004145:	c9                   	leave  
c0004146:	c3                   	ret    

c0004147 <ioq_getchar>:
ioq_getchar():
/work/x86_os_my/device/ioqueue.c:45

/* 消费者从ioq队列中获取一个字符 */
char ioq_getchar(struct ioqueue* ioq) {
c0004147:	55                   	push   %ebp
c0004148:	89 e5                	mov    %esp,%ebp
c000414a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ioqueue.c:46
   ASSERT(intr_get_status() == INTR_OFF);
c000414d:	e8 8c d8 ff ff       	call   c00019de <intr_get_status>
c0004152:	85 c0                	test   %eax,%eax
c0004154:	74 4b                	je     c00041a1 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:46 (discriminator 1)
c0004156:	68 c8 52 00 c0       	push   $0xc00052c8
c000415b:	68 58 53 00 c0       	push   $0xc0005358
c0004160:	6a 2e                	push   $0x2e
c0004162:	68 e6 52 00 c0       	push   $0xc00052e6
c0004167:	e8 36 e1 ff ff       	call   c00022a2 <panic_spin>
c000416c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51 (discriminator 1)

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c000416f:	eb 30                	jmp    c00041a1 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:52
      lock_acquire(&ioq->lock);	 
c0004171:	8b 45 08             	mov    0x8(%ebp),%eax
c0004174:	83 ec 0c             	sub    $0xc,%esp
c0004177:	50                   	push   %eax
c0004178:	e8 42 fa ff ff       	call   c0003bbf <lock_acquire>
c000417d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:53
      ioq_wait(&ioq->consumer);
c0004180:	8b 45 08             	mov    0x8(%ebp),%eax
c0004183:	83 c0 20             	add    $0x20,%eax
c0004186:	83 ec 0c             	sub    $0xc,%esp
c0004189:	50                   	push   %eax
c000418a:	e8 29 ff ff ff       	call   c00040b8 <ioq_wait>
c000418f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:54
      lock_release(&ioq->lock);
c0004192:	8b 45 08             	mov    0x8(%ebp),%eax
c0004195:	83 ec 0c             	sub    $0xc,%esp
c0004198:	50                   	push   %eax
c0004199:	e8 98 fa ff ff       	call   c0003c36 <lock_release>
c000419e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c00041a1:	83 ec 0c             	sub    $0xc,%esp
c00041a4:	ff 75 08             	pushl  0x8(%ebp)
c00041a7:	e8 ce fe ff ff       	call   c000407a <ioq_empty>
c00041ac:	83 c4 10             	add    $0x10,%esp
c00041af:	85 c0                	test   %eax,%eax
c00041b1:	75 be                	jne    c0004171 <ioq_getchar+0x2a>
/work/x86_os_my/device/ioqueue.c:57
      lock_acquire(&ioq->lock);	 
      ioq_wait(&ioq->consumer);
      lock_release(&ioq->lock);
   }

   char byte = ioq->buf[ioq->tail];	  // 从缓冲区中取出
c00041b3:	8b 45 08             	mov    0x8(%ebp),%eax
c00041b6:	8b 40 68             	mov    0x68(%eax),%eax
c00041b9:	8b 55 08             	mov    0x8(%ebp),%edx
c00041bc:	0f b6 44 02 24       	movzbl 0x24(%edx,%eax,1),%eax
c00041c1:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ioqueue.c:58
   ioq->tail = next_pos(ioq->tail);	  // 把读游标移到下一位置
c00041c4:	8b 45 08             	mov    0x8(%ebp),%eax
c00041c7:	8b 40 68             	mov    0x68(%eax),%eax
c00041ca:	83 ec 0c             	sub    $0xc,%esp
c00041cd:	50                   	push   %eax
c00041ce:	e8 3f fe ff ff       	call   c0004012 <next_pos>
c00041d3:	83 c4 10             	add    $0x10,%esp
c00041d6:	89 c2                	mov    %eax,%edx
c00041d8:	8b 45 08             	mov    0x8(%ebp),%eax
c00041db:	89 50 68             	mov    %edx,0x68(%eax)
/work/x86_os_my/device/ioqueue.c:60

   if (ioq->producer != NULL) {
c00041de:	8b 45 08             	mov    0x8(%ebp),%eax
c00041e1:	8b 40 1c             	mov    0x1c(%eax),%eax
c00041e4:	85 c0                	test   %eax,%eax
c00041e6:	74 12                	je     c00041fa <ioq_getchar+0xb3>
/work/x86_os_my/device/ioqueue.c:61
      wakeup(&ioq->producer);		  // 唤醒生产者
c00041e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00041eb:	83 c0 1c             	add    $0x1c,%eax
c00041ee:	83 ec 0c             	sub    $0xc,%esp
c00041f1:	50                   	push   %eax
c00041f2:	e8 0b ff ff ff       	call   c0004102 <wakeup>
c00041f7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:64
   }

   return byte; 
c00041fa:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
/work/x86_os_my/device/ioqueue.c:65
}
c00041fe:	c9                   	leave  
c00041ff:	c3                   	ret    

c0004200 <ioq_putchar>:
ioq_putchar():
/work/x86_os_my/device/ioqueue.c:68

/* 生产者往ioq队列中写入一个字符byte */
void ioq_putchar(struct ioqueue* ioq, char byte) {
c0004200:	55                   	push   %ebp
c0004201:	89 e5                	mov    %esp,%ebp
c0004203:	83 ec 18             	sub    $0x18,%esp
c0004206:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004209:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/ioqueue.c:69
   ASSERT(intr_get_status() == INTR_OFF);
c000420c:	e8 cd d7 ff ff       	call   c00019de <intr_get_status>
c0004211:	85 c0                	test   %eax,%eax
c0004213:	74 4b                	je     c0004260 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:69 (discriminator 1)
c0004215:	68 c8 52 00 c0       	push   $0xc00052c8
c000421a:	68 64 53 00 c0       	push   $0xc0005364
c000421f:	6a 45                	push   $0x45
c0004221:	68 e6 52 00 c0       	push   $0xc00052e6
c0004226:	e8 77 e0 ff ff       	call   c00022a2 <panic_spin>
c000422b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74 (discriminator 1)

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c000422e:	eb 30                	jmp    c0004260 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:75
      lock_acquire(&ioq->lock);
c0004230:	8b 45 08             	mov    0x8(%ebp),%eax
c0004233:	83 ec 0c             	sub    $0xc,%esp
c0004236:	50                   	push   %eax
c0004237:	e8 83 f9 ff ff       	call   c0003bbf <lock_acquire>
c000423c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:76
      ioq_wait(&ioq->producer);
c000423f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004242:	83 c0 1c             	add    $0x1c,%eax
c0004245:	83 ec 0c             	sub    $0xc,%esp
c0004248:	50                   	push   %eax
c0004249:	e8 6a fe ff ff       	call   c00040b8 <ioq_wait>
c000424e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:77
      lock_release(&ioq->lock);
c0004251:	8b 45 08             	mov    0x8(%ebp),%eax
c0004254:	83 ec 0c             	sub    $0xc,%esp
c0004257:	50                   	push   %eax
c0004258:	e8 d9 f9 ff ff       	call   c0003c36 <lock_release>
c000425d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c0004260:	83 ec 0c             	sub    $0xc,%esp
c0004263:	ff 75 08             	pushl  0x8(%ebp)
c0004266:	e8 c3 fd ff ff       	call   c000402e <ioq_full>
c000426b:	83 c4 10             	add    $0x10,%esp
c000426e:	85 c0                	test   %eax,%eax
c0004270:	75 be                	jne    c0004230 <ioq_putchar+0x30>
/work/x86_os_my/device/ioqueue.c:79
      lock_acquire(&ioq->lock);
      ioq_wait(&ioq->producer);
      lock_release(&ioq->lock);
   }
   ioq->buf[ioq->head] = byte;      // 把字节放入缓冲区中
c0004272:	8b 45 08             	mov    0x8(%ebp),%eax
c0004275:	8b 40 64             	mov    0x64(%eax),%eax
c0004278:	8b 55 08             	mov    0x8(%ebp),%edx
c000427b:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
c000427f:	88 4c 02 24          	mov    %cl,0x24(%edx,%eax,1)
/work/x86_os_my/device/ioqueue.c:80
   ioq->head = next_pos(ioq->head); // 把写游标移到下一位置
c0004283:	8b 45 08             	mov    0x8(%ebp),%eax
c0004286:	8b 40 64             	mov    0x64(%eax),%eax
c0004289:	83 ec 0c             	sub    $0xc,%esp
c000428c:	50                   	push   %eax
c000428d:	e8 80 fd ff ff       	call   c0004012 <next_pos>
c0004292:	83 c4 10             	add    $0x10,%esp
c0004295:	89 c2                	mov    %eax,%edx
c0004297:	8b 45 08             	mov    0x8(%ebp),%eax
c000429a:	89 50 64             	mov    %edx,0x64(%eax)
/work/x86_os_my/device/ioqueue.c:82

   if (ioq->consumer != NULL) {
c000429d:	8b 45 08             	mov    0x8(%ebp),%eax
c00042a0:	8b 40 20             	mov    0x20(%eax),%eax
c00042a3:	85 c0                	test   %eax,%eax
c00042a5:	74 12                	je     c00042b9 <ioq_putchar+0xb9>
/work/x86_os_my/device/ioqueue.c:83
      wakeup(&ioq->consumer);          // 唤醒消费者
c00042a7:	8b 45 08             	mov    0x8(%ebp),%eax
c00042aa:	83 c0 20             	add    $0x20,%eax
c00042ad:	83 ec 0c             	sub    $0xc,%esp
c00042b0:	50                   	push   %eax
c00042b1:	e8 4c fe ff ff       	call   c0004102 <wakeup>
c00042b6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:85
   }
}
c00042b9:	90                   	nop
c00042ba:	c9                   	leave  
c00042bb:	c3                   	ret    

c00042bc <update_tss_esp>:
update_tss_esp():
/work/x86_os_my/userprog/tss.c:40
	uint32_t io_base;
}; 
static struct tss g_tss;

/* 更新tss中esp0字段的值为pthread的0级栈 */
void update_tss_esp(struct task_struct* pthread) {
c00042bc:	55                   	push   %ebp
c00042bd:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/userprog/tss.c:41
	g_tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c00042bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00042c2:	05 00 10 00 00       	add    $0x1000,%eax
c00042c7:	a3 a4 74 00 c0       	mov    %eax,0xc00074a4
/work/x86_os_my/userprog/tss.c:42
}
c00042cc:	90                   	nop
c00042cd:	5d                   	pop    %ebp
c00042ce:	c3                   	ret    

c00042cf <make_gdt_desc>:
make_gdt_desc():
/work/x86_os_my/userprog/tss.c:45

/* c语言方式，创建gdt描述符 */
static struct gdt_desc make_gdt_desc(uint32_t* desc_addr, uint32_t limit, uint8_t attr_low, uint8_t attr_high) {
c00042cf:	55                   	push   %ebp
c00042d0:	89 e5                	mov    %esp,%ebp
c00042d2:	83 ec 18             	sub    $0x18,%esp
c00042d5:	8b 55 14             	mov    0x14(%ebp),%edx
c00042d8:	8b 45 18             	mov    0x18(%ebp),%eax
c00042db:	88 55 ec             	mov    %dl,-0x14(%ebp)
c00042de:	88 45 e8             	mov    %al,-0x18(%ebp)
/work/x86_os_my/userprog/tss.c:46
	uint32_t desc_base = (uint32_t)desc_addr;
c00042e1:	8b 45 0c             	mov    0xc(%ebp),%eax
c00042e4:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/userprog/tss.c:48
	struct gdt_desc desc;
	desc.limit_low_word = limit & 0x0000ffff;
c00042e7:	8b 45 10             	mov    0x10(%ebp),%eax
c00042ea:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/userprog/tss.c:49
	desc.base_low_word = desc_base & 0x0000ffff;
c00042ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00042f1:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/userprog/tss.c:50
	desc.base_mid_byte = ((desc_base & 0x00ff0000) >> 16);
c00042f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00042f8:	25 00 00 ff 00       	and    $0xff0000,%eax
c00042fd:	c1 e8 10             	shr    $0x10,%eax
c0004300:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/userprog/tss.c:51
	desc.attr_low_byte = (uint8_t)(attr_low);
c0004303:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0004307:	88 45 f9             	mov    %al,-0x7(%ebp)
/work/x86_os_my/userprog/tss.c:52
	desc.limit_high_attr_high = (((limit & 0x000f0000) >> 16) + (uint8_t)(attr_high));
c000430a:	8b 45 10             	mov    0x10(%ebp),%eax
c000430d:	25 00 00 0f 00       	and    $0xf0000,%eax
c0004312:	c1 e8 10             	shr    $0x10,%eax
c0004315:	89 c2                	mov    %eax,%edx
c0004317:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c000431b:	01 d0                	add    %edx,%eax
c000431d:	88 45 fa             	mov    %al,-0x6(%ebp)
/work/x86_os_my/userprog/tss.c:53
	desc.base_high_byte = desc_base >> 24;
c0004320:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004323:	c1 e8 18             	shr    $0x18,%eax
c0004326:	88 45 fb             	mov    %al,-0x5(%ebp)
/work/x86_os_my/userprog/tss.c:54
	return desc;
c0004329:	8b 4d 08             	mov    0x8(%ebp),%ecx
c000432c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000432f:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0004332:	89 01                	mov    %eax,(%ecx)
c0004334:	89 51 04             	mov    %edx,0x4(%ecx)
/work/x86_os_my/userprog/tss.c:55
}
c0004337:	8b 45 08             	mov    0x8(%ebp),%eax
c000433a:	c9                   	leave  
c000433b:	c2 04 00             	ret    $0x4

c000433e <tss_init>:
tss_init():
/work/x86_os_my/userprog/tss.c:61

/* 在gdt中创建tss描述符
 * 重新加载 gdt
 * 加载 tr
 */
void tss_init() {
c000433e:	55                   	push   %ebp
c000433f:	89 e5                	mov    %esp,%ebp
c0004341:	53                   	push   %ebx
c0004342:	83 ec 24             	sub    $0x24,%esp
/work/x86_os_my/userprog/tss.c:62
	put_str("tss_init start\n");
c0004345:	83 ec 0c             	sub    $0xc,%esp
c0004348:	68 70 53 00 c0       	push   $0xc0005370
c000434d:	e8 de dd ff ff       	call   c0002130 <put_str>
c0004352:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:63
	uint32_t tss_size = sizeof(g_tss);
c0004355:	c7 45 f4 6c 00 00 00 	movl   $0x6c,-0xc(%ebp)
/work/x86_os_my/userprog/tss.c:64
	memset(&g_tss, 0, tss_size);
c000435c:	83 ec 04             	sub    $0x4,%esp
c000435f:	ff 75 f4             	pushl  -0xc(%ebp)
c0004362:	6a 00                	push   $0x0
c0004364:	68 a0 74 00 c0       	push   $0xc00074a0
c0004369:	e8 5c ea ff ff       	call   c0002dca <memset>
c000436e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:66
	
	g_tss.ss0 = SELECTOR_K_STACK;	// 0 级栈段的选择子 
c0004371:	c7 05 a8 74 00 c0 10 	movl   $0x10,0xc00074a8
c0004378:	00 00 00 
/work/x86_os_my/userprog/tss.c:67
	g_tss.io_base = tss_size;		// 当 IO 位图的偏移地址大于等于 TSS 大小减 1 时，就表示没有 IO 位图。
c000437b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000437e:	a3 08 75 00 c0       	mov    %eax,0xc0007508
/work/x86_os_my/userprog/tss.c:75
	 * 内核地址 0xC000_0900 是映射到 0x900 的 
	 * 在GDT中，第 0 个段描述符不可用，第 1 个为代码段，第 2 个为数据段和栈，第 3 个为显存段
	 */

	/* 在gdt中添加dpl为0的TSS描述符 */
	*((struct gdt_desc*)0xc0000920) = make_gdt_desc((uint32_t*)&g_tss, tss_size - 1, TSS_ATTR_LOW, TSS_ATTR_HIGH);
c0004383:	bb 20 09 00 c0       	mov    $0xc0000920,%ebx
c0004388:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000438b:	8d 50 ff             	lea    -0x1(%eax),%edx
c000438e:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0004391:	83 ec 0c             	sub    $0xc,%esp
c0004394:	68 80 00 00 00       	push   $0x80
c0004399:	68 89 00 00 00       	push   $0x89
c000439e:	52                   	push   %edx
c000439f:	68 a0 74 00 c0       	push   $0xc00074a0
c00043a4:	50                   	push   %eax
c00043a5:	e8 25 ff ff ff       	call   c00042cf <make_gdt_desc>
c00043aa:	83 c4 1c             	add    $0x1c,%esp
c00043ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00043b0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00043b3:	89 03                	mov    %eax,(%ebx)
c00043b5:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:78

	/* 在gdt中添加dpl为3的,用户级,数据段和代码段描述符 */
	*((struct gdt_desc*)0xc0000928) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
c00043b8:	bb 28 09 00 c0       	mov    $0xc0000928,%ebx
c00043bd:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00043c0:	83 ec 0c             	sub    $0xc,%esp
c00043c3:	68 c0 00 00 00       	push   $0xc0
c00043c8:	68 f8 00 00 00       	push   $0xf8
c00043cd:	68 ff ff 0f 00       	push   $0xfffff
c00043d2:	6a 00                	push   $0x0
c00043d4:	50                   	push   %eax
c00043d5:	e8 f5 fe ff ff       	call   c00042cf <make_gdt_desc>
c00043da:	83 c4 1c             	add    $0x1c,%esp
c00043dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00043e0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00043e3:	89 03                	mov    %eax,(%ebx)
c00043e5:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:79
	*((struct gdt_desc*)0xc0000930) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
c00043e8:	bb 30 09 00 c0       	mov    $0xc0000930,%ebx
c00043ed:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00043f0:	83 ec 0c             	sub    $0xc,%esp
c00043f3:	68 c0 00 00 00       	push   $0xc0
c00043f8:	68 f2 00 00 00       	push   $0xf2
c00043fd:	68 ff ff 0f 00       	push   $0xfffff
c0004402:	6a 00                	push   $0x0
c0004404:	50                   	push   %eax
c0004405:	e8 c5 fe ff ff       	call   c00042cf <make_gdt_desc>
c000440a:	83 c4 1c             	add    $0x1c,%esp
c000440d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0004410:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0004413:	89 03                	mov    %eax,(%ebx)
c0004415:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:83

	/* GDTR 16位的limit、32位的段基址 */
	// 先转换成 uint32_t 后，再将其转换成 uint64_t 位（不可一步到位转为 uint64_t）
	uint64_t gdt_operand = ((8 * 7 - 1) | ((uint64_t)(uint32_t)0xc0000900 << 16));   // 7个描述符大小
c0004418:	c7 45 e8 37 00 00 09 	movl   $0x9000037,-0x18(%ebp)
c000441f:	c7 45 ec 00 c0 00 00 	movl   $0xc000,-0x14(%ebp)
/work/x86_os_my/userprog/tss.c:84
	asm volatile ("lgdt %0" : : "m" (gdt_operand));
c0004426:	0f 01 55 e8          	lgdtl  -0x18(%ebp)
/work/x86_os_my/userprog/tss.c:85
	asm volatile ("ltr %w0" : : "r" (SELECTOR_TSS));
c000442a:	b8 20 00 00 00       	mov    $0x20,%eax
c000442f:	0f 00 d8             	ltr    %ax
/work/x86_os_my/userprog/tss.c:86
	put_str("tss_init and ltr done\n");
c0004432:	83 ec 0c             	sub    $0xc,%esp
c0004435:	68 80 53 00 c0       	push   $0xc0005380
c000443a:	e8 f1 dc ff ff       	call   c0002130 <put_str>
c000443f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:87
}
c0004442:	90                   	nop
c0004443:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0004446:	c9                   	leave  
c0004447:	c3                   	ret    

c0004448 <start_process>:
start_process():
/work/x86_os_my/userprog/process.c:17
extern void intr_exit(void);

/* 构建用户进程初始上下文信息
 * 填充用户进程的中断栈，并将中断栈的信息，利用iretd填充到 CPU 中
 */
void start_process(void* filename_) {
c0004448:	55                   	push   %ebp
c0004449:	89 e5                	mov    %esp,%ebp
c000444b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:18
	void* function = filename_;
c000444e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004451:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:19
	struct task_struct* cur = running_thread();
c0004454:	e8 41 ed ff ff       	call   c000319a <running_thread>
c0004459:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:20
	cur->self_kstack += sizeof(struct thread_stack);
c000445c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000445f:	8b 00                	mov    (%eax),%eax
c0004461:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
c0004467:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000446a:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/process.c:21
	struct intr_stack* proc_stack = (struct intr_stack*)cur->self_kstack;	 
c000446c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000446f:	8b 00                	mov    (%eax),%eax
c0004471:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/userprog/process.c:22
	proc_stack->edi = proc_stack->esi = proc_stack->ebp = proc_stack->esp_dummy = 0;
c0004474:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004477:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
c000447e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004481:	8b 50 10             	mov    0x10(%eax),%edx
c0004484:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004487:	89 50 0c             	mov    %edx,0xc(%eax)
c000448a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000448d:	8b 50 0c             	mov    0xc(%eax),%edx
c0004490:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004493:	89 50 08             	mov    %edx,0x8(%eax)
c0004496:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004499:	8b 50 08             	mov    0x8(%eax),%edx
c000449c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000449f:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/userprog/process.c:23
	proc_stack->ebx = proc_stack->edx = proc_stack->ecx = proc_stack->eax = 0;
c00044a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00044a5:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c00044ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00044af:	8b 50 20             	mov    0x20(%eax),%edx
c00044b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00044b5:	89 50 1c             	mov    %edx,0x1c(%eax)
c00044b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00044bb:	8b 50 1c             	mov    0x1c(%eax),%edx
c00044be:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00044c1:	89 50 18             	mov    %edx,0x18(%eax)
c00044c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00044c7:	8b 50 18             	mov    0x18(%eax),%edx
c00044ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00044cd:	89 50 14             	mov    %edx,0x14(%eax)
/work/x86_os_my/userprog/process.c:28
	/* 在iretd返回时，如果发现未来的 CPL（也就是内核栈中 CS.RPL，或者说是返回到的用户进程的代码段CS.CPL）
	 * 权限低于（数值上大于） CPU 中段寄存器（如 DS、 ES、 FS、 GS）中选择子指向的内存段的 DPL，
	 * CPU 会自动将相应段寄存器的选择子置为 0 
	 * 这里gs的选择子在iretd返回后，会被自动清零。*/
	proc_stack->gs = 0;					// 用户态用不上,直接初始为0
c00044d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00044d3:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
/work/x86_os_my/userprog/process.c:29
	proc_stack->ds = proc_stack->es = proc_stack->fs = SELECTOR_U_DATA;		// 用户级数据段
c00044da:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00044dd:	c7 40 28 33 00 00 00 	movl   $0x33,0x28(%eax)
c00044e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00044e7:	8b 50 28             	mov    0x28(%eax),%edx
c00044ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00044ed:	89 50 2c             	mov    %edx,0x2c(%eax)
c00044f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00044f3:	8b 50 2c             	mov    0x2c(%eax),%edx
c00044f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00044f9:	89 50 30             	mov    %edx,0x30(%eax)
/work/x86_os_my/userprog/process.c:30
	proc_stack->eip = function;			// 待执行的用户程序地址
c00044fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00044ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004502:	89 50 38             	mov    %edx,0x38(%eax)
/work/x86_os_my/userprog/process.c:31
	proc_stack->cs = SELECTOR_U_CODE;	// 用户级代码段
c0004505:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004508:	c7 40 3c 2b 00 00 00 	movl   $0x2b,0x3c(%eax)
/work/x86_os_my/userprog/process.c:32
	proc_stack->eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);
c000450f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004512:	c7 40 40 02 02 00 00 	movl   $0x202,0x40(%eax)
/work/x86_os_my/userprog/process.c:41
	 * process_activate 使用户进程页表生效【已经把CR3寄存器 更新为 用户进程的页表了】
	 * start_process    为用户进程创建3特权级栈【所以申请的内存空间来自用户进程的页表】
	 * 
	 * USER_STACK3_VADDR=(0xc0000000 - 0x1000)
	 */
	proc_stack->esp = (void*)((uint32_t)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE) ;
c0004519:	83 ec 08             	sub    $0x8,%esp
c000451c:	68 00 f0 ff bf       	push   $0xbffff000
c0004521:	6a 02                	push   $0x2
c0004523:	e8 d8 e4 ff ff       	call   c0002a00 <get_a_page>
c0004528:	83 c4 10             	add    $0x10,%esp
c000452b:	05 00 10 00 00       	add    $0x1000,%eax
c0004530:	89 c2                	mov    %eax,%edx
c0004532:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004535:	89 50 44             	mov    %edx,0x44(%eax)
/work/x86_os_my/userprog/process.c:42
	proc_stack->ss = SELECTOR_U_DATA;
c0004538:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000453b:	c7 40 48 33 00 00 00 	movl   $0x33,0x48(%eax)
/work/x86_os_my/userprog/process.c:49
	/* 将 esp 替换为 proc_stack
	 * 通过 jmp intr_exit 那里的一系列 pop 指令和 iretd 指令，
	 * 将 proc_stack 中的数据载入 CPU 的寄存器，
	 * 从而使程序“假装”退出中断，进入特权级 3
	 */
	asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (proc_stack) : "memory");
c0004542:	8b 65 ec             	mov    -0x14(%ebp),%esp
c0004545:	e9 a6 d6 ff ff       	jmp    c0001bf0 <intr_exit>
/work/x86_os_my/userprog/process.c:50
}
c000454a:	90                   	nop
c000454b:	c9                   	leave  
c000454c:	c3                   	ret    

c000454d <page_dir_activate>:
page_dir_activate():
/work/x86_os_my/userprog/process.c:53

/* 更新CR3寄存器，激活页目录表 */
void page_dir_activate(struct task_struct* p_thread) {
c000454d:	55                   	push   %ebp
c000454e:	89 e5                	mov    %esp,%ebp
c0004550:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:56
	
	/* 若为"内核线程",需要重新填充页表为0x100000 */
	uint32_t pagedir_phy_addr = 0x100000;	// 默认为内核的页目录物理地址,也就是内核线程所用的页目录表
c0004553:	c7 45 f4 00 00 10 00 	movl   $0x100000,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:59
	
	/* "用户态进程"有自己的页目录表 */
	if (p_thread->pgdir != NULL) {
c000455a:	8b 45 08             	mov    0x8(%ebp),%eax
c000455d:	8b 40 30             	mov    0x30(%eax),%eax
c0004560:	85 c0                	test   %eax,%eax
c0004562:	74 15                	je     c0004579 <page_dir_activate+0x2c>
/work/x86_os_my/userprog/process.c:60
		pagedir_phy_addr = addr_v2p((uint32_t)p_thread->pgdir);
c0004564:	8b 45 08             	mov    0x8(%ebp),%eax
c0004567:	8b 40 30             	mov    0x30(%eax),%eax
c000456a:	83 ec 0c             	sub    $0xc,%esp
c000456d:	50                   	push   %eax
c000456e:	e8 eb e5 ff ff       	call   c0002b5e <addr_v2p>
c0004573:	83 c4 10             	add    $0x10,%esp
c0004576:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:66
	}

	/* 更新页目录寄存器cr3,使新页表生效
	 * 实现进程间，虚拟地址空间的隔离。
	 */
	asm volatile ("movl %0, %%cr3" : : "r" (pagedir_phy_addr) : "memory");
c0004579:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000457c:	0f 22 d8             	mov    %eax,%cr3
/work/x86_os_my/userprog/process.c:67
}
c000457f:	90                   	nop
c0004580:	c9                   	leave  
c0004581:	c3                   	ret    

c0004582 <process_activate>:
process_activate():
/work/x86_os_my/userprog/process.c:73

/* 1.激活线程或进程的页表,【更新CR3寄存器】
 * 2.用户进程，更新tss中的esp0为进程的特权级0的栈
 * 【只有在任务调度时（中断时），才会切换页表及更新 0 级栈，因此 process_activate 是被"中断执行流"的 schedule 调用的！】
 */
void process_activate(struct task_struct* p_thread) {
c0004582:	55                   	push   %ebp
c0004583:	89 e5                	mov    %esp,%ebp
c0004585:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/process.c:74
	ASSERT(p_thread != NULL);
c0004588:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000458c:	75 19                	jne    c00045a7 <process_activate+0x25>
/work/x86_os_my/userprog/process.c:74 (discriminator 1)
c000458e:	68 98 53 00 c0       	push   $0xc0005398
c0004593:	68 54 54 00 c0       	push   $0xc0005454
c0004598:	6a 4a                	push   $0x4a
c000459a:	68 a9 53 00 c0       	push   $0xc00053a9
c000459f:	e8 fe dc ff ff       	call   c00022a2 <panic_spin>
c00045a4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:77
	
	/* 激活该进程或线程的页目录表【重新加载了CR3】 */
	page_dir_activate(p_thread);
c00045a7:	83 ec 0c             	sub    $0xc,%esp
c00045aa:	ff 75 08             	pushl  0x8(%ebp)
c00045ad:	e8 9b ff ff ff       	call   c000454d <page_dir_activate>
c00045b2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:80

	/* 内核线程特权级本身就是0,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */
	if (p_thread->pgdir != NULL) {
c00045b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00045b8:	8b 40 30             	mov    0x30(%eax),%eax
c00045bb:	85 c0                	test   %eax,%eax
c00045bd:	74 0e                	je     c00045cd <process_activate+0x4b>
/work/x86_os_my/userprog/process.c:83
		/* 若为用户进程,更新该进程的esp0,用于此进程被中断时保留上下文 
		 * 需要从tss中获取0特权级栈地址 */
		update_tss_esp(p_thread);	//就一行：g_tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c00045bf:	83 ec 0c             	sub    $0xc,%esp
c00045c2:	ff 75 08             	pushl  0x8(%ebp)
c00045c5:	e8 f2 fc ff ff       	call   c00042bc <update_tss_esp>
c00045ca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:85
	}
}
c00045cd:	90                   	nop
c00045ce:	c9                   	leave  
c00045cf:	c3                   	ret    

c00045d0 <create_page_dir>:
create_page_dir():
/work/x86_os_my/userprog/process.c:94
 * 
 * 要确保用户进程，在自己的地址空间中，能够访问到内核。
 * 即：任意进程的页目录表中，用户进程占第 0~767 个页目录项，内核占第 768~1023 个页目录项。
 * 0x300 = 768
 */
uint32_t* create_page_dir(void) {
c00045d0:	55                   	push   %ebp
c00045d1:	89 e5                	mov    %esp,%ebp
c00045d3:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:97

	/* 用户进程的页表不能让用户直接访问到,所以在内核空间来申请 */
	uint32_t* page_dir_vaddr = get_kernel_pages(1);
c00045d6:	83 ec 0c             	sub    $0xc,%esp
c00045d9:	6a 01                	push   $0x1
c00045db:	e8 6a e3 ff ff       	call   c000294a <get_kernel_pages>
c00045e0:	83 c4 10             	add    $0x10,%esp
c00045e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:98
	if (page_dir_vaddr == NULL) {
c00045e6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00045ea:	75 17                	jne    c0004603 <create_page_dir+0x33>
/work/x86_os_my/userprog/process.c:99
		console_put_str("create_page_dir: get_kernel_page failed!");
c00045ec:	83 ec 0c             	sub    $0xc,%esp
c00045ef:	68 bc 53 00 c0       	push   $0xc00053bc
c00045f4:	e8 57 f3 ff ff       	call   c0003950 <console_put_str>
c00045f9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:100
		return NULL;
c00045fc:	b8 00 00 00 00       	mov    $0x0,%eax
c0004601:	eb 43                	jmp    c0004646 <create_page_dir+0x76>
/work/x86_os_my/userprog/process.c:106
	}

	/*** 1 复制内核的页目录表  ***/
	// page_dir_vaddr + 0x300*4 是内核页目录的第768项
	// 复制的页目录项个数=1024/4
	memcpy((uint32_t*)((uint32_t)page_dir_vaddr + 0x300*4), (uint32_t*)(0xfffff000+0x300*4), 1024);
c0004603:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004606:	05 00 0c 00 00       	add    $0xc00,%eax
c000460b:	83 ec 04             	sub    $0x4,%esp
c000460e:	68 00 04 00 00       	push   $0x400
c0004613:	68 00 fc ff ff       	push   $0xfffffc00
c0004618:	50                   	push   %eax
c0004619:	e8 fe e7 ff ff       	call   c0002e1c <memcpy>
c000461e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:110

	/*** 2 更新页目录表地址 ***/
	// 页目录表地址是页目录的最后一项
	uint32_t new_page_dir_phy_addr = addr_v2p((uint32_t)page_dir_vaddr);
c0004621:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004624:	83 ec 0c             	sub    $0xc,%esp
c0004627:	50                   	push   %eax
c0004628:	e8 31 e5 ff ff       	call   c0002b5e <addr_v2p>
c000462d:	83 c4 10             	add    $0x10,%esp
c0004630:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:111
	page_dir_vaddr[1023] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1;
c0004633:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004636:	05 fc 0f 00 00       	add    $0xffc,%eax
c000463b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000463e:	83 ca 07             	or     $0x7,%edx
c0004641:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/process.c:113

	return page_dir_vaddr;
c0004643:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/userprog/process.c:114
}
c0004646:	c9                   	leave  
c0004647:	c3                   	ret    

c0004648 <create_user_vaddr_bitmap>:
create_user_vaddr_bitmap():
/work/x86_os_my/userprog/process.c:117

/* 创建用户进程虚拟地址位图 */
void create_user_vaddr_bitmap(struct task_struct* user_prog) {
c0004648:	55                   	push   %ebp
c0004649:	89 e5                	mov    %esp,%ebp
c000464b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:118
   user_prog->userprog_vaddr.vaddr_start = USER_VADDR_START;	// linux用户程序入口地址 0x80480000
c000464e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004651:	c7 40 3c 00 80 04 08 	movl   $0x8048000,0x3c(%eax)
/work/x86_os_my/userprog/process.c:119
   uint32_t bitmap_pg_cnt = DIV_ROUND_UP((0xc0000000 - USER_VADDR_START) / PG_SIZE / 8 , PG_SIZE);
c0004658:	c7 45 f4 17 00 00 00 	movl   $0x17,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:120
   user_prog->userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt);
c000465f:	83 ec 0c             	sub    $0xc,%esp
c0004662:	ff 75 f4             	pushl  -0xc(%ebp)
c0004665:	e8 e0 e2 ff ff       	call   c000294a <get_kernel_pages>
c000466a:	83 c4 10             	add    $0x10,%esp
c000466d:	89 c2                	mov    %eax,%edx
c000466f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004672:	89 50 38             	mov    %edx,0x38(%eax)
/work/x86_os_my/userprog/process.c:121
   user_prog->userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (0xc0000000 - USER_VADDR_START) / PG_SIZE / 8;
c0004675:	8b 45 08             	mov    0x8(%ebp),%eax
c0004678:	c7 40 34 f7 6f 01 00 	movl   $0x16ff7,0x34(%eax)
/work/x86_os_my/userprog/process.c:122
   bitmap_init(&user_prog->userprog_vaddr.vaddr_bitmap);
c000467f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004682:	83 c0 34             	add    $0x34,%eax
c0004685:	83 ec 0c             	sub    $0xc,%esp
c0004688:	50                   	push   %eax
c0004689:	e8 ea dc ff ff       	call   c0002378 <bitmap_init>
c000468e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:123
}
c0004691:	90                   	nop
c0004692:	c9                   	leave  
c0004693:	c3                   	ret    

c0004694 <process_execute>:
process_execute():
/work/x86_os_my/userprog/process.c:126

/* 创建用户进程 */
void process_execute(void* filename, char* name) {
c0004694:	55                   	push   %ebp
c0004695:	89 e5                	mov    %esp,%ebp
c0004697:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:128
   /* pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 */
   struct task_struct* thread = get_kernel_pages(1);
c000469a:	83 ec 0c             	sub    $0xc,%esp
c000469d:	6a 01                	push   $0x1
c000469f:	e8 a6 e2 ff ff       	call   c000294a <get_kernel_pages>
c00046a4:	83 c4 10             	add    $0x10,%esp
c00046a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:129
   init_thread(thread, name, default_prio);			//初始化线程PCB结构体 struct task_struct
c00046aa:	83 ec 04             	sub    $0x4,%esp
c00046ad:	6a 1f                	push   $0x1f
c00046af:	ff 75 0c             	pushl  0xc(%ebp)
c00046b2:	ff 75 f4             	pushl  -0xc(%ebp)
c00046b5:	e8 88 eb ff ff       	call   c0003242 <init_thread>
c00046ba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:130
   create_user_vaddr_bitmap(thread);				//【进程新增】创建用户进程，虚拟地址空间位图
c00046bd:	83 ec 0c             	sub    $0xc,%esp
c00046c0:	ff 75 f4             	pushl  -0xc(%ebp)
c00046c3:	e8 80 ff ff ff       	call   c0004648 <create_user_vaddr_bitmap>
c00046c8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:131
   thread_create(thread, start_process, filename);	//初始化线程栈结构体 struct thread_stack
c00046cb:	83 ec 04             	sub    $0x4,%esp
c00046ce:	ff 75 08             	pushl  0x8(%ebp)
c00046d1:	68 48 44 00 c0       	push   $0xc0004448
c00046d6:	ff 75 f4             	pushl  -0xc(%ebp)
c00046d9:	e8 ed ea ff ff       	call   c00031cb <thread_create>
c00046de:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:132
   thread->pgdir = create_page_dir();				//【进程新增】创建用户进程，页目录表
c00046e1:	e8 ea fe ff ff       	call   c00045d0 <create_page_dir>
c00046e6:	89 c2                	mov    %eax,%edx
c00046e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00046eb:	89 50 30             	mov    %edx,0x30(%eax)
/work/x86_os_my/userprog/process.c:134
   
   enum intr_status old_status = intr_disable();
c00046ee:	e8 a4 d2 ff ff       	call   c0001997 <intr_disable>
c00046f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:135
   ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));
c00046f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00046f9:	83 c0 20             	add    $0x20,%eax
c00046fc:	83 ec 08             	sub    $0x8,%esp
c00046ff:	50                   	push   %eax
c0004700:	68 2c 77 00 c0       	push   $0xc000772c
c0004705:	e8 ff f0 ff ff       	call   c0003809 <elem_find>
c000470a:	83 c4 10             	add    $0x10,%esp
c000470d:	85 c0                	test   %eax,%eax
c000470f:	74 1c                	je     c000472d <process_execute+0x99>
/work/x86_os_my/userprog/process.c:135 (discriminator 1)
c0004711:	68 e8 53 00 c0       	push   $0xc00053e8
c0004716:	68 68 54 00 c0       	push   $0xc0005468
c000471b:	68 87 00 00 00       	push   $0x87
c0004720:	68 a9 53 00 c0       	push   $0xc00053a9
c0004725:	e8 78 db ff ff       	call   c00022a2 <panic_spin>
c000472a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:136
   list_append(&thread_ready_list, &thread->general_tag);
c000472d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004730:	83 c0 20             	add    $0x20,%eax
c0004733:	83 ec 08             	sub    $0x8,%esp
c0004736:	50                   	push   %eax
c0004737:	68 2c 77 00 c0       	push   $0xc000772c
c000473c:	e8 4e f0 ff ff       	call   c000378f <list_append>
c0004741:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:137
   ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
c0004744:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004747:	83 c0 28             	add    $0x28,%eax
c000474a:	83 ec 08             	sub    $0x8,%esp
c000474d:	50                   	push   %eax
c000474e:	68 3c 77 00 c0       	push   $0xc000773c
c0004753:	e8 b1 f0 ff ff       	call   c0003809 <elem_find>
c0004758:	83 c4 10             	add    $0x10,%esp
c000475b:	85 c0                	test   %eax,%eax
c000475d:	74 1c                	je     c000477b <process_execute+0xe7>
/work/x86_os_my/userprog/process.c:137 (discriminator 1)
c000475f:	68 20 54 00 c0       	push   $0xc0005420
c0004764:	68 68 54 00 c0       	push   $0xc0005468
c0004769:	68 89 00 00 00       	push   $0x89
c000476e:	68 a9 53 00 c0       	push   $0xc00053a9
c0004773:	e8 2a db ff ff       	call   c00022a2 <panic_spin>
c0004778:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:138
   list_append(&thread_all_list, &thread->all_list_tag);
c000477b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000477e:	83 c0 28             	add    $0x28,%eax
c0004781:	83 ec 08             	sub    $0x8,%esp
c0004784:	50                   	push   %eax
c0004785:	68 3c 77 00 c0       	push   $0xc000773c
c000478a:	e8 00 f0 ff ff       	call   c000378f <list_append>
c000478f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:139
   intr_set_status(old_status);
c0004792:	83 ec 0c             	sub    $0xc,%esp
c0004795:	ff 75 f0             	pushl  -0x10(%ebp)
c0004798:	e8 23 d2 ff ff       	call   c00019c0 <intr_set_status>
c000479d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:140
}
c00047a0:	90                   	nop
c00047a1:	c9                   	leave  
c00047a2:	c3                   	ret    
