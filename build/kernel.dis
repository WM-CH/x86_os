
./build/kernel.bin:     file format elf32-i386


Disassembly of section .text:

c0001500 <main>:
main():
/work/x86_os_my/kernel/main.c:28
*/
/*
信号量、锁

*/
int main(void) {
c0001500:	8d 4c 24 04          	lea    0x4(%esp),%ecx
c0001504:	83 e4 f0             	and    $0xfffffff0,%esp
c0001507:	ff 71 fc             	pushl  -0x4(%ecx)
c000150a:	55                   	push   %ebp
c000150b:	89 e5                	mov    %esp,%ebp
c000150d:	51                   	push   %ecx
c000150e:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/kernel/main.c:29
	put_str("I am kernel\n");
c0001511:	83 ec 0c             	sub    $0xc,%esp
c0001514:	68 2c 40 00 c0       	push   $0xc000402c
c0001519:	e8 32 0c 00 00       	call   c0002150 <put_str>
c000151e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:30
	init_all();
c0001521:	e8 05 01 00 00       	call   c000162b <init_all>
/work/x86_os_my/kernel/main.c:32
	
	thread_start("consumer_a", 31, k_thread_a, " A_");
c0001526:	68 39 40 00 c0       	push   $0xc0004039
c000152b:	68 5f 15 00 c0       	push   $0xc000155f
c0001530:	6a 1f                	push   $0x1f
c0001532:	68 3d 40 00 c0       	push   $0xc000403d
c0001537:	e8 0a 1b 00 00       	call   c0003046 <thread_start>
c000153c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:33
	thread_start("consumer_b", 31, k_thread_b, " B_");
c000153f:	68 48 40 00 c0       	push   $0xc0004048
c0001544:	68 c5 15 00 c0       	push   $0xc00015c5
c0001549:	6a 1f                	push   $0x1f
c000154b:	68 4c 40 00 c0       	push   $0xc000404c
c0001550:	e8 f1 1a 00 00       	call   c0003046 <thread_start>
c0001555:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:34
	intr_enable();
c0001558:	e8 2c 04 00 00       	call   c0001989 <intr_enable>
/work/x86_os_my/kernel/main.c:35 (discriminator 1)
	while(1);
c000155d:	eb fe                	jmp    c000155d <main+0x5d>

c000155f <k_thread_a>:
k_thread_a():
/work/x86_os_my/kernel/main.c:41
	
	return 0;
}

/* 在线程中运行的函数 */
void k_thread_a(void* arg) {
c000155f:	55                   	push   %ebp
c0001560:	89 e5                	mov    %esp,%ebp
c0001562:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:43
	while(1) {
		enum intr_status old_status = intr_disable();
c0001565:	e8 48 04 00 00       	call   c00019b2 <intr_disable>
c000156a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:44
		if (!ioq_empty(&kbd_buf)) {
c000156d:	83 ec 0c             	sub    $0xc,%esp
c0001570:	68 40 6b 00 c0       	push   $0xc0006b40
c0001575:	e8 70 28 00 00       	call   c0003dea <ioq_empty>
c000157a:	83 c4 10             	add    $0x10,%esp
c000157d:	85 c0                	test   %eax,%eax
c000157f:	75 34                	jne    c00015b5 <k_thread_a+0x56>
/work/x86_os_my/kernel/main.c:45
			console_put_str(arg);
c0001581:	83 ec 0c             	sub    $0xc,%esp
c0001584:	ff 75 08             	pushl  0x8(%ebp)
c0001587:	e8 34 21 00 00       	call   c00036c0 <console_put_str>
c000158c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:46
			char byte = ioq_getchar(&kbd_buf);
c000158f:	83 ec 0c             	sub    $0xc,%esp
c0001592:	68 40 6b 00 c0       	push   $0xc0006b40
c0001597:	e8 1b 29 00 00       	call   c0003eb7 <ioq_getchar>
c000159c:	83 c4 10             	add    $0x10,%esp
c000159f:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/kernel/main.c:47
			console_put_char(byte);
c00015a2:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c00015a6:	0f b6 c0             	movzbl %al,%eax
c00015a9:	83 ec 0c             	sub    $0xc,%esp
c00015ac:	50                   	push   %eax
c00015ad:	e8 2f 21 00 00       	call   c00036e1 <console_put_char>
c00015b2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:49
		}
		intr_set_status(old_status);
c00015b5:	83 ec 0c             	sub    $0xc,%esp
c00015b8:	ff 75 f4             	pushl  -0xc(%ebp)
c00015bb:	e8 1b 04 00 00       	call   c00019db <intr_set_status>
c00015c0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:50
	}
c00015c3:	eb a0                	jmp    c0001565 <k_thread_a+0x6>

c00015c5 <k_thread_b>:
k_thread_b():
/work/x86_os_my/kernel/main.c:54
}

/* 在线程中运行的函数 */
void k_thread_b(void* arg) {
c00015c5:	55                   	push   %ebp
c00015c6:	89 e5                	mov    %esp,%ebp
c00015c8:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:56
	while(1) {
		enum intr_status old_status = intr_disable();
c00015cb:	e8 e2 03 00 00       	call   c00019b2 <intr_disable>
c00015d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:57
		if (!ioq_empty(&kbd_buf)) {
c00015d3:	83 ec 0c             	sub    $0xc,%esp
c00015d6:	68 40 6b 00 c0       	push   $0xc0006b40
c00015db:	e8 0a 28 00 00       	call   c0003dea <ioq_empty>
c00015e0:	83 c4 10             	add    $0x10,%esp
c00015e3:	85 c0                	test   %eax,%eax
c00015e5:	75 34                	jne    c000161b <k_thread_b+0x56>
/work/x86_os_my/kernel/main.c:58
			console_put_str(arg);
c00015e7:	83 ec 0c             	sub    $0xc,%esp
c00015ea:	ff 75 08             	pushl  0x8(%ebp)
c00015ed:	e8 ce 20 00 00       	call   c00036c0 <console_put_str>
c00015f2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:59
			char byte = ioq_getchar(&kbd_buf);
c00015f5:	83 ec 0c             	sub    $0xc,%esp
c00015f8:	68 40 6b 00 c0       	push   $0xc0006b40
c00015fd:	e8 b5 28 00 00       	call   c0003eb7 <ioq_getchar>
c0001602:	83 c4 10             	add    $0x10,%esp
c0001605:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/kernel/main.c:60
			console_put_char(byte);
c0001608:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c000160c:	0f b6 c0             	movzbl %al,%eax
c000160f:	83 ec 0c             	sub    $0xc,%esp
c0001612:	50                   	push   %eax
c0001613:	e8 c9 20 00 00       	call   c00036e1 <console_put_char>
c0001618:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:62
		}
		intr_set_status(old_status);
c000161b:	83 ec 0c             	sub    $0xc,%esp
c000161e:	ff 75 f4             	pushl  -0xc(%ebp)
c0001621:	e8 b5 03 00 00       	call   c00019db <intr_set_status>
c0001626:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:63
	}
c0001629:	eb a0                	jmp    c00015cb <k_thread_b+0x6>

c000162b <init_all>:
init_all():
/work/x86_os_my/kernel/init.c:11
#include "thread.h"
#include "console.h"
#include "keyboard.h"

/*负责初始化所有模块 */
void init_all() {
c000162b:	55                   	push   %ebp
c000162c:	89 e5                	mov    %esp,%ebp
c000162e:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/init.c:12
	put_str("init_all\n");
c0001631:	83 ec 0c             	sub    $0xc,%esp
c0001634:	68 57 40 00 c0       	push   $0xc0004057
c0001639:	e8 12 0b 00 00       	call   c0002150 <put_str>
c000163e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/init.c:13
	idt_init();			// 初始化中断
c0001641:	e8 f4 03 00 00       	call   c0001a3a <idt_init>
/work/x86_os_my/kernel/init.c:14
	mem_init();			// 初始化内存管理系统
c0001646:	e8 af 14 00 00       	call   c0002afa <mem_init>
/work/x86_os_my/kernel/init.c:15
	thread_init();		// 初始化线程相关结构
c000164b:	e8 c3 1d 00 00       	call   c0003413 <thread_init>
/work/x86_os_my/kernel/init.c:16
	timer_init();		// 初始化PIT
c0001650:	e8 5f 05 00 00       	call   c0001bb4 <timer_init>
/work/x86_os_my/kernel/init.c:17
	console_init();		// 控制台初始化最好放在开中断之前
c0001655:	e8 1b 20 00 00       	call   c0003675 <console_init>
/work/x86_os_my/kernel/init.c:18
	keyboard_init();	// 键盘初始化
c000165a:	e8 94 26 00 00       	call   c0003cf3 <keyboard_init>
/work/x86_os_my/kernel/init.c:19
}
c000165f:	90                   	nop
c0001660:	c9                   	leave  
c0001661:	c3                   	ret    

c0001662 <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c0001662:	55                   	push   %ebp
c0001663:	89 e5                	mov    %esp,%ebp
c0001665:	83 ec 08             	sub    $0x8,%esp
c0001668:	8b 55 08             	mov    0x8(%ebp),%edx
c000166b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000166e:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0001672:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c0001675:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0001679:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c000167d:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c000167e:	90                   	nop
c000167f:	c9                   	leave  
c0001680:	c3                   	ret    

c0001681 <pic_init>:
pic_init():
/work/x86_os_my/kernel/interrupt.c:39
//自定义类型 intr_handler = void*
extern intr_handler intr_entry_table[IDT_DESC_CNT];	    // 声明引用汇编kernel.S中的中断处理函数入口数组

/* 初始化可编程中断控制器8259A */
// outb 来着 lib/kernel/io.h 内联汇编写法
static void pic_init(void) {
c0001681:	55                   	push   %ebp
c0001682:	89 e5                	mov    %esp,%ebp
c0001684:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:41
	/* 初始化主片 */
	outb (PIC_M_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c0001687:	6a 11                	push   $0x11
c0001689:	6a 20                	push   $0x20
c000168b:	e8 d2 ff ff ff       	call   c0001662 <outb>
c0001690:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:42
	outb (PIC_M_DATA, 0x20);	// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.
c0001693:	6a 20                	push   $0x20
c0001695:	6a 21                	push   $0x21
c0001697:	e8 c6 ff ff ff       	call   c0001662 <outb>
c000169c:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:43
	outb (PIC_M_DATA, 0x04);	// ICW3: IR2接从片. 
c000169f:	6a 04                	push   $0x4
c00016a1:	6a 21                	push   $0x21
c00016a3:	e8 ba ff ff ff       	call   c0001662 <outb>
c00016a8:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:44
	outb (PIC_M_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c00016ab:	6a 01                	push   $0x1
c00016ad:	6a 21                	push   $0x21
c00016af:	e8 ae ff ff ff       	call   c0001662 <outb>
c00016b4:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:47

	/* 初始化从片 */
	outb (PIC_S_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c00016b7:	6a 11                	push   $0x11
c00016b9:	68 a0 00 00 00       	push   $0xa0
c00016be:	e8 9f ff ff ff       	call   c0001662 <outb>
c00016c3:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:48
	outb (PIC_S_DATA, 0x28);	// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.
c00016c6:	6a 28                	push   $0x28
c00016c8:	68 a1 00 00 00       	push   $0xa1
c00016cd:	e8 90 ff ff ff       	call   c0001662 <outb>
c00016d2:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:49
	outb (PIC_S_DATA, 0x02);	// ICW3: 设置从片连接到主片的IR2引脚
c00016d5:	6a 02                	push   $0x2
c00016d7:	68 a1 00 00 00       	push   $0xa1
c00016dc:	e8 81 ff ff ff       	call   c0001662 <outb>
c00016e1:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:50
	outb (PIC_S_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c00016e4:	6a 01                	push   $0x1
c00016e6:	68 a1 00 00 00       	push   $0xa1
c00016eb:	e8 72 ff ff ff       	call   c0001662 <outb>
c00016f0:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:53

	/* 打开主片上IR0,也就是目前只接受 时钟0xfe + 键盘0xfc 产生的中断 */
	outb (PIC_M_DATA, 0xfc);
c00016f3:	68 fc 00 00 00       	push   $0xfc
c00016f8:	6a 21                	push   $0x21
c00016fa:	e8 63 ff ff ff       	call   c0001662 <outb>
c00016ff:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:54
	outb (PIC_S_DATA, 0xff);
c0001702:	68 ff 00 00 00       	push   $0xff
c0001707:	68 a1 00 00 00       	push   $0xa1
c000170c:	e8 51 ff ff ff       	call   c0001662 <outb>
c0001711:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:56

	put_str("   pic_init done\n");
c0001714:	83 ec 0c             	sub    $0xc,%esp
c0001717:	68 64 40 00 c0       	push   $0xc0004064
c000171c:	e8 2f 0a 00 00       	call   c0002150 <put_str>
c0001721:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:57
}
c0001724:	90                   	nop
c0001725:	c9                   	leave  
c0001726:	c3                   	ret    

c0001727 <make_idt_desc>:
make_idt_desc():
/work/x86_os_my/kernel/interrupt.c:60

/* 创建中断门描述符 */
static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function) { 
c0001727:	55                   	push   %ebp
c0001728:	89 e5                	mov    %esp,%ebp
c000172a:	83 ec 04             	sub    $0x4,%esp
c000172d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001730:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:61
	p_gdesc->func_offset_low_word = (uint32_t)function & 0x0000FFFF;
c0001733:	8b 45 10             	mov    0x10(%ebp),%eax
c0001736:	89 c2                	mov    %eax,%edx
c0001738:	8b 45 08             	mov    0x8(%ebp),%eax
c000173b:	66 89 10             	mov    %dx,(%eax)
/work/x86_os_my/kernel/interrupt.c:62
	p_gdesc->selector = SELECTOR_K_CODE;
c000173e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001741:	66 c7 40 02 08 00    	movw   $0x8,0x2(%eax)
/work/x86_os_my/kernel/interrupt.c:63
	p_gdesc->dcount = 0;
c0001747:	8b 45 08             	mov    0x8(%ebp),%eax
c000174a:	c6 40 04 00          	movb   $0x0,0x4(%eax)
/work/x86_os_my/kernel/interrupt.c:64
	p_gdesc->attribute = attr;
c000174e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001751:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c0001755:	88 50 05             	mov    %dl,0x5(%eax)
/work/x86_os_my/kernel/interrupt.c:65
	p_gdesc->func_offset_high_word = ((uint32_t)function & 0xFFFF0000) >> 16;
c0001758:	8b 45 10             	mov    0x10(%ebp),%eax
c000175b:	c1 e8 10             	shr    $0x10,%eax
c000175e:	89 c2                	mov    %eax,%edx
c0001760:	8b 45 08             	mov    0x8(%ebp),%eax
c0001763:	66 89 50 06          	mov    %dx,0x6(%eax)
/work/x86_os_my/kernel/interrupt.c:66
}
c0001767:	90                   	nop
c0001768:	c9                   	leave  
c0001769:	c3                   	ret    

c000176a <idt_desc_init>:
idt_desc_init():
/work/x86_os_my/kernel/interrupt.c:69

/*初始化中断描述符表*/
static void idt_desc_init(void) {
c000176a:	55                   	push   %ebp
c000176b:	89 e5                	mov    %esp,%ebp
c000176d:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:71
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001770:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0001777:	eb 29                	jmp    c00017a2 <idt_desc_init+0x38>
/work/x86_os_my/kernel/interrupt.c:72 (discriminator 3)
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
c0001779:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000177c:	8b 04 85 40 66 00 c0 	mov    -0x3fff99c0(,%eax,4),%eax
c0001783:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0001786:	c1 e2 03             	shl    $0x3,%edx
c0001789:	81 c2 a0 67 00 c0    	add    $0xc00067a0,%edx
c000178f:	50                   	push   %eax
c0001790:	68 8e 00 00 00       	push   $0x8e
c0001795:	52                   	push   %edx
c0001796:	e8 8c ff ff ff       	call   c0001727 <make_idt_desc>
c000179b:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/kernel/interrupt.c:71 (discriminator 3)
}

/*初始化中断描述符表*/
static void idt_desc_init(void) {
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c000179e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:71 (discriminator 1)
c00017a2:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
c00017a6:	7e d1                	jle    c0001779 <idt_desc_init+0xf>
/work/x86_os_my/kernel/interrupt.c:74
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
	}
	put_str("   idt_desc_init done\n");
c00017a8:	83 ec 0c             	sub    $0xc,%esp
c00017ab:	68 76 40 00 c0       	push   $0xc0004076
c00017b0:	e8 9b 09 00 00       	call   c0002150 <put_str>
c00017b5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:75
}
c00017b8:	90                   	nop
c00017b9:	c9                   	leave  
c00017ba:	c3                   	ret    

c00017bb <general_intr_handler>:
general_intr_handler():
/work/x86_os_my/kernel/interrupt.c:78

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
c00017bb:	55                   	push   %ebp
c00017bc:	89 e5                	mov    %esp,%ebp
c00017be:	83 ec 28             	sub    $0x28,%esp
c00017c1:	8b 45 08             	mov    0x8(%ebp),%eax
c00017c4:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/kernel/interrupt.c:79
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
c00017c7:	80 7d e4 27          	cmpb   $0x27,-0x1c(%ebp)
c00017cb:	0f 84 bf 00 00 00    	je     c0001890 <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:79 (discriminator 1)
c00017d1:	80 7d e4 2f          	cmpb   $0x2f,-0x1c(%ebp)
c00017d5:	0f 84 b5 00 00 00    	je     c0001890 <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:84
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
c00017db:	83 ec 0c             	sub    $0xc,%esp
c00017de:	6a 00                	push   $0x0
c00017e0:	e8 b9 0a 00 00       	call   c000229e <set_cursor>
c00017e5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:85
	int cursor_pos = 0;
c00017e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:86
	while(cursor_pos < 320) {
c00017ef:	eb 11                	jmp    c0001802 <general_intr_handler+0x47>
/work/x86_os_my/kernel/interrupt.c:87
		put_char(' ');
c00017f1:	83 ec 0c             	sub    $0xc,%esp
c00017f4:	6a 20                	push   $0x20
c00017f6:	e8 73 09 00 00       	call   c000216e <put_char>
c00017fb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:88
		cursor_pos++;
c00017fe:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:86
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
	int cursor_pos = 0;
	while(cursor_pos < 320) {
c0001802:	81 7d f4 3f 01 00 00 	cmpl   $0x13f,-0xc(%ebp)
c0001809:	7e e6                	jle    c00017f1 <general_intr_handler+0x36>
/work/x86_os_my/kernel/interrupt.c:92
		put_char(' ');
		cursor_pos++;
	}

	/* 将光标置为左上角 打印信息 */
	set_cursor(0);
c000180b:	83 ec 0c             	sub    $0xc,%esp
c000180e:	6a 00                	push   $0x0
c0001810:	e8 89 0a 00 00       	call   c000229e <set_cursor>
c0001815:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:93
	put_str("!!!!!!!      excetion message begin  !!!!!!!!\n");
c0001818:	83 ec 0c             	sub    $0xc,%esp
c000181b:	68 90 40 00 c0       	push   $0xc0004090
c0001820:	e8 2b 09 00 00       	call   c0002150 <put_str>
c0001825:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:94
	set_cursor(88);			// 第2行第8个字符
c0001828:	83 ec 0c             	sub    $0xc,%esp
c000182b:	6a 58                	push   $0x58
c000182d:	e8 6c 0a 00 00       	call   c000229e <set_cursor>
c0001832:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:95
	put_str(intr_name[vec_nr]);
c0001835:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0001839:	8b 04 85 60 69 00 c0 	mov    -0x3fff96a0(,%eax,4),%eax
c0001840:	83 ec 0c             	sub    $0xc,%esp
c0001843:	50                   	push   %eax
c0001844:	e8 07 09 00 00       	call   c0002150 <put_str>
c0001849:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:96
	if (vec_nr == 14) {		// 若为Pagefault,将缺失的地址打印出来并悬停
c000184c:	80 7d e4 0e          	cmpb   $0xe,-0x1c(%ebp)
c0001850:	75 2c                	jne    c000187e <general_intr_handler+0xc3>
/work/x86_os_my/kernel/interrupt.c:97
		int page_fault_vaddr = 0; 
c0001852:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:98
		asm ("movl %%cr2, %0" : "=r" (page_fault_vaddr));	  // cr2是存放造成page_fault的地址
c0001859:	0f 20 d0             	mov    %cr2,%eax
c000185c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:99
		put_str("\npage fault addr is ");
c000185f:	83 ec 0c             	sub    $0xc,%esp
c0001862:	68 bf 40 00 c0       	push   $0xc00040bf
c0001867:	e8 e4 08 00 00       	call   c0002150 <put_str>
c000186c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:100
		put_int(page_fault_vaddr); 
c000186f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001872:	83 ec 0c             	sub    $0xc,%esp
c0001875:	50                   	push   %eax
c0001876:	e8 c0 09 00 00       	call   c000223b <put_int>
c000187b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:102
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
c000187e:	83 ec 0c             	sub    $0xc,%esp
c0001881:	68 d4 40 00 c0       	push   $0xc00040d4
c0001886:	e8 c5 08 00 00       	call   c0002150 <put_str>
c000188b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:105 (discriminator 1)
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
c000188e:	eb fe                	jmp    c000188e <general_intr_handler+0xd3>
/work/x86_os_my/kernel/interrupt.c:80
}

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
c0001890:	90                   	nop
/work/x86_os_my/kernel/interrupt.c:106
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
}
c0001891:	c9                   	leave  
c0001892:	c3                   	ret    

c0001893 <exception_init>:
exception_init():
/work/x86_os_my/kernel/interrupt.c:109

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
c0001893:	55                   	push   %ebp
c0001894:	89 e5                	mov    %esp,%ebp
c0001896:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:111
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001899:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00018a0:	eb 20                	jmp    c00018c2 <exception_init+0x2f>
/work/x86_os_my/kernel/interrupt.c:114 (discriminator 3)
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
c00018a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00018a5:	c7 04 85 20 6a 00 c0 	movl   $0xc00017bb,-0x3fff95e0(,%eax,4)
c00018ac:	bb 17 00 c0 
/work/x86_os_my/kernel/interrupt.c:115 (discriminator 3)
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
c00018b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00018b3:	c7 04 85 60 69 00 c0 	movl   $0xc0004104,-0x3fff96a0(,%eax,4)
c00018ba:	04 41 00 c0 
/work/x86_os_my/kernel/interrupt.c:111 (discriminator 3)
}

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c00018be:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:111 (discriminator 1)
c00018c2:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%ebp)
c00018c6:	7e da                	jle    c00018a2 <exception_init+0xf>
/work/x86_os_my/kernel/interrupt.c:117
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
	}
	intr_name[0] = "#DE Divide Error";
c00018c8:	c7 05 60 69 00 c0 0c 	movl   $0xc000410c,0xc0006960
c00018cf:	41 00 c0 
/work/x86_os_my/kernel/interrupt.c:118
	intr_name[1] = "#DB Debug Exception";
c00018d2:	c7 05 64 69 00 c0 1d 	movl   $0xc000411d,0xc0006964
c00018d9:	41 00 c0 
/work/x86_os_my/kernel/interrupt.c:119
	intr_name[2] = "NMI Interrupt";
c00018dc:	c7 05 68 69 00 c0 31 	movl   $0xc0004131,0xc0006968
c00018e3:	41 00 c0 
/work/x86_os_my/kernel/interrupt.c:120
	intr_name[3] = "#BP Breakpoint Exception";
c00018e6:	c7 05 6c 69 00 c0 3f 	movl   $0xc000413f,0xc000696c
c00018ed:	41 00 c0 
/work/x86_os_my/kernel/interrupt.c:121
	intr_name[4] = "#OF Overflow Exception";
c00018f0:	c7 05 70 69 00 c0 58 	movl   $0xc0004158,0xc0006970
c00018f7:	41 00 c0 
/work/x86_os_my/kernel/interrupt.c:122
	intr_name[5] = "#BR BOUND Range Exceeded Exception";
c00018fa:	c7 05 74 69 00 c0 70 	movl   $0xc0004170,0xc0006974
c0001901:	41 00 c0 
/work/x86_os_my/kernel/interrupt.c:123
	intr_name[6] = "#UD Invalid Opcode Exception";
c0001904:	c7 05 78 69 00 c0 93 	movl   $0xc0004193,0xc0006978
c000190b:	41 00 c0 
/work/x86_os_my/kernel/interrupt.c:124
	intr_name[7] = "#NM Device Not Available Exception";
c000190e:	c7 05 7c 69 00 c0 b0 	movl   $0xc00041b0,0xc000697c
c0001915:	41 00 c0 
/work/x86_os_my/kernel/interrupt.c:125
	intr_name[8] = "#DF Double Fault Exception";
c0001918:	c7 05 80 69 00 c0 d3 	movl   $0xc00041d3,0xc0006980
c000191f:	41 00 c0 
/work/x86_os_my/kernel/interrupt.c:126
	intr_name[9] = "Coprocessor Segment Overrun";
c0001922:	c7 05 84 69 00 c0 ee 	movl   $0xc00041ee,0xc0006984
c0001929:	41 00 c0 
/work/x86_os_my/kernel/interrupt.c:127
	intr_name[10] = "#TS Invalid TSS Exception";
c000192c:	c7 05 88 69 00 c0 0a 	movl   $0xc000420a,0xc0006988
c0001933:	42 00 c0 
/work/x86_os_my/kernel/interrupt.c:128
	intr_name[11] = "#NP Segment Not Present";
c0001936:	c7 05 8c 69 00 c0 24 	movl   $0xc0004224,0xc000698c
c000193d:	42 00 c0 
/work/x86_os_my/kernel/interrupt.c:129
	intr_name[12] = "#SS Stack Fault Exception";
c0001940:	c7 05 90 69 00 c0 3c 	movl   $0xc000423c,0xc0006990
c0001947:	42 00 c0 
/work/x86_os_my/kernel/interrupt.c:130
	intr_name[13] = "#GP General Protection Exception";
c000194a:	c7 05 94 69 00 c0 58 	movl   $0xc0004258,0xc0006994
c0001951:	42 00 c0 
/work/x86_os_my/kernel/interrupt.c:131
	intr_name[14] = "#PF Page-Fault Exception";
c0001954:	c7 05 98 69 00 c0 79 	movl   $0xc0004279,0xc0006998
c000195b:	42 00 c0 
/work/x86_os_my/kernel/interrupt.c:133
	// intr_name[15] 第15项是intel保留项，未使用
	intr_name[16] = "#MF x87 FPU Floating-Point Error";
c000195e:	c7 05 a0 69 00 c0 94 	movl   $0xc0004294,0xc00069a0
c0001965:	42 00 c0 
/work/x86_os_my/kernel/interrupt.c:134
	intr_name[17] = "#AC Alignment Check Exception";
c0001968:	c7 05 a4 69 00 c0 b5 	movl   $0xc00042b5,0xc00069a4
c000196f:	42 00 c0 
/work/x86_os_my/kernel/interrupt.c:135
	intr_name[18] = "#MC Machine-Check Exception";
c0001972:	c7 05 a8 69 00 c0 d3 	movl   $0xc00042d3,0xc00069a8
c0001979:	42 00 c0 
/work/x86_os_my/kernel/interrupt.c:136
	intr_name[19] = "#XF SIMD Floating-Point Exception";
c000197c:	c7 05 ac 69 00 c0 f0 	movl   $0xc00042f0,0xc00069ac
c0001983:	42 00 c0 
/work/x86_os_my/kernel/interrupt.c:137
}
c0001986:	90                   	nop
c0001987:	c9                   	leave  
c0001988:	c3                   	ret    

c0001989 <intr_enable>:
intr_enable():
/work/x86_os_my/kernel/interrupt.c:140

/* 开中断并返回开中断前的状态*/
enum intr_status intr_enable() {
c0001989:	55                   	push   %ebp
c000198a:	89 e5                	mov    %esp,%ebp
c000198c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:142
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c000198f:	e8 65 00 00 00       	call   c00019f9 <intr_get_status>
c0001994:	83 f8 01             	cmp    $0x1,%eax
c0001997:	75 0c                	jne    c00019a5 <intr_enable+0x1c>
/work/x86_os_my/kernel/interrupt.c:143
		old_status = INTR_ON;
c0001999:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:144
		return old_status;
c00019a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00019a3:	eb 0b                	jmp    c00019b0 <intr_enable+0x27>
/work/x86_os_my/kernel/interrupt.c:146
	} else {
		old_status = INTR_OFF;
c00019a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:147
		asm volatile("sti");	 // 开中断,sti指令将IF位置1
c00019ac:	fb                   	sti    
/work/x86_os_my/kernel/interrupt.c:148
		return old_status;
c00019ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:150
	}
}
c00019b0:	c9                   	leave  
c00019b1:	c3                   	ret    

c00019b2 <intr_disable>:
intr_disable():
/work/x86_os_my/kernel/interrupt.c:153

/* 关中断,并且返回关中断前的状态 */
enum intr_status intr_disable() {     
c00019b2:	55                   	push   %ebp
c00019b3:	89 e5                	mov    %esp,%ebp
c00019b5:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:155
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c00019b8:	e8 3c 00 00 00       	call   c00019f9 <intr_get_status>
c00019bd:	83 f8 01             	cmp    $0x1,%eax
c00019c0:	75 0d                	jne    c00019cf <intr_disable+0x1d>
/work/x86_os_my/kernel/interrupt.c:156
		old_status = INTR_ON;
c00019c2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:157
		asm volatile("cli" : : : "memory"); // 关中断,cli指令将IF位置0
c00019c9:	fa                   	cli    
/work/x86_os_my/kernel/interrupt.c:158
		return old_status;
c00019ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00019cd:	eb 0a                	jmp    c00019d9 <intr_disable+0x27>
/work/x86_os_my/kernel/interrupt.c:160
	} else {
		old_status = INTR_OFF;
c00019cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:161
		return old_status;
c00019d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:163
	}
}
c00019d9:	c9                   	leave  
c00019da:	c3                   	ret    

c00019db <intr_set_status>:
intr_set_status():
/work/x86_os_my/kernel/interrupt.c:166

/* 将中断状态设置为status */
enum intr_status intr_set_status(enum intr_status status) {
c00019db:	55                   	push   %ebp
c00019dc:	89 e5                	mov    %esp,%ebp
c00019de:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:167
	return status & INTR_ON ? intr_enable() : intr_disable();
c00019e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00019e4:	83 e0 01             	and    $0x1,%eax
c00019e7:	85 c0                	test   %eax,%eax
c00019e9:	74 07                	je     c00019f2 <intr_set_status+0x17>
/work/x86_os_my/kernel/interrupt.c:167 (discriminator 1)
c00019eb:	e8 99 ff ff ff       	call   c0001989 <intr_enable>
c00019f0:	eb 05                	jmp    c00019f7 <intr_set_status+0x1c>
/work/x86_os_my/kernel/interrupt.c:167 (discriminator 2)
c00019f2:	e8 bb ff ff ff       	call   c00019b2 <intr_disable>
/work/x86_os_my/kernel/interrupt.c:168 (discriminator 5)
}
c00019f7:	c9                   	leave  
c00019f8:	c3                   	ret    

c00019f9 <intr_get_status>:
intr_get_status():
/work/x86_os_my/kernel/interrupt.c:171

/* 获取当前中断状态 */
enum intr_status intr_get_status() {
c00019f9:	55                   	push   %ebp
c00019fa:	89 e5                	mov    %esp,%ebp
c00019fc:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:172
	uint32_t eflags = 0; 
c00019ff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:173
	GET_EFLAGS(eflags);
c0001a06:	9c                   	pushf  
c0001a07:	58                   	pop    %eax
c0001a08:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:174
	return (EFLAGS_IF & eflags) ? INTR_ON : INTR_OFF;
c0001a0b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001a0e:	25 00 02 00 00       	and    $0x200,%eax
c0001a13:	85 c0                	test   %eax,%eax
c0001a15:	0f 95 c0             	setne  %al
c0001a18:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/kernel/interrupt.c:175
}
c0001a1b:	c9                   	leave  
c0001a1c:	c3                   	ret    

c0001a1d <register_handler>:
register_handler():
/work/x86_os_my/kernel/interrupt.c:178

/* 在中断处理程序数组第vector_no个元素中注册安装中断处理程序function */
void register_handler(uint8_t vector_no, intr_handler function) {
c0001a1d:	55                   	push   %ebp
c0001a1e:	89 e5                	mov    %esp,%ebp
c0001a20:	83 ec 04             	sub    $0x4,%esp
c0001a23:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a26:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:181
/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
 * 见kernel/kernel.S的call [idt_table + %1*4] */
   idt_table[vector_no] = function; 
c0001a29:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0001a2d:	8b 55 0c             	mov    0xc(%ebp),%edx
c0001a30:	89 14 85 20 6a 00 c0 	mov    %edx,-0x3fff95e0(,%eax,4)
/work/x86_os_my/kernel/interrupt.c:182
}
c0001a37:	90                   	nop
c0001a38:	c9                   	leave  
c0001a39:	c3                   	ret    

c0001a3a <idt_init>:
idt_init():
/work/x86_os_my/kernel/interrupt.c:185

/*完成有关中断的所有初始化工作*/
void idt_init() {
c0001a3a:	55                   	push   %ebp
c0001a3b:	89 e5                	mov    %esp,%ebp
c0001a3d:	56                   	push   %esi
c0001a3e:	53                   	push   %ebx
c0001a3f:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:186
	put_str("idt_init start\n");
c0001a42:	83 ec 0c             	sub    $0xc,%esp
c0001a45:	68 12 43 00 c0       	push   $0xc0004312
c0001a4a:	e8 01 07 00 00       	call   c0002150 <put_str>
c0001a4f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:187
	idt_desc_init();	// 初始化中断描述符表
c0001a52:	e8 13 fd ff ff       	call   c000176a <idt_desc_init>
/work/x86_os_my/kernel/interrupt.c:188
	exception_init();	// 异常名初始化并注册通常的中断处理函数
c0001a57:	e8 37 fe ff ff       	call   c0001893 <exception_init>
/work/x86_os_my/kernel/interrupt.c:189
	pic_init();			// 初始化8259A
c0001a5c:	e8 20 fc ff ff       	call   c0001681 <pic_init>
/work/x86_os_my/kernel/interrupt.c:193

	/* 加载idt */
	// IDTR 是 48 位的寄存器，低 16 位是 IDT 的界限 = IDT 尺寸大小-1，高 32 位是 IDT 的线性基地址
	uint64_t idt_operand = ((sizeof(idt) - 1) | ((uint64_t)(uint32_t)idt << 16));
c0001a61:	b8 a0 67 00 c0       	mov    $0xc00067a0,%eax
c0001a66:	ba 00 00 00 00       	mov    $0x0,%edx
c0001a6b:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0001a6f:	c1 e0 10             	shl    $0x10,%eax
c0001a72:	89 c1                	mov    %eax,%ecx
c0001a74:	81 c9 7f 01 00 00    	or     $0x17f,%ecx
c0001a7a:	89 cb                	mov    %ecx,%ebx
c0001a7c:	89 d0                	mov    %edx,%eax
c0001a7e:	80 cc 00             	or     $0x0,%ah
c0001a81:	89 c6                	mov    %eax,%esi
c0001a83:	89 5d f0             	mov    %ebx,-0x10(%ebp)
c0001a86:	89 75 f4             	mov    %esi,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:194
	asm volatile("lidt %0" : : "m" (idt_operand));
c0001a89:	0f 01 5d f0          	lidtl  -0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:195
	put_str("idt_init done\n");
c0001a8d:	83 ec 0c             	sub    $0xc,%esp
c0001a90:	68 22 43 00 c0       	push   $0xc0004322
c0001a95:	e8 b6 06 00 00       	call   c0002150 <put_str>
c0001a9a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:196
}
c0001a9d:	90                   	nop
c0001a9e:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001aa1:	5b                   	pop    %ebx
c0001aa2:	5e                   	pop    %esi
c0001aa3:	5d                   	pop    %ebp
c0001aa4:	c3                   	ret    

c0001aa5 <outb>:
outb():
c0001aa5:	55                   	push   %ebp
c0001aa6:	89 e5                	mov    %esp,%ebp
c0001aa8:	83 ec 08             	sub    $0x8,%esp
c0001aab:	8b 55 08             	mov    0x8(%ebp),%edx
c0001aae:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001ab1:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0001ab5:	88 45 f8             	mov    %al,-0x8(%ebp)
c0001ab8:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0001abc:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0001ac0:	ee                   	out    %al,(%dx)
c0001ac1:	90                   	nop
c0001ac2:	c9                   	leave  
c0001ac3:	c3                   	ret    

c0001ac4 <frequency_set>:
frequency_set():
c0001ac4:	55                   	push   %ebp
c0001ac5:	89 e5                	mov    %esp,%ebp
c0001ac7:	56                   	push   %esi
c0001ac8:	53                   	push   %ebx
c0001ac9:	83 ec 14             	sub    $0x14,%esp
c0001acc:	8b 45 08             	mov    0x8(%ebp),%eax
c0001acf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c0001ad2:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001ad5:	8b 55 14             	mov    0x14(%ebp),%edx
c0001ad8:	8b 75 18             	mov    0x18(%ebp),%esi
c0001adb:	88 45 f4             	mov    %al,-0xc(%ebp)
c0001ade:	88 5d f0             	mov    %bl,-0x10(%ebp)
c0001ae1:	88 4d ec             	mov    %cl,-0x14(%ebp)
c0001ae4:	88 55 e8             	mov    %dl,-0x18(%ebp)
c0001ae7:	66 89 75 e4          	mov    %si,-0x1c(%ebp)
c0001aeb:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0001aef:	c1 e0 06             	shl    $0x6,%eax
c0001af2:	89 c2                	mov    %eax,%edx
c0001af4:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0001af8:	c1 e0 04             	shl    $0x4,%eax
c0001afb:	09 c2                	or     %eax,%edx
c0001afd:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0001b01:	01 c0                	add    %eax,%eax
c0001b03:	09 d0                	or     %edx,%eax
c0001b05:	0f b6 c0             	movzbl %al,%eax
c0001b08:	50                   	push   %eax
c0001b09:	6a 43                	push   $0x43
c0001b0b:	e8 95 ff ff ff       	call   c0001aa5 <outb>
c0001b10:	83 c4 08             	add    $0x8,%esp
c0001b13:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0001b17:	0f b6 d0             	movzbl %al,%edx
c0001b1a:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001b1e:	52                   	push   %edx
c0001b1f:	50                   	push   %eax
c0001b20:	e8 80 ff ff ff       	call   c0001aa5 <outb>
c0001b25:	83 c4 08             	add    $0x8,%esp
c0001b28:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001b2c:	6a 00                	push   $0x0
c0001b2e:	50                   	push   %eax
c0001b2f:	e8 71 ff ff ff       	call   c0001aa5 <outb>
c0001b34:	83 c4 08             	add    $0x8,%esp
c0001b37:	90                   	nop
c0001b38:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001b3b:	5b                   	pop    %ebx
c0001b3c:	5e                   	pop    %esi
c0001b3d:	5d                   	pop    %ebp
c0001b3e:	c3                   	ret    

c0001b3f <intr_timer_handler>:
intr_timer_handler():
c0001b3f:	55                   	push   %ebp
c0001b40:	89 e5                	mov    %esp,%ebp
c0001b42:	83 ec 18             	sub    $0x18,%esp
c0001b45:	e8 c1 13 00 00       	call   c0002f0b <running_thread>
c0001b4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0001b4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b50:	8b 40 34             	mov    0x34(%eax),%eax
c0001b53:	3d 16 09 87 19       	cmp    $0x19870916,%eax
c0001b58:	74 19                	je     c0001b73 <intr_timer_handler+0x34>
c0001b5a:	68 34 43 00 c0       	push   $0xc0004334
c0001b5f:	68 8c 43 00 c0       	push   $0xc000438c
c0001b64:	6a 26                	push   $0x26
c0001b66:	68 5a 43 00 c0       	push   $0xc000435a
c0001b6b:	e8 52 07 00 00       	call   c00022c2 <panic_spin>
c0001b70:	83 c4 10             	add    $0x10,%esp
c0001b73:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b76:	8b 40 1c             	mov    0x1c(%eax),%eax
c0001b79:	8d 50 01             	lea    0x1(%eax),%edx
c0001b7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b7f:	89 50 1c             	mov    %edx,0x1c(%eax)
c0001b82:	a1 e0 6a 00 c0       	mov    0xc0006ae0,%eax
c0001b87:	83 c0 01             	add    $0x1,%eax
c0001b8a:	a3 e0 6a 00 c0       	mov    %eax,0xc0006ae0
c0001b8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b92:	0f b6 40 19          	movzbl 0x19(%eax),%eax
c0001b96:	84 c0                	test   %al,%al
c0001b98:	75 07                	jne    c0001ba1 <intr_timer_handler+0x62>
c0001b9a:	e8 fd 15 00 00       	call   c000319c <schedule>
c0001b9f:	eb 10                	jmp    c0001bb1 <intr_timer_handler+0x72>
c0001ba1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001ba4:	0f b6 40 19          	movzbl 0x19(%eax),%eax
c0001ba8:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001bab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001bae:	88 50 19             	mov    %dl,0x19(%eax)
c0001bb1:	90                   	nop
c0001bb2:	c9                   	leave  
c0001bb3:	c3                   	ret    

c0001bb4 <timer_init>:
timer_init():
c0001bb4:	55                   	push   %ebp
c0001bb5:	89 e5                	mov    %esp,%ebp
c0001bb7:	83 ec 08             	sub    $0x8,%esp
c0001bba:	83 ec 0c             	sub    $0xc,%esp
c0001bbd:	68 69 43 00 c0       	push   $0xc0004369
c0001bc2:	e8 89 05 00 00       	call   c0002150 <put_str>
c0001bc7:	83 c4 10             	add    $0x10,%esp
c0001bca:	83 ec 0c             	sub    $0xc,%esp
c0001bcd:	68 9b 2e 00 00       	push   $0x2e9b
c0001bd2:	6a 02                	push   $0x2
c0001bd4:	6a 03                	push   $0x3
c0001bd6:	6a 00                	push   $0x0
c0001bd8:	6a 40                	push   $0x40
c0001bda:	e8 e5 fe ff ff       	call   c0001ac4 <frequency_set>
c0001bdf:	83 c4 20             	add    $0x20,%esp
c0001be2:	83 ec 08             	sub    $0x8,%esp
c0001be5:	68 3f 1b 00 c0       	push   $0xc0001b3f
c0001bea:	6a 20                	push   $0x20
c0001bec:	e8 2c fe ff ff       	call   c0001a1d <register_handler>
c0001bf1:	83 c4 10             	add    $0x10,%esp
c0001bf4:	83 ec 0c             	sub    $0xc,%esp
c0001bf7:	68 7b 43 00 c0       	push   $0xc000437b
c0001bfc:	e8 4f 05 00 00       	call   c0002150 <put_str>
c0001c01:	83 c4 10             	add    $0x10,%esp
c0001c04:	90                   	nop
c0001c05:	c9                   	leave  
c0001c06:	c3                   	ret    
c0001c07:	66 90                	xchg   %ax,%ax
c0001c09:	66 90                	xchg   %ax,%ax
c0001c0b:	66 90                	xchg   %ax,%ax
c0001c0d:	66 90                	xchg   %ax,%ax
c0001c0f:	90                   	nop

c0001c10 <intr_exit>:
intr_exit():
c0001c10:	83 c4 04             	add    $0x4,%esp
c0001c13:	61                   	popa   
c0001c14:	0f a9                	pop    %gs
c0001c16:	0f a1                	pop    %fs
c0001c18:	07                   	pop    %es
c0001c19:	1f                   	pop    %ds
c0001c1a:	83 c4 04             	add    $0x4,%esp
c0001c1d:	cf                   	iret   

c0001c1e <intr0x00entry>:
intr0x00entry():
c0001c1e:	6a 00                	push   $0x0
c0001c20:	1e                   	push   %ds
c0001c21:	06                   	push   %es
c0001c22:	0f a0                	push   %fs
c0001c24:	0f a8                	push   %gs
c0001c26:	60                   	pusha  
c0001c27:	b0 20                	mov    $0x20,%al
c0001c29:	e6 a0                	out    %al,$0xa0
c0001c2b:	e6 20                	out    %al,$0x20
c0001c2d:	6a 00                	push   $0x0
c0001c2f:	ff 15 20 6a 00 c0    	call   *0xc0006a20
c0001c35:	eb d9                	jmp    c0001c10 <intr_exit>

c0001c37 <intr0x01entry>:
intr0x01entry():
c0001c37:	6a 00                	push   $0x0
c0001c39:	1e                   	push   %ds
c0001c3a:	06                   	push   %es
c0001c3b:	0f a0                	push   %fs
c0001c3d:	0f a8                	push   %gs
c0001c3f:	60                   	pusha  
c0001c40:	b0 20                	mov    $0x20,%al
c0001c42:	e6 a0                	out    %al,$0xa0
c0001c44:	e6 20                	out    %al,$0x20
c0001c46:	6a 01                	push   $0x1
c0001c48:	ff 15 24 6a 00 c0    	call   *0xc0006a24
c0001c4e:	eb c0                	jmp    c0001c10 <intr_exit>

c0001c50 <intr0x02entry>:
intr0x02entry():
c0001c50:	6a 00                	push   $0x0
c0001c52:	1e                   	push   %ds
c0001c53:	06                   	push   %es
c0001c54:	0f a0                	push   %fs
c0001c56:	0f a8                	push   %gs
c0001c58:	60                   	pusha  
c0001c59:	b0 20                	mov    $0x20,%al
c0001c5b:	e6 a0                	out    %al,$0xa0
c0001c5d:	e6 20                	out    %al,$0x20
c0001c5f:	6a 02                	push   $0x2
c0001c61:	ff 15 28 6a 00 c0    	call   *0xc0006a28
c0001c67:	eb a7                	jmp    c0001c10 <intr_exit>

c0001c69 <intr0x03entry>:
intr0x03entry():
c0001c69:	6a 00                	push   $0x0
c0001c6b:	1e                   	push   %ds
c0001c6c:	06                   	push   %es
c0001c6d:	0f a0                	push   %fs
c0001c6f:	0f a8                	push   %gs
c0001c71:	60                   	pusha  
c0001c72:	b0 20                	mov    $0x20,%al
c0001c74:	e6 a0                	out    %al,$0xa0
c0001c76:	e6 20                	out    %al,$0x20
c0001c78:	6a 03                	push   $0x3
c0001c7a:	ff 15 2c 6a 00 c0    	call   *0xc0006a2c
c0001c80:	eb 8e                	jmp    c0001c10 <intr_exit>

c0001c82 <intr0x04entry>:
intr0x04entry():
c0001c82:	6a 00                	push   $0x0
c0001c84:	1e                   	push   %ds
c0001c85:	06                   	push   %es
c0001c86:	0f a0                	push   %fs
c0001c88:	0f a8                	push   %gs
c0001c8a:	60                   	pusha  
c0001c8b:	b0 20                	mov    $0x20,%al
c0001c8d:	e6 a0                	out    %al,$0xa0
c0001c8f:	e6 20                	out    %al,$0x20
c0001c91:	6a 04                	push   $0x4
c0001c93:	ff 15 30 6a 00 c0    	call   *0xc0006a30
c0001c99:	e9 72 ff ff ff       	jmp    c0001c10 <intr_exit>

c0001c9e <intr0x05entry>:
intr0x05entry():
c0001c9e:	6a 00                	push   $0x0
c0001ca0:	1e                   	push   %ds
c0001ca1:	06                   	push   %es
c0001ca2:	0f a0                	push   %fs
c0001ca4:	0f a8                	push   %gs
c0001ca6:	60                   	pusha  
c0001ca7:	b0 20                	mov    $0x20,%al
c0001ca9:	e6 a0                	out    %al,$0xa0
c0001cab:	e6 20                	out    %al,$0x20
c0001cad:	6a 05                	push   $0x5
c0001caf:	ff 15 34 6a 00 c0    	call   *0xc0006a34
c0001cb5:	e9 56 ff ff ff       	jmp    c0001c10 <intr_exit>

c0001cba <intr0x06entry>:
intr0x06entry():
c0001cba:	6a 00                	push   $0x0
c0001cbc:	1e                   	push   %ds
c0001cbd:	06                   	push   %es
c0001cbe:	0f a0                	push   %fs
c0001cc0:	0f a8                	push   %gs
c0001cc2:	60                   	pusha  
c0001cc3:	b0 20                	mov    $0x20,%al
c0001cc5:	e6 a0                	out    %al,$0xa0
c0001cc7:	e6 20                	out    %al,$0x20
c0001cc9:	6a 06                	push   $0x6
c0001ccb:	ff 15 38 6a 00 c0    	call   *0xc0006a38
c0001cd1:	e9 3a ff ff ff       	jmp    c0001c10 <intr_exit>

c0001cd6 <intr0x07entry>:
intr0x07entry():
c0001cd6:	6a 00                	push   $0x0
c0001cd8:	1e                   	push   %ds
c0001cd9:	06                   	push   %es
c0001cda:	0f a0                	push   %fs
c0001cdc:	0f a8                	push   %gs
c0001cde:	60                   	pusha  
c0001cdf:	b0 20                	mov    $0x20,%al
c0001ce1:	e6 a0                	out    %al,$0xa0
c0001ce3:	e6 20                	out    %al,$0x20
c0001ce5:	6a 07                	push   $0x7
c0001ce7:	ff 15 3c 6a 00 c0    	call   *0xc0006a3c
c0001ced:	e9 1e ff ff ff       	jmp    c0001c10 <intr_exit>

c0001cf2 <intr0x08entry>:
intr0x08entry():
c0001cf2:	90                   	nop
c0001cf3:	1e                   	push   %ds
c0001cf4:	06                   	push   %es
c0001cf5:	0f a0                	push   %fs
c0001cf7:	0f a8                	push   %gs
c0001cf9:	60                   	pusha  
c0001cfa:	b0 20                	mov    $0x20,%al
c0001cfc:	e6 a0                	out    %al,$0xa0
c0001cfe:	e6 20                	out    %al,$0x20
c0001d00:	6a 08                	push   $0x8
c0001d02:	ff 15 40 6a 00 c0    	call   *0xc0006a40
c0001d08:	e9 03 ff ff ff       	jmp    c0001c10 <intr_exit>

c0001d0d <intr0x09entry>:
intr0x09entry():
c0001d0d:	6a 00                	push   $0x0
c0001d0f:	1e                   	push   %ds
c0001d10:	06                   	push   %es
c0001d11:	0f a0                	push   %fs
c0001d13:	0f a8                	push   %gs
c0001d15:	60                   	pusha  
c0001d16:	b0 20                	mov    $0x20,%al
c0001d18:	e6 a0                	out    %al,$0xa0
c0001d1a:	e6 20                	out    %al,$0x20
c0001d1c:	6a 09                	push   $0x9
c0001d1e:	ff 15 44 6a 00 c0    	call   *0xc0006a44
c0001d24:	e9 e7 fe ff ff       	jmp    c0001c10 <intr_exit>

c0001d29 <intr0x0aentry>:
intr0x0aentry():
c0001d29:	90                   	nop
c0001d2a:	1e                   	push   %ds
c0001d2b:	06                   	push   %es
c0001d2c:	0f a0                	push   %fs
c0001d2e:	0f a8                	push   %gs
c0001d30:	60                   	pusha  
c0001d31:	b0 20                	mov    $0x20,%al
c0001d33:	e6 a0                	out    %al,$0xa0
c0001d35:	e6 20                	out    %al,$0x20
c0001d37:	6a 0a                	push   $0xa
c0001d39:	ff 15 48 6a 00 c0    	call   *0xc0006a48
c0001d3f:	e9 cc fe ff ff       	jmp    c0001c10 <intr_exit>

c0001d44 <intr0x0bentry>:
intr0x0bentry():
c0001d44:	90                   	nop
c0001d45:	1e                   	push   %ds
c0001d46:	06                   	push   %es
c0001d47:	0f a0                	push   %fs
c0001d49:	0f a8                	push   %gs
c0001d4b:	60                   	pusha  
c0001d4c:	b0 20                	mov    $0x20,%al
c0001d4e:	e6 a0                	out    %al,$0xa0
c0001d50:	e6 20                	out    %al,$0x20
c0001d52:	6a 0b                	push   $0xb
c0001d54:	ff 15 4c 6a 00 c0    	call   *0xc0006a4c
c0001d5a:	e9 b1 fe ff ff       	jmp    c0001c10 <intr_exit>

c0001d5f <intr0x0centry>:
intr0x0centry():
c0001d5f:	6a 00                	push   $0x0
c0001d61:	1e                   	push   %ds
c0001d62:	06                   	push   %es
c0001d63:	0f a0                	push   %fs
c0001d65:	0f a8                	push   %gs
c0001d67:	60                   	pusha  
c0001d68:	b0 20                	mov    $0x20,%al
c0001d6a:	e6 a0                	out    %al,$0xa0
c0001d6c:	e6 20                	out    %al,$0x20
c0001d6e:	6a 0c                	push   $0xc
c0001d70:	ff 15 50 6a 00 c0    	call   *0xc0006a50
c0001d76:	e9 95 fe ff ff       	jmp    c0001c10 <intr_exit>

c0001d7b <intr0x0dentry>:
intr0x0dentry():
c0001d7b:	90                   	nop
c0001d7c:	1e                   	push   %ds
c0001d7d:	06                   	push   %es
c0001d7e:	0f a0                	push   %fs
c0001d80:	0f a8                	push   %gs
c0001d82:	60                   	pusha  
c0001d83:	b0 20                	mov    $0x20,%al
c0001d85:	e6 a0                	out    %al,$0xa0
c0001d87:	e6 20                	out    %al,$0x20
c0001d89:	6a 0d                	push   $0xd
c0001d8b:	ff 15 54 6a 00 c0    	call   *0xc0006a54
c0001d91:	e9 7a fe ff ff       	jmp    c0001c10 <intr_exit>

c0001d96 <intr0x0eentry>:
intr0x0eentry():
c0001d96:	90                   	nop
c0001d97:	1e                   	push   %ds
c0001d98:	06                   	push   %es
c0001d99:	0f a0                	push   %fs
c0001d9b:	0f a8                	push   %gs
c0001d9d:	60                   	pusha  
c0001d9e:	b0 20                	mov    $0x20,%al
c0001da0:	e6 a0                	out    %al,$0xa0
c0001da2:	e6 20                	out    %al,$0x20
c0001da4:	6a 0e                	push   $0xe
c0001da6:	ff 15 58 6a 00 c0    	call   *0xc0006a58
c0001dac:	e9 5f fe ff ff       	jmp    c0001c10 <intr_exit>

c0001db1 <intr0x0fentry>:
intr0x0fentry():
c0001db1:	6a 00                	push   $0x0
c0001db3:	1e                   	push   %ds
c0001db4:	06                   	push   %es
c0001db5:	0f a0                	push   %fs
c0001db7:	0f a8                	push   %gs
c0001db9:	60                   	pusha  
c0001dba:	b0 20                	mov    $0x20,%al
c0001dbc:	e6 a0                	out    %al,$0xa0
c0001dbe:	e6 20                	out    %al,$0x20
c0001dc0:	6a 0f                	push   $0xf
c0001dc2:	ff 15 5c 6a 00 c0    	call   *0xc0006a5c
c0001dc8:	e9 43 fe ff ff       	jmp    c0001c10 <intr_exit>

c0001dcd <intr0x10entry>:
intr0x10entry():
c0001dcd:	6a 00                	push   $0x0
c0001dcf:	1e                   	push   %ds
c0001dd0:	06                   	push   %es
c0001dd1:	0f a0                	push   %fs
c0001dd3:	0f a8                	push   %gs
c0001dd5:	60                   	pusha  
c0001dd6:	b0 20                	mov    $0x20,%al
c0001dd8:	e6 a0                	out    %al,$0xa0
c0001dda:	e6 20                	out    %al,$0x20
c0001ddc:	6a 10                	push   $0x10
c0001dde:	ff 15 60 6a 00 c0    	call   *0xc0006a60
c0001de4:	e9 27 fe ff ff       	jmp    c0001c10 <intr_exit>

c0001de9 <intr0x11entry>:
intr0x11entry():
c0001de9:	90                   	nop
c0001dea:	1e                   	push   %ds
c0001deb:	06                   	push   %es
c0001dec:	0f a0                	push   %fs
c0001dee:	0f a8                	push   %gs
c0001df0:	60                   	pusha  
c0001df1:	b0 20                	mov    $0x20,%al
c0001df3:	e6 a0                	out    %al,$0xa0
c0001df5:	e6 20                	out    %al,$0x20
c0001df7:	6a 11                	push   $0x11
c0001df9:	ff 15 64 6a 00 c0    	call   *0xc0006a64
c0001dff:	e9 0c fe ff ff       	jmp    c0001c10 <intr_exit>

c0001e04 <intr0x12entry>:
intr0x12entry():
c0001e04:	6a 00                	push   $0x0
c0001e06:	1e                   	push   %ds
c0001e07:	06                   	push   %es
c0001e08:	0f a0                	push   %fs
c0001e0a:	0f a8                	push   %gs
c0001e0c:	60                   	pusha  
c0001e0d:	b0 20                	mov    $0x20,%al
c0001e0f:	e6 a0                	out    %al,$0xa0
c0001e11:	e6 20                	out    %al,$0x20
c0001e13:	6a 12                	push   $0x12
c0001e15:	ff 15 68 6a 00 c0    	call   *0xc0006a68
c0001e1b:	e9 f0 fd ff ff       	jmp    c0001c10 <intr_exit>

c0001e20 <intr0x13entry>:
intr0x13entry():
c0001e20:	6a 00                	push   $0x0
c0001e22:	1e                   	push   %ds
c0001e23:	06                   	push   %es
c0001e24:	0f a0                	push   %fs
c0001e26:	0f a8                	push   %gs
c0001e28:	60                   	pusha  
c0001e29:	b0 20                	mov    $0x20,%al
c0001e2b:	e6 a0                	out    %al,$0xa0
c0001e2d:	e6 20                	out    %al,$0x20
c0001e2f:	6a 13                	push   $0x13
c0001e31:	ff 15 6c 6a 00 c0    	call   *0xc0006a6c
c0001e37:	e9 d4 fd ff ff       	jmp    c0001c10 <intr_exit>

c0001e3c <intr0x14entry>:
intr0x14entry():
c0001e3c:	6a 00                	push   $0x0
c0001e3e:	1e                   	push   %ds
c0001e3f:	06                   	push   %es
c0001e40:	0f a0                	push   %fs
c0001e42:	0f a8                	push   %gs
c0001e44:	60                   	pusha  
c0001e45:	b0 20                	mov    $0x20,%al
c0001e47:	e6 a0                	out    %al,$0xa0
c0001e49:	e6 20                	out    %al,$0x20
c0001e4b:	6a 14                	push   $0x14
c0001e4d:	ff 15 70 6a 00 c0    	call   *0xc0006a70
c0001e53:	e9 b8 fd ff ff       	jmp    c0001c10 <intr_exit>

c0001e58 <intr0x15entry>:
intr0x15entry():
c0001e58:	6a 00                	push   $0x0
c0001e5a:	1e                   	push   %ds
c0001e5b:	06                   	push   %es
c0001e5c:	0f a0                	push   %fs
c0001e5e:	0f a8                	push   %gs
c0001e60:	60                   	pusha  
c0001e61:	b0 20                	mov    $0x20,%al
c0001e63:	e6 a0                	out    %al,$0xa0
c0001e65:	e6 20                	out    %al,$0x20
c0001e67:	6a 15                	push   $0x15
c0001e69:	ff 15 74 6a 00 c0    	call   *0xc0006a74
c0001e6f:	e9 9c fd ff ff       	jmp    c0001c10 <intr_exit>

c0001e74 <intr0x16entry>:
intr0x16entry():
c0001e74:	6a 00                	push   $0x0
c0001e76:	1e                   	push   %ds
c0001e77:	06                   	push   %es
c0001e78:	0f a0                	push   %fs
c0001e7a:	0f a8                	push   %gs
c0001e7c:	60                   	pusha  
c0001e7d:	b0 20                	mov    $0x20,%al
c0001e7f:	e6 a0                	out    %al,$0xa0
c0001e81:	e6 20                	out    %al,$0x20
c0001e83:	6a 16                	push   $0x16
c0001e85:	ff 15 78 6a 00 c0    	call   *0xc0006a78
c0001e8b:	e9 80 fd ff ff       	jmp    c0001c10 <intr_exit>

c0001e90 <intr0x17entry>:
intr0x17entry():
c0001e90:	6a 00                	push   $0x0
c0001e92:	1e                   	push   %ds
c0001e93:	06                   	push   %es
c0001e94:	0f a0                	push   %fs
c0001e96:	0f a8                	push   %gs
c0001e98:	60                   	pusha  
c0001e99:	b0 20                	mov    $0x20,%al
c0001e9b:	e6 a0                	out    %al,$0xa0
c0001e9d:	e6 20                	out    %al,$0x20
c0001e9f:	6a 17                	push   $0x17
c0001ea1:	ff 15 7c 6a 00 c0    	call   *0xc0006a7c
c0001ea7:	e9 64 fd ff ff       	jmp    c0001c10 <intr_exit>

c0001eac <intr0x18entry>:
intr0x18entry():
c0001eac:	90                   	nop
c0001ead:	1e                   	push   %ds
c0001eae:	06                   	push   %es
c0001eaf:	0f a0                	push   %fs
c0001eb1:	0f a8                	push   %gs
c0001eb3:	60                   	pusha  
c0001eb4:	b0 20                	mov    $0x20,%al
c0001eb6:	e6 a0                	out    %al,$0xa0
c0001eb8:	e6 20                	out    %al,$0x20
c0001eba:	6a 18                	push   $0x18
c0001ebc:	ff 15 80 6a 00 c0    	call   *0xc0006a80
c0001ec2:	e9 49 fd ff ff       	jmp    c0001c10 <intr_exit>

c0001ec7 <intr0x19entry>:
intr0x19entry():
c0001ec7:	6a 00                	push   $0x0
c0001ec9:	1e                   	push   %ds
c0001eca:	06                   	push   %es
c0001ecb:	0f a0                	push   %fs
c0001ecd:	0f a8                	push   %gs
c0001ecf:	60                   	pusha  
c0001ed0:	b0 20                	mov    $0x20,%al
c0001ed2:	e6 a0                	out    %al,$0xa0
c0001ed4:	e6 20                	out    %al,$0x20
c0001ed6:	6a 19                	push   $0x19
c0001ed8:	ff 15 84 6a 00 c0    	call   *0xc0006a84
c0001ede:	e9 2d fd ff ff       	jmp    c0001c10 <intr_exit>

c0001ee3 <intr0x1aentry>:
intr0x1aentry():
c0001ee3:	90                   	nop
c0001ee4:	1e                   	push   %ds
c0001ee5:	06                   	push   %es
c0001ee6:	0f a0                	push   %fs
c0001ee8:	0f a8                	push   %gs
c0001eea:	60                   	pusha  
c0001eeb:	b0 20                	mov    $0x20,%al
c0001eed:	e6 a0                	out    %al,$0xa0
c0001eef:	e6 20                	out    %al,$0x20
c0001ef1:	6a 1a                	push   $0x1a
c0001ef3:	ff 15 88 6a 00 c0    	call   *0xc0006a88
c0001ef9:	e9 12 fd ff ff       	jmp    c0001c10 <intr_exit>

c0001efe <intr0x1bentry>:
intr0x1bentry():
c0001efe:	90                   	nop
c0001eff:	1e                   	push   %ds
c0001f00:	06                   	push   %es
c0001f01:	0f a0                	push   %fs
c0001f03:	0f a8                	push   %gs
c0001f05:	60                   	pusha  
c0001f06:	b0 20                	mov    $0x20,%al
c0001f08:	e6 a0                	out    %al,$0xa0
c0001f0a:	e6 20                	out    %al,$0x20
c0001f0c:	6a 1b                	push   $0x1b
c0001f0e:	ff 15 8c 6a 00 c0    	call   *0xc0006a8c
c0001f14:	e9 f7 fc ff ff       	jmp    c0001c10 <intr_exit>

c0001f19 <intr0x1centry>:
intr0x1centry():
c0001f19:	6a 00                	push   $0x0
c0001f1b:	1e                   	push   %ds
c0001f1c:	06                   	push   %es
c0001f1d:	0f a0                	push   %fs
c0001f1f:	0f a8                	push   %gs
c0001f21:	60                   	pusha  
c0001f22:	b0 20                	mov    $0x20,%al
c0001f24:	e6 a0                	out    %al,$0xa0
c0001f26:	e6 20                	out    %al,$0x20
c0001f28:	6a 1c                	push   $0x1c
c0001f2a:	ff 15 90 6a 00 c0    	call   *0xc0006a90
c0001f30:	e9 db fc ff ff       	jmp    c0001c10 <intr_exit>

c0001f35 <intr0x1dentry>:
intr0x1dentry():
c0001f35:	90                   	nop
c0001f36:	1e                   	push   %ds
c0001f37:	06                   	push   %es
c0001f38:	0f a0                	push   %fs
c0001f3a:	0f a8                	push   %gs
c0001f3c:	60                   	pusha  
c0001f3d:	b0 20                	mov    $0x20,%al
c0001f3f:	e6 a0                	out    %al,$0xa0
c0001f41:	e6 20                	out    %al,$0x20
c0001f43:	6a 1d                	push   $0x1d
c0001f45:	ff 15 94 6a 00 c0    	call   *0xc0006a94
c0001f4b:	e9 c0 fc ff ff       	jmp    c0001c10 <intr_exit>

c0001f50 <intr0x1eentry>:
intr0x1eentry():
c0001f50:	90                   	nop
c0001f51:	1e                   	push   %ds
c0001f52:	06                   	push   %es
c0001f53:	0f a0                	push   %fs
c0001f55:	0f a8                	push   %gs
c0001f57:	60                   	pusha  
c0001f58:	b0 20                	mov    $0x20,%al
c0001f5a:	e6 a0                	out    %al,$0xa0
c0001f5c:	e6 20                	out    %al,$0x20
c0001f5e:	6a 1e                	push   $0x1e
c0001f60:	ff 15 98 6a 00 c0    	call   *0xc0006a98
c0001f66:	e9 a5 fc ff ff       	jmp    c0001c10 <intr_exit>

c0001f6b <intr0x1fentry>:
intr0x1fentry():
c0001f6b:	6a 00                	push   $0x0
c0001f6d:	1e                   	push   %ds
c0001f6e:	06                   	push   %es
c0001f6f:	0f a0                	push   %fs
c0001f71:	0f a8                	push   %gs
c0001f73:	60                   	pusha  
c0001f74:	b0 20                	mov    $0x20,%al
c0001f76:	e6 a0                	out    %al,$0xa0
c0001f78:	e6 20                	out    %al,$0x20
c0001f7a:	6a 1f                	push   $0x1f
c0001f7c:	ff 15 9c 6a 00 c0    	call   *0xc0006a9c
c0001f82:	e9 89 fc ff ff       	jmp    c0001c10 <intr_exit>

c0001f87 <intr0x20entry>:
intr0x20entry():
c0001f87:	6a 00                	push   $0x0
c0001f89:	1e                   	push   %ds
c0001f8a:	06                   	push   %es
c0001f8b:	0f a0                	push   %fs
c0001f8d:	0f a8                	push   %gs
c0001f8f:	60                   	pusha  
c0001f90:	b0 20                	mov    $0x20,%al
c0001f92:	e6 a0                	out    %al,$0xa0
c0001f94:	e6 20                	out    %al,$0x20
c0001f96:	6a 20                	push   $0x20
c0001f98:	ff 15 a0 6a 00 c0    	call   *0xc0006aa0
c0001f9e:	e9 6d fc ff ff       	jmp    c0001c10 <intr_exit>

c0001fa3 <intr0x21entry>:
intr0x21entry():
c0001fa3:	6a 00                	push   $0x0
c0001fa5:	1e                   	push   %ds
c0001fa6:	06                   	push   %es
c0001fa7:	0f a0                	push   %fs
c0001fa9:	0f a8                	push   %gs
c0001fab:	60                   	pusha  
c0001fac:	b0 20                	mov    $0x20,%al
c0001fae:	e6 a0                	out    %al,$0xa0
c0001fb0:	e6 20                	out    %al,$0x20
c0001fb2:	6a 21                	push   $0x21
c0001fb4:	ff 15 a4 6a 00 c0    	call   *0xc0006aa4
c0001fba:	e9 51 fc ff ff       	jmp    c0001c10 <intr_exit>

c0001fbf <intr0x22entry>:
intr0x22entry():
c0001fbf:	6a 00                	push   $0x0
c0001fc1:	1e                   	push   %ds
c0001fc2:	06                   	push   %es
c0001fc3:	0f a0                	push   %fs
c0001fc5:	0f a8                	push   %gs
c0001fc7:	60                   	pusha  
c0001fc8:	b0 20                	mov    $0x20,%al
c0001fca:	e6 a0                	out    %al,$0xa0
c0001fcc:	e6 20                	out    %al,$0x20
c0001fce:	6a 22                	push   $0x22
c0001fd0:	ff 15 a8 6a 00 c0    	call   *0xc0006aa8
c0001fd6:	e9 35 fc ff ff       	jmp    c0001c10 <intr_exit>

c0001fdb <intr0x23entry>:
intr0x23entry():
c0001fdb:	6a 00                	push   $0x0
c0001fdd:	1e                   	push   %ds
c0001fde:	06                   	push   %es
c0001fdf:	0f a0                	push   %fs
c0001fe1:	0f a8                	push   %gs
c0001fe3:	60                   	pusha  
c0001fe4:	b0 20                	mov    $0x20,%al
c0001fe6:	e6 a0                	out    %al,$0xa0
c0001fe8:	e6 20                	out    %al,$0x20
c0001fea:	6a 23                	push   $0x23
c0001fec:	ff 15 ac 6a 00 c0    	call   *0xc0006aac
c0001ff2:	e9 19 fc ff ff       	jmp    c0001c10 <intr_exit>

c0001ff7 <intr0x24entry>:
intr0x24entry():
c0001ff7:	6a 00                	push   $0x0
c0001ff9:	1e                   	push   %ds
c0001ffa:	06                   	push   %es
c0001ffb:	0f a0                	push   %fs
c0001ffd:	0f a8                	push   %gs
c0001fff:	60                   	pusha  
c0002000:	b0 20                	mov    $0x20,%al
c0002002:	e6 a0                	out    %al,$0xa0
c0002004:	e6 20                	out    %al,$0x20
c0002006:	6a 24                	push   $0x24
c0002008:	ff 15 b0 6a 00 c0    	call   *0xc0006ab0
c000200e:	e9 fd fb ff ff       	jmp    c0001c10 <intr_exit>

c0002013 <intr0x25entry>:
intr0x25entry():
c0002013:	6a 00                	push   $0x0
c0002015:	1e                   	push   %ds
c0002016:	06                   	push   %es
c0002017:	0f a0                	push   %fs
c0002019:	0f a8                	push   %gs
c000201b:	60                   	pusha  
c000201c:	b0 20                	mov    $0x20,%al
c000201e:	e6 a0                	out    %al,$0xa0
c0002020:	e6 20                	out    %al,$0x20
c0002022:	6a 25                	push   $0x25
c0002024:	ff 15 b4 6a 00 c0    	call   *0xc0006ab4
c000202a:	e9 e1 fb ff ff       	jmp    c0001c10 <intr_exit>

c000202f <intr0x26entry>:
intr0x26entry():
c000202f:	6a 00                	push   $0x0
c0002031:	1e                   	push   %ds
c0002032:	06                   	push   %es
c0002033:	0f a0                	push   %fs
c0002035:	0f a8                	push   %gs
c0002037:	60                   	pusha  
c0002038:	b0 20                	mov    $0x20,%al
c000203a:	e6 a0                	out    %al,$0xa0
c000203c:	e6 20                	out    %al,$0x20
c000203e:	6a 26                	push   $0x26
c0002040:	ff 15 b8 6a 00 c0    	call   *0xc0006ab8
c0002046:	e9 c5 fb ff ff       	jmp    c0001c10 <intr_exit>

c000204b <intr0x27entry>:
intr0x27entry():
c000204b:	6a 00                	push   $0x0
c000204d:	1e                   	push   %ds
c000204e:	06                   	push   %es
c000204f:	0f a0                	push   %fs
c0002051:	0f a8                	push   %gs
c0002053:	60                   	pusha  
c0002054:	b0 20                	mov    $0x20,%al
c0002056:	e6 a0                	out    %al,$0xa0
c0002058:	e6 20                	out    %al,$0x20
c000205a:	6a 27                	push   $0x27
c000205c:	ff 15 bc 6a 00 c0    	call   *0xc0006abc
c0002062:	e9 a9 fb ff ff       	jmp    c0001c10 <intr_exit>

c0002067 <intr0x28entry>:
intr0x28entry():
c0002067:	6a 00                	push   $0x0
c0002069:	1e                   	push   %ds
c000206a:	06                   	push   %es
c000206b:	0f a0                	push   %fs
c000206d:	0f a8                	push   %gs
c000206f:	60                   	pusha  
c0002070:	b0 20                	mov    $0x20,%al
c0002072:	e6 a0                	out    %al,$0xa0
c0002074:	e6 20                	out    %al,$0x20
c0002076:	6a 28                	push   $0x28
c0002078:	ff 15 c0 6a 00 c0    	call   *0xc0006ac0
c000207e:	e9 8d fb ff ff       	jmp    c0001c10 <intr_exit>

c0002083 <intr0x29entry>:
intr0x29entry():
c0002083:	6a 00                	push   $0x0
c0002085:	1e                   	push   %ds
c0002086:	06                   	push   %es
c0002087:	0f a0                	push   %fs
c0002089:	0f a8                	push   %gs
c000208b:	60                   	pusha  
c000208c:	b0 20                	mov    $0x20,%al
c000208e:	e6 a0                	out    %al,$0xa0
c0002090:	e6 20                	out    %al,$0x20
c0002092:	6a 29                	push   $0x29
c0002094:	ff 15 c4 6a 00 c0    	call   *0xc0006ac4
c000209a:	e9 71 fb ff ff       	jmp    c0001c10 <intr_exit>

c000209f <intr0x2aentry>:
intr0x2aentry():
c000209f:	6a 00                	push   $0x0
c00020a1:	1e                   	push   %ds
c00020a2:	06                   	push   %es
c00020a3:	0f a0                	push   %fs
c00020a5:	0f a8                	push   %gs
c00020a7:	60                   	pusha  
c00020a8:	b0 20                	mov    $0x20,%al
c00020aa:	e6 a0                	out    %al,$0xa0
c00020ac:	e6 20                	out    %al,$0x20
c00020ae:	6a 2a                	push   $0x2a
c00020b0:	ff 15 c8 6a 00 c0    	call   *0xc0006ac8
c00020b6:	e9 55 fb ff ff       	jmp    c0001c10 <intr_exit>

c00020bb <intr0x2bentry>:
intr0x2bentry():
c00020bb:	6a 00                	push   $0x0
c00020bd:	1e                   	push   %ds
c00020be:	06                   	push   %es
c00020bf:	0f a0                	push   %fs
c00020c1:	0f a8                	push   %gs
c00020c3:	60                   	pusha  
c00020c4:	b0 20                	mov    $0x20,%al
c00020c6:	e6 a0                	out    %al,$0xa0
c00020c8:	e6 20                	out    %al,$0x20
c00020ca:	6a 2b                	push   $0x2b
c00020cc:	ff 15 cc 6a 00 c0    	call   *0xc0006acc
c00020d2:	e9 39 fb ff ff       	jmp    c0001c10 <intr_exit>

c00020d7 <intr0x2centry>:
intr0x2centry():
c00020d7:	6a 00                	push   $0x0
c00020d9:	1e                   	push   %ds
c00020da:	06                   	push   %es
c00020db:	0f a0                	push   %fs
c00020dd:	0f a8                	push   %gs
c00020df:	60                   	pusha  
c00020e0:	b0 20                	mov    $0x20,%al
c00020e2:	e6 a0                	out    %al,$0xa0
c00020e4:	e6 20                	out    %al,$0x20
c00020e6:	6a 2c                	push   $0x2c
c00020e8:	ff 15 d0 6a 00 c0    	call   *0xc0006ad0
c00020ee:	e9 1d fb ff ff       	jmp    c0001c10 <intr_exit>

c00020f3 <intr0x2dentry>:
intr0x2dentry():
c00020f3:	6a 00                	push   $0x0
c00020f5:	1e                   	push   %ds
c00020f6:	06                   	push   %es
c00020f7:	0f a0                	push   %fs
c00020f9:	0f a8                	push   %gs
c00020fb:	60                   	pusha  
c00020fc:	b0 20                	mov    $0x20,%al
c00020fe:	e6 a0                	out    %al,$0xa0
c0002100:	e6 20                	out    %al,$0x20
c0002102:	6a 2d                	push   $0x2d
c0002104:	ff 15 d4 6a 00 c0    	call   *0xc0006ad4
c000210a:	e9 01 fb ff ff       	jmp    c0001c10 <intr_exit>

c000210f <intr0x2eentry>:
intr0x2eentry():
c000210f:	6a 00                	push   $0x0
c0002111:	1e                   	push   %ds
c0002112:	06                   	push   %es
c0002113:	0f a0                	push   %fs
c0002115:	0f a8                	push   %gs
c0002117:	60                   	pusha  
c0002118:	b0 20                	mov    $0x20,%al
c000211a:	e6 a0                	out    %al,$0xa0
c000211c:	e6 20                	out    %al,$0x20
c000211e:	6a 2e                	push   $0x2e
c0002120:	ff 15 d8 6a 00 c0    	call   *0xc0006ad8
c0002126:	e9 e5 fa ff ff       	jmp    c0001c10 <intr_exit>

c000212b <intr0x2fentry>:
intr0x2fentry():
c000212b:	6a 00                	push   $0x0
c000212d:	1e                   	push   %ds
c000212e:	06                   	push   %es
c000212f:	0f a0                	push   %fs
c0002131:	0f a8                	push   %gs
c0002133:	60                   	pusha  
c0002134:	b0 20                	mov    $0x20,%al
c0002136:	e6 a0                	out    %al,$0xa0
c0002138:	e6 20                	out    %al,$0x20
c000213a:	6a 2f                	push   $0x2f
c000213c:	ff 15 dc 6a 00 c0    	call   *0xc0006adc
c0002142:	e9 c9 fa ff ff       	jmp    c0001c10 <intr_exit>
c0002147:	66 90                	xchg   %ax,%ax
c0002149:	66 90                	xchg   %ax,%ax
c000214b:	66 90                	xchg   %ax,%ax
c000214d:	66 90                	xchg   %ax,%ax
c000214f:	90                   	nop

c0002150 <put_str>:
put_str():
c0002150:	53                   	push   %ebx
c0002151:	51                   	push   %ecx
c0002152:	31 c9                	xor    %ecx,%ecx
c0002154:	8b 5c 24 0c          	mov    0xc(%esp),%ebx

c0002158 <put_str.goon>:
put_str.goon():
c0002158:	8a 0b                	mov    (%ebx),%cl
c000215a:	80 f9 00             	cmp    $0x0,%cl
c000215d:	74 0c                	je     c000216b <put_str.str_over>
c000215f:	51                   	push   %ecx
c0002160:	e8 09 00 00 00       	call   c000216e <put_char>
c0002165:	83 c4 04             	add    $0x4,%esp
c0002168:	43                   	inc    %ebx
c0002169:	eb ed                	jmp    c0002158 <put_str.goon>

c000216b <put_str.str_over>:
put_str.str_over():
c000216b:	59                   	pop    %ecx
c000216c:	5b                   	pop    %ebx
c000216d:	c3                   	ret    

c000216e <put_char>:
put_char():
c000216e:	60                   	pusha  
c000216f:	66 b8 18 00          	mov    $0x18,%ax
c0002173:	8e e8                	mov    %eax,%gs
c0002175:	66 ba d4 03          	mov    $0x3d4,%dx
c0002179:	b0 0e                	mov    $0xe,%al
c000217b:	ee                   	out    %al,(%dx)
c000217c:	66 ba d5 03          	mov    $0x3d5,%dx
c0002180:	ec                   	in     (%dx),%al
c0002181:	88 c4                	mov    %al,%ah
c0002183:	66 ba d4 03          	mov    $0x3d4,%dx
c0002187:	b0 0f                	mov    $0xf,%al
c0002189:	ee                   	out    %al,(%dx)
c000218a:	66 ba d5 03          	mov    $0x3d5,%dx
c000218e:	ec                   	in     (%dx),%al
c000218f:	66 89 c3             	mov    %ax,%bx
c0002192:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0002196:	80 f9 0d             	cmp    $0xd,%cl
c0002199:	74 3c                	je     c00021d7 <put_char.is_carriage_return>
c000219b:	80 f9 0a             	cmp    $0xa,%cl
c000219e:	74 37                	je     c00021d7 <put_char.is_carriage_return>
c00021a0:	80 f9 08             	cmp    $0x8,%cl
c00021a3:	74 02                	je     c00021a7 <put_char.is_backspace>
c00021a5:	eb 16                	jmp    c00021bd <put_char.put_other>

c00021a7 <put_char.is_backspace>:
put_char.is_backspace():
c00021a7:	66 4b                	dec    %bx
c00021a9:	66 d1 e3             	shl    %bx
c00021ac:	65 67 c6 07 20       	movb   $0x20,%gs:(%bx)
c00021b1:	66 43                	inc    %bx
c00021b3:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c00021b8:	66 d1 eb             	shr    %bx
c00021bb:	eb 60                	jmp    c000221d <put_char.set_cursor>

c00021bd <put_char.put_other>:
put_char.put_other():
c00021bd:	66 d1 e3             	shl    %bx
c00021c0:	65 67 88 0f          	mov    %cl,%gs:(%bx)
c00021c4:	66 43                	inc    %bx
c00021c6:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c00021cb:	66 d1 eb             	shr    %bx
c00021ce:	66 43                	inc    %bx
c00021d0:	66 81 fb d0 07       	cmp    $0x7d0,%bx
c00021d5:	7c 46                	jl     c000221d <put_char.set_cursor>

c00021d7 <put_char.is_carriage_return>:
put_char.is_line_feed():
c00021d7:	66 31 d2             	xor    %dx,%dx
c00021da:	66 89 d8             	mov    %bx,%ax
c00021dd:	66 be 50 00          	mov    $0x50,%si
c00021e1:	66 f7 f6             	div    %si
c00021e4:	66 29 d3             	sub    %dx,%bx

c00021e7 <put_char.is_carriage_return_end>:
put_char.is_carriage_return_end():
c00021e7:	66 83 c3 50          	add    $0x50,%bx
c00021eb:	66 81 fb d0 07       	cmp    $0x7d0,%bx

c00021f0 <put_char.is_line_feed_end>:
put_char.is_line_feed_end():
c00021f0:	7c 2b                	jl     c000221d <put_char.set_cursor>

c00021f2 <put_char.roll_screen>:
put_char.roll_screen():
c00021f2:	fc                   	cld    
c00021f3:	b9 c0 03 00 00       	mov    $0x3c0,%ecx
c00021f8:	be a0 80 0b 00       	mov    $0xb80a0,%esi
c00021fd:	bf 00 80 0b 00       	mov    $0xb8000,%edi
c0002202:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
c0002204:	bb 00 0f 00 00       	mov    $0xf00,%ebx
c0002209:	b9 50 00 00 00       	mov    $0x50,%ecx

c000220e <put_char.cls>:
put_char.cls():
c000220e:	65 66 c7 03 20 07    	movw   $0x720,%gs:(%ebx)
c0002214:	83 c3 02             	add    $0x2,%ebx
c0002217:	e2 f5                	loop   c000220e <put_char.cls>
c0002219:	66 bb 80 07          	mov    $0x780,%bx

c000221d <put_char.set_cursor>:
put_char.set_cursor():
c000221d:	66 ba d4 03          	mov    $0x3d4,%dx
c0002221:	b0 0e                	mov    $0xe,%al
c0002223:	ee                   	out    %al,(%dx)
c0002224:	66 ba d5 03          	mov    $0x3d5,%dx
c0002228:	88 f8                	mov    %bh,%al
c000222a:	ee                   	out    %al,(%dx)
c000222b:	66 ba d4 03          	mov    $0x3d4,%dx
c000222f:	b0 0f                	mov    $0xf,%al
c0002231:	ee                   	out    %al,(%dx)
c0002232:	66 ba d5 03          	mov    $0x3d5,%dx
c0002236:	88 d8                	mov    %bl,%al
c0002238:	ee                   	out    %al,(%dx)

c0002239 <put_char.put_char_done>:
put_char.put_char_done():
c0002239:	61                   	popa   
c000223a:	c3                   	ret    

c000223b <put_int>:
put_int():
c000223b:	60                   	pusha  
c000223c:	89 e5                	mov    %esp,%ebp
c000223e:	8b 45 24             	mov    0x24(%ebp),%eax
c0002241:	89 c2                	mov    %eax,%edx
c0002243:	bf 07 00 00 00       	mov    $0x7,%edi
c0002248:	b9 08 00 00 00       	mov    $0x8,%ecx
c000224d:	bb 00 67 00 c0       	mov    $0xc0006700,%ebx

c0002252 <put_int.16based_4bits>:
put_int.16based_4bits():
c0002252:	83 e2 0f             	and    $0xf,%edx
c0002255:	83 fa 09             	cmp    $0x9,%edx
c0002258:	7f 05                	jg     c000225f <put_int.is_A2F>
c000225a:	83 c2 30             	add    $0x30,%edx
c000225d:	eb 06                	jmp    c0002265 <put_int.store>

c000225f <put_int.is_A2F>:
put_int.is_A2F():
c000225f:	83 ea 0a             	sub    $0xa,%edx
c0002262:	83 c2 41             	add    $0x41,%edx

c0002265 <put_int.store>:
put_int.store():
c0002265:	88 14 3b             	mov    %dl,(%ebx,%edi,1)
c0002268:	4f                   	dec    %edi
c0002269:	c1 e8 04             	shr    $0x4,%eax
c000226c:	89 c2                	mov    %eax,%edx
c000226e:	e2 e2                	loop   c0002252 <put_int.16based_4bits>

c0002270 <put_int.ready_to_print>:
put_int.ready_to_print():
c0002270:	47                   	inc    %edi

c0002271 <put_int.skip_prefix_0>:
put_int.skip_prefix_0():
c0002271:	83 ff 08             	cmp    $0x8,%edi
c0002274:	74 0f                	je     c0002285 <put_int.full0>

c0002276 <put_int.go_on_skip>:
put_int.go_on_skip():
c0002276:	8a 8f 00 67 00 c0    	mov    -0x3fff9900(%edi),%cl
c000227c:	47                   	inc    %edi
c000227d:	80 f9 30             	cmp    $0x30,%cl
c0002280:	74 ef                	je     c0002271 <put_int.skip_prefix_0>
c0002282:	4f                   	dec    %edi
c0002283:	eb 02                	jmp    c0002287 <put_int.put_each_num>

c0002285 <put_int.full0>:
put_int.full0():
c0002285:	b1 30                	mov    $0x30,%cl

c0002287 <put_int.put_each_num>:
put_int.put_each_num():
c0002287:	51                   	push   %ecx
c0002288:	e8 e1 fe ff ff       	call   c000216e <put_char>
c000228d:	83 c4 04             	add    $0x4,%esp
c0002290:	47                   	inc    %edi
c0002291:	8a 8f 00 67 00 c0    	mov    -0x3fff9900(%edi),%cl
c0002297:	83 ff 08             	cmp    $0x8,%edi
c000229a:	7c eb                	jl     c0002287 <put_int.put_each_num>
c000229c:	61                   	popa   
c000229d:	c3                   	ret    

c000229e <set_cursor>:
set_cursor():
c000229e:	60                   	pusha  
c000229f:	66 8b 5c 24 24       	mov    0x24(%esp),%bx
c00022a4:	66 ba d4 03          	mov    $0x3d4,%dx
c00022a8:	b0 0e                	mov    $0xe,%al
c00022aa:	ee                   	out    %al,(%dx)
c00022ab:	66 ba d5 03          	mov    $0x3d5,%dx
c00022af:	88 f8                	mov    %bh,%al
c00022b1:	ee                   	out    %al,(%dx)
c00022b2:	66 ba d4 03          	mov    $0x3d4,%dx
c00022b6:	b0 0f                	mov    $0xf,%al
c00022b8:	ee                   	out    %al,(%dx)
c00022b9:	66 ba d5 03          	mov    $0x3d5,%dx
c00022bd:	88 d8                	mov    %bl,%al
c00022bf:	ee                   	out    %al,(%dx)
c00022c0:	61                   	popa   
c00022c1:	c3                   	ret    

c00022c2 <panic_spin>:
panic_spin():
c00022c2:	55                   	push   %ebp
c00022c3:	89 e5                	mov    %esp,%ebp
c00022c5:	83 ec 08             	sub    $0x8,%esp
c00022c8:	e8 e5 f6 ff ff       	call   c00019b2 <intr_disable>
c00022cd:	83 ec 0c             	sub    $0xc,%esp
c00022d0:	68 9f 43 00 c0       	push   $0xc000439f
c00022d5:	e8 76 fe ff ff       	call   c0002150 <put_str>
c00022da:	83 c4 10             	add    $0x10,%esp
c00022dd:	83 ec 0c             	sub    $0xc,%esp
c00022e0:	68 b5 43 00 c0       	push   $0xc00043b5
c00022e5:	e8 66 fe ff ff       	call   c0002150 <put_str>
c00022ea:	83 c4 10             	add    $0x10,%esp
c00022ed:	83 ec 0c             	sub    $0xc,%esp
c00022f0:	ff 75 08             	pushl  0x8(%ebp)
c00022f3:	e8 58 fe ff ff       	call   c0002150 <put_str>
c00022f8:	83 c4 10             	add    $0x10,%esp
c00022fb:	83 ec 0c             	sub    $0xc,%esp
c00022fe:	68 bf 43 00 c0       	push   $0xc00043bf
c0002303:	e8 48 fe ff ff       	call   c0002150 <put_str>
c0002308:	83 c4 10             	add    $0x10,%esp
c000230b:	83 ec 0c             	sub    $0xc,%esp
c000230e:	68 c1 43 00 c0       	push   $0xc00043c1
c0002313:	e8 38 fe ff ff       	call   c0002150 <put_str>
c0002318:	83 c4 10             	add    $0x10,%esp
c000231b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000231e:	83 ec 0c             	sub    $0xc,%esp
c0002321:	50                   	push   %eax
c0002322:	e8 14 ff ff ff       	call   c000223b <put_int>
c0002327:	83 c4 10             	add    $0x10,%esp
c000232a:	83 ec 0c             	sub    $0xc,%esp
c000232d:	68 bf 43 00 c0       	push   $0xc00043bf
c0002332:	e8 19 fe ff ff       	call   c0002150 <put_str>
c0002337:	83 c4 10             	add    $0x10,%esp
c000233a:	83 ec 0c             	sub    $0xc,%esp
c000233d:	68 c9 43 00 c0       	push   $0xc00043c9
c0002342:	e8 09 fe ff ff       	call   c0002150 <put_str>
c0002347:	83 c4 10             	add    $0x10,%esp
c000234a:	83 ec 0c             	sub    $0xc,%esp
c000234d:	ff 75 10             	pushl  0x10(%ebp)
c0002350:	e8 fb fd ff ff       	call   c0002150 <put_str>
c0002355:	83 c4 10             	add    $0x10,%esp
c0002358:	83 ec 0c             	sub    $0xc,%esp
c000235b:	68 bf 43 00 c0       	push   $0xc00043bf
c0002360:	e8 eb fd ff ff       	call   c0002150 <put_str>
c0002365:	83 c4 10             	add    $0x10,%esp
c0002368:	83 ec 0c             	sub    $0xc,%esp
c000236b:	68 d3 43 00 c0       	push   $0xc00043d3
c0002370:	e8 db fd ff ff       	call   c0002150 <put_str>
c0002375:	83 c4 10             	add    $0x10,%esp
c0002378:	83 ec 0c             	sub    $0xc,%esp
c000237b:	ff 75 14             	pushl  0x14(%ebp)
c000237e:	e8 cd fd ff ff       	call   c0002150 <put_str>
c0002383:	83 c4 10             	add    $0x10,%esp
c0002386:	83 ec 0c             	sub    $0xc,%esp
c0002389:	68 bf 43 00 c0       	push   $0xc00043bf
c000238e:	e8 bd fd ff ff       	call   c0002150 <put_str>
c0002393:	83 c4 10             	add    $0x10,%esp
c0002396:	eb fe                	jmp    c0002396 <panic_spin+0xd4>

c0002398 <bitmap_init>:
bitmap_init():
c0002398:	55                   	push   %ebp
c0002399:	89 e5                	mov    %esp,%ebp
c000239b:	83 ec 08             	sub    $0x8,%esp
c000239e:	8b 45 08             	mov    0x8(%ebp),%eax
c00023a1:	8b 10                	mov    (%eax),%edx
c00023a3:	8b 45 08             	mov    0x8(%ebp),%eax
c00023a6:	8b 40 04             	mov    0x4(%eax),%eax
c00023a9:	83 ec 04             	sub    $0x4,%esp
c00023ac:	52                   	push   %edx
c00023ad:	6a 00                	push   $0x0
c00023af:	50                   	push   %eax
c00023b0:	e8 86 07 00 00       	call   c0002b3b <memset>
c00023b5:	83 c4 10             	add    $0x10,%esp
c00023b8:	90                   	nop
c00023b9:	c9                   	leave  
c00023ba:	c3                   	ret    

c00023bb <bitmap_scan_test>:
bitmap_scan_test():
c00023bb:	55                   	push   %ebp
c00023bc:	89 e5                	mov    %esp,%ebp
c00023be:	53                   	push   %ebx
c00023bf:	83 ec 10             	sub    $0x10,%esp
c00023c2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00023c5:	c1 e8 03             	shr    $0x3,%eax
c00023c8:	89 45 f8             	mov    %eax,-0x8(%ebp)
c00023cb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00023ce:	83 e0 07             	and    $0x7,%eax
c00023d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00023d4:	8b 45 08             	mov    0x8(%ebp),%eax
c00023d7:	8b 50 04             	mov    0x4(%eax),%edx
c00023da:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00023dd:	01 d0                	add    %edx,%eax
c00023df:	0f b6 00             	movzbl (%eax),%eax
c00023e2:	0f b6 d0             	movzbl %al,%edx
c00023e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00023e8:	bb 01 00 00 00       	mov    $0x1,%ebx
c00023ed:	89 c1                	mov    %eax,%ecx
c00023ef:	d3 e3                	shl    %cl,%ebx
c00023f1:	89 d8                	mov    %ebx,%eax
c00023f3:	21 d0                	and    %edx,%eax
c00023f5:	83 c4 10             	add    $0x10,%esp
c00023f8:	5b                   	pop    %ebx
c00023f9:	5d                   	pop    %ebp
c00023fa:	c3                   	ret    

c00023fb <bitmap_scan>:
bitmap_scan():
c00023fb:	55                   	push   %ebp
c00023fc:	89 e5                	mov    %esp,%ebp
c00023fe:	83 ec 28             	sub    $0x28,%esp
c0002401:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0002408:	eb 04                	jmp    c000240e <bitmap_scan+0x13>
c000240a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c000240e:	8b 45 08             	mov    0x8(%ebp),%eax
c0002411:	8b 50 04             	mov    0x4(%eax),%edx
c0002414:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002417:	01 d0                	add    %edx,%eax
c0002419:	0f b6 00             	movzbl (%eax),%eax
c000241c:	3c ff                	cmp    $0xff,%al
c000241e:	75 0a                	jne    c000242a <bitmap_scan+0x2f>
c0002420:	8b 45 08             	mov    0x8(%ebp),%eax
c0002423:	8b 00                	mov    (%eax),%eax
c0002425:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0002428:	77 e0                	ja     c000240a <bitmap_scan+0xf>
c000242a:	8b 45 08             	mov    0x8(%ebp),%eax
c000242d:	8b 00                	mov    (%eax),%eax
c000242f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0002432:	77 19                	ja     c000244d <bitmap_scan+0x52>
c0002434:	68 e0 43 00 c0       	push   $0xc00043e0
c0002439:	68 34 44 00 c0       	push   $0xc0004434
c000243e:	6a 27                	push   $0x27
c0002440:	68 00 44 00 c0       	push   $0xc0004400
c0002445:	e8 78 fe ff ff       	call   c00022c2 <panic_spin>
c000244a:	83 c4 10             	add    $0x10,%esp
c000244d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002450:	8b 00                	mov    (%eax),%eax
c0002452:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0002455:	75 0a                	jne    c0002461 <bitmap_scan+0x66>
c0002457:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000245c:	e9 cd 00 00 00       	jmp    c000252e <bitmap_scan+0x133>
c0002461:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0002468:	eb 04                	jmp    c000246e <bitmap_scan+0x73>
c000246a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c000246e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002471:	ba 01 00 00 00       	mov    $0x1,%edx
c0002476:	89 c1                	mov    %eax,%ecx
c0002478:	d3 e2                	shl    %cl,%edx
c000247a:	89 d0                	mov    %edx,%eax
c000247c:	0f b6 d0             	movzbl %al,%edx
c000247f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002482:	8b 48 04             	mov    0x4(%eax),%ecx
c0002485:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002488:	01 c8                	add    %ecx,%eax
c000248a:	0f b6 00             	movzbl (%eax),%eax
c000248d:	0f b6 c0             	movzbl %al,%eax
c0002490:	21 d0                	and    %edx,%eax
c0002492:	85 c0                	test   %eax,%eax
c0002494:	75 d4                	jne    c000246a <bitmap_scan+0x6f>
c0002496:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002499:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c00024a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00024a3:	01 d0                	add    %edx,%eax
c00024a5:	89 45 ec             	mov    %eax,-0x14(%ebp)
c00024a8:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
c00024ac:	75 05                	jne    c00024b3 <bitmap_scan+0xb8>
c00024ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00024b1:	eb 7b                	jmp    c000252e <bitmap_scan+0x133>
c00024b3:	8b 45 08             	mov    0x8(%ebp),%eax
c00024b6:	8b 00                	mov    (%eax),%eax
c00024b8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c00024bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00024c2:	29 c2                	sub    %eax,%edx
c00024c4:	89 d0                	mov    %edx,%eax
c00024c6:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00024c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00024cc:	83 c0 01             	add    $0x1,%eax
c00024cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c00024d2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
c00024d9:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
c00024e0:	eb 3c                	jmp    c000251e <bitmap_scan+0x123>
c00024e2:	83 ec 08             	sub    $0x8,%esp
c00024e5:	ff 75 e4             	pushl  -0x1c(%ebp)
c00024e8:	ff 75 08             	pushl  0x8(%ebp)
c00024eb:	e8 cb fe ff ff       	call   c00023bb <bitmap_scan_test>
c00024f0:	83 c4 10             	add    $0x10,%esp
c00024f3:	85 c0                	test   %eax,%eax
c00024f5:	75 06                	jne    c00024fd <bitmap_scan+0x102>
c00024f7:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
c00024fb:	eb 07                	jmp    c0002504 <bitmap_scan+0x109>
c00024fd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c0002504:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002507:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000250a:	75 0e                	jne    c000251a <bitmap_scan+0x11f>
c000250c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000250f:	2b 45 0c             	sub    0xc(%ebp),%eax
c0002512:	83 c0 01             	add    $0x1,%eax
c0002515:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0002518:	eb 11                	jmp    c000252b <bitmap_scan+0x130>
c000251a:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
c000251e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002521:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002524:	89 55 e8             	mov    %edx,-0x18(%ebp)
c0002527:	85 c0                	test   %eax,%eax
c0002529:	75 b7                	jne    c00024e2 <bitmap_scan+0xe7>
c000252b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000252e:	c9                   	leave  
c000252f:	c3                   	ret    

c0002530 <bitmap_set>:
bitmap_set():
c0002530:	55                   	push   %ebp
c0002531:	89 e5                	mov    %esp,%ebp
c0002533:	56                   	push   %esi
c0002534:	53                   	push   %ebx
c0002535:	83 ec 20             	sub    $0x20,%esp
c0002538:	8b 45 10             	mov    0x10(%ebp),%eax
c000253b:	88 45 e4             	mov    %al,-0x1c(%ebp)
c000253e:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c0002542:	74 1f                	je     c0002563 <bitmap_set+0x33>
c0002544:	80 7d e4 01          	cmpb   $0x1,-0x1c(%ebp)
c0002548:	74 19                	je     c0002563 <bitmap_set+0x33>
c000254a:	68 14 44 00 c0       	push   $0xc0004414
c000254f:	68 40 44 00 c0       	push   $0xc0004440
c0002554:	6a 50                	push   $0x50
c0002556:	68 00 44 00 c0       	push   $0xc0004400
c000255b:	e8 62 fd ff ff       	call   c00022c2 <panic_spin>
c0002560:	83 c4 10             	add    $0x10,%esp
c0002563:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002566:	c1 e8 03             	shr    $0x3,%eax
c0002569:	89 45 f4             	mov    %eax,-0xc(%ebp)
c000256c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000256f:	83 e0 07             	and    $0x7,%eax
c0002572:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0002575:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c0002579:	74 2f                	je     c00025aa <bitmap_set+0x7a>
c000257b:	8b 45 08             	mov    0x8(%ebp),%eax
c000257e:	8b 50 04             	mov    0x4(%eax),%edx
c0002581:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002584:	01 c2                	add    %eax,%edx
c0002586:	8b 45 08             	mov    0x8(%ebp),%eax
c0002589:	8b 48 04             	mov    0x4(%eax),%ecx
c000258c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000258f:	01 c8                	add    %ecx,%eax
c0002591:	0f b6 00             	movzbl (%eax),%eax
c0002594:	89 c6                	mov    %eax,%esi
c0002596:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002599:	bb 01 00 00 00       	mov    $0x1,%ebx
c000259e:	89 c1                	mov    %eax,%ecx
c00025a0:	d3 e3                	shl    %cl,%ebx
c00025a2:	89 d8                	mov    %ebx,%eax
c00025a4:	09 f0                	or     %esi,%eax
c00025a6:	88 02                	mov    %al,(%edx)
c00025a8:	eb 2f                	jmp    c00025d9 <bitmap_set+0xa9>
c00025aa:	8b 45 08             	mov    0x8(%ebp),%eax
c00025ad:	8b 50 04             	mov    0x4(%eax),%edx
c00025b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00025b3:	01 c2                	add    %eax,%edx
c00025b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00025b8:	8b 48 04             	mov    0x4(%eax),%ecx
c00025bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00025be:	01 c8                	add    %ecx,%eax
c00025c0:	0f b6 00             	movzbl (%eax),%eax
c00025c3:	89 c3                	mov    %eax,%ebx
c00025c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00025c8:	be 01 00 00 00       	mov    $0x1,%esi
c00025cd:	89 c1                	mov    %eax,%ecx
c00025cf:	d3 e6                	shl    %cl,%esi
c00025d1:	89 f0                	mov    %esi,%eax
c00025d3:	f7 d0                	not    %eax
c00025d5:	21 d8                	and    %ebx,%eax
c00025d7:	88 02                	mov    %al,(%edx)
c00025d9:	90                   	nop
c00025da:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00025dd:	5b                   	pop    %ebx
c00025de:	5e                   	pop    %esi
c00025df:	5d                   	pop    %ebp
c00025e0:	c3                   	ret    

c00025e1 <vaddr_get>:
vaddr_get():
c00025e1:	55                   	push   %ebp
c00025e2:	89 e5                	mov    %esp,%ebp
c00025e4:	83 ec 18             	sub    $0x18,%esp
c00025e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00025ee:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
c00025f5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00025fc:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0002600:	75 5c                	jne    c000265e <vaddr_get+0x7d>
c0002602:	83 ec 08             	sub    $0x8,%esp
c0002605:	ff 75 0c             	pushl  0xc(%ebp)
c0002608:	68 f4 6a 00 c0       	push   $0xc0006af4
c000260d:	e8 e9 fd ff ff       	call   c00023fb <bitmap_scan>
c0002612:	83 c4 10             	add    $0x10,%esp
c0002615:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0002618:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c000261c:	75 28                	jne    c0002646 <vaddr_get+0x65>
c000261e:	b8 00 00 00 00       	mov    $0x0,%eax
c0002623:	eb 3c                	jmp    c0002661 <vaddr_get+0x80>
c0002625:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002628:	8d 50 01             	lea    0x1(%eax),%edx
c000262b:	89 55 f0             	mov    %edx,-0x10(%ebp)
c000262e:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002631:	01 d0                	add    %edx,%eax
c0002633:	83 ec 04             	sub    $0x4,%esp
c0002636:	6a 01                	push   $0x1
c0002638:	50                   	push   %eax
c0002639:	68 f4 6a 00 c0       	push   $0xc0006af4
c000263e:	e8 ed fe ff ff       	call   c0002530 <bitmap_set>
c0002643:	83 c4 10             	add    $0x10,%esp
c0002646:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002649:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000264c:	72 d7                	jb     c0002625 <vaddr_get+0x44>
c000264e:	a1 fc 6a 00 c0       	mov    0xc0006afc,%eax
c0002653:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002656:	c1 e2 0c             	shl    $0xc,%edx
c0002659:	01 d0                	add    %edx,%eax
c000265b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c000265e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002661:	c9                   	leave  
c0002662:	c3                   	ret    

c0002663 <pte_ptr>:
pte_ptr():
c0002663:	55                   	push   %ebp
c0002664:	89 e5                	mov    %esp,%ebp
c0002666:	83 ec 10             	sub    $0x10,%esp
c0002669:	8b 45 08             	mov    0x8(%ebp),%eax
c000266c:	25 00 00 c0 ff       	and    $0xffc00000,%eax
c0002671:	c1 e8 0a             	shr    $0xa,%eax
c0002674:	89 c2                	mov    %eax,%edx
c0002676:	8b 45 08             	mov    0x8(%ebp),%eax
c0002679:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c000267e:	c1 e8 0c             	shr    $0xc,%eax
c0002681:	c1 e0 02             	shl    $0x2,%eax
c0002684:	01 d0                	add    %edx,%eax
c0002686:	2d 00 00 40 00       	sub    $0x400000,%eax
c000268b:	89 45 fc             	mov    %eax,-0x4(%ebp)
c000268e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002691:	c9                   	leave  
c0002692:	c3                   	ret    

c0002693 <pde_ptr>:
pde_ptr():
c0002693:	55                   	push   %ebp
c0002694:	89 e5                	mov    %esp,%ebp
c0002696:	83 ec 10             	sub    $0x10,%esp
c0002699:	8b 45 08             	mov    0x8(%ebp),%eax
c000269c:	c1 e8 16             	shr    $0x16,%eax
c000269f:	05 00 fc ff 3f       	add    $0x3ffffc00,%eax
c00026a4:	c1 e0 02             	shl    $0x2,%eax
c00026a7:	89 45 fc             	mov    %eax,-0x4(%ebp)
c00026aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00026ad:	c9                   	leave  
c00026ae:	c3                   	ret    

c00026af <palloc>:
palloc():
c00026af:	55                   	push   %ebp
c00026b0:	89 e5                	mov    %esp,%ebp
c00026b2:	83 ec 18             	sub    $0x18,%esp
c00026b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00026b8:	83 ec 08             	sub    $0x8,%esp
c00026bb:	6a 01                	push   $0x1
c00026bd:	50                   	push   %eax
c00026be:	e8 38 fd ff ff       	call   c00023fb <bitmap_scan>
c00026c3:	83 c4 10             	add    $0x10,%esp
c00026c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00026c9:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c00026cd:	75 07                	jne    c00026d6 <palloc+0x27>
c00026cf:	b8 00 00 00 00       	mov    $0x0,%eax
c00026d4:	eb 2b                	jmp    c0002701 <palloc+0x52>
c00026d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00026d9:	8b 45 08             	mov    0x8(%ebp),%eax
c00026dc:	83 ec 04             	sub    $0x4,%esp
c00026df:	6a 01                	push   $0x1
c00026e1:	52                   	push   %edx
c00026e2:	50                   	push   %eax
c00026e3:	e8 48 fe ff ff       	call   c0002530 <bitmap_set>
c00026e8:	83 c4 10             	add    $0x10,%esp
c00026eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00026ee:	c1 e0 0c             	shl    $0xc,%eax
c00026f1:	89 c2                	mov    %eax,%edx
c00026f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00026f6:	8b 40 08             	mov    0x8(%eax),%eax
c00026f9:	01 d0                	add    %edx,%eax
c00026fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00026fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002701:	c9                   	leave  
c0002702:	c3                   	ret    

c0002703 <page_table_add>:
page_table_add():
c0002703:	55                   	push   %ebp
c0002704:	89 e5                	mov    %esp,%ebp
c0002706:	83 ec 28             	sub    $0x28,%esp
c0002709:	8b 45 08             	mov    0x8(%ebp),%eax
c000270c:	89 45 f4             	mov    %eax,-0xc(%ebp)
c000270f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002712:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0002715:	ff 75 f4             	pushl  -0xc(%ebp)
c0002718:	e8 76 ff ff ff       	call   c0002693 <pde_ptr>
c000271d:	83 c4 04             	add    $0x4,%esp
c0002720:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0002723:	ff 75 f4             	pushl  -0xc(%ebp)
c0002726:	e8 38 ff ff ff       	call   c0002663 <pte_ptr>
c000272b:	83 c4 04             	add    $0x4,%esp
c000272e:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0002731:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002734:	8b 00                	mov    (%eax),%eax
c0002736:	83 e0 01             	and    $0x1,%eax
c0002739:	85 c0                	test   %eax,%eax
c000273b:	74 6e                	je     c00027ab <page_table_add+0xa8>
c000273d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002740:	8b 00                	mov    (%eax),%eax
c0002742:	83 e0 01             	and    $0x1,%eax
c0002745:	85 c0                	test   %eax,%eax
c0002747:	74 19                	je     c0002762 <page_table_add+0x5f>
c0002749:	68 4c 44 00 c0       	push   $0xc000444c
c000274e:	68 60 45 00 c0       	push   $0xc0004560
c0002753:	6a 7d                	push   $0x7d
c0002755:	68 61 44 00 c0       	push   $0xc0004461
c000275a:	e8 63 fb ff ff       	call   c00022c2 <panic_spin>
c000275f:	83 c4 10             	add    $0x10,%esp
c0002762:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002765:	8b 00                	mov    (%eax),%eax
c0002767:	83 e0 01             	and    $0x1,%eax
c000276a:	85 c0                	test   %eax,%eax
c000276c:	75 12                	jne    c0002780 <page_table_add+0x7d>
c000276e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002771:	83 c8 07             	or     $0x7,%eax
c0002774:	89 c2                	mov    %eax,%edx
c0002776:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002779:	89 10                	mov    %edx,(%eax)
c000277b:	e9 9b 00 00 00       	jmp    c000281b <page_table_add+0x118>
c0002780:	68 71 44 00 c0       	push   $0xc0004471
c0002785:	68 60 45 00 c0       	push   $0xc0004560
c000278a:	68 82 00 00 00       	push   $0x82
c000278f:	68 61 44 00 c0       	push   $0xc0004461
c0002794:	e8 29 fb ff ff       	call   c00022c2 <panic_spin>
c0002799:	83 c4 10             	add    $0x10,%esp
c000279c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000279f:	83 c8 07             	or     $0x7,%eax
c00027a2:	89 c2                	mov    %eax,%edx
c00027a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00027a7:	89 10                	mov    %edx,(%eax)
c00027a9:	eb 70                	jmp    c000281b <page_table_add+0x118>
c00027ab:	83 ec 0c             	sub    $0xc,%esp
c00027ae:	68 00 6b 00 c0       	push   $0xc0006b00
c00027b3:	e8 f7 fe ff ff       	call   c00026af <palloc>
c00027b8:	83 c4 10             	add    $0x10,%esp
c00027bb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c00027be:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00027c1:	83 c8 07             	or     $0x7,%eax
c00027c4:	89 c2                	mov    %eax,%edx
c00027c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00027c9:	89 10                	mov    %edx,(%eax)
c00027cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00027ce:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c00027d3:	83 ec 04             	sub    $0x4,%esp
c00027d6:	68 00 10 00 00       	push   $0x1000
c00027db:	6a 00                	push   $0x0
c00027dd:	50                   	push   %eax
c00027de:	e8 58 03 00 00       	call   c0002b3b <memset>
c00027e3:	83 c4 10             	add    $0x10,%esp
c00027e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00027e9:	8b 00                	mov    (%eax),%eax
c00027eb:	83 e0 01             	and    $0x1,%eax
c00027ee:	85 c0                	test   %eax,%eax
c00027f0:	74 1c                	je     c000280e <page_table_add+0x10b>
c00027f2:	68 4c 44 00 c0       	push   $0xc000444c
c00027f7:	68 60 45 00 c0       	push   $0xc0004560
c00027fc:	68 92 00 00 00       	push   $0x92
c0002801:	68 61 44 00 c0       	push   $0xc0004461
c0002806:	e8 b7 fa ff ff       	call   c00022c2 <panic_spin>
c000280b:	83 c4 10             	add    $0x10,%esp
c000280e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002811:	83 c8 07             	or     $0x7,%eax
c0002814:	89 c2                	mov    %eax,%edx
c0002816:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002819:	89 10                	mov    %edx,(%eax)
c000281b:	90                   	nop
c000281c:	c9                   	leave  
c000281d:	c3                   	ret    

c000281e <malloc_page>:
malloc_page():
c000281e:	55                   	push   %ebp
c000281f:	89 e5                	mov    %esp,%ebp
c0002821:	83 ec 28             	sub    $0x28,%esp
c0002824:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002828:	74 09                	je     c0002833 <malloc_page+0x15>
c000282a:	81 7d 0c ff 0e 00 00 	cmpl   $0xeff,0xc(%ebp)
c0002831:	76 1c                	jbe    c000284f <malloc_page+0x31>
c0002833:	68 7c 44 00 c0       	push   $0xc000447c
c0002838:	68 70 45 00 c0       	push   $0xc0004570
c000283d:	68 99 00 00 00       	push   $0x99
c0002842:	68 61 44 00 c0       	push   $0xc0004461
c0002847:	e8 76 fa ff ff       	call   c00022c2 <panic_spin>
c000284c:	83 c4 10             	add    $0x10,%esp
c000284f:	83 ec 08             	sub    $0x8,%esp
c0002852:	ff 75 0c             	pushl  0xc(%ebp)
c0002855:	ff 75 08             	pushl  0x8(%ebp)
c0002858:	e8 84 fd ff ff       	call   c00025e1 <vaddr_get>
c000285d:	83 c4 10             	add    $0x10,%esp
c0002860:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0002863:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002867:	75 07                	jne    c0002870 <malloc_page+0x52>
c0002869:	b8 00 00 00 00       	mov    $0x0,%eax
c000286e:	eb 6e                	jmp    c00028de <malloc_page+0xc0>
c0002870:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002873:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002876:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002879:	89 45 f0             	mov    %eax,-0x10(%ebp)
c000287c:	8b 45 08             	mov    0x8(%ebp),%eax
c000287f:	83 e0 01             	and    $0x1,%eax
c0002882:	85 c0                	test   %eax,%eax
c0002884:	74 07                	je     c000288d <malloc_page+0x6f>
c0002886:	b8 00 6b 00 c0       	mov    $0xc0006b00,%eax
c000288b:	eb 05                	jmp    c0002892 <malloc_page+0x74>
c000288d:	b8 e4 6a 00 c0       	mov    $0xc0006ae4,%eax
c0002892:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0002895:	eb 37                	jmp    c00028ce <malloc_page+0xb0>
c0002897:	83 ec 0c             	sub    $0xc,%esp
c000289a:	ff 75 e8             	pushl  -0x18(%ebp)
c000289d:	e8 0d fe ff ff       	call   c00026af <palloc>
c00028a2:	83 c4 10             	add    $0x10,%esp
c00028a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c00028a8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00028ac:	75 07                	jne    c00028b5 <malloc_page+0x97>
c00028ae:	b8 00 00 00 00       	mov    $0x0,%eax
c00028b3:	eb 29                	jmp    c00028de <malloc_page+0xc0>
c00028b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00028b8:	83 ec 08             	sub    $0x8,%esp
c00028bb:	ff 75 e4             	pushl  -0x1c(%ebp)
c00028be:	50                   	push   %eax
c00028bf:	e8 3f fe ff ff       	call   c0002703 <page_table_add>
c00028c4:	83 c4 10             	add    $0x10,%esp
c00028c7:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
c00028ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00028d1:	8d 50 ff             	lea    -0x1(%eax),%edx
c00028d4:	89 55 f0             	mov    %edx,-0x10(%ebp)
c00028d7:	85 c0                	test   %eax,%eax
c00028d9:	75 bc                	jne    c0002897 <malloc_page+0x79>
c00028db:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00028de:	c9                   	leave  
c00028df:	c3                   	ret    

c00028e0 <get_kernel_pages>:
get_kernel_pages():
c00028e0:	55                   	push   %ebp
c00028e1:	89 e5                	mov    %esp,%ebp
c00028e3:	83 ec 18             	sub    $0x18,%esp
c00028e6:	83 ec 08             	sub    $0x8,%esp
c00028e9:	ff 75 08             	pushl  0x8(%ebp)
c00028ec:	6a 01                	push   $0x1
c00028ee:	e8 2b ff ff ff       	call   c000281e <malloc_page>
c00028f3:	83 c4 10             	add    $0x10,%esp
c00028f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00028f9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00028fd:	74 17                	je     c0002916 <get_kernel_pages+0x36>
c00028ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0002902:	c1 e0 0c             	shl    $0xc,%eax
c0002905:	83 ec 04             	sub    $0x4,%esp
c0002908:	50                   	push   %eax
c0002909:	6a 00                	push   $0x0
c000290b:	ff 75 f4             	pushl  -0xc(%ebp)
c000290e:	e8 28 02 00 00       	call   c0002b3b <memset>
c0002913:	83 c4 10             	add    $0x10,%esp
c0002916:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002919:	c9                   	leave  
c000291a:	c3                   	ret    

c000291b <mem_pool_init>:
mem_pool_init():
c000291b:	55                   	push   %ebp
c000291c:	89 e5                	mov    %esp,%ebp
c000291e:	83 ec 38             	sub    $0x38,%esp
c0002921:	83 ec 0c             	sub    $0xc,%esp
c0002924:	68 98 44 00 c0       	push   $0xc0004498
c0002929:	e8 22 f8 ff ff       	call   c0002150 <put_str>
c000292e:	83 c4 10             	add    $0x10,%esp
c0002931:	c7 45 f4 00 00 10 00 	movl   $0x100000,-0xc(%ebp)
c0002938:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000293b:	05 00 00 10 00       	add    $0x100000,%eax
c0002940:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0002943:	8b 45 08             	mov    0x8(%ebp),%eax
c0002946:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0002949:	89 45 ec             	mov    %eax,-0x14(%ebp)
c000294c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000294f:	c1 e8 0c             	shr    $0xc,%eax
c0002952:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
c0002956:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c000295a:	66 d1 e8             	shr    %ax
c000295d:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
c0002961:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c0002965:	66 2b 45 e8          	sub    -0x18(%ebp),%ax
c0002969:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
c000296d:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0002971:	66 c1 e8 03          	shr    $0x3,%ax
c0002975:	0f b7 c0             	movzwl %ax,%eax
c0002978:	89 45 e0             	mov    %eax,-0x20(%ebp)
c000297b:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c000297f:	66 c1 e8 03          	shr    $0x3,%ax
c0002983:	0f b7 c0             	movzwl %ax,%eax
c0002986:	89 45 dc             	mov    %eax,-0x24(%ebp)
c0002989:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000298c:	89 45 d8             	mov    %eax,-0x28(%ebp)
c000298f:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0002993:	c1 e0 0c             	shl    $0xc,%eax
c0002996:	89 c2                	mov    %eax,%edx
c0002998:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000299b:	01 d0                	add    %edx,%eax
c000299d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
c00029a0:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00029a3:	a3 08 6b 00 c0       	mov    %eax,0xc0006b08
c00029a8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00029ab:	a3 ec 6a 00 c0       	mov    %eax,0xc0006aec
c00029b0:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c00029b4:	c1 e0 0c             	shl    $0xc,%eax
c00029b7:	a3 0c 6b 00 c0       	mov    %eax,0xc0006b0c
c00029bc:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c00029c0:	c1 e0 0c             	shl    $0xc,%eax
c00029c3:	a3 f0 6a 00 c0       	mov    %eax,0xc0006af0
c00029c8:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00029cb:	a3 00 6b 00 c0       	mov    %eax,0xc0006b00
c00029d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00029d3:	a3 e4 6a 00 c0       	mov    %eax,0xc0006ae4
c00029d8:	c7 05 04 6b 00 c0 00 	movl   $0xc009a000,0xc0006b04
c00029df:	a0 09 c0 
c00029e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00029e5:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c00029ea:	a3 e8 6a 00 c0       	mov    %eax,0xc0006ae8
c00029ef:	83 ec 0c             	sub    $0xc,%esp
c00029f2:	68 b0 44 00 c0       	push   $0xc00044b0
c00029f7:	e8 54 f7 ff ff       	call   c0002150 <put_str>
c00029fc:	83 c4 10             	add    $0x10,%esp
c00029ff:	a1 04 6b 00 c0       	mov    0xc0006b04,%eax
c0002a04:	83 ec 0c             	sub    $0xc,%esp
c0002a07:	50                   	push   %eax
c0002a08:	e8 2e f8 ff ff       	call   c000223b <put_int>
c0002a0d:	83 c4 10             	add    $0x10,%esp
c0002a10:	83 ec 0c             	sub    $0xc,%esp
c0002a13:	68 d0 44 00 c0       	push   $0xc00044d0
c0002a18:	e8 33 f7 ff ff       	call   c0002150 <put_str>
c0002a1d:	83 c4 10             	add    $0x10,%esp
c0002a20:	a1 08 6b 00 c0       	mov    0xc0006b08,%eax
c0002a25:	83 ec 0c             	sub    $0xc,%esp
c0002a28:	50                   	push   %eax
c0002a29:	e8 0d f8 ff ff       	call   c000223b <put_int>
c0002a2e:	83 c4 10             	add    $0x10,%esp
c0002a31:	83 ec 0c             	sub    $0xc,%esp
c0002a34:	68 ed 44 00 c0       	push   $0xc00044ed
c0002a39:	e8 12 f7 ff ff       	call   c0002150 <put_str>
c0002a3e:	83 c4 10             	add    $0x10,%esp
c0002a41:	83 ec 0c             	sub    $0xc,%esp
c0002a44:	68 ef 44 00 c0       	push   $0xc00044ef
c0002a49:	e8 02 f7 ff ff       	call   c0002150 <put_str>
c0002a4e:	83 c4 10             	add    $0x10,%esp
c0002a51:	a1 e8 6a 00 c0       	mov    0xc0006ae8,%eax
c0002a56:	83 ec 0c             	sub    $0xc,%esp
c0002a59:	50                   	push   %eax
c0002a5a:	e8 dc f7 ff ff       	call   c000223b <put_int>
c0002a5f:	83 c4 10             	add    $0x10,%esp
c0002a62:	83 ec 0c             	sub    $0xc,%esp
c0002a65:	68 0d 45 00 c0       	push   $0xc000450d
c0002a6a:	e8 e1 f6 ff ff       	call   c0002150 <put_str>
c0002a6f:	83 c4 10             	add    $0x10,%esp
c0002a72:	a1 ec 6a 00 c0       	mov    0xc0006aec,%eax
c0002a77:	83 ec 0c             	sub    $0xc,%esp
c0002a7a:	50                   	push   %eax
c0002a7b:	e8 bb f7 ff ff       	call   c000223b <put_int>
c0002a80:	83 c4 10             	add    $0x10,%esp
c0002a83:	83 ec 0c             	sub    $0xc,%esp
c0002a86:	68 ed 44 00 c0       	push   $0xc00044ed
c0002a8b:	e8 c0 f6 ff ff       	call   c0002150 <put_str>
c0002a90:	83 c4 10             	add    $0x10,%esp
c0002a93:	83 ec 0c             	sub    $0xc,%esp
c0002a96:	68 00 6b 00 c0       	push   $0xc0006b00
c0002a9b:	e8 f8 f8 ff ff       	call   c0002398 <bitmap_init>
c0002aa0:	83 c4 10             	add    $0x10,%esp
c0002aa3:	83 ec 0c             	sub    $0xc,%esp
c0002aa6:	68 e4 6a 00 c0       	push   $0xc0006ae4
c0002aab:	e8 e8 f8 ff ff       	call   c0002398 <bitmap_init>
c0002ab0:	83 c4 10             	add    $0x10,%esp
c0002ab3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002ab6:	a3 f4 6a 00 c0       	mov    %eax,0xc0006af4
c0002abb:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0002abe:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0002ac1:	01 d0                	add    %edx,%eax
c0002ac3:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c0002ac8:	a3 f8 6a 00 c0       	mov    %eax,0xc0006af8
c0002acd:	c7 05 fc 6a 00 c0 00 	movl   $0xc0100000,0xc0006afc
c0002ad4:	00 10 c0 
c0002ad7:	83 ec 0c             	sub    $0xc,%esp
c0002ada:	68 f4 6a 00 c0       	push   $0xc0006af4
c0002adf:	e8 b4 f8 ff ff       	call   c0002398 <bitmap_init>
c0002ae4:	83 c4 10             	add    $0x10,%esp
c0002ae7:	83 ec 0c             	sub    $0xc,%esp
c0002aea:	68 28 45 00 c0       	push   $0xc0004528
c0002aef:	e8 5c f6 ff ff       	call   c0002150 <put_str>
c0002af4:	83 c4 10             	add    $0x10,%esp
c0002af7:	90                   	nop
c0002af8:	c9                   	leave  
c0002af9:	c3                   	ret    

c0002afa <mem_init>:
mem_init():
c0002afa:	55                   	push   %ebp
c0002afb:	89 e5                	mov    %esp,%ebp
c0002afd:	83 ec 18             	sub    $0x18,%esp
c0002b00:	83 ec 0c             	sub    $0xc,%esp
c0002b03:	68 3f 45 00 c0       	push   $0xc000453f
c0002b08:	e8 43 f6 ff ff       	call   c0002150 <put_str>
c0002b0d:	83 c4 10             	add    $0x10,%esp
c0002b10:	b8 00 0b 00 00       	mov    $0xb00,%eax
c0002b15:	8b 00                	mov    (%eax),%eax
c0002b17:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002b1a:	83 ec 0c             	sub    $0xc,%esp
c0002b1d:	ff 75 f4             	pushl  -0xc(%ebp)
c0002b20:	e8 f6 fd ff ff       	call   c000291b <mem_pool_init>
c0002b25:	83 c4 10             	add    $0x10,%esp
c0002b28:	83 ec 0c             	sub    $0xc,%esp
c0002b2b:	68 4f 45 00 c0       	push   $0xc000454f
c0002b30:	e8 1b f6 ff ff       	call   c0002150 <put_str>
c0002b35:	83 c4 10             	add    $0x10,%esp
c0002b38:	90                   	nop
c0002b39:	c9                   	leave  
c0002b3a:	c3                   	ret    

c0002b3b <memset>:
memset():
c0002b3b:	55                   	push   %ebp
c0002b3c:	89 e5                	mov    %esp,%ebp
c0002b3e:	83 ec 28             	sub    $0x28,%esp
c0002b41:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002b44:	88 45 e4             	mov    %al,-0x1c(%ebp)
c0002b47:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002b4b:	75 19                	jne    c0002b66 <memset+0x2b>
c0002b4d:	68 7c 45 00 c0       	push   $0xc000457c
c0002b52:	68 f0 45 00 c0       	push   $0xc00045f0
c0002b57:	6a 07                	push   $0x7
c0002b59:	68 89 45 00 c0       	push   $0xc0004589
c0002b5e:	e8 5f f7 ff ff       	call   c00022c2 <panic_spin>
c0002b63:	83 c4 10             	add    $0x10,%esp
c0002b66:	8b 45 08             	mov    0x8(%ebp),%eax
c0002b69:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002b6c:	eb 0f                	jmp    c0002b7d <memset+0x42>
c0002b6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002b71:	8d 50 01             	lea    0x1(%eax),%edx
c0002b74:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0002b77:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c0002b7b:	88 10                	mov    %dl,(%eax)
c0002b7d:	8b 45 10             	mov    0x10(%ebp),%eax
c0002b80:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002b83:	89 55 10             	mov    %edx,0x10(%ebp)
c0002b86:	85 c0                	test   %eax,%eax
c0002b88:	75 e4                	jne    c0002b6e <memset+0x33>
c0002b8a:	90                   	nop
c0002b8b:	c9                   	leave  
c0002b8c:	c3                   	ret    

c0002b8d <memcpy>:
memcpy():
c0002b8d:	55                   	push   %ebp
c0002b8e:	89 e5                	mov    %esp,%ebp
c0002b90:	83 ec 18             	sub    $0x18,%esp
c0002b93:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002b97:	74 06                	je     c0002b9f <memcpy+0x12>
c0002b99:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002b9d:	75 19                	jne    c0002bb8 <memcpy+0x2b>
c0002b9f:	68 96 45 00 c0       	push   $0xc0004596
c0002ba4:	68 f8 45 00 c0       	push   $0xc00045f8
c0002ba9:	6a 0f                	push   $0xf
c0002bab:	68 89 45 00 c0       	push   $0xc0004589
c0002bb0:	e8 0d f7 ff ff       	call   c00022c2 <panic_spin>
c0002bb5:	83 c4 10             	add    $0x10,%esp
c0002bb8:	8b 45 08             	mov    0x8(%ebp),%eax
c0002bbb:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002bbe:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002bc1:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0002bc4:	eb 17                	jmp    c0002bdd <memcpy+0x50>
c0002bc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002bc9:	8d 50 01             	lea    0x1(%eax),%edx
c0002bcc:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0002bcf:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002bd2:	8d 4a 01             	lea    0x1(%edx),%ecx
c0002bd5:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0002bd8:	0f b6 12             	movzbl (%edx),%edx
c0002bdb:	88 10                	mov    %dl,(%eax)
c0002bdd:	8b 45 10             	mov    0x10(%ebp),%eax
c0002be0:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002be3:	89 55 10             	mov    %edx,0x10(%ebp)
c0002be6:	85 c0                	test   %eax,%eax
c0002be8:	75 dc                	jne    c0002bc6 <memcpy+0x39>
c0002bea:	90                   	nop
c0002beb:	c9                   	leave  
c0002bec:	c3                   	ret    

c0002bed <memcmp>:
memcmp():
c0002bed:	55                   	push   %ebp
c0002bee:	89 e5                	mov    %esp,%ebp
c0002bf0:	83 ec 18             	sub    $0x18,%esp
c0002bf3:	8b 45 08             	mov    0x8(%ebp),%eax
c0002bf6:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002bf9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002bfc:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0002bff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002c03:	75 57                	jne    c0002c5c <memcmp+0x6f>
c0002c05:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0002c09:	75 51                	jne    c0002c5c <memcmp+0x6f>
c0002c0b:	68 b3 45 00 c0       	push   $0xc00045b3
c0002c10:	68 00 46 00 c0       	push   $0xc0004600
c0002c15:	6a 1a                	push   $0x1a
c0002c17:	68 89 45 00 c0       	push   $0xc0004589
c0002c1c:	e8 a1 f6 ff ff       	call   c00022c2 <panic_spin>
c0002c21:	83 c4 10             	add    $0x10,%esp
c0002c24:	eb 36                	jmp    c0002c5c <memcmp+0x6f>
c0002c26:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002c29:	0f b6 10             	movzbl (%eax),%edx
c0002c2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002c2f:	0f b6 00             	movzbl (%eax),%eax
c0002c32:	38 c2                	cmp    %al,%dl
c0002c34:	74 1e                	je     c0002c54 <memcmp+0x67>
c0002c36:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002c39:	0f b6 10             	movzbl (%eax),%edx
c0002c3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002c3f:	0f b6 00             	movzbl (%eax),%eax
c0002c42:	38 c2                	cmp    %al,%dl
c0002c44:	7e 07                	jle    c0002c4d <memcmp+0x60>
c0002c46:	b8 01 00 00 00       	mov    $0x1,%eax
c0002c4b:	eb 21                	jmp    c0002c6e <memcmp+0x81>
c0002c4d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002c52:	eb 1a                	jmp    c0002c6e <memcmp+0x81>
c0002c54:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0002c58:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0002c5c:	8b 45 10             	mov    0x10(%ebp),%eax
c0002c5f:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002c62:	89 55 10             	mov    %edx,0x10(%ebp)
c0002c65:	85 c0                	test   %eax,%eax
c0002c67:	75 bd                	jne    c0002c26 <memcmp+0x39>
c0002c69:	b8 00 00 00 00       	mov    $0x0,%eax
c0002c6e:	c9                   	leave  
c0002c6f:	c3                   	ret    

c0002c70 <strcpy>:
strcpy():
c0002c70:	55                   	push   %ebp
c0002c71:	89 e5                	mov    %esp,%ebp
c0002c73:	83 ec 18             	sub    $0x18,%esp
c0002c76:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002c7a:	74 06                	je     c0002c82 <strcpy+0x12>
c0002c7c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002c80:	75 19                	jne    c0002c9b <strcpy+0x2b>
c0002c82:	68 96 45 00 c0       	push   $0xc0004596
c0002c87:	68 08 46 00 c0       	push   $0xc0004608
c0002c8c:	6a 27                	push   $0x27
c0002c8e:	68 89 45 00 c0       	push   $0xc0004589
c0002c93:	e8 2a f6 ff ff       	call   c00022c2 <panic_spin>
c0002c98:	83 c4 10             	add    $0x10,%esp
c0002c9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002ca1:	90                   	nop
c0002ca2:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ca5:	8d 50 01             	lea    0x1(%eax),%edx
c0002ca8:	89 55 08             	mov    %edx,0x8(%ebp)
c0002cab:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002cae:	8d 4a 01             	lea    0x1(%edx),%ecx
c0002cb1:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c0002cb4:	0f b6 12             	movzbl (%edx),%edx
c0002cb7:	88 10                	mov    %dl,(%eax)
c0002cb9:	0f b6 00             	movzbl (%eax),%eax
c0002cbc:	84 c0                	test   %al,%al
c0002cbe:	75 e2                	jne    c0002ca2 <strcpy+0x32>
c0002cc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002cc3:	c9                   	leave  
c0002cc4:	c3                   	ret    

c0002cc5 <strlen>:
strlen():
c0002cc5:	55                   	push   %ebp
c0002cc6:	89 e5                	mov    %esp,%ebp
c0002cc8:	83 ec 18             	sub    $0x18,%esp
c0002ccb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002ccf:	75 19                	jne    c0002cea <strlen+0x25>
c0002cd1:	68 ca 45 00 c0       	push   $0xc00045ca
c0002cd6:	68 10 46 00 c0       	push   $0xc0004610
c0002cdb:	6a 2f                	push   $0x2f
c0002cdd:	68 89 45 00 c0       	push   $0xc0004589
c0002ce2:	e8 db f5 ff ff       	call   c00022c2 <panic_spin>
c0002ce7:	83 c4 10             	add    $0x10,%esp
c0002cea:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ced:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002cf0:	90                   	nop
c0002cf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002cf4:	8d 50 01             	lea    0x1(%eax),%edx
c0002cf7:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0002cfa:	0f b6 00             	movzbl (%eax),%eax
c0002cfd:	84 c0                	test   %al,%al
c0002cff:	75 f0                	jne    c0002cf1 <strlen+0x2c>
c0002d01:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0002d04:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d07:	29 c2                	sub    %eax,%edx
c0002d09:	89 d0                	mov    %edx,%eax
c0002d0b:	83 e8 01             	sub    $0x1,%eax
c0002d0e:	c9                   	leave  
c0002d0f:	c3                   	ret    

c0002d10 <strcmp>:
strcmp():
c0002d10:	55                   	push   %ebp
c0002d11:	89 e5                	mov    %esp,%ebp
c0002d13:	83 ec 08             	sub    $0x8,%esp
c0002d16:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002d1a:	74 06                	je     c0002d22 <strcmp+0x12>
c0002d1c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002d20:	75 19                	jne    c0002d3b <strcmp+0x2b>
c0002d22:	68 d6 45 00 c0       	push   $0xc00045d6
c0002d27:	68 18 46 00 c0       	push   $0xc0004618
c0002d2c:	6a 37                	push   $0x37
c0002d2e:	68 89 45 00 c0       	push   $0xc0004589
c0002d33:	e8 8a f5 ff ff       	call   c00022c2 <panic_spin>
c0002d38:	83 c4 10             	add    $0x10,%esp
c0002d3b:	eb 08                	jmp    c0002d45 <strcmp+0x35>
c0002d3d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0002d41:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
c0002d45:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d48:	0f b6 00             	movzbl (%eax),%eax
c0002d4b:	84 c0                	test   %al,%al
c0002d4d:	74 10                	je     c0002d5f <strcmp+0x4f>
c0002d4f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d52:	0f b6 10             	movzbl (%eax),%edx
c0002d55:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002d58:	0f b6 00             	movzbl (%eax),%eax
c0002d5b:	38 c2                	cmp    %al,%dl
c0002d5d:	74 de                	je     c0002d3d <strcmp+0x2d>
c0002d5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d62:	0f b6 10             	movzbl (%eax),%edx
c0002d65:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002d68:	0f b6 00             	movzbl (%eax),%eax
c0002d6b:	38 c2                	cmp    %al,%dl
c0002d6d:	7c 13                	jl     c0002d82 <strcmp+0x72>
c0002d6f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d72:	0f b6 10             	movzbl (%eax),%edx
c0002d75:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002d78:	0f b6 00             	movzbl (%eax),%eax
c0002d7b:	38 c2                	cmp    %al,%dl
c0002d7d:	0f 9f c0             	setg   %al
c0002d80:	eb 05                	jmp    c0002d87 <strcmp+0x77>
c0002d82:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002d87:	c9                   	leave  
c0002d88:	c3                   	ret    

c0002d89 <strchr>:
strchr():
c0002d89:	55                   	push   %ebp
c0002d8a:	89 e5                	mov    %esp,%ebp
c0002d8c:	83 ec 18             	sub    $0x18,%esp
c0002d8f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002d92:	88 45 f4             	mov    %al,-0xc(%ebp)
c0002d95:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002d99:	75 35                	jne    c0002dd0 <strchr+0x47>
c0002d9b:	68 ca 45 00 c0       	push   $0xc00045ca
c0002da0:	68 20 46 00 c0       	push   $0xc0004620
c0002da5:	6a 43                	push   $0x43
c0002da7:	68 89 45 00 c0       	push   $0xc0004589
c0002dac:	e8 11 f5 ff ff       	call   c00022c2 <panic_spin>
c0002db1:	83 c4 10             	add    $0x10,%esp
c0002db4:	eb 1a                	jmp    c0002dd0 <strchr+0x47>
c0002db6:	8b 45 08             	mov    0x8(%ebp),%eax
c0002db9:	0f b6 00             	movzbl (%eax),%eax
c0002dbc:	0f be d0             	movsbl %al,%edx
c0002dbf:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0002dc3:	39 c2                	cmp    %eax,%edx
c0002dc5:	75 05                	jne    c0002dcc <strchr+0x43>
c0002dc7:	8b 45 08             	mov    0x8(%ebp),%eax
c0002dca:	eb 13                	jmp    c0002ddf <strchr+0x56>
c0002dcc:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0002dd0:	8b 45 08             	mov    0x8(%ebp),%eax
c0002dd3:	0f b6 00             	movzbl (%eax),%eax
c0002dd6:	84 c0                	test   %al,%al
c0002dd8:	75 dc                	jne    c0002db6 <strchr+0x2d>
c0002dda:	b8 00 00 00 00       	mov    $0x0,%eax
c0002ddf:	c9                   	leave  
c0002de0:	c3                   	ret    

c0002de1 <strrchr>:
strrchr():
c0002de1:	55                   	push   %ebp
c0002de2:	89 e5                	mov    %esp,%ebp
c0002de4:	83 ec 28             	sub    $0x28,%esp
c0002de7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002dea:	88 45 e4             	mov    %al,-0x1c(%ebp)
c0002ded:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002df1:	75 19                	jne    c0002e0c <strrchr+0x2b>
c0002df3:	68 ca 45 00 c0       	push   $0xc00045ca
c0002df8:	68 28 46 00 c0       	push   $0xc0004628
c0002dfd:	6a 4f                	push   $0x4f
c0002dff:	68 89 45 00 c0       	push   $0xc0004589
c0002e04:	e8 b9 f4 ff ff       	call   c00022c2 <panic_spin>
c0002e09:	83 c4 10             	add    $0x10,%esp
c0002e0c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0002e13:	eb 1b                	jmp    c0002e30 <strrchr+0x4f>
c0002e15:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e18:	0f b6 00             	movzbl (%eax),%eax
c0002e1b:	0f be d0             	movsbl %al,%edx
c0002e1e:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0002e22:	39 c2                	cmp    %eax,%edx
c0002e24:	75 06                	jne    c0002e2c <strrchr+0x4b>
c0002e26:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e29:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002e2c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0002e30:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e33:	0f b6 00             	movzbl (%eax),%eax
c0002e36:	84 c0                	test   %al,%al
c0002e38:	75 db                	jne    c0002e15 <strrchr+0x34>
c0002e3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002e3d:	c9                   	leave  
c0002e3e:	c3                   	ret    

c0002e3f <strcat>:
strcat():
c0002e3f:	55                   	push   %ebp
c0002e40:	89 e5                	mov    %esp,%ebp
c0002e42:	83 ec 18             	sub    $0x18,%esp
c0002e45:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002e49:	74 06                	je     c0002e51 <strcat+0x12>
c0002e4b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002e4f:	75 19                	jne    c0002e6a <strcat+0x2b>
c0002e51:	68 96 45 00 c0       	push   $0xc0004596
c0002e56:	68 30 46 00 c0       	push   $0xc0004630
c0002e5b:	6a 5d                	push   $0x5d
c0002e5d:	68 89 45 00 c0       	push   $0xc0004589
c0002e62:	e8 5b f4 ff ff       	call   c00022c2 <panic_spin>
c0002e67:	83 c4 10             	add    $0x10,%esp
c0002e6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0002e6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002e70:	90                   	nop
c0002e71:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002e74:	8d 50 01             	lea    0x1(%eax),%edx
c0002e77:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0002e7a:	0f b6 00             	movzbl (%eax),%eax
c0002e7d:	84 c0                	test   %al,%al
c0002e7f:	75 f0                	jne    c0002e71 <strcat+0x32>
c0002e81:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c0002e85:	90                   	nop
c0002e86:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002e89:	8d 50 01             	lea    0x1(%eax),%edx
c0002e8c:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0002e8f:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002e92:	8d 4a 01             	lea    0x1(%edx),%ecx
c0002e95:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c0002e98:	0f b6 12             	movzbl (%edx),%edx
c0002e9b:	88 10                	mov    %dl,(%eax)
c0002e9d:	0f b6 00             	movzbl (%eax),%eax
c0002ea0:	84 c0                	test   %al,%al
c0002ea2:	75 e2                	jne    c0002e86 <strcat+0x47>
c0002ea4:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ea7:	c9                   	leave  
c0002ea8:	c3                   	ret    

c0002ea9 <strchrs>:
strchrs():
c0002ea9:	55                   	push   %ebp
c0002eaa:	89 e5                	mov    %esp,%ebp
c0002eac:	83 ec 28             	sub    $0x28,%esp
c0002eaf:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002eb2:	88 45 e4             	mov    %al,-0x1c(%ebp)
c0002eb5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002eb9:	75 19                	jne    c0002ed4 <strchrs+0x2b>
c0002ebb:	68 ca 45 00 c0       	push   $0xc00045ca
c0002ec0:	68 38 46 00 c0       	push   $0xc0004638
c0002ec5:	6a 67                	push   $0x67
c0002ec7:	68 89 45 00 c0       	push   $0xc0004589
c0002ecc:	e8 f1 f3 ff ff       	call   c00022c2 <panic_spin>
c0002ed1:	83 c4 10             	add    $0x10,%esp
c0002ed4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0002edb:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ede:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0002ee1:	eb 19                	jmp    c0002efc <strchrs+0x53>
c0002ee3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002ee6:	0f b6 00             	movzbl (%eax),%eax
c0002ee9:	0f be d0             	movsbl %al,%edx
c0002eec:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0002ef0:	39 c2                	cmp    %eax,%edx
c0002ef2:	75 04                	jne    c0002ef8 <strchrs+0x4f>
c0002ef4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0002ef8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0002efc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002eff:	0f b6 00             	movzbl (%eax),%eax
c0002f02:	84 c0                	test   %al,%al
c0002f04:	75 dd                	jne    c0002ee3 <strchrs+0x3a>
c0002f06:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002f09:	c9                   	leave  
c0002f0a:	c3                   	ret    

c0002f0b <running_thread>:
running_thread():
/work/x86_os_my/thread/thread.c:23

/* 返回线程 PCB 地址。
 * 各个线程所用的 0 级栈都是在自己的 PCB 当中，
 * 取当前栈指针的高 20 位，就是当前运行线程的 PCB（PCB是在自然页的起始地址！）
 */
struct task_struct* running_thread() {
c0002f0b:	55                   	push   %ebp
c0002f0c:	89 e5                	mov    %esp,%ebp
c0002f0e:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:25
	uint32_t esp;
	asm ("mov %%esp, %0" : "=g" (esp));	//esp寄存器的值，放入变量esp
c0002f11:	89 e0                	mov    %esp,%eax
c0002f13:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:26
	return (struct task_struct*)(esp & 0xfffff000);
c0002f16:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002f19:	25 00 f0 ff ff       	and    $0xfffff000,%eax
/work/x86_os_my/thread/thread.c:27
}
c0002f1e:	c9                   	leave  
c0002f1f:	c3                   	ret    

c0002f20 <kernel_thread>:
kernel_thread():
/work/x86_os_my/thread/thread.c:30

/* 由kernel_thread去执行function(func_arg) */
static void kernel_thread(thread_func* function, void* func_arg) {
c0002f20:	55                   	push   %ebp
c0002f21:	89 e5                	mov    %esp,%ebp
c0002f23:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:36
	/* 线程的首次运行是由时钟中断处理函数调用任务调度器 schedule 完成的，
	 * 进入中断后处理器会自动关中断，
	 * 因此在执行 function 前要打开中断，否则 kernel_thread 中的 function 在关中断的情况下运行，
	 * 也就是时钟中断被屏蔽了，再也不会调度到新的线程，function 会独享处理器。
	 */
	intr_enable();
c0002f26:	e8 5e ea ff ff       	call   c0001989 <intr_enable>
/work/x86_os_my/thread/thread.c:37
	function(func_arg); 
c0002f2b:	83 ec 0c             	sub    $0xc,%esp
c0002f2e:	ff 75 0c             	pushl  0xc(%ebp)
c0002f31:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f34:	ff d0                	call   *%eax
c0002f36:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:38
}
c0002f39:	90                   	nop
c0002f3a:	c9                   	leave  
c0002f3b:	c3                   	ret    

c0002f3c <thread_create>:
thread_create():
/work/x86_os_my/thread/thread.c:41

/* 初始化线程栈结构体 struct thread_stack */
void thread_create(struct task_struct* pthread, thread_func function, void* func_arg) {
c0002f3c:	55                   	push   %ebp
c0002f3d:	89 e5                	mov    %esp,%ebp
c0002f3f:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:45
	/* 先预留中断使用栈的空间 
	 *（1）将来线程进入中断后，位于 kernel.S 中的中断代码会通过此栈来保存上下文。
	 *（2）将来实现用户进程时，会将用户进程的初始信息放在中断栈中。*/
	pthread->self_kstack -= sizeof(struct intr_stack);
c0002f42:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f45:	8b 00                	mov    (%eax),%eax
c0002f47:	8d 90 d0 fe ff ff    	lea    -0x130(%eax),%edx
c0002f4d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f50:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:48

	/* 再留出线程栈空间（unused_retaddr 所在的栈）*/
	pthread->self_kstack -= sizeof(struct thread_stack);
c0002f52:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f55:	8b 00                	mov    (%eax),%eax
c0002f57:	8d 50 80             	lea    -0x80(%eax),%edx
c0002f5a:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f5d:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:49
	struct thread_stack* kthread_stack = (struct thread_stack*)pthread->self_kstack;
c0002f5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f62:	8b 00                	mov    (%eax),%eax
c0002f64:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:57
	 * kernel_thread 并不是通过 call 指令调用的，而是通过 ret 来执行的，
	 * 因此无法按照正常的函数调用形式传递 kernel_thread 所需要的参数，
	 * 这样调用是不行的： kernel_thread(function, func_arg)，
	 * 只能将参数放在 kernel_thread 所用的栈中，即处理器进入 kernel_thread 函数体时，
	 * 栈顶为返回地址，栈顶+4 为参数function，栈顶+8 为参数func_arg */
	kthread_stack->eip = kernel_thread;
c0002f67:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002f6a:	c7 40 10 20 2f 00 c0 	movl   $0xc0002f20,0x10(%eax)
/work/x86_os_my/thread/thread.c:58
	kthread_stack->function = function;
c0002f71:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002f74:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002f77:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/thread.c:59
	kthread_stack->func_arg = func_arg;
c0002f7a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002f7d:	8b 55 10             	mov    0x10(%ebp),%edx
c0002f80:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/thread/thread.c:60
	kthread_stack->ebp = kthread_stack->ebx = kthread_stack->esi = kthread_stack->edi = 0;
c0002f83:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002f86:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c0002f8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002f90:	8b 50 08             	mov    0x8(%eax),%edx
c0002f93:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002f96:	89 50 0c             	mov    %edx,0xc(%eax)
c0002f99:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002f9c:	8b 50 0c             	mov    0xc(%eax),%edx
c0002f9f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002fa2:	89 50 04             	mov    %edx,0x4(%eax)
c0002fa5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002fa8:	8b 50 04             	mov    0x4(%eax),%edx
c0002fab:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002fae:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:61
}
c0002fb0:	90                   	nop
c0002fb1:	c9                   	leave  
c0002fb2:	c3                   	ret    

c0002fb3 <init_thread>:
init_thread():
/work/x86_os_my/thread/thread.c:64

/* 初始化线程PCB结构体 struct task_struct*/
void init_thread(struct task_struct* pthread, char* name, int prio) {
c0002fb3:	55                   	push   %ebp
c0002fb4:	89 e5                	mov    %esp,%ebp
c0002fb6:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:65
	memset(pthread, 0, sizeof(*pthread));	//清空PCB
c0002fb9:	83 ec 04             	sub    $0x4,%esp
c0002fbc:	6a 38                	push   $0x38
c0002fbe:	6a 00                	push   $0x0
c0002fc0:	ff 75 08             	pushl  0x8(%ebp)
c0002fc3:	e8 73 fb ff ff       	call   c0002b3b <memset>
c0002fc8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:66
	strcpy(pthread->name, name);
c0002fcb:	8b 45 08             	mov    0x8(%ebp),%eax
c0002fce:	83 c0 08             	add    $0x8,%eax
c0002fd1:	83 ec 08             	sub    $0x8,%esp
c0002fd4:	ff 75 0c             	pushl  0xc(%ebp)
c0002fd7:	50                   	push   %eax
c0002fd8:	e8 93 fc ff ff       	call   c0002c70 <strcpy>
c0002fdd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:68

	if (pthread == g_main_thread) {
c0002fe0:	a1 30 6b 00 c0       	mov    0xc0006b30,%eax
c0002fe5:	39 45 08             	cmp    %eax,0x8(%ebp)
c0002fe8:	75 0c                	jne    c0002ff6 <init_thread+0x43>
/work/x86_os_my/thread/thread.c:70
		/* 由于把main函数也封装成一个线程,并且它一直是运行的,故将其直接设为TASK_RUNNING */
		pthread->status = TASK_RUNNING;
c0002fea:	8b 45 08             	mov    0x8(%ebp),%eax
c0002fed:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
c0002ff4:	eb 0a                	jmp    c0003000 <init_thread+0x4d>
/work/x86_os_my/thread/thread.c:72
	} else {
		pthread->status = TASK_READY;
c0002ff6:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ff9:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
/work/x86_os_my/thread/thread.c:78
	}

	/* self_kstack是线程自己在内核态下使用的栈顶地址 
	 * 线程自己在 0 特权级下所用的栈，在线程创建之初，
	 * 它被初始化为线程 PCB 的最顶端，即(uint32_t)pthread + PG_SIZE。*/
	pthread->self_kstack = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c0003000:	8b 45 08             	mov    0x8(%ebp),%eax
c0003003:	05 00 10 00 00       	add    $0x1000,%eax
c0003008:	89 c2                	mov    %eax,%edx
c000300a:	8b 45 08             	mov    0x8(%ebp),%eax
c000300d:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:79
	pthread->priority = prio;
c000300f:	8b 45 10             	mov    0x10(%ebp),%eax
c0003012:	89 c2                	mov    %eax,%edx
c0003014:	8b 45 08             	mov    0x8(%ebp),%eax
c0003017:	88 50 18             	mov    %dl,0x18(%eax)
/work/x86_os_my/thread/thread.c:80
	pthread->ticks = prio;
c000301a:	8b 45 10             	mov    0x10(%ebp),%eax
c000301d:	89 c2                	mov    %eax,%edx
c000301f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003022:	88 50 19             	mov    %dl,0x19(%eax)
/work/x86_os_my/thread/thread.c:81
	pthread->elapsed_ticks = 0;
c0003025:	8b 45 08             	mov    0x8(%ebp),%eax
c0003028:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
/work/x86_os_my/thread/thread.c:82
	pthread->pgdir = NULL;
c000302f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003032:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
/work/x86_os_my/thread/thread.c:83
	pthread->stack_magic = 0x19870916;	  // 自定义的魔数
c0003039:	8b 45 08             	mov    0x8(%ebp),%eax
c000303c:	c7 40 34 16 09 87 19 	movl   $0x19870916,0x34(%eax)
/work/x86_os_my/thread/thread.c:84
}
c0003043:	90                   	nop
c0003044:	c9                   	leave  
c0003045:	c3                   	ret    

c0003046 <thread_start>:
thread_start():
/work/x86_os_my/thread/thread.c:87

/* 创建线程 */
struct task_struct* thread_start(char* name, int prio, thread_func function, void* func_arg) {
c0003046:	55                   	push   %ebp
c0003047:	89 e5                	mov    %esp,%ebp
c0003049:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:89
	/* pcb都位于内核空间,包括用户进程的pcb也是在内核空间 */
	struct task_struct* thread = get_kernel_pages(1);
c000304c:	83 ec 0c             	sub    $0xc,%esp
c000304f:	6a 01                	push   $0x1
c0003051:	e8 8a f8 ff ff       	call   c00028e0 <get_kernel_pages>
c0003056:	83 c4 10             	add    $0x10,%esp
c0003059:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:91

	init_thread(thread, name, prio);			//初始化线程PCB
c000305c:	83 ec 04             	sub    $0x4,%esp
c000305f:	ff 75 0c             	pushl  0xc(%ebp)
c0003062:	ff 75 08             	pushl  0x8(%ebp)
c0003065:	ff 75 f4             	pushl  -0xc(%ebp)
c0003068:	e8 46 ff ff ff       	call   c0002fb3 <init_thread>
c000306d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:92
	thread_create(thread, function, func_arg);	//初始化线程栈结构体
c0003070:	83 ec 04             	sub    $0x4,%esp
c0003073:	ff 75 14             	pushl  0x14(%ebp)
c0003076:	ff 75 10             	pushl  0x10(%ebp)
c0003079:	ff 75 f4             	pushl  -0xc(%ebp)
c000307c:	e8 bb fe ff ff       	call   c0002f3c <thread_create>
c0003081:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:94
	
	ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));	// 确保之前不在队列中
c0003084:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003087:	83 c0 20             	add    $0x20,%eax
c000308a:	83 ec 08             	sub    $0x8,%esp
c000308d:	50                   	push   %eax
c000308e:	68 10 6b 00 c0       	push   $0xc0006b10
c0003093:	e8 d4 04 00 00       	call   c000356c <elem_find>
c0003098:	83 c4 10             	add    $0x10,%esp
c000309b:	85 c0                	test   %eax,%eax
c000309d:	74 19                	je     c00030b8 <thread_start+0x72>
/work/x86_os_my/thread/thread.c:94 (discriminator 1)
c000309f:	68 40 46 00 c0       	push   $0xc0004640
c00030a4:	68 c0 48 00 c0       	push   $0xc00048c0
c00030a9:	6a 5e                	push   $0x5e
c00030ab:	68 75 46 00 c0       	push   $0xc0004675
c00030b0:	e8 0d f2 ff ff       	call   c00022c2 <panic_spin>
c00030b5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:95
	list_append(&thread_ready_list, &thread->general_tag);			// 加入就绪线程队列
c00030b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00030bb:	83 c0 20             	add    $0x20,%eax
c00030be:	83 ec 08             	sub    $0x8,%esp
c00030c1:	50                   	push   %eax
c00030c2:	68 10 6b 00 c0       	push   $0xc0006b10
c00030c7:	e8 26 04 00 00       	call   c00034f2 <list_append>
c00030cc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:97

	ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
c00030cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00030d2:	83 c0 28             	add    $0x28,%eax
c00030d5:	83 ec 08             	sub    $0x8,%esp
c00030d8:	50                   	push   %eax
c00030d9:	68 20 6b 00 c0       	push   $0xc0006b20
c00030de:	e8 89 04 00 00       	call   c000356c <elem_find>
c00030e3:	83 c4 10             	add    $0x10,%esp
c00030e6:	85 c0                	test   %eax,%eax
c00030e8:	74 19                	je     c0003103 <thread_start+0xbd>
/work/x86_os_my/thread/thread.c:97 (discriminator 1)
c00030ea:	68 88 46 00 c0       	push   $0xc0004688
c00030ef:	68 c0 48 00 c0       	push   $0xc00048c0
c00030f4:	6a 61                	push   $0x61
c00030f6:	68 75 46 00 c0       	push   $0xc0004675
c00030fb:	e8 c2 f1 ff ff       	call   c00022c2 <panic_spin>
c0003100:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:98
	list_append(&thread_all_list, &thread->all_list_tag);			// 加入全部线程队列
c0003103:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003106:	83 c0 28             	add    $0x28,%eax
c0003109:	83 ec 08             	sub    $0x8,%esp
c000310c:	50                   	push   %eax
c000310d:	68 20 6b 00 c0       	push   $0xc0006b20
c0003112:	e8 db 03 00 00       	call   c00034f2 <list_append>
c0003117:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:114
	 * 在执行 ret 后，esp 指向的数值被弹岀到 eip。
	 * 处理器会去执行 kernel_thread 函数。
	 * 在执行 kernel_thread 时，处理器以为栈顶是返回地址，其实只是一个假的占位置的变量 unused_retaddr！
	 * 接着会调用函数 function(func_arg) */
	//asm volatile ("movl %0, %%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret" : : "g" (thread->self_kstack) : "memory");
	return thread;
c000311a:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/thread/thread.c:115
}
c000311d:	c9                   	leave  
c000311e:	c3                   	ret    

c000311f <make_main_thread>:
make_main_thread():
/work/x86_os_my/thread/thread.c:119


/* 将kernel中的main函数完善为主线程 */
static void make_main_thread(void) {
c000311f:	55                   	push   %ebp
c0003120:	89 e5                	mov    %esp,%ebp
c0003122:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:124
	/* 因为main线程早已运行,咱们在loader.S中进入内核时的mov esp, 0xc009f000设置了栈顶，也预留了pcb, 地址为0xc009e000
	 * 主线程不需要再为PCB申请页，只需要通过 init_thread 填充PCB成员：名称和优先级等。
	 * 也不需要再通过 thread_create 构造它的线程栈。
	 */
	g_main_thread = running_thread();	//用栈指针的高20位，当做当前线程的PCB
c0003125:	e8 e1 fd ff ff       	call   c0002f0b <running_thread>
c000312a:	a3 30 6b 00 c0       	mov    %eax,0xc0006b30
/work/x86_os_my/thread/thread.c:125
	init_thread(g_main_thread, "main", 31);
c000312f:	a1 30 6b 00 c0       	mov    0xc0006b30,%eax
c0003134:	83 ec 04             	sub    $0x4,%esp
c0003137:	6a 1f                	push   $0x1f
c0003139:	68 bc 46 00 c0       	push   $0xc00046bc
c000313e:	50                   	push   %eax
c000313f:	e8 6f fe ff ff       	call   c0002fb3 <init_thread>
c0003144:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:129

	/* main函数是当前线程,当前线程不在thread_ready_list中,
	 * 所以只将其加在thread_all_list中. */
	ASSERT(!elem_find(&thread_all_list, &g_main_thread->all_list_tag));
c0003147:	a1 30 6b 00 c0       	mov    0xc0006b30,%eax
c000314c:	83 c0 28             	add    $0x28,%eax
c000314f:	83 ec 08             	sub    $0x8,%esp
c0003152:	50                   	push   %eax
c0003153:	68 20 6b 00 c0       	push   $0xc0006b20
c0003158:	e8 0f 04 00 00       	call   c000356c <elem_find>
c000315d:	83 c4 10             	add    $0x10,%esp
c0003160:	85 c0                	test   %eax,%eax
c0003162:	74 1c                	je     c0003180 <make_main_thread+0x61>
/work/x86_os_my/thread/thread.c:129 (discriminator 1)
c0003164:	68 c4 46 00 c0       	push   $0xc00046c4
c0003169:	68 d0 48 00 c0       	push   $0xc00048d0
c000316e:	68 81 00 00 00       	push   $0x81
c0003173:	68 75 46 00 c0       	push   $0xc0004675
c0003178:	e8 45 f1 ff ff       	call   c00022c2 <panic_spin>
c000317d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:130
	list_append(&thread_all_list, &g_main_thread->all_list_tag);
c0003180:	a1 30 6b 00 c0       	mov    0xc0006b30,%eax
c0003185:	83 c0 28             	add    $0x28,%eax
c0003188:	83 ec 08             	sub    $0x8,%esp
c000318b:	50                   	push   %eax
c000318c:	68 20 6b 00 c0       	push   $0xc0006b20
c0003191:	e8 5c 03 00 00       	call   c00034f2 <list_append>
c0003196:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:131
}
c0003199:	90                   	nop
c000319a:	c9                   	leave  
c000319b:	c3                   	ret    

c000319c <schedule>:
schedule():
/work/x86_os_my/thread/thread.c:141
（2）调度器 schedule。
（3）任务切换函数 switch_to。
*/
/* 实现任务调度 */
void schedule()
{
c000319c:	55                   	push   %ebp
c000319d:	89 e5                	mov    %esp,%ebp
c000319f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:142
	ASSERT(intr_get_status() == INTR_OFF);
c00031a2:	e8 52 e8 ff ff       	call   c00019f9 <intr_get_status>
c00031a7:	85 c0                	test   %eax,%eax
c00031a9:	74 1c                	je     c00031c7 <schedule+0x2b>
/work/x86_os_my/thread/thread.c:142 (discriminator 1)
c00031ab:	68 ff 46 00 c0       	push   $0xc00046ff
c00031b0:	68 e4 48 00 c0       	push   $0xc00048e4
c00031b5:	68 8e 00 00 00       	push   $0x8e
c00031ba:	68 75 46 00 c0       	push   $0xc0004675
c00031bf:	e8 fe f0 ff ff       	call   c00022c2 <panic_spin>
c00031c4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:145

	/* 换下 */
	struct task_struct* cur = running_thread(); 
c00031c7:	e8 3f fd ff ff       	call   c0002f0b <running_thread>
c00031cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:146
	if (cur->status == TASK_RUNNING) { // 若此线程只是cpu时间片到了,将其加入到就绪队列尾
c00031cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00031d2:	8b 40 04             	mov    0x4(%eax),%eax
c00031d5:	85 c0                	test   %eax,%eax
c00031d7:	75 65                	jne    c000323e <schedule+0xa2>
/work/x86_os_my/thread/thread.c:147
		ASSERT(!elem_find(&thread_ready_list, &cur->general_tag));
c00031d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00031dc:	83 c0 20             	add    $0x20,%eax
c00031df:	83 ec 08             	sub    $0x8,%esp
c00031e2:	50                   	push   %eax
c00031e3:	68 10 6b 00 c0       	push   $0xc0006b10
c00031e8:	e8 7f 03 00 00       	call   c000356c <elem_find>
c00031ed:	83 c4 10             	add    $0x10,%esp
c00031f0:	85 c0                	test   %eax,%eax
c00031f2:	74 1c                	je     c0003210 <schedule+0x74>
/work/x86_os_my/thread/thread.c:147 (discriminator 1)
c00031f4:	68 20 47 00 c0       	push   $0xc0004720
c00031f9:	68 e4 48 00 c0       	push   $0xc00048e4
c00031fe:	68 93 00 00 00       	push   $0x93
c0003203:	68 75 46 00 c0       	push   $0xc0004675
c0003208:	e8 b5 f0 ff ff       	call   c00022c2 <panic_spin>
c000320d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:148
		list_append(&thread_ready_list, &cur->general_tag);
c0003210:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003213:	83 c0 20             	add    $0x20,%eax
c0003216:	83 ec 08             	sub    $0x8,%esp
c0003219:	50                   	push   %eax
c000321a:	68 10 6b 00 c0       	push   $0xc0006b10
c000321f:	e8 ce 02 00 00       	call   c00034f2 <list_append>
c0003224:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:149
		cur->ticks = cur->priority;     // 重新将当前线程的ticks再重置为其priority;
c0003227:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000322a:	0f b6 50 18          	movzbl 0x18(%eax),%edx
c000322e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003231:	88 50 19             	mov    %dl,0x19(%eax)
/work/x86_os_my/thread/thread.c:150
		cur->status = TASK_READY;
c0003234:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003237:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
/work/x86_os_my/thread/thread.c:157
		/* 若此线程需要某事件发生后才能继续上cpu运行,
		不需要将其加入队列,因为当前线程不在就绪队列中。*/
	}

	/* 换上 */
	ASSERT(!list_empty(&thread_ready_list));
c000323e:	83 ec 0c             	sub    $0xc,%esp
c0003241:	68 10 6b 00 c0       	push   $0xc0006b10
c0003246:	e8 ee 03 00 00       	call   c0003639 <list_empty>
c000324b:	83 c4 10             	add    $0x10,%esp
c000324e:	85 c0                	test   %eax,%eax
c0003250:	74 1c                	je     c000326e <schedule+0xd2>
/work/x86_os_my/thread/thread.c:157 (discriminator 1)
c0003252:	68 54 47 00 c0       	push   $0xc0004754
c0003257:	68 e4 48 00 c0       	push   $0xc00048e4
c000325c:	68 9d 00 00 00       	push   $0x9d
c0003261:	68 75 46 00 c0       	push   $0xc0004675
c0003266:	e8 57 f0 ff ff       	call   c00022c2 <panic_spin>
c000326b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:158
	g_thread_tag = NULL;	  // g_thread_tag清空
c000326e:	c7 05 20 69 00 c0 00 	movl   $0x0,0xc0006920
c0003275:	00 00 00 
/work/x86_os_my/thread/thread.c:160
	/* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */
	g_thread_tag = list_pop(&thread_ready_list);   
c0003278:	83 ec 0c             	sub    $0xc,%esp
c000327b:	68 10 6b 00 c0       	push   $0xc0006b10
c0003280:	e8 c5 02 00 00       	call   c000354a <list_pop>
c0003285:	83 c4 10             	add    $0x10,%esp
c0003288:	a3 20 69 00 c0       	mov    %eax,0xc0006920
/work/x86_os_my/thread/thread.c:161
	struct task_struct* next = elem2entry(struct task_struct, general_tag, g_thread_tag);
c000328d:	a1 20 69 00 c0       	mov    0xc0006920,%eax
c0003292:	83 e8 20             	sub    $0x20,%eax
c0003295:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:162
	next->status = TASK_RUNNING;
c0003298:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000329b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
/work/x86_os_my/thread/thread.c:163
	switch_to(cur, next);
c00032a2:	83 ec 08             	sub    $0x8,%esp
c00032a5:	ff 75 f0             	pushl  -0x10(%ebp)
c00032a8:	ff 75 f4             	pushl  -0xc(%ebp)
c00032ab:	e8 b0 03 00 00       	call   c0003660 <switch_to>
c00032b0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:164
}
c00032b3:	90                   	nop
c00032b4:	c9                   	leave  
c00032b5:	c3                   	ret    

c00032b6 <thread_block>:
thread_block():
/work/x86_os_my/thread/thread.c:167

/* 当前线程将自己阻塞,标志其状态为stat. */
void thread_block(enum task_status stat) {
c00032b6:	55                   	push   %ebp
c00032b7:	89 e5                	mov    %esp,%ebp
c00032b9:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:169
	/* stat取值为TASK_BLOCKED,TASK_WAITING,TASK_HANGING,也就是只有这三种状态才不会被调度*/
	ASSERT(((stat == TASK_BLOCKED) || (stat == TASK_WAITING) || (stat == TASK_HANGING)));
c00032bc:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c00032c0:	74 28                	je     c00032ea <thread_block+0x34>
/work/x86_os_my/thread/thread.c:169 (discriminator 1)
c00032c2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c00032c6:	74 22                	je     c00032ea <thread_block+0x34>
/work/x86_os_my/thread/thread.c:169 (discriminator 2)
c00032c8:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
c00032cc:	74 1c                	je     c00032ea <thread_block+0x34>
/work/x86_os_my/thread/thread.c:169 (discriminator 3)
c00032ce:	68 74 47 00 c0       	push   $0xc0004774
c00032d3:	68 f0 48 00 c0       	push   $0xc00048f0
c00032d8:	68 a9 00 00 00       	push   $0xa9
c00032dd:	68 75 46 00 c0       	push   $0xc0004675
c00032e2:	e8 db ef ff ff       	call   c00022c2 <panic_spin>
c00032e7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:170
	enum intr_status old_status = intr_disable();
c00032ea:	e8 c3 e6 ff ff       	call   c00019b2 <intr_disable>
c00032ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:172
	
	struct task_struct* cur_thread = running_thread();
c00032f2:	e8 14 fc ff ff       	call   c0002f0b <running_thread>
c00032f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:173
	cur_thread->status = stat;
c00032fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00032fd:	8b 55 08             	mov    0x8(%ebp),%edx
c0003300:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/thread/thread.c:174
	schedule();
c0003303:	e8 94 fe ff ff       	call   c000319c <schedule>
/work/x86_os_my/thread/thread.c:177
	
	/* 待当前线程被解除阻塞后才继续运行下面的intr_set_status */
	intr_set_status(old_status);
c0003308:	83 ec 0c             	sub    $0xc,%esp
c000330b:	ff 75 f4             	pushl  -0xc(%ebp)
c000330e:	e8 c8 e6 ff ff       	call   c00019db <intr_set_status>
c0003313:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:178
}
c0003316:	90                   	nop
c0003317:	c9                   	leave  
c0003318:	c3                   	ret    

c0003319 <thread_unblock>:
thread_unblock():
/work/x86_os_my/thread/thread.c:181

/* 将线程pthread解除阻塞 */
void thread_unblock(struct task_struct* pthread) {
c0003319:	55                   	push   %ebp
c000331a:	89 e5                	mov    %esp,%ebp
c000331c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:182
	enum intr_status old_status = intr_disable();
c000331f:	e8 8e e6 ff ff       	call   c00019b2 <intr_disable>
c0003324:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:183
	ASSERT(((pthread->status == TASK_BLOCKED) || (pthread->status == TASK_WAITING) || (pthread->status == TASK_HANGING)));
c0003327:	8b 45 08             	mov    0x8(%ebp),%eax
c000332a:	8b 40 04             	mov    0x4(%eax),%eax
c000332d:	83 f8 02             	cmp    $0x2,%eax
c0003330:	74 32                	je     c0003364 <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:183 (discriminator 1)
c0003332:	8b 45 08             	mov    0x8(%ebp),%eax
c0003335:	8b 40 04             	mov    0x4(%eax),%eax
c0003338:	83 f8 03             	cmp    $0x3,%eax
c000333b:	74 27                	je     c0003364 <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:183 (discriminator 2)
c000333d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003340:	8b 40 04             	mov    0x4(%eax),%eax
c0003343:	83 f8 04             	cmp    $0x4,%eax
c0003346:	74 1c                	je     c0003364 <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:183 (discriminator 3)
c0003348:	68 c4 47 00 c0       	push   $0xc00047c4
c000334d:	68 00 49 00 c0       	push   $0xc0004900
c0003352:	68 b7 00 00 00       	push   $0xb7
c0003357:	68 75 46 00 c0       	push   $0xc0004675
c000335c:	e8 61 ef ff ff       	call   c00022c2 <panic_spin>
c0003361:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:185
	
	if (pthread->status != TASK_READY) {
c0003364:	8b 45 08             	mov    0x8(%ebp),%eax
c0003367:	8b 40 04             	mov    0x4(%eax),%eax
c000336a:	83 f8 01             	cmp    $0x1,%eax
c000336d:	0f 84 8f 00 00 00    	je     c0003402 <thread_unblock+0xe9>
/work/x86_os_my/thread/thread.c:186
		ASSERT(!elem_find(&thread_ready_list, &pthread->general_tag));
c0003373:	8b 45 08             	mov    0x8(%ebp),%eax
c0003376:	83 c0 20             	add    $0x20,%eax
c0003379:	83 ec 08             	sub    $0x8,%esp
c000337c:	50                   	push   %eax
c000337d:	68 10 6b 00 c0       	push   $0xc0006b10
c0003382:	e8 e5 01 00 00       	call   c000356c <elem_find>
c0003387:	83 c4 10             	add    $0x10,%esp
c000338a:	85 c0                	test   %eax,%eax
c000338c:	74 1c                	je     c00033aa <thread_unblock+0x91>
/work/x86_os_my/thread/thread.c:186 (discriminator 1)
c000338e:	68 34 48 00 c0       	push   $0xc0004834
c0003393:	68 00 49 00 c0       	push   $0xc0004900
c0003398:	68 ba 00 00 00       	push   $0xba
c000339d:	68 75 46 00 c0       	push   $0xc0004675
c00033a2:	e8 1b ef ff ff       	call   c00022c2 <panic_spin>
c00033a7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:187
		if (elem_find(&thread_ready_list, &pthread->general_tag)) {
c00033aa:	8b 45 08             	mov    0x8(%ebp),%eax
c00033ad:	83 c0 20             	add    $0x20,%eax
c00033b0:	83 ec 08             	sub    $0x8,%esp
c00033b3:	50                   	push   %eax
c00033b4:	68 10 6b 00 c0       	push   $0xc0006b10
c00033b9:	e8 ae 01 00 00       	call   c000356c <elem_find>
c00033be:	83 c4 10             	add    $0x10,%esp
c00033c1:	85 c0                	test   %eax,%eax
c00033c3:	74 1c                	je     c00033e1 <thread_unblock+0xc8>
/work/x86_os_my/thread/thread.c:188
			PANIC("thread_unblock: blocked thread in ready_list\n");
c00033c5:	68 6c 48 00 c0       	push   $0xc000486c
c00033ca:	68 00 49 00 c0       	push   $0xc0004900
c00033cf:	68 bc 00 00 00       	push   $0xbc
c00033d4:	68 75 46 00 c0       	push   $0xc0004675
c00033d9:	e8 e4 ee ff ff       	call   c00022c2 <panic_spin>
c00033de:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:190
		}
		list_push(&thread_ready_list, &pthread->general_tag);	// 放到队列的最前面,使其尽快得到调度
c00033e1:	8b 45 08             	mov    0x8(%ebp),%eax
c00033e4:	83 c0 20             	add    $0x20,%eax
c00033e7:	83 ec 08             	sub    $0x8,%esp
c00033ea:	50                   	push   %eax
c00033eb:	68 10 6b 00 c0       	push   $0xc0006b10
c00033f0:	e8 df 00 00 00       	call   c00034d4 <list_push>
c00033f5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:191
		pthread->status = TASK_READY;
c00033f8:	8b 45 08             	mov    0x8(%ebp),%eax
c00033fb:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
/work/x86_os_my/thread/thread.c:194
	}
	
	intr_set_status(old_status);
c0003402:	83 ec 0c             	sub    $0xc,%esp
c0003405:	ff 75 f4             	pushl  -0xc(%ebp)
c0003408:	e8 ce e5 ff ff       	call   c00019db <intr_set_status>
c000340d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:195
}
c0003410:	90                   	nop
c0003411:	c9                   	leave  
c0003412:	c3                   	ret    

c0003413 <thread_init>:
thread_init():
/work/x86_os_my/thread/thread.c:198

/* 初始化线程环境 */
void thread_init(void) {
c0003413:	55                   	push   %ebp
c0003414:	89 e5                	mov    %esp,%ebp
c0003416:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:199
	put_str("thread_init start\n");
c0003419:	83 ec 0c             	sub    $0xc,%esp
c000341c:	68 9a 48 00 c0       	push   $0xc000489a
c0003421:	e8 2a ed ff ff       	call   c0002150 <put_str>
c0003426:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:200
	list_init(&thread_ready_list);
c0003429:	83 ec 0c             	sub    $0xc,%esp
c000342c:	68 10 6b 00 c0       	push   $0xc0006b10
c0003431:	e8 2b 00 00 00       	call   c0003461 <list_init>
c0003436:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:201
	list_init(&thread_all_list);
c0003439:	83 ec 0c             	sub    $0xc,%esp
c000343c:	68 20 6b 00 c0       	push   $0xc0006b20
c0003441:	e8 1b 00 00 00       	call   c0003461 <list_init>
c0003446:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:203
	/* 将当前main函数创建为线程 */
	make_main_thread();
c0003449:	e8 d1 fc ff ff       	call   c000311f <make_main_thread>
/work/x86_os_my/thread/thread.c:204
	put_str("thread_init done\n");
c000344e:	83 ec 0c             	sub    $0xc,%esp
c0003451:	68 ad 48 00 c0       	push   $0xc00048ad
c0003456:	e8 f5 ec ff ff       	call   c0002150 <put_str>
c000345b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:205
}
c000345e:	90                   	nop
c000345f:	c9                   	leave  
c0003460:	c3                   	ret    

c0003461 <list_init>:
list_init():
c0003461:	55                   	push   %ebp
c0003462:	89 e5                	mov    %esp,%ebp
c0003464:	8b 45 08             	mov    0x8(%ebp),%eax
c0003467:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c000346d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003470:	8d 50 08             	lea    0x8(%eax),%edx
c0003473:	8b 45 08             	mov    0x8(%ebp),%eax
c0003476:	89 50 04             	mov    %edx,0x4(%eax)
c0003479:	8b 55 08             	mov    0x8(%ebp),%edx
c000347c:	8b 45 08             	mov    0x8(%ebp),%eax
c000347f:	89 50 08             	mov    %edx,0x8(%eax)
c0003482:	8b 45 08             	mov    0x8(%ebp),%eax
c0003485:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
c000348c:	90                   	nop
c000348d:	5d                   	pop    %ebp
c000348e:	c3                   	ret    

c000348f <list_insert_before>:
list_insert_before():
c000348f:	55                   	push   %ebp
c0003490:	89 e5                	mov    %esp,%ebp
c0003492:	83 ec 18             	sub    $0x18,%esp
c0003495:	e8 18 e5 ff ff       	call   c00019b2 <intr_disable>
c000349a:	89 45 f4             	mov    %eax,-0xc(%ebp)
c000349d:	8b 45 08             	mov    0x8(%ebp),%eax
c00034a0:	8b 00                	mov    (%eax),%eax
c00034a2:	8b 55 0c             	mov    0xc(%ebp),%edx
c00034a5:	89 50 04             	mov    %edx,0x4(%eax)
c00034a8:	8b 45 08             	mov    0x8(%ebp),%eax
c00034ab:	8b 10                	mov    (%eax),%edx
c00034ad:	8b 45 0c             	mov    0xc(%ebp),%eax
c00034b0:	89 10                	mov    %edx,(%eax)
c00034b2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00034b5:	8b 55 08             	mov    0x8(%ebp),%edx
c00034b8:	89 50 04             	mov    %edx,0x4(%eax)
c00034bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00034be:	8b 55 0c             	mov    0xc(%ebp),%edx
c00034c1:	89 10                	mov    %edx,(%eax)
c00034c3:	83 ec 0c             	sub    $0xc,%esp
c00034c6:	ff 75 f4             	pushl  -0xc(%ebp)
c00034c9:	e8 0d e5 ff ff       	call   c00019db <intr_set_status>
c00034ce:	83 c4 10             	add    $0x10,%esp
c00034d1:	90                   	nop
c00034d2:	c9                   	leave  
c00034d3:	c3                   	ret    

c00034d4 <list_push>:
list_push():
c00034d4:	55                   	push   %ebp
c00034d5:	89 e5                	mov    %esp,%ebp
c00034d7:	83 ec 08             	sub    $0x8,%esp
c00034da:	8b 45 08             	mov    0x8(%ebp),%eax
c00034dd:	8b 40 04             	mov    0x4(%eax),%eax
c00034e0:	83 ec 08             	sub    $0x8,%esp
c00034e3:	ff 75 0c             	pushl  0xc(%ebp)
c00034e6:	50                   	push   %eax
c00034e7:	e8 a3 ff ff ff       	call   c000348f <list_insert_before>
c00034ec:	83 c4 10             	add    $0x10,%esp
c00034ef:	90                   	nop
c00034f0:	c9                   	leave  
c00034f1:	c3                   	ret    

c00034f2 <list_append>:
list_append():
c00034f2:	55                   	push   %ebp
c00034f3:	89 e5                	mov    %esp,%ebp
c00034f5:	83 ec 08             	sub    $0x8,%esp
c00034f8:	8b 45 08             	mov    0x8(%ebp),%eax
c00034fb:	83 c0 08             	add    $0x8,%eax
c00034fe:	83 ec 08             	sub    $0x8,%esp
c0003501:	ff 75 0c             	pushl  0xc(%ebp)
c0003504:	50                   	push   %eax
c0003505:	e8 85 ff ff ff       	call   c000348f <list_insert_before>
c000350a:	83 c4 10             	add    $0x10,%esp
c000350d:	90                   	nop
c000350e:	c9                   	leave  
c000350f:	c3                   	ret    

c0003510 <list_remove>:
list_remove():
c0003510:	55                   	push   %ebp
c0003511:	89 e5                	mov    %esp,%ebp
c0003513:	83 ec 18             	sub    $0x18,%esp
c0003516:	e8 97 e4 ff ff       	call   c00019b2 <intr_disable>
c000351b:	89 45 f4             	mov    %eax,-0xc(%ebp)
c000351e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003521:	8b 00                	mov    (%eax),%eax
c0003523:	8b 55 08             	mov    0x8(%ebp),%edx
c0003526:	8b 52 04             	mov    0x4(%edx),%edx
c0003529:	89 50 04             	mov    %edx,0x4(%eax)
c000352c:	8b 45 08             	mov    0x8(%ebp),%eax
c000352f:	8b 40 04             	mov    0x4(%eax),%eax
c0003532:	8b 55 08             	mov    0x8(%ebp),%edx
c0003535:	8b 12                	mov    (%edx),%edx
c0003537:	89 10                	mov    %edx,(%eax)
c0003539:	83 ec 0c             	sub    $0xc,%esp
c000353c:	ff 75 f4             	pushl  -0xc(%ebp)
c000353f:	e8 97 e4 ff ff       	call   c00019db <intr_set_status>
c0003544:	83 c4 10             	add    $0x10,%esp
c0003547:	90                   	nop
c0003548:	c9                   	leave  
c0003549:	c3                   	ret    

c000354a <list_pop>:
list_pop():
c000354a:	55                   	push   %ebp
c000354b:	89 e5                	mov    %esp,%ebp
c000354d:	83 ec 18             	sub    $0x18,%esp
c0003550:	8b 45 08             	mov    0x8(%ebp),%eax
c0003553:	8b 40 04             	mov    0x4(%eax),%eax
c0003556:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0003559:	83 ec 0c             	sub    $0xc,%esp
c000355c:	ff 75 f4             	pushl  -0xc(%ebp)
c000355f:	e8 ac ff ff ff       	call   c0003510 <list_remove>
c0003564:	83 c4 10             	add    $0x10,%esp
c0003567:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000356a:	c9                   	leave  
c000356b:	c3                   	ret    

c000356c <elem_find>:
elem_find():
c000356c:	55                   	push   %ebp
c000356d:	89 e5                	mov    %esp,%ebp
c000356f:	83 ec 10             	sub    $0x10,%esp
c0003572:	8b 45 08             	mov    0x8(%ebp),%eax
c0003575:	8b 40 04             	mov    0x4(%eax),%eax
c0003578:	89 45 fc             	mov    %eax,-0x4(%ebp)
c000357b:	eb 18                	jmp    c0003595 <elem_find+0x29>
c000357d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003580:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0003583:	75 07                	jne    c000358c <elem_find+0x20>
c0003585:	b8 01 00 00 00       	mov    $0x1,%eax
c000358a:	eb 19                	jmp    c00035a5 <elem_find+0x39>
c000358c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000358f:	8b 40 04             	mov    0x4(%eax),%eax
c0003592:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0003595:	8b 45 08             	mov    0x8(%ebp),%eax
c0003598:	83 c0 08             	add    $0x8,%eax
c000359b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c000359e:	75 dd                	jne    c000357d <elem_find+0x11>
c00035a0:	b8 00 00 00 00       	mov    $0x0,%eax
c00035a5:	c9                   	leave  
c00035a6:	c3                   	ret    

c00035a7 <list_traversal>:
list_traversal():
c00035a7:	55                   	push   %ebp
c00035a8:	89 e5                	mov    %esp,%ebp
c00035aa:	83 ec 18             	sub    $0x18,%esp
c00035ad:	8b 45 08             	mov    0x8(%ebp),%eax
c00035b0:	8b 40 04             	mov    0x4(%eax),%eax
c00035b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00035b6:	83 ec 0c             	sub    $0xc,%esp
c00035b9:	ff 75 08             	pushl  0x8(%ebp)
c00035bc:	e8 78 00 00 00       	call   c0003639 <list_empty>
c00035c1:	83 c4 10             	add    $0x10,%esp
c00035c4:	85 c0                	test   %eax,%eax
c00035c6:	74 2a                	je     c00035f2 <list_traversal+0x4b>
c00035c8:	b8 00 00 00 00       	mov    $0x0,%eax
c00035cd:	eb 33                	jmp    c0003602 <list_traversal+0x5b>
c00035cf:	83 ec 08             	sub    $0x8,%esp
c00035d2:	ff 75 10             	pushl  0x10(%ebp)
c00035d5:	ff 75 f4             	pushl  -0xc(%ebp)
c00035d8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00035db:	ff d0                	call   *%eax
c00035dd:	83 c4 10             	add    $0x10,%esp
c00035e0:	85 c0                	test   %eax,%eax
c00035e2:	74 05                	je     c00035e9 <list_traversal+0x42>
c00035e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00035e7:	eb 19                	jmp    c0003602 <list_traversal+0x5b>
c00035e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00035ec:	8b 40 04             	mov    0x4(%eax),%eax
c00035ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00035f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00035f5:	83 c0 08             	add    $0x8,%eax
c00035f8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00035fb:	75 d2                	jne    c00035cf <list_traversal+0x28>
c00035fd:	b8 00 00 00 00       	mov    $0x0,%eax
c0003602:	c9                   	leave  
c0003603:	c3                   	ret    

c0003604 <list_len>:
list_len():
c0003604:	55                   	push   %ebp
c0003605:	89 e5                	mov    %esp,%ebp
c0003607:	83 ec 10             	sub    $0x10,%esp
c000360a:	8b 45 08             	mov    0x8(%ebp),%eax
c000360d:	8b 40 04             	mov    0x4(%eax),%eax
c0003610:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0003613:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c000361a:	eb 0d                	jmp    c0003629 <list_len+0x25>
c000361c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0003620:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003623:	8b 40 04             	mov    0x4(%eax),%eax
c0003626:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0003629:	8b 45 08             	mov    0x8(%ebp),%eax
c000362c:	83 c0 08             	add    $0x8,%eax
c000362f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c0003632:	75 e8                	jne    c000361c <list_len+0x18>
c0003634:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0003637:	c9                   	leave  
c0003638:	c3                   	ret    

c0003639 <list_empty>:
list_empty():
c0003639:	55                   	push   %ebp
c000363a:	89 e5                	mov    %esp,%ebp
c000363c:	8b 45 08             	mov    0x8(%ebp),%eax
c000363f:	8b 40 04             	mov    0x4(%eax),%eax
c0003642:	8b 55 08             	mov    0x8(%ebp),%edx
c0003645:	83 c2 08             	add    $0x8,%edx
c0003648:	39 d0                	cmp    %edx,%eax
c000364a:	0f 94 c0             	sete   %al
c000364d:	0f b6 c0             	movzbl %al,%eax
c0003650:	5d                   	pop    %ebp
c0003651:	c3                   	ret    
c0003652:	66 90                	xchg   %ax,%ax
c0003654:	66 90                	xchg   %ax,%ax
c0003656:	66 90                	xchg   %ax,%ax
c0003658:	66 90                	xchg   %ax,%ax
c000365a:	66 90                	xchg   %ax,%ax
c000365c:	66 90                	xchg   %ax,%ax
c000365e:	66 90                	xchg   %ax,%ax

c0003660 <switch_to>:
switch_to():
c0003660:	56                   	push   %esi
c0003661:	57                   	push   %edi
c0003662:	53                   	push   %ebx
c0003663:	55                   	push   %ebp
c0003664:	8b 44 24 14          	mov    0x14(%esp),%eax
c0003668:	89 20                	mov    %esp,(%eax)
c000366a:	8b 44 24 18          	mov    0x18(%esp),%eax
c000366e:	8b 20                	mov    (%eax),%esp
c0003670:	5d                   	pop    %ebp
c0003671:	5b                   	pop    %ebx
c0003672:	5f                   	pop    %edi
c0003673:	5e                   	pop    %esi
c0003674:	c3                   	ret    

c0003675 <console_init>:
console_init():
/work/x86_os_my/device/console.c:9
#include "sync.h"
#include "thread.h"
static struct lock console_lock;	// 控制台锁

/* 初始化终端 */
void console_init() {
c0003675:	55                   	push   %ebp
c0003676:	89 e5                	mov    %esp,%ebp
c0003678:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:10
	lock_init(&console_lock);
c000367b:	83 ec 0c             	sub    $0xc,%esp
c000367e:	68 24 69 00 c0       	push   $0xc0006924
c0003683:	e8 cd 00 00 00       	call   c0003755 <lock_init>
c0003688:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:11
}
c000368b:	90                   	nop
c000368c:	c9                   	leave  
c000368d:	c3                   	ret    

c000368e <console_acquire>:
console_acquire():
/work/x86_os_my/device/console.c:14

/* 获取终端 */
void console_acquire() {
c000368e:	55                   	push   %ebp
c000368f:	89 e5                	mov    %esp,%ebp
c0003691:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:15
	lock_acquire(&console_lock);
c0003694:	83 ec 0c             	sub    $0xc,%esp
c0003697:	68 24 69 00 c0       	push   $0xc0006924
c000369c:	e8 8e 02 00 00       	call   c000392f <lock_acquire>
c00036a1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:16
}
c00036a4:	90                   	nop
c00036a5:	c9                   	leave  
c00036a6:	c3                   	ret    

c00036a7 <console_release>:
console_release():
/work/x86_os_my/device/console.c:19

/* 释放终端 */
void console_release() {
c00036a7:	55                   	push   %ebp
c00036a8:	89 e5                	mov    %esp,%ebp
c00036aa:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:20
	lock_release(&console_lock);
c00036ad:	83 ec 0c             	sub    $0xc,%esp
c00036b0:	68 24 69 00 c0       	push   $0xc0006924
c00036b5:	e8 ec 02 00 00       	call   c00039a6 <lock_release>
c00036ba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:21
}
c00036bd:	90                   	nop
c00036be:	c9                   	leave  
c00036bf:	c3                   	ret    

c00036c0 <console_put_str>:
console_put_str():
/work/x86_os_my/device/console.c:24

/* 终端中输出字符串 */
void console_put_str(char* str) {
c00036c0:	55                   	push   %ebp
c00036c1:	89 e5                	mov    %esp,%ebp
c00036c3:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:25
	console_acquire();
c00036c6:	e8 c3 ff ff ff       	call   c000368e <console_acquire>
/work/x86_os_my/device/console.c:26
	put_str(str);
c00036cb:	83 ec 0c             	sub    $0xc,%esp
c00036ce:	ff 75 08             	pushl  0x8(%ebp)
c00036d1:	e8 7a ea ff ff       	call   c0002150 <put_str>
c00036d6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:27
	console_release();
c00036d9:	e8 c9 ff ff ff       	call   c00036a7 <console_release>
/work/x86_os_my/device/console.c:28
}
c00036de:	90                   	nop
c00036df:	c9                   	leave  
c00036e0:	c3                   	ret    

c00036e1 <console_put_char>:
console_put_char():
/work/x86_os_my/device/console.c:31

/* 终端中输出字符 */
void console_put_char(uint8_t char_asci) {
c00036e1:	55                   	push   %ebp
c00036e2:	89 e5                	mov    %esp,%ebp
c00036e4:	83 ec 18             	sub    $0x18,%esp
c00036e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00036ea:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/console.c:32
	console_acquire();
c00036ed:	e8 9c ff ff ff       	call   c000368e <console_acquire>
/work/x86_os_my/device/console.c:33
	put_char(char_asci);
c00036f2:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00036f6:	83 ec 0c             	sub    $0xc,%esp
c00036f9:	50                   	push   %eax
c00036fa:	e8 6f ea ff ff       	call   c000216e <put_char>
c00036ff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:34
	console_release();
c0003702:	e8 a0 ff ff ff       	call   c00036a7 <console_release>
/work/x86_os_my/device/console.c:35
}
c0003707:	90                   	nop
c0003708:	c9                   	leave  
c0003709:	c3                   	ret    

c000370a <console_put_int>:
console_put_int():
/work/x86_os_my/device/console.c:38

/* 终端中输出16进制整数 */
void console_put_int(uint32_t num) {
c000370a:	55                   	push   %ebp
c000370b:	89 e5                	mov    %esp,%ebp
c000370d:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:39
	console_acquire();
c0003710:	e8 79 ff ff ff       	call   c000368e <console_acquire>
/work/x86_os_my/device/console.c:40
	put_int(num);
c0003715:	83 ec 0c             	sub    $0xc,%esp
c0003718:	ff 75 08             	pushl  0x8(%ebp)
c000371b:	e8 1b eb ff ff       	call   c000223b <put_int>
c0003720:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:41
	console_release();
c0003723:	e8 7f ff ff ff       	call   c00036a7 <console_release>
/work/x86_os_my/device/console.c:42
}
c0003728:	90                   	nop
c0003729:	c9                   	leave  
c000372a:	c3                   	ret    

c000372b <sema_init>:
sema_init():
/work/x86_os_my/thread/sync.c:8
#include "global.h"
#include "debug.h"
#include "interrupt.h"

/* 初始化信号量 */
void sema_init(struct semaphore* psema, uint8_t value) {
c000372b:	55                   	push   %ebp
c000372c:	89 e5                	mov    %esp,%ebp
c000372e:	83 ec 18             	sub    $0x18,%esp
c0003731:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003734:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:9
	psema->value = value;       // 为信号量赋初值
c0003737:	8b 45 08             	mov    0x8(%ebp),%eax
c000373a:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c000373e:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:10
	list_init(&psema->waiters); //初始化信号量的等待队列
c0003740:	8b 45 08             	mov    0x8(%ebp),%eax
c0003743:	83 c0 04             	add    $0x4,%eax
c0003746:	83 ec 0c             	sub    $0xc,%esp
c0003749:	50                   	push   %eax
c000374a:	e8 12 fd ff ff       	call   c0003461 <list_init>
c000374f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:11
}
c0003752:	90                   	nop
c0003753:	c9                   	leave  
c0003754:	c3                   	ret    

c0003755 <lock_init>:
lock_init():
/work/x86_os_my/thread/sync.c:14

/* 初始化锁plock */
void lock_init(struct lock* plock) {
c0003755:	55                   	push   %ebp
c0003756:	89 e5                	mov    %esp,%ebp
c0003758:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/sync.c:15
	plock->holder = NULL;
c000375b:	8b 45 08             	mov    0x8(%ebp),%eax
c000375e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:16
	plock->holder_repeat_nr = 0;
c0003764:	8b 45 08             	mov    0x8(%ebp),%eax
c0003767:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:17
	sema_init(&plock->semaphore, 1);  // 信号量初值为1
c000376e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003771:	83 c0 04             	add    $0x4,%eax
c0003774:	83 ec 08             	sub    $0x8,%esp
c0003777:	6a 01                	push   $0x1
c0003779:	50                   	push   %eax
c000377a:	e8 ac ff ff ff       	call   c000372b <sema_init>
c000377f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:18
}
c0003782:	90                   	nop
c0003783:	c9                   	leave  
c0003784:	c3                   	ret    

c0003785 <sema_down>:
sema_down():
/work/x86_os_my/thread/sync.c:21

/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
c0003785:	55                   	push   %ebp
c0003786:	89 e5                	mov    %esp,%ebp
c0003788:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:23
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
c000378b:	e8 22 e2 ff ff       	call   c00019b2 <intr_disable>
c0003790:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:25
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c0003793:	e9 98 00 00 00       	jmp    c0003830 <sema_down+0xab>
/work/x86_os_my/thread/sync.c:26
		ASSERT(!elem_find(&psema->waiters, &running_thread()->general_tag));
c0003798:	e8 6e f7 ff ff       	call   c0002f0b <running_thread>
c000379d:	8d 50 20             	lea    0x20(%eax),%edx
c00037a0:	8b 45 08             	mov    0x8(%ebp),%eax
c00037a3:	83 c0 04             	add    $0x4,%eax
c00037a6:	83 ec 08             	sub    $0x8,%esp
c00037a9:	52                   	push   %edx
c00037aa:	50                   	push   %eax
c00037ab:	e8 bc fd ff ff       	call   c000356c <elem_find>
c00037b0:	83 c4 10             	add    $0x10,%esp
c00037b3:	85 c0                	test   %eax,%eax
c00037b5:	74 19                	je     c00037d0 <sema_down+0x4b>
/work/x86_os_my/thread/sync.c:26 (discriminator 1)
c00037b7:	68 10 49 00 c0       	push   $0xc0004910
c00037bc:	68 14 4a 00 c0       	push   $0xc0004a14
c00037c1:	6a 1a                	push   $0x1a
c00037c3:	68 4c 49 00 c0       	push   $0xc000494c
c00037c8:	e8 f5 ea ff ff       	call   c00022c2 <panic_spin>
c00037cd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:28
		/* 当前线程不应该已在信号量的waiters队列中 */
		if (elem_find(&psema->waiters, &running_thread()->general_tag)) {
c00037d0:	e8 36 f7 ff ff       	call   c0002f0b <running_thread>
c00037d5:	8d 50 20             	lea    0x20(%eax),%edx
c00037d8:	8b 45 08             	mov    0x8(%ebp),%eax
c00037db:	83 c0 04             	add    $0x4,%eax
c00037de:	83 ec 08             	sub    $0x8,%esp
c00037e1:	52                   	push   %edx
c00037e2:	50                   	push   %eax
c00037e3:	e8 84 fd ff ff       	call   c000356c <elem_find>
c00037e8:	83 c4 10             	add    $0x10,%esp
c00037eb:	85 c0                	test   %eax,%eax
c00037ed:	74 19                	je     c0003808 <sema_down+0x83>
/work/x86_os_my/thread/sync.c:29
			PANIC("sema_down: thread blocked has been in waiters_list\n");
c00037ef:	68 5c 49 00 c0       	push   $0xc000495c
c00037f4:	68 14 4a 00 c0       	push   $0xc0004a14
c00037f9:	6a 1d                	push   $0x1d
c00037fb:	68 4c 49 00 c0       	push   $0xc000494c
c0003800:	e8 bd ea ff ff       	call   c00022c2 <panic_spin>
c0003805:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:32
		}
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
c0003808:	e8 fe f6 ff ff       	call   c0002f0b <running_thread>
c000380d:	8d 50 20             	lea    0x20(%eax),%edx
c0003810:	8b 45 08             	mov    0x8(%ebp),%eax
c0003813:	83 c0 04             	add    $0x4,%eax
c0003816:	83 ec 08             	sub    $0x8,%esp
c0003819:	52                   	push   %edx
c000381a:	50                   	push   %eax
c000381b:	e8 d2 fc ff ff       	call   c00034f2 <list_append>
c0003820:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:33
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
c0003823:	83 ec 0c             	sub    $0xc,%esp
c0003826:	6a 02                	push   $0x2
c0003828:	e8 89 fa ff ff       	call   c00032b6 <thread_block>
c000382d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:25
/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c0003830:	8b 45 08             	mov    0x8(%ebp),%eax
c0003833:	0f b6 00             	movzbl (%eax),%eax
c0003836:	84 c0                	test   %al,%al
c0003838:	0f 84 5a ff ff ff    	je     c0003798 <sema_down+0x13>
/work/x86_os_my/thread/sync.c:36
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
	}
	/* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*/
	psema->value--;
c000383e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003841:	0f b6 00             	movzbl (%eax),%eax
c0003844:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003847:	8b 45 08             	mov    0x8(%ebp),%eax
c000384a:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:37
	ASSERT(psema->value == 0);
c000384c:	8b 45 08             	mov    0x8(%ebp),%eax
c000384f:	0f b6 00             	movzbl (%eax),%eax
c0003852:	84 c0                	test   %al,%al
c0003854:	74 19                	je     c000386f <sema_down+0xea>
/work/x86_os_my/thread/sync.c:37 (discriminator 1)
c0003856:	68 90 49 00 c0       	push   $0xc0004990
c000385b:	68 14 4a 00 c0       	push   $0xc0004a14
c0003860:	6a 25                	push   $0x25
c0003862:	68 4c 49 00 c0       	push   $0xc000494c
c0003867:	e8 56 ea ff ff       	call   c00022c2 <panic_spin>
c000386c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:40
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c000386f:	83 ec 0c             	sub    $0xc,%esp
c0003872:	ff 75 f4             	pushl  -0xc(%ebp)
c0003875:	e8 61 e1 ff ff       	call   c00019db <intr_set_status>
c000387a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:41
}
c000387d:	90                   	nop
c000387e:	c9                   	leave  
c000387f:	c3                   	ret    

c0003880 <sema_up>:
sema_up():
/work/x86_os_my/thread/sync.c:44

/* 信号量的up操作 */
void sema_up(struct semaphore* psema) {
c0003880:	55                   	push   %ebp
c0003881:	89 e5                	mov    %esp,%ebp
c0003883:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:46
	/* 关中断,保证原子操作 */
	enum intr_status old_status = intr_disable();
c0003886:	e8 27 e1 ff ff       	call   c00019b2 <intr_disable>
c000388b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:48
	
	ASSERT(psema->value == 0);
c000388e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003891:	0f b6 00             	movzbl (%eax),%eax
c0003894:	84 c0                	test   %al,%al
c0003896:	74 19                	je     c00038b1 <sema_up+0x31>
/work/x86_os_my/thread/sync.c:48 (discriminator 1)
c0003898:	68 90 49 00 c0       	push   $0xc0004990
c000389d:	68 20 4a 00 c0       	push   $0xc0004a20
c00038a2:	6a 30                	push   $0x30
c00038a4:	68 4c 49 00 c0       	push   $0xc000494c
c00038a9:	e8 14 ea ff ff       	call   c00022c2 <panic_spin>
c00038ae:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:49
	if (!list_empty(&psema->waiters)) {
c00038b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00038b4:	83 c0 04             	add    $0x4,%eax
c00038b7:	83 ec 0c             	sub    $0xc,%esp
c00038ba:	50                   	push   %eax
c00038bb:	e8 79 fd ff ff       	call   c0003639 <list_empty>
c00038c0:	83 c4 10             	add    $0x10,%esp
c00038c3:	85 c0                	test   %eax,%eax
c00038c5:	75 26                	jne    c00038ed <sema_up+0x6d>
/work/x86_os_my/thread/sync.c:50
		struct task_struct* thread_blocked = elem2entry(struct task_struct, general_tag, list_pop(&psema->waiters));
c00038c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00038ca:	83 c0 04             	add    $0x4,%eax
c00038cd:	83 ec 0c             	sub    $0xc,%esp
c00038d0:	50                   	push   %eax
c00038d1:	e8 74 fc ff ff       	call   c000354a <list_pop>
c00038d6:	83 c4 10             	add    $0x10,%esp
c00038d9:	83 e8 20             	sub    $0x20,%eax
c00038dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/sync.c:51
		thread_unblock(thread_blocked);
c00038df:	83 ec 0c             	sub    $0xc,%esp
c00038e2:	ff 75 f0             	pushl  -0x10(%ebp)
c00038e5:	e8 2f fa ff ff       	call   c0003319 <thread_unblock>
c00038ea:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:53
	}
	psema->value++;
c00038ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00038f0:	0f b6 00             	movzbl (%eax),%eax
c00038f3:	8d 50 01             	lea    0x1(%eax),%edx
c00038f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00038f9:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:54
	ASSERT(psema->value == 1);
c00038fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00038fe:	0f b6 00             	movzbl (%eax),%eax
c0003901:	3c 01                	cmp    $0x1,%al
c0003903:	74 19                	je     c000391e <sema_up+0x9e>
/work/x86_os_my/thread/sync.c:54 (discriminator 1)
c0003905:	68 a2 49 00 c0       	push   $0xc00049a2
c000390a:	68 20 4a 00 c0       	push   $0xc0004a20
c000390f:	6a 36                	push   $0x36
c0003911:	68 4c 49 00 c0       	push   $0xc000494c
c0003916:	e8 a7 e9 ff ff       	call   c00022c2 <panic_spin>
c000391b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:57
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c000391e:	83 ec 0c             	sub    $0xc,%esp
c0003921:	ff 75 f4             	pushl  -0xc(%ebp)
c0003924:	e8 b2 e0 ff ff       	call   c00019db <intr_set_status>
c0003929:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:58
}
c000392c:	90                   	nop
c000392d:	c9                   	leave  
c000392e:	c3                   	ret    

c000392f <lock_acquire>:
lock_acquire():
/work/x86_os_my/thread/sync.c:61

/* 获取锁plock */
void lock_acquire(struct lock* plock) {
c000392f:	55                   	push   %ebp
c0003930:	89 e5                	mov    %esp,%ebp
c0003932:	53                   	push   %ebx
c0003933:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:63
	/* 排除曾经自己已经持有锁但还未将其释放的情况。*/
	if (plock->holder != running_thread()) {
c0003936:	8b 45 08             	mov    0x8(%ebp),%eax
c0003939:	8b 18                	mov    (%eax),%ebx
c000393b:	e8 cb f5 ff ff       	call   c0002f0b <running_thread>
c0003940:	39 c3                	cmp    %eax,%ebx
c0003942:	74 4d                	je     c0003991 <lock_acquire+0x62>
/work/x86_os_my/thread/sync.c:64
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
c0003944:	8b 45 08             	mov    0x8(%ebp),%eax
c0003947:	83 c0 04             	add    $0x4,%eax
c000394a:	83 ec 0c             	sub    $0xc,%esp
c000394d:	50                   	push   %eax
c000394e:	e8 32 fe ff ff       	call   c0003785 <sema_down>
c0003953:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:65
		plock->holder = running_thread();
c0003956:	e8 b0 f5 ff ff       	call   c0002f0b <running_thread>
c000395b:	89 c2                	mov    %eax,%edx
c000395d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003960:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/sync.c:66
		ASSERT(plock->holder_repeat_nr == 0);
c0003962:	8b 45 08             	mov    0x8(%ebp),%eax
c0003965:	8b 40 18             	mov    0x18(%eax),%eax
c0003968:	85 c0                	test   %eax,%eax
c000396a:	74 19                	je     c0003985 <lock_acquire+0x56>
/work/x86_os_my/thread/sync.c:66 (discriminator 1)
c000396c:	68 b4 49 00 c0       	push   $0xc00049b4
c0003971:	68 28 4a 00 c0       	push   $0xc0004a28
c0003976:	6a 42                	push   $0x42
c0003978:	68 4c 49 00 c0       	push   $0xc000494c
c000397d:	e8 40 e9 ff ff       	call   c00022c2 <panic_spin>
c0003982:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:67
		plock->holder_repeat_nr = 1;
c0003985:	8b 45 08             	mov    0x8(%ebp),%eax
c0003988:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	} else {
		plock->holder_repeat_nr++;
	}
}
c000398f:	eb 0f                	jmp    c00039a0 <lock_acquire+0x71>
/work/x86_os_my/thread/sync.c:69
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
		plock->holder = running_thread();
		ASSERT(plock->holder_repeat_nr == 0);
		plock->holder_repeat_nr = 1;
	} else {
		plock->holder_repeat_nr++;
c0003991:	8b 45 08             	mov    0x8(%ebp),%eax
c0003994:	8b 40 18             	mov    0x18(%eax),%eax
c0003997:	8d 50 01             	lea    0x1(%eax),%edx
c000399a:	8b 45 08             	mov    0x8(%ebp),%eax
c000399d:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	}
}
c00039a0:	90                   	nop
c00039a1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00039a4:	c9                   	leave  
c00039a5:	c3                   	ret    

c00039a6 <lock_release>:
lock_release():
/work/x86_os_my/thread/sync.c:74

/* 释放锁plock */
void lock_release(struct lock* plock) {
c00039a6:	55                   	push   %ebp
c00039a7:	89 e5                	mov    %esp,%ebp
c00039a9:	53                   	push   %ebx
c00039aa:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:75
	ASSERT(plock->holder == running_thread());
c00039ad:	8b 45 08             	mov    0x8(%ebp),%eax
c00039b0:	8b 18                	mov    (%eax),%ebx
c00039b2:	e8 54 f5 ff ff       	call   c0002f0b <running_thread>
c00039b7:	39 c3                	cmp    %eax,%ebx
c00039b9:	74 19                	je     c00039d4 <lock_release+0x2e>
/work/x86_os_my/thread/sync.c:75 (discriminator 1)
c00039bb:	68 d4 49 00 c0       	push   $0xc00049d4
c00039c0:	68 38 4a 00 c0       	push   $0xc0004a38
c00039c5:	6a 4b                	push   $0x4b
c00039c7:	68 4c 49 00 c0       	push   $0xc000494c
c00039cc:	e8 f1 e8 ff ff       	call   c00022c2 <panic_spin>
c00039d1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:76
	if (plock->holder_repeat_nr > 1) {
c00039d4:	8b 45 08             	mov    0x8(%ebp),%eax
c00039d7:	8b 40 18             	mov    0x18(%eax),%eax
c00039da:	83 f8 01             	cmp    $0x1,%eax
c00039dd:	76 11                	jbe    c00039f0 <lock_release+0x4a>
/work/x86_os_my/thread/sync.c:77
		plock->holder_repeat_nr--;
c00039df:	8b 45 08             	mov    0x8(%ebp),%eax
c00039e2:	8b 40 18             	mov    0x18(%eax),%eax
c00039e5:	8d 50 ff             	lea    -0x1(%eax),%edx
c00039e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00039eb:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:78
		return;
c00039ee:	eb 49                	jmp    c0003a39 <lock_release+0x93>
/work/x86_os_my/thread/sync.c:80
	}
	ASSERT(plock->holder_repeat_nr == 1);
c00039f0:	8b 45 08             	mov    0x8(%ebp),%eax
c00039f3:	8b 40 18             	mov    0x18(%eax),%eax
c00039f6:	83 f8 01             	cmp    $0x1,%eax
c00039f9:	74 19                	je     c0003a14 <lock_release+0x6e>
/work/x86_os_my/thread/sync.c:80 (discriminator 1)
c00039fb:	68 f6 49 00 c0       	push   $0xc00049f6
c0003a00:	68 38 4a 00 c0       	push   $0xc0004a38
c0003a05:	6a 50                	push   $0x50
c0003a07:	68 4c 49 00 c0       	push   $0xc000494c
c0003a0c:	e8 b1 e8 ff ff       	call   c00022c2 <panic_spin>
c0003a11:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:82

	plock->holder = NULL;			// 把锁的持有者置空放在V操作之前
c0003a14:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a17:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:83
	plock->holder_repeat_nr = 0;
c0003a1d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a20:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:84
	sema_up(&plock->semaphore);		// 信号量的V操作,也是原子操作
c0003a27:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a2a:	83 c0 04             	add    $0x4,%eax
c0003a2d:	83 ec 0c             	sub    $0xc,%esp
c0003a30:	50                   	push   %eax
c0003a31:	e8 4a fe ff ff       	call   c0003880 <sema_up>
c0003a36:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:85
}
c0003a39:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0003a3c:	c9                   	leave  
c0003a3d:	c3                   	ret    

c0003a3e <inb>:
inb():
/work/x86_os_my/lib/kernel/io.h:36
   asm volatile ("cld; rep outsw" : "+S" (addr), "+c" (word_cnt) : "d" (port));
/******************************************************/
}

/* 将从端口port读入的一个字节返回 */
static inline uint8_t inb(uint16_t port) {
c0003a3e:	55                   	push   %ebp
c0003a3f:	89 e5                	mov    %esp,%ebp
c0003a41:	83 ec 14             	sub    $0x14,%esp
c0003a44:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a47:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/io.h:38
   uint8_t data;
   asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0003a4b:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0003a4f:	89 c2                	mov    %eax,%edx
c0003a51:	ec                   	in     (%dx),%al
c0003a52:	88 45 ff             	mov    %al,-0x1(%ebp)
/work/x86_os_my/lib/kernel/io.h:39
   return data;
c0003a55:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
/work/x86_os_my/lib/kernel/io.h:40
}
c0003a59:	c9                   	leave  
c0003a5a:	c3                   	ret    

c0003a5b <intr_keyboard_handler>:
intr_keyboard_handler():
/work/x86_os_my/device/keyboard.c:111
/* 0x3A */	{caps_lock_char, caps_lock_char}
/*其它按键暂不处理*/
};

/* 键盘中断处理程序 */
static void intr_keyboard_handler(void) {
c0003a5b:	55                   	push   %ebp
c0003a5c:	89 e5                	mov    %esp,%ebp
c0003a5e:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/device/keyboard.c:114

/* 这次中断发生前的上一次中断,以下任意三个键是否有按下 */
   bool ctrl_down_last = ctrl_status;	  
c0003a61:	a1 40 69 00 c0       	mov    0xc0006940,%eax
c0003a66:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/device/keyboard.c:115
   bool shift_down_last = shift_status;
c0003a69:	a1 44 69 00 c0       	mov    0xc0006944,%eax
c0003a6e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/device/keyboard.c:116
   bool caps_lock_last = caps_lock_status;
c0003a71:	a1 4c 69 00 c0       	mov    0xc000694c,%eax
c0003a76:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/device/keyboard.c:119

   bool break_code;
   uint16_t scancode = inb(KBD_BUF_PORT);
c0003a79:	6a 60                	push   $0x60
c0003a7b:	e8 be ff ff ff       	call   c0003a3e <inb>
c0003a80:	83 c4 04             	add    $0x4,%esp
c0003a83:	0f b6 c0             	movzbl %al,%eax
c0003a86:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:123

/* 若扫描码是e0开头的,表示此键的按下将产生多个扫描码,
 * 所以马上结束此次中断处理函数,等待下一个扫描码进来*/ 
   if (scancode == 0xe0) { 
c0003a8a:	66 81 7d f6 e0 00    	cmpw   $0xe0,-0xa(%ebp)
c0003a90:	75 0f                	jne    c0003aa1 <intr_keyboard_handler+0x46>
/work/x86_os_my/device/keyboard.c:124
      ext_scancode = true;    // 打开e0标记
c0003a92:	c7 05 50 69 00 c0 01 	movl   $0x1,0xc0006950
c0003a99:	00 00 00 
/work/x86_os_my/device/keyboard.c:125
      return;
c0003a9c:	e9 50 02 00 00       	jmp    c0003cf1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:129
   }

/* 如果上次是以0xe0开头,将扫描码合并 */
   if (ext_scancode) {
c0003aa1:	a1 50 69 00 c0       	mov    0xc0006950,%eax
c0003aa6:	85 c0                	test   %eax,%eax
c0003aa8:	74 10                	je     c0003aba <intr_keyboard_handler+0x5f>
/work/x86_os_my/device/keyboard.c:130
      scancode = ((0xe000) | scancode);
c0003aaa:	66 81 4d f6 00 e0    	orw    $0xe000,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:131
      ext_scancode = false;   // 关闭e0标记
c0003ab0:	c7 05 50 69 00 c0 00 	movl   $0x0,0xc0006950
c0003ab7:	00 00 00 
/work/x86_os_my/device/keyboard.c:134
   }   

   break_code = ((scancode & 0x0080) != 0);   // 获取break_code
c0003aba:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0003abe:	25 80 00 00 00       	and    $0x80,%eax
c0003ac3:	85 c0                	test   %eax,%eax
c0003ac5:	0f 95 c0             	setne  %al
c0003ac8:	0f b6 c0             	movzbl %al,%eax
c0003acb:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/device/keyboard.c:136
   
   if (break_code) {   // 若是断码break_code(按键弹起时产生的扫描码)
c0003ace:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0003ad2:	74 6a                	je     c0003b3e <intr_keyboard_handler+0xe3>
/work/x86_os_my/device/keyboard.c:140

   /* 由于ctrl_r 和alt_r的make_code和break_code都是两字节,
   所以可用下面的方法取make_code,多字节的扫描码暂不处理 */
      uint16_t make_code = (scancode &= 0xff7f);   // 得到其make_code(按键按下时产生的扫描码)
c0003ad4:	66 81 65 f6 7f ff    	andw   $0xff7f,-0xa(%ebp)
c0003ada:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0003ade:	66 89 45 da          	mov    %ax,-0x26(%ebp)
/work/x86_os_my/device/keyboard.c:143

   /* 若是任意以下三个键弹起了,将状态置为false */
      if (make_code == ctrl_l_make || make_code == ctrl_r_make) {
c0003ae2:	66 83 7d da 1d       	cmpw   $0x1d,-0x26(%ebp)
c0003ae7:	74 08                	je     c0003af1 <intr_keyboard_handler+0x96>
/work/x86_os_my/device/keyboard.c:143 (discriminator 1)
c0003ae9:	66 81 7d da 1d e0    	cmpw   $0xe01d,-0x26(%ebp)
c0003aef:	75 0c                	jne    c0003afd <intr_keyboard_handler+0xa2>
/work/x86_os_my/device/keyboard.c:144
	 ctrl_status = false;
c0003af1:	c7 05 40 69 00 c0 00 	movl   $0x0,0xc0006940
c0003af8:	00 00 00 
c0003afb:	eb 3c                	jmp    c0003b39 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:145
      } else if (make_code == shift_l_make || make_code == shift_r_make) {
c0003afd:	66 83 7d da 2a       	cmpw   $0x2a,-0x26(%ebp)
c0003b02:	74 07                	je     c0003b0b <intr_keyboard_handler+0xb0>
/work/x86_os_my/device/keyboard.c:145 (discriminator 1)
c0003b04:	66 83 7d da 36       	cmpw   $0x36,-0x26(%ebp)
c0003b09:	75 0c                	jne    c0003b17 <intr_keyboard_handler+0xbc>
/work/x86_os_my/device/keyboard.c:146
	 shift_status = false;
c0003b0b:	c7 05 44 69 00 c0 00 	movl   $0x0,0xc0006944
c0003b12:	00 00 00 
c0003b15:	eb 22                	jmp    c0003b39 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:147
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
c0003b17:	66 83 7d da 38       	cmpw   $0x38,-0x26(%ebp)
c0003b1c:	74 0c                	je     c0003b2a <intr_keyboard_handler+0xcf>
/work/x86_os_my/device/keyboard.c:147 (discriminator 1)
c0003b1e:	66 81 7d da 38 e0    	cmpw   $0xe038,-0x26(%ebp)
c0003b24:	0f 85 c0 01 00 00    	jne    c0003cea <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:148
	 alt_status = false;
c0003b2a:	c7 05 48 69 00 c0 00 	movl   $0x0,0xc0006948
c0003b31:	00 00 00 
/work/x86_os_my/device/keyboard.c:151
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c0003b34:	e9 b1 01 00 00       	jmp    c0003cea <intr_keyboard_handler+0x28f>
c0003b39:	e9 ac 01 00 00       	jmp    c0003cea <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:155

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
c0003b3e:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c0003b43:	74 07                	je     c0003b4c <intr_keyboard_handler+0xf1>
/work/x86_os_my/device/keyboard.c:155 (discriminator 1)
c0003b45:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0003b4a:	76 14                	jbe    c0003b60 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:155 (discriminator 3)
c0003b4c:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c0003b52:	74 0c                	je     c0003b60 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:156
	       (scancode == alt_r_make) || \
c0003b54:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0003b5a:	0f 85 78 01 00 00    	jne    c0003cd8 <intr_keyboard_handler+0x27d>
/work/x86_os_my/device/keyboard.c:158
	       (scancode == ctrl_r_make)) {
      bool shift = false;  // 判断是否与shift组合,用来在一维数组中索引对应的字符
c0003b60:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:159
      if ((scancode < 0x0e) || (scancode == 0x29) || \
c0003b67:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%ebp)
c0003b6c:	76 3f                	jbe    c0003bad <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 1)
c0003b6e:	66 83 7d f6 29       	cmpw   $0x29,-0xa(%ebp)
c0003b73:	74 38                	je     c0003bad <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 2)
c0003b75:	66 83 7d f6 1a       	cmpw   $0x1a,-0xa(%ebp)
c0003b7a:	74 31                	je     c0003bad <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160
	 (scancode == 0x1a) || (scancode == 0x1b) || \
c0003b7c:	66 83 7d f6 1b       	cmpw   $0x1b,-0xa(%ebp)
c0003b81:	74 2a                	je     c0003bad <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160 (discriminator 1)
c0003b83:	66 83 7d f6 2b       	cmpw   $0x2b,-0xa(%ebp)
c0003b88:	74 23                	je     c0003bad <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161
	 (scancode == 0x2b) || (scancode == 0x27) || \
c0003b8a:	66 83 7d f6 27       	cmpw   $0x27,-0xa(%ebp)
c0003b8f:	74 1c                	je     c0003bad <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161 (discriminator 1)
c0003b91:	66 83 7d f6 28       	cmpw   $0x28,-0xa(%ebp)
c0003b96:	74 15                	je     c0003bad <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162
	 (scancode == 0x28) || (scancode == 0x33) || \
c0003b98:	66 83 7d f6 33       	cmpw   $0x33,-0xa(%ebp)
c0003b9d:	74 0e                	je     c0003bad <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162 (discriminator 1)
c0003b9f:	66 83 7d f6 34       	cmpw   $0x34,-0xa(%ebp)
c0003ba4:	74 07                	je     c0003bad <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:163
	 (scancode == 0x34) || (scancode == 0x35)) {  
c0003ba6:	66 83 7d f6 35       	cmpw   $0x35,-0xa(%ebp)
c0003bab:	75 0f                	jne    c0003bbc <intr_keyboard_handler+0x161>
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c0003bad:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0003bb1:	74 3a                	je     c0003bed <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:177
	    shift = true;
c0003bb3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c0003bba:	eb 31                	jmp    c0003bed <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:180
	    shift = true;
	 }
      } else {	  // 默认为字母键
	 if (shift_down_last && caps_lock_last) {  // 如果shift和capslock同时按下
c0003bbc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0003bc0:	74 0f                	je     c0003bd1 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:180 (discriminator 1)
c0003bc2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0003bc6:	74 09                	je     c0003bd1 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:181
	    shift = false;
c0003bc8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0003bcf:	eb 1c                	jmp    c0003bed <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:182
	 } else if (shift_down_last || caps_lock_last) { // 如果shift和capslock任意被按下
c0003bd1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0003bd5:	75 06                	jne    c0003bdd <intr_keyboard_handler+0x182>
/work/x86_os_my/device/keyboard.c:182 (discriminator 1)
c0003bd7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0003bdb:	74 09                	je     c0003be6 <intr_keyboard_handler+0x18b>
/work/x86_os_my/device/keyboard.c:183
	    shift = true;
c0003bdd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c0003be4:	eb 07                	jmp    c0003bed <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:185
	 } else {
	    shift = false;
c0003be6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:189
	 }
      }

      uint8_t index = (scancode &= 0x00ff);  // 将扫描码的高字节置0,主要是针对高字节是e0的扫描码.
c0003bed:	66 81 65 f6 ff 00    	andw   $0xff,-0xa(%ebp)
c0003bf3:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0003bf7:	88 45 d9             	mov    %al,-0x27(%ebp)
/work/x86_os_my/device/keyboard.c:190
      char cur_char = keymap[index][shift];  // 在数组中找到对应的字符
c0003bfa:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
c0003bfe:	8d 14 00             	lea    (%eax,%eax,1),%edx
c0003c01:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003c04:	01 d0                	add    %edx,%eax
c0003c06:	05 20 67 00 c0       	add    $0xc0006720,%eax
c0003c0b:	0f b6 00             	movzbl (%eax),%eax
c0003c0e:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:193

   /* 如果cur_char不为0,也就是ascii码为除'\0'外的字符就加入键盘缓冲区中 */
      if (cur_char) {
c0003c11:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c0003c15:	74 54                	je     c0003c6b <intr_keyboard_handler+0x210>
/work/x86_os_my/device/keyboard.c:200
     /*****************  快捷键ctrl+l和ctrl+u的处理 *********************
      * 下面是把ctrl+l和ctrl+u这两种组合键产生的字符置为:
      * cur_char的asc码-字符a的asc码, 此差值比较小,
      * 属于asc码表中不可见的字符部分.故不会产生可见字符.
      * 我们在shell中将ascii值为l-a和u-a的分别处理为清屏和删除输入的快捷键*/
	 if ((ctrl_down_last && cur_char == 'l') || (ctrl_down_last && cur_char == 'u')) {
c0003c17:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0003c1b:	74 06                	je     c0003c23 <intr_keyboard_handler+0x1c8>
/work/x86_os_my/device/keyboard.c:200 (discriminator 1)
c0003c1d:	80 7d ef 6c          	cmpb   $0x6c,-0x11(%ebp)
c0003c21:	74 0c                	je     c0003c2f <intr_keyboard_handler+0x1d4>
/work/x86_os_my/device/keyboard.c:200 (discriminator 3)
c0003c23:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0003c27:	74 10                	je     c0003c39 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:200 (discriminator 4)
c0003c29:	80 7d ef 75          	cmpb   $0x75,-0x11(%ebp)
c0003c2d:	75 0a                	jne    c0003c39 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:201
	    cur_char -= 'a';
c0003c2f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c0003c33:	83 e8 61             	sub    $0x61,%eax
c0003c36:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:207
	 }
      /****************************************************************/
      
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
c0003c39:	83 ec 0c             	sub    $0xc,%esp
c0003c3c:	68 40 6b 00 c0       	push   $0xc0006b40
c0003c41:	e8 58 01 00 00       	call   c0003d9e <ioq_full>
c0003c46:	83 c4 10             	add    $0x10,%esp
c0003c49:	85 c0                	test   %eax,%eax
c0003c4b:	0f 85 9c 00 00 00    	jne    c0003ced <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:208
	    ioq_putchar(&kbd_buf, cur_char);
c0003c51:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
c0003c55:	83 ec 08             	sub    $0x8,%esp
c0003c58:	50                   	push   %eax
c0003c59:	68 40 6b 00 c0       	push   $0xc0006b40
c0003c5e:	e8 0d 03 00 00       	call   c0003f70 <ioq_putchar>
c0003c63:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:210
	 }
	 return;
c0003c66:	e9 82 00 00 00       	jmp    c0003ced <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:214
      }

      /* 记录本次是否按下了下面几类控制键之一,供下次键入时判断组合键 */
      if (scancode == ctrl_l_make || scancode == ctrl_r_make) {
c0003c6b:	66 83 7d f6 1d       	cmpw   $0x1d,-0xa(%ebp)
c0003c70:	74 08                	je     c0003c7a <intr_keyboard_handler+0x21f>
/work/x86_os_my/device/keyboard.c:214 (discriminator 1)
c0003c72:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0003c78:	75 0c                	jne    c0003c86 <intr_keyboard_handler+0x22b>
/work/x86_os_my/device/keyboard.c:215
	 ctrl_status = true;
c0003c7a:	c7 05 40 69 00 c0 01 	movl   $0x1,0xc0006940
c0003c81:	00 00 00 
c0003c84:	eb 50                	jmp    c0003cd6 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:216
      } else if (scancode == shift_l_make || scancode == shift_r_make) {
c0003c86:	66 83 7d f6 2a       	cmpw   $0x2a,-0xa(%ebp)
c0003c8b:	74 07                	je     c0003c94 <intr_keyboard_handler+0x239>
/work/x86_os_my/device/keyboard.c:216 (discriminator 1)
c0003c8d:	66 83 7d f6 36       	cmpw   $0x36,-0xa(%ebp)
c0003c92:	75 0c                	jne    c0003ca0 <intr_keyboard_handler+0x245>
/work/x86_os_my/device/keyboard.c:217
	 shift_status = true;
c0003c94:	c7 05 44 69 00 c0 01 	movl   $0x1,0xc0006944
c0003c9b:	00 00 00 
c0003c9e:	eb 36                	jmp    c0003cd6 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:218
      } else if (scancode == alt_l_make || scancode == alt_r_make) {
c0003ca0:	66 83 7d f6 38       	cmpw   $0x38,-0xa(%ebp)
c0003ca5:	74 08                	je     c0003caf <intr_keyboard_handler+0x254>
/work/x86_os_my/device/keyboard.c:218 (discriminator 1)
c0003ca7:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c0003cad:	75 0c                	jne    c0003cbb <intr_keyboard_handler+0x260>
/work/x86_os_my/device/keyboard.c:219
	 alt_status = true;
c0003caf:	c7 05 48 69 00 c0 01 	movl   $0x1,0xc0006948
c0003cb6:	00 00 00 
c0003cb9:	eb 1b                	jmp    c0003cd6 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:220
      } else if (scancode == caps_lock_make) {
c0003cbb:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0003cc0:	75 2e                	jne    c0003cf0 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:223
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
c0003cc2:	a1 4c 69 00 c0       	mov    0xc000694c,%eax
c0003cc7:	85 c0                	test   %eax,%eax
c0003cc9:	0f 94 c0             	sete   %al
c0003ccc:	0f b6 c0             	movzbl %al,%eax
c0003ccf:	a3 4c 69 00 c0       	mov    %eax,0xc000694c
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c0003cd4:	eb 1a                	jmp    c0003cf0 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:157 (discriminator 3)
c0003cd6:	eb 18                	jmp    c0003cf0 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:226
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
c0003cd8:	83 ec 0c             	sub    $0xc,%esp
c0003cdb:	68 45 4a 00 c0       	push   $0xc0004a45
c0003ce0:	e8 6b e4 ff ff       	call   c0002150 <put_str>
c0003ce5:	83 c4 10             	add    $0x10,%esp
c0003ce8:	eb 07                	jmp    c0003cf1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:151
	 shift_status = false;
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
	 alt_status = false;
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c0003cea:	90                   	nop
c0003ceb:	eb 04                	jmp    c0003cf1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:210
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
	    ioq_putchar(&kbd_buf, cur_char);
	 }
	 return;
c0003ced:	90                   	nop
c0003cee:	eb 01                	jmp    c0003cf1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c0003cf0:	90                   	nop
/work/x86_os_my/device/keyboard.c:228
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
   }
}
c0003cf1:	c9                   	leave  
c0003cf2:	c3                   	ret    

c0003cf3 <keyboard_init>:
keyboard_init():
/work/x86_os_my/device/keyboard.c:231

/* 键盘初始化 */
void keyboard_init() {
c0003cf3:	55                   	push   %ebp
c0003cf4:	89 e5                	mov    %esp,%ebp
c0003cf6:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/keyboard.c:232
   put_str("keyboard init start\n");
c0003cf9:	83 ec 0c             	sub    $0xc,%esp
c0003cfc:	68 52 4a 00 c0       	push   $0xc0004a52
c0003d01:	e8 4a e4 ff ff       	call   c0002150 <put_str>
c0003d06:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:233
   ioqueue_init(&kbd_buf);
c0003d09:	83 ec 0c             	sub    $0xc,%esp
c0003d0c:	68 40 6b 00 c0       	push   $0xc0006b40
c0003d11:	e8 28 00 00 00       	call   c0003d3e <ioqueue_init>
c0003d16:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:234
   register_handler(0x21, intr_keyboard_handler);
c0003d19:	83 ec 08             	sub    $0x8,%esp
c0003d1c:	68 5b 3a 00 c0       	push   $0xc0003a5b
c0003d21:	6a 21                	push   $0x21
c0003d23:	e8 f5 dc ff ff       	call   c0001a1d <register_handler>
c0003d28:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:235
   put_str("keyboard init done\n");
c0003d2b:	83 ec 0c             	sub    $0xc,%esp
c0003d2e:	68 67 4a 00 c0       	push   $0xc0004a67
c0003d33:	e8 18 e4 ff ff       	call   c0002150 <put_str>
c0003d38:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:236
}
c0003d3b:	90                   	nop
c0003d3c:	c9                   	leave  
c0003d3d:	c3                   	ret    

c0003d3e <ioqueue_init>:
ioqueue_init():
/work/x86_os_my/device/ioqueue.c:7
#include "interrupt.h"
#include "global.h"
#include "debug.h"

/* 初始化io队列ioq */
void ioqueue_init(struct ioqueue* ioq) {
c0003d3e:	55                   	push   %ebp
c0003d3f:	89 e5                	mov    %esp,%ebp
c0003d41:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:8
   lock_init(&ioq->lock);     // 初始化io队列的锁
c0003d44:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d47:	83 ec 0c             	sub    $0xc,%esp
c0003d4a:	50                   	push   %eax
c0003d4b:	e8 05 fa ff ff       	call   c0003755 <lock_init>
c0003d50:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:9
   ioq->producer = ioq->consumer = NULL;  // 生产者和消费者置空
c0003d53:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d56:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c0003d5d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d60:	8b 50 20             	mov    0x20(%eax),%edx
c0003d63:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d66:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/device/ioqueue.c:10
   ioq->head = ioq->tail = 0; // 队列的首尾指针指向缓冲区数组第0个位置
c0003d69:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d6c:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)
c0003d73:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d76:	8b 50 68             	mov    0x68(%eax),%edx
c0003d79:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d7c:	89 50 64             	mov    %edx,0x64(%eax)
/work/x86_os_my/device/ioqueue.c:11
}
c0003d7f:	90                   	nop
c0003d80:	c9                   	leave  
c0003d81:	c3                   	ret    

c0003d82 <next_pos>:
next_pos():
/work/x86_os_my/device/ioqueue.c:14

/* 返回pos在缓冲区中的下一个位置值 */
static int32_t next_pos(int32_t pos) {
c0003d82:	55                   	push   %ebp
c0003d83:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/device/ioqueue.c:15
   return (pos + 1) % bufsize; 
c0003d85:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d88:	8d 50 01             	lea    0x1(%eax),%edx
c0003d8b:	89 d0                	mov    %edx,%eax
c0003d8d:	c1 f8 1f             	sar    $0x1f,%eax
c0003d90:	c1 e8 1a             	shr    $0x1a,%eax
c0003d93:	01 c2                	add    %eax,%edx
c0003d95:	83 e2 3f             	and    $0x3f,%edx
c0003d98:	29 c2                	sub    %eax,%edx
c0003d9a:	89 d0                	mov    %edx,%eax
/work/x86_os_my/device/ioqueue.c:16
}
c0003d9c:	5d                   	pop    %ebp
c0003d9d:	c3                   	ret    

c0003d9e <ioq_full>:
ioq_full():
/work/x86_os_my/device/ioqueue.c:19

/* 判断队列是否已满 */
bool ioq_full(struct ioqueue* ioq) {
c0003d9e:	55                   	push   %ebp
c0003d9f:	89 e5                	mov    %esp,%ebp
c0003da1:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:20
   ASSERT(intr_get_status() == INTR_OFF);
c0003da4:	e8 50 dc ff ff       	call   c00019f9 <intr_get_status>
c0003da9:	85 c0                	test   %eax,%eax
c0003dab:	74 19                	je     c0003dc6 <ioq_full+0x28>
/work/x86_os_my/device/ioqueue.c:20 (discriminator 1)
c0003dad:	68 7c 4a 00 c0       	push   $0xc0004a7c
c0003db2:	68 e0 4a 00 c0       	push   $0xc0004ae0
c0003db7:	6a 14                	push   $0x14
c0003db9:	68 9a 4a 00 c0       	push   $0xc0004a9a
c0003dbe:	e8 ff e4 ff ff       	call   c00022c2 <panic_spin>
c0003dc3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:21
   return next_pos(ioq->head) == ioq->tail;
c0003dc6:	8b 45 08             	mov    0x8(%ebp),%eax
c0003dc9:	8b 40 64             	mov    0x64(%eax),%eax
c0003dcc:	83 ec 0c             	sub    $0xc,%esp
c0003dcf:	50                   	push   %eax
c0003dd0:	e8 ad ff ff ff       	call   c0003d82 <next_pos>
c0003dd5:	83 c4 10             	add    $0x10,%esp
c0003dd8:	89 c2                	mov    %eax,%edx
c0003dda:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ddd:	8b 40 68             	mov    0x68(%eax),%eax
c0003de0:	39 c2                	cmp    %eax,%edx
c0003de2:	0f 94 c0             	sete   %al
c0003de5:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:22
}
c0003de8:	c9                   	leave  
c0003de9:	c3                   	ret    

c0003dea <ioq_empty>:
ioq_empty():
/work/x86_os_my/device/ioqueue.c:25

/* 判断队列是否已空 */
bool ioq_empty(struct ioqueue* ioq) {
c0003dea:	55                   	push   %ebp
c0003deb:	89 e5                	mov    %esp,%ebp
c0003ded:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:26
   ASSERT(intr_get_status() == INTR_OFF);
c0003df0:	e8 04 dc ff ff       	call   c00019f9 <intr_get_status>
c0003df5:	85 c0                	test   %eax,%eax
c0003df7:	74 19                	je     c0003e12 <ioq_empty+0x28>
/work/x86_os_my/device/ioqueue.c:26 (discriminator 1)
c0003df9:	68 7c 4a 00 c0       	push   $0xc0004a7c
c0003dfe:	68 ec 4a 00 c0       	push   $0xc0004aec
c0003e03:	6a 1a                	push   $0x1a
c0003e05:	68 9a 4a 00 c0       	push   $0xc0004a9a
c0003e0a:	e8 b3 e4 ff ff       	call   c00022c2 <panic_spin>
c0003e0f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:27
   return ioq->head == ioq->tail;
c0003e12:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e15:	8b 50 64             	mov    0x64(%eax),%edx
c0003e18:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e1b:	8b 40 68             	mov    0x68(%eax),%eax
c0003e1e:	39 c2                	cmp    %eax,%edx
c0003e20:	0f 94 c0             	sete   %al
c0003e23:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:28
}
c0003e26:	c9                   	leave  
c0003e27:	c3                   	ret    

c0003e28 <ioq_wait>:
ioq_wait():
/work/x86_os_my/device/ioqueue.c:31

/* 使当前生产者或消费者在此缓冲区上等待 */
static void ioq_wait(struct task_struct** waiter) {
c0003e28:	55                   	push   %ebp
c0003e29:	89 e5                	mov    %esp,%ebp
c0003e2b:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:32
   ASSERT(*waiter == NULL && waiter != NULL);
c0003e2e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e31:	8b 00                	mov    (%eax),%eax
c0003e33:	85 c0                	test   %eax,%eax
c0003e35:	75 06                	jne    c0003e3d <ioq_wait+0x15>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 1)
c0003e37:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003e3b:	75 19                	jne    c0003e56 <ioq_wait+0x2e>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 3)
c0003e3d:	68 ac 4a 00 c0       	push   $0xc0004aac
c0003e42:	68 f8 4a 00 c0       	push   $0xc0004af8
c0003e47:	6a 20                	push   $0x20
c0003e49:	68 9a 4a 00 c0       	push   $0xc0004a9a
c0003e4e:	e8 6f e4 ff ff       	call   c00022c2 <panic_spin>
c0003e53:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:33
   *waiter = running_thread();
c0003e56:	e8 b0 f0 ff ff       	call   c0002f0b <running_thread>
c0003e5b:	89 c2                	mov    %eax,%edx
c0003e5d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e60:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ioqueue.c:34
   thread_block(TASK_BLOCKED);
c0003e62:	83 ec 0c             	sub    $0xc,%esp
c0003e65:	6a 02                	push   $0x2
c0003e67:	e8 4a f4 ff ff       	call   c00032b6 <thread_block>
c0003e6c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:35
}
c0003e6f:	90                   	nop
c0003e70:	c9                   	leave  
c0003e71:	c3                   	ret    

c0003e72 <wakeup>:
wakeup():
/work/x86_os_my/device/ioqueue.c:38

/* 唤醒waiter */
static void wakeup(struct task_struct** waiter) {
c0003e72:	55                   	push   %ebp
c0003e73:	89 e5                	mov    %esp,%ebp
c0003e75:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:39
   ASSERT(*waiter != NULL);
c0003e78:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e7b:	8b 00                	mov    (%eax),%eax
c0003e7d:	85 c0                	test   %eax,%eax
c0003e7f:	75 19                	jne    c0003e9a <wakeup+0x28>
/work/x86_os_my/device/ioqueue.c:39 (discriminator 1)
c0003e81:	68 ce 4a 00 c0       	push   $0xc0004ace
c0003e86:	68 04 4b 00 c0       	push   $0xc0004b04
c0003e8b:	6a 27                	push   $0x27
c0003e8d:	68 9a 4a 00 c0       	push   $0xc0004a9a
c0003e92:	e8 2b e4 ff ff       	call   c00022c2 <panic_spin>
c0003e97:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:40
   thread_unblock(*waiter); 
c0003e9a:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e9d:	8b 00                	mov    (%eax),%eax
c0003e9f:	83 ec 0c             	sub    $0xc,%esp
c0003ea2:	50                   	push   %eax
c0003ea3:	e8 71 f4 ff ff       	call   c0003319 <thread_unblock>
c0003ea8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:41
   *waiter = NULL;
c0003eab:	8b 45 08             	mov    0x8(%ebp),%eax
c0003eae:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/device/ioqueue.c:42
}
c0003eb4:	90                   	nop
c0003eb5:	c9                   	leave  
c0003eb6:	c3                   	ret    

c0003eb7 <ioq_getchar>:
ioq_getchar():
/work/x86_os_my/device/ioqueue.c:45

/* 消费者从ioq队列中获取一个字符 */
char ioq_getchar(struct ioqueue* ioq) {
c0003eb7:	55                   	push   %ebp
c0003eb8:	89 e5                	mov    %esp,%ebp
c0003eba:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ioqueue.c:46
   ASSERT(intr_get_status() == INTR_OFF);
c0003ebd:	e8 37 db ff ff       	call   c00019f9 <intr_get_status>
c0003ec2:	85 c0                	test   %eax,%eax
c0003ec4:	74 4b                	je     c0003f11 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:46 (discriminator 1)
c0003ec6:	68 7c 4a 00 c0       	push   $0xc0004a7c
c0003ecb:	68 0c 4b 00 c0       	push   $0xc0004b0c
c0003ed0:	6a 2e                	push   $0x2e
c0003ed2:	68 9a 4a 00 c0       	push   $0xc0004a9a
c0003ed7:	e8 e6 e3 ff ff       	call   c00022c2 <panic_spin>
c0003edc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51 (discriminator 1)

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c0003edf:	eb 30                	jmp    c0003f11 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:52
      lock_acquire(&ioq->lock);	 
c0003ee1:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ee4:	83 ec 0c             	sub    $0xc,%esp
c0003ee7:	50                   	push   %eax
c0003ee8:	e8 42 fa ff ff       	call   c000392f <lock_acquire>
c0003eed:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:53
      ioq_wait(&ioq->consumer);
c0003ef0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ef3:	83 c0 20             	add    $0x20,%eax
c0003ef6:	83 ec 0c             	sub    $0xc,%esp
c0003ef9:	50                   	push   %eax
c0003efa:	e8 29 ff ff ff       	call   c0003e28 <ioq_wait>
c0003eff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:54
      lock_release(&ioq->lock);
c0003f02:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f05:	83 ec 0c             	sub    $0xc,%esp
c0003f08:	50                   	push   %eax
c0003f09:	e8 98 fa ff ff       	call   c00039a6 <lock_release>
c0003f0e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c0003f11:	83 ec 0c             	sub    $0xc,%esp
c0003f14:	ff 75 08             	pushl  0x8(%ebp)
c0003f17:	e8 ce fe ff ff       	call   c0003dea <ioq_empty>
c0003f1c:	83 c4 10             	add    $0x10,%esp
c0003f1f:	85 c0                	test   %eax,%eax
c0003f21:	75 be                	jne    c0003ee1 <ioq_getchar+0x2a>
/work/x86_os_my/device/ioqueue.c:57
      lock_acquire(&ioq->lock);	 
      ioq_wait(&ioq->consumer);
      lock_release(&ioq->lock);
   }

   char byte = ioq->buf[ioq->tail];	  // 从缓冲区中取出
c0003f23:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f26:	8b 40 68             	mov    0x68(%eax),%eax
c0003f29:	8b 55 08             	mov    0x8(%ebp),%edx
c0003f2c:	0f b6 44 02 24       	movzbl 0x24(%edx,%eax,1),%eax
c0003f31:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ioqueue.c:58
   ioq->tail = next_pos(ioq->tail);	  // 把读游标移到下一位置
c0003f34:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f37:	8b 40 68             	mov    0x68(%eax),%eax
c0003f3a:	83 ec 0c             	sub    $0xc,%esp
c0003f3d:	50                   	push   %eax
c0003f3e:	e8 3f fe ff ff       	call   c0003d82 <next_pos>
c0003f43:	83 c4 10             	add    $0x10,%esp
c0003f46:	89 c2                	mov    %eax,%edx
c0003f48:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f4b:	89 50 68             	mov    %edx,0x68(%eax)
/work/x86_os_my/device/ioqueue.c:60

   if (ioq->producer != NULL) {
c0003f4e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f51:	8b 40 1c             	mov    0x1c(%eax),%eax
c0003f54:	85 c0                	test   %eax,%eax
c0003f56:	74 12                	je     c0003f6a <ioq_getchar+0xb3>
/work/x86_os_my/device/ioqueue.c:61
      wakeup(&ioq->producer);		  // 唤醒生产者
c0003f58:	8b 45 08             	mov    0x8(%ebp),%eax
c0003f5b:	83 c0 1c             	add    $0x1c,%eax
c0003f5e:	83 ec 0c             	sub    $0xc,%esp
c0003f61:	50                   	push   %eax
c0003f62:	e8 0b ff ff ff       	call   c0003e72 <wakeup>
c0003f67:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:64
   }

   return byte; 
c0003f6a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
/work/x86_os_my/device/ioqueue.c:65
}
c0003f6e:	c9                   	leave  
c0003f6f:	c3                   	ret    

c0003f70 <ioq_putchar>:
ioq_putchar():
/work/x86_os_my/device/ioqueue.c:68

/* 生产者往ioq队列中写入一个字符byte */
void ioq_putchar(struct ioqueue* ioq, char byte) {
c0003f70:	55                   	push   %ebp
c0003f71:	89 e5                	mov    %esp,%ebp
c0003f73:	83 ec 18             	sub    $0x18,%esp
c0003f76:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003f79:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/ioqueue.c:69
   ASSERT(intr_get_status() == INTR_OFF);
c0003f7c:	e8 78 da ff ff       	call   c00019f9 <intr_get_status>
c0003f81:	85 c0                	test   %eax,%eax
c0003f83:	74 4b                	je     c0003fd0 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:69 (discriminator 1)
c0003f85:	68 7c 4a 00 c0       	push   $0xc0004a7c
c0003f8a:	68 18 4b 00 c0       	push   $0xc0004b18
c0003f8f:	6a 45                	push   $0x45
c0003f91:	68 9a 4a 00 c0       	push   $0xc0004a9a
c0003f96:	e8 27 e3 ff ff       	call   c00022c2 <panic_spin>
c0003f9b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74 (discriminator 1)

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c0003f9e:	eb 30                	jmp    c0003fd0 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:75
      lock_acquire(&ioq->lock);
c0003fa0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003fa3:	83 ec 0c             	sub    $0xc,%esp
c0003fa6:	50                   	push   %eax
c0003fa7:	e8 83 f9 ff ff       	call   c000392f <lock_acquire>
c0003fac:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:76
      ioq_wait(&ioq->producer);
c0003faf:	8b 45 08             	mov    0x8(%ebp),%eax
c0003fb2:	83 c0 1c             	add    $0x1c,%eax
c0003fb5:	83 ec 0c             	sub    $0xc,%esp
c0003fb8:	50                   	push   %eax
c0003fb9:	e8 6a fe ff ff       	call   c0003e28 <ioq_wait>
c0003fbe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:77
      lock_release(&ioq->lock);
c0003fc1:	8b 45 08             	mov    0x8(%ebp),%eax
c0003fc4:	83 ec 0c             	sub    $0xc,%esp
c0003fc7:	50                   	push   %eax
c0003fc8:	e8 d9 f9 ff ff       	call   c00039a6 <lock_release>
c0003fcd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c0003fd0:	83 ec 0c             	sub    $0xc,%esp
c0003fd3:	ff 75 08             	pushl  0x8(%ebp)
c0003fd6:	e8 c3 fd ff ff       	call   c0003d9e <ioq_full>
c0003fdb:	83 c4 10             	add    $0x10,%esp
c0003fde:	85 c0                	test   %eax,%eax
c0003fe0:	75 be                	jne    c0003fa0 <ioq_putchar+0x30>
/work/x86_os_my/device/ioqueue.c:79
      lock_acquire(&ioq->lock);
      ioq_wait(&ioq->producer);
      lock_release(&ioq->lock);
   }
   ioq->buf[ioq->head] = byte;      // 把字节放入缓冲区中
c0003fe2:	8b 45 08             	mov    0x8(%ebp),%eax
c0003fe5:	8b 40 64             	mov    0x64(%eax),%eax
c0003fe8:	8b 55 08             	mov    0x8(%ebp),%edx
c0003feb:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
c0003fef:	88 4c 02 24          	mov    %cl,0x24(%edx,%eax,1)
/work/x86_os_my/device/ioqueue.c:80
   ioq->head = next_pos(ioq->head); // 把写游标移到下一位置
c0003ff3:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ff6:	8b 40 64             	mov    0x64(%eax),%eax
c0003ff9:	83 ec 0c             	sub    $0xc,%esp
c0003ffc:	50                   	push   %eax
c0003ffd:	e8 80 fd ff ff       	call   c0003d82 <next_pos>
c0004002:	83 c4 10             	add    $0x10,%esp
c0004005:	89 c2                	mov    %eax,%edx
c0004007:	8b 45 08             	mov    0x8(%ebp),%eax
c000400a:	89 50 64             	mov    %edx,0x64(%eax)
/work/x86_os_my/device/ioqueue.c:82

   if (ioq->consumer != NULL) {
c000400d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004010:	8b 40 20             	mov    0x20(%eax),%eax
c0004013:	85 c0                	test   %eax,%eax
c0004015:	74 12                	je     c0004029 <ioq_putchar+0xb9>
/work/x86_os_my/device/ioqueue.c:83
      wakeup(&ioq->consumer);          // 唤醒消费者
c0004017:	8b 45 08             	mov    0x8(%ebp),%eax
c000401a:	83 c0 20             	add    $0x20,%eax
c000401d:	83 ec 0c             	sub    $0xc,%esp
c0004020:	50                   	push   %eax
c0004021:	e8 4c fe ff ff       	call   c0003e72 <wakeup>
c0004026:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:85
   }
}
c0004029:	90                   	nop
c000402a:	c9                   	leave  
c000402b:	c3                   	ret    
