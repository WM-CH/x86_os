
./build/kernel.bin:     file format elf32-i386


Disassembly of section .text:

c0001500 <main>:
main():
/work/x86_os_my/kernel/main.c:31
*/
/*
用户进程
u_prog_a 的地址是在 0xc0000000 以上，位于内核空间，但这并不表示它无法模拟用户进程。
*/
int main(void) {
c0001500:	8d 4c 24 04          	lea    0x4(%esp),%ecx
c0001504:	83 e4 f0             	and    $0xfffffff0,%esp
c0001507:	ff 71 fc             	pushl  -0x4(%ecx)
c000150a:	55                   	push   %ebp
c000150b:	89 e5                	mov    %esp,%ebp
c000150d:	51                   	push   %ecx
c000150e:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/kernel/main.c:32
	put_str("I am kernel\n");
c0001511:	83 ec 0c             	sub    $0xc,%esp
c0001514:	68 50 49 00 c0       	push   $0xc0004950
c0001519:	e8 02 0d 00 00       	call   c0002220 <put_str>
c000151e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:33
	init_all();
c0001521:	e8 89 01 00 00       	call   c00016af <init_all>
/work/x86_os_my/kernel/main.c:35
	
	process_execute(u_prog_a, "user_prog_a");
c0001526:	83 ec 08             	sub    $0x8,%esp
c0001529:	68 5d 49 00 c0       	push   $0xc000495d
c000152e:	68 8b 16 00 c0       	push   $0xc000168b
c0001533:	e8 ac 32 00 00       	call   c00047e4 <process_execute>
c0001538:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:36
	process_execute(u_prog_b, "user_prog_b");
c000153b:	83 ec 08             	sub    $0x8,%esp
c000153e:	68 69 49 00 c0       	push   $0xc0004969
c0001543:	68 9d 16 00 c0       	push   $0xc000169d
c0001548:	e8 97 32 00 00       	call   c00047e4 <process_execute>
c000154d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:38

	intr_enable();
c0001550:	e8 ed 04 00 00       	call   c0001a42 <intr_enable>
/work/x86_os_my/kernel/main.c:40
	
	console_put_str(" main_pid:0x");
c0001555:	83 ec 0c             	sub    $0xc,%esp
c0001558:	68 75 49 00 c0       	push   $0xc0004975
c000155d:	e8 3e 25 00 00       	call   c0003aa0 <console_put_str>
c0001562:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:41
	console_put_int(sys_getpid());
c0001565:	e8 9e 33 00 00       	call   c0004908 <sys_getpid>
c000156a:	83 ec 0c             	sub    $0xc,%esp
c000156d:	50                   	push   %eax
c000156e:	e8 77 25 00 00       	call   c0003aea <console_put_int>
c0001573:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:42
	console_put_char('\n');
c0001576:	83 ec 0c             	sub    $0xc,%esp
c0001579:	6a 0a                	push   $0xa
c000157b:	e8 41 25 00 00       	call   c0003ac1 <console_put_char>
c0001580:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:43
	thread_start("k_thread_a", 31, k_thread_a, "argA ");
c0001583:	68 82 49 00 c0       	push   $0xc0004982
c0001588:	68 b7 15 00 c0       	push   $0xc00015b7
c000158d:	6a 1f                	push   $0x1f
c000158f:	68 88 49 00 c0       	push   $0xc0004988
c0001594:	e8 79 1e 00 00       	call   c0003412 <thread_start>
c0001599:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:44
	thread_start("k_thread_b", 31, k_thread_b, "argB ");
c000159c:	68 93 49 00 c0       	push   $0xc0004993
c00015a1:	68 21 16 00 c0       	push   $0xc0001621
c00015a6:	6a 1f                	push   $0x1f
c00015a8:	68 99 49 00 c0       	push   $0xc0004999
c00015ad:	e8 60 1e 00 00       	call   c0003412 <thread_start>
c00015b2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:46 (discriminator 1)
	
	while(1);
c00015b5:	eb fe                	jmp    c00015b5 <main+0xb5>

c00015b7 <k_thread_a>:
k_thread_a():
/work/x86_os_my/kernel/main.c:51
	return 0;
}

/* 在线程中运行的函数 */
void k_thread_a(void* arg) {
c00015b7:	55                   	push   %ebp
c00015b8:	89 e5                	mov    %esp,%ebp
c00015ba:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:52
	char* para = arg;
c00015bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00015c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:53
	console_put_str(" thread_a_pid:0x");
c00015c3:	83 ec 0c             	sub    $0xc,%esp
c00015c6:	68 a4 49 00 c0       	push   $0xc00049a4
c00015cb:	e8 d0 24 00 00       	call   c0003aa0 <console_put_str>
c00015d0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:54
	console_put_int(sys_getpid());
c00015d3:	e8 30 33 00 00       	call   c0004908 <sys_getpid>
c00015d8:	83 ec 0c             	sub    $0xc,%esp
c00015db:	50                   	push   %eax
c00015dc:	e8 09 25 00 00       	call   c0003aea <console_put_int>
c00015e1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:55
	console_put_char('\n');
c00015e4:	83 ec 0c             	sub    $0xc,%esp
c00015e7:	6a 0a                	push   $0xa
c00015e9:	e8 d3 24 00 00       	call   c0003ac1 <console_put_char>
c00015ee:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:56
	console_put_str(" prog_a_pid:0x");
c00015f1:	83 ec 0c             	sub    $0xc,%esp
c00015f4:	68 b5 49 00 c0       	push   $0xc00049b5
c00015f9:	e8 a2 24 00 00       	call   c0003aa0 <console_put_str>
c00015fe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:57
	console_put_int(prog_a_pid);
c0001601:	a1 60 71 00 c0       	mov    0xc0007160,%eax
c0001606:	83 ec 0c             	sub    $0xc,%esp
c0001609:	50                   	push   %eax
c000160a:	e8 db 24 00 00       	call   c0003aea <console_put_int>
c000160f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:58
	console_put_char('\n');
c0001612:	83 ec 0c             	sub    $0xc,%esp
c0001615:	6a 0a                	push   $0xa
c0001617:	e8 a5 24 00 00       	call   c0003ac1 <console_put_char>
c000161c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:59 (discriminator 1)
	while(1);
c000161f:	eb fe                	jmp    c000161f <k_thread_a+0x68>

c0001621 <k_thread_b>:
k_thread_b():
/work/x86_os_my/kernel/main.c:63
}

/* 在线程中运行的函数 */
void k_thread_b(void* arg) {
c0001621:	55                   	push   %ebp
c0001622:	89 e5                	mov    %esp,%ebp
c0001624:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:64
	char* para = arg;
c0001627:	8b 45 08             	mov    0x8(%ebp),%eax
c000162a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:65
	console_put_str(" thread_b_pid:0x");
c000162d:	83 ec 0c             	sub    $0xc,%esp
c0001630:	68 c4 49 00 c0       	push   $0xc00049c4
c0001635:	e8 66 24 00 00       	call   c0003aa0 <console_put_str>
c000163a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:66
	console_put_int(sys_getpid());
c000163d:	e8 c6 32 00 00       	call   c0004908 <sys_getpid>
c0001642:	83 ec 0c             	sub    $0xc,%esp
c0001645:	50                   	push   %eax
c0001646:	e8 9f 24 00 00       	call   c0003aea <console_put_int>
c000164b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:67
	console_put_char('\n');
c000164e:	83 ec 0c             	sub    $0xc,%esp
c0001651:	6a 0a                	push   $0xa
c0001653:	e8 69 24 00 00       	call   c0003ac1 <console_put_char>
c0001658:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:68
	console_put_str(" prog_b_pid:0x");
c000165b:	83 ec 0c             	sub    $0xc,%esp
c000165e:	68 d5 49 00 c0       	push   $0xc00049d5
c0001663:	e8 38 24 00 00       	call   c0003aa0 <console_put_str>
c0001668:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:69
	console_put_int(prog_a_pid);
c000166b:	a1 60 71 00 c0       	mov    0xc0007160,%eax
c0001670:	83 ec 0c             	sub    $0xc,%esp
c0001673:	50                   	push   %eax
c0001674:	e8 71 24 00 00       	call   c0003aea <console_put_int>
c0001679:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:70
	console_put_char('\n');
c000167c:	83 ec 0c             	sub    $0xc,%esp
c000167f:	6a 0a                	push   $0xa
c0001681:	e8 3b 24 00 00       	call   c0003ac1 <console_put_char>
c0001686:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:71 (discriminator 1)
	while(1);
c0001689:	eb fe                	jmp    c0001689 <k_thread_b+0x68>

c000168b <u_prog_a>:
u_prog_a():
/work/x86_os_my/kernel/main.c:75
}

/* 测试用户进程 */
void u_prog_a(void) {
c000168b:	55                   	push   %ebp
c000168c:	89 e5                	mov    %esp,%ebp
c000168e:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/main.c:76
	prog_a_pid = getpid();
c0001691:	e8 5d 32 00 00       	call   c00048f3 <getpid>
c0001696:	a3 60 71 00 c0       	mov    %eax,0xc0007160
/work/x86_os_my/kernel/main.c:77 (discriminator 1)
	while(1);
c000169b:	eb fe                	jmp    c000169b <u_prog_a+0x10>

c000169d <u_prog_b>:
u_prog_b():
/work/x86_os_my/kernel/main.c:81
}

/* 测试用户进程 */
void u_prog_b(void) {
c000169d:	55                   	push   %ebp
c000169e:	89 e5                	mov    %esp,%ebp
c00016a0:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/main.c:82
	prog_b_pid = getpid();
c00016a3:	e8 4b 32 00 00       	call   c00048f3 <getpid>
c00016a8:	a3 64 71 00 c0       	mov    %eax,0xc0007164
/work/x86_os_my/kernel/main.c:83 (discriminator 1)
	while(1);
c00016ad:	eb fe                	jmp    c00016ad <u_prog_b+0x10>

c00016af <init_all>:
init_all():
/work/x86_os_my/kernel/init.c:13
#include "keyboard.h"
#include "tss.h"
#include "syscall-init.h"

/*负责初始化所有模块 */
void init_all() {
c00016af:	55                   	push   %ebp
c00016b0:	89 e5                	mov    %esp,%ebp
c00016b2:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/init.c:14
	put_str("init_all\n");
c00016b5:	83 ec 0c             	sub    $0xc,%esp
c00016b8:	68 e4 49 00 c0       	push   $0xc00049e4
c00016bd:	e8 5e 0b 00 00       	call   c0002220 <put_str>
c00016c2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/init.c:15
	idt_init();			// 初始化中断
c00016c5:	e8 29 04 00 00       	call   c0001af3 <idt_init>
/work/x86_os_my/kernel/init.c:16
	mem_init();			// 初始化内存管理系统
c00016ca:	e8 aa 17 00 00       	call   c0002e79 <mem_init>
/work/x86_os_my/kernel/init.c:17
	thread_init();		// 初始化线程相关结构
c00016cf:	e8 19 21 00 00       	call   c00037ed <thread_init>
/work/x86_os_my/kernel/init.c:18
	timer_init();		// 初始化PIT
c00016d4:	e8 94 05 00 00       	call   c0001c6d <timer_init>
/work/x86_os_my/kernel/init.c:19
	console_init();		// 控制台初始化最好放在开中断之前
c00016d9:	e8 77 23 00 00       	call   c0003a55 <console_init>
/work/x86_os_my/kernel/init.c:20
	keyboard_init();	// 键盘初始化
c00016de:	e8 f0 29 00 00       	call   c00040d3 <keyboard_init>
/work/x86_os_my/kernel/init.c:21
	tss_init();			// tss初始化
c00016e3:	e8 a6 2d 00 00       	call   c000448e <tss_init>
/work/x86_os_my/kernel/init.c:22
	syscall_init();		// 初始化系统调用
c00016e8:	e8 2d 32 00 00       	call   c000491a <syscall_init>
/work/x86_os_my/kernel/init.c:23
}
c00016ed:	90                   	nop
c00016ee:	c9                   	leave  
c00016ef:	c3                   	ret    

c00016f0 <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c00016f0:	55                   	push   %ebp
c00016f1:	89 e5                	mov    %esp,%ebp
c00016f3:	83 ec 08             	sub    $0x8,%esp
c00016f6:	8b 55 08             	mov    0x8(%ebp),%edx
c00016f9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00016fc:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0001700:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c0001703:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0001707:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c000170b:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c000170c:	90                   	nop
c000170d:	c9                   	leave  
c000170e:	c3                   	ret    

c000170f <pic_init>:
pic_init():
/work/x86_os_my/kernel/interrupt.c:41
//自定义类型 intr_handler = void*
extern intr_handler intr_entry_table[IDT_DESC_CNT];	    // 声明引用汇编kernel.S中的中断处理函数入口数组

/* 初始化可编程中断控制器8259A */
// outb 来着 lib/kernel/io.h 内联汇编写法
static void pic_init(void) {
c000170f:	55                   	push   %ebp
c0001710:	89 e5                	mov    %esp,%ebp
c0001712:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:43
	/* 初始化主片 */
	outb (PIC_M_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c0001715:	6a 11                	push   $0x11
c0001717:	6a 20                	push   $0x20
c0001719:	e8 d2 ff ff ff       	call   c00016f0 <outb>
c000171e:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:44
	outb (PIC_M_DATA, 0x20);	// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.
c0001721:	6a 20                	push   $0x20
c0001723:	6a 21                	push   $0x21
c0001725:	e8 c6 ff ff ff       	call   c00016f0 <outb>
c000172a:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:45
	outb (PIC_M_DATA, 0x04);	// ICW3: IR2接从片. 
c000172d:	6a 04                	push   $0x4
c000172f:	6a 21                	push   $0x21
c0001731:	e8 ba ff ff ff       	call   c00016f0 <outb>
c0001736:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:46
	outb (PIC_M_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c0001739:	6a 01                	push   $0x1
c000173b:	6a 21                	push   $0x21
c000173d:	e8 ae ff ff ff       	call   c00016f0 <outb>
c0001742:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:49

	/* 初始化从片 */
	outb (PIC_S_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c0001745:	6a 11                	push   $0x11
c0001747:	68 a0 00 00 00       	push   $0xa0
c000174c:	e8 9f ff ff ff       	call   c00016f0 <outb>
c0001751:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:50
	outb (PIC_S_DATA, 0x28);	// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.
c0001754:	6a 28                	push   $0x28
c0001756:	68 a1 00 00 00       	push   $0xa1
c000175b:	e8 90 ff ff ff       	call   c00016f0 <outb>
c0001760:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:51
	outb (PIC_S_DATA, 0x02);	// ICW3: 设置从片连接到主片的IR2引脚
c0001763:	6a 02                	push   $0x2
c0001765:	68 a1 00 00 00       	push   $0xa1
c000176a:	e8 81 ff ff ff       	call   c00016f0 <outb>
c000176f:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:52
	outb (PIC_S_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c0001772:	6a 01                	push   $0x1
c0001774:	68 a1 00 00 00       	push   $0xa1
c0001779:	e8 72 ff ff ff       	call   c00016f0 <outb>
c000177e:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:55

	/* 打开主片上IR0,也就是目前只接受 时钟0xfe、时钟和键盘0xfc 产生的中断 */
	outb (PIC_M_DATA, 0xfe);
c0001781:	68 fe 00 00 00       	push   $0xfe
c0001786:	6a 21                	push   $0x21
c0001788:	e8 63 ff ff ff       	call   c00016f0 <outb>
c000178d:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:56
	outb (PIC_S_DATA, 0xff);
c0001790:	68 ff 00 00 00       	push   $0xff
c0001795:	68 a1 00 00 00       	push   $0xa1
c000179a:	e8 51 ff ff ff       	call   c00016f0 <outb>
c000179f:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:58

	put_str("   pic_init done\n");
c00017a2:	83 ec 0c             	sub    $0xc,%esp
c00017a5:	68 f0 49 00 c0       	push   $0xc00049f0
c00017aa:	e8 71 0a 00 00       	call   c0002220 <put_str>
c00017af:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:59
}
c00017b2:	90                   	nop
c00017b3:	c9                   	leave  
c00017b4:	c3                   	ret    

c00017b5 <make_idt_desc>:
make_idt_desc():
/work/x86_os_my/kernel/interrupt.c:62

/* 创建中断门描述符 */
static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function) { 
c00017b5:	55                   	push   %ebp
c00017b6:	89 e5                	mov    %esp,%ebp
c00017b8:	83 ec 04             	sub    $0x4,%esp
c00017bb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00017be:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:63
	p_gdesc->func_offset_low_word = (uint32_t)function & 0x0000FFFF;
c00017c1:	8b 45 10             	mov    0x10(%ebp),%eax
c00017c4:	89 c2                	mov    %eax,%edx
c00017c6:	8b 45 08             	mov    0x8(%ebp),%eax
c00017c9:	66 89 10             	mov    %dx,(%eax)
/work/x86_os_my/kernel/interrupt.c:64
	p_gdesc->selector = SELECTOR_K_CODE;
c00017cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00017cf:	66 c7 40 02 08 00    	movw   $0x8,0x2(%eax)
/work/x86_os_my/kernel/interrupt.c:65
	p_gdesc->dcount = 0;
c00017d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00017d8:	c6 40 04 00          	movb   $0x0,0x4(%eax)
/work/x86_os_my/kernel/interrupt.c:66
	p_gdesc->attribute = attr;
c00017dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00017df:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c00017e3:	88 50 05             	mov    %dl,0x5(%eax)
/work/x86_os_my/kernel/interrupt.c:67
	p_gdesc->func_offset_high_word = ((uint32_t)function & 0xFFFF0000) >> 16;
c00017e6:	8b 45 10             	mov    0x10(%ebp),%eax
c00017e9:	c1 e8 10             	shr    $0x10,%eax
c00017ec:	89 c2                	mov    %eax,%edx
c00017ee:	8b 45 08             	mov    0x8(%ebp),%eax
c00017f1:	66 89 50 06          	mov    %dx,0x6(%eax)
/work/x86_os_my/kernel/interrupt.c:68
}
c00017f5:	90                   	nop
c00017f6:	c9                   	leave  
c00017f7:	c3                   	ret    

c00017f8 <idt_desc_init>:
idt_desc_init():
/work/x86_os_my/kernel/interrupt.c:71

/*初始化中断描述符表*/
static void idt_desc_init(void) {
c00017f8:	55                   	push   %ebp
c00017f9:	89 e5                	mov    %esp,%ebp
c00017fb:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:73
	int i;
	int lastindex = IDT_DESC_CNT - 1;
c00017fe:	c7 45 f0 80 00 00 00 	movl   $0x80,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:74
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001805:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000180c:	eb 29                	jmp    c0001837 <idt_desc_init+0x3f>
/work/x86_os_my/kernel/interrupt.c:75 (discriminator 3)
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
c000180e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001811:	8b 04 85 00 70 00 c0 	mov    -0x3fff9000(,%eax,4),%eax
c0001818:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000181b:	c1 e2 03             	shl    $0x3,%edx
c000181e:	81 c2 80 71 00 c0    	add    $0xc0007180,%edx
c0001824:	50                   	push   %eax
c0001825:	68 8e 00 00 00       	push   $0x8e
c000182a:	52                   	push   %edx
c000182b:	e8 85 ff ff ff       	call   c00017b5 <make_idt_desc>
c0001830:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/kernel/interrupt.c:74 (discriminator 3)

/*初始化中断描述符表*/
static void idt_desc_init(void) {
	int i;
	int lastindex = IDT_DESC_CNT - 1;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001833:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:74 (discriminator 1)
c0001837:	81 7d f4 80 00 00 00 	cmpl   $0x80,-0xc(%ebp)
c000183e:	7e ce                	jle    c000180e <idt_desc_init+0x16>
/work/x86_os_my/kernel/interrupt.c:79
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
	}
	/* 单独处理系统调用,系统调用对应的中断门dpl为3,
	 * 中断处理程序为单独的syscall_handler */
	make_idt_desc(&idt[lastindex], IDT_DESC_ATTR_DPL3, syscall_handler);
c0001840:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001843:	c1 e0 03             	shl    $0x3,%eax
c0001846:	05 80 71 00 c0       	add    $0xc0007180,%eax
c000184b:	68 f7 21 00 c0       	push   $0xc00021f7
c0001850:	68 ee 00 00 00       	push   $0xee
c0001855:	50                   	push   %eax
c0001856:	e8 5a ff ff ff       	call   c00017b5 <make_idt_desc>
c000185b:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/kernel/interrupt.c:80
	put_str("   idt_desc_init done\n");
c000185e:	83 ec 0c             	sub    $0xc,%esp
c0001861:	68 02 4a 00 c0       	push   $0xc0004a02
c0001866:	e8 b5 09 00 00       	call   c0002220 <put_str>
c000186b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:81
}
c000186e:	90                   	nop
c000186f:	c9                   	leave  
c0001870:	c3                   	ret    

c0001871 <general_intr_handler>:
general_intr_handler():
/work/x86_os_my/kernel/interrupt.c:84

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
c0001871:	55                   	push   %ebp
c0001872:	89 e5                	mov    %esp,%ebp
c0001874:	83 ec 28             	sub    $0x28,%esp
c0001877:	8b 45 08             	mov    0x8(%ebp),%eax
c000187a:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/kernel/interrupt.c:85
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
c000187d:	80 7d e4 27          	cmpb   $0x27,-0x1c(%ebp)
c0001881:	0f 84 bf 00 00 00    	je     c0001946 <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:85 (discriminator 1)
c0001887:	80 7d e4 2f          	cmpb   $0x2f,-0x1c(%ebp)
c000188b:	0f 84 b5 00 00 00    	je     c0001946 <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:90
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
c0001891:	83 ec 0c             	sub    $0xc,%esp
c0001894:	6a 00                	push   $0x0
c0001896:	e8 d3 0a 00 00       	call   c000236e <set_cursor>
c000189b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:91
	int cursor_pos = 0;
c000189e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:92
	while(cursor_pos < 320) {
c00018a5:	eb 11                	jmp    c00018b8 <general_intr_handler+0x47>
/work/x86_os_my/kernel/interrupt.c:93
		put_char(' ');
c00018a7:	83 ec 0c             	sub    $0xc,%esp
c00018aa:	6a 20                	push   $0x20
c00018ac:	e8 8d 09 00 00       	call   c000223e <put_char>
c00018b1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:94
		cursor_pos++;
c00018b4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:92
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
	int cursor_pos = 0;
	while(cursor_pos < 320) {
c00018b8:	81 7d f4 3f 01 00 00 	cmpl   $0x13f,-0xc(%ebp)
c00018bf:	7e e6                	jle    c00018a7 <general_intr_handler+0x36>
/work/x86_os_my/kernel/interrupt.c:98
		put_char(' ');
		cursor_pos++;
	}

	/* 将光标置为左上角 打印信息 */
	set_cursor(0);
c00018c1:	83 ec 0c             	sub    $0xc,%esp
c00018c4:	6a 00                	push   $0x0
c00018c6:	e8 a3 0a 00 00       	call   c000236e <set_cursor>
c00018cb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:99
	put_str("!!!!!!!      excetion message begin  !!!!!!!!\n");
c00018ce:	83 ec 0c             	sub    $0xc,%esp
c00018d1:	68 1c 4a 00 c0       	push   $0xc0004a1c
c00018d6:	e8 45 09 00 00       	call   c0002220 <put_str>
c00018db:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:100
	set_cursor(88);			// 第2行第8个字符
c00018de:	83 ec 0c             	sub    $0xc,%esp
c00018e1:	6a 58                	push   $0x58
c00018e3:	e8 86 0a 00 00       	call   c000236e <set_cursor>
c00018e8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:101
	put_str(intr_name[vec_nr]);
c00018eb:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c00018ef:	8b 04 85 40 76 00 c0 	mov    -0x3fff89c0(,%eax,4),%eax
c00018f6:	83 ec 0c             	sub    $0xc,%esp
c00018f9:	50                   	push   %eax
c00018fa:	e8 21 09 00 00       	call   c0002220 <put_str>
c00018ff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:102
	if (vec_nr == 14) {		// 若为Pagefault,将缺失的地址打印出来并悬停
c0001902:	80 7d e4 0e          	cmpb   $0xe,-0x1c(%ebp)
c0001906:	75 2c                	jne    c0001934 <general_intr_handler+0xc3>
/work/x86_os_my/kernel/interrupt.c:103
		int page_fault_vaddr = 0; 
c0001908:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:104
		asm ("movl %%cr2, %0" : "=r" (page_fault_vaddr));	  // cr2是存放造成page_fault的地址
c000190f:	0f 20 d0             	mov    %cr2,%eax
c0001912:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:105
		put_str("\npage fault addr is ");
c0001915:	83 ec 0c             	sub    $0xc,%esp
c0001918:	68 4b 4a 00 c0       	push   $0xc0004a4b
c000191d:	e8 fe 08 00 00       	call   c0002220 <put_str>
c0001922:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:106
		put_int(page_fault_vaddr); 
c0001925:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001928:	83 ec 0c             	sub    $0xc,%esp
c000192b:	50                   	push   %eax
c000192c:	e8 da 09 00 00       	call   c000230b <put_int>
c0001931:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:108
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
c0001934:	83 ec 0c             	sub    $0xc,%esp
c0001937:	68 60 4a 00 c0       	push   $0xc0004a60
c000193c:	e8 df 08 00 00       	call   c0002220 <put_str>
c0001941:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:111 (discriminator 1)
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
c0001944:	eb fe                	jmp    c0001944 <general_intr_handler+0xd3>
/work/x86_os_my/kernel/interrupt.c:86
}

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
c0001946:	90                   	nop
/work/x86_os_my/kernel/interrupt.c:112
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
}
c0001947:	c9                   	leave  
c0001948:	c3                   	ret    

c0001949 <exception_init>:
exception_init():
/work/x86_os_my/kernel/interrupt.c:115

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
c0001949:	55                   	push   %ebp
c000194a:	89 e5                	mov    %esp,%ebp
c000194c:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:117
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c000194f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0001956:	eb 20                	jmp    c0001978 <exception_init+0x2f>
/work/x86_os_my/kernel/interrupt.c:120 (discriminator 3)
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
c0001958:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000195b:	c7 04 85 60 78 00 c0 	movl   $0xc0001871,-0x3fff87a0(,%eax,4)
c0001962:	71 18 00 c0 
/work/x86_os_my/kernel/interrupt.c:121 (discriminator 3)
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
c0001966:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001969:	c7 04 85 40 76 00 c0 	movl   $0xc0004a90,-0x3fff89c0(,%eax,4)
c0001970:	90 4a 00 c0 
/work/x86_os_my/kernel/interrupt.c:117 (discriminator 3)
}

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001974:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:117 (discriminator 1)
c0001978:	81 7d fc 80 00 00 00 	cmpl   $0x80,-0x4(%ebp)
c000197f:	7e d7                	jle    c0001958 <exception_init+0xf>
/work/x86_os_my/kernel/interrupt.c:123
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
	}
	intr_name[0] = "#DE Divide Error";
c0001981:	c7 05 40 76 00 c0 98 	movl   $0xc0004a98,0xc0007640
c0001988:	4a 00 c0 
/work/x86_os_my/kernel/interrupt.c:124
	intr_name[1] = "#DB Debug Exception";
c000198b:	c7 05 44 76 00 c0 a9 	movl   $0xc0004aa9,0xc0007644
c0001992:	4a 00 c0 
/work/x86_os_my/kernel/interrupt.c:125
	intr_name[2] = "NMI Interrupt";
c0001995:	c7 05 48 76 00 c0 bd 	movl   $0xc0004abd,0xc0007648
c000199c:	4a 00 c0 
/work/x86_os_my/kernel/interrupt.c:126
	intr_name[3] = "#BP Breakpoint Exception";
c000199f:	c7 05 4c 76 00 c0 cb 	movl   $0xc0004acb,0xc000764c
c00019a6:	4a 00 c0 
/work/x86_os_my/kernel/interrupt.c:127
	intr_name[4] = "#OF Overflow Exception";
c00019a9:	c7 05 50 76 00 c0 e4 	movl   $0xc0004ae4,0xc0007650
c00019b0:	4a 00 c0 
/work/x86_os_my/kernel/interrupt.c:128
	intr_name[5] = "#BR BOUND Range Exceeded Exception";
c00019b3:	c7 05 54 76 00 c0 fc 	movl   $0xc0004afc,0xc0007654
c00019ba:	4a 00 c0 
/work/x86_os_my/kernel/interrupt.c:129
	intr_name[6] = "#UD Invalid Opcode Exception";
c00019bd:	c7 05 58 76 00 c0 1f 	movl   $0xc0004b1f,0xc0007658
c00019c4:	4b 00 c0 
/work/x86_os_my/kernel/interrupt.c:130
	intr_name[7] = "#NM Device Not Available Exception";
c00019c7:	c7 05 5c 76 00 c0 3c 	movl   $0xc0004b3c,0xc000765c
c00019ce:	4b 00 c0 
/work/x86_os_my/kernel/interrupt.c:131
	intr_name[8] = "#DF Double Fault Exception";
c00019d1:	c7 05 60 76 00 c0 5f 	movl   $0xc0004b5f,0xc0007660
c00019d8:	4b 00 c0 
/work/x86_os_my/kernel/interrupt.c:132
	intr_name[9] = "Coprocessor Segment Overrun";
c00019db:	c7 05 64 76 00 c0 7a 	movl   $0xc0004b7a,0xc0007664
c00019e2:	4b 00 c0 
/work/x86_os_my/kernel/interrupt.c:133
	intr_name[10] = "#TS Invalid TSS Exception";
c00019e5:	c7 05 68 76 00 c0 96 	movl   $0xc0004b96,0xc0007668
c00019ec:	4b 00 c0 
/work/x86_os_my/kernel/interrupt.c:134
	intr_name[11] = "#NP Segment Not Present";
c00019ef:	c7 05 6c 76 00 c0 b0 	movl   $0xc0004bb0,0xc000766c
c00019f6:	4b 00 c0 
/work/x86_os_my/kernel/interrupt.c:135
	intr_name[12] = "#SS Stack Fault Exception";
c00019f9:	c7 05 70 76 00 c0 c8 	movl   $0xc0004bc8,0xc0007670
c0001a00:	4b 00 c0 
/work/x86_os_my/kernel/interrupt.c:136
	intr_name[13] = "#GP General Protection Exception";
c0001a03:	c7 05 74 76 00 c0 e4 	movl   $0xc0004be4,0xc0007674
c0001a0a:	4b 00 c0 
/work/x86_os_my/kernel/interrupt.c:137
	intr_name[14] = "#PF Page-Fault Exception";
c0001a0d:	c7 05 78 76 00 c0 05 	movl   $0xc0004c05,0xc0007678
c0001a14:	4c 00 c0 
/work/x86_os_my/kernel/interrupt.c:139
	// intr_name[15] 第15项是intel保留项，未使用
	intr_name[16] = "#MF x87 FPU Floating-Point Error";
c0001a17:	c7 05 80 76 00 c0 20 	movl   $0xc0004c20,0xc0007680
c0001a1e:	4c 00 c0 
/work/x86_os_my/kernel/interrupt.c:140
	intr_name[17] = "#AC Alignment Check Exception";
c0001a21:	c7 05 84 76 00 c0 41 	movl   $0xc0004c41,0xc0007684
c0001a28:	4c 00 c0 
/work/x86_os_my/kernel/interrupt.c:141
	intr_name[18] = "#MC Machine-Check Exception";
c0001a2b:	c7 05 88 76 00 c0 5f 	movl   $0xc0004c5f,0xc0007688
c0001a32:	4c 00 c0 
/work/x86_os_my/kernel/interrupt.c:142
	intr_name[19] = "#XF SIMD Floating-Point Exception";
c0001a35:	c7 05 8c 76 00 c0 7c 	movl   $0xc0004c7c,0xc000768c
c0001a3c:	4c 00 c0 
/work/x86_os_my/kernel/interrupt.c:143
}
c0001a3f:	90                   	nop
c0001a40:	c9                   	leave  
c0001a41:	c3                   	ret    

c0001a42 <intr_enable>:
intr_enable():
/work/x86_os_my/kernel/interrupt.c:146

/* 开中断并返回开中断前的状态*/
enum intr_status intr_enable() {
c0001a42:	55                   	push   %ebp
c0001a43:	89 e5                	mov    %esp,%ebp
c0001a45:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:148
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c0001a48:	e8 65 00 00 00       	call   c0001ab2 <intr_get_status>
c0001a4d:	83 f8 01             	cmp    $0x1,%eax
c0001a50:	75 0c                	jne    c0001a5e <intr_enable+0x1c>
/work/x86_os_my/kernel/interrupt.c:149
		old_status = INTR_ON;
c0001a52:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:150
		return old_status;
c0001a59:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001a5c:	eb 0b                	jmp    c0001a69 <intr_enable+0x27>
/work/x86_os_my/kernel/interrupt.c:152
	} else {
		old_status = INTR_OFF;
c0001a5e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:153
		asm volatile("sti");	 // 开中断,sti指令将IF位置1
c0001a65:	fb                   	sti    
/work/x86_os_my/kernel/interrupt.c:154
		return old_status;
c0001a66:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:156
	}
}
c0001a69:	c9                   	leave  
c0001a6a:	c3                   	ret    

c0001a6b <intr_disable>:
intr_disable():
/work/x86_os_my/kernel/interrupt.c:159

/* 关中断,并且返回关中断前的状态 */
enum intr_status intr_disable() {     
c0001a6b:	55                   	push   %ebp
c0001a6c:	89 e5                	mov    %esp,%ebp
c0001a6e:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:161
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c0001a71:	e8 3c 00 00 00       	call   c0001ab2 <intr_get_status>
c0001a76:	83 f8 01             	cmp    $0x1,%eax
c0001a79:	75 0d                	jne    c0001a88 <intr_disable+0x1d>
/work/x86_os_my/kernel/interrupt.c:162
		old_status = INTR_ON;
c0001a7b:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:163
		asm volatile("cli" : : : "memory"); // 关中断,cli指令将IF位置0
c0001a82:	fa                   	cli    
/work/x86_os_my/kernel/interrupt.c:164
		return old_status;
c0001a83:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001a86:	eb 0a                	jmp    c0001a92 <intr_disable+0x27>
/work/x86_os_my/kernel/interrupt.c:166
	} else {
		old_status = INTR_OFF;
c0001a88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:167
		return old_status;
c0001a8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:169
	}
}
c0001a92:	c9                   	leave  
c0001a93:	c3                   	ret    

c0001a94 <intr_set_status>:
intr_set_status():
/work/x86_os_my/kernel/interrupt.c:172

/* 将中断状态设置为status */
enum intr_status intr_set_status(enum intr_status status) {
c0001a94:	55                   	push   %ebp
c0001a95:	89 e5                	mov    %esp,%ebp
c0001a97:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:173
	return status & INTR_ON ? intr_enable() : intr_disable();
c0001a9a:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a9d:	83 e0 01             	and    $0x1,%eax
c0001aa0:	85 c0                	test   %eax,%eax
c0001aa2:	74 07                	je     c0001aab <intr_set_status+0x17>
/work/x86_os_my/kernel/interrupt.c:173 (discriminator 1)
c0001aa4:	e8 99 ff ff ff       	call   c0001a42 <intr_enable>
c0001aa9:	eb 05                	jmp    c0001ab0 <intr_set_status+0x1c>
/work/x86_os_my/kernel/interrupt.c:173 (discriminator 2)
c0001aab:	e8 bb ff ff ff       	call   c0001a6b <intr_disable>
/work/x86_os_my/kernel/interrupt.c:174 (discriminator 5)
}
c0001ab0:	c9                   	leave  
c0001ab1:	c3                   	ret    

c0001ab2 <intr_get_status>:
intr_get_status():
/work/x86_os_my/kernel/interrupt.c:177

/* 获取当前中断状态 */
enum intr_status intr_get_status() {
c0001ab2:	55                   	push   %ebp
c0001ab3:	89 e5                	mov    %esp,%ebp
c0001ab5:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:178
	uint32_t eflags = 0; 
c0001ab8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:179
	GET_EFLAGS(eflags);
c0001abf:	9c                   	pushf  
c0001ac0:	58                   	pop    %eax
c0001ac1:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:180
	return (EFLAGS_IF & eflags) ? INTR_ON : INTR_OFF;
c0001ac4:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0001ac7:	25 00 02 00 00       	and    $0x200,%eax
c0001acc:	85 c0                	test   %eax,%eax
c0001ace:	0f 95 c0             	setne  %al
c0001ad1:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/kernel/interrupt.c:181
}
c0001ad4:	c9                   	leave  
c0001ad5:	c3                   	ret    

c0001ad6 <register_handler>:
register_handler():
/work/x86_os_my/kernel/interrupt.c:184

/* 在中断处理程序数组第vector_no个元素中注册安装中断处理程序function */
void register_handler(uint8_t vector_no, intr_handler function) {
c0001ad6:	55                   	push   %ebp
c0001ad7:	89 e5                	mov    %esp,%ebp
c0001ad9:	83 ec 04             	sub    $0x4,%esp
c0001adc:	8b 45 08             	mov    0x8(%ebp),%eax
c0001adf:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:187
/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
 * 见kernel/kernel.S的call [idt_table + %1*4] */
   idt_table[vector_no] = function; 
c0001ae2:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0001ae6:	8b 55 0c             	mov    0xc(%ebp),%edx
c0001ae9:	89 14 85 60 78 00 c0 	mov    %edx,-0x3fff87a0(,%eax,4)
/work/x86_os_my/kernel/interrupt.c:188
}
c0001af0:	90                   	nop
c0001af1:	c9                   	leave  
c0001af2:	c3                   	ret    

c0001af3 <idt_init>:
idt_init():
/work/x86_os_my/kernel/interrupt.c:191

/*完成有关中断的所有初始化工作*/
void idt_init() {
c0001af3:	55                   	push   %ebp
c0001af4:	89 e5                	mov    %esp,%ebp
c0001af6:	56                   	push   %esi
c0001af7:	53                   	push   %ebx
c0001af8:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:192
	put_str("idt_init start\n");
c0001afb:	83 ec 0c             	sub    $0xc,%esp
c0001afe:	68 9e 4c 00 c0       	push   $0xc0004c9e
c0001b03:	e8 18 07 00 00       	call   c0002220 <put_str>
c0001b08:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:193
	idt_desc_init();	// 初始化中断描述符表
c0001b0b:	e8 e8 fc ff ff       	call   c00017f8 <idt_desc_init>
/work/x86_os_my/kernel/interrupt.c:194
	exception_init();	// 异常名初始化并注册通常的中断处理函数
c0001b10:	e8 34 fe ff ff       	call   c0001949 <exception_init>
/work/x86_os_my/kernel/interrupt.c:195
	pic_init();			// 初始化8259A
c0001b15:	e8 f5 fb ff ff       	call   c000170f <pic_init>
/work/x86_os_my/kernel/interrupt.c:199

	/* 加载idt */
	// IDTR 是 48 位的寄存器，低 16 位是 IDT 的界限 = IDT 尺寸大小-1，高 32 位是 IDT 的线性基地址
	uint64_t idt_operand = ((sizeof(idt) - 1) | ((uint64_t)(uint32_t)idt << 16));
c0001b1a:	b8 80 71 00 c0       	mov    $0xc0007180,%eax
c0001b1f:	ba 00 00 00 00       	mov    $0x0,%edx
c0001b24:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0001b28:	c1 e0 10             	shl    $0x10,%eax
c0001b2b:	89 c1                	mov    %eax,%ecx
c0001b2d:	81 c9 07 04 00 00    	or     $0x407,%ecx
c0001b33:	89 cb                	mov    %ecx,%ebx
c0001b35:	89 d0                	mov    %edx,%eax
c0001b37:	80 cc 00             	or     $0x0,%ah
c0001b3a:	89 c6                	mov    %eax,%esi
c0001b3c:	89 5d f0             	mov    %ebx,-0x10(%ebp)
c0001b3f:	89 75 f4             	mov    %esi,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:200
	asm volatile("lidt %0" : : "m" (idt_operand));
c0001b42:	0f 01 5d f0          	lidtl  -0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:201
	put_str("idt_init done\n");
c0001b46:	83 ec 0c             	sub    $0xc,%esp
c0001b49:	68 ae 4c 00 c0       	push   $0xc0004cae
c0001b4e:	e8 cd 06 00 00       	call   c0002220 <put_str>
c0001b53:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:202
}
c0001b56:	90                   	nop
c0001b57:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001b5a:	5b                   	pop    %ebx
c0001b5b:	5e                   	pop    %esi
c0001b5c:	5d                   	pop    %ebp
c0001b5d:	c3                   	ret    

c0001b5e <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c0001b5e:	55                   	push   %ebp
c0001b5f:	89 e5                	mov    %esp,%ebp
c0001b61:	83 ec 08             	sub    $0x8,%esp
c0001b64:	8b 55 08             	mov    0x8(%ebp),%edx
c0001b67:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001b6a:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0001b6e:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c0001b71:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0001b75:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0001b79:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c0001b7a:	90                   	nop
c0001b7b:	c9                   	leave  
c0001b7c:	c3                   	ret    

c0001b7d <frequency_set>:
frequency_set():
/work/x86_os_my/device/timer.c:25
/* 把操作的计数器counter_no、读写锁属性rwl、计数器模式counter_mode写入模式控制寄存器并赋予初始值counter_value */
static void frequency_set(uint8_t counter_port, \
		uint8_t counter_no, \
		uint8_t rwl, \
		uint8_t counter_mode, \
		uint16_t counter_value) {
c0001b7d:	55                   	push   %ebp
c0001b7e:	89 e5                	mov    %esp,%ebp
c0001b80:	56                   	push   %esi
c0001b81:	53                   	push   %ebx
c0001b82:	83 ec 14             	sub    $0x14,%esp
c0001b85:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b88:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c0001b8b:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001b8e:	8b 55 14             	mov    0x14(%ebp),%edx
c0001b91:	8b 75 18             	mov    0x18(%ebp),%esi
c0001b94:	88 45 f4             	mov    %al,-0xc(%ebp)
c0001b97:	88 5d f0             	mov    %bl,-0x10(%ebp)
c0001b9a:	88 4d ec             	mov    %cl,-0x14(%ebp)
c0001b9d:	88 55 e8             	mov    %dl,-0x18(%ebp)
c0001ba0:	66 89 75 e4          	mov    %si,-0x1c(%ebp)
/work/x86_os_my/device/timer.c:27
	/* 往控制字寄存器端口0x43中写入控制字 */
	outb(PIT_CONTROL_PORT, (uint8_t)(counter_no << 6 | rwl << 4 | counter_mode << 1));
c0001ba4:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0001ba8:	c1 e0 06             	shl    $0x6,%eax
c0001bab:	89 c2                	mov    %eax,%edx
c0001bad:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0001bb1:	c1 e0 04             	shl    $0x4,%eax
c0001bb4:	09 c2                	or     %eax,%edx
c0001bb6:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0001bba:	01 c0                	add    %eax,%eax
c0001bbc:	09 d0                	or     %edx,%eax
c0001bbe:	0f b6 c0             	movzbl %al,%eax
c0001bc1:	50                   	push   %eax
c0001bc2:	6a 43                	push   $0x43
c0001bc4:	e8 95 ff ff ff       	call   c0001b5e <outb>
c0001bc9:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:29
	/* 先写入counter_value的低8位 */
	outb(counter_port, (uint8_t)counter_value);
c0001bcc:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0001bd0:	0f b6 d0             	movzbl %al,%edx
c0001bd3:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001bd7:	52                   	push   %edx
c0001bd8:	50                   	push   %eax
c0001bd9:	e8 80 ff ff ff       	call   c0001b5e <outb>
c0001bde:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:31
	/* 再写入counter_value的高8位 */
	outb(counter_port, (uint8_t)counter_value >> 8);
c0001be1:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001be5:	6a 00                	push   $0x0
c0001be7:	50                   	push   %eax
c0001be8:	e8 71 ff ff ff       	call   c0001b5e <outb>
c0001bed:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:32
}
c0001bf0:	90                   	nop
c0001bf1:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001bf4:	5b                   	pop    %ebx
c0001bf5:	5e                   	pop    %esi
c0001bf6:	5d                   	pop    %ebp
c0001bf7:	c3                   	ret    

c0001bf8 <intr_timer_handler>:
intr_timer_handler():
/work/x86_os_my/device/timer.c:35

/* 时钟的中断处理函数 */
static void intr_timer_handler(void) {
c0001bf8:	55                   	push   %ebp
c0001bf9:	89 e5                	mov    %esp,%ebp
c0001bfb:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/timer.c:36
	struct task_struct* cur_thread = running_thread();		// 返回线程PCB
c0001bfe:	e8 87 16 00 00       	call   c000328a <running_thread>
c0001c03:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/timer.c:38

	ASSERT(cur_thread->stack_magic == 0x19870916);			// 检查栈是否溢出
c0001c06:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001c09:	8b 40 44             	mov    0x44(%eax),%eax
c0001c0c:	3d 16 09 87 19       	cmp    $0x19870916,%eax
c0001c11:	74 19                	je     c0001c2c <intr_timer_handler+0x34>
/work/x86_os_my/device/timer.c:38 (discriminator 1)
c0001c13:	68 c0 4c 00 c0       	push   $0xc0004cc0
c0001c18:	68 18 4d 00 c0       	push   $0xc0004d18
c0001c1d:	6a 26                	push   $0x26
c0001c1f:	68 e6 4c 00 c0       	push   $0xc0004ce6
c0001c24:	e8 69 07 00 00       	call   c0002392 <panic_spin>
c0001c29:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:40

	cur_thread->elapsed_ticks++;// 记录此线程占用的cpu时间
c0001c2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001c2f:	8b 40 20             	mov    0x20(%eax),%eax
c0001c32:	8d 50 01             	lea    0x1(%eax),%edx
c0001c35:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001c38:	89 50 20             	mov    %edx,0x20(%eax)
/work/x86_os_my/device/timer.c:41
	ticks++;	//从内核第一次处理时间中断开始,至今的滴哒数,是内核态和用户态总共的嘀哒数
c0001c3b:	a1 64 7a 00 c0       	mov    0xc0007a64,%eax
c0001c40:	83 c0 01             	add    $0x1,%eax
c0001c43:	a3 64 7a 00 c0       	mov    %eax,0xc0007a64
/work/x86_os_my/device/timer.c:43

	if (cur_thread->ticks == 0) {
c0001c48:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001c4b:	0f b6 40 1d          	movzbl 0x1d(%eax),%eax
c0001c4f:	84 c0                	test   %al,%al
c0001c51:	75 07                	jne    c0001c5a <intr_timer_handler+0x62>
/work/x86_os_my/device/timer.c:44
		schedule();				// 若进程时间片用完就开始调度新的进程上cpu
c0001c53:	e8 10 19 00 00       	call   c0003568 <schedule>
/work/x86_os_my/device/timer.c:48
	} else {
		cur_thread->ticks--;	// 将当前进程的时间片-1
	}
}
c0001c58:	eb 10                	jmp    c0001c6a <intr_timer_handler+0x72>
/work/x86_os_my/device/timer.c:46
	ticks++;	//从内核第一次处理时间中断开始,至今的滴哒数,是内核态和用户态总共的嘀哒数

	if (cur_thread->ticks == 0) {
		schedule();				// 若进程时间片用完就开始调度新的进程上cpu
	} else {
		cur_thread->ticks--;	// 将当前进程的时间片-1
c0001c5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001c5d:	0f b6 40 1d          	movzbl 0x1d(%eax),%eax
c0001c61:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001c64:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001c67:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/device/timer.c:48
	}
}
c0001c6a:	90                   	nop
c0001c6b:	c9                   	leave  
c0001c6c:	c3                   	ret    

c0001c6d <timer_init>:
timer_init():
/work/x86_os_my/device/timer.c:51

/* 初始化PIT8253 */
void timer_init() {
c0001c6d:	55                   	push   %ebp
c0001c6e:	89 e5                	mov    %esp,%ebp
c0001c70:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/timer.c:52
	put_str("timer_init start\n");
c0001c73:	83 ec 0c             	sub    $0xc,%esp
c0001c76:	68 f5 4c 00 c0       	push   $0xc0004cf5
c0001c7b:	e8 a0 05 00 00       	call   c0002220 <put_str>
c0001c80:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:54
	/* 设置8253的定时周期,也就是发中断的周期 */
	frequency_set(CONTRER0_PORT, COUNTER0_NO, READ_WRITE_LATCH, COUNTER_MODE, COUNTER0_VALUE);
c0001c83:	83 ec 0c             	sub    $0xc,%esp
c0001c86:	68 9b 2e 00 00       	push   $0x2e9b
c0001c8b:	6a 02                	push   $0x2
c0001c8d:	6a 03                	push   $0x3
c0001c8f:	6a 00                	push   $0x0
c0001c91:	6a 40                	push   $0x40
c0001c93:	e8 e5 fe ff ff       	call   c0001b7d <frequency_set>
c0001c98:	83 c4 20             	add    $0x20,%esp
/work/x86_os_my/device/timer.c:55
	register_handler(0x20, intr_timer_handler);
c0001c9b:	83 ec 08             	sub    $0x8,%esp
c0001c9e:	68 f8 1b 00 c0       	push   $0xc0001bf8
c0001ca3:	6a 20                	push   $0x20
c0001ca5:	e8 2c fe ff ff       	call   c0001ad6 <register_handler>
c0001caa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:56
	put_str("timer_init done\n");
c0001cad:	83 ec 0c             	sub    $0xc,%esp
c0001cb0:	68 07 4d 00 c0       	push   $0xc0004d07
c0001cb5:	e8 66 05 00 00       	call   c0002220 <put_str>
c0001cba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:57
}
c0001cbd:	90                   	nop
c0001cbe:	c9                   	leave  
c0001cbf:	c3                   	ret    

c0001cc0 <intr_exit>:
intr_exit():
c0001cc0:	83 c4 04             	add    $0x4,%esp
c0001cc3:	61                   	popa   
c0001cc4:	0f a9                	pop    %gs
c0001cc6:	0f a1                	pop    %fs
c0001cc8:	07                   	pop    %es
c0001cc9:	1f                   	pop    %ds
c0001cca:	83 c4 04             	add    $0x4,%esp
c0001ccd:	cf                   	iret   

c0001cce <intr0x00entry>:
intr0x00entry():
c0001cce:	6a 00                	push   $0x0
c0001cd0:	1e                   	push   %ds
c0001cd1:	06                   	push   %es
c0001cd2:	0f a0                	push   %fs
c0001cd4:	0f a8                	push   %gs
c0001cd6:	60                   	pusha  
c0001cd7:	b0 20                	mov    $0x20,%al
c0001cd9:	e6 a0                	out    %al,$0xa0
c0001cdb:	e6 20                	out    %al,$0x20
c0001cdd:	6a 00                	push   $0x0
c0001cdf:	ff 15 60 78 00 c0    	call   *0xc0007860
c0001ce5:	eb d9                	jmp    c0001cc0 <intr_exit>

c0001ce7 <intr0x01entry>:
intr0x01entry():
c0001ce7:	6a 00                	push   $0x0
c0001ce9:	1e                   	push   %ds
c0001cea:	06                   	push   %es
c0001ceb:	0f a0                	push   %fs
c0001ced:	0f a8                	push   %gs
c0001cef:	60                   	pusha  
c0001cf0:	b0 20                	mov    $0x20,%al
c0001cf2:	e6 a0                	out    %al,$0xa0
c0001cf4:	e6 20                	out    %al,$0x20
c0001cf6:	6a 01                	push   $0x1
c0001cf8:	ff 15 64 78 00 c0    	call   *0xc0007864
c0001cfe:	eb c0                	jmp    c0001cc0 <intr_exit>

c0001d00 <intr0x02entry>:
intr0x02entry():
c0001d00:	6a 00                	push   $0x0
c0001d02:	1e                   	push   %ds
c0001d03:	06                   	push   %es
c0001d04:	0f a0                	push   %fs
c0001d06:	0f a8                	push   %gs
c0001d08:	60                   	pusha  
c0001d09:	b0 20                	mov    $0x20,%al
c0001d0b:	e6 a0                	out    %al,$0xa0
c0001d0d:	e6 20                	out    %al,$0x20
c0001d0f:	6a 02                	push   $0x2
c0001d11:	ff 15 68 78 00 c0    	call   *0xc0007868
c0001d17:	eb a7                	jmp    c0001cc0 <intr_exit>

c0001d19 <intr0x03entry>:
intr0x03entry():
c0001d19:	6a 00                	push   $0x0
c0001d1b:	1e                   	push   %ds
c0001d1c:	06                   	push   %es
c0001d1d:	0f a0                	push   %fs
c0001d1f:	0f a8                	push   %gs
c0001d21:	60                   	pusha  
c0001d22:	b0 20                	mov    $0x20,%al
c0001d24:	e6 a0                	out    %al,$0xa0
c0001d26:	e6 20                	out    %al,$0x20
c0001d28:	6a 03                	push   $0x3
c0001d2a:	ff 15 6c 78 00 c0    	call   *0xc000786c
c0001d30:	eb 8e                	jmp    c0001cc0 <intr_exit>

c0001d32 <intr0x04entry>:
intr0x04entry():
c0001d32:	6a 00                	push   $0x0
c0001d34:	1e                   	push   %ds
c0001d35:	06                   	push   %es
c0001d36:	0f a0                	push   %fs
c0001d38:	0f a8                	push   %gs
c0001d3a:	60                   	pusha  
c0001d3b:	b0 20                	mov    $0x20,%al
c0001d3d:	e6 a0                	out    %al,$0xa0
c0001d3f:	e6 20                	out    %al,$0x20
c0001d41:	6a 04                	push   $0x4
c0001d43:	ff 15 70 78 00 c0    	call   *0xc0007870
c0001d49:	e9 72 ff ff ff       	jmp    c0001cc0 <intr_exit>

c0001d4e <intr0x05entry>:
intr0x05entry():
c0001d4e:	6a 00                	push   $0x0
c0001d50:	1e                   	push   %ds
c0001d51:	06                   	push   %es
c0001d52:	0f a0                	push   %fs
c0001d54:	0f a8                	push   %gs
c0001d56:	60                   	pusha  
c0001d57:	b0 20                	mov    $0x20,%al
c0001d59:	e6 a0                	out    %al,$0xa0
c0001d5b:	e6 20                	out    %al,$0x20
c0001d5d:	6a 05                	push   $0x5
c0001d5f:	ff 15 74 78 00 c0    	call   *0xc0007874
c0001d65:	e9 56 ff ff ff       	jmp    c0001cc0 <intr_exit>

c0001d6a <intr0x06entry>:
intr0x06entry():
c0001d6a:	6a 00                	push   $0x0
c0001d6c:	1e                   	push   %ds
c0001d6d:	06                   	push   %es
c0001d6e:	0f a0                	push   %fs
c0001d70:	0f a8                	push   %gs
c0001d72:	60                   	pusha  
c0001d73:	b0 20                	mov    $0x20,%al
c0001d75:	e6 a0                	out    %al,$0xa0
c0001d77:	e6 20                	out    %al,$0x20
c0001d79:	6a 06                	push   $0x6
c0001d7b:	ff 15 78 78 00 c0    	call   *0xc0007878
c0001d81:	e9 3a ff ff ff       	jmp    c0001cc0 <intr_exit>

c0001d86 <intr0x07entry>:
intr0x07entry():
c0001d86:	6a 00                	push   $0x0
c0001d88:	1e                   	push   %ds
c0001d89:	06                   	push   %es
c0001d8a:	0f a0                	push   %fs
c0001d8c:	0f a8                	push   %gs
c0001d8e:	60                   	pusha  
c0001d8f:	b0 20                	mov    $0x20,%al
c0001d91:	e6 a0                	out    %al,$0xa0
c0001d93:	e6 20                	out    %al,$0x20
c0001d95:	6a 07                	push   $0x7
c0001d97:	ff 15 7c 78 00 c0    	call   *0xc000787c
c0001d9d:	e9 1e ff ff ff       	jmp    c0001cc0 <intr_exit>

c0001da2 <intr0x08entry>:
intr0x08entry():
c0001da2:	90                   	nop
c0001da3:	1e                   	push   %ds
c0001da4:	06                   	push   %es
c0001da5:	0f a0                	push   %fs
c0001da7:	0f a8                	push   %gs
c0001da9:	60                   	pusha  
c0001daa:	b0 20                	mov    $0x20,%al
c0001dac:	e6 a0                	out    %al,$0xa0
c0001dae:	e6 20                	out    %al,$0x20
c0001db0:	6a 08                	push   $0x8
c0001db2:	ff 15 80 78 00 c0    	call   *0xc0007880
c0001db8:	e9 03 ff ff ff       	jmp    c0001cc0 <intr_exit>

c0001dbd <intr0x09entry>:
intr0x09entry():
c0001dbd:	6a 00                	push   $0x0
c0001dbf:	1e                   	push   %ds
c0001dc0:	06                   	push   %es
c0001dc1:	0f a0                	push   %fs
c0001dc3:	0f a8                	push   %gs
c0001dc5:	60                   	pusha  
c0001dc6:	b0 20                	mov    $0x20,%al
c0001dc8:	e6 a0                	out    %al,$0xa0
c0001dca:	e6 20                	out    %al,$0x20
c0001dcc:	6a 09                	push   $0x9
c0001dce:	ff 15 84 78 00 c0    	call   *0xc0007884
c0001dd4:	e9 e7 fe ff ff       	jmp    c0001cc0 <intr_exit>

c0001dd9 <intr0x0aentry>:
intr0x0aentry():
c0001dd9:	90                   	nop
c0001dda:	1e                   	push   %ds
c0001ddb:	06                   	push   %es
c0001ddc:	0f a0                	push   %fs
c0001dde:	0f a8                	push   %gs
c0001de0:	60                   	pusha  
c0001de1:	b0 20                	mov    $0x20,%al
c0001de3:	e6 a0                	out    %al,$0xa0
c0001de5:	e6 20                	out    %al,$0x20
c0001de7:	6a 0a                	push   $0xa
c0001de9:	ff 15 88 78 00 c0    	call   *0xc0007888
c0001def:	e9 cc fe ff ff       	jmp    c0001cc0 <intr_exit>

c0001df4 <intr0x0bentry>:
intr0x0bentry():
c0001df4:	90                   	nop
c0001df5:	1e                   	push   %ds
c0001df6:	06                   	push   %es
c0001df7:	0f a0                	push   %fs
c0001df9:	0f a8                	push   %gs
c0001dfb:	60                   	pusha  
c0001dfc:	b0 20                	mov    $0x20,%al
c0001dfe:	e6 a0                	out    %al,$0xa0
c0001e00:	e6 20                	out    %al,$0x20
c0001e02:	6a 0b                	push   $0xb
c0001e04:	ff 15 8c 78 00 c0    	call   *0xc000788c
c0001e0a:	e9 b1 fe ff ff       	jmp    c0001cc0 <intr_exit>

c0001e0f <intr0x0centry>:
intr0x0centry():
c0001e0f:	6a 00                	push   $0x0
c0001e11:	1e                   	push   %ds
c0001e12:	06                   	push   %es
c0001e13:	0f a0                	push   %fs
c0001e15:	0f a8                	push   %gs
c0001e17:	60                   	pusha  
c0001e18:	b0 20                	mov    $0x20,%al
c0001e1a:	e6 a0                	out    %al,$0xa0
c0001e1c:	e6 20                	out    %al,$0x20
c0001e1e:	6a 0c                	push   $0xc
c0001e20:	ff 15 90 78 00 c0    	call   *0xc0007890
c0001e26:	e9 95 fe ff ff       	jmp    c0001cc0 <intr_exit>

c0001e2b <intr0x0dentry>:
intr0x0dentry():
c0001e2b:	90                   	nop
c0001e2c:	1e                   	push   %ds
c0001e2d:	06                   	push   %es
c0001e2e:	0f a0                	push   %fs
c0001e30:	0f a8                	push   %gs
c0001e32:	60                   	pusha  
c0001e33:	b0 20                	mov    $0x20,%al
c0001e35:	e6 a0                	out    %al,$0xa0
c0001e37:	e6 20                	out    %al,$0x20
c0001e39:	6a 0d                	push   $0xd
c0001e3b:	ff 15 94 78 00 c0    	call   *0xc0007894
c0001e41:	e9 7a fe ff ff       	jmp    c0001cc0 <intr_exit>

c0001e46 <intr0x0eentry>:
intr0x0eentry():
c0001e46:	90                   	nop
c0001e47:	1e                   	push   %ds
c0001e48:	06                   	push   %es
c0001e49:	0f a0                	push   %fs
c0001e4b:	0f a8                	push   %gs
c0001e4d:	60                   	pusha  
c0001e4e:	b0 20                	mov    $0x20,%al
c0001e50:	e6 a0                	out    %al,$0xa0
c0001e52:	e6 20                	out    %al,$0x20
c0001e54:	6a 0e                	push   $0xe
c0001e56:	ff 15 98 78 00 c0    	call   *0xc0007898
c0001e5c:	e9 5f fe ff ff       	jmp    c0001cc0 <intr_exit>

c0001e61 <intr0x0fentry>:
intr0x0fentry():
c0001e61:	6a 00                	push   $0x0
c0001e63:	1e                   	push   %ds
c0001e64:	06                   	push   %es
c0001e65:	0f a0                	push   %fs
c0001e67:	0f a8                	push   %gs
c0001e69:	60                   	pusha  
c0001e6a:	b0 20                	mov    $0x20,%al
c0001e6c:	e6 a0                	out    %al,$0xa0
c0001e6e:	e6 20                	out    %al,$0x20
c0001e70:	6a 0f                	push   $0xf
c0001e72:	ff 15 9c 78 00 c0    	call   *0xc000789c
c0001e78:	e9 43 fe ff ff       	jmp    c0001cc0 <intr_exit>

c0001e7d <intr0x10entry>:
intr0x10entry():
c0001e7d:	6a 00                	push   $0x0
c0001e7f:	1e                   	push   %ds
c0001e80:	06                   	push   %es
c0001e81:	0f a0                	push   %fs
c0001e83:	0f a8                	push   %gs
c0001e85:	60                   	pusha  
c0001e86:	b0 20                	mov    $0x20,%al
c0001e88:	e6 a0                	out    %al,$0xa0
c0001e8a:	e6 20                	out    %al,$0x20
c0001e8c:	6a 10                	push   $0x10
c0001e8e:	ff 15 a0 78 00 c0    	call   *0xc00078a0
c0001e94:	e9 27 fe ff ff       	jmp    c0001cc0 <intr_exit>

c0001e99 <intr0x11entry>:
intr0x11entry():
c0001e99:	90                   	nop
c0001e9a:	1e                   	push   %ds
c0001e9b:	06                   	push   %es
c0001e9c:	0f a0                	push   %fs
c0001e9e:	0f a8                	push   %gs
c0001ea0:	60                   	pusha  
c0001ea1:	b0 20                	mov    $0x20,%al
c0001ea3:	e6 a0                	out    %al,$0xa0
c0001ea5:	e6 20                	out    %al,$0x20
c0001ea7:	6a 11                	push   $0x11
c0001ea9:	ff 15 a4 78 00 c0    	call   *0xc00078a4
c0001eaf:	e9 0c fe ff ff       	jmp    c0001cc0 <intr_exit>

c0001eb4 <intr0x12entry>:
intr0x12entry():
c0001eb4:	6a 00                	push   $0x0
c0001eb6:	1e                   	push   %ds
c0001eb7:	06                   	push   %es
c0001eb8:	0f a0                	push   %fs
c0001eba:	0f a8                	push   %gs
c0001ebc:	60                   	pusha  
c0001ebd:	b0 20                	mov    $0x20,%al
c0001ebf:	e6 a0                	out    %al,$0xa0
c0001ec1:	e6 20                	out    %al,$0x20
c0001ec3:	6a 12                	push   $0x12
c0001ec5:	ff 15 a8 78 00 c0    	call   *0xc00078a8
c0001ecb:	e9 f0 fd ff ff       	jmp    c0001cc0 <intr_exit>

c0001ed0 <intr0x13entry>:
intr0x13entry():
c0001ed0:	6a 00                	push   $0x0
c0001ed2:	1e                   	push   %ds
c0001ed3:	06                   	push   %es
c0001ed4:	0f a0                	push   %fs
c0001ed6:	0f a8                	push   %gs
c0001ed8:	60                   	pusha  
c0001ed9:	b0 20                	mov    $0x20,%al
c0001edb:	e6 a0                	out    %al,$0xa0
c0001edd:	e6 20                	out    %al,$0x20
c0001edf:	6a 13                	push   $0x13
c0001ee1:	ff 15 ac 78 00 c0    	call   *0xc00078ac
c0001ee7:	e9 d4 fd ff ff       	jmp    c0001cc0 <intr_exit>

c0001eec <intr0x14entry>:
intr0x14entry():
c0001eec:	6a 00                	push   $0x0
c0001eee:	1e                   	push   %ds
c0001eef:	06                   	push   %es
c0001ef0:	0f a0                	push   %fs
c0001ef2:	0f a8                	push   %gs
c0001ef4:	60                   	pusha  
c0001ef5:	b0 20                	mov    $0x20,%al
c0001ef7:	e6 a0                	out    %al,$0xa0
c0001ef9:	e6 20                	out    %al,$0x20
c0001efb:	6a 14                	push   $0x14
c0001efd:	ff 15 b0 78 00 c0    	call   *0xc00078b0
c0001f03:	e9 b8 fd ff ff       	jmp    c0001cc0 <intr_exit>

c0001f08 <intr0x15entry>:
intr0x15entry():
c0001f08:	6a 00                	push   $0x0
c0001f0a:	1e                   	push   %ds
c0001f0b:	06                   	push   %es
c0001f0c:	0f a0                	push   %fs
c0001f0e:	0f a8                	push   %gs
c0001f10:	60                   	pusha  
c0001f11:	b0 20                	mov    $0x20,%al
c0001f13:	e6 a0                	out    %al,$0xa0
c0001f15:	e6 20                	out    %al,$0x20
c0001f17:	6a 15                	push   $0x15
c0001f19:	ff 15 b4 78 00 c0    	call   *0xc00078b4
c0001f1f:	e9 9c fd ff ff       	jmp    c0001cc0 <intr_exit>

c0001f24 <intr0x16entry>:
intr0x16entry():
c0001f24:	6a 00                	push   $0x0
c0001f26:	1e                   	push   %ds
c0001f27:	06                   	push   %es
c0001f28:	0f a0                	push   %fs
c0001f2a:	0f a8                	push   %gs
c0001f2c:	60                   	pusha  
c0001f2d:	b0 20                	mov    $0x20,%al
c0001f2f:	e6 a0                	out    %al,$0xa0
c0001f31:	e6 20                	out    %al,$0x20
c0001f33:	6a 16                	push   $0x16
c0001f35:	ff 15 b8 78 00 c0    	call   *0xc00078b8
c0001f3b:	e9 80 fd ff ff       	jmp    c0001cc0 <intr_exit>

c0001f40 <intr0x17entry>:
intr0x17entry():
c0001f40:	6a 00                	push   $0x0
c0001f42:	1e                   	push   %ds
c0001f43:	06                   	push   %es
c0001f44:	0f a0                	push   %fs
c0001f46:	0f a8                	push   %gs
c0001f48:	60                   	pusha  
c0001f49:	b0 20                	mov    $0x20,%al
c0001f4b:	e6 a0                	out    %al,$0xa0
c0001f4d:	e6 20                	out    %al,$0x20
c0001f4f:	6a 17                	push   $0x17
c0001f51:	ff 15 bc 78 00 c0    	call   *0xc00078bc
c0001f57:	e9 64 fd ff ff       	jmp    c0001cc0 <intr_exit>

c0001f5c <intr0x18entry>:
intr0x18entry():
c0001f5c:	90                   	nop
c0001f5d:	1e                   	push   %ds
c0001f5e:	06                   	push   %es
c0001f5f:	0f a0                	push   %fs
c0001f61:	0f a8                	push   %gs
c0001f63:	60                   	pusha  
c0001f64:	b0 20                	mov    $0x20,%al
c0001f66:	e6 a0                	out    %al,$0xa0
c0001f68:	e6 20                	out    %al,$0x20
c0001f6a:	6a 18                	push   $0x18
c0001f6c:	ff 15 c0 78 00 c0    	call   *0xc00078c0
c0001f72:	e9 49 fd ff ff       	jmp    c0001cc0 <intr_exit>

c0001f77 <intr0x19entry>:
intr0x19entry():
c0001f77:	6a 00                	push   $0x0
c0001f79:	1e                   	push   %ds
c0001f7a:	06                   	push   %es
c0001f7b:	0f a0                	push   %fs
c0001f7d:	0f a8                	push   %gs
c0001f7f:	60                   	pusha  
c0001f80:	b0 20                	mov    $0x20,%al
c0001f82:	e6 a0                	out    %al,$0xa0
c0001f84:	e6 20                	out    %al,$0x20
c0001f86:	6a 19                	push   $0x19
c0001f88:	ff 15 c4 78 00 c0    	call   *0xc00078c4
c0001f8e:	e9 2d fd ff ff       	jmp    c0001cc0 <intr_exit>

c0001f93 <intr0x1aentry>:
intr0x1aentry():
c0001f93:	90                   	nop
c0001f94:	1e                   	push   %ds
c0001f95:	06                   	push   %es
c0001f96:	0f a0                	push   %fs
c0001f98:	0f a8                	push   %gs
c0001f9a:	60                   	pusha  
c0001f9b:	b0 20                	mov    $0x20,%al
c0001f9d:	e6 a0                	out    %al,$0xa0
c0001f9f:	e6 20                	out    %al,$0x20
c0001fa1:	6a 1a                	push   $0x1a
c0001fa3:	ff 15 c8 78 00 c0    	call   *0xc00078c8
c0001fa9:	e9 12 fd ff ff       	jmp    c0001cc0 <intr_exit>

c0001fae <intr0x1bentry>:
intr0x1bentry():
c0001fae:	90                   	nop
c0001faf:	1e                   	push   %ds
c0001fb0:	06                   	push   %es
c0001fb1:	0f a0                	push   %fs
c0001fb3:	0f a8                	push   %gs
c0001fb5:	60                   	pusha  
c0001fb6:	b0 20                	mov    $0x20,%al
c0001fb8:	e6 a0                	out    %al,$0xa0
c0001fba:	e6 20                	out    %al,$0x20
c0001fbc:	6a 1b                	push   $0x1b
c0001fbe:	ff 15 cc 78 00 c0    	call   *0xc00078cc
c0001fc4:	e9 f7 fc ff ff       	jmp    c0001cc0 <intr_exit>

c0001fc9 <intr0x1centry>:
intr0x1centry():
c0001fc9:	6a 00                	push   $0x0
c0001fcb:	1e                   	push   %ds
c0001fcc:	06                   	push   %es
c0001fcd:	0f a0                	push   %fs
c0001fcf:	0f a8                	push   %gs
c0001fd1:	60                   	pusha  
c0001fd2:	b0 20                	mov    $0x20,%al
c0001fd4:	e6 a0                	out    %al,$0xa0
c0001fd6:	e6 20                	out    %al,$0x20
c0001fd8:	6a 1c                	push   $0x1c
c0001fda:	ff 15 d0 78 00 c0    	call   *0xc00078d0
c0001fe0:	e9 db fc ff ff       	jmp    c0001cc0 <intr_exit>

c0001fe5 <intr0x1dentry>:
intr0x1dentry():
c0001fe5:	90                   	nop
c0001fe6:	1e                   	push   %ds
c0001fe7:	06                   	push   %es
c0001fe8:	0f a0                	push   %fs
c0001fea:	0f a8                	push   %gs
c0001fec:	60                   	pusha  
c0001fed:	b0 20                	mov    $0x20,%al
c0001fef:	e6 a0                	out    %al,$0xa0
c0001ff1:	e6 20                	out    %al,$0x20
c0001ff3:	6a 1d                	push   $0x1d
c0001ff5:	ff 15 d4 78 00 c0    	call   *0xc00078d4
c0001ffb:	e9 c0 fc ff ff       	jmp    c0001cc0 <intr_exit>

c0002000 <intr0x1eentry>:
intr0x1eentry():
c0002000:	90                   	nop
c0002001:	1e                   	push   %ds
c0002002:	06                   	push   %es
c0002003:	0f a0                	push   %fs
c0002005:	0f a8                	push   %gs
c0002007:	60                   	pusha  
c0002008:	b0 20                	mov    $0x20,%al
c000200a:	e6 a0                	out    %al,$0xa0
c000200c:	e6 20                	out    %al,$0x20
c000200e:	6a 1e                	push   $0x1e
c0002010:	ff 15 d8 78 00 c0    	call   *0xc00078d8
c0002016:	e9 a5 fc ff ff       	jmp    c0001cc0 <intr_exit>

c000201b <intr0x1fentry>:
intr0x1fentry():
c000201b:	6a 00                	push   $0x0
c000201d:	1e                   	push   %ds
c000201e:	06                   	push   %es
c000201f:	0f a0                	push   %fs
c0002021:	0f a8                	push   %gs
c0002023:	60                   	pusha  
c0002024:	b0 20                	mov    $0x20,%al
c0002026:	e6 a0                	out    %al,$0xa0
c0002028:	e6 20                	out    %al,$0x20
c000202a:	6a 1f                	push   $0x1f
c000202c:	ff 15 dc 78 00 c0    	call   *0xc00078dc
c0002032:	e9 89 fc ff ff       	jmp    c0001cc0 <intr_exit>

c0002037 <intr0x20entry>:
intr0x20entry():
c0002037:	6a 00                	push   $0x0
c0002039:	1e                   	push   %ds
c000203a:	06                   	push   %es
c000203b:	0f a0                	push   %fs
c000203d:	0f a8                	push   %gs
c000203f:	60                   	pusha  
c0002040:	b0 20                	mov    $0x20,%al
c0002042:	e6 a0                	out    %al,$0xa0
c0002044:	e6 20                	out    %al,$0x20
c0002046:	6a 20                	push   $0x20
c0002048:	ff 15 e0 78 00 c0    	call   *0xc00078e0
c000204e:	e9 6d fc ff ff       	jmp    c0001cc0 <intr_exit>

c0002053 <intr0x21entry>:
intr0x21entry():
c0002053:	6a 00                	push   $0x0
c0002055:	1e                   	push   %ds
c0002056:	06                   	push   %es
c0002057:	0f a0                	push   %fs
c0002059:	0f a8                	push   %gs
c000205b:	60                   	pusha  
c000205c:	b0 20                	mov    $0x20,%al
c000205e:	e6 a0                	out    %al,$0xa0
c0002060:	e6 20                	out    %al,$0x20
c0002062:	6a 21                	push   $0x21
c0002064:	ff 15 e4 78 00 c0    	call   *0xc00078e4
c000206a:	e9 51 fc ff ff       	jmp    c0001cc0 <intr_exit>

c000206f <intr0x22entry>:
intr0x22entry():
c000206f:	6a 00                	push   $0x0
c0002071:	1e                   	push   %ds
c0002072:	06                   	push   %es
c0002073:	0f a0                	push   %fs
c0002075:	0f a8                	push   %gs
c0002077:	60                   	pusha  
c0002078:	b0 20                	mov    $0x20,%al
c000207a:	e6 a0                	out    %al,$0xa0
c000207c:	e6 20                	out    %al,$0x20
c000207e:	6a 22                	push   $0x22
c0002080:	ff 15 e8 78 00 c0    	call   *0xc00078e8
c0002086:	e9 35 fc ff ff       	jmp    c0001cc0 <intr_exit>

c000208b <intr0x23entry>:
intr0x23entry():
c000208b:	6a 00                	push   $0x0
c000208d:	1e                   	push   %ds
c000208e:	06                   	push   %es
c000208f:	0f a0                	push   %fs
c0002091:	0f a8                	push   %gs
c0002093:	60                   	pusha  
c0002094:	b0 20                	mov    $0x20,%al
c0002096:	e6 a0                	out    %al,$0xa0
c0002098:	e6 20                	out    %al,$0x20
c000209a:	6a 23                	push   $0x23
c000209c:	ff 15 ec 78 00 c0    	call   *0xc00078ec
c00020a2:	e9 19 fc ff ff       	jmp    c0001cc0 <intr_exit>

c00020a7 <intr0x24entry>:
intr0x24entry():
c00020a7:	6a 00                	push   $0x0
c00020a9:	1e                   	push   %ds
c00020aa:	06                   	push   %es
c00020ab:	0f a0                	push   %fs
c00020ad:	0f a8                	push   %gs
c00020af:	60                   	pusha  
c00020b0:	b0 20                	mov    $0x20,%al
c00020b2:	e6 a0                	out    %al,$0xa0
c00020b4:	e6 20                	out    %al,$0x20
c00020b6:	6a 24                	push   $0x24
c00020b8:	ff 15 f0 78 00 c0    	call   *0xc00078f0
c00020be:	e9 fd fb ff ff       	jmp    c0001cc0 <intr_exit>

c00020c3 <intr0x25entry>:
intr0x25entry():
c00020c3:	6a 00                	push   $0x0
c00020c5:	1e                   	push   %ds
c00020c6:	06                   	push   %es
c00020c7:	0f a0                	push   %fs
c00020c9:	0f a8                	push   %gs
c00020cb:	60                   	pusha  
c00020cc:	b0 20                	mov    $0x20,%al
c00020ce:	e6 a0                	out    %al,$0xa0
c00020d0:	e6 20                	out    %al,$0x20
c00020d2:	6a 25                	push   $0x25
c00020d4:	ff 15 f4 78 00 c0    	call   *0xc00078f4
c00020da:	e9 e1 fb ff ff       	jmp    c0001cc0 <intr_exit>

c00020df <intr0x26entry>:
intr0x26entry():
c00020df:	6a 00                	push   $0x0
c00020e1:	1e                   	push   %ds
c00020e2:	06                   	push   %es
c00020e3:	0f a0                	push   %fs
c00020e5:	0f a8                	push   %gs
c00020e7:	60                   	pusha  
c00020e8:	b0 20                	mov    $0x20,%al
c00020ea:	e6 a0                	out    %al,$0xa0
c00020ec:	e6 20                	out    %al,$0x20
c00020ee:	6a 26                	push   $0x26
c00020f0:	ff 15 f8 78 00 c0    	call   *0xc00078f8
c00020f6:	e9 c5 fb ff ff       	jmp    c0001cc0 <intr_exit>

c00020fb <intr0x27entry>:
intr0x27entry():
c00020fb:	6a 00                	push   $0x0
c00020fd:	1e                   	push   %ds
c00020fe:	06                   	push   %es
c00020ff:	0f a0                	push   %fs
c0002101:	0f a8                	push   %gs
c0002103:	60                   	pusha  
c0002104:	b0 20                	mov    $0x20,%al
c0002106:	e6 a0                	out    %al,$0xa0
c0002108:	e6 20                	out    %al,$0x20
c000210a:	6a 27                	push   $0x27
c000210c:	ff 15 fc 78 00 c0    	call   *0xc00078fc
c0002112:	e9 a9 fb ff ff       	jmp    c0001cc0 <intr_exit>

c0002117 <intr0x28entry>:
intr0x28entry():
c0002117:	6a 00                	push   $0x0
c0002119:	1e                   	push   %ds
c000211a:	06                   	push   %es
c000211b:	0f a0                	push   %fs
c000211d:	0f a8                	push   %gs
c000211f:	60                   	pusha  
c0002120:	b0 20                	mov    $0x20,%al
c0002122:	e6 a0                	out    %al,$0xa0
c0002124:	e6 20                	out    %al,$0x20
c0002126:	6a 28                	push   $0x28
c0002128:	ff 15 00 79 00 c0    	call   *0xc0007900
c000212e:	e9 8d fb ff ff       	jmp    c0001cc0 <intr_exit>

c0002133 <intr0x29entry>:
intr0x29entry():
c0002133:	6a 00                	push   $0x0
c0002135:	1e                   	push   %ds
c0002136:	06                   	push   %es
c0002137:	0f a0                	push   %fs
c0002139:	0f a8                	push   %gs
c000213b:	60                   	pusha  
c000213c:	b0 20                	mov    $0x20,%al
c000213e:	e6 a0                	out    %al,$0xa0
c0002140:	e6 20                	out    %al,$0x20
c0002142:	6a 29                	push   $0x29
c0002144:	ff 15 04 79 00 c0    	call   *0xc0007904
c000214a:	e9 71 fb ff ff       	jmp    c0001cc0 <intr_exit>

c000214f <intr0x2aentry>:
intr0x2aentry():
c000214f:	6a 00                	push   $0x0
c0002151:	1e                   	push   %ds
c0002152:	06                   	push   %es
c0002153:	0f a0                	push   %fs
c0002155:	0f a8                	push   %gs
c0002157:	60                   	pusha  
c0002158:	b0 20                	mov    $0x20,%al
c000215a:	e6 a0                	out    %al,$0xa0
c000215c:	e6 20                	out    %al,$0x20
c000215e:	6a 2a                	push   $0x2a
c0002160:	ff 15 08 79 00 c0    	call   *0xc0007908
c0002166:	e9 55 fb ff ff       	jmp    c0001cc0 <intr_exit>

c000216b <intr0x2bentry>:
intr0x2bentry():
c000216b:	6a 00                	push   $0x0
c000216d:	1e                   	push   %ds
c000216e:	06                   	push   %es
c000216f:	0f a0                	push   %fs
c0002171:	0f a8                	push   %gs
c0002173:	60                   	pusha  
c0002174:	b0 20                	mov    $0x20,%al
c0002176:	e6 a0                	out    %al,$0xa0
c0002178:	e6 20                	out    %al,$0x20
c000217a:	6a 2b                	push   $0x2b
c000217c:	ff 15 0c 79 00 c0    	call   *0xc000790c
c0002182:	e9 39 fb ff ff       	jmp    c0001cc0 <intr_exit>

c0002187 <intr0x2centry>:
intr0x2centry():
c0002187:	6a 00                	push   $0x0
c0002189:	1e                   	push   %ds
c000218a:	06                   	push   %es
c000218b:	0f a0                	push   %fs
c000218d:	0f a8                	push   %gs
c000218f:	60                   	pusha  
c0002190:	b0 20                	mov    $0x20,%al
c0002192:	e6 a0                	out    %al,$0xa0
c0002194:	e6 20                	out    %al,$0x20
c0002196:	6a 2c                	push   $0x2c
c0002198:	ff 15 10 79 00 c0    	call   *0xc0007910
c000219e:	e9 1d fb ff ff       	jmp    c0001cc0 <intr_exit>

c00021a3 <intr0x2dentry>:
intr0x2dentry():
c00021a3:	6a 00                	push   $0x0
c00021a5:	1e                   	push   %ds
c00021a6:	06                   	push   %es
c00021a7:	0f a0                	push   %fs
c00021a9:	0f a8                	push   %gs
c00021ab:	60                   	pusha  
c00021ac:	b0 20                	mov    $0x20,%al
c00021ae:	e6 a0                	out    %al,$0xa0
c00021b0:	e6 20                	out    %al,$0x20
c00021b2:	6a 2d                	push   $0x2d
c00021b4:	ff 15 14 79 00 c0    	call   *0xc0007914
c00021ba:	e9 01 fb ff ff       	jmp    c0001cc0 <intr_exit>

c00021bf <intr0x2eentry>:
intr0x2eentry():
c00021bf:	6a 00                	push   $0x0
c00021c1:	1e                   	push   %ds
c00021c2:	06                   	push   %es
c00021c3:	0f a0                	push   %fs
c00021c5:	0f a8                	push   %gs
c00021c7:	60                   	pusha  
c00021c8:	b0 20                	mov    $0x20,%al
c00021ca:	e6 a0                	out    %al,$0xa0
c00021cc:	e6 20                	out    %al,$0x20
c00021ce:	6a 2e                	push   $0x2e
c00021d0:	ff 15 18 79 00 c0    	call   *0xc0007918
c00021d6:	e9 e5 fa ff ff       	jmp    c0001cc0 <intr_exit>

c00021db <intr0x2fentry>:
intr0x2fentry():
c00021db:	6a 00                	push   $0x0
c00021dd:	1e                   	push   %ds
c00021de:	06                   	push   %es
c00021df:	0f a0                	push   %fs
c00021e1:	0f a8                	push   %gs
c00021e3:	60                   	pusha  
c00021e4:	b0 20                	mov    $0x20,%al
c00021e6:	e6 a0                	out    %al,$0xa0
c00021e8:	e6 20                	out    %al,$0x20
c00021ea:	6a 2f                	push   $0x2f
c00021ec:	ff 15 1c 79 00 c0    	call   *0xc000791c
c00021f2:	e9 c9 fa ff ff       	jmp    c0001cc0 <intr_exit>

c00021f7 <syscall_handler>:
syscall_handler():
c00021f7:	6a 00                	push   $0x0
c00021f9:	1e                   	push   %ds
c00021fa:	06                   	push   %es
c00021fb:	0f a0                	push   %fs
c00021fd:	0f a8                	push   %gs
c00021ff:	60                   	pusha  
c0002200:	68 80 00 00 00       	push   $0x80
c0002205:	52                   	push   %edx
c0002206:	51                   	push   %ecx
c0002207:	53                   	push   %ebx
c0002208:	ff 14 85 c0 7b 00 c0 	call   *-0x3fff8440(,%eax,4)
c000220f:	83 c4 0c             	add    $0xc,%esp
c0002212:	89 44 24 20          	mov    %eax,0x20(%esp)
c0002216:	e9 a5 fa ff ff       	jmp    c0001cc0 <intr_exit>
c000221b:	66 90                	xchg   %ax,%ax
c000221d:	66 90                	xchg   %ax,%ax
c000221f:	90                   	nop

c0002220 <put_str>:
put_str():
c0002220:	53                   	push   %ebx
c0002221:	51                   	push   %ecx
c0002222:	31 c9                	xor    %ecx,%ecx
c0002224:	8b 5c 24 0c          	mov    0xc(%esp),%ebx

c0002228 <put_str.goon>:
put_str.goon():
c0002228:	8a 0b                	mov    (%ebx),%cl
c000222a:	80 f9 00             	cmp    $0x0,%cl
c000222d:	74 0c                	je     c000223b <put_str.str_over>
c000222f:	51                   	push   %ecx
c0002230:	e8 09 00 00 00       	call   c000223e <put_char>
c0002235:	83 c4 04             	add    $0x4,%esp
c0002238:	43                   	inc    %ebx
c0002239:	eb ed                	jmp    c0002228 <put_str.goon>

c000223b <put_str.str_over>:
put_str.str_over():
c000223b:	59                   	pop    %ecx
c000223c:	5b                   	pop    %ebx
c000223d:	c3                   	ret    

c000223e <put_char>:
put_char():
c000223e:	60                   	pusha  
c000223f:	66 b8 18 00          	mov    $0x18,%ax
c0002243:	8e e8                	mov    %eax,%gs
c0002245:	66 ba d4 03          	mov    $0x3d4,%dx
c0002249:	b0 0e                	mov    $0xe,%al
c000224b:	ee                   	out    %al,(%dx)
c000224c:	66 ba d5 03          	mov    $0x3d5,%dx
c0002250:	ec                   	in     (%dx),%al
c0002251:	88 c4                	mov    %al,%ah
c0002253:	66 ba d4 03          	mov    $0x3d4,%dx
c0002257:	b0 0f                	mov    $0xf,%al
c0002259:	ee                   	out    %al,(%dx)
c000225a:	66 ba d5 03          	mov    $0x3d5,%dx
c000225e:	ec                   	in     (%dx),%al
c000225f:	66 89 c3             	mov    %ax,%bx
c0002262:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0002266:	80 f9 0d             	cmp    $0xd,%cl
c0002269:	74 3c                	je     c00022a7 <put_char.is_carriage_return>
c000226b:	80 f9 0a             	cmp    $0xa,%cl
c000226e:	74 37                	je     c00022a7 <put_char.is_carriage_return>
c0002270:	80 f9 08             	cmp    $0x8,%cl
c0002273:	74 02                	je     c0002277 <put_char.is_backspace>
c0002275:	eb 16                	jmp    c000228d <put_char.put_other>

c0002277 <put_char.is_backspace>:
put_char.is_backspace():
c0002277:	66 4b                	dec    %bx
c0002279:	66 d1 e3             	shl    %bx
c000227c:	65 67 c6 07 20       	movb   $0x20,%gs:(%bx)
c0002281:	66 43                	inc    %bx
c0002283:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c0002288:	66 d1 eb             	shr    %bx
c000228b:	eb 60                	jmp    c00022ed <put_char.set_cursor>

c000228d <put_char.put_other>:
put_char.put_other():
c000228d:	66 d1 e3             	shl    %bx
c0002290:	65 67 88 0f          	mov    %cl,%gs:(%bx)
c0002294:	66 43                	inc    %bx
c0002296:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c000229b:	66 d1 eb             	shr    %bx
c000229e:	66 43                	inc    %bx
c00022a0:	66 81 fb d0 07       	cmp    $0x7d0,%bx
c00022a5:	7c 46                	jl     c00022ed <put_char.set_cursor>

c00022a7 <put_char.is_carriage_return>:
put_char.is_line_feed():
c00022a7:	66 31 d2             	xor    %dx,%dx
c00022aa:	66 89 d8             	mov    %bx,%ax
c00022ad:	66 be 50 00          	mov    $0x50,%si
c00022b1:	66 f7 f6             	div    %si
c00022b4:	66 29 d3             	sub    %dx,%bx

c00022b7 <put_char.is_carriage_return_end>:
put_char.is_carriage_return_end():
c00022b7:	66 83 c3 50          	add    $0x50,%bx
c00022bb:	66 81 fb d0 07       	cmp    $0x7d0,%bx

c00022c0 <put_char.is_line_feed_end>:
put_char.is_line_feed_end():
c00022c0:	7c 2b                	jl     c00022ed <put_char.set_cursor>

c00022c2 <put_char.roll_screen>:
put_char.roll_screen():
c00022c2:	fc                   	cld    
c00022c3:	b9 c0 03 00 00       	mov    $0x3c0,%ecx
c00022c8:	be a0 80 0b 00       	mov    $0xb80a0,%esi
c00022cd:	bf 00 80 0b 00       	mov    $0xb8000,%edi
c00022d2:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
c00022d4:	bb 00 0f 00 00       	mov    $0xf00,%ebx
c00022d9:	b9 50 00 00 00       	mov    $0x50,%ecx

c00022de <put_char.cls>:
put_char.cls():
c00022de:	65 66 c7 03 20 07    	movw   $0x720,%gs:(%ebx)
c00022e4:	83 c3 02             	add    $0x2,%ebx
c00022e7:	e2 f5                	loop   c00022de <put_char.cls>
c00022e9:	66 bb 80 07          	mov    $0x780,%bx

c00022ed <put_char.set_cursor>:
put_char.set_cursor():
c00022ed:	66 ba d4 03          	mov    $0x3d4,%dx
c00022f1:	b0 0e                	mov    $0xe,%al
c00022f3:	ee                   	out    %al,(%dx)
c00022f4:	66 ba d5 03          	mov    $0x3d5,%dx
c00022f8:	88 f8                	mov    %bh,%al
c00022fa:	ee                   	out    %al,(%dx)
c00022fb:	66 ba d4 03          	mov    $0x3d4,%dx
c00022ff:	b0 0f                	mov    $0xf,%al
c0002301:	ee                   	out    %al,(%dx)
c0002302:	66 ba d5 03          	mov    $0x3d5,%dx
c0002306:	88 d8                	mov    %bl,%al
c0002308:	ee                   	out    %al,(%dx)

c0002309 <put_char.put_char_done>:
put_char.put_char_done():
c0002309:	61                   	popa   
c000230a:	c3                   	ret    

c000230b <put_int>:
put_int():
c000230b:	60                   	pusha  
c000230c:	89 e5                	mov    %esp,%ebp
c000230e:	8b 45 24             	mov    0x24(%ebp),%eax
c0002311:	89 c2                	mov    %eax,%edx
c0002313:	bf 07 00 00 00       	mov    $0x7,%edi
c0002318:	b9 08 00 00 00       	mov    $0x8,%ecx
c000231d:	bb c0 70 00 c0       	mov    $0xc00070c0,%ebx

c0002322 <put_int.16based_4bits>:
put_int.16based_4bits():
c0002322:	83 e2 0f             	and    $0xf,%edx
c0002325:	83 fa 09             	cmp    $0x9,%edx
c0002328:	7f 05                	jg     c000232f <put_int.is_A2F>
c000232a:	83 c2 30             	add    $0x30,%edx
c000232d:	eb 06                	jmp    c0002335 <put_int.store>

c000232f <put_int.is_A2F>:
put_int.is_A2F():
c000232f:	83 ea 0a             	sub    $0xa,%edx
c0002332:	83 c2 41             	add    $0x41,%edx

c0002335 <put_int.store>:
put_int.store():
c0002335:	88 14 3b             	mov    %dl,(%ebx,%edi,1)
c0002338:	4f                   	dec    %edi
c0002339:	c1 e8 04             	shr    $0x4,%eax
c000233c:	89 c2                	mov    %eax,%edx
c000233e:	e2 e2                	loop   c0002322 <put_int.16based_4bits>

c0002340 <put_int.ready_to_print>:
put_int.ready_to_print():
c0002340:	47                   	inc    %edi

c0002341 <put_int.skip_prefix_0>:
put_int.skip_prefix_0():
c0002341:	83 ff 08             	cmp    $0x8,%edi
c0002344:	74 0f                	je     c0002355 <put_int.full0>

c0002346 <put_int.go_on_skip>:
put_int.go_on_skip():
c0002346:	8a 8f c0 70 00 c0    	mov    -0x3fff8f40(%edi),%cl
c000234c:	47                   	inc    %edi
c000234d:	80 f9 30             	cmp    $0x30,%cl
c0002350:	74 ef                	je     c0002341 <put_int.skip_prefix_0>
c0002352:	4f                   	dec    %edi
c0002353:	eb 02                	jmp    c0002357 <put_int.put_each_num>

c0002355 <put_int.full0>:
put_int.full0():
c0002355:	b1 30                	mov    $0x30,%cl

c0002357 <put_int.put_each_num>:
put_int.put_each_num():
c0002357:	51                   	push   %ecx
c0002358:	e8 e1 fe ff ff       	call   c000223e <put_char>
c000235d:	83 c4 04             	add    $0x4,%esp
c0002360:	47                   	inc    %edi
c0002361:	8a 8f c0 70 00 c0    	mov    -0x3fff8f40(%edi),%cl
c0002367:	83 ff 08             	cmp    $0x8,%edi
c000236a:	7c eb                	jl     c0002357 <put_int.put_each_num>
c000236c:	61                   	popa   
c000236d:	c3                   	ret    

c000236e <set_cursor>:
set_cursor():
c000236e:	60                   	pusha  
c000236f:	66 8b 5c 24 24       	mov    0x24(%esp),%bx
c0002374:	66 ba d4 03          	mov    $0x3d4,%dx
c0002378:	b0 0e                	mov    $0xe,%al
c000237a:	ee                   	out    %al,(%dx)
c000237b:	66 ba d5 03          	mov    $0x3d5,%dx
c000237f:	88 f8                	mov    %bh,%al
c0002381:	ee                   	out    %al,(%dx)
c0002382:	66 ba d4 03          	mov    $0x3d4,%dx
c0002386:	b0 0f                	mov    $0xf,%al
c0002388:	ee                   	out    %al,(%dx)
c0002389:	66 ba d5 03          	mov    $0x3d5,%dx
c000238d:	88 d8                	mov    %bl,%al
c000238f:	ee                   	out    %al,(%dx)
c0002390:	61                   	popa   
c0002391:	c3                   	ret    

c0002392 <panic_spin>:
panic_spin():
/work/x86_os_my/kernel/debug.c:10
/* 打印文件名,行号,函数名,条件并使程序悬停 */
void panic_spin(char* filename,	       \
	        int line,	       \
		const char* func,      \
		const char* condition) \
{
c0002392:	55                   	push   %ebp
c0002393:	89 e5                	mov    %esp,%ebp
c0002395:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/debug.c:11
   intr_disable();	// 因为有时候会单独调用panic_spin,所以在此处关中断。
c0002398:	e8 ce f6 ff ff       	call   c0001a6b <intr_disable>
/work/x86_os_my/kernel/debug.c:12
   put_str("\n\n\n!!!!! error !!!!!\n");
c000239d:	83 ec 0c             	sub    $0xc,%esp
c00023a0:	68 2b 4d 00 c0       	push   $0xc0004d2b
c00023a5:	e8 76 fe ff ff       	call   c0002220 <put_str>
c00023aa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:13
   put_str("filename:");put_str(filename);put_str("\n");
c00023ad:	83 ec 0c             	sub    $0xc,%esp
c00023b0:	68 41 4d 00 c0       	push   $0xc0004d41
c00023b5:	e8 66 fe ff ff       	call   c0002220 <put_str>
c00023ba:	83 c4 10             	add    $0x10,%esp
c00023bd:	83 ec 0c             	sub    $0xc,%esp
c00023c0:	ff 75 08             	pushl  0x8(%ebp)
c00023c3:	e8 58 fe ff ff       	call   c0002220 <put_str>
c00023c8:	83 c4 10             	add    $0x10,%esp
c00023cb:	83 ec 0c             	sub    $0xc,%esp
c00023ce:	68 4b 4d 00 c0       	push   $0xc0004d4b
c00023d3:	e8 48 fe ff ff       	call   c0002220 <put_str>
c00023d8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:14
   put_str("line:0x");put_int(line);put_str("\n");
c00023db:	83 ec 0c             	sub    $0xc,%esp
c00023de:	68 4d 4d 00 c0       	push   $0xc0004d4d
c00023e3:	e8 38 fe ff ff       	call   c0002220 <put_str>
c00023e8:	83 c4 10             	add    $0x10,%esp
c00023eb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00023ee:	83 ec 0c             	sub    $0xc,%esp
c00023f1:	50                   	push   %eax
c00023f2:	e8 14 ff ff ff       	call   c000230b <put_int>
c00023f7:	83 c4 10             	add    $0x10,%esp
c00023fa:	83 ec 0c             	sub    $0xc,%esp
c00023fd:	68 4b 4d 00 c0       	push   $0xc0004d4b
c0002402:	e8 19 fe ff ff       	call   c0002220 <put_str>
c0002407:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:15
   put_str("function:");put_str((char*)func);put_str("\n");
c000240a:	83 ec 0c             	sub    $0xc,%esp
c000240d:	68 55 4d 00 c0       	push   $0xc0004d55
c0002412:	e8 09 fe ff ff       	call   c0002220 <put_str>
c0002417:	83 c4 10             	add    $0x10,%esp
c000241a:	83 ec 0c             	sub    $0xc,%esp
c000241d:	ff 75 10             	pushl  0x10(%ebp)
c0002420:	e8 fb fd ff ff       	call   c0002220 <put_str>
c0002425:	83 c4 10             	add    $0x10,%esp
c0002428:	83 ec 0c             	sub    $0xc,%esp
c000242b:	68 4b 4d 00 c0       	push   $0xc0004d4b
c0002430:	e8 eb fd ff ff       	call   c0002220 <put_str>
c0002435:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:16
   put_str("condition:");put_str((char*)condition);put_str("\n");
c0002438:	83 ec 0c             	sub    $0xc,%esp
c000243b:	68 5f 4d 00 c0       	push   $0xc0004d5f
c0002440:	e8 db fd ff ff       	call   c0002220 <put_str>
c0002445:	83 c4 10             	add    $0x10,%esp
c0002448:	83 ec 0c             	sub    $0xc,%esp
c000244b:	ff 75 14             	pushl  0x14(%ebp)
c000244e:	e8 cd fd ff ff       	call   c0002220 <put_str>
c0002453:	83 c4 10             	add    $0x10,%esp
c0002456:	83 ec 0c             	sub    $0xc,%esp
c0002459:	68 4b 4d 00 c0       	push   $0xc0004d4b
c000245e:	e8 bd fd ff ff       	call   c0002220 <put_str>
c0002463:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:17 (discriminator 1)
   while(1);
c0002466:	eb fe                	jmp    c0002466 <panic_spin+0xd4>

c0002468 <bitmap_init>:
bitmap_init():
/work/x86_os_my/lib/kernel/bitmap.c:16
	uint8_t* bits;				位图空间
};
*/

/* 将位图btmp初始化 */
void bitmap_init(struct bitmap* btmp) {
c0002468:	55                   	push   %ebp
c0002469:	89 e5                	mov    %esp,%ebp
c000246b:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/bitmap.c:17
	memset(btmp->bits, 0, btmp->btmp_bytes_len);   
c000246e:	8b 45 08             	mov    0x8(%ebp),%eax
c0002471:	8b 10                	mov    (%eax),%edx
c0002473:	8b 45 08             	mov    0x8(%ebp),%eax
c0002476:	8b 40 04             	mov    0x4(%eax),%eax
c0002479:	83 ec 04             	sub    $0x4,%esp
c000247c:	52                   	push   %edx
c000247d:	6a 00                	push   $0x0
c000247f:	50                   	push   %eax
c0002480:	e8 35 0a 00 00       	call   c0002eba <memset>
c0002485:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:18
}
c0002488:	90                   	nop
c0002489:	c9                   	leave  
c000248a:	c3                   	ret    

c000248b <bitmap_scan_test>:
bitmap_scan_test():
/work/x86_os_my/lib/kernel/bitmap.c:23

/* 判断bit_idx位是否为1
若为1则返回true
否则返回false */
bool bitmap_scan_test(struct bitmap* btmp, uint32_t bit_idx) {
c000248b:	55                   	push   %ebp
c000248c:	89 e5                	mov    %esp,%ebp
c000248e:	53                   	push   %ebx
c000248f:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:24
	uint32_t byte_idx = bit_idx / 8;    // 向下取整用于索引数组下标
c0002492:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002495:	c1 e8 03             	shr    $0x3,%eax
c0002498:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:25
	uint32_t bit_odd  = bit_idx % 8;    // 取余用于索引数组内的位
c000249b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000249e:	83 e0 07             	and    $0x7,%eax
c00024a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:26
	return (btmp->bits[byte_idx] & (BITMAP_MASK << bit_odd));
c00024a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00024a7:	8b 50 04             	mov    0x4(%eax),%edx
c00024aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00024ad:	01 d0                	add    %edx,%eax
c00024af:	0f b6 00             	movzbl (%eax),%eax
c00024b2:	0f b6 d0             	movzbl %al,%edx
c00024b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00024b8:	bb 01 00 00 00       	mov    $0x1,%ebx
c00024bd:	89 c1                	mov    %eax,%ecx
c00024bf:	d3 e3                	shl    %cl,%ebx
c00024c1:	89 d8                	mov    %ebx,%eax
c00024c3:	21 d0                	and    %edx,%eax
/work/x86_os_my/lib/kernel/bitmap.c:27
}
c00024c5:	83 c4 10             	add    $0x10,%esp
c00024c8:	5b                   	pop    %ebx
c00024c9:	5d                   	pop    %ebp
c00024ca:	c3                   	ret    

c00024cb <bitmap_scan>:
bitmap_scan():
/work/x86_os_my/lib/kernel/bitmap.c:32

/* 在位图中申请连续cnt个位
成功：返回其起始位下标
失败：返回-1 */
int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {
c00024cb:	55                   	push   %ebp
c00024cc:	89 e5                	mov    %esp,%ebp
c00024ce:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/lib/kernel/bitmap.c:33
	uint32_t idx_byte = 0;	 // 用于记录空闲位所在的字节
c00024d1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:35
	/* 先逐字节比较,蛮力法 */
	while (( 0xff == btmp->bits[idx_byte]) && (idx_byte < btmp->btmp_bytes_len)) {
c00024d8:	eb 04                	jmp    c00024de <bitmap_scan+0x13>
/work/x86_os_my/lib/kernel/bitmap.c:37
		/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */
		idx_byte++;
c00024da:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:35
成功：返回其起始位下标
失败：返回-1 */
int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {
	uint32_t idx_byte = 0;	 // 用于记录空闲位所在的字节
	/* 先逐字节比较,蛮力法 */
	while (( 0xff == btmp->bits[idx_byte]) && (idx_byte < btmp->btmp_bytes_len)) {
c00024de:	8b 45 08             	mov    0x8(%ebp),%eax
c00024e1:	8b 50 04             	mov    0x4(%eax),%edx
c00024e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00024e7:	01 d0                	add    %edx,%eax
c00024e9:	0f b6 00             	movzbl (%eax),%eax
c00024ec:	3c ff                	cmp    $0xff,%al
c00024ee:	75 0a                	jne    c00024fa <bitmap_scan+0x2f>
/work/x86_os_my/lib/kernel/bitmap.c:35 (discriminator 1)
c00024f0:	8b 45 08             	mov    0x8(%ebp),%eax
c00024f3:	8b 00                	mov    (%eax),%eax
c00024f5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00024f8:	77 e0                	ja     c00024da <bitmap_scan+0xf>
/work/x86_os_my/lib/kernel/bitmap.c:39
		/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */
		idx_byte++;
	}
	ASSERT(idx_byte < btmp->btmp_bytes_len);	//这里应该是"<="
c00024fa:	8b 45 08             	mov    0x8(%ebp),%eax
c00024fd:	8b 00                	mov    (%eax),%eax
c00024ff:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0002502:	77 19                	ja     c000251d <bitmap_scan+0x52>
/work/x86_os_my/lib/kernel/bitmap.c:39 (discriminator 1)
c0002504:	68 6c 4d 00 c0       	push   $0xc0004d6c
c0002509:	68 c0 4d 00 c0       	push   $0xc0004dc0
c000250e:	6a 27                	push   $0x27
c0002510:	68 8c 4d 00 c0       	push   $0xc0004d8c
c0002515:	e8 78 fe ff ff       	call   c0002392 <panic_spin>
c000251a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:40
	if (idx_byte == btmp->btmp_bytes_len) {		// 若该内存池找不到可用空间		
c000251d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002520:	8b 00                	mov    (%eax),%eax
c0002522:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0002525:	75 0a                	jne    c0002531 <bitmap_scan+0x66>
/work/x86_os_my/lib/kernel/bitmap.c:41
		return -1;
c0002527:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000252c:	e9 cd 00 00 00       	jmp    c00025fe <bitmap_scan+0x133>
/work/x86_os_my/lib/kernel/bitmap.c:46
	}

	/* 若在位图数组范围内的某字节内找到了空闲位，
	 * 在该字节内逐位比对,返回空闲位的索引。*/
	int idx_bit = 0;
c0002531:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:48
	/* 和btmp->bits[idx_byte]这个字节逐位对比 */
	while ((uint8_t)(BITMAP_MASK << idx_bit) & btmp->bits[idx_byte]) { 
c0002538:	eb 04                	jmp    c000253e <bitmap_scan+0x73>
/work/x86_os_my/lib/kernel/bitmap.c:49
		idx_bit++;
c000253a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:48

	/* 若在位图数组范围内的某字节内找到了空闲位，
	 * 在该字节内逐位比对,返回空闲位的索引。*/
	int idx_bit = 0;
	/* 和btmp->bits[idx_byte]这个字节逐位对比 */
	while ((uint8_t)(BITMAP_MASK << idx_bit) & btmp->bits[idx_byte]) { 
c000253e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002541:	ba 01 00 00 00       	mov    $0x1,%edx
c0002546:	89 c1                	mov    %eax,%ecx
c0002548:	d3 e2                	shl    %cl,%edx
c000254a:	89 d0                	mov    %edx,%eax
c000254c:	0f b6 d0             	movzbl %al,%edx
c000254f:	8b 45 08             	mov    0x8(%ebp),%eax
c0002552:	8b 48 04             	mov    0x4(%eax),%ecx
c0002555:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002558:	01 c8                	add    %ecx,%eax
c000255a:	0f b6 00             	movzbl (%eax),%eax
c000255d:	0f b6 c0             	movzbl %al,%eax
c0002560:	21 d0                	and    %edx,%eax
c0002562:	85 c0                	test   %eax,%eax
c0002564:	75 d4                	jne    c000253a <bitmap_scan+0x6f>
/work/x86_os_my/lib/kernel/bitmap.c:52
		idx_bit++;
	}
	
	int bit_idx_start = idx_byte * 8 + idx_bit;		// 空闲位在位图内的下标
c0002566:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002569:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c0002570:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002573:	01 d0                	add    %edx,%eax
c0002575:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:53
	if (cnt == 1) {
c0002578:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
c000257c:	75 05                	jne    c0002583 <bitmap_scan+0xb8>
/work/x86_os_my/lib/kernel/bitmap.c:54
		return bit_idx_start;
c000257e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002581:	eb 7b                	jmp    c00025fe <bitmap_scan+0x133>
/work/x86_os_my/lib/kernel/bitmap.c:57
	}

	uint32_t bit_left = (btmp->btmp_bytes_len * 8 - bit_idx_start);	// 记录还有多少位可以判断
c0002583:	8b 45 08             	mov    0x8(%ebp),%eax
c0002586:	8b 00                	mov    (%eax),%eax
c0002588:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c000258f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002592:	29 c2                	sub    %eax,%edx
c0002594:	89 d0                	mov    %edx,%eax
c0002596:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:58
	uint32_t next_bit = bit_idx_start + 1;
c0002599:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000259c:	83 c0 01             	add    $0x1,%eax
c000259f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:59
	uint32_t count = 1;			// 用于记录找到的空闲位的个数
c00025a2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:61

	bit_idx_start = -1;			// 初始化为-1，若找不到连续的位就直接返回-1
c00025a9:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:62
	while (bit_left-- > 0) {
c00025b0:	eb 3c                	jmp    c00025ee <bitmap_scan+0x123>
/work/x86_os_my/lib/kernel/bitmap.c:63
		if (!(bitmap_scan_test(btmp, next_bit))) {	// 判断next_bit位是否为1,=1返回true，=0返回false
c00025b2:	83 ec 08             	sub    $0x8,%esp
c00025b5:	ff 75 e4             	pushl  -0x1c(%ebp)
c00025b8:	ff 75 08             	pushl  0x8(%ebp)
c00025bb:	e8 cb fe ff ff       	call   c000248b <bitmap_scan_test>
c00025c0:	83 c4 10             	add    $0x10,%esp
c00025c3:	85 c0                	test   %eax,%eax
c00025c5:	75 06                	jne    c00025cd <bitmap_scan+0x102>
/work/x86_os_my/lib/kernel/bitmap.c:64
			count++;
c00025c7:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
c00025cb:	eb 07                	jmp    c00025d4 <bitmap_scan+0x109>
/work/x86_os_my/lib/kernel/bitmap.c:66
		} else {
			count = 0;			// 重新从0找cnt个连续的bit
c00025cd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:69
		}
		
		if (count == cnt) {		// 已找到连续的cnt个空位
c00025d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00025d7:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00025da:	75 0e                	jne    c00025ea <bitmap_scan+0x11f>
/work/x86_os_my/lib/kernel/bitmap.c:70
			bit_idx_start = next_bit - cnt + 1;
c00025dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00025df:	2b 45 0c             	sub    0xc(%ebp),%eax
c00025e2:	83 c0 01             	add    $0x1,%eax
c00025e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:71
			break;
c00025e8:	eb 11                	jmp    c00025fb <bitmap_scan+0x130>
/work/x86_os_my/lib/kernel/bitmap.c:73
		}
		next_bit++;
c00025ea:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:62
	uint32_t bit_left = (btmp->btmp_bytes_len * 8 - bit_idx_start);	// 记录还有多少位可以判断
	uint32_t next_bit = bit_idx_start + 1;
	uint32_t count = 1;			// 用于记录找到的空闲位的个数

	bit_idx_start = -1;			// 初始化为-1，若找不到连续的位就直接返回-1
	while (bit_left-- > 0) {
c00025ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00025f1:	8d 50 ff             	lea    -0x1(%eax),%edx
c00025f4:	89 55 e8             	mov    %edx,-0x18(%ebp)
c00025f7:	85 c0                	test   %eax,%eax
c00025f9:	75 b7                	jne    c00025b2 <bitmap_scan+0xe7>
/work/x86_os_my/lib/kernel/bitmap.c:75
			bit_idx_start = next_bit - cnt + 1;
			break;
		}
		next_bit++;
	}
	return bit_idx_start;
c00025fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/lib/kernel/bitmap.c:76
}
c00025fe:	c9                   	leave  
c00025ff:	c3                   	ret    

c0002600 <bitmap_set>:
bitmap_set():
/work/x86_os_my/lib/kernel/bitmap.c:79

/* 将位图btmp的bit_idx位设置为value */
void bitmap_set(struct bitmap* btmp, uint32_t bit_idx, int8_t value) {
c0002600:	55                   	push   %ebp
c0002601:	89 e5                	mov    %esp,%ebp
c0002603:	56                   	push   %esi
c0002604:	53                   	push   %ebx
c0002605:	83 ec 20             	sub    $0x20,%esp
c0002608:	8b 45 10             	mov    0x10(%ebp),%eax
c000260b:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:80
	ASSERT((value == 0) || (value == 1));
c000260e:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c0002612:	74 1f                	je     c0002633 <bitmap_set+0x33>
/work/x86_os_my/lib/kernel/bitmap.c:80 (discriminator 1)
c0002614:	80 7d e4 01          	cmpb   $0x1,-0x1c(%ebp)
c0002618:	74 19                	je     c0002633 <bitmap_set+0x33>
/work/x86_os_my/lib/kernel/bitmap.c:80 (discriminator 2)
c000261a:	68 a0 4d 00 c0       	push   $0xc0004da0
c000261f:	68 cc 4d 00 c0       	push   $0xc0004dcc
c0002624:	6a 50                	push   $0x50
c0002626:	68 8c 4d 00 c0       	push   $0xc0004d8c
c000262b:	e8 62 fd ff ff       	call   c0002392 <panic_spin>
c0002630:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:81
	uint32_t byte_idx = bit_idx / 8;    // 向下取整用于索引数组下标
c0002633:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002636:	c1 e8 03             	shr    $0x3,%eax
c0002639:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:82
	uint32_t bit_odd  = bit_idx % 8;    // 取余用于索引数组内的位
c000263c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000263f:	83 e0 07             	and    $0x7,%eax
c0002642:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:86

	/* 一般都会用个0x1这样的数对字节中的位操作,
	* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/
	if (value) {
c0002645:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c0002649:	74 2f                	je     c000267a <bitmap_set+0x7a>
/work/x86_os_my/lib/kernel/bitmap.c:87
		btmp->bits[byte_idx] |= (BITMAP_MASK << bit_odd);
c000264b:	8b 45 08             	mov    0x8(%ebp),%eax
c000264e:	8b 50 04             	mov    0x4(%eax),%edx
c0002651:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002654:	01 c2                	add    %eax,%edx
c0002656:	8b 45 08             	mov    0x8(%ebp),%eax
c0002659:	8b 48 04             	mov    0x4(%eax),%ecx
c000265c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000265f:	01 c8                	add    %ecx,%eax
c0002661:	0f b6 00             	movzbl (%eax),%eax
c0002664:	89 c6                	mov    %eax,%esi
c0002666:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002669:	bb 01 00 00 00       	mov    $0x1,%ebx
c000266e:	89 c1                	mov    %eax,%ecx
c0002670:	d3 e3                	shl    %cl,%ebx
c0002672:	89 d8                	mov    %ebx,%eax
c0002674:	09 f0                	or     %esi,%eax
c0002676:	88 02                	mov    %al,(%edx)
/work/x86_os_my/lib/kernel/bitmap.c:91
	} else {
		btmp->bits[byte_idx] &= ~(BITMAP_MASK << bit_odd);
	}
}
c0002678:	eb 2f                	jmp    c00026a9 <bitmap_set+0xa9>
/work/x86_os_my/lib/kernel/bitmap.c:89
	/* 一般都会用个0x1这样的数对字节中的位操作,
	* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/
	if (value) {
		btmp->bits[byte_idx] |= (BITMAP_MASK << bit_odd);
	} else {
		btmp->bits[byte_idx] &= ~(BITMAP_MASK << bit_odd);
c000267a:	8b 45 08             	mov    0x8(%ebp),%eax
c000267d:	8b 50 04             	mov    0x4(%eax),%edx
c0002680:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002683:	01 c2                	add    %eax,%edx
c0002685:	8b 45 08             	mov    0x8(%ebp),%eax
c0002688:	8b 48 04             	mov    0x4(%eax),%ecx
c000268b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000268e:	01 c8                	add    %ecx,%eax
c0002690:	0f b6 00             	movzbl (%eax),%eax
c0002693:	89 c3                	mov    %eax,%ebx
c0002695:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002698:	be 01 00 00 00       	mov    $0x1,%esi
c000269d:	89 c1                	mov    %eax,%ecx
c000269f:	d3 e6                	shl    %cl,%esi
c00026a1:	89 f0                	mov    %esi,%eax
c00026a3:	f7 d0                	not    %eax
c00026a5:	21 d8                	and    %ebx,%eax
c00026a7:	88 02                	mov    %al,(%edx)
/work/x86_os_my/lib/kernel/bitmap.c:91
	}
}
c00026a9:	90                   	nop
c00026aa:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00026ad:	5b                   	pop    %ebx
c00026ae:	5e                   	pop    %esi
c00026af:	5d                   	pop    %ebp
c00026b0:	c3                   	ret    

c00026b1 <vaddr_get>:
vaddr_get():
/work/x86_os_my/kernel/memory.c:55
struct pool kernel_pool, user_pool;		// 生成内核内存池和用户内存池
struct virtual_addr kernel_vaddr;		// 此结构是用来给内核分配虚拟地址

/* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页,
 * 成功则返回虚拟页的起始地址, 失败则返回NULL */
static void* vaddr_get(enum pool_flags pf, uint32_t pg_cnt) {
c00026b1:	55                   	push   %ebp
c00026b2:	89 e5                	mov    %esp,%ebp
c00026b4:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:56
	int vaddr_start = 0, bit_idx_start = -1;
c00026b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00026be:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:57
	uint32_t cnt = 0;
c00026c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:58
	if (pf == PF_KERNEL) {
c00026cc:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c00026d0:	75 64                	jne    c0002736 <vaddr_get+0x85>
/work/x86_os_my/kernel/memory.c:60
		// 在位图中申请连续cnt个位 成功：返回其起始位下标
		bit_idx_start  = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
c00026d2:	83 ec 08             	sub    $0x8,%esp
c00026d5:	ff 75 0c             	pushl  0xc(%ebp)
c00026d8:	68 ac 7a 00 c0       	push   $0xc0007aac
c00026dd:	e8 e9 fd ff ff       	call   c00024cb <bitmap_scan>
c00026e2:	83 c4 10             	add    $0x10,%esp
c00026e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:61
		if (bit_idx_start == -1) {	//失败
c00026e8:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c00026ec:	75 2b                	jne    c0002719 <vaddr_get+0x68>
/work/x86_os_my/kernel/memory.c:62
			return NULL;
c00026ee:	b8 00 00 00 00       	mov    $0x0,%eax
c00026f3:	e9 cd 00 00 00       	jmp    c00027c5 <vaddr_get+0x114>
/work/x86_os_my/kernel/memory.c:66
		}
		while(cnt < pg_cnt) {
			// 设置位图中的位，表示内存已被占用
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
c00026f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00026fb:	8d 50 01             	lea    0x1(%eax),%edx
c00026fe:	89 55 f0             	mov    %edx,-0x10(%ebp)
c0002701:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002704:	01 d0                	add    %edx,%eax
c0002706:	83 ec 04             	sub    $0x4,%esp
c0002709:	6a 01                	push   $0x1
c000270b:	50                   	push   %eax
c000270c:	68 ac 7a 00 c0       	push   $0xc0007aac
c0002711:	e8 ea fe ff ff       	call   c0002600 <bitmap_set>
c0002716:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:64
		// 在位图中申请连续cnt个位 成功：返回其起始位下标
		bit_idx_start  = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
		if (bit_idx_start == -1) {	//失败
			return NULL;
		}
		while(cnt < pg_cnt) {
c0002719:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000271c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000271f:	72 d7                	jb     c00026f8 <vaddr_get+0x47>
/work/x86_os_my/kernel/memory.c:68
			// 设置位图中的位，表示内存已被占用
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
		}
		vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
c0002721:	a1 b4 7a 00 c0       	mov    0xc0007ab4,%eax
c0002726:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002729:	c1 e2 0c             	shl    $0xc,%edx
c000272c:	01 d0                	add    %edx,%eax
c000272e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002731:	e9 8c 00 00 00       	jmp    c00027c2 <vaddr_get+0x111>
/work/x86_os_my/kernel/memory.c:70
	} else {
		struct task_struct* cur = running_thread();
c0002736:	e8 4f 0b 00 00       	call   c000328a <running_thread>
c000273b:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:71
		bit_idx_start  = bitmap_scan(&cur->userprog_vaddr.vaddr_bitmap, pg_cnt);
c000273e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002741:	83 c0 38             	add    $0x38,%eax
c0002744:	83 ec 08             	sub    $0x8,%esp
c0002747:	ff 75 0c             	pushl  0xc(%ebp)
c000274a:	50                   	push   %eax
c000274b:	e8 7b fd ff ff       	call   c00024cb <bitmap_scan>
c0002750:	83 c4 10             	add    $0x10,%esp
c0002753:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:72
		if (bit_idx_start == -1) {
c0002756:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c000275a:	75 2a                	jne    c0002786 <vaddr_get+0xd5>
/work/x86_os_my/kernel/memory.c:73
			return NULL;
c000275c:	b8 00 00 00 00       	mov    $0x0,%eax
c0002761:	eb 62                	jmp    c00027c5 <vaddr_get+0x114>
/work/x86_os_my/kernel/memory.c:76
		}
		while(cnt < pg_cnt) {
			bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
c0002763:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002766:	8d 50 01             	lea    0x1(%eax),%edx
c0002769:	89 55 f0             	mov    %edx,-0x10(%ebp)
c000276c:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000276f:	01 c2                	add    %eax,%edx
c0002771:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002774:	83 c0 38             	add    $0x38,%eax
c0002777:	83 ec 04             	sub    $0x4,%esp
c000277a:	6a 01                	push   $0x1
c000277c:	52                   	push   %edx
c000277d:	50                   	push   %eax
c000277e:	e8 7d fe ff ff       	call   c0002600 <bitmap_set>
c0002783:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:75
		struct task_struct* cur = running_thread();
		bit_idx_start  = bitmap_scan(&cur->userprog_vaddr.vaddr_bitmap, pg_cnt);
		if (bit_idx_start == -1) {
			return NULL;
		}
		while(cnt < pg_cnt) {
c0002786:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002789:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000278c:	72 d5                	jb     c0002763 <vaddr_get+0xb2>
/work/x86_os_my/kernel/memory.c:78
			bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
		}
		vaddr_start = cur->userprog_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
c000278e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002791:	8b 40 40             	mov    0x40(%eax),%eax
c0002794:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002797:	c1 e2 0c             	shl    $0xc,%edx
c000279a:	01 d0                	add    %edx,%eax
c000279c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:81

		/* (0xc0000000 - PG_SIZE)做为用户3级栈已经在start_process被分配 */
		ASSERT((uint32_t)vaddr_start < (0xc0000000 - PG_SIZE));
c000279f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00027a2:	3d ff ef ff bf       	cmp    $0xbfffefff,%eax
c00027a7:	76 19                	jbe    c00027c2 <vaddr_get+0x111>
/work/x86_os_my/kernel/memory.c:81 (discriminator 1)
c00027a9:	68 d8 4d 00 c0       	push   $0xc0004dd8
c00027ae:	68 7c 4f 00 c0       	push   $0xc0004f7c
c00027b3:	6a 51                	push   $0x51
c00027b5:	68 07 4e 00 c0       	push   $0xc0004e07
c00027ba:	e8 d3 fb ff ff       	call   c0002392 <panic_spin>
c00027bf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:84
		
	}
	return (void*)vaddr_start;
c00027c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:85
}
c00027c5:	c9                   	leave  
c00027c6:	c3                   	ret    

c00027c7 <pte_ptr>:
pte_ptr():
/work/x86_os_my/kernel/memory.c:92
// 页表项 page table
/* 得到虚拟地址vaddr对应的pte指针*/
// 虚拟地址 vaddr 所在 pte 的"虚拟地址"!!!
// *pte 代表的是 pte 页表项的内容,
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页表项"属性
uint32_t* pte_ptr(uint32_t vaddr) {
c00027c7:	55                   	push   %ebp
c00027c8:	89 e5                	mov    %esp,%ebp
c00027ca:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:97
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
					((vaddr & 0xffc00000) >> 10) + \
c00027cd:	8b 45 08             	mov    0x8(%ebp),%eax
c00027d0:	25 00 00 c0 ff       	and    $0xffc00000,%eax
c00027d5:	c1 e8 0a             	shr    $0xa,%eax
c00027d8:	89 c2                	mov    %eax,%edx
/work/x86_os_my/kernel/memory.c:98
					PTE_IDX(vaddr) * 4);
c00027da:	8b 45 08             	mov    0x8(%ebp),%eax
c00027dd:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c00027e2:	c1 e8 0c             	shr    $0xc,%eax
c00027e5:	c1 e0 02             	shl    $0x2,%eax
/work/x86_os_my/kernel/memory.c:97
uint32_t* pte_ptr(uint32_t vaddr) {
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
					((vaddr & 0xffc00000) >> 10) + \
c00027e8:	01 d0                	add    %edx,%eax
c00027ea:	2d 00 00 40 00       	sub    $0x400000,%eax
/work/x86_os_my/kernel/memory.c:96
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页表项"属性
uint32_t* pte_ptr(uint32_t vaddr) {
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
c00027ef:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:99
					((vaddr & 0xffc00000) >> 10) + \
					PTE_IDX(vaddr) * 4);
	return pte;
c00027f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/kernel/memory.c:100
}
c00027f5:	c9                   	leave  
c00027f6:	c3                   	ret    

c00027f7 <pde_ptr>:
pde_ptr():
/work/x86_os_my/kernel/memory.c:107
// 页目录表项 page Directory table entry
/* 得到虚拟地址vaddr对应的pde的指针 */
// 虚拟地址 vaddr 所在 pde 的"虚拟地址"!!!
// *pde 代表的是 pde 页目录项的内容
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页目录项"属性
uint32_t* pde_ptr(uint32_t vaddr) {
c00027f7:	55                   	push   %ebp
c00027f8:	89 e5                	mov    %esp,%ebp
c00027fa:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:109
	/* 0xfffff是用来访问到页目录表本身所在的地址 */
	uint32_t* pde = (uint32_t*)((0xfffff000) + PDE_IDX(vaddr) * 4);
c00027fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0002800:	c1 e8 16             	shr    $0x16,%eax
c0002803:	05 00 fc ff 3f       	add    $0x3ffffc00,%eax
c0002808:	c1 e0 02             	shl    $0x2,%eax
c000280b:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:110
	return pde;
c000280e:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/kernel/memory.c:111
}
c0002811:	c9                   	leave  
c0002812:	c3                   	ret    

c0002813 <palloc>:
palloc():
/work/x86_os_my/kernel/memory.c:115

/* 在m_pool指向的物理内存池中分配1个物理页,
 * 成功则返回页框的物理地址,失败则返回NULL */
static void* palloc(struct pool* m_pool) {
c0002813:	55                   	push   %ebp
c0002814:	89 e5                	mov    %esp,%ebp
c0002816:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:117
	/* 扫描或设置位图要保证原子操作 */
	int bit_idx = bitmap_scan(&m_pool->pool_bitmap, 1);    // 找一个物理页面
c0002819:	8b 45 08             	mov    0x8(%ebp),%eax
c000281c:	83 ec 08             	sub    $0x8,%esp
c000281f:	6a 01                	push   $0x1
c0002821:	50                   	push   %eax
c0002822:	e8 a4 fc ff ff       	call   c00024cb <bitmap_scan>
c0002827:	83 c4 10             	add    $0x10,%esp
c000282a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:118
	if (bit_idx == -1 ) {
c000282d:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0002831:	75 07                	jne    c000283a <palloc+0x27>
/work/x86_os_my/kernel/memory.c:119
		return NULL;
c0002833:	b8 00 00 00 00       	mov    $0x0,%eax
c0002838:	eb 2b                	jmp    c0002865 <palloc+0x52>
/work/x86_os_my/kernel/memory.c:121
	}
	bitmap_set(&m_pool->pool_bitmap, bit_idx, 1);	// 将此位bit_idx置1
c000283a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000283d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002840:	83 ec 04             	sub    $0x4,%esp
c0002843:	6a 01                	push   $0x1
c0002845:	52                   	push   %edx
c0002846:	50                   	push   %eax
c0002847:	e8 b4 fd ff ff       	call   c0002600 <bitmap_set>
c000284c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:122
	uint32_t page_phyaddr = ((bit_idx * PG_SIZE) + m_pool->phy_addr_start);
c000284f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002852:	c1 e0 0c             	shl    $0xc,%eax
c0002855:	89 c2                	mov    %eax,%edx
c0002857:	8b 45 08             	mov    0x8(%ebp),%eax
c000285a:	8b 40 08             	mov    0x8(%eax),%eax
c000285d:	01 d0                	add    %edx,%eax
c000285f:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:123
	return (void*)page_phyaddr;
c0002862:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/kernel/memory.c:124
}
c0002865:	c9                   	leave  
c0002866:	c3                   	ret    

c0002867 <page_table_add>:
page_table_add():
/work/x86_os_my/kernel/memory.c:127

/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */
static void page_table_add(void* _vaddr, void* _page_phyaddr) {
c0002867:	55                   	push   %ebp
c0002868:	89 e5                	mov    %esp,%ebp
c000286a:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:128
	uint32_t vaddr = (uint32_t)_vaddr, page_phyaddr = (uint32_t)_page_phyaddr;
c000286d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002870:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002873:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002876:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:129
	uint32_t* pde = pde_ptr(vaddr);	//变量pde是虚拟地址!!!
c0002879:	ff 75 f4             	pushl  -0xc(%ebp)
c000287c:	e8 76 ff ff ff       	call   c00027f7 <pde_ptr>
c0002881:	83 c4 04             	add    $0x4,%esp
c0002884:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:130
	uint32_t* pte = pte_ptr(vaddr);	//变量pte是虚拟地址!!!
c0002887:	ff 75 f4             	pushl  -0xc(%ebp)
c000288a:	e8 38 ff ff ff       	call   c00027c7 <pte_ptr>
c000288f:	83 c4 04             	add    $0x4,%esp
c0002892:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:138
	* pde页目录项 pte页表项
	* 执行*pte可能会访问到空的pde。所以确保pde创建完成后才能执行*pte，否则会引发page_fault。
	* 因此在*pde为0时，*pte只能出现在下面else语句块中的*pde后面。
	* *********************************************************/
	/* 先在页目录内判断目录项的P位，若为1,则表示该表已存在 */
	if (*pde & 0x00000001) {			// 页目录项 存在
c0002895:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002898:	8b 00                	mov    (%eax),%eax
c000289a:	83 e0 01             	and    $0x1,%eax
c000289d:	85 c0                	test   %eax,%eax
c000289f:	74 64                	je     c0002905 <page_table_add+0x9e>
/work/x86_os_my/kernel/memory.c:139
		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
c00028a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00028a4:	8b 00                	mov    (%eax),%eax
c00028a6:	83 e0 01             	and    $0x1,%eax
c00028a9:	85 c0                	test   %eax,%eax
c00028ab:	74 1c                	je     c00028c9 <page_table_add+0x62>
/work/x86_os_my/kernel/memory.c:139 (discriminator 1)
c00028ad:	68 17 4e 00 c0       	push   $0xc0004e17
c00028b2:	68 88 4f 00 c0       	push   $0xc0004f88
c00028b7:	68 8b 00 00 00       	push   $0x8b
c00028bc:	68 07 4e 00 c0       	push   $0xc0004e07
c00028c1:	e8 cc fa ff ff       	call   c0002392 <panic_spin>
c00028c6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:141

		if (!(*pte & 0x00000001)) {		// 页表项pte不存在，创建PTE
c00028c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00028cc:	8b 00                	mov    (%eax),%eax
c00028ce:	83 e0 01             	and    $0x1,%eax
c00028d1:	85 c0                	test   %eax,%eax
c00028d3:	75 12                	jne    c00028e7 <page_table_add+0x80>
/work/x86_os_my/kernel/memory.c:142
			*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);		// 物理地址 | US=1,RW=1,P=1
c00028d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00028d8:	83 c8 07             	or     $0x7,%eax
c00028db:	89 c2                	mov    %eax,%edx
c00028dd:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00028e0:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:162
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
	}
}
c00028e2:	e9 8e 00 00 00       	jmp    c0002975 <page_table_add+0x10e>
/work/x86_os_my/kernel/memory.c:144
		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic

		if (!(*pte & 0x00000001)) {		// 页表项pte不存在，创建PTE
			*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);		// 物理地址 | US=1,RW=1,P=1
		} else {						// 不会执行到这，因为上面的ASSERT
			PANIC("pte repeat");
c00028e7:	68 2c 4e 00 c0       	push   $0xc0004e2c
c00028ec:	68 88 4f 00 c0       	push   $0xc0004f88
c00028f1:	68 90 00 00 00       	push   $0x90
c00028f6:	68 07 4e 00 c0       	push   $0xc0004e07
c00028fb:	e8 92 fa ff ff       	call   c0002392 <panic_spin>
c0002900:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:162
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
	}
}
c0002903:	eb 70                	jmp    c0002975 <page_table_add+0x10e>
/work/x86_os_my/kernel/memory.c:148
		} else {						// 不会执行到这，因为上面的ASSERT
			PANIC("pte repeat");
		}
	} else {							// 页目录项不存在，先创建页目录，再创建页表项
		/* 页表中用到的页一律从内核空间分配 */
		uint32_t pde_phyaddr = (uint32_t)palloc(&kernel_pool);
c0002905:	83 ec 0c             	sub    $0xc,%esp
c0002908:	68 c0 7a 00 c0       	push   $0xc0007ac0
c000290d:	e8 01 ff ff ff       	call   c0002813 <palloc>
c0002912:	83 c4 10             	add    $0x10,%esp
c0002915:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:149
		*pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 注意这行是pde_phyaddr，不是page_phyaddr!!!
c0002918:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000291b:	83 c8 07             	or     $0x7,%eax
c000291e:	89 c2                	mov    %eax,%edx
c0002920:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002923:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:157
		 * 访问物理地址 pde_phyaddr，需要找到它的虚拟地址！
		 * 只要用_vaddr的 PTE 取高20位即可。
		   搞得这么难理解，其实就是0xffc00000找到页目录表，然后加上vaddr的PDE在页目录表中的索引
		   (uint32_t*)(0xffc00000 + ((vaddr & 0xffc00000) >> 10))
		 */
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);
c0002925:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002928:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000292d:	83 ec 04             	sub    $0x4,%esp
c0002930:	68 00 10 00 00       	push   $0x1000
c0002935:	6a 00                	push   $0x0
c0002937:	50                   	push   %eax
c0002938:	e8 7d 05 00 00       	call   c0002eba <memset>
c000293d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:159

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
c0002940:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002943:	8b 00                	mov    (%eax),%eax
c0002945:	83 e0 01             	and    $0x1,%eax
c0002948:	85 c0                	test   %eax,%eax
c000294a:	74 1c                	je     c0002968 <page_table_add+0x101>
/work/x86_os_my/kernel/memory.c:159 (discriminator 1)
c000294c:	68 17 4e 00 c0       	push   $0xc0004e17
c0002951:	68 88 4f 00 c0       	push   $0xc0004f88
c0002956:	68 9f 00 00 00       	push   $0x9f
c000295b:	68 07 4e 00 c0       	push   $0xc0004e07
c0002960:	e8 2d fa ff ff       	call   c0002392 <panic_spin>
c0002965:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:160
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
c0002968:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000296b:	83 c8 07             	or     $0x7,%eax
c000296e:	89 c2                	mov    %eax,%edx
c0002970:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002973:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:162
	}
}
c0002975:	90                   	nop
c0002976:	c9                   	leave  
c0002977:	c3                   	ret    

c0002978 <malloc_page>:
malloc_page():
/work/x86_os_my/kernel/memory.c:165

/* 分配pg_cnt个页空间,成功则返回起始虚拟地址,失败时返回NULL */
void* malloc_page(enum pool_flags pf, uint32_t pg_cnt) {
c0002978:	55                   	push   %ebp
c0002979:	89 e5                	mov    %esp,%ebp
c000297b:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:166
	ASSERT(pg_cnt > 0 && pg_cnt < 3840);
c000297e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002982:	74 09                	je     c000298d <malloc_page+0x15>
/work/x86_os_my/kernel/memory.c:166 (discriminator 1)
c0002984:	81 7d 0c ff 0e 00 00 	cmpl   $0xeff,0xc(%ebp)
c000298b:	76 1c                	jbe    c00029a9 <malloc_page+0x31>
/work/x86_os_my/kernel/memory.c:166 (discriminator 3)
c000298d:	68 37 4e 00 c0       	push   $0xc0004e37
c0002992:	68 98 4f 00 c0       	push   $0xc0004f98
c0002997:	68 a6 00 00 00       	push   $0xa6
c000299c:	68 07 4e 00 c0       	push   $0xc0004e07
c00029a1:	e8 ec f9 ff ff       	call   c0002392 <panic_spin>
c00029a6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:172
	/***********   malloc_page的原理是三个动作的合成:   ***********
		1 通过vaddr_get在虚拟内存池中申请虚拟地址
		2 通过palloc在物理内存池中申请物理页
		3 通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射
	***************************************************************/
	void* vaddr_start = vaddr_get(pf, pg_cnt);
c00029a9:	83 ec 08             	sub    $0x8,%esp
c00029ac:	ff 75 0c             	pushl  0xc(%ebp)
c00029af:	ff 75 08             	pushl  0x8(%ebp)
c00029b2:	e8 fa fc ff ff       	call   c00026b1 <vaddr_get>
c00029b7:	83 c4 10             	add    $0x10,%esp
c00029ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:173
	if (vaddr_start == NULL) {
c00029bd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00029c1:	75 07                	jne    c00029ca <malloc_page+0x52>
/work/x86_os_my/kernel/memory.c:174
		return NULL;
c00029c3:	b8 00 00 00 00       	mov    $0x0,%eax
c00029c8:	eb 6e                	jmp    c0002a38 <malloc_page+0xc0>
/work/x86_os_my/kernel/memory.c:177
	}

	uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
c00029ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00029cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00029d0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00029d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:178
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c00029d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00029d9:	83 e0 01             	and    $0x1,%eax
c00029dc:	85 c0                	test   %eax,%eax
c00029de:	74 07                	je     c00029e7 <malloc_page+0x6f>
/work/x86_os_my/kernel/memory.c:178 (discriminator 1)
c00029e0:	b8 c0 7a 00 c0       	mov    $0xc0007ac0,%eax
c00029e5:	eb 05                	jmp    c00029ec <malloc_page+0x74>
/work/x86_os_my/kernel/memory.c:178 (discriminator 2)
c00029e7:	b8 80 7a 00 c0       	mov    $0xc0007a80,%eax
/work/x86_os_my/kernel/memory.c:178 (discriminator 4)
c00029ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:181 (discriminator 4)

	/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
	while (cnt-- > 0) {
c00029ef:	eb 37                	jmp    c0002a28 <malloc_page+0xb0>
/work/x86_os_my/kernel/memory.c:182
		void* page_phyaddr = palloc(mem_pool);
c00029f1:	83 ec 0c             	sub    $0xc,%esp
c00029f4:	ff 75 e8             	pushl  -0x18(%ebp)
c00029f7:	e8 17 fe ff ff       	call   c0002813 <palloc>
c00029fc:	83 c4 10             	add    $0x10,%esp
c00029ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:183
		if (page_phyaddr == NULL) {  // 失败时要将曾经已申请的虚拟地址和物理页全部回滚，在将来完成内存回收时再补充
c0002a02:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0002a06:	75 07                	jne    c0002a0f <malloc_page+0x97>
/work/x86_os_my/kernel/memory.c:184
			return NULL;
c0002a08:	b8 00 00 00 00       	mov    $0x0,%eax
c0002a0d:	eb 29                	jmp    c0002a38 <malloc_page+0xc0>
/work/x86_os_my/kernel/memory.c:186
		}
		page_table_add((void*)vaddr, page_phyaddr); // 在页表中做映射 
c0002a0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002a12:	83 ec 08             	sub    $0x8,%esp
c0002a15:	ff 75 e4             	pushl  -0x1c(%ebp)
c0002a18:	50                   	push   %eax
c0002a19:	e8 49 fe ff ff       	call   c0002867 <page_table_add>
c0002a1e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:187
		vaddr += PG_SIZE;		 // 下一个虚拟页
c0002a21:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:181

	uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;

	/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
	while (cnt-- > 0) {
c0002a28:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002a2b:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002a2e:	89 55 f0             	mov    %edx,-0x10(%ebp)
c0002a31:	85 c0                	test   %eax,%eax
c0002a33:	75 bc                	jne    c00029f1 <malloc_page+0x79>
/work/x86_os_my/kernel/memory.c:189
			return NULL;
		}
		page_table_add((void*)vaddr, page_phyaddr); // 在页表中做映射 
		vaddr += PG_SIZE;		 // 下一个虚拟页
	}
	return vaddr_start;
c0002a35:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/kernel/memory.c:190
}
c0002a38:	c9                   	leave  
c0002a39:	c3                   	ret    

c0002a3a <get_kernel_pages>:
get_kernel_pages():
/work/x86_os_my/kernel/memory.c:193

/* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */
void* get_kernel_pages(uint32_t pg_cnt) {
c0002a3a:	55                   	push   %ebp
c0002a3b:	89 e5                	mov    %esp,%ebp
c0002a3d:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:194
	lock_acquire(&kernel_pool.lock);
c0002a40:	83 ec 0c             	sub    $0xc,%esp
c0002a43:	68 d0 7a 00 c0       	push   $0xc0007ad0
c0002a48:	e8 c2 12 00 00       	call   c0003d0f <lock_acquire>
c0002a4d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:195
	void* vaddr =  malloc_page(PF_KERNEL, pg_cnt);
c0002a50:	83 ec 08             	sub    $0x8,%esp
c0002a53:	ff 75 08             	pushl  0x8(%ebp)
c0002a56:	6a 01                	push   $0x1
c0002a58:	e8 1b ff ff ff       	call   c0002978 <malloc_page>
c0002a5d:	83 c4 10             	add    $0x10,%esp
c0002a60:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:196
	if (vaddr != NULL) {
c0002a63:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002a67:	74 17                	je     c0002a80 <get_kernel_pages+0x46>
/work/x86_os_my/kernel/memory.c:197
		memset(vaddr, 0, pg_cnt * PG_SIZE);
c0002a69:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a6c:	c1 e0 0c             	shl    $0xc,%eax
c0002a6f:	83 ec 04             	sub    $0x4,%esp
c0002a72:	50                   	push   %eax
c0002a73:	6a 00                	push   $0x0
c0002a75:	ff 75 f4             	pushl  -0xc(%ebp)
c0002a78:	e8 3d 04 00 00       	call   c0002eba <memset>
c0002a7d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:199
	}
	lock_release(&kernel_pool.lock);
c0002a80:	83 ec 0c             	sub    $0xc,%esp
c0002a83:	68 d0 7a 00 c0       	push   $0xc0007ad0
c0002a88:	e8 f9 12 00 00       	call   c0003d86 <lock_release>
c0002a8d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:200
	return vaddr;
c0002a90:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:201
}
c0002a93:	c9                   	leave  
c0002a94:	c3                   	ret    

c0002a95 <get_user_pages>:
get_user_pages():
/work/x86_os_my/kernel/memory.c:204

/* 在用户空间中申请4k内存,并返回其虚拟地址 */
void* get_user_pages(uint32_t pg_cnt) {
c0002a95:	55                   	push   %ebp
c0002a96:	89 e5                	mov    %esp,%ebp
c0002a98:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:205
	lock_acquire(&user_pool.lock);
c0002a9b:	83 ec 0c             	sub    $0xc,%esp
c0002a9e:	68 90 7a 00 c0       	push   $0xc0007a90
c0002aa3:	e8 67 12 00 00       	call   c0003d0f <lock_acquire>
c0002aa8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:206
	void* vaddr = malloc_page(PF_USER, pg_cnt);
c0002aab:	83 ec 08             	sub    $0x8,%esp
c0002aae:	ff 75 08             	pushl  0x8(%ebp)
c0002ab1:	6a 02                	push   $0x2
c0002ab3:	e8 c0 fe ff ff       	call   c0002978 <malloc_page>
c0002ab8:	83 c4 10             	add    $0x10,%esp
c0002abb:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:207
	if (vaddr != NULL) {
c0002abe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002ac2:	74 17                	je     c0002adb <get_user_pages+0x46>
/work/x86_os_my/kernel/memory.c:208
		memset(vaddr, 0, pg_cnt * PG_SIZE);
c0002ac4:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ac7:	c1 e0 0c             	shl    $0xc,%eax
c0002aca:	83 ec 04             	sub    $0x4,%esp
c0002acd:	50                   	push   %eax
c0002ace:	6a 00                	push   $0x0
c0002ad0:	ff 75 f4             	pushl  -0xc(%ebp)
c0002ad3:	e8 e2 03 00 00       	call   c0002eba <memset>
c0002ad8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:210
	}
	lock_release(&user_pool.lock);
c0002adb:	83 ec 0c             	sub    $0xc,%esp
c0002ade:	68 90 7a 00 c0       	push   $0xc0007a90
c0002ae3:	e8 9e 12 00 00       	call   c0003d86 <lock_release>
c0002ae8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:211
	return vaddr;
c0002aeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:212
}
c0002aee:	c9                   	leave  
c0002aef:	c3                   	ret    

c0002af0 <get_a_page>:
get_a_page():
/work/x86_os_my/kernel/memory.c:216

/* 将虚拟地址vaddr与pf池中的物理地址关联,仅支持一页空间分配
 * 功能是，可以指定虚拟地址的内存分配 */
void* get_a_page(enum pool_flags pf, uint32_t vaddr) {
c0002af0:	55                   	push   %ebp
c0002af1:	89 e5                	mov    %esp,%ebp
c0002af3:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:217
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c0002af6:	8b 45 08             	mov    0x8(%ebp),%eax
c0002af9:	83 e0 01             	and    $0x1,%eax
c0002afc:	85 c0                	test   %eax,%eax
c0002afe:	74 07                	je     c0002b07 <get_a_page+0x17>
/work/x86_os_my/kernel/memory.c:217 (discriminator 1)
c0002b00:	b8 c0 7a 00 c0       	mov    $0xc0007ac0,%eax
c0002b05:	eb 05                	jmp    c0002b0c <get_a_page+0x1c>
/work/x86_os_my/kernel/memory.c:217 (discriminator 2)
c0002b07:	b8 80 7a 00 c0       	mov    $0xc0007a80,%eax
/work/x86_os_my/kernel/memory.c:217 (discriminator 4)
c0002b0c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:218 (discriminator 4)
	lock_acquire(&mem_pool->lock);
c0002b0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002b12:	83 c0 10             	add    $0x10,%eax
c0002b15:	83 ec 0c             	sub    $0xc,%esp
c0002b18:	50                   	push   %eax
c0002b19:	e8 f1 11 00 00       	call   c0003d0f <lock_acquire>
c0002b1e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:221 (discriminator 4)

	/* 先将虚拟地址对应的位图置1 */
	struct task_struct* cur = running_thread();
c0002b21:	e8 64 07 00 00       	call   c000328a <running_thread>
c0002b26:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:222 (discriminator 4)
	int32_t bit_idx = -1;
c0002b29:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:224 (discriminator 4)

	if (cur->pgdir != NULL && pf == PF_USER) {
c0002b30:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002b33:	8b 40 34             	mov    0x34(%eax),%eax
c0002b36:	85 c0                	test   %eax,%eax
c0002b38:	74 55                	je     c0002b8f <get_a_page+0x9f>
/work/x86_os_my/kernel/memory.c:224 (discriminator 1)
c0002b3a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0002b3e:	75 4f                	jne    c0002b8f <get_a_page+0x9f>
/work/x86_os_my/kernel/memory.c:226
		/* 若当前是用户进程申请用户内存,就修改用户进程自己的虚拟地址池的 位图 */
		bit_idx = (vaddr - cur->userprog_vaddr.vaddr_start) / PG_SIZE;
c0002b40:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002b43:	8b 40 40             	mov    0x40(%eax),%eax
c0002b46:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002b49:	29 c2                	sub    %eax,%edx
c0002b4b:	89 d0                	mov    %edx,%eax
c0002b4d:	c1 e8 0c             	shr    $0xc,%eax
c0002b50:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:227
		ASSERT(bit_idx > 0);
c0002b53:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002b57:	7f 1c                	jg     c0002b75 <get_a_page+0x85>
/work/x86_os_my/kernel/memory.c:227 (discriminator 1)
c0002b59:	68 53 4e 00 c0       	push   $0xc0004e53
c0002b5e:	68 a4 4f 00 c0       	push   $0xc0004fa4
c0002b63:	68 e3 00 00 00       	push   $0xe3
c0002b68:	68 07 4e 00 c0       	push   $0xc0004e07
c0002b6d:	e8 20 f8 ff ff       	call   c0002392 <panic_spin>
c0002b72:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:228
		bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx, 1);
c0002b75:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002b78:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002b7b:	83 c2 38             	add    $0x38,%edx
c0002b7e:	83 ec 04             	sub    $0x4,%esp
c0002b81:	6a 01                	push   $0x1
c0002b83:	50                   	push   %eax
c0002b84:	52                   	push   %edx
c0002b85:	e8 76 fa ff ff       	call   c0002600 <bitmap_set>
c0002b8a:	83 c4 10             	add    $0x10,%esp
c0002b8d:	eb 78                	jmp    c0002c07 <get_a_page+0x117>
/work/x86_os_my/kernel/memory.c:230

	} else if (cur->pgdir == NULL && pf == PF_KERNEL) {
c0002b8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002b92:	8b 40 34             	mov    0x34(%eax),%eax
c0002b95:	85 c0                	test   %eax,%eax
c0002b97:	75 52                	jne    c0002beb <get_a_page+0xfb>
/work/x86_os_my/kernel/memory.c:230 (discriminator 1)
c0002b99:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0002b9d:	75 4c                	jne    c0002beb <get_a_page+0xfb>
/work/x86_os_my/kernel/memory.c:232
		/* 如果是内核线程申请内核内存,就修改 kernel_vaddr */
		bit_idx = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
c0002b9f:	a1 b4 7a 00 c0       	mov    0xc0007ab4,%eax
c0002ba4:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002ba7:	29 c2                	sub    %eax,%edx
c0002ba9:	89 d0                	mov    %edx,%eax
c0002bab:	c1 e8 0c             	shr    $0xc,%eax
c0002bae:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:233
		ASSERT(bit_idx > 0);
c0002bb1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002bb5:	7f 1c                	jg     c0002bd3 <get_a_page+0xe3>
/work/x86_os_my/kernel/memory.c:233 (discriminator 1)
c0002bb7:	68 53 4e 00 c0       	push   $0xc0004e53
c0002bbc:	68 a4 4f 00 c0       	push   $0xc0004fa4
c0002bc1:	68 e9 00 00 00       	push   $0xe9
c0002bc6:	68 07 4e 00 c0       	push   $0xc0004e07
c0002bcb:	e8 c2 f7 ff ff       	call   c0002392 <panic_spin>
c0002bd0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:234
		bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx, 1);
c0002bd3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002bd6:	83 ec 04             	sub    $0x4,%esp
c0002bd9:	6a 01                	push   $0x1
c0002bdb:	50                   	push   %eax
c0002bdc:	68 ac 7a 00 c0       	push   $0xc0007aac
c0002be1:	e8 1a fa ff ff       	call   c0002600 <bitmap_set>
c0002be6:	83 c4 10             	add    $0x10,%esp
c0002be9:	eb 1c                	jmp    c0002c07 <get_a_page+0x117>
/work/x86_os_my/kernel/memory.c:237

	} else {
		PANIC("get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page");
c0002beb:	68 60 4e 00 c0       	push   $0xc0004e60
c0002bf0:	68 a4 4f 00 c0       	push   $0xc0004fa4
c0002bf5:	68 ed 00 00 00       	push   $0xed
c0002bfa:	68 07 4e 00 c0       	push   $0xc0004e07
c0002bff:	e8 8e f7 ff ff       	call   c0002392 <panic_spin>
c0002c04:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:240
	}

	void* page_phyaddr = palloc(mem_pool);
c0002c07:	83 ec 0c             	sub    $0xc,%esp
c0002c0a:	ff 75 f4             	pushl  -0xc(%ebp)
c0002c0d:	e8 01 fc ff ff       	call   c0002813 <palloc>
c0002c12:	83 c4 10             	add    $0x10,%esp
c0002c15:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:241
	if (page_phyaddr == NULL) {
c0002c18:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0002c1c:	75 07                	jne    c0002c25 <get_a_page+0x135>
/work/x86_os_my/kernel/memory.c:242
		return NULL;
c0002c1e:	b8 00 00 00 00       	mov    $0x0,%eax
c0002c23:	eb 27                	jmp    c0002c4c <get_a_page+0x15c>
/work/x86_os_my/kernel/memory.c:244
	}
	page_table_add((void*)vaddr, page_phyaddr);
c0002c25:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002c28:	83 ec 08             	sub    $0x8,%esp
c0002c2b:	ff 75 e8             	pushl  -0x18(%ebp)
c0002c2e:	50                   	push   %eax
c0002c2f:	e8 33 fc ff ff       	call   c0002867 <page_table_add>
c0002c34:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:246
	
	lock_release(&mem_pool->lock);
c0002c37:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002c3a:	83 c0 10             	add    $0x10,%eax
c0002c3d:	83 ec 0c             	sub    $0xc,%esp
c0002c40:	50                   	push   %eax
c0002c41:	e8 40 11 00 00       	call   c0003d86 <lock_release>
c0002c46:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:247
	return (void*)vaddr;
c0002c49:	8b 45 0c             	mov    0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:248
}
c0002c4c:	c9                   	leave  
c0002c4d:	c3                   	ret    

c0002c4e <addr_v2p>:
addr_v2p():
/work/x86_os_my/kernel/memory.c:251

/* 得到虚拟地址映射到的物理地址 */
uint32_t addr_v2p(uint32_t vaddr) {
c0002c4e:	55                   	push   %ebp
c0002c4f:	89 e5                	mov    %esp,%ebp
c0002c51:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:252
	uint32_t* pte = pte_ptr(vaddr);
c0002c54:	ff 75 08             	pushl  0x8(%ebp)
c0002c57:	e8 6b fb ff ff       	call   c00027c7 <pte_ptr>
c0002c5c:	83 c4 04             	add    $0x4,%esp
c0002c5f:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:256
	/* (*pte)的内容是 vaddr 所在 pte 的内容，也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的页表项属性，
	 * 因为页框都是自然页，低 12 位地址是 0，所以页表项 pte（和页目录项 pde）中只需要记录页框的高 20 位地址即可。
	 */
	return ((*pte & 0xfffff000) + (vaddr & 0x00000fff));
c0002c62:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002c65:	8b 00                	mov    (%eax),%eax
c0002c67:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002c6c:	89 c2                	mov    %eax,%edx
c0002c6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c71:	25 ff 0f 00 00       	and    $0xfff,%eax
c0002c76:	01 d0                	add    %edx,%eax
/work/x86_os_my/kernel/memory.c:257
}
c0002c78:	c9                   	leave  
c0002c79:	c3                   	ret    

c0002c7a <mem_pool_init>:
mem_pool_init():
/work/x86_os_my/kernel/memory.c:260

/* 初始化内存池 */
static void mem_pool_init(uint32_t all_mem) {
c0002c7a:	55                   	push   %ebp
c0002c7b:	89 e5                	mov    %esp,%ebp
c0002c7d:	83 ec 38             	sub    $0x38,%esp
/work/x86_os_my/kernel/memory.c:261
	put_str("   mem_pool_init start\n");
c0002c80:	83 ec 0c             	sub    $0xc,%esp
c0002c83:	68 b4 4e 00 c0       	push   $0xc0004eb4
c0002c88:	e8 93 f5 ff ff       	call   c0002220 <put_str>
c0002c8d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:262
	uint32_t page_table_size = PG_SIZE * 256;		// 页表大小= 1页的页目录表+第0和第768个页目录项指向同一个页表+
c0002c90:	c7 45 f4 00 00 10 00 	movl   $0x100000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:264
													// 第769~1022个页目录项共指向254个页表,共256个页框
	uint32_t used_mem = page_table_size + 0x100000;	// 0x100000为低端1M内存
c0002c97:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002c9a:	05 00 00 10 00       	add    $0x100000,%eax
c0002c9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:265
	uint32_t free_mem = all_mem - used_mem;
c0002ca2:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ca5:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0002ca8:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:266
	uint16_t all_free_pages = free_mem / PG_SIZE;	// 1页为4k,不管总内存是不是4k的倍数,
c0002cab:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002cae:	c1 e8 0c             	shr    $0xc,%eax
c0002cb1:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
/work/x86_os_my/kernel/memory.c:268
													// 对于以页为单位的内存分配策略，不足1页的内存不用考虑了。
	uint16_t kernel_free_pages = all_free_pages / 2;
c0002cb5:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c0002cb9:	66 d1 e8             	shr    %ax
c0002cbc:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:269
	uint16_t user_free_pages = all_free_pages - kernel_free_pages;
c0002cc0:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c0002cc4:	66 2b 45 e8          	sub    -0x18(%ebp),%ax
c0002cc8:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
/work/x86_os_my/kernel/memory.c:273

	/* 为简化位图操作，余数不处理，坏处是这样做会丢内存。
	好处是不用做内存的越界检查,因为位图表示的内存少于实际物理内存*/
	uint32_t kbm_length = kernel_free_pages / 8;	// Kernel BitMap的长度,位图中的一位表示一页,以字节为单位
c0002ccc:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0002cd0:	66 c1 e8 03          	shr    $0x3,%ax
c0002cd4:	0f b7 c0             	movzwl %ax,%eax
c0002cd7:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/kernel/memory.c:274
	uint32_t ubm_length = user_free_pages / 8;		// User BitMap的长度.
c0002cda:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c0002cde:	66 c1 e8 03          	shr    $0x3,%ax
c0002ce2:	0f b7 c0             	movzwl %ax,%eax
c0002ce5:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/kernel/memory.c:276

	uint32_t kp_start = used_mem;								// Kernel Pool start,内核内存池的起始地址
c0002ce8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002ceb:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/kernel/memory.c:277
	uint32_t up_start = kp_start + kernel_free_pages * PG_SIZE;	// User Pool start,用户内存池的起始地址
c0002cee:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0002cf2:	c1 e0 0c             	shl    $0xc,%eax
c0002cf5:	89 c2                	mov    %eax,%edx
c0002cf7:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0002cfa:	01 d0                	add    %edx,%eax
c0002cfc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:279

	kernel_pool.phy_addr_start = kp_start;
c0002cff:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0002d02:	a3 c8 7a 00 c0       	mov    %eax,0xc0007ac8
/work/x86_os_my/kernel/memory.c:280
	user_pool.phy_addr_start   = up_start;
c0002d07:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002d0a:	a3 88 7a 00 c0       	mov    %eax,0xc0007a88
/work/x86_os_my/kernel/memory.c:282

	kernel_pool.pool_size = kernel_free_pages * PG_SIZE;
c0002d0f:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0002d13:	c1 e0 0c             	shl    $0xc,%eax
c0002d16:	a3 cc 7a 00 c0       	mov    %eax,0xc0007acc
/work/x86_os_my/kernel/memory.c:283
	user_pool.pool_size	 = user_free_pages * PG_SIZE;
c0002d1b:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c0002d1f:	c1 e0 0c             	shl    $0xc,%eax
c0002d22:	a3 8c 7a 00 c0       	mov    %eax,0xc0007a8c
/work/x86_os_my/kernel/memory.c:285

	kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;
c0002d27:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002d2a:	a3 c0 7a 00 c0       	mov    %eax,0xc0007ac0
/work/x86_os_my/kernel/memory.c:286
	user_pool.pool_bitmap.btmp_bytes_len	  = ubm_length;
c0002d2f:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0002d32:	a3 80 7a 00 c0       	mov    %eax,0xc0007a80
/work/x86_os_my/kernel/memory.c:295
	*	而我们需要根据总内存大小在运行时，计算出位图的数组需要多少字节。
	*   所以改为指定一块内存来生成位图.
	*   ************************************************/
	// 内核使用的最高地址是0xc009f000,这是主线程的栈地址.(内核的大小预计为70K左右)
	// 32M内存占用的位图是2k.内核内存池的位图先定在MEM_BITMAP_BASE(0xc009a000)处.
	kernel_pool.pool_bitmap.bits = (void*)MEM_BITMAP_BASE;
c0002d37:	c7 05 c4 7a 00 c0 00 	movl   $0xc009a000,0xc0007ac4
c0002d3e:	a0 09 c0 
/work/x86_os_my/kernel/memory.c:297
	/* 用户内存池的位图紧跟在内核内存池位图之后 */
	user_pool.pool_bitmap.bits = (void*)(MEM_BITMAP_BASE + kbm_length);
c0002d41:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002d44:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c0002d49:	a3 84 7a 00 c0       	mov    %eax,0xc0007a84
/work/x86_os_my/kernel/memory.c:300
	
	/******************** 输出内存池信息 **********************/
	put_str("      kernel_pool_bitmap_start:");put_int((int)kernel_pool.pool_bitmap.bits);
c0002d4e:	83 ec 0c             	sub    $0xc,%esp
c0002d51:	68 cc 4e 00 c0       	push   $0xc0004ecc
c0002d56:	e8 c5 f4 ff ff       	call   c0002220 <put_str>
c0002d5b:	83 c4 10             	add    $0x10,%esp
c0002d5e:	a1 c4 7a 00 c0       	mov    0xc0007ac4,%eax
c0002d63:	83 ec 0c             	sub    $0xc,%esp
c0002d66:	50                   	push   %eax
c0002d67:	e8 9f f5 ff ff       	call   c000230b <put_int>
c0002d6c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:301
	put_str(" kernel_pool_phy_addr_start:");put_int(kernel_pool.phy_addr_start);
c0002d6f:	83 ec 0c             	sub    $0xc,%esp
c0002d72:	68 ec 4e 00 c0       	push   $0xc0004eec
c0002d77:	e8 a4 f4 ff ff       	call   c0002220 <put_str>
c0002d7c:	83 c4 10             	add    $0x10,%esp
c0002d7f:	a1 c8 7a 00 c0       	mov    0xc0007ac8,%eax
c0002d84:	83 ec 0c             	sub    $0xc,%esp
c0002d87:	50                   	push   %eax
c0002d88:	e8 7e f5 ff ff       	call   c000230b <put_int>
c0002d8d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:302
	put_str("\n");
c0002d90:	83 ec 0c             	sub    $0xc,%esp
c0002d93:	68 09 4f 00 c0       	push   $0xc0004f09
c0002d98:	e8 83 f4 ff ff       	call   c0002220 <put_str>
c0002d9d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:303
	put_str("      user_pool_bitmap_start:");put_int((int)user_pool.pool_bitmap.bits);
c0002da0:	83 ec 0c             	sub    $0xc,%esp
c0002da3:	68 0b 4f 00 c0       	push   $0xc0004f0b
c0002da8:	e8 73 f4 ff ff       	call   c0002220 <put_str>
c0002dad:	83 c4 10             	add    $0x10,%esp
c0002db0:	a1 84 7a 00 c0       	mov    0xc0007a84,%eax
c0002db5:	83 ec 0c             	sub    $0xc,%esp
c0002db8:	50                   	push   %eax
c0002db9:	e8 4d f5 ff ff       	call   c000230b <put_int>
c0002dbe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:304
	put_str(" user_pool_phy_addr_start:");put_int(user_pool.phy_addr_start);
c0002dc1:	83 ec 0c             	sub    $0xc,%esp
c0002dc4:	68 29 4f 00 c0       	push   $0xc0004f29
c0002dc9:	e8 52 f4 ff ff       	call   c0002220 <put_str>
c0002dce:	83 c4 10             	add    $0x10,%esp
c0002dd1:	a1 88 7a 00 c0       	mov    0xc0007a88,%eax
c0002dd6:	83 ec 0c             	sub    $0xc,%esp
c0002dd9:	50                   	push   %eax
c0002dda:	e8 2c f5 ff ff       	call   c000230b <put_int>
c0002ddf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:305
	put_str("\n");
c0002de2:	83 ec 0c             	sub    $0xc,%esp
c0002de5:	68 09 4f 00 c0       	push   $0xc0004f09
c0002dea:	e8 31 f4 ff ff       	call   c0002220 <put_str>
c0002def:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:308

	/* 将位图置0*/
	bitmap_init(&kernel_pool.pool_bitmap);
c0002df2:	83 ec 0c             	sub    $0xc,%esp
c0002df5:	68 c0 7a 00 c0       	push   $0xc0007ac0
c0002dfa:	e8 69 f6 ff ff       	call   c0002468 <bitmap_init>
c0002dff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:309
	bitmap_init(&user_pool.pool_bitmap);
c0002e02:	83 ec 0c             	sub    $0xc,%esp
c0002e05:	68 80 7a 00 c0       	push   $0xc0007a80
c0002e0a:	e8 59 f6 ff ff       	call   c0002468 <bitmap_init>
c0002e0f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:311

	lock_init(&kernel_pool.lock);
c0002e12:	83 ec 0c             	sub    $0xc,%esp
c0002e15:	68 d0 7a 00 c0       	push   $0xc0007ad0
c0002e1a:	e8 16 0d 00 00       	call   c0003b35 <lock_init>
c0002e1f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:312
	lock_init(&user_pool.lock);
c0002e22:	83 ec 0c             	sub    $0xc,%esp
c0002e25:	68 90 7a 00 c0       	push   $0xc0007a90
c0002e2a:	e8 06 0d 00 00       	call   c0003b35 <lock_init>
c0002e2f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:316
	
	/* 下面初始化内核虚拟地址的位图(bp_len + bits数组),按实际物理内存大小生成数组。*/
	// 用于维护内核堆的虚拟地址,所以要和内核内存池大小一致
	kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;
c0002e32:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002e35:	a3 ac 7a 00 c0       	mov    %eax,0xc0007aac
/work/x86_os_my/kernel/memory.c:318
	/* 位图的数组指向一块未使用的内存,目前定位在内核内存池和用户内存池之外*/
	kernel_vaddr.vaddr_bitmap.bits = (void*)(MEM_BITMAP_BASE + kbm_length + ubm_length);
c0002e3a:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0002e3d:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0002e40:	01 d0                	add    %edx,%eax
c0002e42:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c0002e47:	a3 b0 7a 00 c0       	mov    %eax,0xc0007ab0
/work/x86_os_my/kernel/memory.c:320

	kernel_vaddr.vaddr_start = K_HEAP_START;
c0002e4c:	c7 05 b4 7a 00 c0 00 	movl   $0xc0100000,0xc0007ab4
c0002e53:	00 10 c0 
/work/x86_os_my/kernel/memory.c:321
	bitmap_init(&kernel_vaddr.vaddr_bitmap);
c0002e56:	83 ec 0c             	sub    $0xc,%esp
c0002e59:	68 ac 7a 00 c0       	push   $0xc0007aac
c0002e5e:	e8 05 f6 ff ff       	call   c0002468 <bitmap_init>
c0002e63:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:322
	put_str("   mem_pool_init done\n");
c0002e66:	83 ec 0c             	sub    $0xc,%esp
c0002e69:	68 44 4f 00 c0       	push   $0xc0004f44
c0002e6e:	e8 ad f3 ff ff       	call   c0002220 <put_str>
c0002e73:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:323
}
c0002e76:	90                   	nop
c0002e77:	c9                   	leave  
c0002e78:	c3                   	ret    

c0002e79 <mem_init>:
mem_init():
/work/x86_os_my/kernel/memory.c:326

/* 内存管理部分初始化入口 */
void mem_init() {
c0002e79:	55                   	push   %ebp
c0002e7a:	89 e5                	mov    %esp,%ebp
c0002e7c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:327
	put_str("mem_init start\n");
c0002e7f:	83 ec 0c             	sub    $0xc,%esp
c0002e82:	68 5b 4f 00 c0       	push   $0xc0004f5b
c0002e87:	e8 94 f3 ff ff       	call   c0002220 <put_str>
c0002e8c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:328
	uint32_t mem_bytes_total = (*(uint32_t*)(0xb00));	//内存总数在汇编中获取，放到了地址0xb00处。
c0002e8f:	b8 00 0b 00 00       	mov    $0xb00,%eax
c0002e94:	8b 00                	mov    (%eax),%eax
c0002e96:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:329
	mem_pool_init(mem_bytes_total);	  // 初始化内存池
c0002e99:	83 ec 0c             	sub    $0xc,%esp
c0002e9c:	ff 75 f4             	pushl  -0xc(%ebp)
c0002e9f:	e8 d6 fd ff ff       	call   c0002c7a <mem_pool_init>
c0002ea4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:330
	put_str("mem_init done\n");
c0002ea7:	83 ec 0c             	sub    $0xc,%esp
c0002eaa:	68 6b 4f 00 c0       	push   $0xc0004f6b
c0002eaf:	e8 6c f3 ff ff       	call   c0002220 <put_str>
c0002eb4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:331
}
c0002eb7:	90                   	nop
c0002eb8:	c9                   	leave  
c0002eb9:	c3                   	ret    

c0002eba <memset>:
memset():
/work/x86_os_my/lib/string.c:6
#include "string.h"
#include "global.h"
#include "debug.h"

/* 将dst_起始的size个字节置为value */
void memset(void* dst_, uint8_t value, uint32_t size) {
c0002eba:	55                   	push   %ebp
c0002ebb:	89 e5                	mov    %esp,%ebp
c0002ebd:	83 ec 28             	sub    $0x28,%esp
c0002ec0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002ec3:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:7
   ASSERT(dst_ != NULL);
c0002ec6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002eca:	75 19                	jne    c0002ee5 <memset+0x2b>
/work/x86_os_my/lib/string.c:7 (discriminator 1)
c0002ecc:	68 b0 4f 00 c0       	push   $0xc0004fb0
c0002ed1:	68 24 50 00 c0       	push   $0xc0005024
c0002ed6:	6a 07                	push   $0x7
c0002ed8:	68 bd 4f 00 c0       	push   $0xc0004fbd
c0002edd:	e8 b0 f4 ff ff       	call   c0002392 <panic_spin>
c0002ee2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:8
   uint8_t* dst = (uint8_t*)dst_;
c0002ee5:	8b 45 08             	mov    0x8(%ebp),%eax
c0002ee8:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:9
   while (size-- > 0)
c0002eeb:	eb 0f                	jmp    c0002efc <memset+0x42>
/work/x86_os_my/lib/string.c:10
      *dst++ = value;
c0002eed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002ef0:	8d 50 01             	lea    0x1(%eax),%edx
c0002ef3:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0002ef6:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c0002efa:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/string.c:9

/* 将dst_起始的size个字节置为value */
void memset(void* dst_, uint8_t value, uint32_t size) {
   ASSERT(dst_ != NULL);
   uint8_t* dst = (uint8_t*)dst_;
   while (size-- > 0)
c0002efc:	8b 45 10             	mov    0x10(%ebp),%eax
c0002eff:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002f02:	89 55 10             	mov    %edx,0x10(%ebp)
c0002f05:	85 c0                	test   %eax,%eax
c0002f07:	75 e4                	jne    c0002eed <memset+0x33>
/work/x86_os_my/lib/string.c:11
      *dst++ = value;
}
c0002f09:	90                   	nop
c0002f0a:	c9                   	leave  
c0002f0b:	c3                   	ret    

c0002f0c <memcpy>:
memcpy():
/work/x86_os_my/lib/string.c:14

/* 将src_起始的size个字节复制到dst_ */
void memcpy(void* dst_, const void* src_, uint32_t size) {
c0002f0c:	55                   	push   %ebp
c0002f0d:	89 e5                	mov    %esp,%ebp
c0002f0f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:15
   ASSERT(dst_ != NULL && src_ != NULL);
c0002f12:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002f16:	74 06                	je     c0002f1e <memcpy+0x12>
/work/x86_os_my/lib/string.c:15 (discriminator 1)
c0002f18:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002f1c:	75 19                	jne    c0002f37 <memcpy+0x2b>
/work/x86_os_my/lib/string.c:15 (discriminator 3)
c0002f1e:	68 ca 4f 00 c0       	push   $0xc0004fca
c0002f23:	68 2c 50 00 c0       	push   $0xc000502c
c0002f28:	6a 0f                	push   $0xf
c0002f2a:	68 bd 4f 00 c0       	push   $0xc0004fbd
c0002f2f:	e8 5e f4 ff ff       	call   c0002392 <panic_spin>
c0002f34:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:16
   uint8_t* dst = dst_;
c0002f37:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:17
   const uint8_t* src = src_;
c0002f3d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002f40:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:18
   while (size-- > 0)
c0002f43:	eb 17                	jmp    c0002f5c <memcpy+0x50>
/work/x86_os_my/lib/string.c:19
      *dst++ = *src++;
c0002f45:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002f48:	8d 50 01             	lea    0x1(%eax),%edx
c0002f4b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0002f4e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002f51:	8d 4a 01             	lea    0x1(%edx),%ecx
c0002f54:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0002f57:	0f b6 12             	movzbl (%edx),%edx
c0002f5a:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/string.c:18
/* 将src_起始的size个字节复制到dst_ */
void memcpy(void* dst_, const void* src_, uint32_t size) {
   ASSERT(dst_ != NULL && src_ != NULL);
   uint8_t* dst = dst_;
   const uint8_t* src = src_;
   while (size-- > 0)
c0002f5c:	8b 45 10             	mov    0x10(%ebp),%eax
c0002f5f:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002f62:	89 55 10             	mov    %edx,0x10(%ebp)
c0002f65:	85 c0                	test   %eax,%eax
c0002f67:	75 dc                	jne    c0002f45 <memcpy+0x39>
/work/x86_os_my/lib/string.c:20
      *dst++ = *src++;
}
c0002f69:	90                   	nop
c0002f6a:	c9                   	leave  
c0002f6b:	c3                   	ret    

c0002f6c <memcmp>:
memcmp():
/work/x86_os_my/lib/string.c:23

/* 连续比较以地址a_和地址b_开头的size个字节,若相等则返回0,若a_大于b_返回+1,否则返回-1 */
int memcmp(const void* a_, const void* b_, uint32_t size) {
c0002f6c:	55                   	push   %ebp
c0002f6d:	89 e5                	mov    %esp,%ebp
c0002f6f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:24
   const char* a = a_;
c0002f72:	8b 45 08             	mov    0x8(%ebp),%eax
c0002f75:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:25
   const char* b = b_;
c0002f78:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002f7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:26
   ASSERT(a != NULL || b != NULL);
c0002f7e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002f82:	75 57                	jne    c0002fdb <memcmp+0x6f>
/work/x86_os_my/lib/string.c:26 (discriminator 1)
c0002f84:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0002f88:	75 51                	jne    c0002fdb <memcmp+0x6f>
/work/x86_os_my/lib/string.c:26 (discriminator 2)
c0002f8a:	68 e7 4f 00 c0       	push   $0xc0004fe7
c0002f8f:	68 34 50 00 c0       	push   $0xc0005034
c0002f94:	6a 1a                	push   $0x1a
c0002f96:	68 bd 4f 00 c0       	push   $0xc0004fbd
c0002f9b:	e8 f2 f3 ff ff       	call   c0002392 <panic_spin>
c0002fa0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:27 (discriminator 2)
   while (size-- > 0) {
c0002fa3:	eb 36                	jmp    c0002fdb <memcmp+0x6f>
/work/x86_os_my/lib/string.c:28
      if(*a != *b) {
c0002fa5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002fa8:	0f b6 10             	movzbl (%eax),%edx
c0002fab:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002fae:	0f b6 00             	movzbl (%eax),%eax
c0002fb1:	38 c2                	cmp    %al,%dl
c0002fb3:	74 1e                	je     c0002fd3 <memcmp+0x67>
/work/x86_os_my/lib/string.c:29
	 return *a > *b ? 1 : -1; 
c0002fb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002fb8:	0f b6 10             	movzbl (%eax),%edx
c0002fbb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002fbe:	0f b6 00             	movzbl (%eax),%eax
c0002fc1:	38 c2                	cmp    %al,%dl
c0002fc3:	7e 07                	jle    c0002fcc <memcmp+0x60>
/work/x86_os_my/lib/string.c:29 (discriminator 1)
c0002fc5:	b8 01 00 00 00       	mov    $0x1,%eax
c0002fca:	eb 21                	jmp    c0002fed <memcmp+0x81>
/work/x86_os_my/lib/string.c:29 (discriminator 2)
c0002fcc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0002fd1:	eb 1a                	jmp    c0002fed <memcmp+0x81>
/work/x86_os_my/lib/string.c:31
      }
      a++;
c0002fd3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:32
      b++;
c0002fd7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/string.c:27
/* 连续比较以地址a_和地址b_开头的size个字节,若相等则返回0,若a_大于b_返回+1,否则返回-1 */
int memcmp(const void* a_, const void* b_, uint32_t size) {
   const char* a = a_;
   const char* b = b_;
   ASSERT(a != NULL || b != NULL);
   while (size-- > 0) {
c0002fdb:	8b 45 10             	mov    0x10(%ebp),%eax
c0002fde:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002fe1:	89 55 10             	mov    %edx,0x10(%ebp)
c0002fe4:	85 c0                	test   %eax,%eax
c0002fe6:	75 bd                	jne    c0002fa5 <memcmp+0x39>
/work/x86_os_my/lib/string.c:34
	 return *a > *b ? 1 : -1; 
      }
      a++;
      b++;
   }
   return 0;
c0002fe8:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/string.c:35
}
c0002fed:	c9                   	leave  
c0002fee:	c3                   	ret    

c0002fef <strcpy>:
strcpy():
/work/x86_os_my/lib/string.c:38

/* 将字符串从src_复制到dst_ */
char* strcpy(char* dst_, const char* src_) {
c0002fef:	55                   	push   %ebp
c0002ff0:	89 e5                	mov    %esp,%ebp
c0002ff2:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:39
   ASSERT(dst_ != NULL && src_ != NULL);
c0002ff5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002ff9:	74 06                	je     c0003001 <strcpy+0x12>
/work/x86_os_my/lib/string.c:39 (discriminator 1)
c0002ffb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0002fff:	75 19                	jne    c000301a <strcpy+0x2b>
/work/x86_os_my/lib/string.c:39 (discriminator 3)
c0003001:	68 ca 4f 00 c0       	push   $0xc0004fca
c0003006:	68 3c 50 00 c0       	push   $0xc000503c
c000300b:	6a 27                	push   $0x27
c000300d:	68 bd 4f 00 c0       	push   $0xc0004fbd
c0003012:	e8 7b f3 ff ff       	call   c0002392 <panic_spin>
c0003017:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:40
   char* r = dst_;		       // 用来返回目的字符串起始地址
c000301a:	8b 45 08             	mov    0x8(%ebp),%eax
c000301d:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:41
   while((*dst_++ = *src_++));
c0003020:	90                   	nop
/work/x86_os_my/lib/string.c:41 (discriminator 1)
c0003021:	8b 45 08             	mov    0x8(%ebp),%eax
c0003024:	8d 50 01             	lea    0x1(%eax),%edx
c0003027:	89 55 08             	mov    %edx,0x8(%ebp)
c000302a:	8b 55 0c             	mov    0xc(%ebp),%edx
c000302d:	8d 4a 01             	lea    0x1(%edx),%ecx
c0003030:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c0003033:	0f b6 12             	movzbl (%edx),%edx
c0003036:	88 10                	mov    %dl,(%eax)
c0003038:	0f b6 00             	movzbl (%eax),%eax
c000303b:	84 c0                	test   %al,%al
c000303d:	75 e2                	jne    c0003021 <strcpy+0x32>
/work/x86_os_my/lib/string.c:42
   return r;
c000303f:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:43
}
c0003042:	c9                   	leave  
c0003043:	c3                   	ret    

c0003044 <strlen>:
strlen():
/work/x86_os_my/lib/string.c:46

/* 返回字符串长度 */
uint32_t strlen(const char* str) {
c0003044:	55                   	push   %ebp
c0003045:	89 e5                	mov    %esp,%ebp
c0003047:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:47
   ASSERT(str != NULL);
c000304a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000304e:	75 19                	jne    c0003069 <strlen+0x25>
/work/x86_os_my/lib/string.c:47 (discriminator 1)
c0003050:	68 fe 4f 00 c0       	push   $0xc0004ffe
c0003055:	68 44 50 00 c0       	push   $0xc0005044
c000305a:	6a 2f                	push   $0x2f
c000305c:	68 bd 4f 00 c0       	push   $0xc0004fbd
c0003061:	e8 2c f3 ff ff       	call   c0002392 <panic_spin>
c0003066:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:48
   const char* p = str;
c0003069:	8b 45 08             	mov    0x8(%ebp),%eax
c000306c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:49
   while(*p++);
c000306f:	90                   	nop
/work/x86_os_my/lib/string.c:49 (discriminator 1)
c0003070:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003073:	8d 50 01             	lea    0x1(%eax),%edx
c0003076:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003079:	0f b6 00             	movzbl (%eax),%eax
c000307c:	84 c0                	test   %al,%al
c000307e:	75 f0                	jne    c0003070 <strlen+0x2c>
/work/x86_os_my/lib/string.c:50
   return (p - str - 1);
c0003080:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0003083:	8b 45 08             	mov    0x8(%ebp),%eax
c0003086:	29 c2                	sub    %eax,%edx
c0003088:	89 d0                	mov    %edx,%eax
c000308a:	83 e8 01             	sub    $0x1,%eax
/work/x86_os_my/lib/string.c:51
}
c000308d:	c9                   	leave  
c000308e:	c3                   	ret    

c000308f <strcmp>:
strcmp():
/work/x86_os_my/lib/string.c:54

/* 比较两个字符串,若a_中的字符大于b_中的字符返回1,相等时返回0,否则返回-1. */
int8_t strcmp (const char* a, const char* b) {
c000308f:	55                   	push   %ebp
c0003090:	89 e5                	mov    %esp,%ebp
c0003092:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/string.c:55
   ASSERT(a != NULL && b != NULL);
c0003095:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003099:	74 06                	je     c00030a1 <strcmp+0x12>
/work/x86_os_my/lib/string.c:55 (discriminator 1)
c000309b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c000309f:	75 19                	jne    c00030ba <strcmp+0x2b>
/work/x86_os_my/lib/string.c:55 (discriminator 3)
c00030a1:	68 0a 50 00 c0       	push   $0xc000500a
c00030a6:	68 4c 50 00 c0       	push   $0xc000504c
c00030ab:	6a 37                	push   $0x37
c00030ad:	68 bd 4f 00 c0       	push   $0xc0004fbd
c00030b2:	e8 db f2 ff ff       	call   c0002392 <panic_spin>
c00030b7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:56 (discriminator 1)
   while (*a != 0 && *a == *b) {
c00030ba:	eb 08                	jmp    c00030c4 <strcmp+0x35>
/work/x86_os_my/lib/string.c:57
      a++;
c00030bc:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:58
      b++;
c00030c0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
/work/x86_os_my/lib/string.c:56
}

/* 比较两个字符串,若a_中的字符大于b_中的字符返回1,相等时返回0,否则返回-1. */
int8_t strcmp (const char* a, const char* b) {
   ASSERT(a != NULL && b != NULL);
   while (*a != 0 && *a == *b) {
c00030c4:	8b 45 08             	mov    0x8(%ebp),%eax
c00030c7:	0f b6 00             	movzbl (%eax),%eax
c00030ca:	84 c0                	test   %al,%al
c00030cc:	74 10                	je     c00030de <strcmp+0x4f>
/work/x86_os_my/lib/string.c:56 (discriminator 1)
c00030ce:	8b 45 08             	mov    0x8(%ebp),%eax
c00030d1:	0f b6 10             	movzbl (%eax),%edx
c00030d4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00030d7:	0f b6 00             	movzbl (%eax),%eax
c00030da:	38 c2                	cmp    %al,%dl
c00030dc:	74 de                	je     c00030bc <strcmp+0x2d>
/work/x86_os_my/lib/string.c:62
      a++;
      b++;
   }
/* 如果*a小于*b就返回-1,否则就属于*a大于等于*b的情况。在后面的布尔表达式"*a > *b"中,
 * 若*a大于*b,表达式就等于1,否则就表达式不成立,也就是布尔值为0,恰恰表示*a等于*b */
   return *a < *b ? -1 : *a > *b;
c00030de:	8b 45 08             	mov    0x8(%ebp),%eax
c00030e1:	0f b6 10             	movzbl (%eax),%edx
c00030e4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00030e7:	0f b6 00             	movzbl (%eax),%eax
c00030ea:	38 c2                	cmp    %al,%dl
c00030ec:	7c 13                	jl     c0003101 <strcmp+0x72>
/work/x86_os_my/lib/string.c:62 (discriminator 1)
c00030ee:	8b 45 08             	mov    0x8(%ebp),%eax
c00030f1:	0f b6 10             	movzbl (%eax),%edx
c00030f4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00030f7:	0f b6 00             	movzbl (%eax),%eax
c00030fa:	38 c2                	cmp    %al,%dl
c00030fc:	0f 9f c0             	setg   %al
c00030ff:	eb 05                	jmp    c0003106 <strcmp+0x77>
/work/x86_os_my/lib/string.c:62 (discriminator 2)
c0003101:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/lib/string.c:63 (discriminator 5)
}
c0003106:	c9                   	leave  
c0003107:	c3                   	ret    

c0003108 <strchr>:
strchr():
/work/x86_os_my/lib/string.c:66

/* 从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strchr(const char* str, const uint8_t ch) {
c0003108:	55                   	push   %ebp
c0003109:	89 e5                	mov    %esp,%ebp
c000310b:	83 ec 18             	sub    $0x18,%esp
c000310e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003111:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/lib/string.c:67
   ASSERT(str != NULL);
c0003114:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003118:	75 35                	jne    c000314f <strchr+0x47>
/work/x86_os_my/lib/string.c:67 (discriminator 1)
c000311a:	68 fe 4f 00 c0       	push   $0xc0004ffe
c000311f:	68 54 50 00 c0       	push   $0xc0005054
c0003124:	6a 43                	push   $0x43
c0003126:	68 bd 4f 00 c0       	push   $0xc0004fbd
c000312b:	e8 62 f2 ff ff       	call   c0002392 <panic_spin>
c0003130:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:68 (discriminator 1)
   while (*str != 0) {
c0003133:	eb 1a                	jmp    c000314f <strchr+0x47>
/work/x86_os_my/lib/string.c:69
      if (*str == ch) {
c0003135:	8b 45 08             	mov    0x8(%ebp),%eax
c0003138:	0f b6 00             	movzbl (%eax),%eax
c000313b:	0f be d0             	movsbl %al,%edx
c000313e:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0003142:	39 c2                	cmp    %eax,%edx
c0003144:	75 05                	jne    c000314b <strchr+0x43>
/work/x86_os_my/lib/string.c:70
	 return (char*)str;	    // 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.
c0003146:	8b 45 08             	mov    0x8(%ebp),%eax
c0003149:	eb 13                	jmp    c000315e <strchr+0x56>
/work/x86_os_my/lib/string.c:72
      }
      str++;
c000314b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:68
}

/* 从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strchr(const char* str, const uint8_t ch) {
   ASSERT(str != NULL);
   while (*str != 0) {
c000314f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003152:	0f b6 00             	movzbl (%eax),%eax
c0003155:	84 c0                	test   %al,%al
c0003157:	75 dc                	jne    c0003135 <strchr+0x2d>
/work/x86_os_my/lib/string.c:74
      if (*str == ch) {
	 return (char*)str;	    // 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.
      }
      str++;
   }
   return NULL;
c0003159:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/string.c:75
}
c000315e:	c9                   	leave  
c000315f:	c3                   	ret    

c0003160 <strrchr>:
strrchr():
/work/x86_os_my/lib/string.c:78

/* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strrchr(const char* str, const uint8_t ch) {
c0003160:	55                   	push   %ebp
c0003161:	89 e5                	mov    %esp,%ebp
c0003163:	83 ec 28             	sub    $0x28,%esp
c0003166:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003169:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:79
   ASSERT(str != NULL);
c000316c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003170:	75 19                	jne    c000318b <strrchr+0x2b>
/work/x86_os_my/lib/string.c:79 (discriminator 1)
c0003172:	68 fe 4f 00 c0       	push   $0xc0004ffe
c0003177:	68 5c 50 00 c0       	push   $0xc000505c
c000317c:	6a 4f                	push   $0x4f
c000317e:	68 bd 4f 00 c0       	push   $0xc0004fbd
c0003183:	e8 0a f2 ff ff       	call   c0002392 <panic_spin>
c0003188:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:80
   const char* last_char = NULL;
c000318b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/string.c:82
   /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/
   while (*str != 0) {
c0003192:	eb 1b                	jmp    c00031af <strrchr+0x4f>
/work/x86_os_my/lib/string.c:83
      if (*str == ch) {
c0003194:	8b 45 08             	mov    0x8(%ebp),%eax
c0003197:	0f b6 00             	movzbl (%eax),%eax
c000319a:	0f be d0             	movsbl %al,%edx
c000319d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c00031a1:	39 c2                	cmp    %eax,%edx
c00031a3:	75 06                	jne    c00031ab <strrchr+0x4b>
/work/x86_os_my/lib/string.c:84
	 last_char = str;
c00031a5:	8b 45 08             	mov    0x8(%ebp),%eax
c00031a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:86
      }
      str++;
c00031ab:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:82
/* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strrchr(const char* str, const uint8_t ch) {
   ASSERT(str != NULL);
   const char* last_char = NULL;
   /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/
   while (*str != 0) {
c00031af:	8b 45 08             	mov    0x8(%ebp),%eax
c00031b2:	0f b6 00             	movzbl (%eax),%eax
c00031b5:	84 c0                	test   %al,%al
c00031b7:	75 db                	jne    c0003194 <strrchr+0x34>
/work/x86_os_my/lib/string.c:88
      if (*str == ch) {
	 last_char = str;
      }
      str++;
   }
   return (char*)last_char;
c00031b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:89
}
c00031bc:	c9                   	leave  
c00031bd:	c3                   	ret    

c00031be <strcat>:
strcat():
/work/x86_os_my/lib/string.c:92

/* 将字符串src_拼接到dst_后,将回拼接的串地址 */
char* strcat(char* dst_, const char* src_) {
c00031be:	55                   	push   %ebp
c00031bf:	89 e5                	mov    %esp,%ebp
c00031c1:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:93
   ASSERT(dst_ != NULL && src_ != NULL);
c00031c4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00031c8:	74 06                	je     c00031d0 <strcat+0x12>
/work/x86_os_my/lib/string.c:93 (discriminator 1)
c00031ca:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00031ce:	75 19                	jne    c00031e9 <strcat+0x2b>
/work/x86_os_my/lib/string.c:93 (discriminator 3)
c00031d0:	68 ca 4f 00 c0       	push   $0xc0004fca
c00031d5:	68 64 50 00 c0       	push   $0xc0005064
c00031da:	6a 5d                	push   $0x5d
c00031dc:	68 bd 4f 00 c0       	push   $0xc0004fbd
c00031e1:	e8 ac f1 ff ff       	call   c0002392 <panic_spin>
c00031e6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:94
   char* str = dst_;
c00031e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00031ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:95
   while (*str++);
c00031ef:	90                   	nop
/work/x86_os_my/lib/string.c:95 (discriminator 1)
c00031f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00031f3:	8d 50 01             	lea    0x1(%eax),%edx
c00031f6:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00031f9:	0f b6 00             	movzbl (%eax),%eax
c00031fc:	84 c0                	test   %al,%al
c00031fe:	75 f0                	jne    c00031f0 <strcat+0x32>
/work/x86_os_my/lib/string.c:96
   --str;      // 别看错了，--str是独立的一句，并不是while的循环体
c0003200:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:97
   while((*str++ = *src_++));	 // 当*str被赋值为0时,此时表达式不成立,正好添加了字符串结尾的0.
c0003204:	90                   	nop
/work/x86_os_my/lib/string.c:97 (discriminator 1)
c0003205:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003208:	8d 50 01             	lea    0x1(%eax),%edx
c000320b:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000320e:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003211:	8d 4a 01             	lea    0x1(%edx),%ecx
c0003214:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c0003217:	0f b6 12             	movzbl (%edx),%edx
c000321a:	88 10                	mov    %dl,(%eax)
c000321c:	0f b6 00             	movzbl (%eax),%eax
c000321f:	84 c0                	test   %al,%al
c0003221:	75 e2                	jne    c0003205 <strcat+0x47>
/work/x86_os_my/lib/string.c:98
   return dst_;
c0003223:	8b 45 08             	mov    0x8(%ebp),%eax
/work/x86_os_my/lib/string.c:99
}
c0003226:	c9                   	leave  
c0003227:	c3                   	ret    

c0003228 <strchrs>:
strchrs():
/work/x86_os_my/lib/string.c:102

/* 在字符串str中查找指定字符ch出现的次数 */
uint32_t strchrs(const char* str, uint8_t ch) {
c0003228:	55                   	push   %ebp
c0003229:	89 e5                	mov    %esp,%ebp
c000322b:	83 ec 28             	sub    $0x28,%esp
c000322e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003231:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:103
   ASSERT(str != NULL);
c0003234:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003238:	75 19                	jne    c0003253 <strchrs+0x2b>
/work/x86_os_my/lib/string.c:103 (discriminator 1)
c000323a:	68 fe 4f 00 c0       	push   $0xc0004ffe
c000323f:	68 6c 50 00 c0       	push   $0xc000506c
c0003244:	6a 67                	push   $0x67
c0003246:	68 bd 4f 00 c0       	push   $0xc0004fbd
c000324b:	e8 42 f1 ff ff       	call   c0002392 <panic_spin>
c0003250:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:104
   uint32_t ch_cnt = 0;
c0003253:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/string.c:105
   const char* p = str;
c000325a:	8b 45 08             	mov    0x8(%ebp),%eax
c000325d:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:106
   while(*p != 0) {
c0003260:	eb 19                	jmp    c000327b <strchrs+0x53>
/work/x86_os_my/lib/string.c:107
      if (*p == ch) {
c0003262:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003265:	0f b6 00             	movzbl (%eax),%eax
c0003268:	0f be d0             	movsbl %al,%edx
c000326b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c000326f:	39 c2                	cmp    %eax,%edx
c0003271:	75 04                	jne    c0003277 <strchrs+0x4f>
/work/x86_os_my/lib/string.c:108
	 ch_cnt++;
c0003273:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:110
      }
      p++;
c0003277:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/string.c:106
/* 在字符串str中查找指定字符ch出现的次数 */
uint32_t strchrs(const char* str, uint8_t ch) {
   ASSERT(str != NULL);
   uint32_t ch_cnt = 0;
   const char* p = str;
   while(*p != 0) {
c000327b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000327e:	0f b6 00             	movzbl (%eax),%eax
c0003281:	84 c0                	test   %al,%al
c0003283:	75 dd                	jne    c0003262 <strchrs+0x3a>
/work/x86_os_my/lib/string.c:112
      if (*p == ch) {
	 ch_cnt++;
      }
      p++;
   }
   return ch_cnt;
c0003285:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:113
}
c0003288:	c9                   	leave  
c0003289:	c3                   	ret    

c000328a <running_thread>:
running_thread():
/work/x86_os_my/thread/thread.c:24

/* 返回线程 PCB 地址。
 * 各个线程所用的 0 级栈都是在自己的 PCB 当中，
 * 取当前栈指针的高 20 位，就是当前运行线程的 PCB（PCB是在自然页的起始地址！）
 */
struct task_struct* running_thread() {
c000328a:	55                   	push   %ebp
c000328b:	89 e5                	mov    %esp,%ebp
c000328d:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:26
	uint32_t esp;
	asm ("mov %%esp, %0" : "=g" (esp));	//esp寄存器的值，放入变量esp
c0003290:	89 e0                	mov    %esp,%eax
c0003292:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:27
	return (struct task_struct*)(esp & 0xfffff000);
c0003295:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003298:	25 00 f0 ff ff       	and    $0xfffff000,%eax
/work/x86_os_my/thread/thread.c:28
}
c000329d:	c9                   	leave  
c000329e:	c3                   	ret    

c000329f <kernel_thread>:
kernel_thread():
/work/x86_os_my/thread/thread.c:31

/* 由kernel_thread去执行function(func_arg) */
static void kernel_thread(thread_func* function, void* func_arg) {
c000329f:	55                   	push   %ebp
c00032a0:	89 e5                	mov    %esp,%ebp
c00032a2:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:37
	/* 线程的首次运行是由时钟中断处理函数调用任务调度器 schedule 完成的，
	 * 进入中断后处理器会自动关中断，
	 * 因此在执行 function 前要打开中断，否则 kernel_thread 中的 function 在关中断的情况下运行，
	 * 也就是时钟中断被屏蔽了，再也不会调度到新的线程，function 会独享处理器。
	 */
	intr_enable();
c00032a5:	e8 98 e7 ff ff       	call   c0001a42 <intr_enable>
/work/x86_os_my/thread/thread.c:38
	function(func_arg); 
c00032aa:	83 ec 0c             	sub    $0xc,%esp
c00032ad:	ff 75 0c             	pushl  0xc(%ebp)
c00032b0:	8b 45 08             	mov    0x8(%ebp),%eax
c00032b3:	ff d0                	call   *%eax
c00032b5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:39
}
c00032b8:	90                   	nop
c00032b9:	c9                   	leave  
c00032ba:	c3                   	ret    

c00032bb <allocate_pid>:
allocate_pid():
/work/x86_os_my/thread/thread.c:42

/* 分配pid */
static pid_t allocate_pid(void) {
c00032bb:	55                   	push   %ebp
c00032bc:	89 e5                	mov    %esp,%ebp
c00032be:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:44
   static pid_t next_pid = 0;
   lock_acquire(&pid_lock);
c00032c1:	83 ec 0c             	sub    $0xc,%esp
c00032c4:	68 10 7b 00 c0       	push   $0xc0007b10
c00032c9:	e8 41 0a 00 00       	call   c0003d0f <lock_acquire>
c00032ce:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:45
   next_pid++;
c00032d1:	0f b7 05 8c 75 00 c0 	movzwl 0xc000758c,%eax
c00032d8:	83 c0 01             	add    $0x1,%eax
c00032db:	66 a3 8c 75 00 c0    	mov    %ax,0xc000758c
/work/x86_os_my/thread/thread.c:46
   lock_release(&pid_lock);
c00032e1:	83 ec 0c             	sub    $0xc,%esp
c00032e4:	68 10 7b 00 c0       	push   $0xc0007b10
c00032e9:	e8 98 0a 00 00       	call   c0003d86 <lock_release>
c00032ee:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:47
   return next_pid;
c00032f1:	0f b7 05 8c 75 00 c0 	movzwl 0xc000758c,%eax
/work/x86_os_my/thread/thread.c:48
}
c00032f8:	c9                   	leave  
c00032f9:	c3                   	ret    

c00032fa <thread_create>:
thread_create():
/work/x86_os_my/thread/thread.c:51

/* 初始化线程栈结构体 struct thread_stack */
void thread_create(struct task_struct* pthread, thread_func function, void* func_arg) {
c00032fa:	55                   	push   %ebp
c00032fb:	89 e5                	mov    %esp,%ebp
c00032fd:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:55
	/* 先预留中断使用栈的空间 
	 *（1）将来线程进入中断后，位于 kernel.S 中的中断代码会通过此栈来保存上下文。
	 *（2）将来实现用户进程时，会将用户进程的初始信息放在中断栈中。*/
	pthread->self_kstack -= sizeof(struct intr_stack);
c0003300:	8b 45 08             	mov    0x8(%ebp),%eax
c0003303:	8b 00                	mov    (%eax),%eax
c0003305:	8d 90 d0 fe ff ff    	lea    -0x130(%eax),%edx
c000330b:	8b 45 08             	mov    0x8(%ebp),%eax
c000330e:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:58

	/* 再留出线程栈空间（unused_retaddr 所在的栈）*/
	pthread->self_kstack -= sizeof(struct thread_stack);
c0003310:	8b 45 08             	mov    0x8(%ebp),%eax
c0003313:	8b 00                	mov    (%eax),%eax
c0003315:	8d 50 80             	lea    -0x80(%eax),%edx
c0003318:	8b 45 08             	mov    0x8(%ebp),%eax
c000331b:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:59
	struct thread_stack* kthread_stack = (struct thread_stack*)pthread->self_kstack;
c000331d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003320:	8b 00                	mov    (%eax),%eax
c0003322:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:67
	 * kernel_thread 并不是通过 call 指令调用的，而是通过 ret 来执行的，
	 * 因此无法按照正常的函数调用形式传递 kernel_thread 所需要的参数，
	 * 这样调用是不行的： kernel_thread(function, func_arg)，
	 * 只能将参数放在 kernel_thread 所用的栈中，即处理器进入 kernel_thread 函数体时，
	 * 栈顶为返回地址，栈顶+4 为参数function，栈顶+8 为参数func_arg */
	kthread_stack->eip = kernel_thread;
c0003325:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003328:	c7 40 10 9f 32 00 c0 	movl   $0xc000329f,0x10(%eax)
/work/x86_os_my/thread/thread.c:68
	kthread_stack->function = function;
c000332f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003332:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003335:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/thread.c:69
	kthread_stack->func_arg = func_arg;
c0003338:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000333b:	8b 55 10             	mov    0x10(%ebp),%edx
c000333e:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/thread/thread.c:70
	kthread_stack->ebp = kthread_stack->ebx = kthread_stack->esi = kthread_stack->edi = 0;
c0003341:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003344:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c000334b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000334e:	8b 50 08             	mov    0x8(%eax),%edx
c0003351:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003354:	89 50 0c             	mov    %edx,0xc(%eax)
c0003357:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000335a:	8b 50 0c             	mov    0xc(%eax),%edx
c000335d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003360:	89 50 04             	mov    %edx,0x4(%eax)
c0003363:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003366:	8b 50 04             	mov    0x4(%eax),%edx
c0003369:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000336c:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:71
}
c000336e:	90                   	nop
c000336f:	c9                   	leave  
c0003370:	c3                   	ret    

c0003371 <init_thread>:
init_thread():
/work/x86_os_my/thread/thread.c:74

/* 初始化线程PCB结构体 struct task_struct */
void init_thread(struct task_struct* pthread, char* name, int prio) {
c0003371:	55                   	push   %ebp
c0003372:	89 e5                	mov    %esp,%ebp
c0003374:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:75
	memset(pthread, 0, sizeof(*pthread));	//清空PCB
c0003377:	83 ec 04             	sub    $0x4,%esp
c000337a:	6a 48                	push   $0x48
c000337c:	6a 00                	push   $0x0
c000337e:	ff 75 08             	pushl  0x8(%ebp)
c0003381:	e8 34 fb ff ff       	call   c0002eba <memset>
c0003386:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:76
	pthread->pid = allocate_pid();
c0003389:	e8 2d ff ff ff       	call   c00032bb <allocate_pid>
c000338e:	89 c2                	mov    %eax,%edx
c0003390:	8b 45 08             	mov    0x8(%ebp),%eax
c0003393:	66 89 50 04          	mov    %dx,0x4(%eax)
/work/x86_os_my/thread/thread.c:77
	strcpy(pthread->name, name);
c0003397:	8b 45 08             	mov    0x8(%ebp),%eax
c000339a:	83 c0 0c             	add    $0xc,%eax
c000339d:	83 ec 08             	sub    $0x8,%esp
c00033a0:	ff 75 0c             	pushl  0xc(%ebp)
c00033a3:	50                   	push   %eax
c00033a4:	e8 46 fc ff ff       	call   c0002fef <strcpy>
c00033a9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:79

	if (pthread == g_main_thread) {
c00033ac:	a1 0c 7b 00 c0       	mov    0xc0007b0c,%eax
c00033b1:	39 45 08             	cmp    %eax,0x8(%ebp)
c00033b4:	75 0c                	jne    c00033c2 <init_thread+0x51>
/work/x86_os_my/thread/thread.c:81
		/* 由于把main函数也封装成一个线程,并且它一直是运行的,故将其直接设为TASK_RUNNING */
		pthread->status = TASK_RUNNING;
c00033b6:	8b 45 08             	mov    0x8(%ebp),%eax
c00033b9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c00033c0:	eb 0a                	jmp    c00033cc <init_thread+0x5b>
/work/x86_os_my/thread/thread.c:83
	} else {
		pthread->status = TASK_READY;
c00033c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00033c5:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:89
	}

	/* self_kstack是线程自己在内核态下使用的栈顶地址 
	 * 线程自己在 0 特权级下所用的栈，在线程创建之初，
	 * 它被初始化为线程 PCB 的最顶端，即(uint32_t)pthread + PG_SIZE。*/
	pthread->self_kstack = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c00033cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00033cf:	05 00 10 00 00       	add    $0x1000,%eax
c00033d4:	89 c2                	mov    %eax,%edx
c00033d6:	8b 45 08             	mov    0x8(%ebp),%eax
c00033d9:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:90
	pthread->priority = prio;
c00033db:	8b 45 10             	mov    0x10(%ebp),%eax
c00033de:	89 c2                	mov    %eax,%edx
c00033e0:	8b 45 08             	mov    0x8(%ebp),%eax
c00033e3:	88 50 1c             	mov    %dl,0x1c(%eax)
/work/x86_os_my/thread/thread.c:91
	pthread->ticks = prio;
c00033e6:	8b 45 10             	mov    0x10(%ebp),%eax
c00033e9:	89 c2                	mov    %eax,%edx
c00033eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00033ee:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/thread/thread.c:92
	pthread->elapsed_ticks = 0;
c00033f1:	8b 45 08             	mov    0x8(%ebp),%eax
c00033f4:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
/work/x86_os_my/thread/thread.c:93
	pthread->pgdir = NULL;
c00033fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00033fe:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
/work/x86_os_my/thread/thread.c:94
	pthread->stack_magic = 0x19870916;	  // 自定义的魔数
c0003405:	8b 45 08             	mov    0x8(%ebp),%eax
c0003408:	c7 40 44 16 09 87 19 	movl   $0x19870916,0x44(%eax)
/work/x86_os_my/thread/thread.c:95
}
c000340f:	90                   	nop
c0003410:	c9                   	leave  
c0003411:	c3                   	ret    

c0003412 <thread_start>:
thread_start():
/work/x86_os_my/thread/thread.c:98

/* 创建线程 */
struct task_struct* thread_start(char* name, int prio, thread_func function, void* func_arg) {
c0003412:	55                   	push   %ebp
c0003413:	89 e5                	mov    %esp,%ebp
c0003415:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:100
	/* pcb都位于内核空间,包括用户进程的pcb也是在内核空间 */
	struct task_struct* thread = get_kernel_pages(1);
c0003418:	83 ec 0c             	sub    $0xc,%esp
c000341b:	6a 01                	push   $0x1
c000341d:	e8 18 f6 ff ff       	call   c0002a3a <get_kernel_pages>
c0003422:	83 c4 10             	add    $0x10,%esp
c0003425:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:102

	init_thread(thread, name, prio);			//初始化线程PCB
c0003428:	83 ec 04             	sub    $0x4,%esp
c000342b:	ff 75 0c             	pushl  0xc(%ebp)
c000342e:	ff 75 08             	pushl  0x8(%ebp)
c0003431:	ff 75 f4             	pushl  -0xc(%ebp)
c0003434:	e8 38 ff ff ff       	call   c0003371 <init_thread>
c0003439:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:103
	thread_create(thread, function, func_arg);	//初始化线程栈结构体
c000343c:	83 ec 04             	sub    $0x4,%esp
c000343f:	ff 75 14             	pushl  0x14(%ebp)
c0003442:	ff 75 10             	pushl  0x10(%ebp)
c0003445:	ff 75 f4             	pushl  -0xc(%ebp)
c0003448:	e8 ad fe ff ff       	call   c00032fa <thread_create>
c000344d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:105
	
	ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));	// 确保之前不在队列中
c0003450:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003453:	83 c0 24             	add    $0x24,%eax
c0003456:	83 ec 08             	sub    $0x8,%esp
c0003459:	50                   	push   %eax
c000345a:	68 ec 7a 00 c0       	push   $0xc0007aec
c000345f:	e8 f2 04 00 00       	call   c0003956 <elem_find>
c0003464:	83 c4 10             	add    $0x10,%esp
c0003467:	85 c0                	test   %eax,%eax
c0003469:	74 19                	je     c0003484 <thread_start+0x72>
/work/x86_os_my/thread/thread.c:105 (discriminator 1)
c000346b:	68 74 50 00 c0       	push   $0xc0005074
c0003470:	68 f4 52 00 c0       	push   $0xc00052f4
c0003475:	6a 69                	push   $0x69
c0003477:	68 a9 50 00 c0       	push   $0xc00050a9
c000347c:	e8 11 ef ff ff       	call   c0002392 <panic_spin>
c0003481:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:106
	list_append(&thread_ready_list, &thread->general_tag);			// 加入就绪线程队列
c0003484:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003487:	83 c0 24             	add    $0x24,%eax
c000348a:	83 ec 08             	sub    $0x8,%esp
c000348d:	50                   	push   %eax
c000348e:	68 ec 7a 00 c0       	push   $0xc0007aec
c0003493:	e8 44 04 00 00       	call   c00038dc <list_append>
c0003498:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:108

	ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
c000349b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000349e:	83 c0 2c             	add    $0x2c,%eax
c00034a1:	83 ec 08             	sub    $0x8,%esp
c00034a4:	50                   	push   %eax
c00034a5:	68 fc 7a 00 c0       	push   $0xc0007afc
c00034aa:	e8 a7 04 00 00       	call   c0003956 <elem_find>
c00034af:	83 c4 10             	add    $0x10,%esp
c00034b2:	85 c0                	test   %eax,%eax
c00034b4:	74 19                	je     c00034cf <thread_start+0xbd>
/work/x86_os_my/thread/thread.c:108 (discriminator 1)
c00034b6:	68 bc 50 00 c0       	push   $0xc00050bc
c00034bb:	68 f4 52 00 c0       	push   $0xc00052f4
c00034c0:	6a 6c                	push   $0x6c
c00034c2:	68 a9 50 00 c0       	push   $0xc00050a9
c00034c7:	e8 c6 ee ff ff       	call   c0002392 <panic_spin>
c00034cc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:109
	list_append(&thread_all_list, &thread->all_list_tag);			// 加入全部线程队列
c00034cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00034d2:	83 c0 2c             	add    $0x2c,%eax
c00034d5:	83 ec 08             	sub    $0x8,%esp
c00034d8:	50                   	push   %eax
c00034d9:	68 fc 7a 00 c0       	push   $0xc0007afc
c00034de:	e8 f9 03 00 00       	call   c00038dc <list_append>
c00034e3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:125
	 * 在执行 ret 后，esp 指向的数值被弹岀到 eip。
	 * 处理器会去执行 kernel_thread 函数。
	 * 在执行 kernel_thread 时，处理器以为栈顶是返回地址，其实只是一个假的占位置的变量 unused_retaddr！
	 * 接着会调用函数 function(func_arg) */
	//asm volatile ("movl %0, %%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret" : : "g" (thread->self_kstack) : "memory");
	return thread;
c00034e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/thread/thread.c:126
}
c00034e9:	c9                   	leave  
c00034ea:	c3                   	ret    

c00034eb <make_main_thread>:
make_main_thread():
/work/x86_os_my/thread/thread.c:130


/* 将kernel中的main函数完善为主线程 */
static void make_main_thread(void) {
c00034eb:	55                   	push   %ebp
c00034ec:	89 e5                	mov    %esp,%ebp
c00034ee:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:135
	/* 因为main线程早已运行,咱们在loader.S中进入内核时的mov esp, 0xc009f000设置了栈顶，也预留了pcb, 地址为0xc009e000
	 * 主线程不需要再为PCB申请页，只需要通过 init_thread 填充PCB成员：名称和优先级等。
	 * 也不需要再通过 thread_create 构造它的线程栈。
	 */
	g_main_thread = running_thread();	//用栈指针的高20位，当做当前线程的PCB
c00034f1:	e8 94 fd ff ff       	call   c000328a <running_thread>
c00034f6:	a3 0c 7b 00 c0       	mov    %eax,0xc0007b0c
/work/x86_os_my/thread/thread.c:136
	init_thread(g_main_thread, "main", 31);
c00034fb:	a1 0c 7b 00 c0       	mov    0xc0007b0c,%eax
c0003500:	83 ec 04             	sub    $0x4,%esp
c0003503:	6a 1f                	push   $0x1f
c0003505:	68 f0 50 00 c0       	push   $0xc00050f0
c000350a:	50                   	push   %eax
c000350b:	e8 61 fe ff ff       	call   c0003371 <init_thread>
c0003510:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:140

	/* main函数是当前线程,当前线程不在thread_ready_list中,
	 * 所以只将其加在thread_all_list中. */
	ASSERT(!elem_find(&thread_all_list, &g_main_thread->all_list_tag));
c0003513:	a1 0c 7b 00 c0       	mov    0xc0007b0c,%eax
c0003518:	83 c0 2c             	add    $0x2c,%eax
c000351b:	83 ec 08             	sub    $0x8,%esp
c000351e:	50                   	push   %eax
c000351f:	68 fc 7a 00 c0       	push   $0xc0007afc
c0003524:	e8 2d 04 00 00       	call   c0003956 <elem_find>
c0003529:	83 c4 10             	add    $0x10,%esp
c000352c:	85 c0                	test   %eax,%eax
c000352e:	74 1c                	je     c000354c <make_main_thread+0x61>
/work/x86_os_my/thread/thread.c:140 (discriminator 1)
c0003530:	68 f8 50 00 c0       	push   $0xc00050f8
c0003535:	68 04 53 00 c0       	push   $0xc0005304
c000353a:	68 8c 00 00 00       	push   $0x8c
c000353f:	68 a9 50 00 c0       	push   $0xc00050a9
c0003544:	e8 49 ee ff ff       	call   c0002392 <panic_spin>
c0003549:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:141
	list_append(&thread_all_list, &g_main_thread->all_list_tag);
c000354c:	a1 0c 7b 00 c0       	mov    0xc0007b0c,%eax
c0003551:	83 c0 2c             	add    $0x2c,%eax
c0003554:	83 ec 08             	sub    $0x8,%esp
c0003557:	50                   	push   %eax
c0003558:	68 fc 7a 00 c0       	push   $0xc0007afc
c000355d:	e8 7a 03 00 00       	call   c00038dc <list_append>
c0003562:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:142
}
c0003565:	90                   	nop
c0003566:	c9                   	leave  
c0003567:	c3                   	ret    

c0003568 <schedule>:
schedule():
/work/x86_os_my/thread/thread.c:152
（2）调度器 schedule。
（3）任务切换函数 switch_to。
*/
/* 实现任务调度 */
void schedule()
{
c0003568:	55                   	push   %ebp
c0003569:	89 e5                	mov    %esp,%ebp
c000356b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:153
	ASSERT(intr_get_status() == INTR_OFF);
c000356e:	e8 3f e5 ff ff       	call   c0001ab2 <intr_get_status>
c0003573:	85 c0                	test   %eax,%eax
c0003575:	74 1c                	je     c0003593 <schedule+0x2b>
/work/x86_os_my/thread/thread.c:153 (discriminator 1)
c0003577:	68 33 51 00 c0       	push   $0xc0005133
c000357c:	68 18 53 00 c0       	push   $0xc0005318
c0003581:	68 99 00 00 00       	push   $0x99
c0003586:	68 a9 50 00 c0       	push   $0xc00050a9
c000358b:	e8 02 ee ff ff       	call   c0002392 <panic_spin>
c0003590:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:156

	/* 换下 */
	struct task_struct* cur = running_thread(); 
c0003593:	e8 f2 fc ff ff       	call   c000328a <running_thread>
c0003598:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:157
	if (cur->status == TASK_RUNNING) { // 若此线程只是cpu时间片到了,将其加入到就绪队列尾
c000359b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000359e:	8b 40 08             	mov    0x8(%eax),%eax
c00035a1:	85 c0                	test   %eax,%eax
c00035a3:	75 65                	jne    c000360a <schedule+0xa2>
/work/x86_os_my/thread/thread.c:158
		ASSERT(!elem_find(&thread_ready_list, &cur->general_tag));
c00035a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00035a8:	83 c0 24             	add    $0x24,%eax
c00035ab:	83 ec 08             	sub    $0x8,%esp
c00035ae:	50                   	push   %eax
c00035af:	68 ec 7a 00 c0       	push   $0xc0007aec
c00035b4:	e8 9d 03 00 00       	call   c0003956 <elem_find>
c00035b9:	83 c4 10             	add    $0x10,%esp
c00035bc:	85 c0                	test   %eax,%eax
c00035be:	74 1c                	je     c00035dc <schedule+0x74>
/work/x86_os_my/thread/thread.c:158 (discriminator 1)
c00035c0:	68 54 51 00 c0       	push   $0xc0005154
c00035c5:	68 18 53 00 c0       	push   $0xc0005318
c00035ca:	68 9e 00 00 00       	push   $0x9e
c00035cf:	68 a9 50 00 c0       	push   $0xc00050a9
c00035d4:	e8 b9 ed ff ff       	call   c0002392 <panic_spin>
c00035d9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:159
		list_append(&thread_ready_list, &cur->general_tag);
c00035dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00035df:	83 c0 24             	add    $0x24,%eax
c00035e2:	83 ec 08             	sub    $0x8,%esp
c00035e5:	50                   	push   %eax
c00035e6:	68 ec 7a 00 c0       	push   $0xc0007aec
c00035eb:	e8 ec 02 00 00       	call   c00038dc <list_append>
c00035f0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:160
		cur->ticks = cur->priority;     // 重新将当前线程的ticks再重置为其priority;
c00035f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00035f6:	0f b6 50 1c          	movzbl 0x1c(%eax),%edx
c00035fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00035fd:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/thread/thread.c:161
		cur->status = TASK_READY;
c0003600:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003603:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:168
		/* 若此线程需要某事件发生后才能继续上cpu运行,
		不需要将其加入队列,因为当前线程不在就绪队列中。*/
	}

	/* 换上 */
	ASSERT(!list_empty(&thread_ready_list));
c000360a:	83 ec 0c             	sub    $0xc,%esp
c000360d:	68 ec 7a 00 c0       	push   $0xc0007aec
c0003612:	e8 0c 04 00 00       	call   c0003a23 <list_empty>
c0003617:	83 c4 10             	add    $0x10,%esp
c000361a:	85 c0                	test   %eax,%eax
c000361c:	74 1c                	je     c000363a <schedule+0xd2>
/work/x86_os_my/thread/thread.c:168 (discriminator 1)
c000361e:	68 88 51 00 c0       	push   $0xc0005188
c0003623:	68 18 53 00 c0       	push   $0xc0005318
c0003628:	68 a8 00 00 00       	push   $0xa8
c000362d:	68 a9 50 00 c0       	push   $0xc00050a9
c0003632:	e8 5b ed ff ff       	call   c0002392 <panic_spin>
c0003637:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:169
	g_thread_tag = NULL;	  // g_thread_tag清空
c000363a:	c7 05 88 75 00 c0 00 	movl   $0x0,0xc0007588
c0003641:	00 00 00 
/work/x86_os_my/thread/thread.c:171
	/* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */
	g_thread_tag = list_pop(&thread_ready_list);   
c0003644:	83 ec 0c             	sub    $0xc,%esp
c0003647:	68 ec 7a 00 c0       	push   $0xc0007aec
c000364c:	e8 e3 02 00 00       	call   c0003934 <list_pop>
c0003651:	83 c4 10             	add    $0x10,%esp
c0003654:	a3 88 75 00 c0       	mov    %eax,0xc0007588
/work/x86_os_my/thread/thread.c:172
	struct task_struct* next = elem2entry(struct task_struct, general_tag, g_thread_tag);
c0003659:	a1 88 75 00 c0       	mov    0xc0007588,%eax
c000365e:	83 e8 24             	sub    $0x24,%eax
c0003661:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:173
	next->status = TASK_RUNNING;
c0003664:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003667:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/thread/thread.c:177
	
	/* 1.激活线程或进程的页表,【更新CR3寄存器】
	 * 2.用户进程，更新tss中的esp0为进程的特权级0的栈 */
	process_activate(next);
c000366e:	83 ec 0c             	sub    $0xc,%esp
c0003671:	ff 75 f0             	pushl  -0x10(%ebp)
c0003674:	e8 59 10 00 00       	call   c00046d2 <process_activate>
c0003679:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:179

	switch_to(cur, next);
c000367c:	83 ec 08             	sub    $0x8,%esp
c000367f:	ff 75 f0             	pushl  -0x10(%ebp)
c0003682:	ff 75 f4             	pushl  -0xc(%ebp)
c0003685:	e8 b6 03 00 00       	call   c0003a40 <switch_to>
c000368a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:180
}
c000368d:	90                   	nop
c000368e:	c9                   	leave  
c000368f:	c3                   	ret    

c0003690 <thread_block>:
thread_block():
/work/x86_os_my/thread/thread.c:183

/* 当前线程将自己阻塞,标志其状态为stat. */
void thread_block(enum task_status stat) {
c0003690:	55                   	push   %ebp
c0003691:	89 e5                	mov    %esp,%ebp
c0003693:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:185
	/* stat取值为TASK_BLOCKED,TASK_WAITING,TASK_HANGING,也就是只有这三种状态才不会被调度*/
	ASSERT(((stat == TASK_BLOCKED) || (stat == TASK_WAITING) || (stat == TASK_HANGING)));
c0003696:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c000369a:	74 28                	je     c00036c4 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:185 (discriminator 1)
c000369c:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c00036a0:	74 22                	je     c00036c4 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:185 (discriminator 2)
c00036a2:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
c00036a6:	74 1c                	je     c00036c4 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:185 (discriminator 3)
c00036a8:	68 a8 51 00 c0       	push   $0xc00051a8
c00036ad:	68 24 53 00 c0       	push   $0xc0005324
c00036b2:	68 b9 00 00 00       	push   $0xb9
c00036b7:	68 a9 50 00 c0       	push   $0xc00050a9
c00036bc:	e8 d1 ec ff ff       	call   c0002392 <panic_spin>
c00036c1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:186
	enum intr_status old_status = intr_disable();
c00036c4:	e8 a2 e3 ff ff       	call   c0001a6b <intr_disable>
c00036c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:188
	
	struct task_struct* cur_thread = running_thread();
c00036cc:	e8 b9 fb ff ff       	call   c000328a <running_thread>
c00036d1:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:189
	cur_thread->status = stat;
c00036d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00036d7:	8b 55 08             	mov    0x8(%ebp),%edx
c00036da:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/thread/thread.c:190
	schedule();
c00036dd:	e8 86 fe ff ff       	call   c0003568 <schedule>
/work/x86_os_my/thread/thread.c:193
	
	/* 待当前线程被解除阻塞后才继续运行下面的intr_set_status */
	intr_set_status(old_status);
c00036e2:	83 ec 0c             	sub    $0xc,%esp
c00036e5:	ff 75 f4             	pushl  -0xc(%ebp)
c00036e8:	e8 a7 e3 ff ff       	call   c0001a94 <intr_set_status>
c00036ed:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:194
}
c00036f0:	90                   	nop
c00036f1:	c9                   	leave  
c00036f2:	c3                   	ret    

c00036f3 <thread_unblock>:
thread_unblock():
/work/x86_os_my/thread/thread.c:197

/* 将线程pthread解除阻塞 */
void thread_unblock(struct task_struct* pthread) {
c00036f3:	55                   	push   %ebp
c00036f4:	89 e5                	mov    %esp,%ebp
c00036f6:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:198
	enum intr_status old_status = intr_disable();
c00036f9:	e8 6d e3 ff ff       	call   c0001a6b <intr_disable>
c00036fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:199
	ASSERT(((pthread->status == TASK_BLOCKED) || (pthread->status == TASK_WAITING) || (pthread->status == TASK_HANGING)));
c0003701:	8b 45 08             	mov    0x8(%ebp),%eax
c0003704:	8b 40 08             	mov    0x8(%eax),%eax
c0003707:	83 f8 02             	cmp    $0x2,%eax
c000370a:	74 32                	je     c000373e <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:199 (discriminator 1)
c000370c:	8b 45 08             	mov    0x8(%ebp),%eax
c000370f:	8b 40 08             	mov    0x8(%eax),%eax
c0003712:	83 f8 03             	cmp    $0x3,%eax
c0003715:	74 27                	je     c000373e <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:199 (discriminator 2)
c0003717:	8b 45 08             	mov    0x8(%ebp),%eax
c000371a:	8b 40 08             	mov    0x8(%eax),%eax
c000371d:	83 f8 04             	cmp    $0x4,%eax
c0003720:	74 1c                	je     c000373e <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:199 (discriminator 3)
c0003722:	68 f8 51 00 c0       	push   $0xc00051f8
c0003727:	68 34 53 00 c0       	push   $0xc0005334
c000372c:	68 c7 00 00 00       	push   $0xc7
c0003731:	68 a9 50 00 c0       	push   $0xc00050a9
c0003736:	e8 57 ec ff ff       	call   c0002392 <panic_spin>
c000373b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:201
	
	if (pthread->status != TASK_READY) {
c000373e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003741:	8b 40 08             	mov    0x8(%eax),%eax
c0003744:	83 f8 01             	cmp    $0x1,%eax
c0003747:	0f 84 8f 00 00 00    	je     c00037dc <thread_unblock+0xe9>
/work/x86_os_my/thread/thread.c:202
		ASSERT(!elem_find(&thread_ready_list, &pthread->general_tag));
c000374d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003750:	83 c0 24             	add    $0x24,%eax
c0003753:	83 ec 08             	sub    $0x8,%esp
c0003756:	50                   	push   %eax
c0003757:	68 ec 7a 00 c0       	push   $0xc0007aec
c000375c:	e8 f5 01 00 00       	call   c0003956 <elem_find>
c0003761:	83 c4 10             	add    $0x10,%esp
c0003764:	85 c0                	test   %eax,%eax
c0003766:	74 1c                	je     c0003784 <thread_unblock+0x91>
/work/x86_os_my/thread/thread.c:202 (discriminator 1)
c0003768:	68 68 52 00 c0       	push   $0xc0005268
c000376d:	68 34 53 00 c0       	push   $0xc0005334
c0003772:	68 ca 00 00 00       	push   $0xca
c0003777:	68 a9 50 00 c0       	push   $0xc00050a9
c000377c:	e8 11 ec ff ff       	call   c0002392 <panic_spin>
c0003781:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:203
		if (elem_find(&thread_ready_list, &pthread->general_tag)) {
c0003784:	8b 45 08             	mov    0x8(%ebp),%eax
c0003787:	83 c0 24             	add    $0x24,%eax
c000378a:	83 ec 08             	sub    $0x8,%esp
c000378d:	50                   	push   %eax
c000378e:	68 ec 7a 00 c0       	push   $0xc0007aec
c0003793:	e8 be 01 00 00       	call   c0003956 <elem_find>
c0003798:	83 c4 10             	add    $0x10,%esp
c000379b:	85 c0                	test   %eax,%eax
c000379d:	74 1c                	je     c00037bb <thread_unblock+0xc8>
/work/x86_os_my/thread/thread.c:204
			PANIC("thread_unblock: blocked thread in ready_list\n");
c000379f:	68 a0 52 00 c0       	push   $0xc00052a0
c00037a4:	68 34 53 00 c0       	push   $0xc0005334
c00037a9:	68 cc 00 00 00       	push   $0xcc
c00037ae:	68 a9 50 00 c0       	push   $0xc00050a9
c00037b3:	e8 da eb ff ff       	call   c0002392 <panic_spin>
c00037b8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:206
		}
		list_push(&thread_ready_list, &pthread->general_tag);	// 放到队列的最前面,使其尽快得到调度
c00037bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00037be:	83 c0 24             	add    $0x24,%eax
c00037c1:	83 ec 08             	sub    $0x8,%esp
c00037c4:	50                   	push   %eax
c00037c5:	68 ec 7a 00 c0       	push   $0xc0007aec
c00037ca:	e8 ef 00 00 00       	call   c00038be <list_push>
c00037cf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:207
		pthread->status = TASK_READY;
c00037d2:	8b 45 08             	mov    0x8(%ebp),%eax
c00037d5:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:210
	}
	
	intr_set_status(old_status);
c00037dc:	83 ec 0c             	sub    $0xc,%esp
c00037df:	ff 75 f4             	pushl  -0xc(%ebp)
c00037e2:	e8 ad e2 ff ff       	call   c0001a94 <intr_set_status>
c00037e7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:211
}
c00037ea:	90                   	nop
c00037eb:	c9                   	leave  
c00037ec:	c3                   	ret    

c00037ed <thread_init>:
thread_init():
/work/x86_os_my/thread/thread.c:214

/* 初始化线程环境 */
void thread_init(void) {
c00037ed:	55                   	push   %ebp
c00037ee:	89 e5                	mov    %esp,%ebp
c00037f0:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:215
	put_str("thread_init start\n");
c00037f3:	83 ec 0c             	sub    $0xc,%esp
c00037f6:	68 ce 52 00 c0       	push   $0xc00052ce
c00037fb:	e8 20 ea ff ff       	call   c0002220 <put_str>
c0003800:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:216
	list_init(&thread_ready_list);
c0003803:	83 ec 0c             	sub    $0xc,%esp
c0003806:	68 ec 7a 00 c0       	push   $0xc0007aec
c000380b:	e8 3b 00 00 00       	call   c000384b <list_init>
c0003810:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:217
	list_init(&thread_all_list);
c0003813:	83 ec 0c             	sub    $0xc,%esp
c0003816:	68 fc 7a 00 c0       	push   $0xc0007afc
c000381b:	e8 2b 00 00 00       	call   c000384b <list_init>
c0003820:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:218
	lock_init(&pid_lock);
c0003823:	83 ec 0c             	sub    $0xc,%esp
c0003826:	68 10 7b 00 c0       	push   $0xc0007b10
c000382b:	e8 05 03 00 00       	call   c0003b35 <lock_init>
c0003830:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:220
	/* 将当前main函数创建为线程 */
	make_main_thread();
c0003833:	e8 b3 fc ff ff       	call   c00034eb <make_main_thread>
/work/x86_os_my/thread/thread.c:221
	put_str("thread_init done\n");
c0003838:	83 ec 0c             	sub    $0xc,%esp
c000383b:	68 e1 52 00 c0       	push   $0xc00052e1
c0003840:	e8 db e9 ff ff       	call   c0002220 <put_str>
c0003845:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:222
}
c0003848:	90                   	nop
c0003849:	c9                   	leave  
c000384a:	c3                   	ret    

c000384b <list_init>:
list_init():
/work/x86_os_my/lib/kernel/list.c:6
#include "list.h"
#include "interrupt.h"
/* 注意关中断的操作：临界区 */

/* 初始化双向链表list */
void list_init (struct list* list) {
c000384b:	55                   	push   %ebp
c000384c:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/lib/kernel/list.c:7
	list->head.prev = NULL;
c000384e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003851:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/lib/kernel/list.c:8
	list->head.next = &list->tail;
c0003857:	8b 45 08             	mov    0x8(%ebp),%eax
c000385a:	8d 50 08             	lea    0x8(%eax),%edx
c000385d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003860:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:9
	list->tail.prev = &list->head;
c0003863:	8b 55 08             	mov    0x8(%ebp),%edx
c0003866:	8b 45 08             	mov    0x8(%ebp),%eax
c0003869:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/lib/kernel/list.c:10
	list->tail.next = NULL;
c000386c:	8b 45 08             	mov    0x8(%ebp),%eax
c000386f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/lib/kernel/list.c:11
}
c0003876:	90                   	nop
c0003877:	5d                   	pop    %ebp
c0003878:	c3                   	ret    

c0003879 <list_insert_before>:
list_insert_before():
/work/x86_os_my/lib/kernel/list.c:14

/* 把链表元素elem插入在元素before之前 */
void list_insert_before(struct list_elem* before, struct list_elem* elem) { 
c0003879:	55                   	push   %ebp
c000387a:	89 e5                	mov    %esp,%ebp
c000387c:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:15
	enum intr_status old_status = intr_disable();
c000387f:	e8 e7 e1 ff ff       	call   c0001a6b <intr_disable>
c0003884:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:18

	/* 将before前驱元素的后继元素更新为elem, 暂时使before脱离链表*/ 
	before->prev->next = elem; 
c0003887:	8b 45 08             	mov    0x8(%ebp),%eax
c000388a:	8b 00                	mov    (%eax),%eax
c000388c:	8b 55 0c             	mov    0xc(%ebp),%edx
c000388f:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:22

	/* 更新elem自己的前驱结点为before的前驱,
	* 更新elem自己的后继结点为before, 于是before又回到链表 */
	elem->prev = before->prev;
c0003892:	8b 45 08             	mov    0x8(%ebp),%eax
c0003895:	8b 10                	mov    (%eax),%edx
c0003897:	8b 45 0c             	mov    0xc(%ebp),%eax
c000389a:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:23
	elem->next = before;
c000389c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000389f:	8b 55 08             	mov    0x8(%ebp),%edx
c00038a2:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:26

	/* 更新before的前驱结点为elem */
	before->prev = elem;
c00038a5:	8b 45 08             	mov    0x8(%ebp),%eax
c00038a8:	8b 55 0c             	mov    0xc(%ebp),%edx
c00038ab:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:28

	intr_set_status(old_status);
c00038ad:	83 ec 0c             	sub    $0xc,%esp
c00038b0:	ff 75 f4             	pushl  -0xc(%ebp)
c00038b3:	e8 dc e1 ff ff       	call   c0001a94 <intr_set_status>
c00038b8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:29
}
c00038bb:	90                   	nop
c00038bc:	c9                   	leave  
c00038bd:	c3                   	ret    

c00038be <list_push>:
list_push():
/work/x86_os_my/lib/kernel/list.c:32

/* 添加元素到列表队首,类似栈push操作 */
void list_push(struct list* plist, struct list_elem* elem) {
c00038be:	55                   	push   %ebp
c00038bf:	89 e5                	mov    %esp,%ebp
c00038c1:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/list.c:33
	list_insert_before(plist->head.next, elem); // 在队头插入elem
c00038c4:	8b 45 08             	mov    0x8(%ebp),%eax
c00038c7:	8b 40 04             	mov    0x4(%eax),%eax
c00038ca:	83 ec 08             	sub    $0x8,%esp
c00038cd:	ff 75 0c             	pushl  0xc(%ebp)
c00038d0:	50                   	push   %eax
c00038d1:	e8 a3 ff ff ff       	call   c0003879 <list_insert_before>
c00038d6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:34
}
c00038d9:	90                   	nop
c00038da:	c9                   	leave  
c00038db:	c3                   	ret    

c00038dc <list_append>:
list_append():
/work/x86_os_my/lib/kernel/list.c:37

/* 追加元素到链表队尾,类似队列的先进先出操作 */
void list_append(struct list* plist, struct list_elem* elem) {
c00038dc:	55                   	push   %ebp
c00038dd:	89 e5                	mov    %esp,%ebp
c00038df:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/list.c:38
	list_insert_before(&plist->tail, elem);     // 在队尾的前面插入
c00038e2:	8b 45 08             	mov    0x8(%ebp),%eax
c00038e5:	83 c0 08             	add    $0x8,%eax
c00038e8:	83 ec 08             	sub    $0x8,%esp
c00038eb:	ff 75 0c             	pushl  0xc(%ebp)
c00038ee:	50                   	push   %eax
c00038ef:	e8 85 ff ff ff       	call   c0003879 <list_insert_before>
c00038f4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:39
}
c00038f7:	90                   	nop
c00038f8:	c9                   	leave  
c00038f9:	c3                   	ret    

c00038fa <list_remove>:
list_remove():
/work/x86_os_my/lib/kernel/list.c:42

/* 使元素pelem脱离链表 */
void list_remove(struct list_elem* pelem) {
c00038fa:	55                   	push   %ebp
c00038fb:	89 e5                	mov    %esp,%ebp
c00038fd:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:43
	enum intr_status old_status = intr_disable();
c0003900:	e8 66 e1 ff ff       	call   c0001a6b <intr_disable>
c0003905:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:45

	pelem->prev->next = pelem->next;
c0003908:	8b 45 08             	mov    0x8(%ebp),%eax
c000390b:	8b 00                	mov    (%eax),%eax
c000390d:	8b 55 08             	mov    0x8(%ebp),%edx
c0003910:	8b 52 04             	mov    0x4(%edx),%edx
c0003913:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:46
	pelem->next->prev = pelem->prev;
c0003916:	8b 45 08             	mov    0x8(%ebp),%eax
c0003919:	8b 40 04             	mov    0x4(%eax),%eax
c000391c:	8b 55 08             	mov    0x8(%ebp),%edx
c000391f:	8b 12                	mov    (%edx),%edx
c0003921:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:48

	intr_set_status(old_status);
c0003923:	83 ec 0c             	sub    $0xc,%esp
c0003926:	ff 75 f4             	pushl  -0xc(%ebp)
c0003929:	e8 66 e1 ff ff       	call   c0001a94 <intr_set_status>
c000392e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:49
}
c0003931:	90                   	nop
c0003932:	c9                   	leave  
c0003933:	c3                   	ret    

c0003934 <list_pop>:
list_pop():
/work/x86_os_my/lib/kernel/list.c:52

/* 将链表第一个元素弹出并返回,类似栈的pop操作 */
struct list_elem* list_pop(struct list* plist) {
c0003934:	55                   	push   %ebp
c0003935:	89 e5                	mov    %esp,%ebp
c0003937:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:53
	struct list_elem* elem = plist->head.next;
c000393a:	8b 45 08             	mov    0x8(%ebp),%eax
c000393d:	8b 40 04             	mov    0x4(%eax),%eax
c0003940:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:54
	list_remove(elem);
c0003943:	83 ec 0c             	sub    $0xc,%esp
c0003946:	ff 75 f4             	pushl  -0xc(%ebp)
c0003949:	e8 ac ff ff ff       	call   c00038fa <list_remove>
c000394e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:55
	return elem;
c0003951:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/kernel/list.c:56
} 
c0003954:	c9                   	leave  
c0003955:	c3                   	ret    

c0003956 <elem_find>:
elem_find():
/work/x86_os_my/lib/kernel/list.c:59

/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */
bool elem_find(struct list* plist, struct list_elem* obj_elem) {
c0003956:	55                   	push   %ebp
c0003957:	89 e5                	mov    %esp,%ebp
c0003959:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:60
	struct list_elem* elem = plist->head.next;
c000395c:	8b 45 08             	mov    0x8(%ebp),%eax
c000395f:	8b 40 04             	mov    0x4(%eax),%eax
c0003962:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:61
	while (elem != &plist->tail) {
c0003965:	eb 18                	jmp    c000397f <elem_find+0x29>
/work/x86_os_my/lib/kernel/list.c:62
	if (elem == obj_elem) {
c0003967:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000396a:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000396d:	75 07                	jne    c0003976 <elem_find+0x20>
/work/x86_os_my/lib/kernel/list.c:63
		return true;
c000396f:	b8 01 00 00 00       	mov    $0x1,%eax
c0003974:	eb 19                	jmp    c000398f <elem_find+0x39>
/work/x86_os_my/lib/kernel/list.c:65
	}
		elem = elem->next;
c0003976:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003979:	8b 40 04             	mov    0x4(%eax),%eax
c000397c:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:61
} 

/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */
bool elem_find(struct list* plist, struct list_elem* obj_elem) {
	struct list_elem* elem = plist->head.next;
	while (elem != &plist->tail) {
c000397f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003982:	83 c0 08             	add    $0x8,%eax
c0003985:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c0003988:	75 dd                	jne    c0003967 <elem_find+0x11>
/work/x86_os_my/lib/kernel/list.c:67
	if (elem == obj_elem) {
		return true;
	}
		elem = elem->next;
	}
	return false;
c000398a:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/kernel/list.c:68
}
c000398f:	c9                   	leave  
c0003990:	c3                   	ret    

c0003991 <list_traversal>:
list_traversal():
/work/x86_os_my/lib/kernel/list.c:74

/* 把列表plist中的每个元素elem和arg传给回调函数func,
 * arg给func用来判断elem是否符合条件.
 * 本函数的功能是遍历列表内所有元素,逐个判断是否有符合条件的元素。
 * 找到符合条件的元素返回元素指针,否则返回NULL. */
struct list_elem* list_traversal(struct list* plist, function func, int arg) {
c0003991:	55                   	push   %ebp
c0003992:	89 e5                	mov    %esp,%ebp
c0003994:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:75
	struct list_elem* elem = plist->head.next;
c0003997:	8b 45 08             	mov    0x8(%ebp),%eax
c000399a:	8b 40 04             	mov    0x4(%eax),%eax
c000399d:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:77
	/* 如果队列为空,就必然没有符合条件的结点,故直接返回NULL */
	if (list_empty(plist)) { 
c00039a0:	83 ec 0c             	sub    $0xc,%esp
c00039a3:	ff 75 08             	pushl  0x8(%ebp)
c00039a6:	e8 78 00 00 00       	call   c0003a23 <list_empty>
c00039ab:	83 c4 10             	add    $0x10,%esp
c00039ae:	85 c0                	test   %eax,%eax
c00039b0:	74 2a                	je     c00039dc <list_traversal+0x4b>
/work/x86_os_my/lib/kernel/list.c:78
		return NULL;
c00039b2:	b8 00 00 00 00       	mov    $0x0,%eax
c00039b7:	eb 33                	jmp    c00039ec <list_traversal+0x5b>
/work/x86_os_my/lib/kernel/list.c:82
	}

	while (elem != &plist->tail) {
	if (func(elem, arg)) {		  // func返回ture则认为该元素在回调函数中符合条件,命中,故停止继续遍历
c00039b9:	83 ec 08             	sub    $0x8,%esp
c00039bc:	ff 75 10             	pushl  0x10(%ebp)
c00039bf:	ff 75 f4             	pushl  -0xc(%ebp)
c00039c2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00039c5:	ff d0                	call   *%eax
c00039c7:	83 c4 10             	add    $0x10,%esp
c00039ca:	85 c0                	test   %eax,%eax
c00039cc:	74 05                	je     c00039d3 <list_traversal+0x42>
/work/x86_os_my/lib/kernel/list.c:83
		return elem;
c00039ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00039d1:	eb 19                	jmp    c00039ec <list_traversal+0x5b>
/work/x86_os_my/lib/kernel/list.c:85
	}					  // 若回调函数func返回true,则继续遍历
		elem = elem->next;	       
c00039d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00039d6:	8b 40 04             	mov    0x4(%eax),%eax
c00039d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:81
	/* 如果队列为空,就必然没有符合条件的结点,故直接返回NULL */
	if (list_empty(plist)) { 
		return NULL;
	}

	while (elem != &plist->tail) {
c00039dc:	8b 45 08             	mov    0x8(%ebp),%eax
c00039df:	83 c0 08             	add    $0x8,%eax
c00039e2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00039e5:	75 d2                	jne    c00039b9 <list_traversal+0x28>
/work/x86_os_my/lib/kernel/list.c:87
	if (func(elem, arg)) {		  // func返回ture则认为该元素在回调函数中符合条件,命中,故停止继续遍历
		return elem;
	}					  // 若回调函数func返回true,则继续遍历
		elem = elem->next;	       
	}
	return NULL;
c00039e7:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/kernel/list.c:88
}
c00039ec:	c9                   	leave  
c00039ed:	c3                   	ret    

c00039ee <list_len>:
list_len():
/work/x86_os_my/lib/kernel/list.c:91

/* 返回链表长度 */
uint32_t list_len(struct list* plist) {
c00039ee:	55                   	push   %ebp
c00039ef:	89 e5                	mov    %esp,%ebp
c00039f1:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:92
	struct list_elem* elem = plist->head.next;
c00039f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00039f7:	8b 40 04             	mov    0x4(%eax),%eax
c00039fa:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:93
	uint32_t length = 0;
c00039fd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
/work/x86_os_my/lib/kernel/list.c:94
	while (elem != &plist->tail) {
c0003a04:	eb 0d                	jmp    c0003a13 <list_len+0x25>
/work/x86_os_my/lib/kernel/list.c:95
		length++; 
c0003a06:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
/work/x86_os_my/lib/kernel/list.c:96
		elem = elem->next;
c0003a0a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003a0d:	8b 40 04             	mov    0x4(%eax),%eax
c0003a10:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:94

/* 返回链表长度 */
uint32_t list_len(struct list* plist) {
	struct list_elem* elem = plist->head.next;
	uint32_t length = 0;
	while (elem != &plist->tail) {
c0003a13:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a16:	83 c0 08             	add    $0x8,%eax
c0003a19:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c0003a1c:	75 e8                	jne    c0003a06 <list_len+0x18>
/work/x86_os_my/lib/kernel/list.c:98
		length++; 
		elem = elem->next;
	}
	return length;
c0003a1e:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/kernel/list.c:99
}
c0003a21:	c9                   	leave  
c0003a22:	c3                   	ret    

c0003a23 <list_empty>:
list_empty():
/work/x86_os_my/lib/kernel/list.c:102

/* 判断链表是否为空,空时返回true,否则返回false */
bool list_empty(struct list* plist) {		// 判断队列是否为空
c0003a23:	55                   	push   %ebp
c0003a24:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/lib/kernel/list.c:103
	return (plist->head.next == &plist->tail ? true : false);
c0003a26:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a29:	8b 40 04             	mov    0x4(%eax),%eax
c0003a2c:	8b 55 08             	mov    0x8(%ebp),%edx
c0003a2f:	83 c2 08             	add    $0x8,%edx
c0003a32:	39 d0                	cmp    %edx,%eax
c0003a34:	0f 94 c0             	sete   %al
c0003a37:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/lib/kernel/list.c:104
}
c0003a3a:	5d                   	pop    %ebp
c0003a3b:	c3                   	ret    
c0003a3c:	66 90                	xchg   %ax,%ax
c0003a3e:	66 90                	xchg   %ax,%ax

c0003a40 <switch_to>:
switch_to():
c0003a40:	56                   	push   %esi
c0003a41:	57                   	push   %edi
c0003a42:	53                   	push   %ebx
c0003a43:	55                   	push   %ebp
c0003a44:	8b 44 24 14          	mov    0x14(%esp),%eax
c0003a48:	89 20                	mov    %esp,(%eax)
c0003a4a:	8b 44 24 18          	mov    0x18(%esp),%eax
c0003a4e:	8b 20                	mov    (%eax),%esp
c0003a50:	5d                   	pop    %ebp
c0003a51:	5b                   	pop    %ebx
c0003a52:	5f                   	pop    %edi
c0003a53:	5e                   	pop    %esi
c0003a54:	c3                   	ret    

c0003a55 <console_init>:
console_init():
/work/x86_os_my/device/console.c:9
#include "sync.h"
#include "thread.h"
static struct lock console_lock;	// 控制台锁

/* 初始化终端 */
void console_init() {
c0003a55:	55                   	push   %ebp
c0003a56:	89 e5                	mov    %esp,%ebp
c0003a58:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:10
	lock_init(&console_lock);
c0003a5b:	83 ec 0c             	sub    $0xc,%esp
c0003a5e:	68 90 75 00 c0       	push   $0xc0007590
c0003a63:	e8 cd 00 00 00       	call   c0003b35 <lock_init>
c0003a68:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:11
}
c0003a6b:	90                   	nop
c0003a6c:	c9                   	leave  
c0003a6d:	c3                   	ret    

c0003a6e <console_acquire>:
console_acquire():
/work/x86_os_my/device/console.c:14

/* 获取终端 */
void console_acquire() {
c0003a6e:	55                   	push   %ebp
c0003a6f:	89 e5                	mov    %esp,%ebp
c0003a71:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:15
	lock_acquire(&console_lock);
c0003a74:	83 ec 0c             	sub    $0xc,%esp
c0003a77:	68 90 75 00 c0       	push   $0xc0007590
c0003a7c:	e8 8e 02 00 00       	call   c0003d0f <lock_acquire>
c0003a81:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:16
}
c0003a84:	90                   	nop
c0003a85:	c9                   	leave  
c0003a86:	c3                   	ret    

c0003a87 <console_release>:
console_release():
/work/x86_os_my/device/console.c:19

/* 释放终端 */
void console_release() {
c0003a87:	55                   	push   %ebp
c0003a88:	89 e5                	mov    %esp,%ebp
c0003a8a:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:20
	lock_release(&console_lock);
c0003a8d:	83 ec 0c             	sub    $0xc,%esp
c0003a90:	68 90 75 00 c0       	push   $0xc0007590
c0003a95:	e8 ec 02 00 00       	call   c0003d86 <lock_release>
c0003a9a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:21
}
c0003a9d:	90                   	nop
c0003a9e:	c9                   	leave  
c0003a9f:	c3                   	ret    

c0003aa0 <console_put_str>:
console_put_str():
/work/x86_os_my/device/console.c:24

/* 终端中输出字符串 */
void console_put_str(char* str) {
c0003aa0:	55                   	push   %ebp
c0003aa1:	89 e5                	mov    %esp,%ebp
c0003aa3:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:25
	console_acquire();
c0003aa6:	e8 c3 ff ff ff       	call   c0003a6e <console_acquire>
/work/x86_os_my/device/console.c:26
	put_str(str);
c0003aab:	83 ec 0c             	sub    $0xc,%esp
c0003aae:	ff 75 08             	pushl  0x8(%ebp)
c0003ab1:	e8 6a e7 ff ff       	call   c0002220 <put_str>
c0003ab6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:27
	console_release();
c0003ab9:	e8 c9 ff ff ff       	call   c0003a87 <console_release>
/work/x86_os_my/device/console.c:28
}
c0003abe:	90                   	nop
c0003abf:	c9                   	leave  
c0003ac0:	c3                   	ret    

c0003ac1 <console_put_char>:
console_put_char():
/work/x86_os_my/device/console.c:31

/* 终端中输出字符 */
void console_put_char(uint8_t char_asci) {
c0003ac1:	55                   	push   %ebp
c0003ac2:	89 e5                	mov    %esp,%ebp
c0003ac4:	83 ec 18             	sub    $0x18,%esp
c0003ac7:	8b 45 08             	mov    0x8(%ebp),%eax
c0003aca:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/console.c:32
	console_acquire();
c0003acd:	e8 9c ff ff ff       	call   c0003a6e <console_acquire>
/work/x86_os_my/device/console.c:33
	put_char(char_asci);
c0003ad2:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0003ad6:	83 ec 0c             	sub    $0xc,%esp
c0003ad9:	50                   	push   %eax
c0003ada:	e8 5f e7 ff ff       	call   c000223e <put_char>
c0003adf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:34
	console_release();
c0003ae2:	e8 a0 ff ff ff       	call   c0003a87 <console_release>
/work/x86_os_my/device/console.c:35
}
c0003ae7:	90                   	nop
c0003ae8:	c9                   	leave  
c0003ae9:	c3                   	ret    

c0003aea <console_put_int>:
console_put_int():
/work/x86_os_my/device/console.c:38

/* 终端中输出16进制整数 */
void console_put_int(uint32_t num) {
c0003aea:	55                   	push   %ebp
c0003aeb:	89 e5                	mov    %esp,%ebp
c0003aed:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:39
	console_acquire();
c0003af0:	e8 79 ff ff ff       	call   c0003a6e <console_acquire>
/work/x86_os_my/device/console.c:40
	put_int(num);
c0003af5:	83 ec 0c             	sub    $0xc,%esp
c0003af8:	ff 75 08             	pushl  0x8(%ebp)
c0003afb:	e8 0b e8 ff ff       	call   c000230b <put_int>
c0003b00:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:41
	console_release();
c0003b03:	e8 7f ff ff ff       	call   c0003a87 <console_release>
/work/x86_os_my/device/console.c:42
}
c0003b08:	90                   	nop
c0003b09:	c9                   	leave  
c0003b0a:	c3                   	ret    

c0003b0b <sema_init>:
sema_init():
/work/x86_os_my/thread/sync.c:8
#include "global.h"
#include "debug.h"
#include "interrupt.h"

/* 初始化信号量 */
void sema_init(struct semaphore* psema, uint8_t value) {
c0003b0b:	55                   	push   %ebp
c0003b0c:	89 e5                	mov    %esp,%ebp
c0003b0e:	83 ec 18             	sub    $0x18,%esp
c0003b11:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003b14:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:9
	psema->value = value;       // 为信号量赋初值
c0003b17:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b1a:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0003b1e:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:10
	list_init(&psema->waiters); //初始化信号量的等待队列
c0003b20:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b23:	83 c0 04             	add    $0x4,%eax
c0003b26:	83 ec 0c             	sub    $0xc,%esp
c0003b29:	50                   	push   %eax
c0003b2a:	e8 1c fd ff ff       	call   c000384b <list_init>
c0003b2f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:11
}
c0003b32:	90                   	nop
c0003b33:	c9                   	leave  
c0003b34:	c3                   	ret    

c0003b35 <lock_init>:
lock_init():
/work/x86_os_my/thread/sync.c:14

/* 初始化锁plock */
void lock_init(struct lock* plock) {
c0003b35:	55                   	push   %ebp
c0003b36:	89 e5                	mov    %esp,%ebp
c0003b38:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/sync.c:15
	plock->holder = NULL;
c0003b3b:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b3e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:16
	plock->holder_repeat_nr = 0;
c0003b44:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b47:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:17
	sema_init(&plock->semaphore, 1);  // 信号量初值为1
c0003b4e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b51:	83 c0 04             	add    $0x4,%eax
c0003b54:	83 ec 08             	sub    $0x8,%esp
c0003b57:	6a 01                	push   $0x1
c0003b59:	50                   	push   %eax
c0003b5a:	e8 ac ff ff ff       	call   c0003b0b <sema_init>
c0003b5f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:18
}
c0003b62:	90                   	nop
c0003b63:	c9                   	leave  
c0003b64:	c3                   	ret    

c0003b65 <sema_down>:
sema_down():
/work/x86_os_my/thread/sync.c:21

/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
c0003b65:	55                   	push   %ebp
c0003b66:	89 e5                	mov    %esp,%ebp
c0003b68:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:23
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
c0003b6b:	e8 fb de ff ff       	call   c0001a6b <intr_disable>
c0003b70:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:25
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c0003b73:	e9 98 00 00 00       	jmp    c0003c10 <sema_down+0xab>
/work/x86_os_my/thread/sync.c:26
		ASSERT(!elem_find(&psema->waiters, &running_thread()->general_tag));
c0003b78:	e8 0d f7 ff ff       	call   c000328a <running_thread>
c0003b7d:	8d 50 24             	lea    0x24(%eax),%edx
c0003b80:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b83:	83 c0 04             	add    $0x4,%eax
c0003b86:	83 ec 08             	sub    $0x8,%esp
c0003b89:	52                   	push   %edx
c0003b8a:	50                   	push   %eax
c0003b8b:	e8 c6 fd ff ff       	call   c0003956 <elem_find>
c0003b90:	83 c4 10             	add    $0x10,%esp
c0003b93:	85 c0                	test   %eax,%eax
c0003b95:	74 19                	je     c0003bb0 <sema_down+0x4b>
/work/x86_os_my/thread/sync.c:26 (discriminator 1)
c0003b97:	68 44 53 00 c0       	push   $0xc0005344
c0003b9c:	68 48 54 00 c0       	push   $0xc0005448
c0003ba1:	6a 1a                	push   $0x1a
c0003ba3:	68 80 53 00 c0       	push   $0xc0005380
c0003ba8:	e8 e5 e7 ff ff       	call   c0002392 <panic_spin>
c0003bad:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:28
		/* 当前线程不应该已在信号量的waiters队列中 */
		if (elem_find(&psema->waiters, &running_thread()->general_tag)) {
c0003bb0:	e8 d5 f6 ff ff       	call   c000328a <running_thread>
c0003bb5:	8d 50 24             	lea    0x24(%eax),%edx
c0003bb8:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bbb:	83 c0 04             	add    $0x4,%eax
c0003bbe:	83 ec 08             	sub    $0x8,%esp
c0003bc1:	52                   	push   %edx
c0003bc2:	50                   	push   %eax
c0003bc3:	e8 8e fd ff ff       	call   c0003956 <elem_find>
c0003bc8:	83 c4 10             	add    $0x10,%esp
c0003bcb:	85 c0                	test   %eax,%eax
c0003bcd:	74 19                	je     c0003be8 <sema_down+0x83>
/work/x86_os_my/thread/sync.c:29
			PANIC("sema_down: thread blocked has been in waiters_list\n");
c0003bcf:	68 90 53 00 c0       	push   $0xc0005390
c0003bd4:	68 48 54 00 c0       	push   $0xc0005448
c0003bd9:	6a 1d                	push   $0x1d
c0003bdb:	68 80 53 00 c0       	push   $0xc0005380
c0003be0:	e8 ad e7 ff ff       	call   c0002392 <panic_spin>
c0003be5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:32
		}
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
c0003be8:	e8 9d f6 ff ff       	call   c000328a <running_thread>
c0003bed:	8d 50 24             	lea    0x24(%eax),%edx
c0003bf0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bf3:	83 c0 04             	add    $0x4,%eax
c0003bf6:	83 ec 08             	sub    $0x8,%esp
c0003bf9:	52                   	push   %edx
c0003bfa:	50                   	push   %eax
c0003bfb:	e8 dc fc ff ff       	call   c00038dc <list_append>
c0003c00:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:33
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
c0003c03:	83 ec 0c             	sub    $0xc,%esp
c0003c06:	6a 02                	push   $0x2
c0003c08:	e8 83 fa ff ff       	call   c0003690 <thread_block>
c0003c0d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:25
/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c0003c10:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c13:	0f b6 00             	movzbl (%eax),%eax
c0003c16:	84 c0                	test   %al,%al
c0003c18:	0f 84 5a ff ff ff    	je     c0003b78 <sema_down+0x13>
/work/x86_os_my/thread/sync.c:36
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
	}
	/* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*/
	psema->value--;
c0003c1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c21:	0f b6 00             	movzbl (%eax),%eax
c0003c24:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003c27:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c2a:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:37
	ASSERT(psema->value == 0);
c0003c2c:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c2f:	0f b6 00             	movzbl (%eax),%eax
c0003c32:	84 c0                	test   %al,%al
c0003c34:	74 19                	je     c0003c4f <sema_down+0xea>
/work/x86_os_my/thread/sync.c:37 (discriminator 1)
c0003c36:	68 c4 53 00 c0       	push   $0xc00053c4
c0003c3b:	68 48 54 00 c0       	push   $0xc0005448
c0003c40:	6a 25                	push   $0x25
c0003c42:	68 80 53 00 c0       	push   $0xc0005380
c0003c47:	e8 46 e7 ff ff       	call   c0002392 <panic_spin>
c0003c4c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:40
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c0003c4f:	83 ec 0c             	sub    $0xc,%esp
c0003c52:	ff 75 f4             	pushl  -0xc(%ebp)
c0003c55:	e8 3a de ff ff       	call   c0001a94 <intr_set_status>
c0003c5a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:41
}
c0003c5d:	90                   	nop
c0003c5e:	c9                   	leave  
c0003c5f:	c3                   	ret    

c0003c60 <sema_up>:
sema_up():
/work/x86_os_my/thread/sync.c:44

/* 信号量的up操作 */
void sema_up(struct semaphore* psema) {
c0003c60:	55                   	push   %ebp
c0003c61:	89 e5                	mov    %esp,%ebp
c0003c63:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:46
	/* 关中断,保证原子操作 */
	enum intr_status old_status = intr_disable();
c0003c66:	e8 00 de ff ff       	call   c0001a6b <intr_disable>
c0003c6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:48
	
	ASSERT(psema->value == 0);
c0003c6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c71:	0f b6 00             	movzbl (%eax),%eax
c0003c74:	84 c0                	test   %al,%al
c0003c76:	74 19                	je     c0003c91 <sema_up+0x31>
/work/x86_os_my/thread/sync.c:48 (discriminator 1)
c0003c78:	68 c4 53 00 c0       	push   $0xc00053c4
c0003c7d:	68 54 54 00 c0       	push   $0xc0005454
c0003c82:	6a 30                	push   $0x30
c0003c84:	68 80 53 00 c0       	push   $0xc0005380
c0003c89:	e8 04 e7 ff ff       	call   c0002392 <panic_spin>
c0003c8e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:49
	if (!list_empty(&psema->waiters)) {
c0003c91:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c94:	83 c0 04             	add    $0x4,%eax
c0003c97:	83 ec 0c             	sub    $0xc,%esp
c0003c9a:	50                   	push   %eax
c0003c9b:	e8 83 fd ff ff       	call   c0003a23 <list_empty>
c0003ca0:	83 c4 10             	add    $0x10,%esp
c0003ca3:	85 c0                	test   %eax,%eax
c0003ca5:	75 26                	jne    c0003ccd <sema_up+0x6d>
/work/x86_os_my/thread/sync.c:50
		struct task_struct* thread_blocked = elem2entry(struct task_struct, general_tag, list_pop(&psema->waiters));
c0003ca7:	8b 45 08             	mov    0x8(%ebp),%eax
c0003caa:	83 c0 04             	add    $0x4,%eax
c0003cad:	83 ec 0c             	sub    $0xc,%esp
c0003cb0:	50                   	push   %eax
c0003cb1:	e8 7e fc ff ff       	call   c0003934 <list_pop>
c0003cb6:	83 c4 10             	add    $0x10,%esp
c0003cb9:	83 e8 24             	sub    $0x24,%eax
c0003cbc:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/sync.c:51
		thread_unblock(thread_blocked);
c0003cbf:	83 ec 0c             	sub    $0xc,%esp
c0003cc2:	ff 75 f0             	pushl  -0x10(%ebp)
c0003cc5:	e8 29 fa ff ff       	call   c00036f3 <thread_unblock>
c0003cca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:53
	}
	psema->value++;
c0003ccd:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cd0:	0f b6 00             	movzbl (%eax),%eax
c0003cd3:	8d 50 01             	lea    0x1(%eax),%edx
c0003cd6:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cd9:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:54
	ASSERT(psema->value == 1);
c0003cdb:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cde:	0f b6 00             	movzbl (%eax),%eax
c0003ce1:	3c 01                	cmp    $0x1,%al
c0003ce3:	74 19                	je     c0003cfe <sema_up+0x9e>
/work/x86_os_my/thread/sync.c:54 (discriminator 1)
c0003ce5:	68 d6 53 00 c0       	push   $0xc00053d6
c0003cea:	68 54 54 00 c0       	push   $0xc0005454
c0003cef:	6a 36                	push   $0x36
c0003cf1:	68 80 53 00 c0       	push   $0xc0005380
c0003cf6:	e8 97 e6 ff ff       	call   c0002392 <panic_spin>
c0003cfb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:57
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c0003cfe:	83 ec 0c             	sub    $0xc,%esp
c0003d01:	ff 75 f4             	pushl  -0xc(%ebp)
c0003d04:	e8 8b dd ff ff       	call   c0001a94 <intr_set_status>
c0003d09:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:58
}
c0003d0c:	90                   	nop
c0003d0d:	c9                   	leave  
c0003d0e:	c3                   	ret    

c0003d0f <lock_acquire>:
lock_acquire():
/work/x86_os_my/thread/sync.c:61

/* 获取锁plock */
void lock_acquire(struct lock* plock) {
c0003d0f:	55                   	push   %ebp
c0003d10:	89 e5                	mov    %esp,%ebp
c0003d12:	53                   	push   %ebx
c0003d13:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:63
	/* 排除曾经自己已经持有锁但还未将其释放的情况。*/
	if (plock->holder != running_thread()) {
c0003d16:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d19:	8b 18                	mov    (%eax),%ebx
c0003d1b:	e8 6a f5 ff ff       	call   c000328a <running_thread>
c0003d20:	39 c3                	cmp    %eax,%ebx
c0003d22:	74 4d                	je     c0003d71 <lock_acquire+0x62>
/work/x86_os_my/thread/sync.c:64
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
c0003d24:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d27:	83 c0 04             	add    $0x4,%eax
c0003d2a:	83 ec 0c             	sub    $0xc,%esp
c0003d2d:	50                   	push   %eax
c0003d2e:	e8 32 fe ff ff       	call   c0003b65 <sema_down>
c0003d33:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:65
		plock->holder = running_thread();
c0003d36:	e8 4f f5 ff ff       	call   c000328a <running_thread>
c0003d3b:	89 c2                	mov    %eax,%edx
c0003d3d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d40:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/sync.c:66
		ASSERT(plock->holder_repeat_nr == 0);
c0003d42:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d45:	8b 40 18             	mov    0x18(%eax),%eax
c0003d48:	85 c0                	test   %eax,%eax
c0003d4a:	74 19                	je     c0003d65 <lock_acquire+0x56>
/work/x86_os_my/thread/sync.c:66 (discriminator 1)
c0003d4c:	68 e8 53 00 c0       	push   $0xc00053e8
c0003d51:	68 5c 54 00 c0       	push   $0xc000545c
c0003d56:	6a 42                	push   $0x42
c0003d58:	68 80 53 00 c0       	push   $0xc0005380
c0003d5d:	e8 30 e6 ff ff       	call   c0002392 <panic_spin>
c0003d62:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:67
		plock->holder_repeat_nr = 1;
c0003d65:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d68:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	} else {
		plock->holder_repeat_nr++;
	}
}
c0003d6f:	eb 0f                	jmp    c0003d80 <lock_acquire+0x71>
/work/x86_os_my/thread/sync.c:69
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
		plock->holder = running_thread();
		ASSERT(plock->holder_repeat_nr == 0);
		plock->holder_repeat_nr = 1;
	} else {
		plock->holder_repeat_nr++;
c0003d71:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d74:	8b 40 18             	mov    0x18(%eax),%eax
c0003d77:	8d 50 01             	lea    0x1(%eax),%edx
c0003d7a:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d7d:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	}
}
c0003d80:	90                   	nop
c0003d81:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0003d84:	c9                   	leave  
c0003d85:	c3                   	ret    

c0003d86 <lock_release>:
lock_release():
/work/x86_os_my/thread/sync.c:74

/* 释放锁plock */
void lock_release(struct lock* plock) {
c0003d86:	55                   	push   %ebp
c0003d87:	89 e5                	mov    %esp,%ebp
c0003d89:	53                   	push   %ebx
c0003d8a:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:75
	ASSERT(plock->holder == running_thread());
c0003d8d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d90:	8b 18                	mov    (%eax),%ebx
c0003d92:	e8 f3 f4 ff ff       	call   c000328a <running_thread>
c0003d97:	39 c3                	cmp    %eax,%ebx
c0003d99:	74 19                	je     c0003db4 <lock_release+0x2e>
/work/x86_os_my/thread/sync.c:75 (discriminator 1)
c0003d9b:	68 08 54 00 c0       	push   $0xc0005408
c0003da0:	68 6c 54 00 c0       	push   $0xc000546c
c0003da5:	6a 4b                	push   $0x4b
c0003da7:	68 80 53 00 c0       	push   $0xc0005380
c0003dac:	e8 e1 e5 ff ff       	call   c0002392 <panic_spin>
c0003db1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:76
	if (plock->holder_repeat_nr > 1) {
c0003db4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003db7:	8b 40 18             	mov    0x18(%eax),%eax
c0003dba:	83 f8 01             	cmp    $0x1,%eax
c0003dbd:	76 11                	jbe    c0003dd0 <lock_release+0x4a>
/work/x86_os_my/thread/sync.c:77
		plock->holder_repeat_nr--;
c0003dbf:	8b 45 08             	mov    0x8(%ebp),%eax
c0003dc2:	8b 40 18             	mov    0x18(%eax),%eax
c0003dc5:	8d 50 ff             	lea    -0x1(%eax),%edx
c0003dc8:	8b 45 08             	mov    0x8(%ebp),%eax
c0003dcb:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:78
		return;
c0003dce:	eb 49                	jmp    c0003e19 <lock_release+0x93>
/work/x86_os_my/thread/sync.c:80
	}
	ASSERT(plock->holder_repeat_nr == 1);
c0003dd0:	8b 45 08             	mov    0x8(%ebp),%eax
c0003dd3:	8b 40 18             	mov    0x18(%eax),%eax
c0003dd6:	83 f8 01             	cmp    $0x1,%eax
c0003dd9:	74 19                	je     c0003df4 <lock_release+0x6e>
/work/x86_os_my/thread/sync.c:80 (discriminator 1)
c0003ddb:	68 2a 54 00 c0       	push   $0xc000542a
c0003de0:	68 6c 54 00 c0       	push   $0xc000546c
c0003de5:	6a 50                	push   $0x50
c0003de7:	68 80 53 00 c0       	push   $0xc0005380
c0003dec:	e8 a1 e5 ff ff       	call   c0002392 <panic_spin>
c0003df1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:82

	plock->holder = NULL;			// 把锁的持有者置空放在V操作之前
c0003df4:	8b 45 08             	mov    0x8(%ebp),%eax
c0003df7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:83
	plock->holder_repeat_nr = 0;
c0003dfd:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e00:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:84
	sema_up(&plock->semaphore);		// 信号量的V操作,也是原子操作
c0003e07:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e0a:	83 c0 04             	add    $0x4,%eax
c0003e0d:	83 ec 0c             	sub    $0xc,%esp
c0003e10:	50                   	push   %eax
c0003e11:	e8 4a fe ff ff       	call   c0003c60 <sema_up>
c0003e16:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:85
}
c0003e19:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0003e1c:	c9                   	leave  
c0003e1d:	c3                   	ret    

c0003e1e <inb>:
inb():
/work/x86_os_my/lib/kernel/io.h:36
   asm volatile ("cld; rep outsw" : "+S" (addr), "+c" (word_cnt) : "d" (port));
/******************************************************/
}

/* 将从端口port读入的一个字节返回 */
static inline uint8_t inb(uint16_t port) {
c0003e1e:	55                   	push   %ebp
c0003e1f:	89 e5                	mov    %esp,%ebp
c0003e21:	83 ec 14             	sub    $0x14,%esp
c0003e24:	8b 45 08             	mov    0x8(%ebp),%eax
c0003e27:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/io.h:38
   uint8_t data;
   asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0003e2b:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0003e2f:	89 c2                	mov    %eax,%edx
c0003e31:	ec                   	in     (%dx),%al
c0003e32:	88 45 ff             	mov    %al,-0x1(%ebp)
/work/x86_os_my/lib/kernel/io.h:39
   return data;
c0003e35:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
/work/x86_os_my/lib/kernel/io.h:40
}
c0003e39:	c9                   	leave  
c0003e3a:	c3                   	ret    

c0003e3b <intr_keyboard_handler>:
intr_keyboard_handler():
/work/x86_os_my/device/keyboard.c:111
/* 0x3A */	{caps_lock_char, caps_lock_char}
/*其它按键暂不处理*/
};

/* 键盘中断处理程序 */
static void intr_keyboard_handler(void) {
c0003e3b:	55                   	push   %ebp
c0003e3c:	89 e5                	mov    %esp,%ebp
c0003e3e:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/device/keyboard.c:114

/* 这次中断发生前的上一次中断,以下任意三个键是否有按下 */
   bool ctrl_down_last = ctrl_status;	  
c0003e41:	a1 ac 75 00 c0       	mov    0xc00075ac,%eax
c0003e46:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/device/keyboard.c:115
   bool shift_down_last = shift_status;
c0003e49:	a1 b0 75 00 c0       	mov    0xc00075b0,%eax
c0003e4e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/device/keyboard.c:116
   bool caps_lock_last = caps_lock_status;
c0003e51:	a1 b8 75 00 c0       	mov    0xc00075b8,%eax
c0003e56:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/device/keyboard.c:119

   bool break_code;
   uint16_t scancode = inb(KBD_BUF_PORT);
c0003e59:	6a 60                	push   $0x60
c0003e5b:	e8 be ff ff ff       	call   c0003e1e <inb>
c0003e60:	83 c4 04             	add    $0x4,%esp
c0003e63:	0f b6 c0             	movzbl %al,%eax
c0003e66:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:123

/* 若扫描码是e0开头的,表示此键的按下将产生多个扫描码,
 * 所以马上结束此次中断处理函数,等待下一个扫描码进来*/ 
   if (scancode == 0xe0) { 
c0003e6a:	66 81 7d f6 e0 00    	cmpw   $0xe0,-0xa(%ebp)
c0003e70:	75 0f                	jne    c0003e81 <intr_keyboard_handler+0x46>
/work/x86_os_my/device/keyboard.c:124
      ext_scancode = true;    // 打开e0标记
c0003e72:	c7 05 bc 75 00 c0 01 	movl   $0x1,0xc00075bc
c0003e79:	00 00 00 
/work/x86_os_my/device/keyboard.c:125
      return;
c0003e7c:	e9 50 02 00 00       	jmp    c00040d1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:129
   }

/* 如果上次是以0xe0开头,将扫描码合并 */
   if (ext_scancode) {
c0003e81:	a1 bc 75 00 c0       	mov    0xc00075bc,%eax
c0003e86:	85 c0                	test   %eax,%eax
c0003e88:	74 10                	je     c0003e9a <intr_keyboard_handler+0x5f>
/work/x86_os_my/device/keyboard.c:130
      scancode = ((0xe000) | scancode);
c0003e8a:	66 81 4d f6 00 e0    	orw    $0xe000,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:131
      ext_scancode = false;   // 关闭e0标记
c0003e90:	c7 05 bc 75 00 c0 00 	movl   $0x0,0xc00075bc
c0003e97:	00 00 00 
/work/x86_os_my/device/keyboard.c:134
   }   

   break_code = ((scancode & 0x0080) != 0);   // 获取break_code
c0003e9a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0003e9e:	25 80 00 00 00       	and    $0x80,%eax
c0003ea3:	85 c0                	test   %eax,%eax
c0003ea5:	0f 95 c0             	setne  %al
c0003ea8:	0f b6 c0             	movzbl %al,%eax
c0003eab:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/device/keyboard.c:136
   
   if (break_code) {   // 若是断码break_code(按键弹起时产生的扫描码)
c0003eae:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0003eb2:	74 6a                	je     c0003f1e <intr_keyboard_handler+0xe3>
/work/x86_os_my/device/keyboard.c:140

   /* 由于ctrl_r 和alt_r的make_code和break_code都是两字节,
   所以可用下面的方法取make_code,多字节的扫描码暂不处理 */
      uint16_t make_code = (scancode &= 0xff7f);   // 得到其make_code(按键按下时产生的扫描码)
c0003eb4:	66 81 65 f6 7f ff    	andw   $0xff7f,-0xa(%ebp)
c0003eba:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0003ebe:	66 89 45 da          	mov    %ax,-0x26(%ebp)
/work/x86_os_my/device/keyboard.c:143

   /* 若是任意以下三个键弹起了,将状态置为false */
      if (make_code == ctrl_l_make || make_code == ctrl_r_make) {
c0003ec2:	66 83 7d da 1d       	cmpw   $0x1d,-0x26(%ebp)
c0003ec7:	74 08                	je     c0003ed1 <intr_keyboard_handler+0x96>
/work/x86_os_my/device/keyboard.c:143 (discriminator 1)
c0003ec9:	66 81 7d da 1d e0    	cmpw   $0xe01d,-0x26(%ebp)
c0003ecf:	75 0c                	jne    c0003edd <intr_keyboard_handler+0xa2>
/work/x86_os_my/device/keyboard.c:144
	 ctrl_status = false;
c0003ed1:	c7 05 ac 75 00 c0 00 	movl   $0x0,0xc00075ac
c0003ed8:	00 00 00 
c0003edb:	eb 3c                	jmp    c0003f19 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:145
      } else if (make_code == shift_l_make || make_code == shift_r_make) {
c0003edd:	66 83 7d da 2a       	cmpw   $0x2a,-0x26(%ebp)
c0003ee2:	74 07                	je     c0003eeb <intr_keyboard_handler+0xb0>
/work/x86_os_my/device/keyboard.c:145 (discriminator 1)
c0003ee4:	66 83 7d da 36       	cmpw   $0x36,-0x26(%ebp)
c0003ee9:	75 0c                	jne    c0003ef7 <intr_keyboard_handler+0xbc>
/work/x86_os_my/device/keyboard.c:146
	 shift_status = false;
c0003eeb:	c7 05 b0 75 00 c0 00 	movl   $0x0,0xc00075b0
c0003ef2:	00 00 00 
c0003ef5:	eb 22                	jmp    c0003f19 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:147
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
c0003ef7:	66 83 7d da 38       	cmpw   $0x38,-0x26(%ebp)
c0003efc:	74 0c                	je     c0003f0a <intr_keyboard_handler+0xcf>
/work/x86_os_my/device/keyboard.c:147 (discriminator 1)
c0003efe:	66 81 7d da 38 e0    	cmpw   $0xe038,-0x26(%ebp)
c0003f04:	0f 85 c0 01 00 00    	jne    c00040ca <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:148
	 alt_status = false;
c0003f0a:	c7 05 b4 75 00 c0 00 	movl   $0x0,0xc00075b4
c0003f11:	00 00 00 
/work/x86_os_my/device/keyboard.c:151
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c0003f14:	e9 b1 01 00 00       	jmp    c00040ca <intr_keyboard_handler+0x28f>
c0003f19:	e9 ac 01 00 00       	jmp    c00040ca <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:155

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
c0003f1e:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c0003f23:	74 07                	je     c0003f2c <intr_keyboard_handler+0xf1>
/work/x86_os_my/device/keyboard.c:155 (discriminator 1)
c0003f25:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0003f2a:	76 14                	jbe    c0003f40 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:155 (discriminator 3)
c0003f2c:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c0003f32:	74 0c                	je     c0003f40 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:156
	       (scancode == alt_r_make) || \
c0003f34:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0003f3a:	0f 85 78 01 00 00    	jne    c00040b8 <intr_keyboard_handler+0x27d>
/work/x86_os_my/device/keyboard.c:158
	       (scancode == ctrl_r_make)) {
      bool shift = false;  // 判断是否与shift组合,用来在一维数组中索引对应的字符
c0003f40:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:159
      if ((scancode < 0x0e) || (scancode == 0x29) || \
c0003f47:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%ebp)
c0003f4c:	76 3f                	jbe    c0003f8d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 1)
c0003f4e:	66 83 7d f6 29       	cmpw   $0x29,-0xa(%ebp)
c0003f53:	74 38                	je     c0003f8d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 2)
c0003f55:	66 83 7d f6 1a       	cmpw   $0x1a,-0xa(%ebp)
c0003f5a:	74 31                	je     c0003f8d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160
	 (scancode == 0x1a) || (scancode == 0x1b) || \
c0003f5c:	66 83 7d f6 1b       	cmpw   $0x1b,-0xa(%ebp)
c0003f61:	74 2a                	je     c0003f8d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160 (discriminator 1)
c0003f63:	66 83 7d f6 2b       	cmpw   $0x2b,-0xa(%ebp)
c0003f68:	74 23                	je     c0003f8d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161
	 (scancode == 0x2b) || (scancode == 0x27) || \
c0003f6a:	66 83 7d f6 27       	cmpw   $0x27,-0xa(%ebp)
c0003f6f:	74 1c                	je     c0003f8d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161 (discriminator 1)
c0003f71:	66 83 7d f6 28       	cmpw   $0x28,-0xa(%ebp)
c0003f76:	74 15                	je     c0003f8d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162
	 (scancode == 0x28) || (scancode == 0x33) || \
c0003f78:	66 83 7d f6 33       	cmpw   $0x33,-0xa(%ebp)
c0003f7d:	74 0e                	je     c0003f8d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162 (discriminator 1)
c0003f7f:	66 83 7d f6 34       	cmpw   $0x34,-0xa(%ebp)
c0003f84:	74 07                	je     c0003f8d <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:163
	 (scancode == 0x34) || (scancode == 0x35)) {  
c0003f86:	66 83 7d f6 35       	cmpw   $0x35,-0xa(%ebp)
c0003f8b:	75 0f                	jne    c0003f9c <intr_keyboard_handler+0x161>
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c0003f8d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0003f91:	74 3a                	je     c0003fcd <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:177
	    shift = true;
c0003f93:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c0003f9a:	eb 31                	jmp    c0003fcd <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:180
	    shift = true;
	 }
      } else {	  // 默认为字母键
	 if (shift_down_last && caps_lock_last) {  // 如果shift和capslock同时按下
c0003f9c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0003fa0:	74 0f                	je     c0003fb1 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:180 (discriminator 1)
c0003fa2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0003fa6:	74 09                	je     c0003fb1 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:181
	    shift = false;
c0003fa8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0003faf:	eb 1c                	jmp    c0003fcd <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:182
	 } else if (shift_down_last || caps_lock_last) { // 如果shift和capslock任意被按下
c0003fb1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0003fb5:	75 06                	jne    c0003fbd <intr_keyboard_handler+0x182>
/work/x86_os_my/device/keyboard.c:182 (discriminator 1)
c0003fb7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0003fbb:	74 09                	je     c0003fc6 <intr_keyboard_handler+0x18b>
/work/x86_os_my/device/keyboard.c:183
	    shift = true;
c0003fbd:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c0003fc4:	eb 07                	jmp    c0003fcd <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:185
	 } else {
	    shift = false;
c0003fc6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:189
	 }
      }

      uint8_t index = (scancode &= 0x00ff);  // 将扫描码的高字节置0,主要是针对高字节是e0的扫描码.
c0003fcd:	66 81 65 f6 ff 00    	andw   $0xff,-0xa(%ebp)
c0003fd3:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0003fd7:	88 45 d9             	mov    %al,-0x27(%ebp)
/work/x86_os_my/device/keyboard.c:190
      char cur_char = keymap[index][shift];  // 在数组中找到对应的字符
c0003fda:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
c0003fde:	8d 14 00             	lea    (%eax,%eax,1),%edx
c0003fe1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003fe4:	01 d0                	add    %edx,%eax
c0003fe6:	05 e0 70 00 c0       	add    $0xc00070e0,%eax
c0003feb:	0f b6 00             	movzbl (%eax),%eax
c0003fee:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:193

   /* 如果cur_char不为0,也就是ascii码为除'\0'外的字符就加入键盘缓冲区中 */
      if (cur_char) {
c0003ff1:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c0003ff5:	74 54                	je     c000404b <intr_keyboard_handler+0x210>
/work/x86_os_my/device/keyboard.c:200
     /*****************  快捷键ctrl+l和ctrl+u的处理 *********************
      * 下面是把ctrl+l和ctrl+u这两种组合键产生的字符置为:
      * cur_char的asc码-字符a的asc码, 此差值比较小,
      * 属于asc码表中不可见的字符部分.故不会产生可见字符.
      * 我们在shell中将ascii值为l-a和u-a的分别处理为清屏和删除输入的快捷键*/
	 if ((ctrl_down_last && cur_char == 'l') || (ctrl_down_last && cur_char == 'u')) {
c0003ff7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0003ffb:	74 06                	je     c0004003 <intr_keyboard_handler+0x1c8>
/work/x86_os_my/device/keyboard.c:200 (discriminator 1)
c0003ffd:	80 7d ef 6c          	cmpb   $0x6c,-0x11(%ebp)
c0004001:	74 0c                	je     c000400f <intr_keyboard_handler+0x1d4>
/work/x86_os_my/device/keyboard.c:200 (discriminator 3)
c0004003:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0004007:	74 10                	je     c0004019 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:200 (discriminator 4)
c0004009:	80 7d ef 75          	cmpb   $0x75,-0x11(%ebp)
c000400d:	75 0a                	jne    c0004019 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:201
	    cur_char -= 'a';
c000400f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c0004013:	83 e8 61             	sub    $0x61,%eax
c0004016:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:207
	 }
      /****************************************************************/
      
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
c0004019:	83 ec 0c             	sub    $0xc,%esp
c000401c:	68 40 7b 00 c0       	push   $0xc0007b40
c0004021:	e8 58 01 00 00       	call   c000417e <ioq_full>
c0004026:	83 c4 10             	add    $0x10,%esp
c0004029:	85 c0                	test   %eax,%eax
c000402b:	0f 85 9c 00 00 00    	jne    c00040cd <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:208
	    ioq_putchar(&kbd_buf, cur_char);
c0004031:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
c0004035:	83 ec 08             	sub    $0x8,%esp
c0004038:	50                   	push   %eax
c0004039:	68 40 7b 00 c0       	push   $0xc0007b40
c000403e:	e8 0d 03 00 00       	call   c0004350 <ioq_putchar>
c0004043:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:210
	 }
	 return;
c0004046:	e9 82 00 00 00       	jmp    c00040cd <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:214
      }

      /* 记录本次是否按下了下面几类控制键之一,供下次键入时判断组合键 */
      if (scancode == ctrl_l_make || scancode == ctrl_r_make) {
c000404b:	66 83 7d f6 1d       	cmpw   $0x1d,-0xa(%ebp)
c0004050:	74 08                	je     c000405a <intr_keyboard_handler+0x21f>
/work/x86_os_my/device/keyboard.c:214 (discriminator 1)
c0004052:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0004058:	75 0c                	jne    c0004066 <intr_keyboard_handler+0x22b>
/work/x86_os_my/device/keyboard.c:215
	 ctrl_status = true;
c000405a:	c7 05 ac 75 00 c0 01 	movl   $0x1,0xc00075ac
c0004061:	00 00 00 
c0004064:	eb 50                	jmp    c00040b6 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:216
      } else if (scancode == shift_l_make || scancode == shift_r_make) {
c0004066:	66 83 7d f6 2a       	cmpw   $0x2a,-0xa(%ebp)
c000406b:	74 07                	je     c0004074 <intr_keyboard_handler+0x239>
/work/x86_os_my/device/keyboard.c:216 (discriminator 1)
c000406d:	66 83 7d f6 36       	cmpw   $0x36,-0xa(%ebp)
c0004072:	75 0c                	jne    c0004080 <intr_keyboard_handler+0x245>
/work/x86_os_my/device/keyboard.c:217
	 shift_status = true;
c0004074:	c7 05 b0 75 00 c0 01 	movl   $0x1,0xc00075b0
c000407b:	00 00 00 
c000407e:	eb 36                	jmp    c00040b6 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:218
      } else if (scancode == alt_l_make || scancode == alt_r_make) {
c0004080:	66 83 7d f6 38       	cmpw   $0x38,-0xa(%ebp)
c0004085:	74 08                	je     c000408f <intr_keyboard_handler+0x254>
/work/x86_os_my/device/keyboard.c:218 (discriminator 1)
c0004087:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c000408d:	75 0c                	jne    c000409b <intr_keyboard_handler+0x260>
/work/x86_os_my/device/keyboard.c:219
	 alt_status = true;
c000408f:	c7 05 b4 75 00 c0 01 	movl   $0x1,0xc00075b4
c0004096:	00 00 00 
c0004099:	eb 1b                	jmp    c00040b6 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:220
      } else if (scancode == caps_lock_make) {
c000409b:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c00040a0:	75 2e                	jne    c00040d0 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:223
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
c00040a2:	a1 b8 75 00 c0       	mov    0xc00075b8,%eax
c00040a7:	85 c0                	test   %eax,%eax
c00040a9:	0f 94 c0             	sete   %al
c00040ac:	0f b6 c0             	movzbl %al,%eax
c00040af:	a3 b8 75 00 c0       	mov    %eax,0xc00075b8
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c00040b4:	eb 1a                	jmp    c00040d0 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:157 (discriminator 3)
c00040b6:	eb 18                	jmp    c00040d0 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:226
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
c00040b8:	83 ec 0c             	sub    $0xc,%esp
c00040bb:	68 79 54 00 c0       	push   $0xc0005479
c00040c0:	e8 5b e1 ff ff       	call   c0002220 <put_str>
c00040c5:	83 c4 10             	add    $0x10,%esp
c00040c8:	eb 07                	jmp    c00040d1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:151
	 shift_status = false;
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
	 alt_status = false;
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c00040ca:	90                   	nop
c00040cb:	eb 04                	jmp    c00040d1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:210
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
	    ioq_putchar(&kbd_buf, cur_char);
	 }
	 return;
c00040cd:	90                   	nop
c00040ce:	eb 01                	jmp    c00040d1 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c00040d0:	90                   	nop
/work/x86_os_my/device/keyboard.c:228
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
   }
}
c00040d1:	c9                   	leave  
c00040d2:	c3                   	ret    

c00040d3 <keyboard_init>:
keyboard_init():
/work/x86_os_my/device/keyboard.c:231

/* 键盘初始化 */
void keyboard_init() {
c00040d3:	55                   	push   %ebp
c00040d4:	89 e5                	mov    %esp,%ebp
c00040d6:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/keyboard.c:232
   put_str("keyboard init start\n");
c00040d9:	83 ec 0c             	sub    $0xc,%esp
c00040dc:	68 86 54 00 c0       	push   $0xc0005486
c00040e1:	e8 3a e1 ff ff       	call   c0002220 <put_str>
c00040e6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:233
   ioqueue_init(&kbd_buf);
c00040e9:	83 ec 0c             	sub    $0xc,%esp
c00040ec:	68 40 7b 00 c0       	push   $0xc0007b40
c00040f1:	e8 28 00 00 00       	call   c000411e <ioqueue_init>
c00040f6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:234
   register_handler(0x21, intr_keyboard_handler);
c00040f9:	83 ec 08             	sub    $0x8,%esp
c00040fc:	68 3b 3e 00 c0       	push   $0xc0003e3b
c0004101:	6a 21                	push   $0x21
c0004103:	e8 ce d9 ff ff       	call   c0001ad6 <register_handler>
c0004108:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:235
   put_str("keyboard init done\n");
c000410b:	83 ec 0c             	sub    $0xc,%esp
c000410e:	68 9b 54 00 c0       	push   $0xc000549b
c0004113:	e8 08 e1 ff ff       	call   c0002220 <put_str>
c0004118:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:236
}
c000411b:	90                   	nop
c000411c:	c9                   	leave  
c000411d:	c3                   	ret    

c000411e <ioqueue_init>:
ioqueue_init():
/work/x86_os_my/device/ioqueue.c:7
#include "interrupt.h"
#include "global.h"
#include "debug.h"

/* 初始化io队列ioq */
void ioqueue_init(struct ioqueue* ioq) {
c000411e:	55                   	push   %ebp
c000411f:	89 e5                	mov    %esp,%ebp
c0004121:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:8
   lock_init(&ioq->lock);     // 初始化io队列的锁
c0004124:	8b 45 08             	mov    0x8(%ebp),%eax
c0004127:	83 ec 0c             	sub    $0xc,%esp
c000412a:	50                   	push   %eax
c000412b:	e8 05 fa ff ff       	call   c0003b35 <lock_init>
c0004130:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:9
   ioq->producer = ioq->consumer = NULL;  // 生产者和消费者置空
c0004133:	8b 45 08             	mov    0x8(%ebp),%eax
c0004136:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c000413d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004140:	8b 50 20             	mov    0x20(%eax),%edx
c0004143:	8b 45 08             	mov    0x8(%ebp),%eax
c0004146:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/device/ioqueue.c:10
   ioq->head = ioq->tail = 0; // 队列的首尾指针指向缓冲区数组第0个位置
c0004149:	8b 45 08             	mov    0x8(%ebp),%eax
c000414c:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)
c0004153:	8b 45 08             	mov    0x8(%ebp),%eax
c0004156:	8b 50 68             	mov    0x68(%eax),%edx
c0004159:	8b 45 08             	mov    0x8(%ebp),%eax
c000415c:	89 50 64             	mov    %edx,0x64(%eax)
/work/x86_os_my/device/ioqueue.c:11
}
c000415f:	90                   	nop
c0004160:	c9                   	leave  
c0004161:	c3                   	ret    

c0004162 <next_pos>:
next_pos():
/work/x86_os_my/device/ioqueue.c:14

/* 返回pos在缓冲区中的下一个位置值 */
static int32_t next_pos(int32_t pos) {
c0004162:	55                   	push   %ebp
c0004163:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/device/ioqueue.c:15
   return (pos + 1) % bufsize; 
c0004165:	8b 45 08             	mov    0x8(%ebp),%eax
c0004168:	8d 50 01             	lea    0x1(%eax),%edx
c000416b:	89 d0                	mov    %edx,%eax
c000416d:	c1 f8 1f             	sar    $0x1f,%eax
c0004170:	c1 e8 1a             	shr    $0x1a,%eax
c0004173:	01 c2                	add    %eax,%edx
c0004175:	83 e2 3f             	and    $0x3f,%edx
c0004178:	29 c2                	sub    %eax,%edx
c000417a:	89 d0                	mov    %edx,%eax
/work/x86_os_my/device/ioqueue.c:16
}
c000417c:	5d                   	pop    %ebp
c000417d:	c3                   	ret    

c000417e <ioq_full>:
ioq_full():
/work/x86_os_my/device/ioqueue.c:19

/* 判断队列是否已满 */
bool ioq_full(struct ioqueue* ioq) {
c000417e:	55                   	push   %ebp
c000417f:	89 e5                	mov    %esp,%ebp
c0004181:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:20
   ASSERT(intr_get_status() == INTR_OFF);
c0004184:	e8 29 d9 ff ff       	call   c0001ab2 <intr_get_status>
c0004189:	85 c0                	test   %eax,%eax
c000418b:	74 19                	je     c00041a6 <ioq_full+0x28>
/work/x86_os_my/device/ioqueue.c:20 (discriminator 1)
c000418d:	68 b0 54 00 c0       	push   $0xc00054b0
c0004192:	68 14 55 00 c0       	push   $0xc0005514
c0004197:	6a 14                	push   $0x14
c0004199:	68 ce 54 00 c0       	push   $0xc00054ce
c000419e:	e8 ef e1 ff ff       	call   c0002392 <panic_spin>
c00041a3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:21
   return next_pos(ioq->head) == ioq->tail;
c00041a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00041a9:	8b 40 64             	mov    0x64(%eax),%eax
c00041ac:	83 ec 0c             	sub    $0xc,%esp
c00041af:	50                   	push   %eax
c00041b0:	e8 ad ff ff ff       	call   c0004162 <next_pos>
c00041b5:	83 c4 10             	add    $0x10,%esp
c00041b8:	89 c2                	mov    %eax,%edx
c00041ba:	8b 45 08             	mov    0x8(%ebp),%eax
c00041bd:	8b 40 68             	mov    0x68(%eax),%eax
c00041c0:	39 c2                	cmp    %eax,%edx
c00041c2:	0f 94 c0             	sete   %al
c00041c5:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:22
}
c00041c8:	c9                   	leave  
c00041c9:	c3                   	ret    

c00041ca <ioq_empty>:
ioq_empty():
/work/x86_os_my/device/ioqueue.c:25

/* 判断队列是否已空 */
static bool ioq_empty(struct ioqueue* ioq) {
c00041ca:	55                   	push   %ebp
c00041cb:	89 e5                	mov    %esp,%ebp
c00041cd:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:26
   ASSERT(intr_get_status() == INTR_OFF);
c00041d0:	e8 dd d8 ff ff       	call   c0001ab2 <intr_get_status>
c00041d5:	85 c0                	test   %eax,%eax
c00041d7:	74 19                	je     c00041f2 <ioq_empty+0x28>
/work/x86_os_my/device/ioqueue.c:26 (discriminator 1)
c00041d9:	68 b0 54 00 c0       	push   $0xc00054b0
c00041de:	68 20 55 00 c0       	push   $0xc0005520
c00041e3:	6a 1a                	push   $0x1a
c00041e5:	68 ce 54 00 c0       	push   $0xc00054ce
c00041ea:	e8 a3 e1 ff ff       	call   c0002392 <panic_spin>
c00041ef:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:27
   return ioq->head == ioq->tail;
c00041f2:	8b 45 08             	mov    0x8(%ebp),%eax
c00041f5:	8b 50 64             	mov    0x64(%eax),%edx
c00041f8:	8b 45 08             	mov    0x8(%ebp),%eax
c00041fb:	8b 40 68             	mov    0x68(%eax),%eax
c00041fe:	39 c2                	cmp    %eax,%edx
c0004200:	0f 94 c0             	sete   %al
c0004203:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:28
}
c0004206:	c9                   	leave  
c0004207:	c3                   	ret    

c0004208 <ioq_wait>:
ioq_wait():
/work/x86_os_my/device/ioqueue.c:31

/* 使当前生产者或消费者在此缓冲区上等待 */
static void ioq_wait(struct task_struct** waiter) {
c0004208:	55                   	push   %ebp
c0004209:	89 e5                	mov    %esp,%ebp
c000420b:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:32
   ASSERT(*waiter == NULL && waiter != NULL);
c000420e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004211:	8b 00                	mov    (%eax),%eax
c0004213:	85 c0                	test   %eax,%eax
c0004215:	75 06                	jne    c000421d <ioq_wait+0x15>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 1)
c0004217:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000421b:	75 19                	jne    c0004236 <ioq_wait+0x2e>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 3)
c000421d:	68 e0 54 00 c0       	push   $0xc00054e0
c0004222:	68 2c 55 00 c0       	push   $0xc000552c
c0004227:	6a 20                	push   $0x20
c0004229:	68 ce 54 00 c0       	push   $0xc00054ce
c000422e:	e8 5f e1 ff ff       	call   c0002392 <panic_spin>
c0004233:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:33
   *waiter = running_thread();
c0004236:	e8 4f f0 ff ff       	call   c000328a <running_thread>
c000423b:	89 c2                	mov    %eax,%edx
c000423d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004240:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ioqueue.c:34
   thread_block(TASK_BLOCKED);
c0004242:	83 ec 0c             	sub    $0xc,%esp
c0004245:	6a 02                	push   $0x2
c0004247:	e8 44 f4 ff ff       	call   c0003690 <thread_block>
c000424c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:35
}
c000424f:	90                   	nop
c0004250:	c9                   	leave  
c0004251:	c3                   	ret    

c0004252 <wakeup>:
wakeup():
/work/x86_os_my/device/ioqueue.c:38

/* 唤醒waiter */
static void wakeup(struct task_struct** waiter) {
c0004252:	55                   	push   %ebp
c0004253:	89 e5                	mov    %esp,%ebp
c0004255:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:39
   ASSERT(*waiter != NULL);
c0004258:	8b 45 08             	mov    0x8(%ebp),%eax
c000425b:	8b 00                	mov    (%eax),%eax
c000425d:	85 c0                	test   %eax,%eax
c000425f:	75 19                	jne    c000427a <wakeup+0x28>
/work/x86_os_my/device/ioqueue.c:39 (discriminator 1)
c0004261:	68 02 55 00 c0       	push   $0xc0005502
c0004266:	68 38 55 00 c0       	push   $0xc0005538
c000426b:	6a 27                	push   $0x27
c000426d:	68 ce 54 00 c0       	push   $0xc00054ce
c0004272:	e8 1b e1 ff ff       	call   c0002392 <panic_spin>
c0004277:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:40
   thread_unblock(*waiter); 
c000427a:	8b 45 08             	mov    0x8(%ebp),%eax
c000427d:	8b 00                	mov    (%eax),%eax
c000427f:	83 ec 0c             	sub    $0xc,%esp
c0004282:	50                   	push   %eax
c0004283:	e8 6b f4 ff ff       	call   c00036f3 <thread_unblock>
c0004288:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:41
   *waiter = NULL;
c000428b:	8b 45 08             	mov    0x8(%ebp),%eax
c000428e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/device/ioqueue.c:42
}
c0004294:	90                   	nop
c0004295:	c9                   	leave  
c0004296:	c3                   	ret    

c0004297 <ioq_getchar>:
ioq_getchar():
/work/x86_os_my/device/ioqueue.c:45

/* 消费者从ioq队列中获取一个字符 */
char ioq_getchar(struct ioqueue* ioq) {
c0004297:	55                   	push   %ebp
c0004298:	89 e5                	mov    %esp,%ebp
c000429a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ioqueue.c:46
   ASSERT(intr_get_status() == INTR_OFF);
c000429d:	e8 10 d8 ff ff       	call   c0001ab2 <intr_get_status>
c00042a2:	85 c0                	test   %eax,%eax
c00042a4:	74 4b                	je     c00042f1 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:46 (discriminator 1)
c00042a6:	68 b0 54 00 c0       	push   $0xc00054b0
c00042ab:	68 40 55 00 c0       	push   $0xc0005540
c00042b0:	6a 2e                	push   $0x2e
c00042b2:	68 ce 54 00 c0       	push   $0xc00054ce
c00042b7:	e8 d6 e0 ff ff       	call   c0002392 <panic_spin>
c00042bc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51 (discriminator 1)

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c00042bf:	eb 30                	jmp    c00042f1 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:52
      lock_acquire(&ioq->lock);	 
c00042c1:	8b 45 08             	mov    0x8(%ebp),%eax
c00042c4:	83 ec 0c             	sub    $0xc,%esp
c00042c7:	50                   	push   %eax
c00042c8:	e8 42 fa ff ff       	call   c0003d0f <lock_acquire>
c00042cd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:53
      ioq_wait(&ioq->consumer);
c00042d0:	8b 45 08             	mov    0x8(%ebp),%eax
c00042d3:	83 c0 20             	add    $0x20,%eax
c00042d6:	83 ec 0c             	sub    $0xc,%esp
c00042d9:	50                   	push   %eax
c00042da:	e8 29 ff ff ff       	call   c0004208 <ioq_wait>
c00042df:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:54
      lock_release(&ioq->lock);
c00042e2:	8b 45 08             	mov    0x8(%ebp),%eax
c00042e5:	83 ec 0c             	sub    $0xc,%esp
c00042e8:	50                   	push   %eax
c00042e9:	e8 98 fa ff ff       	call   c0003d86 <lock_release>
c00042ee:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c00042f1:	83 ec 0c             	sub    $0xc,%esp
c00042f4:	ff 75 08             	pushl  0x8(%ebp)
c00042f7:	e8 ce fe ff ff       	call   c00041ca <ioq_empty>
c00042fc:	83 c4 10             	add    $0x10,%esp
c00042ff:	85 c0                	test   %eax,%eax
c0004301:	75 be                	jne    c00042c1 <ioq_getchar+0x2a>
/work/x86_os_my/device/ioqueue.c:57
      lock_acquire(&ioq->lock);	 
      ioq_wait(&ioq->consumer);
      lock_release(&ioq->lock);
   }

   char byte = ioq->buf[ioq->tail];	  // 从缓冲区中取出
c0004303:	8b 45 08             	mov    0x8(%ebp),%eax
c0004306:	8b 40 68             	mov    0x68(%eax),%eax
c0004309:	8b 55 08             	mov    0x8(%ebp),%edx
c000430c:	0f b6 44 02 24       	movzbl 0x24(%edx,%eax,1),%eax
c0004311:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ioqueue.c:58
   ioq->tail = next_pos(ioq->tail);	  // 把读游标移到下一位置
c0004314:	8b 45 08             	mov    0x8(%ebp),%eax
c0004317:	8b 40 68             	mov    0x68(%eax),%eax
c000431a:	83 ec 0c             	sub    $0xc,%esp
c000431d:	50                   	push   %eax
c000431e:	e8 3f fe ff ff       	call   c0004162 <next_pos>
c0004323:	83 c4 10             	add    $0x10,%esp
c0004326:	89 c2                	mov    %eax,%edx
c0004328:	8b 45 08             	mov    0x8(%ebp),%eax
c000432b:	89 50 68             	mov    %edx,0x68(%eax)
/work/x86_os_my/device/ioqueue.c:60

   if (ioq->producer != NULL) {
c000432e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004331:	8b 40 1c             	mov    0x1c(%eax),%eax
c0004334:	85 c0                	test   %eax,%eax
c0004336:	74 12                	je     c000434a <ioq_getchar+0xb3>
/work/x86_os_my/device/ioqueue.c:61
      wakeup(&ioq->producer);		  // 唤醒生产者
c0004338:	8b 45 08             	mov    0x8(%ebp),%eax
c000433b:	83 c0 1c             	add    $0x1c,%eax
c000433e:	83 ec 0c             	sub    $0xc,%esp
c0004341:	50                   	push   %eax
c0004342:	e8 0b ff ff ff       	call   c0004252 <wakeup>
c0004347:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:64
   }

   return byte; 
c000434a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
/work/x86_os_my/device/ioqueue.c:65
}
c000434e:	c9                   	leave  
c000434f:	c3                   	ret    

c0004350 <ioq_putchar>:
ioq_putchar():
/work/x86_os_my/device/ioqueue.c:68

/* 生产者往ioq队列中写入一个字符byte */
void ioq_putchar(struct ioqueue* ioq, char byte) {
c0004350:	55                   	push   %ebp
c0004351:	89 e5                	mov    %esp,%ebp
c0004353:	83 ec 18             	sub    $0x18,%esp
c0004356:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004359:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/ioqueue.c:69
   ASSERT(intr_get_status() == INTR_OFF);
c000435c:	e8 51 d7 ff ff       	call   c0001ab2 <intr_get_status>
c0004361:	85 c0                	test   %eax,%eax
c0004363:	74 4b                	je     c00043b0 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:69 (discriminator 1)
c0004365:	68 b0 54 00 c0       	push   $0xc00054b0
c000436a:	68 4c 55 00 c0       	push   $0xc000554c
c000436f:	6a 45                	push   $0x45
c0004371:	68 ce 54 00 c0       	push   $0xc00054ce
c0004376:	e8 17 e0 ff ff       	call   c0002392 <panic_spin>
c000437b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74 (discriminator 1)

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c000437e:	eb 30                	jmp    c00043b0 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:75
      lock_acquire(&ioq->lock);
c0004380:	8b 45 08             	mov    0x8(%ebp),%eax
c0004383:	83 ec 0c             	sub    $0xc,%esp
c0004386:	50                   	push   %eax
c0004387:	e8 83 f9 ff ff       	call   c0003d0f <lock_acquire>
c000438c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:76
      ioq_wait(&ioq->producer);
c000438f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004392:	83 c0 1c             	add    $0x1c,%eax
c0004395:	83 ec 0c             	sub    $0xc,%esp
c0004398:	50                   	push   %eax
c0004399:	e8 6a fe ff ff       	call   c0004208 <ioq_wait>
c000439e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:77
      lock_release(&ioq->lock);
c00043a1:	8b 45 08             	mov    0x8(%ebp),%eax
c00043a4:	83 ec 0c             	sub    $0xc,%esp
c00043a7:	50                   	push   %eax
c00043a8:	e8 d9 f9 ff ff       	call   c0003d86 <lock_release>
c00043ad:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c00043b0:	83 ec 0c             	sub    $0xc,%esp
c00043b3:	ff 75 08             	pushl  0x8(%ebp)
c00043b6:	e8 c3 fd ff ff       	call   c000417e <ioq_full>
c00043bb:	83 c4 10             	add    $0x10,%esp
c00043be:	85 c0                	test   %eax,%eax
c00043c0:	75 be                	jne    c0004380 <ioq_putchar+0x30>
/work/x86_os_my/device/ioqueue.c:79
      lock_acquire(&ioq->lock);
      ioq_wait(&ioq->producer);
      lock_release(&ioq->lock);
   }
   ioq->buf[ioq->head] = byte;      // 把字节放入缓冲区中
c00043c2:	8b 45 08             	mov    0x8(%ebp),%eax
c00043c5:	8b 40 64             	mov    0x64(%eax),%eax
c00043c8:	8b 55 08             	mov    0x8(%ebp),%edx
c00043cb:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
c00043cf:	88 4c 02 24          	mov    %cl,0x24(%edx,%eax,1)
/work/x86_os_my/device/ioqueue.c:80
   ioq->head = next_pos(ioq->head); // 把写游标移到下一位置
c00043d3:	8b 45 08             	mov    0x8(%ebp),%eax
c00043d6:	8b 40 64             	mov    0x64(%eax),%eax
c00043d9:	83 ec 0c             	sub    $0xc,%esp
c00043dc:	50                   	push   %eax
c00043dd:	e8 80 fd ff ff       	call   c0004162 <next_pos>
c00043e2:	83 c4 10             	add    $0x10,%esp
c00043e5:	89 c2                	mov    %eax,%edx
c00043e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00043ea:	89 50 64             	mov    %edx,0x64(%eax)
/work/x86_os_my/device/ioqueue.c:82

   if (ioq->consumer != NULL) {
c00043ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00043f0:	8b 40 20             	mov    0x20(%eax),%eax
c00043f3:	85 c0                	test   %eax,%eax
c00043f5:	74 12                	je     c0004409 <ioq_putchar+0xb9>
/work/x86_os_my/device/ioqueue.c:83
      wakeup(&ioq->consumer);          // 唤醒消费者
c00043f7:	8b 45 08             	mov    0x8(%ebp),%eax
c00043fa:	83 c0 20             	add    $0x20,%eax
c00043fd:	83 ec 0c             	sub    $0xc,%esp
c0004400:	50                   	push   %eax
c0004401:	e8 4c fe ff ff       	call   c0004252 <wakeup>
c0004406:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:85
   }
}
c0004409:	90                   	nop
c000440a:	c9                   	leave  
c000440b:	c3                   	ret    

c000440c <update_tss_esp>:
update_tss_esp():
/work/x86_os_my/userprog/tss.c:40
	uint32_t io_base;
}; 
static struct tss g_tss;

/* 更新tss中esp0字段的值为pthread的0级栈 */
void update_tss_esp(struct task_struct* pthread) {
c000440c:	55                   	push   %ebp
c000440d:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/userprog/tss.c:41
	g_tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c000440f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004412:	05 00 10 00 00       	add    $0x1000,%eax
c0004417:	a3 c4 75 00 c0       	mov    %eax,0xc00075c4
/work/x86_os_my/userprog/tss.c:42
}
c000441c:	90                   	nop
c000441d:	5d                   	pop    %ebp
c000441e:	c3                   	ret    

c000441f <make_gdt_desc>:
make_gdt_desc():
/work/x86_os_my/userprog/tss.c:45

/* c语言方式，创建gdt描述符 */
static struct gdt_desc make_gdt_desc(uint32_t* desc_addr, uint32_t limit, uint8_t attr_low, uint8_t attr_high) {
c000441f:	55                   	push   %ebp
c0004420:	89 e5                	mov    %esp,%ebp
c0004422:	83 ec 18             	sub    $0x18,%esp
c0004425:	8b 55 14             	mov    0x14(%ebp),%edx
c0004428:	8b 45 18             	mov    0x18(%ebp),%eax
c000442b:	88 55 ec             	mov    %dl,-0x14(%ebp)
c000442e:	88 45 e8             	mov    %al,-0x18(%ebp)
/work/x86_os_my/userprog/tss.c:46
	uint32_t desc_base = (uint32_t)desc_addr;
c0004431:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004434:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/userprog/tss.c:48
	struct gdt_desc desc;
	desc.limit_low_word = limit & 0x0000ffff;
c0004437:	8b 45 10             	mov    0x10(%ebp),%eax
c000443a:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/userprog/tss.c:49
	desc.base_low_word = desc_base & 0x0000ffff;
c000443e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004441:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/userprog/tss.c:50
	desc.base_mid_byte = ((desc_base & 0x00ff0000) >> 16);
c0004445:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004448:	25 00 00 ff 00       	and    $0xff0000,%eax
c000444d:	c1 e8 10             	shr    $0x10,%eax
c0004450:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/userprog/tss.c:51
	desc.attr_low_byte = (uint8_t)(attr_low);
c0004453:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0004457:	88 45 f9             	mov    %al,-0x7(%ebp)
/work/x86_os_my/userprog/tss.c:52
	desc.limit_high_attr_high = (((limit & 0x000f0000) >> 16) + (uint8_t)(attr_high));
c000445a:	8b 45 10             	mov    0x10(%ebp),%eax
c000445d:	25 00 00 0f 00       	and    $0xf0000,%eax
c0004462:	c1 e8 10             	shr    $0x10,%eax
c0004465:	89 c2                	mov    %eax,%edx
c0004467:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c000446b:	01 d0                	add    %edx,%eax
c000446d:	88 45 fa             	mov    %al,-0x6(%ebp)
/work/x86_os_my/userprog/tss.c:53
	desc.base_high_byte = desc_base >> 24;
c0004470:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004473:	c1 e8 18             	shr    $0x18,%eax
c0004476:	88 45 fb             	mov    %al,-0x5(%ebp)
/work/x86_os_my/userprog/tss.c:54
	return desc;
c0004479:	8b 4d 08             	mov    0x8(%ebp),%ecx
c000447c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000447f:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0004482:	89 01                	mov    %eax,(%ecx)
c0004484:	89 51 04             	mov    %edx,0x4(%ecx)
/work/x86_os_my/userprog/tss.c:55
}
c0004487:	8b 45 08             	mov    0x8(%ebp),%eax
c000448a:	c9                   	leave  
c000448b:	c2 04 00             	ret    $0x4

c000448e <tss_init>:
tss_init():
/work/x86_os_my/userprog/tss.c:61

/* 在gdt中创建tss描述符
 * 重新加载 gdt
 * 加载 tr
 */
void tss_init() {
c000448e:	55                   	push   %ebp
c000448f:	89 e5                	mov    %esp,%ebp
c0004491:	53                   	push   %ebx
c0004492:	83 ec 24             	sub    $0x24,%esp
/work/x86_os_my/userprog/tss.c:62
	put_str("tss_init start\n");
c0004495:	83 ec 0c             	sub    $0xc,%esp
c0004498:	68 58 55 00 c0       	push   $0xc0005558
c000449d:	e8 7e dd ff ff       	call   c0002220 <put_str>
c00044a2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:63
	uint32_t tss_size = sizeof(g_tss);
c00044a5:	c7 45 f4 6c 00 00 00 	movl   $0x6c,-0xc(%ebp)
/work/x86_os_my/userprog/tss.c:64
	memset(&g_tss, 0, tss_size);
c00044ac:	83 ec 04             	sub    $0x4,%esp
c00044af:	ff 75 f4             	pushl  -0xc(%ebp)
c00044b2:	6a 00                	push   $0x0
c00044b4:	68 c0 75 00 c0       	push   $0xc00075c0
c00044b9:	e8 fc e9 ff ff       	call   c0002eba <memset>
c00044be:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:66
	
	g_tss.ss0 = SELECTOR_K_STACK;	// 0 级栈段的选择子 
c00044c1:	c7 05 c8 75 00 c0 10 	movl   $0x10,0xc00075c8
c00044c8:	00 00 00 
/work/x86_os_my/userprog/tss.c:67
	g_tss.io_base = tss_size;		// 当 IO 位图的偏移地址大于等于 TSS 大小减 1 时，就表示没有 IO 位图。
c00044cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00044ce:	a3 28 76 00 c0       	mov    %eax,0xc0007628
/work/x86_os_my/userprog/tss.c:75
	 * 内核地址 0xC000_0900 是映射到 0x900 的 
	 * 在GDT中，第 0 个段描述符不可用，第 1 个为代码段，第 2 个为数据段和栈，第 3 个为显存段
	 */

	/* 在gdt中添加dpl为0的TSS描述符 */
	*((struct gdt_desc*)0xc0000920) = make_gdt_desc((uint32_t*)&g_tss, tss_size - 1, TSS_ATTR_LOW, TSS_ATTR_HIGH);
c00044d3:	bb 20 09 00 c0       	mov    $0xc0000920,%ebx
c00044d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00044db:	8d 50 ff             	lea    -0x1(%eax),%edx
c00044de:	8d 45 e0             	lea    -0x20(%ebp),%eax
c00044e1:	83 ec 0c             	sub    $0xc,%esp
c00044e4:	68 80 00 00 00       	push   $0x80
c00044e9:	68 89 00 00 00       	push   $0x89
c00044ee:	52                   	push   %edx
c00044ef:	68 c0 75 00 c0       	push   $0xc00075c0
c00044f4:	50                   	push   %eax
c00044f5:	e8 25 ff ff ff       	call   c000441f <make_gdt_desc>
c00044fa:	83 c4 1c             	add    $0x1c,%esp
c00044fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0004500:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0004503:	89 03                	mov    %eax,(%ebx)
c0004505:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:78

	/* 在gdt中添加dpl为3的,用户级,数据段和代码段描述符 */
	*((struct gdt_desc*)0xc0000928) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
c0004508:	bb 28 09 00 c0       	mov    $0xc0000928,%ebx
c000450d:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0004510:	83 ec 0c             	sub    $0xc,%esp
c0004513:	68 c0 00 00 00       	push   $0xc0
c0004518:	68 f8 00 00 00       	push   $0xf8
c000451d:	68 ff ff 0f 00       	push   $0xfffff
c0004522:	6a 00                	push   $0x0
c0004524:	50                   	push   %eax
c0004525:	e8 f5 fe ff ff       	call   c000441f <make_gdt_desc>
c000452a:	83 c4 1c             	add    $0x1c,%esp
c000452d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0004530:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0004533:	89 03                	mov    %eax,(%ebx)
c0004535:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:79
	*((struct gdt_desc*)0xc0000930) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
c0004538:	bb 30 09 00 c0       	mov    $0xc0000930,%ebx
c000453d:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0004540:	83 ec 0c             	sub    $0xc,%esp
c0004543:	68 c0 00 00 00       	push   $0xc0
c0004548:	68 f2 00 00 00       	push   $0xf2
c000454d:	68 ff ff 0f 00       	push   $0xfffff
c0004552:	6a 00                	push   $0x0
c0004554:	50                   	push   %eax
c0004555:	e8 c5 fe ff ff       	call   c000441f <make_gdt_desc>
c000455a:	83 c4 1c             	add    $0x1c,%esp
c000455d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0004560:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0004563:	89 03                	mov    %eax,(%ebx)
c0004565:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:83

	/* GDTR 16位的limit、32位的段基址 */
	// 先转换成 uint32_t 后，再将其转换成 uint64_t 位（不可一步到位转为 uint64_t）
	uint64_t gdt_operand = ((8 * 7 - 1) | ((uint64_t)(uint32_t)0xc0000900 << 16));   // 7个描述符大小
c0004568:	c7 45 e8 37 00 00 09 	movl   $0x9000037,-0x18(%ebp)
c000456f:	c7 45 ec 00 c0 00 00 	movl   $0xc000,-0x14(%ebp)
/work/x86_os_my/userprog/tss.c:84
	asm volatile ("lgdt %0" : : "m" (gdt_operand));
c0004576:	0f 01 55 e8          	lgdtl  -0x18(%ebp)
/work/x86_os_my/userprog/tss.c:85
	asm volatile ("ltr %w0" : : "r" (SELECTOR_TSS));
c000457a:	b8 20 00 00 00       	mov    $0x20,%eax
c000457f:	0f 00 d8             	ltr    %ax
/work/x86_os_my/userprog/tss.c:86
	put_str("tss_init and ltr done\n");
c0004582:	83 ec 0c             	sub    $0xc,%esp
c0004585:	68 68 55 00 c0       	push   $0xc0005568
c000458a:	e8 91 dc ff ff       	call   c0002220 <put_str>
c000458f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:87
}
c0004592:	90                   	nop
c0004593:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0004596:	c9                   	leave  
c0004597:	c3                   	ret    

c0004598 <start_process>:
start_process():
/work/x86_os_my/userprog/process.c:17
extern void intr_exit(void);

/* 构建用户进程初始上下文信息
 * 填充用户进程的中断栈，并将中断栈的信息，利用iretd填充到 CPU 中
 */
void start_process(void* filename_) {
c0004598:	55                   	push   %ebp
c0004599:	89 e5                	mov    %esp,%ebp
c000459b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:18
	void* function = filename_;
c000459e:	8b 45 08             	mov    0x8(%ebp),%eax
c00045a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:19
	struct task_struct* cur = running_thread();
c00045a4:	e8 e1 ec ff ff       	call   c000328a <running_thread>
c00045a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:20
	cur->self_kstack += sizeof(struct thread_stack);
c00045ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00045af:	8b 00                	mov    (%eax),%eax
c00045b1:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
c00045b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00045ba:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/process.c:21
	struct intr_stack* proc_stack = (struct intr_stack*)cur->self_kstack;	 
c00045bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00045bf:	8b 00                	mov    (%eax),%eax
c00045c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/userprog/process.c:22
	proc_stack->edi = proc_stack->esi = proc_stack->ebp = proc_stack->esp_dummy = 0;
c00045c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045c7:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
c00045ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045d1:	8b 50 10             	mov    0x10(%eax),%edx
c00045d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045d7:	89 50 0c             	mov    %edx,0xc(%eax)
c00045da:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045dd:	8b 50 0c             	mov    0xc(%eax),%edx
c00045e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045e3:	89 50 08             	mov    %edx,0x8(%eax)
c00045e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045e9:	8b 50 08             	mov    0x8(%eax),%edx
c00045ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045ef:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/userprog/process.c:23
	proc_stack->ebx = proc_stack->edx = proc_stack->ecx = proc_stack->eax = 0;
c00045f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045f5:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c00045fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00045ff:	8b 50 20             	mov    0x20(%eax),%edx
c0004602:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004605:	89 50 1c             	mov    %edx,0x1c(%eax)
c0004608:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000460b:	8b 50 1c             	mov    0x1c(%eax),%edx
c000460e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004611:	89 50 18             	mov    %edx,0x18(%eax)
c0004614:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004617:	8b 50 18             	mov    0x18(%eax),%edx
c000461a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000461d:	89 50 14             	mov    %edx,0x14(%eax)
/work/x86_os_my/userprog/process.c:28
	/* 在iretd返回时，如果发现未来的 CPL（也就是内核栈中 CS.RPL，或者说是返回到的用户进程的代码段CS.CPL）
	 * 权限低于（数值上大于） CPU 中段寄存器（如 DS、 ES、 FS、 GS）中选择子指向的内存段的 DPL，
	 * CPU 会自动将相应段寄存器的选择子置为 0 
	 * 这里gs的选择子在iretd返回后，会被自动清零。*/
	proc_stack->gs = 0;					// 用户态用不上,直接初始为0
c0004620:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004623:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
/work/x86_os_my/userprog/process.c:29
	proc_stack->ds = proc_stack->es = proc_stack->fs = SELECTOR_U_DATA;		// 用户级数据段
c000462a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000462d:	c7 40 28 33 00 00 00 	movl   $0x33,0x28(%eax)
c0004634:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004637:	8b 50 28             	mov    0x28(%eax),%edx
c000463a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000463d:	89 50 2c             	mov    %edx,0x2c(%eax)
c0004640:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004643:	8b 50 2c             	mov    0x2c(%eax),%edx
c0004646:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004649:	89 50 30             	mov    %edx,0x30(%eax)
/work/x86_os_my/userprog/process.c:30
	proc_stack->eip = function;			// 待执行的用户程序地址
c000464c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000464f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004652:	89 50 38             	mov    %edx,0x38(%eax)
/work/x86_os_my/userprog/process.c:31
	proc_stack->cs = SELECTOR_U_CODE;	// 用户级代码段
c0004655:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004658:	c7 40 3c 2b 00 00 00 	movl   $0x2b,0x3c(%eax)
/work/x86_os_my/userprog/process.c:32
	proc_stack->eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);
c000465f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004662:	c7 40 40 02 02 00 00 	movl   $0x202,0x40(%eax)
/work/x86_os_my/userprog/process.c:41
	 * process_activate 使用户进程页表生效【已经把CR3寄存器 更新为 用户进程的页表了】
	 * start_process    为用户进程创建3特权级栈【所以申请的内存空间来自用户进程的页表】
	 * 
	 * USER_STACK3_VADDR=(0xc0000000 - 0x1000)
	 */
	proc_stack->esp = (void*)((uint32_t)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE) ;
c0004669:	83 ec 08             	sub    $0x8,%esp
c000466c:	68 00 f0 ff bf       	push   $0xbffff000
c0004671:	6a 02                	push   $0x2
c0004673:	e8 78 e4 ff ff       	call   c0002af0 <get_a_page>
c0004678:	83 c4 10             	add    $0x10,%esp
c000467b:	05 00 10 00 00       	add    $0x1000,%eax
c0004680:	89 c2                	mov    %eax,%edx
c0004682:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004685:	89 50 44             	mov    %edx,0x44(%eax)
/work/x86_os_my/userprog/process.c:42
	proc_stack->ss = SELECTOR_U_DATA;
c0004688:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000468b:	c7 40 48 33 00 00 00 	movl   $0x33,0x48(%eax)
/work/x86_os_my/userprog/process.c:49
	/* 将 esp 替换为 proc_stack
	 * 通过 jmp intr_exit 那里的一系列 pop 指令和 iretd 指令，
	 * 将 proc_stack 中的数据载入 CPU 的寄存器，
	 * 从而使程序“假装”退出中断，进入特权级 3
	 */
	asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (proc_stack) : "memory");
c0004692:	8b 65 ec             	mov    -0x14(%ebp),%esp
c0004695:	e9 26 d6 ff ff       	jmp    c0001cc0 <intr_exit>
/work/x86_os_my/userprog/process.c:50
}
c000469a:	90                   	nop
c000469b:	c9                   	leave  
c000469c:	c3                   	ret    

c000469d <page_dir_activate>:
page_dir_activate():
/work/x86_os_my/userprog/process.c:53

/* 更新CR3寄存器，激活页目录表 */
void page_dir_activate(struct task_struct* p_thread) {
c000469d:	55                   	push   %ebp
c000469e:	89 e5                	mov    %esp,%ebp
c00046a0:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:56
	
	/* 若为"内核线程",需要重新填充页表为0x100000 */
	uint32_t pagedir_phy_addr = 0x100000;	// 默认为内核的页目录物理地址,也就是内核线程所用的页目录表
c00046a3:	c7 45 f4 00 00 10 00 	movl   $0x100000,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:59
	
	/* "用户态进程"有自己的页目录表 */
	if (p_thread->pgdir != NULL) {
c00046aa:	8b 45 08             	mov    0x8(%ebp),%eax
c00046ad:	8b 40 34             	mov    0x34(%eax),%eax
c00046b0:	85 c0                	test   %eax,%eax
c00046b2:	74 15                	je     c00046c9 <page_dir_activate+0x2c>
/work/x86_os_my/userprog/process.c:60
		pagedir_phy_addr = addr_v2p((uint32_t)p_thread->pgdir);
c00046b4:	8b 45 08             	mov    0x8(%ebp),%eax
c00046b7:	8b 40 34             	mov    0x34(%eax),%eax
c00046ba:	83 ec 0c             	sub    $0xc,%esp
c00046bd:	50                   	push   %eax
c00046be:	e8 8b e5 ff ff       	call   c0002c4e <addr_v2p>
c00046c3:	83 c4 10             	add    $0x10,%esp
c00046c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:66
	}

	/* 更新页目录寄存器cr3,使新页表生效
	 * 实现进程间，虚拟地址空间的隔离。
	 */
	asm volatile ("movl %0, %%cr3" : : "r" (pagedir_phy_addr) : "memory");
c00046c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00046cc:	0f 22 d8             	mov    %eax,%cr3
/work/x86_os_my/userprog/process.c:67
}
c00046cf:	90                   	nop
c00046d0:	c9                   	leave  
c00046d1:	c3                   	ret    

c00046d2 <process_activate>:
process_activate():
/work/x86_os_my/userprog/process.c:73

/* 1.激活线程或进程的页表,【更新CR3寄存器】
 * 2.用户进程，更新tss中的esp0为进程的特权级0的栈
 * 【只有在任务调度时（中断时），才会切换页表及更新 0 级栈，因此 process_activate 是被"中断执行流"的 schedule 调用的！】
 */
void process_activate(struct task_struct* p_thread) {
c00046d2:	55                   	push   %ebp
c00046d3:	89 e5                	mov    %esp,%ebp
c00046d5:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/process.c:74
	ASSERT(p_thread != NULL);
c00046d8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00046dc:	75 19                	jne    c00046f7 <process_activate+0x25>
/work/x86_os_my/userprog/process.c:74 (discriminator 1)
c00046de:	68 80 55 00 c0       	push   $0xc0005580
c00046e3:	68 3c 56 00 c0       	push   $0xc000563c
c00046e8:	6a 4a                	push   $0x4a
c00046ea:	68 91 55 00 c0       	push   $0xc0005591
c00046ef:	e8 9e dc ff ff       	call   c0002392 <panic_spin>
c00046f4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:77
	
	/* 激活该进程或线程的页目录表【重新加载了CR3】 */
	page_dir_activate(p_thread);
c00046f7:	83 ec 0c             	sub    $0xc,%esp
c00046fa:	ff 75 08             	pushl  0x8(%ebp)
c00046fd:	e8 9b ff ff ff       	call   c000469d <page_dir_activate>
c0004702:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:80

	/* 内核线程特权级本身就是0,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */
	if (p_thread->pgdir != NULL) {
c0004705:	8b 45 08             	mov    0x8(%ebp),%eax
c0004708:	8b 40 34             	mov    0x34(%eax),%eax
c000470b:	85 c0                	test   %eax,%eax
c000470d:	74 0e                	je     c000471d <process_activate+0x4b>
/work/x86_os_my/userprog/process.c:83
		/* 若为用户进程,更新该进程的esp0,用于此进程被中断时保留上下文 
		 * 需要从tss中获取0特权级栈地址 */
		update_tss_esp(p_thread);	//就一行：g_tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c000470f:	83 ec 0c             	sub    $0xc,%esp
c0004712:	ff 75 08             	pushl  0x8(%ebp)
c0004715:	e8 f2 fc ff ff       	call   c000440c <update_tss_esp>
c000471a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:85
	}
}
c000471d:	90                   	nop
c000471e:	c9                   	leave  
c000471f:	c3                   	ret    

c0004720 <create_page_dir>:
create_page_dir():
/work/x86_os_my/userprog/process.c:94
 * 
 * 要确保用户进程，在自己的地址空间中，能够访问到内核。
 * 即：任意进程的页目录表中，用户进程占第 0~767 个页目录项，内核占第 768~1023 个页目录项。
 * 0x300 = 768
 */
uint32_t* create_page_dir(void) {
c0004720:	55                   	push   %ebp
c0004721:	89 e5                	mov    %esp,%ebp
c0004723:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:97

	/* 用户进程的页表不能让用户直接访问到,所以在内核空间来申请 */
	uint32_t* page_dir_vaddr = get_kernel_pages(1);
c0004726:	83 ec 0c             	sub    $0xc,%esp
c0004729:	6a 01                	push   $0x1
c000472b:	e8 0a e3 ff ff       	call   c0002a3a <get_kernel_pages>
c0004730:	83 c4 10             	add    $0x10,%esp
c0004733:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:98
	if (page_dir_vaddr == NULL) {
c0004736:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000473a:	75 17                	jne    c0004753 <create_page_dir+0x33>
/work/x86_os_my/userprog/process.c:99
		console_put_str("create_page_dir: get_kernel_page failed!");
c000473c:	83 ec 0c             	sub    $0xc,%esp
c000473f:	68 a4 55 00 c0       	push   $0xc00055a4
c0004744:	e8 57 f3 ff ff       	call   c0003aa0 <console_put_str>
c0004749:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:100
		return NULL;
c000474c:	b8 00 00 00 00       	mov    $0x0,%eax
c0004751:	eb 43                	jmp    c0004796 <create_page_dir+0x76>
/work/x86_os_my/userprog/process.c:106
	}

	/*** 1 复制内核的页目录表  ***/
	// page_dir_vaddr + 0x300*4 是内核页目录的第768项
	// 复制的页目录项个数=1024/4
	memcpy((uint32_t*)((uint32_t)page_dir_vaddr + 0x300*4), (uint32_t*)(0xfffff000+0x300*4), 1024);
c0004753:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004756:	05 00 0c 00 00       	add    $0xc00,%eax
c000475b:	83 ec 04             	sub    $0x4,%esp
c000475e:	68 00 04 00 00       	push   $0x400
c0004763:	68 00 fc ff ff       	push   $0xfffffc00
c0004768:	50                   	push   %eax
c0004769:	e8 9e e7 ff ff       	call   c0002f0c <memcpy>
c000476e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:110

	/*** 2 更新页目录表地址 ***/
	// 页目录表地址是页目录的最后一项
	uint32_t new_page_dir_phy_addr = addr_v2p((uint32_t)page_dir_vaddr);
c0004771:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004774:	83 ec 0c             	sub    $0xc,%esp
c0004777:	50                   	push   %eax
c0004778:	e8 d1 e4 ff ff       	call   c0002c4e <addr_v2p>
c000477d:	83 c4 10             	add    $0x10,%esp
c0004780:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:111
	page_dir_vaddr[1023] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1;
c0004783:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004786:	05 fc 0f 00 00       	add    $0xffc,%eax
c000478b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000478e:	83 ca 07             	or     $0x7,%edx
c0004791:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/process.c:113

	return page_dir_vaddr;
c0004793:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/userprog/process.c:114
}
c0004796:	c9                   	leave  
c0004797:	c3                   	ret    

c0004798 <create_user_vaddr_bitmap>:
create_user_vaddr_bitmap():
/work/x86_os_my/userprog/process.c:117

/* 创建用户进程虚拟地址位图 */
void create_user_vaddr_bitmap(struct task_struct* user_prog) {
c0004798:	55                   	push   %ebp
c0004799:	89 e5                	mov    %esp,%ebp
c000479b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:118
   user_prog->userprog_vaddr.vaddr_start = USER_VADDR_START;	// linux用户程序入口地址 0x80480000
c000479e:	8b 45 08             	mov    0x8(%ebp),%eax
c00047a1:	c7 40 40 00 80 04 08 	movl   $0x8048000,0x40(%eax)
/work/x86_os_my/userprog/process.c:119
   uint32_t bitmap_pg_cnt = DIV_ROUND_UP((0xc0000000 - USER_VADDR_START) / PG_SIZE / 8 , PG_SIZE);
c00047a8:	c7 45 f4 17 00 00 00 	movl   $0x17,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:120
   user_prog->userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt);
c00047af:	83 ec 0c             	sub    $0xc,%esp
c00047b2:	ff 75 f4             	pushl  -0xc(%ebp)
c00047b5:	e8 80 e2 ff ff       	call   c0002a3a <get_kernel_pages>
c00047ba:	83 c4 10             	add    $0x10,%esp
c00047bd:	89 c2                	mov    %eax,%edx
c00047bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00047c2:	89 50 3c             	mov    %edx,0x3c(%eax)
/work/x86_os_my/userprog/process.c:121
   user_prog->userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (0xc0000000 - USER_VADDR_START) / PG_SIZE / 8;
c00047c5:	8b 45 08             	mov    0x8(%ebp),%eax
c00047c8:	c7 40 38 f7 6f 01 00 	movl   $0x16ff7,0x38(%eax)
/work/x86_os_my/userprog/process.c:122
   bitmap_init(&user_prog->userprog_vaddr.vaddr_bitmap);
c00047cf:	8b 45 08             	mov    0x8(%ebp),%eax
c00047d2:	83 c0 38             	add    $0x38,%eax
c00047d5:	83 ec 0c             	sub    $0xc,%esp
c00047d8:	50                   	push   %eax
c00047d9:	e8 8a dc ff ff       	call   c0002468 <bitmap_init>
c00047de:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:123
}
c00047e1:	90                   	nop
c00047e2:	c9                   	leave  
c00047e3:	c3                   	ret    

c00047e4 <process_execute>:
process_execute():
/work/x86_os_my/userprog/process.c:126

/* 创建用户进程 */
void process_execute(void* filename, char* name) {
c00047e4:	55                   	push   %ebp
c00047e5:	89 e5                	mov    %esp,%ebp
c00047e7:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:128
   /* pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 */
   struct task_struct* thread = get_kernel_pages(1);
c00047ea:	83 ec 0c             	sub    $0xc,%esp
c00047ed:	6a 01                	push   $0x1
c00047ef:	e8 46 e2 ff ff       	call   c0002a3a <get_kernel_pages>
c00047f4:	83 c4 10             	add    $0x10,%esp
c00047f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:129
   init_thread(thread, name, default_prio);			//初始化线程PCB结构体 struct task_struct
c00047fa:	83 ec 04             	sub    $0x4,%esp
c00047fd:	6a 1f                	push   $0x1f
c00047ff:	ff 75 0c             	pushl  0xc(%ebp)
c0004802:	ff 75 f4             	pushl  -0xc(%ebp)
c0004805:	e8 67 eb ff ff       	call   c0003371 <init_thread>
c000480a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:130
   create_user_vaddr_bitmap(thread);				//【进程新增】创建用户进程，虚拟地址空间位图
c000480d:	83 ec 0c             	sub    $0xc,%esp
c0004810:	ff 75 f4             	pushl  -0xc(%ebp)
c0004813:	e8 80 ff ff ff       	call   c0004798 <create_user_vaddr_bitmap>
c0004818:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:131
   thread_create(thread, start_process, filename);	//初始化线程栈结构体 struct thread_stack
c000481b:	83 ec 04             	sub    $0x4,%esp
c000481e:	ff 75 08             	pushl  0x8(%ebp)
c0004821:	68 98 45 00 c0       	push   $0xc0004598
c0004826:	ff 75 f4             	pushl  -0xc(%ebp)
c0004829:	e8 cc ea ff ff       	call   c00032fa <thread_create>
c000482e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:132
   thread->pgdir = create_page_dir();				//【进程新增】创建用户进程，页目录表
c0004831:	e8 ea fe ff ff       	call   c0004720 <create_page_dir>
c0004836:	89 c2                	mov    %eax,%edx
c0004838:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000483b:	89 50 34             	mov    %edx,0x34(%eax)
/work/x86_os_my/userprog/process.c:134
   
   enum intr_status old_status = intr_disable();
c000483e:	e8 28 d2 ff ff       	call   c0001a6b <intr_disable>
c0004843:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:135
   ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));
c0004846:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004849:	83 c0 24             	add    $0x24,%eax
c000484c:	83 ec 08             	sub    $0x8,%esp
c000484f:	50                   	push   %eax
c0004850:	68 ec 7a 00 c0       	push   $0xc0007aec
c0004855:	e8 fc f0 ff ff       	call   c0003956 <elem_find>
c000485a:	83 c4 10             	add    $0x10,%esp
c000485d:	85 c0                	test   %eax,%eax
c000485f:	74 1c                	je     c000487d <process_execute+0x99>
/work/x86_os_my/userprog/process.c:135 (discriminator 1)
c0004861:	68 d0 55 00 c0       	push   $0xc00055d0
c0004866:	68 50 56 00 c0       	push   $0xc0005650
c000486b:	68 87 00 00 00       	push   $0x87
c0004870:	68 91 55 00 c0       	push   $0xc0005591
c0004875:	e8 18 db ff ff       	call   c0002392 <panic_spin>
c000487a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:136
   list_append(&thread_ready_list, &thread->general_tag);
c000487d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004880:	83 c0 24             	add    $0x24,%eax
c0004883:	83 ec 08             	sub    $0x8,%esp
c0004886:	50                   	push   %eax
c0004887:	68 ec 7a 00 c0       	push   $0xc0007aec
c000488c:	e8 4b f0 ff ff       	call   c00038dc <list_append>
c0004891:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:137
   ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
c0004894:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004897:	83 c0 2c             	add    $0x2c,%eax
c000489a:	83 ec 08             	sub    $0x8,%esp
c000489d:	50                   	push   %eax
c000489e:	68 fc 7a 00 c0       	push   $0xc0007afc
c00048a3:	e8 ae f0 ff ff       	call   c0003956 <elem_find>
c00048a8:	83 c4 10             	add    $0x10,%esp
c00048ab:	85 c0                	test   %eax,%eax
c00048ad:	74 1c                	je     c00048cb <process_execute+0xe7>
/work/x86_os_my/userprog/process.c:137 (discriminator 1)
c00048af:	68 08 56 00 c0       	push   $0xc0005608
c00048b4:	68 50 56 00 c0       	push   $0xc0005650
c00048b9:	68 89 00 00 00       	push   $0x89
c00048be:	68 91 55 00 c0       	push   $0xc0005591
c00048c3:	e8 ca da ff ff       	call   c0002392 <panic_spin>
c00048c8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:138
   list_append(&thread_all_list, &thread->all_list_tag);
c00048cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00048ce:	83 c0 2c             	add    $0x2c,%eax
c00048d1:	83 ec 08             	sub    $0x8,%esp
c00048d4:	50                   	push   %eax
c00048d5:	68 fc 7a 00 c0       	push   $0xc0007afc
c00048da:	e8 fd ef ff ff       	call   c00038dc <list_append>
c00048df:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:139
   intr_set_status(old_status);
c00048e2:	83 ec 0c             	sub    $0xc,%esp
c00048e5:	ff 75 f0             	pushl  -0x10(%ebp)
c00048e8:	e8 a7 d1 ff ff       	call   c0001a94 <intr_set_status>
c00048ed:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:140
}
c00048f0:	90                   	nop
c00048f1:	c9                   	leave  
c00048f2:	c3                   	ret    

c00048f3 <getpid>:
getpid():
/work/x86_os_my/lib/user/syscall.c:52
   );							       \
   retval;						       \
})

/* 返回当前任务pid */
uint32_t getpid() {
c00048f3:	55                   	push   %ebp
c00048f4:	89 e5                	mov    %esp,%ebp
c00048f6:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:53
   return _syscall0(SYS_GETPID);
c00048f9:	b8 00 00 00 00       	mov    $0x0,%eax
c00048fe:	cd 80                	int    $0x80
c0004900:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0004903:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:54
}
c0004906:	c9                   	leave  
c0004907:	c3                   	ret    

c0004908 <sys_getpid>:
sys_getpid():
/work/x86_os_my/userprog/syscall-init.c:12
#define syscall_nr 32 
typedef void* syscall;
syscall syscall_table[syscall_nr];

/* 返回当前任务的pid */
uint32_t sys_getpid(void) {
c0004908:	55                   	push   %ebp
c0004909:	89 e5                	mov    %esp,%ebp
c000490b:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/syscall-init.c:13
   return running_thread()->pid;
c000490e:	e8 77 e9 ff ff       	call   c000328a <running_thread>
c0004913:	0f b7 40 04          	movzwl 0x4(%eax),%eax
c0004917:	98                   	cwtl   
/work/x86_os_my/userprog/syscall-init.c:14
}
c0004918:	c9                   	leave  
c0004919:	c3                   	ret    

c000491a <syscall_init>:
syscall_init():
/work/x86_os_my/userprog/syscall-init.c:17

/* 初始化系统调用 */
void syscall_init(void) {
c000491a:	55                   	push   %ebp
c000491b:	89 e5                	mov    %esp,%ebp
c000491d:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/syscall-init.c:18
   put_str("syscall_init start\n");
c0004920:	83 ec 0c             	sub    $0xc,%esp
c0004923:	68 60 56 00 c0       	push   $0xc0005660
c0004928:	e8 f3 d8 ff ff       	call   c0002220 <put_str>
c000492d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:19
   syscall_table[SYS_GETPID] = sys_getpid;
c0004930:	c7 05 c0 7b 00 c0 08 	movl   $0xc0004908,0xc0007bc0
c0004937:	49 00 c0 
/work/x86_os_my/userprog/syscall-init.c:20
   put_str("syscall_init done\n");
c000493a:	83 ec 0c             	sub    $0xc,%esp
c000493d:	68 74 56 00 c0       	push   $0xc0005674
c0004942:	e8 d9 d8 ff ff       	call   c0002220 <put_str>
c0004947:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:21
}
c000494a:	90                   	nop
c000494b:	c9                   	leave  
c000494c:	c3                   	ret    
