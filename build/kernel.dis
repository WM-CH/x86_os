
./build/kernel.bin:     file format elf32-i386


Disassembly of section .text:

c0001500 <main>:
main():
/work/x86_os_my/kernel/main.c:32
用户进程
u_prog_a 的地址是在 0xc0000000 以上，位于内核空间，但这并不表示它无法模拟用户进程。
*/
void init(void);

int main(void) {
c0001500:	8d 4c 24 04          	lea    0x4(%esp),%ecx
c0001504:	83 e4 f0             	and    $0xfffffff0,%esp
c0001507:	ff 71 fc             	pushl  -0x4(%ecx)
c000150a:	55                   	push   %ebp
c000150b:	89 e5                	mov    %esp,%ebp
c000150d:	51                   	push   %ecx
c000150e:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/kernel/main.c:33
   put_str("I am kernel\n");
c0001511:	83 ec 0c             	sub    $0xc,%esp
c0001514:	68 34 b0 00 c0       	push   $0xc000b034
c0001519:	e8 52 0c 00 00       	call   c0002170 <put_str>
c000151e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:34
   init_all();
c0001521:	e8 4d 00 00 00       	call   c0001573 <init_all>
/work/x86_os_my/kernel/main.c:37 (discriminator 1)
/********  测试代码  ********/
/********  测试代码  ********/
   while(1);
c0001526:	eb fe                	jmp    c0001526 <main+0x26>

c0001528 <init>:
init():
/work/x86_os_my/kernel/main.c:42
   return 0;
}

/* init进程 */
void init(void) {
c0001528:	55                   	push   %ebp
c0001529:	89 e5                	mov    %esp,%ebp
c000152b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/main.c:43
	uint32_t ret_pid = fork();
c000152e:	e8 76 3e 00 00       	call   c00053a9 <fork>
c0001533:	98                   	cwtl   
c0001534:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/main.c:44
	if(ret_pid) {
c0001537:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000153b:	74 1b                	je     c0001558 <init+0x30>
/work/x86_os_my/kernel/main.c:45
		printf("i am father, my pid is %d, child pid is %d\n", getpid(), ret_pid);
c000153d:	e8 f3 3d 00 00       	call   c0005335 <getpid>
c0001542:	83 ec 04             	sub    $0x4,%esp
c0001545:	ff 75 f4             	pushl  -0xc(%ebp)
c0001548:	50                   	push   %eax
c0001549:	68 44 b0 00 c0       	push   $0xc000b044
c000154e:	e8 04 41 00 00       	call   c0005657 <printf>
c0001553:	83 c4 10             	add    $0x10,%esp
c0001556:	eb 19                	jmp    c0001571 <init+0x49>
/work/x86_os_my/kernel/main.c:47
	} else {
		printf("i am child, my pid is %d, ret pid is %d\n", getpid(), ret_pid);
c0001558:	e8 d8 3d 00 00       	call   c0005335 <getpid>
c000155d:	83 ec 04             	sub    $0x4,%esp
c0001560:	ff 75 f4             	pushl  -0xc(%ebp)
c0001563:	50                   	push   %eax
c0001564:	68 70 b0 00 c0       	push   $0xc000b070
c0001569:	e8 e9 40 00 00       	call   c0005657 <printf>
c000156e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/main.c:49 (discriminator 1)
	}
	while(1);
c0001571:	eb fe                	jmp    c0001571 <init+0x49>

c0001573 <init_all>:
init_all():
/work/x86_os_my/kernel/init.c:15
#include "syscall-init.h"
#include "ide.h"
#include "fs.h"

/*负责初始化所有模块 */
void init_all() {
c0001573:	55                   	push   %ebp
c0001574:	89 e5                	mov    %esp,%ebp
c0001576:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/init.c:16
	put_str("init_all\n");
c0001579:	83 ec 0c             	sub    $0xc,%esp
c000157c:	68 99 b0 00 c0       	push   $0xc000b099
c0001581:	e8 ea 0b 00 00       	call   c0002170 <put_str>
c0001586:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/init.c:17
	idt_init();			// 初始化中断
c0001589:	e8 38 04 00 00       	call   c00019c6 <idt_init>
/work/x86_os_my/kernel/init.c:18
	mem_init();			// 初始化内存管理系统
c000158e:	e8 a0 21 00 00       	call   c0003733 <mem_init>
/work/x86_os_my/kernel/init.c:19
	thread_init();		// 初始化线程相关结构
c0001593:	e8 57 2c 00 00       	call   c00041ef <thread_init>
/work/x86_os_my/kernel/init.c:20
	timer_init();		// 初始化PIT
c0001598:	e8 16 06 00 00       	call   c0001bb3 <timer_init>
/work/x86_os_my/kernel/init.c:21
	console_init();		// 控制台初始化最好放在开中断之前
c000159d:	e8 e3 2e 00 00       	call   c0004485 <console_init>
/work/x86_os_my/kernel/init.c:22
	keyboard_init();	// 键盘初始化
c00015a2:	e8 5c 35 00 00       	call   c0004b03 <keyboard_init>
/work/x86_os_my/kernel/init.c:23
	tss_init();			// tss初始化
c00015a7:	e8 12 39 00 00       	call   c0004ebe <tss_init>
/work/x86_os_my/kernel/init.c:24
	syscall_init();		// 初始化系统调用
c00015ac:	e8 1f 3e 00 00       	call   c00053d0 <syscall_init>
/work/x86_os_my/kernel/init.c:25
	intr_enable();		// 后面的ide_init需要打开中断
c00015b1:	e8 5f 03 00 00       	call   c0001915 <intr_enable>
/work/x86_os_my/kernel/init.c:26
	ide_init();			// 初始化硬盘
c00015b6:	e8 88 4c 00 00       	call   c0006243 <ide_init>
/work/x86_os_my/kernel/init.c:27
	filesys_init();		// 初始化文件系统
c00015bb:	e8 c7 6c 00 00       	call   c0008287 <filesys_init>
/work/x86_os_my/kernel/init.c:28
}
c00015c0:	90                   	nop
c00015c1:	c9                   	leave  
c00015c2:	c3                   	ret    

c00015c3 <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c00015c3:	55                   	push   %ebp
c00015c4:	89 e5                	mov    %esp,%ebp
c00015c6:	83 ec 08             	sub    $0x8,%esp
c00015c9:	8b 55 08             	mov    0x8(%ebp),%edx
c00015cc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00015cf:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c00015d3:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c00015d6:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c00015da:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c00015de:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c00015df:	90                   	nop
c00015e0:	c9                   	leave  
c00015e1:	c3                   	ret    

c00015e2 <pic_init>:
pic_init():
/work/x86_os_my/kernel/interrupt.c:41
//自定义类型 intr_handler = void*
extern intr_handler intr_entry_table[IDT_DESC_CNT];	    // 声明引用汇编kernel.S中的中断处理函数入口数组

/* 初始化可编程中断控制器8259A */
// outb 来着 lib/kernel/io.h 内联汇编写法
static void pic_init(void) {
c00015e2:	55                   	push   %ebp
c00015e3:	89 e5                	mov    %esp,%ebp
c00015e5:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:43
	/* 初始化主片 */
	outb (PIC_M_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c00015e8:	6a 11                	push   $0x11
c00015ea:	6a 20                	push   $0x20
c00015ec:	e8 d2 ff ff ff       	call   c00015c3 <outb>
c00015f1:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:44
	outb (PIC_M_DATA, 0x20);	// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.
c00015f4:	6a 20                	push   $0x20
c00015f6:	6a 21                	push   $0x21
c00015f8:	e8 c6 ff ff ff       	call   c00015c3 <outb>
c00015fd:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:45
	outb (PIC_M_DATA, 0x04);	// ICW3: IR2接从片. 
c0001600:	6a 04                	push   $0x4
c0001602:	6a 21                	push   $0x21
c0001604:	e8 ba ff ff ff       	call   c00015c3 <outb>
c0001609:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:46
	outb (PIC_M_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c000160c:	6a 01                	push   $0x1
c000160e:	6a 21                	push   $0x21
c0001610:	e8 ae ff ff ff       	call   c00015c3 <outb>
c0001615:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:49

	/* 初始化从片 */
	outb (PIC_S_CTRL, 0x11);	// ICW1: 边沿触发,级联8259, 需要ICW4.
c0001618:	6a 11                	push   $0x11
c000161a:	68 a0 00 00 00       	push   $0xa0
c000161f:	e8 9f ff ff ff       	call   c00015c3 <outb>
c0001624:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:50
	outb (PIC_S_DATA, 0x28);	// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.
c0001627:	6a 28                	push   $0x28
c0001629:	68 a1 00 00 00       	push   $0xa1
c000162e:	e8 90 ff ff ff       	call   c00015c3 <outb>
c0001633:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:51
	outb (PIC_S_DATA, 0x02);	// ICW3: 设置从片连接到主片的IR2引脚
c0001636:	6a 02                	push   $0x2
c0001638:	68 a1 00 00 00       	push   $0xa1
c000163d:	e8 81 ff ff ff       	call   c00015c3 <outb>
c0001642:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:52
	outb (PIC_S_DATA, 0x01);	// ICW4: 8086模式, 正常EOI
c0001645:	6a 01                	push   $0x1
c0001647:	68 a1 00 00 00       	push   $0xa1
c000164c:	e8 72 ff ff ff       	call   c00015c3 <outb>
c0001651:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:56

	/* IRQ2用于级联从片,必须打开,否则无法响应从片上的中断
	主片上打开的中断有IRQ0的时钟,IRQ1的键盘和级联从片的IRQ2,其它全部关闭 */
	outb (PIC_M_DATA, 0xf8);
c0001654:	68 f8 00 00 00       	push   $0xf8
c0001659:	6a 21                	push   $0x21
c000165b:	e8 63 ff ff ff       	call   c00015c3 <outb>
c0001660:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:58
	/* 打开从片上的IRQ14,此引脚接收硬盘控制器的中断 */
	outb (PIC_S_DATA, 0xbf);
c0001663:	68 bf 00 00 00       	push   $0xbf
c0001668:	68 a1 00 00 00       	push   $0xa1
c000166d:	e8 51 ff ff ff       	call   c00015c3 <outb>
c0001672:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:60

	put_str("   pic_init done\n");
c0001675:	83 ec 0c             	sub    $0xc,%esp
c0001678:	68 a4 b0 00 c0       	push   $0xc000b0a4
c000167d:	e8 ee 0a 00 00       	call   c0002170 <put_str>
c0001682:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:61
}
c0001685:	90                   	nop
c0001686:	c9                   	leave  
c0001687:	c3                   	ret    

c0001688 <make_idt_desc>:
make_idt_desc():
/work/x86_os_my/kernel/interrupt.c:64

/* 创建中断门描述符 */
static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function) { 
c0001688:	55                   	push   %ebp
c0001689:	89 e5                	mov    %esp,%ebp
c000168b:	83 ec 04             	sub    $0x4,%esp
c000168e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001691:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:65
	p_gdesc->func_offset_low_word = (uint32_t)function & 0x0000FFFF;
c0001694:	8b 45 10             	mov    0x10(%ebp),%eax
c0001697:	89 c2                	mov    %eax,%edx
c0001699:	8b 45 08             	mov    0x8(%ebp),%eax
c000169c:	66 89 10             	mov    %dx,(%eax)
/work/x86_os_my/kernel/interrupt.c:66
	p_gdesc->selector = SELECTOR_K_CODE;
c000169f:	8b 45 08             	mov    0x8(%ebp),%eax
c00016a2:	66 c7 40 02 08 00    	movw   $0x8,0x2(%eax)
/work/x86_os_my/kernel/interrupt.c:67
	p_gdesc->dcount = 0;
c00016a8:	8b 45 08             	mov    0x8(%ebp),%eax
c00016ab:	c6 40 04 00          	movb   $0x0,0x4(%eax)
/work/x86_os_my/kernel/interrupt.c:68
	p_gdesc->attribute = attr;
c00016af:	8b 45 08             	mov    0x8(%ebp),%eax
c00016b2:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c00016b6:	88 50 05             	mov    %dl,0x5(%eax)
/work/x86_os_my/kernel/interrupt.c:69
	p_gdesc->func_offset_high_word = ((uint32_t)function & 0xFFFF0000) >> 16;
c00016b9:	8b 45 10             	mov    0x10(%ebp),%eax
c00016bc:	c1 e8 10             	shr    $0x10,%eax
c00016bf:	89 c2                	mov    %eax,%edx
c00016c1:	8b 45 08             	mov    0x8(%ebp),%eax
c00016c4:	66 89 50 06          	mov    %dx,0x6(%eax)
/work/x86_os_my/kernel/interrupt.c:70
}
c00016c8:	90                   	nop
c00016c9:	c9                   	leave  
c00016ca:	c3                   	ret    

c00016cb <idt_desc_init>:
idt_desc_init():
/work/x86_os_my/kernel/interrupt.c:73

/*初始化中断描述符表*/
static void idt_desc_init(void) {
c00016cb:	55                   	push   %ebp
c00016cc:	89 e5                	mov    %esp,%ebp
c00016ce:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:75
	int i;
	int lastindex = IDT_DESC_CNT - 1;
c00016d1:	c7 45 f0 80 00 00 00 	movl   $0x80,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:76
	for (i = 0; i < IDT_DESC_CNT; i++) {
c00016d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00016df:	eb 29                	jmp    c000170a <idt_desc_init+0x3f>
/work/x86_os_my/kernel/interrupt.c:77 (discriminator 3)
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
c00016e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00016e4:	8b 04 85 00 f0 00 c0 	mov    -0x3fff1000(,%eax,4),%eax
c00016eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00016ee:	c1 e2 03             	shl    $0x3,%edx
c00016f1:	81 c2 60 f1 00 c0    	add    $0xc000f160,%edx
c00016f7:	50                   	push   %eax
c00016f8:	68 8e 00 00 00       	push   $0x8e
c00016fd:	52                   	push   %edx
c00016fe:	e8 85 ff ff ff       	call   c0001688 <make_idt_desc>
c0001703:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/kernel/interrupt.c:76 (discriminator 3)

/*初始化中断描述符表*/
static void idt_desc_init(void) {
	int i;
	int lastindex = IDT_DESC_CNT - 1;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001706:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:76 (discriminator 1)
c000170a:	81 7d f4 80 00 00 00 	cmpl   $0x80,-0xc(%ebp)
c0001711:	7e ce                	jle    c00016e1 <idt_desc_init+0x16>
/work/x86_os_my/kernel/interrupt.c:81
		make_idt_desc(&idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]); 
	}
	/* 系统调用对应的中断门dpl为3！
	 * 中断处理程序为单独的syscall_handler */
	make_idt_desc(&idt[lastindex], IDT_DESC_ATTR_DPL3, syscall_handler);
c0001713:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0001716:	c1 e0 03             	shl    $0x3,%eax
c0001719:	05 60 f1 00 c0       	add    $0xc000f160,%eax
c000171e:	68 47 21 00 c0       	push   $0xc0002147
c0001723:	68 ee 00 00 00       	push   $0xee
c0001728:	50                   	push   %eax
c0001729:	e8 5a ff ff ff       	call   c0001688 <make_idt_desc>
c000172e:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/kernel/interrupt.c:82
	put_str("   idt_desc_init done\n");
c0001731:	83 ec 0c             	sub    $0xc,%esp
c0001734:	68 b6 b0 00 c0       	push   $0xc000b0b6
c0001739:	e8 32 0a 00 00       	call   c0002170 <put_str>
c000173e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:83
}
c0001741:	90                   	nop
c0001742:	c9                   	leave  
c0001743:	c3                   	ret    

c0001744 <general_intr_handler>:
general_intr_handler():
/work/x86_os_my/kernel/interrupt.c:86

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
c0001744:	55                   	push   %ebp
c0001745:	89 e5                	mov    %esp,%ebp
c0001747:	83 ec 28             	sub    $0x28,%esp
c000174a:	8b 45 08             	mov    0x8(%ebp),%eax
c000174d:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/kernel/interrupt.c:87
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
c0001750:	80 7d e4 27          	cmpb   $0x27,-0x1c(%ebp)
c0001754:	0f 84 bf 00 00 00    	je     c0001819 <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:87 (discriminator 1)
c000175a:	80 7d e4 2f          	cmpb   $0x2f,-0x1c(%ebp)
c000175e:	0f 84 b5 00 00 00    	je     c0001819 <general_intr_handler+0xd5>
/work/x86_os_my/kernel/interrupt.c:92
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
c0001764:	83 ec 0c             	sub    $0xc,%esp
c0001767:	6a 00                	push   $0x0
c0001769:	e8 50 0b 00 00       	call   c00022be <set_cursor>
c000176e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:93
	int cursor_pos = 0;
c0001771:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:94
	while(cursor_pos < 320) {
c0001778:	eb 11                	jmp    c000178b <general_intr_handler+0x47>
/work/x86_os_my/kernel/interrupt.c:95
		put_char(' ');
c000177a:	83 ec 0c             	sub    $0xc,%esp
c000177d:	6a 20                	push   $0x20
c000177f:	e8 0a 0a 00 00       	call   c000218e <put_char>
c0001784:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:96
		cursor_pos++;
c0001787:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:94
	}
	
	/* 将光标置为左上角 并清空一片区域 */
	set_cursor(0);
	int cursor_pos = 0;
	while(cursor_pos < 320) {
c000178b:	81 7d f4 3f 01 00 00 	cmpl   $0x13f,-0xc(%ebp)
c0001792:	7e e6                	jle    c000177a <general_intr_handler+0x36>
/work/x86_os_my/kernel/interrupt.c:100
		put_char(' ');
		cursor_pos++;
	}

	/* 将光标置为左上角 打印信息 */
	set_cursor(0);
c0001794:	83 ec 0c             	sub    $0xc,%esp
c0001797:	6a 00                	push   $0x0
c0001799:	e8 20 0b 00 00       	call   c00022be <set_cursor>
c000179e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:101
	put_str("!!!!!!!      excetion message begin  !!!!!!!!\n");
c00017a1:	83 ec 0c             	sub    $0xc,%esp
c00017a4:	68 d0 b0 00 c0       	push   $0xc000b0d0
c00017a9:	e8 c2 09 00 00       	call   c0002170 <put_str>
c00017ae:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:102
	set_cursor(88);			// 第2行第8个字符
c00017b1:	83 ec 0c             	sub    $0xc,%esp
c00017b4:	6a 58                	push   $0x58
c00017b6:	e8 03 0b 00 00       	call   c00022be <set_cursor>
c00017bb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:103
	put_str(intr_name[vec_nr]);
c00017be:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c00017c2:	8b 04 85 20 f6 00 c0 	mov    -0x3fff09e0(,%eax,4),%eax
c00017c9:	83 ec 0c             	sub    $0xc,%esp
c00017cc:	50                   	push   %eax
c00017cd:	e8 9e 09 00 00       	call   c0002170 <put_str>
c00017d2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:104
	if (vec_nr == 14) {		// 若为Pagefault,将缺失的地址打印出来并悬停
c00017d5:	80 7d e4 0e          	cmpb   $0xe,-0x1c(%ebp)
c00017d9:	75 2c                	jne    c0001807 <general_intr_handler+0xc3>
/work/x86_os_my/kernel/interrupt.c:105
		int page_fault_vaddr = 0; 
c00017db:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:106
		asm ("movl %%cr2, %0" : "=r" (page_fault_vaddr));	  // cr2是存放造成page_fault的地址
c00017e2:	0f 20 d0             	mov    %cr2,%eax
c00017e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:107
		put_str("\npage fault addr is ");
c00017e8:	83 ec 0c             	sub    $0xc,%esp
c00017eb:	68 ff b0 00 c0       	push   $0xc000b0ff
c00017f0:	e8 7b 09 00 00       	call   c0002170 <put_str>
c00017f5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:108
		put_int(page_fault_vaddr); 
c00017f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00017fb:	83 ec 0c             	sub    $0xc,%esp
c00017fe:	50                   	push   %eax
c00017ff:	e8 57 0a 00 00       	call   c000225b <put_int>
c0001804:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:110
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
c0001807:	83 ec 0c             	sub    $0xc,%esp
c000180a:	68 14 b1 00 c0       	push   $0xc000b114
c000180f:	e8 5c 09 00 00       	call   c0002170 <put_str>
c0001814:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:113 (discriminator 1)
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
c0001817:	eb fe                	jmp    c0001817 <general_intr_handler+0xd3>
/work/x86_os_my/kernel/interrupt.c:88
}

/* 通用的中断处理函数,一般用在异常出现时的处理 */
static void general_intr_handler(uint8_t vec_nr) {
	if (vec_nr == 0x27 || vec_nr == 0x2f) {	// 0x2f是从片8259A上的最后一个irq引脚，保留
		return;	//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。
c0001819:	90                   	nop
/work/x86_os_my/kernel/interrupt.c:114
	}
	put_str("\n!!!!!!!      excetion message end    !!!!!!!!\n");
	// 能进入中断处理程序就表示已经处在关中断情况下, IF=0
	// 不会出现调度进程的情况。故下面的死循环不会再被中断，会卡死在这里。
	while(1);
}
c000181a:	c9                   	leave  
c000181b:	c3                   	ret    

c000181c <exception_init>:
exception_init():
/work/x86_os_my/kernel/interrupt.c:117

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
c000181c:	55                   	push   %ebp
c000181d:	89 e5                	mov    %esp,%ebp
c000181f:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:119
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001822:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0001829:	eb 20                	jmp    c000184b <exception_init+0x2f>
/work/x86_os_my/kernel/interrupt.c:122 (discriminator 3)
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
c000182b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000182e:	c7 04 85 40 f8 00 c0 	movl   $0xc0001744,-0x3fff07c0(,%eax,4)
c0001835:	44 17 00 c0 
/work/x86_os_my/kernel/interrupt.c:123 (discriminator 3)
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
c0001839:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000183c:	c7 04 85 20 f6 00 c0 	movl   $0xc000b144,-0x3fff09e0(,%eax,4)
c0001843:	44 b1 00 c0 
/work/x86_os_my/kernel/interrupt.c:119 (discriminator 3)
}

/* 完成一般中断处理函数注册及异常名称注册 */
static void exception_init(void) {
	int i;
	for (i = 0; i < IDT_DESC_CNT; i++) {
c0001847:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:119 (discriminator 1)
c000184b:	81 7d fc 80 00 00 00 	cmpl   $0x80,-0x4(%ebp)
c0001852:	7e d7                	jle    c000182b <exception_init+0xf>
/work/x86_os_my/kernel/interrupt.c:125
	/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
	 * 见kernel/kernel.S的call [idt_table + %1*4] */
		idt_table[i] = general_intr_handler;		// 默认为general_intr_handler，以后会由register_handler来注册具体处理函数。
		intr_name[i] = "unknown";					// 先统一赋值为unknown 
	}
	intr_name[0] = "#DE Divide Error";
c0001854:	c7 05 20 f6 00 c0 4c 	movl   $0xc000b14c,0xc000f620
c000185b:	b1 00 c0 
/work/x86_os_my/kernel/interrupt.c:126
	intr_name[1] = "#DB Debug Exception";
c000185e:	c7 05 24 f6 00 c0 5d 	movl   $0xc000b15d,0xc000f624
c0001865:	b1 00 c0 
/work/x86_os_my/kernel/interrupt.c:127
	intr_name[2] = "NMI Interrupt";
c0001868:	c7 05 28 f6 00 c0 71 	movl   $0xc000b171,0xc000f628
c000186f:	b1 00 c0 
/work/x86_os_my/kernel/interrupt.c:128
	intr_name[3] = "#BP Breakpoint Exception";
c0001872:	c7 05 2c f6 00 c0 7f 	movl   $0xc000b17f,0xc000f62c
c0001879:	b1 00 c0 
/work/x86_os_my/kernel/interrupt.c:129
	intr_name[4] = "#OF Overflow Exception";
c000187c:	c7 05 30 f6 00 c0 98 	movl   $0xc000b198,0xc000f630
c0001883:	b1 00 c0 
/work/x86_os_my/kernel/interrupt.c:130
	intr_name[5] = "#BR BOUND Range Exceeded Exception";
c0001886:	c7 05 34 f6 00 c0 b0 	movl   $0xc000b1b0,0xc000f634
c000188d:	b1 00 c0 
/work/x86_os_my/kernel/interrupt.c:131
	intr_name[6] = "#UD Invalid Opcode Exception";
c0001890:	c7 05 38 f6 00 c0 d3 	movl   $0xc000b1d3,0xc000f638
c0001897:	b1 00 c0 
/work/x86_os_my/kernel/interrupt.c:132
	intr_name[7] = "#NM Device Not Available Exception";
c000189a:	c7 05 3c f6 00 c0 f0 	movl   $0xc000b1f0,0xc000f63c
c00018a1:	b1 00 c0 
/work/x86_os_my/kernel/interrupt.c:133
	intr_name[8] = "#DF Double Fault Exception";
c00018a4:	c7 05 40 f6 00 c0 13 	movl   $0xc000b213,0xc000f640
c00018ab:	b2 00 c0 
/work/x86_os_my/kernel/interrupt.c:134
	intr_name[9] = "Coprocessor Segment Overrun";
c00018ae:	c7 05 44 f6 00 c0 2e 	movl   $0xc000b22e,0xc000f644
c00018b5:	b2 00 c0 
/work/x86_os_my/kernel/interrupt.c:135
	intr_name[10] = "#TS Invalid TSS Exception";
c00018b8:	c7 05 48 f6 00 c0 4a 	movl   $0xc000b24a,0xc000f648
c00018bf:	b2 00 c0 
/work/x86_os_my/kernel/interrupt.c:136
	intr_name[11] = "#NP Segment Not Present";
c00018c2:	c7 05 4c f6 00 c0 64 	movl   $0xc000b264,0xc000f64c
c00018c9:	b2 00 c0 
/work/x86_os_my/kernel/interrupt.c:137
	intr_name[12] = "#SS Stack Fault Exception";
c00018cc:	c7 05 50 f6 00 c0 7c 	movl   $0xc000b27c,0xc000f650
c00018d3:	b2 00 c0 
/work/x86_os_my/kernel/interrupt.c:138
	intr_name[13] = "#GP General Protection Exception";
c00018d6:	c7 05 54 f6 00 c0 98 	movl   $0xc000b298,0xc000f654
c00018dd:	b2 00 c0 
/work/x86_os_my/kernel/interrupt.c:139
	intr_name[14] = "#PF Page-Fault Exception";
c00018e0:	c7 05 58 f6 00 c0 b9 	movl   $0xc000b2b9,0xc000f658
c00018e7:	b2 00 c0 
/work/x86_os_my/kernel/interrupt.c:141
	// intr_name[15] 第15项是intel保留项，未使用
	intr_name[16] = "#MF x87 FPU Floating-Point Error";
c00018ea:	c7 05 60 f6 00 c0 d4 	movl   $0xc000b2d4,0xc000f660
c00018f1:	b2 00 c0 
/work/x86_os_my/kernel/interrupt.c:142
	intr_name[17] = "#AC Alignment Check Exception";
c00018f4:	c7 05 64 f6 00 c0 f5 	movl   $0xc000b2f5,0xc000f664
c00018fb:	b2 00 c0 
/work/x86_os_my/kernel/interrupt.c:143
	intr_name[18] = "#MC Machine-Check Exception";
c00018fe:	c7 05 68 f6 00 c0 13 	movl   $0xc000b313,0xc000f668
c0001905:	b3 00 c0 
/work/x86_os_my/kernel/interrupt.c:144
	intr_name[19] = "#XF SIMD Floating-Point Exception";
c0001908:	c7 05 6c f6 00 c0 30 	movl   $0xc000b330,0xc000f66c
c000190f:	b3 00 c0 
/work/x86_os_my/kernel/interrupt.c:145
}
c0001912:	90                   	nop
c0001913:	c9                   	leave  
c0001914:	c3                   	ret    

c0001915 <intr_enable>:
intr_enable():
/work/x86_os_my/kernel/interrupt.c:148

/* 开中断并返回开中断前的状态*/
enum intr_status intr_enable() {
c0001915:	55                   	push   %ebp
c0001916:	89 e5                	mov    %esp,%ebp
c0001918:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:150
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c000191b:	e8 65 00 00 00       	call   c0001985 <intr_get_status>
c0001920:	83 f8 01             	cmp    $0x1,%eax
c0001923:	75 0c                	jne    c0001931 <intr_enable+0x1c>
/work/x86_os_my/kernel/interrupt.c:151
		old_status = INTR_ON;
c0001925:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:152
		return old_status;
c000192c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000192f:	eb 0b                	jmp    c000193c <intr_enable+0x27>
/work/x86_os_my/kernel/interrupt.c:154
	} else {
		old_status = INTR_OFF;
c0001931:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:155
		asm volatile("sti");	 // 开中断,sti指令将IF位置1
c0001938:	fb                   	sti    
/work/x86_os_my/kernel/interrupt.c:156
		return old_status;
c0001939:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:158
	}
}
c000193c:	c9                   	leave  
c000193d:	c3                   	ret    

c000193e <intr_disable>:
intr_disable():
/work/x86_os_my/kernel/interrupt.c:161

/* 关中断,并且返回关中断前的状态 */
enum intr_status intr_disable() {     
c000193e:	55                   	push   %ebp
c000193f:	89 e5                	mov    %esp,%ebp
c0001941:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/interrupt.c:163
	enum intr_status old_status;
	if (INTR_ON == intr_get_status()) {
c0001944:	e8 3c 00 00 00       	call   c0001985 <intr_get_status>
c0001949:	83 f8 01             	cmp    $0x1,%eax
c000194c:	75 0d                	jne    c000195b <intr_disable+0x1d>
/work/x86_os_my/kernel/interrupt.c:164
		old_status = INTR_ON;
c000194e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:165
		asm volatile("cli" : : : "memory"); // 关中断,cli指令将IF位置0
c0001955:	fa                   	cli    
/work/x86_os_my/kernel/interrupt.c:166
		return old_status;
c0001956:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001959:	eb 0a                	jmp    c0001965 <intr_disable+0x27>
/work/x86_os_my/kernel/interrupt.c:168
	} else {
		old_status = INTR_OFF;
c000195b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:169
		return old_status;
c0001962:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/interrupt.c:171
	}
}
c0001965:	c9                   	leave  
c0001966:	c3                   	ret    

c0001967 <intr_set_status>:
intr_set_status():
/work/x86_os_my/kernel/interrupt.c:174

/* 将中断状态设置为status */
enum intr_status intr_set_status(enum intr_status status) {
c0001967:	55                   	push   %ebp
c0001968:	89 e5                	mov    %esp,%ebp
c000196a:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/interrupt.c:175
	return status & INTR_ON ? intr_enable() : intr_disable();
c000196d:	8b 45 08             	mov    0x8(%ebp),%eax
c0001970:	83 e0 01             	and    $0x1,%eax
c0001973:	85 c0                	test   %eax,%eax
c0001975:	74 07                	je     c000197e <intr_set_status+0x17>
/work/x86_os_my/kernel/interrupt.c:175 (discriminator 1)
c0001977:	e8 99 ff ff ff       	call   c0001915 <intr_enable>
c000197c:	eb 05                	jmp    c0001983 <intr_set_status+0x1c>
/work/x86_os_my/kernel/interrupt.c:175 (discriminator 2)
c000197e:	e8 bb ff ff ff       	call   c000193e <intr_disable>
/work/x86_os_my/kernel/interrupt.c:176 (discriminator 5)
}
c0001983:	c9                   	leave  
c0001984:	c3                   	ret    

c0001985 <intr_get_status>:
intr_get_status():
/work/x86_os_my/kernel/interrupt.c:179

/* 获取当前中断状态 */
enum intr_status intr_get_status() {
c0001985:	55                   	push   %ebp
c0001986:	89 e5                	mov    %esp,%ebp
c0001988:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:180
	uint32_t eflags = 0; 
c000198b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:181
	GET_EFLAGS(eflags);
c0001992:	9c                   	pushf  
c0001993:	58                   	pop    %eax
c0001994:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:182
	return (EFLAGS_IF & eflags) ? INTR_ON : INTR_OFF;
c0001997:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000199a:	25 00 02 00 00       	and    $0x200,%eax
c000199f:	85 c0                	test   %eax,%eax
c00019a1:	0f 95 c0             	setne  %al
c00019a4:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/kernel/interrupt.c:183
}
c00019a7:	c9                   	leave  
c00019a8:	c3                   	ret    

c00019a9 <register_handler>:
register_handler():
/work/x86_os_my/kernel/interrupt.c:186

/* 在中断处理程序数组第vector_no个元素中注册安装中断处理程序function */
void register_handler(uint8_t vector_no, intr_handler function) {
c00019a9:	55                   	push   %ebp
c00019aa:	89 e5                	mov    %esp,%ebp
c00019ac:	83 ec 04             	sub    $0x4,%esp
c00019af:	8b 45 08             	mov    0x8(%ebp),%eax
c00019b2:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/kernel/interrupt.c:189
/* idt_table数组中的函数是在进入中断后根据中断向量号调用的,
 * 见kernel/kernel.S的call [idt_table + %1*4] */
   idt_table[vector_no] = function; 
c00019b5:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c00019b9:	8b 55 0c             	mov    0xc(%ebp),%edx
c00019bc:	89 14 85 40 f8 00 c0 	mov    %edx,-0x3fff07c0(,%eax,4)
/work/x86_os_my/kernel/interrupt.c:190
}
c00019c3:	90                   	nop
c00019c4:	c9                   	leave  
c00019c5:	c3                   	ret    

c00019c6 <idt_init>:
idt_init():
/work/x86_os_my/kernel/interrupt.c:193

/*完成有关中断的所有初始化工作*/
void idt_init() {
c00019c6:	55                   	push   %ebp
c00019c7:	89 e5                	mov    %esp,%ebp
c00019c9:	56                   	push   %esi
c00019ca:	53                   	push   %ebx
c00019cb:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:194
	put_str("idt_init start\n");
c00019ce:	83 ec 0c             	sub    $0xc,%esp
c00019d1:	68 52 b3 00 c0       	push   $0xc000b352
c00019d6:	e8 95 07 00 00       	call   c0002170 <put_str>
c00019db:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:195
	idt_desc_init();	// 初始化中断描述符表
c00019de:	e8 e8 fc ff ff       	call   c00016cb <idt_desc_init>
/work/x86_os_my/kernel/interrupt.c:196
	exception_init();	// 异常名初始化并注册通常的中断处理函数
c00019e3:	e8 34 fe ff ff       	call   c000181c <exception_init>
/work/x86_os_my/kernel/interrupt.c:197
	pic_init();			// 初始化8259A
c00019e8:	e8 f5 fb ff ff       	call   c00015e2 <pic_init>
/work/x86_os_my/kernel/interrupt.c:201

	/* 加载idt */
	// IDTR 是 48 位的寄存器，低 16 位是 IDT 的界限 = IDT 尺寸大小-1，高 32 位是 IDT 的线性基地址
	uint64_t idt_operand = ((sizeof(idt) - 1) | ((uint64_t)(uint32_t)idt << 16));
c00019ed:	b8 60 f1 00 c0       	mov    $0xc000f160,%eax
c00019f2:	ba 00 00 00 00       	mov    $0x0,%edx
c00019f7:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c00019fb:	c1 e0 10             	shl    $0x10,%eax
c00019fe:	89 c1                	mov    %eax,%ecx
c0001a00:	81 c9 07 04 00 00    	or     $0x407,%ecx
c0001a06:	89 cb                	mov    %ecx,%ebx
c0001a08:	89 d0                	mov    %edx,%eax
c0001a0a:	80 cc 00             	or     $0x0,%ah
c0001a0d:	89 c6                	mov    %eax,%esi
c0001a0f:	89 5d f0             	mov    %ebx,-0x10(%ebp)
c0001a12:	89 75 f4             	mov    %esi,-0xc(%ebp)
/work/x86_os_my/kernel/interrupt.c:202
	asm volatile("lidt %0" : : "m" (idt_operand));
c0001a15:	0f 01 5d f0          	lidtl  -0x10(%ebp)
/work/x86_os_my/kernel/interrupt.c:203
	put_str("idt_init done\n");
c0001a19:	83 ec 0c             	sub    $0xc,%esp
c0001a1c:	68 62 b3 00 c0       	push   $0xc000b362
c0001a21:	e8 4a 07 00 00       	call   c0002170 <put_str>
c0001a26:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/interrupt.c:204
}
c0001a29:	90                   	nop
c0001a2a:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001a2d:	5b                   	pop    %ebx
c0001a2e:	5e                   	pop    %esi
c0001a2f:	5d                   	pop    %ebp
c0001a30:	c3                   	ret    

c0001a31 <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c0001a31:	55                   	push   %ebp
c0001a32:	89 e5                	mov    %esp,%ebp
c0001a34:	83 ec 08             	sub    $0x8,%esp
c0001a37:	8b 55 08             	mov    0x8(%ebp),%edx
c0001a3a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0001a3d:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0001a41:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c0001a44:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0001a48:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0001a4c:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c0001a4d:	90                   	nop
c0001a4e:	c9                   	leave  
c0001a4f:	c3                   	ret    

c0001a50 <frequency_set>:
frequency_set():
/work/x86_os_my/device/timer.c:27
/* 把操作的计数器counter_no、读写锁属性rwl、计数器模式counter_mode写入模式控制寄存器并赋予初始值counter_value */
static void frequency_set(uint8_t counter_port, \
		uint8_t counter_no, \
		uint8_t rwl, \
		uint8_t counter_mode, \
		uint16_t counter_value) {
c0001a50:	55                   	push   %ebp
c0001a51:	89 e5                	mov    %esp,%ebp
c0001a53:	56                   	push   %esi
c0001a54:	53                   	push   %ebx
c0001a55:	83 ec 14             	sub    $0x14,%esp
c0001a58:	8b 45 08             	mov    0x8(%ebp),%eax
c0001a5b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
c0001a5e:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0001a61:	8b 55 14             	mov    0x14(%ebp),%edx
c0001a64:	8b 75 18             	mov    0x18(%ebp),%esi
c0001a67:	88 45 f4             	mov    %al,-0xc(%ebp)
c0001a6a:	88 5d f0             	mov    %bl,-0x10(%ebp)
c0001a6d:	88 4d ec             	mov    %cl,-0x14(%ebp)
c0001a70:	88 55 e8             	mov    %dl,-0x18(%ebp)
c0001a73:	66 89 75 e4          	mov    %si,-0x1c(%ebp)
/work/x86_os_my/device/timer.c:29
	/* 往控制字寄存器端口0x43中写入控制字 */
	outb(PIT_CONTROL_PORT, (uint8_t)(counter_no << 6 | rwl << 4 | counter_mode << 1));
c0001a77:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0001a7b:	c1 e0 06             	shl    $0x6,%eax
c0001a7e:	89 c2                	mov    %eax,%edx
c0001a80:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0001a84:	c1 e0 04             	shl    $0x4,%eax
c0001a87:	09 c2                	or     %eax,%edx
c0001a89:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0001a8d:	01 c0                	add    %eax,%eax
c0001a8f:	09 d0                	or     %edx,%eax
c0001a91:	0f b6 c0             	movzbl %al,%eax
c0001a94:	50                   	push   %eax
c0001a95:	6a 43                	push   $0x43
c0001a97:	e8 95 ff ff ff       	call   c0001a31 <outb>
c0001a9c:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:31
	/* 先写入counter_value的低8位 */
	outb(counter_port, (uint8_t)counter_value);
c0001a9f:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
c0001aa3:	0f b6 d0             	movzbl %al,%edx
c0001aa6:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001aaa:	52                   	push   %edx
c0001aab:	50                   	push   %eax
c0001aac:	e8 80 ff ff ff       	call   c0001a31 <outb>
c0001ab1:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:33
	/* 再写入counter_value的高8位 */
	outb(counter_port, (uint8_t)counter_value >> 8);
c0001ab4:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0001ab8:	6a 00                	push   $0x0
c0001aba:	50                   	push   %eax
c0001abb:	e8 71 ff ff ff       	call   c0001a31 <outb>
c0001ac0:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/timer.c:34
}
c0001ac3:	90                   	nop
c0001ac4:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0001ac7:	5b                   	pop    %ebx
c0001ac8:	5e                   	pop    %esi
c0001ac9:	5d                   	pop    %ebp
c0001aca:	c3                   	ret    

c0001acb <intr_timer_handler>:
intr_timer_handler():
/work/x86_os_my/device/timer.c:37

/* 时钟的中断处理函数 */
static void intr_timer_handler(void) {
c0001acb:	55                   	push   %ebp
c0001acc:	89 e5                	mov    %esp,%ebp
c0001ace:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/timer.c:38
	struct task_struct* cur_thread = running_thread();		// 返回线程PCB
c0001ad1:	e8 95 20 00 00       	call   c0003b6b <running_thread>
c0001ad6:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/timer.c:40

	ASSERT(cur_thread->stack_magic == 0x19870916);			// 检查栈是否溢出
c0001ad9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001adc:	8b 80 14 01 00 00    	mov    0x114(%eax),%eax
c0001ae2:	3d 16 09 87 19       	cmp    $0x19870916,%eax
c0001ae7:	74 19                	je     c0001b02 <intr_timer_handler+0x37>
/work/x86_os_my/device/timer.c:40 (discriminator 1)
c0001ae9:	68 74 b3 00 c0       	push   $0xc000b374
c0001aee:	68 dc b3 00 c0       	push   $0xc000b3dc
c0001af3:	6a 28                	push   $0x28
c0001af5:	68 9a b3 00 c0       	push   $0xc000b39a
c0001afa:	e8 e3 07 00 00       	call   c00022e2 <panic_spin>
c0001aff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:42

	cur_thread->elapsed_ticks++;// 记录此线程占用的cpu时间
c0001b02:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b05:	8b 40 20             	mov    0x20(%eax),%eax
c0001b08:	8d 50 01             	lea    0x1(%eax),%edx
c0001b0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b0e:	89 50 20             	mov    %edx,0x20(%eax)
/work/x86_os_my/device/timer.c:43
	ticks++;	//从内核第一次处理时间中断开始,至今的滴哒数,是内核态和用户态总共的嘀哒数
c0001b11:	a1 44 fa 00 c0       	mov    0xc000fa44,%eax
c0001b16:	83 c0 01             	add    $0x1,%eax
c0001b19:	a3 44 fa 00 c0       	mov    %eax,0xc000fa44
/work/x86_os_my/device/timer.c:45

	if (cur_thread->ticks == 0) {
c0001b1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b21:	0f b6 40 1d          	movzbl 0x1d(%eax),%eax
c0001b25:	84 c0                	test   %al,%al
c0001b27:	75 07                	jne    c0001b30 <intr_timer_handler+0x65>
/work/x86_os_my/device/timer.c:46
		schedule();				// 若进程时间片用完就开始调度新的进程上cpu
c0001b29:	e8 93 23 00 00       	call   c0003ec1 <schedule>
/work/x86_os_my/device/timer.c:50
	} else {
		cur_thread->ticks--;	// 将当前进程的时间片-1
	}
}
c0001b2e:	eb 10                	jmp    c0001b40 <intr_timer_handler+0x75>
/work/x86_os_my/device/timer.c:48
	ticks++;	//从内核第一次处理时间中断开始,至今的滴哒数,是内核态和用户态总共的嘀哒数

	if (cur_thread->ticks == 0) {
		schedule();				// 若进程时间片用完就开始调度新的进程上cpu
	} else {
		cur_thread->ticks--;	// 将当前进程的时间片-1
c0001b30:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b33:	0f b6 40 1d          	movzbl 0x1d(%eax),%eax
c0001b37:	8d 50 ff             	lea    -0x1(%eax),%edx
c0001b3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0001b3d:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/device/timer.c:50
	}
}
c0001b40:	90                   	nop
c0001b41:	c9                   	leave  
c0001b42:	c3                   	ret    

c0001b43 <ticks_to_sleep>:
ticks_to_sleep():
/work/x86_os_my/device/timer.c:53

/* 以tick为单位的sleep,任何时间形式的sleep会转换此ticks形式 */
static void ticks_to_sleep(uint32_t sleep_ticks) {
c0001b43:	55                   	push   %ebp
c0001b44:	89 e5                	mov    %esp,%ebp
c0001b46:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/timer.c:54
	uint32_t start_tick = ticks;
c0001b49:	a1 44 fa 00 c0       	mov    0xc000fa44,%eax
c0001b4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/timer.c:57

	/* 若间隔的ticks数不够便让出cpu */
	while (ticks - start_tick < sleep_ticks) {
c0001b51:	eb 05                	jmp    c0001b58 <ticks_to_sleep+0x15>
/work/x86_os_my/device/timer.c:58
		thread_yield();
c0001b53:	e8 13 26 00 00       	call   c000416b <thread_yield>
/work/x86_os_my/device/timer.c:57
/* 以tick为单位的sleep,任何时间形式的sleep会转换此ticks形式 */
static void ticks_to_sleep(uint32_t sleep_ticks) {
	uint32_t start_tick = ticks;

	/* 若间隔的ticks数不够便让出cpu */
	while (ticks - start_tick < sleep_ticks) {
c0001b58:	a1 44 fa 00 c0       	mov    0xc000fa44,%eax
c0001b5d:	2b 45 f4             	sub    -0xc(%ebp),%eax
c0001b60:	3b 45 08             	cmp    0x8(%ebp),%eax
c0001b63:	72 ee                	jb     c0001b53 <ticks_to_sleep+0x10>
/work/x86_os_my/device/timer.c:60
		thread_yield();
	}
}
c0001b65:	90                   	nop
c0001b66:	c9                   	leave  
c0001b67:	c3                   	ret    

c0001b68 <mtime_sleep>:
mtime_sleep():
/work/x86_os_my/device/timer.c:62

void mtime_sleep(uint32_t m_seconds) {
c0001b68:	55                   	push   %ebp
c0001b69:	89 e5                	mov    %esp,%ebp
c0001b6b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/timer.c:63
	uint32_t sleep_ticks = DIV_ROUND_UP(m_seconds, mil_seconds_per_intr);
c0001b6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0001b71:	83 c0 09             	add    $0x9,%eax
c0001b74:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
c0001b79:	f7 e2                	mul    %edx
c0001b7b:	89 d0                	mov    %edx,%eax
c0001b7d:	c1 e8 03             	shr    $0x3,%eax
c0001b80:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/timer.c:64
	ASSERT(sleep_ticks > 0);
c0001b83:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0001b87:	75 19                	jne    c0001ba2 <mtime_sleep+0x3a>
/work/x86_os_my/device/timer.c:64 (discriminator 1)
c0001b89:	68 a9 b3 00 c0       	push   $0xc000b3a9
c0001b8e:	68 f0 b3 00 c0       	push   $0xc000b3f0
c0001b93:	6a 40                	push   $0x40
c0001b95:	68 9a b3 00 c0       	push   $0xc000b39a
c0001b9a:	e8 43 07 00 00       	call   c00022e2 <panic_spin>
c0001b9f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:65
	ticks_to_sleep(sleep_ticks); 
c0001ba2:	83 ec 0c             	sub    $0xc,%esp
c0001ba5:	ff 75 f4             	pushl  -0xc(%ebp)
c0001ba8:	e8 96 ff ff ff       	call   c0001b43 <ticks_to_sleep>
c0001bad:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:66
}
c0001bb0:	90                   	nop
c0001bb1:	c9                   	leave  
c0001bb2:	c3                   	ret    

c0001bb3 <timer_init>:
timer_init():
/work/x86_os_my/device/timer.c:69

/* 初始化PIT8253 */
void timer_init() {
c0001bb3:	55                   	push   %ebp
c0001bb4:	89 e5                	mov    %esp,%ebp
c0001bb6:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/timer.c:70
	put_str("timer_init start\n");
c0001bb9:	83 ec 0c             	sub    $0xc,%esp
c0001bbc:	68 b9 b3 00 c0       	push   $0xc000b3b9
c0001bc1:	e8 aa 05 00 00       	call   c0002170 <put_str>
c0001bc6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:72
	/* 设置8253的定时周期,也就是发中断的周期 */
	frequency_set(CONTRER0_PORT, COUNTER0_NO, READ_WRITE_LATCH, COUNTER_MODE, COUNTER0_VALUE);
c0001bc9:	83 ec 0c             	sub    $0xc,%esp
c0001bcc:	68 9b 2e 00 00       	push   $0x2e9b
c0001bd1:	6a 02                	push   $0x2
c0001bd3:	6a 03                	push   $0x3
c0001bd5:	6a 00                	push   $0x0
c0001bd7:	6a 40                	push   $0x40
c0001bd9:	e8 72 fe ff ff       	call   c0001a50 <frequency_set>
c0001bde:	83 c4 20             	add    $0x20,%esp
/work/x86_os_my/device/timer.c:73
	register_handler(0x20, intr_timer_handler);
c0001be1:	83 ec 08             	sub    $0x8,%esp
c0001be4:	68 cb 1a 00 c0       	push   $0xc0001acb
c0001be9:	6a 20                	push   $0x20
c0001beb:	e8 b9 fd ff ff       	call   c00019a9 <register_handler>
c0001bf0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:74
	put_str("timer_init done\n");
c0001bf3:	83 ec 0c             	sub    $0xc,%esp
c0001bf6:	68 cb b3 00 c0       	push   $0xc000b3cb
c0001bfb:	e8 70 05 00 00       	call   c0002170 <put_str>
c0001c00:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/timer.c:75
}
c0001c03:	90                   	nop
c0001c04:	c9                   	leave  
c0001c05:	c3                   	ret    
c0001c06:	66 90                	xchg   %ax,%ax
c0001c08:	66 90                	xchg   %ax,%ax
c0001c0a:	66 90                	xchg   %ax,%ax
c0001c0c:	66 90                	xchg   %ax,%ax
c0001c0e:	66 90                	xchg   %ax,%ax

c0001c10 <intr_exit>:
intr_exit():
c0001c10:	83 c4 04             	add    $0x4,%esp
c0001c13:	61                   	popa   
c0001c14:	0f a9                	pop    %gs
c0001c16:	0f a1                	pop    %fs
c0001c18:	07                   	pop    %es
c0001c19:	1f                   	pop    %ds
c0001c1a:	83 c4 04             	add    $0x4,%esp
c0001c1d:	cf                   	iret   

c0001c1e <intr0x00entry>:
intr0x00entry():
c0001c1e:	6a 00                	push   $0x0
c0001c20:	1e                   	push   %ds
c0001c21:	06                   	push   %es
c0001c22:	0f a0                	push   %fs
c0001c24:	0f a8                	push   %gs
c0001c26:	60                   	pusha  
c0001c27:	b0 20                	mov    $0x20,%al
c0001c29:	e6 a0                	out    %al,$0xa0
c0001c2b:	e6 20                	out    %al,$0x20
c0001c2d:	6a 00                	push   $0x0
c0001c2f:	ff 15 40 f8 00 c0    	call   *0xc000f840
c0001c35:	eb d9                	jmp    c0001c10 <intr_exit>

c0001c37 <intr0x01entry>:
intr0x01entry():
c0001c37:	6a 00                	push   $0x0
c0001c39:	1e                   	push   %ds
c0001c3a:	06                   	push   %es
c0001c3b:	0f a0                	push   %fs
c0001c3d:	0f a8                	push   %gs
c0001c3f:	60                   	pusha  
c0001c40:	b0 20                	mov    $0x20,%al
c0001c42:	e6 a0                	out    %al,$0xa0
c0001c44:	e6 20                	out    %al,$0x20
c0001c46:	6a 01                	push   $0x1
c0001c48:	ff 15 44 f8 00 c0    	call   *0xc000f844
c0001c4e:	eb c0                	jmp    c0001c10 <intr_exit>

c0001c50 <intr0x02entry>:
intr0x02entry():
c0001c50:	6a 00                	push   $0x0
c0001c52:	1e                   	push   %ds
c0001c53:	06                   	push   %es
c0001c54:	0f a0                	push   %fs
c0001c56:	0f a8                	push   %gs
c0001c58:	60                   	pusha  
c0001c59:	b0 20                	mov    $0x20,%al
c0001c5b:	e6 a0                	out    %al,$0xa0
c0001c5d:	e6 20                	out    %al,$0x20
c0001c5f:	6a 02                	push   $0x2
c0001c61:	ff 15 48 f8 00 c0    	call   *0xc000f848
c0001c67:	eb a7                	jmp    c0001c10 <intr_exit>

c0001c69 <intr0x03entry>:
intr0x03entry():
c0001c69:	6a 00                	push   $0x0
c0001c6b:	1e                   	push   %ds
c0001c6c:	06                   	push   %es
c0001c6d:	0f a0                	push   %fs
c0001c6f:	0f a8                	push   %gs
c0001c71:	60                   	pusha  
c0001c72:	b0 20                	mov    $0x20,%al
c0001c74:	e6 a0                	out    %al,$0xa0
c0001c76:	e6 20                	out    %al,$0x20
c0001c78:	6a 03                	push   $0x3
c0001c7a:	ff 15 4c f8 00 c0    	call   *0xc000f84c
c0001c80:	eb 8e                	jmp    c0001c10 <intr_exit>

c0001c82 <intr0x04entry>:
intr0x04entry():
c0001c82:	6a 00                	push   $0x0
c0001c84:	1e                   	push   %ds
c0001c85:	06                   	push   %es
c0001c86:	0f a0                	push   %fs
c0001c88:	0f a8                	push   %gs
c0001c8a:	60                   	pusha  
c0001c8b:	b0 20                	mov    $0x20,%al
c0001c8d:	e6 a0                	out    %al,$0xa0
c0001c8f:	e6 20                	out    %al,$0x20
c0001c91:	6a 04                	push   $0x4
c0001c93:	ff 15 50 f8 00 c0    	call   *0xc000f850
c0001c99:	e9 72 ff ff ff       	jmp    c0001c10 <intr_exit>

c0001c9e <intr0x05entry>:
intr0x05entry():
c0001c9e:	6a 00                	push   $0x0
c0001ca0:	1e                   	push   %ds
c0001ca1:	06                   	push   %es
c0001ca2:	0f a0                	push   %fs
c0001ca4:	0f a8                	push   %gs
c0001ca6:	60                   	pusha  
c0001ca7:	b0 20                	mov    $0x20,%al
c0001ca9:	e6 a0                	out    %al,$0xa0
c0001cab:	e6 20                	out    %al,$0x20
c0001cad:	6a 05                	push   $0x5
c0001caf:	ff 15 54 f8 00 c0    	call   *0xc000f854
c0001cb5:	e9 56 ff ff ff       	jmp    c0001c10 <intr_exit>

c0001cba <intr0x06entry>:
intr0x06entry():
c0001cba:	6a 00                	push   $0x0
c0001cbc:	1e                   	push   %ds
c0001cbd:	06                   	push   %es
c0001cbe:	0f a0                	push   %fs
c0001cc0:	0f a8                	push   %gs
c0001cc2:	60                   	pusha  
c0001cc3:	b0 20                	mov    $0x20,%al
c0001cc5:	e6 a0                	out    %al,$0xa0
c0001cc7:	e6 20                	out    %al,$0x20
c0001cc9:	6a 06                	push   $0x6
c0001ccb:	ff 15 58 f8 00 c0    	call   *0xc000f858
c0001cd1:	e9 3a ff ff ff       	jmp    c0001c10 <intr_exit>

c0001cd6 <intr0x07entry>:
intr0x07entry():
c0001cd6:	6a 00                	push   $0x0
c0001cd8:	1e                   	push   %ds
c0001cd9:	06                   	push   %es
c0001cda:	0f a0                	push   %fs
c0001cdc:	0f a8                	push   %gs
c0001cde:	60                   	pusha  
c0001cdf:	b0 20                	mov    $0x20,%al
c0001ce1:	e6 a0                	out    %al,$0xa0
c0001ce3:	e6 20                	out    %al,$0x20
c0001ce5:	6a 07                	push   $0x7
c0001ce7:	ff 15 5c f8 00 c0    	call   *0xc000f85c
c0001ced:	e9 1e ff ff ff       	jmp    c0001c10 <intr_exit>

c0001cf2 <intr0x08entry>:
intr0x08entry():
c0001cf2:	90                   	nop
c0001cf3:	1e                   	push   %ds
c0001cf4:	06                   	push   %es
c0001cf5:	0f a0                	push   %fs
c0001cf7:	0f a8                	push   %gs
c0001cf9:	60                   	pusha  
c0001cfa:	b0 20                	mov    $0x20,%al
c0001cfc:	e6 a0                	out    %al,$0xa0
c0001cfe:	e6 20                	out    %al,$0x20
c0001d00:	6a 08                	push   $0x8
c0001d02:	ff 15 60 f8 00 c0    	call   *0xc000f860
c0001d08:	e9 03 ff ff ff       	jmp    c0001c10 <intr_exit>

c0001d0d <intr0x09entry>:
intr0x09entry():
c0001d0d:	6a 00                	push   $0x0
c0001d0f:	1e                   	push   %ds
c0001d10:	06                   	push   %es
c0001d11:	0f a0                	push   %fs
c0001d13:	0f a8                	push   %gs
c0001d15:	60                   	pusha  
c0001d16:	b0 20                	mov    $0x20,%al
c0001d18:	e6 a0                	out    %al,$0xa0
c0001d1a:	e6 20                	out    %al,$0x20
c0001d1c:	6a 09                	push   $0x9
c0001d1e:	ff 15 64 f8 00 c0    	call   *0xc000f864
c0001d24:	e9 e7 fe ff ff       	jmp    c0001c10 <intr_exit>

c0001d29 <intr0x0aentry>:
intr0x0aentry():
c0001d29:	90                   	nop
c0001d2a:	1e                   	push   %ds
c0001d2b:	06                   	push   %es
c0001d2c:	0f a0                	push   %fs
c0001d2e:	0f a8                	push   %gs
c0001d30:	60                   	pusha  
c0001d31:	b0 20                	mov    $0x20,%al
c0001d33:	e6 a0                	out    %al,$0xa0
c0001d35:	e6 20                	out    %al,$0x20
c0001d37:	6a 0a                	push   $0xa
c0001d39:	ff 15 68 f8 00 c0    	call   *0xc000f868
c0001d3f:	e9 cc fe ff ff       	jmp    c0001c10 <intr_exit>

c0001d44 <intr0x0bentry>:
intr0x0bentry():
c0001d44:	90                   	nop
c0001d45:	1e                   	push   %ds
c0001d46:	06                   	push   %es
c0001d47:	0f a0                	push   %fs
c0001d49:	0f a8                	push   %gs
c0001d4b:	60                   	pusha  
c0001d4c:	b0 20                	mov    $0x20,%al
c0001d4e:	e6 a0                	out    %al,$0xa0
c0001d50:	e6 20                	out    %al,$0x20
c0001d52:	6a 0b                	push   $0xb
c0001d54:	ff 15 6c f8 00 c0    	call   *0xc000f86c
c0001d5a:	e9 b1 fe ff ff       	jmp    c0001c10 <intr_exit>

c0001d5f <intr0x0centry>:
intr0x0centry():
c0001d5f:	6a 00                	push   $0x0
c0001d61:	1e                   	push   %ds
c0001d62:	06                   	push   %es
c0001d63:	0f a0                	push   %fs
c0001d65:	0f a8                	push   %gs
c0001d67:	60                   	pusha  
c0001d68:	b0 20                	mov    $0x20,%al
c0001d6a:	e6 a0                	out    %al,$0xa0
c0001d6c:	e6 20                	out    %al,$0x20
c0001d6e:	6a 0c                	push   $0xc
c0001d70:	ff 15 70 f8 00 c0    	call   *0xc000f870
c0001d76:	e9 95 fe ff ff       	jmp    c0001c10 <intr_exit>

c0001d7b <intr0x0dentry>:
intr0x0dentry():
c0001d7b:	90                   	nop
c0001d7c:	1e                   	push   %ds
c0001d7d:	06                   	push   %es
c0001d7e:	0f a0                	push   %fs
c0001d80:	0f a8                	push   %gs
c0001d82:	60                   	pusha  
c0001d83:	b0 20                	mov    $0x20,%al
c0001d85:	e6 a0                	out    %al,$0xa0
c0001d87:	e6 20                	out    %al,$0x20
c0001d89:	6a 0d                	push   $0xd
c0001d8b:	ff 15 74 f8 00 c0    	call   *0xc000f874
c0001d91:	e9 7a fe ff ff       	jmp    c0001c10 <intr_exit>

c0001d96 <intr0x0eentry>:
intr0x0eentry():
c0001d96:	90                   	nop
c0001d97:	1e                   	push   %ds
c0001d98:	06                   	push   %es
c0001d99:	0f a0                	push   %fs
c0001d9b:	0f a8                	push   %gs
c0001d9d:	60                   	pusha  
c0001d9e:	b0 20                	mov    $0x20,%al
c0001da0:	e6 a0                	out    %al,$0xa0
c0001da2:	e6 20                	out    %al,$0x20
c0001da4:	6a 0e                	push   $0xe
c0001da6:	ff 15 78 f8 00 c0    	call   *0xc000f878
c0001dac:	e9 5f fe ff ff       	jmp    c0001c10 <intr_exit>

c0001db1 <intr0x0fentry>:
intr0x0fentry():
c0001db1:	6a 00                	push   $0x0
c0001db3:	1e                   	push   %ds
c0001db4:	06                   	push   %es
c0001db5:	0f a0                	push   %fs
c0001db7:	0f a8                	push   %gs
c0001db9:	60                   	pusha  
c0001dba:	b0 20                	mov    $0x20,%al
c0001dbc:	e6 a0                	out    %al,$0xa0
c0001dbe:	e6 20                	out    %al,$0x20
c0001dc0:	6a 0f                	push   $0xf
c0001dc2:	ff 15 7c f8 00 c0    	call   *0xc000f87c
c0001dc8:	e9 43 fe ff ff       	jmp    c0001c10 <intr_exit>

c0001dcd <intr0x10entry>:
intr0x10entry():
c0001dcd:	6a 00                	push   $0x0
c0001dcf:	1e                   	push   %ds
c0001dd0:	06                   	push   %es
c0001dd1:	0f a0                	push   %fs
c0001dd3:	0f a8                	push   %gs
c0001dd5:	60                   	pusha  
c0001dd6:	b0 20                	mov    $0x20,%al
c0001dd8:	e6 a0                	out    %al,$0xa0
c0001dda:	e6 20                	out    %al,$0x20
c0001ddc:	6a 10                	push   $0x10
c0001dde:	ff 15 80 f8 00 c0    	call   *0xc000f880
c0001de4:	e9 27 fe ff ff       	jmp    c0001c10 <intr_exit>

c0001de9 <intr0x11entry>:
intr0x11entry():
c0001de9:	90                   	nop
c0001dea:	1e                   	push   %ds
c0001deb:	06                   	push   %es
c0001dec:	0f a0                	push   %fs
c0001dee:	0f a8                	push   %gs
c0001df0:	60                   	pusha  
c0001df1:	b0 20                	mov    $0x20,%al
c0001df3:	e6 a0                	out    %al,$0xa0
c0001df5:	e6 20                	out    %al,$0x20
c0001df7:	6a 11                	push   $0x11
c0001df9:	ff 15 84 f8 00 c0    	call   *0xc000f884
c0001dff:	e9 0c fe ff ff       	jmp    c0001c10 <intr_exit>

c0001e04 <intr0x12entry>:
intr0x12entry():
c0001e04:	6a 00                	push   $0x0
c0001e06:	1e                   	push   %ds
c0001e07:	06                   	push   %es
c0001e08:	0f a0                	push   %fs
c0001e0a:	0f a8                	push   %gs
c0001e0c:	60                   	pusha  
c0001e0d:	b0 20                	mov    $0x20,%al
c0001e0f:	e6 a0                	out    %al,$0xa0
c0001e11:	e6 20                	out    %al,$0x20
c0001e13:	6a 12                	push   $0x12
c0001e15:	ff 15 88 f8 00 c0    	call   *0xc000f888
c0001e1b:	e9 f0 fd ff ff       	jmp    c0001c10 <intr_exit>

c0001e20 <intr0x13entry>:
intr0x13entry():
c0001e20:	6a 00                	push   $0x0
c0001e22:	1e                   	push   %ds
c0001e23:	06                   	push   %es
c0001e24:	0f a0                	push   %fs
c0001e26:	0f a8                	push   %gs
c0001e28:	60                   	pusha  
c0001e29:	b0 20                	mov    $0x20,%al
c0001e2b:	e6 a0                	out    %al,$0xa0
c0001e2d:	e6 20                	out    %al,$0x20
c0001e2f:	6a 13                	push   $0x13
c0001e31:	ff 15 8c f8 00 c0    	call   *0xc000f88c
c0001e37:	e9 d4 fd ff ff       	jmp    c0001c10 <intr_exit>

c0001e3c <intr0x14entry>:
intr0x14entry():
c0001e3c:	6a 00                	push   $0x0
c0001e3e:	1e                   	push   %ds
c0001e3f:	06                   	push   %es
c0001e40:	0f a0                	push   %fs
c0001e42:	0f a8                	push   %gs
c0001e44:	60                   	pusha  
c0001e45:	b0 20                	mov    $0x20,%al
c0001e47:	e6 a0                	out    %al,$0xa0
c0001e49:	e6 20                	out    %al,$0x20
c0001e4b:	6a 14                	push   $0x14
c0001e4d:	ff 15 90 f8 00 c0    	call   *0xc000f890
c0001e53:	e9 b8 fd ff ff       	jmp    c0001c10 <intr_exit>

c0001e58 <intr0x15entry>:
intr0x15entry():
c0001e58:	6a 00                	push   $0x0
c0001e5a:	1e                   	push   %ds
c0001e5b:	06                   	push   %es
c0001e5c:	0f a0                	push   %fs
c0001e5e:	0f a8                	push   %gs
c0001e60:	60                   	pusha  
c0001e61:	b0 20                	mov    $0x20,%al
c0001e63:	e6 a0                	out    %al,$0xa0
c0001e65:	e6 20                	out    %al,$0x20
c0001e67:	6a 15                	push   $0x15
c0001e69:	ff 15 94 f8 00 c0    	call   *0xc000f894
c0001e6f:	e9 9c fd ff ff       	jmp    c0001c10 <intr_exit>

c0001e74 <intr0x16entry>:
intr0x16entry():
c0001e74:	6a 00                	push   $0x0
c0001e76:	1e                   	push   %ds
c0001e77:	06                   	push   %es
c0001e78:	0f a0                	push   %fs
c0001e7a:	0f a8                	push   %gs
c0001e7c:	60                   	pusha  
c0001e7d:	b0 20                	mov    $0x20,%al
c0001e7f:	e6 a0                	out    %al,$0xa0
c0001e81:	e6 20                	out    %al,$0x20
c0001e83:	6a 16                	push   $0x16
c0001e85:	ff 15 98 f8 00 c0    	call   *0xc000f898
c0001e8b:	e9 80 fd ff ff       	jmp    c0001c10 <intr_exit>

c0001e90 <intr0x17entry>:
intr0x17entry():
c0001e90:	6a 00                	push   $0x0
c0001e92:	1e                   	push   %ds
c0001e93:	06                   	push   %es
c0001e94:	0f a0                	push   %fs
c0001e96:	0f a8                	push   %gs
c0001e98:	60                   	pusha  
c0001e99:	b0 20                	mov    $0x20,%al
c0001e9b:	e6 a0                	out    %al,$0xa0
c0001e9d:	e6 20                	out    %al,$0x20
c0001e9f:	6a 17                	push   $0x17
c0001ea1:	ff 15 9c f8 00 c0    	call   *0xc000f89c
c0001ea7:	e9 64 fd ff ff       	jmp    c0001c10 <intr_exit>

c0001eac <intr0x18entry>:
intr0x18entry():
c0001eac:	90                   	nop
c0001ead:	1e                   	push   %ds
c0001eae:	06                   	push   %es
c0001eaf:	0f a0                	push   %fs
c0001eb1:	0f a8                	push   %gs
c0001eb3:	60                   	pusha  
c0001eb4:	b0 20                	mov    $0x20,%al
c0001eb6:	e6 a0                	out    %al,$0xa0
c0001eb8:	e6 20                	out    %al,$0x20
c0001eba:	6a 18                	push   $0x18
c0001ebc:	ff 15 a0 f8 00 c0    	call   *0xc000f8a0
c0001ec2:	e9 49 fd ff ff       	jmp    c0001c10 <intr_exit>

c0001ec7 <intr0x19entry>:
intr0x19entry():
c0001ec7:	6a 00                	push   $0x0
c0001ec9:	1e                   	push   %ds
c0001eca:	06                   	push   %es
c0001ecb:	0f a0                	push   %fs
c0001ecd:	0f a8                	push   %gs
c0001ecf:	60                   	pusha  
c0001ed0:	b0 20                	mov    $0x20,%al
c0001ed2:	e6 a0                	out    %al,$0xa0
c0001ed4:	e6 20                	out    %al,$0x20
c0001ed6:	6a 19                	push   $0x19
c0001ed8:	ff 15 a4 f8 00 c0    	call   *0xc000f8a4
c0001ede:	e9 2d fd ff ff       	jmp    c0001c10 <intr_exit>

c0001ee3 <intr0x1aentry>:
intr0x1aentry():
c0001ee3:	90                   	nop
c0001ee4:	1e                   	push   %ds
c0001ee5:	06                   	push   %es
c0001ee6:	0f a0                	push   %fs
c0001ee8:	0f a8                	push   %gs
c0001eea:	60                   	pusha  
c0001eeb:	b0 20                	mov    $0x20,%al
c0001eed:	e6 a0                	out    %al,$0xa0
c0001eef:	e6 20                	out    %al,$0x20
c0001ef1:	6a 1a                	push   $0x1a
c0001ef3:	ff 15 a8 f8 00 c0    	call   *0xc000f8a8
c0001ef9:	e9 12 fd ff ff       	jmp    c0001c10 <intr_exit>

c0001efe <intr0x1bentry>:
intr0x1bentry():
c0001efe:	90                   	nop
c0001eff:	1e                   	push   %ds
c0001f00:	06                   	push   %es
c0001f01:	0f a0                	push   %fs
c0001f03:	0f a8                	push   %gs
c0001f05:	60                   	pusha  
c0001f06:	b0 20                	mov    $0x20,%al
c0001f08:	e6 a0                	out    %al,$0xa0
c0001f0a:	e6 20                	out    %al,$0x20
c0001f0c:	6a 1b                	push   $0x1b
c0001f0e:	ff 15 ac f8 00 c0    	call   *0xc000f8ac
c0001f14:	e9 f7 fc ff ff       	jmp    c0001c10 <intr_exit>

c0001f19 <intr0x1centry>:
intr0x1centry():
c0001f19:	6a 00                	push   $0x0
c0001f1b:	1e                   	push   %ds
c0001f1c:	06                   	push   %es
c0001f1d:	0f a0                	push   %fs
c0001f1f:	0f a8                	push   %gs
c0001f21:	60                   	pusha  
c0001f22:	b0 20                	mov    $0x20,%al
c0001f24:	e6 a0                	out    %al,$0xa0
c0001f26:	e6 20                	out    %al,$0x20
c0001f28:	6a 1c                	push   $0x1c
c0001f2a:	ff 15 b0 f8 00 c0    	call   *0xc000f8b0
c0001f30:	e9 db fc ff ff       	jmp    c0001c10 <intr_exit>

c0001f35 <intr0x1dentry>:
intr0x1dentry():
c0001f35:	90                   	nop
c0001f36:	1e                   	push   %ds
c0001f37:	06                   	push   %es
c0001f38:	0f a0                	push   %fs
c0001f3a:	0f a8                	push   %gs
c0001f3c:	60                   	pusha  
c0001f3d:	b0 20                	mov    $0x20,%al
c0001f3f:	e6 a0                	out    %al,$0xa0
c0001f41:	e6 20                	out    %al,$0x20
c0001f43:	6a 1d                	push   $0x1d
c0001f45:	ff 15 b4 f8 00 c0    	call   *0xc000f8b4
c0001f4b:	e9 c0 fc ff ff       	jmp    c0001c10 <intr_exit>

c0001f50 <intr0x1eentry>:
intr0x1eentry():
c0001f50:	90                   	nop
c0001f51:	1e                   	push   %ds
c0001f52:	06                   	push   %es
c0001f53:	0f a0                	push   %fs
c0001f55:	0f a8                	push   %gs
c0001f57:	60                   	pusha  
c0001f58:	b0 20                	mov    $0x20,%al
c0001f5a:	e6 a0                	out    %al,$0xa0
c0001f5c:	e6 20                	out    %al,$0x20
c0001f5e:	6a 1e                	push   $0x1e
c0001f60:	ff 15 b8 f8 00 c0    	call   *0xc000f8b8
c0001f66:	e9 a5 fc ff ff       	jmp    c0001c10 <intr_exit>

c0001f6b <intr0x1fentry>:
intr0x1fentry():
c0001f6b:	6a 00                	push   $0x0
c0001f6d:	1e                   	push   %ds
c0001f6e:	06                   	push   %es
c0001f6f:	0f a0                	push   %fs
c0001f71:	0f a8                	push   %gs
c0001f73:	60                   	pusha  
c0001f74:	b0 20                	mov    $0x20,%al
c0001f76:	e6 a0                	out    %al,$0xa0
c0001f78:	e6 20                	out    %al,$0x20
c0001f7a:	6a 1f                	push   $0x1f
c0001f7c:	ff 15 bc f8 00 c0    	call   *0xc000f8bc
c0001f82:	e9 89 fc ff ff       	jmp    c0001c10 <intr_exit>

c0001f87 <intr0x20entry>:
intr0x20entry():
c0001f87:	6a 00                	push   $0x0
c0001f89:	1e                   	push   %ds
c0001f8a:	06                   	push   %es
c0001f8b:	0f a0                	push   %fs
c0001f8d:	0f a8                	push   %gs
c0001f8f:	60                   	pusha  
c0001f90:	b0 20                	mov    $0x20,%al
c0001f92:	e6 a0                	out    %al,$0xa0
c0001f94:	e6 20                	out    %al,$0x20
c0001f96:	6a 20                	push   $0x20
c0001f98:	ff 15 c0 f8 00 c0    	call   *0xc000f8c0
c0001f9e:	e9 6d fc ff ff       	jmp    c0001c10 <intr_exit>

c0001fa3 <intr0x21entry>:
intr0x21entry():
c0001fa3:	6a 00                	push   $0x0
c0001fa5:	1e                   	push   %ds
c0001fa6:	06                   	push   %es
c0001fa7:	0f a0                	push   %fs
c0001fa9:	0f a8                	push   %gs
c0001fab:	60                   	pusha  
c0001fac:	b0 20                	mov    $0x20,%al
c0001fae:	e6 a0                	out    %al,$0xa0
c0001fb0:	e6 20                	out    %al,$0x20
c0001fb2:	6a 21                	push   $0x21
c0001fb4:	ff 15 c4 f8 00 c0    	call   *0xc000f8c4
c0001fba:	e9 51 fc ff ff       	jmp    c0001c10 <intr_exit>

c0001fbf <intr0x22entry>:
intr0x22entry():
c0001fbf:	6a 00                	push   $0x0
c0001fc1:	1e                   	push   %ds
c0001fc2:	06                   	push   %es
c0001fc3:	0f a0                	push   %fs
c0001fc5:	0f a8                	push   %gs
c0001fc7:	60                   	pusha  
c0001fc8:	b0 20                	mov    $0x20,%al
c0001fca:	e6 a0                	out    %al,$0xa0
c0001fcc:	e6 20                	out    %al,$0x20
c0001fce:	6a 22                	push   $0x22
c0001fd0:	ff 15 c8 f8 00 c0    	call   *0xc000f8c8
c0001fd6:	e9 35 fc ff ff       	jmp    c0001c10 <intr_exit>

c0001fdb <intr0x23entry>:
intr0x23entry():
c0001fdb:	6a 00                	push   $0x0
c0001fdd:	1e                   	push   %ds
c0001fde:	06                   	push   %es
c0001fdf:	0f a0                	push   %fs
c0001fe1:	0f a8                	push   %gs
c0001fe3:	60                   	pusha  
c0001fe4:	b0 20                	mov    $0x20,%al
c0001fe6:	e6 a0                	out    %al,$0xa0
c0001fe8:	e6 20                	out    %al,$0x20
c0001fea:	6a 23                	push   $0x23
c0001fec:	ff 15 cc f8 00 c0    	call   *0xc000f8cc
c0001ff2:	e9 19 fc ff ff       	jmp    c0001c10 <intr_exit>

c0001ff7 <intr0x24entry>:
intr0x24entry():
c0001ff7:	6a 00                	push   $0x0
c0001ff9:	1e                   	push   %ds
c0001ffa:	06                   	push   %es
c0001ffb:	0f a0                	push   %fs
c0001ffd:	0f a8                	push   %gs
c0001fff:	60                   	pusha  
c0002000:	b0 20                	mov    $0x20,%al
c0002002:	e6 a0                	out    %al,$0xa0
c0002004:	e6 20                	out    %al,$0x20
c0002006:	6a 24                	push   $0x24
c0002008:	ff 15 d0 f8 00 c0    	call   *0xc000f8d0
c000200e:	e9 fd fb ff ff       	jmp    c0001c10 <intr_exit>

c0002013 <intr0x25entry>:
intr0x25entry():
c0002013:	6a 00                	push   $0x0
c0002015:	1e                   	push   %ds
c0002016:	06                   	push   %es
c0002017:	0f a0                	push   %fs
c0002019:	0f a8                	push   %gs
c000201b:	60                   	pusha  
c000201c:	b0 20                	mov    $0x20,%al
c000201e:	e6 a0                	out    %al,$0xa0
c0002020:	e6 20                	out    %al,$0x20
c0002022:	6a 25                	push   $0x25
c0002024:	ff 15 d4 f8 00 c0    	call   *0xc000f8d4
c000202a:	e9 e1 fb ff ff       	jmp    c0001c10 <intr_exit>

c000202f <intr0x26entry>:
intr0x26entry():
c000202f:	6a 00                	push   $0x0
c0002031:	1e                   	push   %ds
c0002032:	06                   	push   %es
c0002033:	0f a0                	push   %fs
c0002035:	0f a8                	push   %gs
c0002037:	60                   	pusha  
c0002038:	b0 20                	mov    $0x20,%al
c000203a:	e6 a0                	out    %al,$0xa0
c000203c:	e6 20                	out    %al,$0x20
c000203e:	6a 26                	push   $0x26
c0002040:	ff 15 d8 f8 00 c0    	call   *0xc000f8d8
c0002046:	e9 c5 fb ff ff       	jmp    c0001c10 <intr_exit>

c000204b <intr0x27entry>:
intr0x27entry():
c000204b:	6a 00                	push   $0x0
c000204d:	1e                   	push   %ds
c000204e:	06                   	push   %es
c000204f:	0f a0                	push   %fs
c0002051:	0f a8                	push   %gs
c0002053:	60                   	pusha  
c0002054:	b0 20                	mov    $0x20,%al
c0002056:	e6 a0                	out    %al,$0xa0
c0002058:	e6 20                	out    %al,$0x20
c000205a:	6a 27                	push   $0x27
c000205c:	ff 15 dc f8 00 c0    	call   *0xc000f8dc
c0002062:	e9 a9 fb ff ff       	jmp    c0001c10 <intr_exit>

c0002067 <intr0x28entry>:
intr0x28entry():
c0002067:	6a 00                	push   $0x0
c0002069:	1e                   	push   %ds
c000206a:	06                   	push   %es
c000206b:	0f a0                	push   %fs
c000206d:	0f a8                	push   %gs
c000206f:	60                   	pusha  
c0002070:	b0 20                	mov    $0x20,%al
c0002072:	e6 a0                	out    %al,$0xa0
c0002074:	e6 20                	out    %al,$0x20
c0002076:	6a 28                	push   $0x28
c0002078:	ff 15 e0 f8 00 c0    	call   *0xc000f8e0
c000207e:	e9 8d fb ff ff       	jmp    c0001c10 <intr_exit>

c0002083 <intr0x29entry>:
intr0x29entry():
c0002083:	6a 00                	push   $0x0
c0002085:	1e                   	push   %ds
c0002086:	06                   	push   %es
c0002087:	0f a0                	push   %fs
c0002089:	0f a8                	push   %gs
c000208b:	60                   	pusha  
c000208c:	b0 20                	mov    $0x20,%al
c000208e:	e6 a0                	out    %al,$0xa0
c0002090:	e6 20                	out    %al,$0x20
c0002092:	6a 29                	push   $0x29
c0002094:	ff 15 e4 f8 00 c0    	call   *0xc000f8e4
c000209a:	e9 71 fb ff ff       	jmp    c0001c10 <intr_exit>

c000209f <intr0x2aentry>:
intr0x2aentry():
c000209f:	6a 00                	push   $0x0
c00020a1:	1e                   	push   %ds
c00020a2:	06                   	push   %es
c00020a3:	0f a0                	push   %fs
c00020a5:	0f a8                	push   %gs
c00020a7:	60                   	pusha  
c00020a8:	b0 20                	mov    $0x20,%al
c00020aa:	e6 a0                	out    %al,$0xa0
c00020ac:	e6 20                	out    %al,$0x20
c00020ae:	6a 2a                	push   $0x2a
c00020b0:	ff 15 e8 f8 00 c0    	call   *0xc000f8e8
c00020b6:	e9 55 fb ff ff       	jmp    c0001c10 <intr_exit>

c00020bb <intr0x2bentry>:
intr0x2bentry():
c00020bb:	6a 00                	push   $0x0
c00020bd:	1e                   	push   %ds
c00020be:	06                   	push   %es
c00020bf:	0f a0                	push   %fs
c00020c1:	0f a8                	push   %gs
c00020c3:	60                   	pusha  
c00020c4:	b0 20                	mov    $0x20,%al
c00020c6:	e6 a0                	out    %al,$0xa0
c00020c8:	e6 20                	out    %al,$0x20
c00020ca:	6a 2b                	push   $0x2b
c00020cc:	ff 15 ec f8 00 c0    	call   *0xc000f8ec
c00020d2:	e9 39 fb ff ff       	jmp    c0001c10 <intr_exit>

c00020d7 <intr0x2centry>:
intr0x2centry():
c00020d7:	6a 00                	push   $0x0
c00020d9:	1e                   	push   %ds
c00020da:	06                   	push   %es
c00020db:	0f a0                	push   %fs
c00020dd:	0f a8                	push   %gs
c00020df:	60                   	pusha  
c00020e0:	b0 20                	mov    $0x20,%al
c00020e2:	e6 a0                	out    %al,$0xa0
c00020e4:	e6 20                	out    %al,$0x20
c00020e6:	6a 2c                	push   $0x2c
c00020e8:	ff 15 f0 f8 00 c0    	call   *0xc000f8f0
c00020ee:	e9 1d fb ff ff       	jmp    c0001c10 <intr_exit>

c00020f3 <intr0x2dentry>:
intr0x2dentry():
c00020f3:	6a 00                	push   $0x0
c00020f5:	1e                   	push   %ds
c00020f6:	06                   	push   %es
c00020f7:	0f a0                	push   %fs
c00020f9:	0f a8                	push   %gs
c00020fb:	60                   	pusha  
c00020fc:	b0 20                	mov    $0x20,%al
c00020fe:	e6 a0                	out    %al,$0xa0
c0002100:	e6 20                	out    %al,$0x20
c0002102:	6a 2d                	push   $0x2d
c0002104:	ff 15 f4 f8 00 c0    	call   *0xc000f8f4
c000210a:	e9 01 fb ff ff       	jmp    c0001c10 <intr_exit>

c000210f <intr0x2eentry>:
intr0x2eentry():
c000210f:	6a 00                	push   $0x0
c0002111:	1e                   	push   %ds
c0002112:	06                   	push   %es
c0002113:	0f a0                	push   %fs
c0002115:	0f a8                	push   %gs
c0002117:	60                   	pusha  
c0002118:	b0 20                	mov    $0x20,%al
c000211a:	e6 a0                	out    %al,$0xa0
c000211c:	e6 20                	out    %al,$0x20
c000211e:	6a 2e                	push   $0x2e
c0002120:	ff 15 f8 f8 00 c0    	call   *0xc000f8f8
c0002126:	e9 e5 fa ff ff       	jmp    c0001c10 <intr_exit>

c000212b <intr0x2fentry>:
intr0x2fentry():
c000212b:	6a 00                	push   $0x0
c000212d:	1e                   	push   %ds
c000212e:	06                   	push   %es
c000212f:	0f a0                	push   %fs
c0002131:	0f a8                	push   %gs
c0002133:	60                   	pusha  
c0002134:	b0 20                	mov    $0x20,%al
c0002136:	e6 a0                	out    %al,$0xa0
c0002138:	e6 20                	out    %al,$0x20
c000213a:	6a 2f                	push   $0x2f
c000213c:	ff 15 fc f8 00 c0    	call   *0xc000f8fc
c0002142:	e9 c9 fa ff ff       	jmp    c0001c10 <intr_exit>

c0002147 <syscall_handler>:
syscall_handler():
c0002147:	6a 00                	push   $0x0
c0002149:	1e                   	push   %ds
c000214a:	06                   	push   %es
c000214b:	0f a0                	push   %fs
c000214d:	0f a8                	push   %gs
c000214f:	60                   	pusha  
c0002150:	68 80 00 00 00       	push   $0x80
c0002155:	52                   	push   %edx
c0002156:	51                   	push   %ecx
c0002157:	53                   	push   %ebx
c0002158:	ff 14 85 60 fc 00 c0 	call   *-0x3fff03a0(,%eax,4)
c000215f:	83 c4 0c             	add    $0xc,%esp
c0002162:	89 44 24 20          	mov    %eax,0x20(%esp)
c0002166:	e9 a5 fa ff ff       	jmp    c0001c10 <intr_exit>
c000216b:	66 90                	xchg   %ax,%ax
c000216d:	66 90                	xchg   %ax,%ax
c000216f:	90                   	nop

c0002170 <put_str>:
put_str():
c0002170:	53                   	push   %ebx
c0002171:	51                   	push   %ecx
c0002172:	31 c9                	xor    %ecx,%ecx
c0002174:	8b 5c 24 0c          	mov    0xc(%esp),%ebx

c0002178 <put_str.goon>:
put_str.goon():
c0002178:	8a 0b                	mov    (%ebx),%cl
c000217a:	80 f9 00             	cmp    $0x0,%cl
c000217d:	74 0c                	je     c000218b <put_str.str_over>
c000217f:	51                   	push   %ecx
c0002180:	e8 09 00 00 00       	call   c000218e <put_char>
c0002185:	83 c4 04             	add    $0x4,%esp
c0002188:	43                   	inc    %ebx
c0002189:	eb ed                	jmp    c0002178 <put_str.goon>

c000218b <put_str.str_over>:
put_str.str_over():
c000218b:	59                   	pop    %ecx
c000218c:	5b                   	pop    %ebx
c000218d:	c3                   	ret    

c000218e <put_char>:
put_char():
c000218e:	60                   	pusha  
c000218f:	66 b8 18 00          	mov    $0x18,%ax
c0002193:	8e e8                	mov    %eax,%gs
c0002195:	66 ba d4 03          	mov    $0x3d4,%dx
c0002199:	b0 0e                	mov    $0xe,%al
c000219b:	ee                   	out    %al,(%dx)
c000219c:	66 ba d5 03          	mov    $0x3d5,%dx
c00021a0:	ec                   	in     (%dx),%al
c00021a1:	88 c4                	mov    %al,%ah
c00021a3:	66 ba d4 03          	mov    $0x3d4,%dx
c00021a7:	b0 0f                	mov    $0xf,%al
c00021a9:	ee                   	out    %al,(%dx)
c00021aa:	66 ba d5 03          	mov    $0x3d5,%dx
c00021ae:	ec                   	in     (%dx),%al
c00021af:	66 89 c3             	mov    %ax,%bx
c00021b2:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c00021b6:	80 f9 0d             	cmp    $0xd,%cl
c00021b9:	74 3c                	je     c00021f7 <put_char.is_carriage_return>
c00021bb:	80 f9 0a             	cmp    $0xa,%cl
c00021be:	74 37                	je     c00021f7 <put_char.is_carriage_return>
c00021c0:	80 f9 08             	cmp    $0x8,%cl
c00021c3:	74 02                	je     c00021c7 <put_char.is_backspace>
c00021c5:	eb 16                	jmp    c00021dd <put_char.put_other>

c00021c7 <put_char.is_backspace>:
put_char.is_backspace():
c00021c7:	66 4b                	dec    %bx
c00021c9:	66 d1 e3             	shl    %bx
c00021cc:	65 67 c6 07 20       	movb   $0x20,%gs:(%bx)
c00021d1:	66 43                	inc    %bx
c00021d3:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c00021d8:	66 d1 eb             	shr    %bx
c00021db:	eb 60                	jmp    c000223d <put_char.set_cursor>

c00021dd <put_char.put_other>:
put_char.put_other():
c00021dd:	66 d1 e3             	shl    %bx
c00021e0:	65 67 88 0f          	mov    %cl,%gs:(%bx)
c00021e4:	66 43                	inc    %bx
c00021e6:	65 67 c6 07 07       	movb   $0x7,%gs:(%bx)
c00021eb:	66 d1 eb             	shr    %bx
c00021ee:	66 43                	inc    %bx
c00021f0:	66 81 fb d0 07       	cmp    $0x7d0,%bx
c00021f5:	7c 46                	jl     c000223d <put_char.set_cursor>

c00021f7 <put_char.is_carriage_return>:
put_char.is_line_feed():
c00021f7:	66 31 d2             	xor    %dx,%dx
c00021fa:	66 89 d8             	mov    %bx,%ax
c00021fd:	66 be 50 00          	mov    $0x50,%si
c0002201:	66 f7 f6             	div    %si
c0002204:	66 29 d3             	sub    %dx,%bx

c0002207 <put_char.is_carriage_return_end>:
put_char.is_carriage_return_end():
c0002207:	66 83 c3 50          	add    $0x50,%bx
c000220b:	66 81 fb d0 07       	cmp    $0x7d0,%bx

c0002210 <put_char.is_line_feed_end>:
put_char.is_line_feed_end():
c0002210:	7c 2b                	jl     c000223d <put_char.set_cursor>

c0002212 <put_char.roll_screen>:
put_char.roll_screen():
c0002212:	fc                   	cld    
c0002213:	b9 c0 03 00 00       	mov    $0x3c0,%ecx
c0002218:	be a0 80 0b c0       	mov    $0xc00b80a0,%esi
c000221d:	bf 00 80 0b c0       	mov    $0xc00b8000,%edi
c0002222:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
c0002224:	bb 00 0f 00 00       	mov    $0xf00,%ebx
c0002229:	b9 50 00 00 00       	mov    $0x50,%ecx

c000222e <put_char.cls>:
put_char.cls():
c000222e:	65 66 c7 03 20 07    	movw   $0x720,%gs:(%ebx)
c0002234:	83 c3 02             	add    $0x2,%ebx
c0002237:	e2 f5                	loop   c000222e <put_char.cls>
c0002239:	66 bb 80 07          	mov    $0x780,%bx

c000223d <put_char.set_cursor>:
put_char.set_cursor():
c000223d:	66 ba d4 03          	mov    $0x3d4,%dx
c0002241:	b0 0e                	mov    $0xe,%al
c0002243:	ee                   	out    %al,(%dx)
c0002244:	66 ba d5 03          	mov    $0x3d5,%dx
c0002248:	88 f8                	mov    %bh,%al
c000224a:	ee                   	out    %al,(%dx)
c000224b:	66 ba d4 03          	mov    $0x3d4,%dx
c000224f:	b0 0f                	mov    $0xf,%al
c0002251:	ee                   	out    %al,(%dx)
c0002252:	66 ba d5 03          	mov    $0x3d5,%dx
c0002256:	88 d8                	mov    %bl,%al
c0002258:	ee                   	out    %al,(%dx)

c0002259 <put_char.put_char_done>:
put_char.put_char_done():
c0002259:	61                   	popa   
c000225a:	c3                   	ret    

c000225b <put_int>:
put_int():
c000225b:	60                   	pusha  
c000225c:	89 e5                	mov    %esp,%ebp
c000225e:	8b 45 24             	mov    0x24(%ebp),%eax
c0002261:	89 c2                	mov    %eax,%edx
c0002263:	bf 07 00 00 00       	mov    $0x7,%edi
c0002268:	b9 08 00 00 00       	mov    $0x8,%ecx
c000226d:	bb c0 f0 00 c0       	mov    $0xc000f0c0,%ebx

c0002272 <put_int.16based_4bits>:
put_int.16based_4bits():
c0002272:	83 e2 0f             	and    $0xf,%edx
c0002275:	83 fa 09             	cmp    $0x9,%edx
c0002278:	7f 05                	jg     c000227f <put_int.is_A2F>
c000227a:	83 c2 30             	add    $0x30,%edx
c000227d:	eb 06                	jmp    c0002285 <put_int.store>

c000227f <put_int.is_A2F>:
put_int.is_A2F():
c000227f:	83 ea 0a             	sub    $0xa,%edx
c0002282:	83 c2 41             	add    $0x41,%edx

c0002285 <put_int.store>:
put_int.store():
c0002285:	88 14 3b             	mov    %dl,(%ebx,%edi,1)
c0002288:	4f                   	dec    %edi
c0002289:	c1 e8 04             	shr    $0x4,%eax
c000228c:	89 c2                	mov    %eax,%edx
c000228e:	e2 e2                	loop   c0002272 <put_int.16based_4bits>

c0002290 <put_int.ready_to_print>:
put_int.ready_to_print():
c0002290:	47                   	inc    %edi

c0002291 <put_int.skip_prefix_0>:
put_int.skip_prefix_0():
c0002291:	83 ff 08             	cmp    $0x8,%edi
c0002294:	74 0f                	je     c00022a5 <put_int.full0>

c0002296 <put_int.go_on_skip>:
put_int.go_on_skip():
c0002296:	8a 8f c0 f0 00 c0    	mov    -0x3fff0f40(%edi),%cl
c000229c:	47                   	inc    %edi
c000229d:	80 f9 30             	cmp    $0x30,%cl
c00022a0:	74 ef                	je     c0002291 <put_int.skip_prefix_0>
c00022a2:	4f                   	dec    %edi
c00022a3:	eb 02                	jmp    c00022a7 <put_int.put_each_num>

c00022a5 <put_int.full0>:
put_int.full0():
c00022a5:	b1 30                	mov    $0x30,%cl

c00022a7 <put_int.put_each_num>:
put_int.put_each_num():
c00022a7:	51                   	push   %ecx
c00022a8:	e8 e1 fe ff ff       	call   c000218e <put_char>
c00022ad:	83 c4 04             	add    $0x4,%esp
c00022b0:	47                   	inc    %edi
c00022b1:	8a 8f c0 f0 00 c0    	mov    -0x3fff0f40(%edi),%cl
c00022b7:	83 ff 08             	cmp    $0x8,%edi
c00022ba:	7c eb                	jl     c00022a7 <put_int.put_each_num>
c00022bc:	61                   	popa   
c00022bd:	c3                   	ret    

c00022be <set_cursor>:
set_cursor():
c00022be:	60                   	pusha  
c00022bf:	66 8b 5c 24 24       	mov    0x24(%esp),%bx
c00022c4:	66 ba d4 03          	mov    $0x3d4,%dx
c00022c8:	b0 0e                	mov    $0xe,%al
c00022ca:	ee                   	out    %al,(%dx)
c00022cb:	66 ba d5 03          	mov    $0x3d5,%dx
c00022cf:	88 f8                	mov    %bh,%al
c00022d1:	ee                   	out    %al,(%dx)
c00022d2:	66 ba d4 03          	mov    $0x3d4,%dx
c00022d6:	b0 0f                	mov    $0xf,%al
c00022d8:	ee                   	out    %al,(%dx)
c00022d9:	66 ba d5 03          	mov    $0x3d5,%dx
c00022dd:	88 d8                	mov    %bl,%al
c00022df:	ee                   	out    %al,(%dx)
c00022e0:	61                   	popa   
c00022e1:	c3                   	ret    

c00022e2 <panic_spin>:
panic_spin():
/work/x86_os_my/kernel/debug.c:10
/* 打印文件名,行号,函数名,条件并使程序悬停 */
void panic_spin(char* filename,	       \
	        int line,	       \
		const char* func,      \
		const char* condition) \
{
c00022e2:	55                   	push   %ebp
c00022e3:	89 e5                	mov    %esp,%ebp
c00022e5:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/kernel/debug.c:11
   intr_disable();	// 因为有时候会单独调用panic_spin,所以在此处关中断。
c00022e8:	e8 51 f6 ff ff       	call   c000193e <intr_disable>
/work/x86_os_my/kernel/debug.c:12
   put_str("\n\n\n!!!!! error !!!!!\n");
c00022ed:	83 ec 0c             	sub    $0xc,%esp
c00022f0:	68 fc b3 00 c0       	push   $0xc000b3fc
c00022f5:	e8 76 fe ff ff       	call   c0002170 <put_str>
c00022fa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:13
   put_str("filename:");put_str(filename);put_str("\n");
c00022fd:	83 ec 0c             	sub    $0xc,%esp
c0002300:	68 12 b4 00 c0       	push   $0xc000b412
c0002305:	e8 66 fe ff ff       	call   c0002170 <put_str>
c000230a:	83 c4 10             	add    $0x10,%esp
c000230d:	83 ec 0c             	sub    $0xc,%esp
c0002310:	ff 75 08             	pushl  0x8(%ebp)
c0002313:	e8 58 fe ff ff       	call   c0002170 <put_str>
c0002318:	83 c4 10             	add    $0x10,%esp
c000231b:	83 ec 0c             	sub    $0xc,%esp
c000231e:	68 1c b4 00 c0       	push   $0xc000b41c
c0002323:	e8 48 fe ff ff       	call   c0002170 <put_str>
c0002328:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:14
   put_str("line:0x");put_int(line);put_str("\n");
c000232b:	83 ec 0c             	sub    $0xc,%esp
c000232e:	68 1e b4 00 c0       	push   $0xc000b41e
c0002333:	e8 38 fe ff ff       	call   c0002170 <put_str>
c0002338:	83 c4 10             	add    $0x10,%esp
c000233b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000233e:	83 ec 0c             	sub    $0xc,%esp
c0002341:	50                   	push   %eax
c0002342:	e8 14 ff ff ff       	call   c000225b <put_int>
c0002347:	83 c4 10             	add    $0x10,%esp
c000234a:	83 ec 0c             	sub    $0xc,%esp
c000234d:	68 1c b4 00 c0       	push   $0xc000b41c
c0002352:	e8 19 fe ff ff       	call   c0002170 <put_str>
c0002357:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:15
   put_str("function:");put_str((char*)func);put_str("\n");
c000235a:	83 ec 0c             	sub    $0xc,%esp
c000235d:	68 26 b4 00 c0       	push   $0xc000b426
c0002362:	e8 09 fe ff ff       	call   c0002170 <put_str>
c0002367:	83 c4 10             	add    $0x10,%esp
c000236a:	83 ec 0c             	sub    $0xc,%esp
c000236d:	ff 75 10             	pushl  0x10(%ebp)
c0002370:	e8 fb fd ff ff       	call   c0002170 <put_str>
c0002375:	83 c4 10             	add    $0x10,%esp
c0002378:	83 ec 0c             	sub    $0xc,%esp
c000237b:	68 1c b4 00 c0       	push   $0xc000b41c
c0002380:	e8 eb fd ff ff       	call   c0002170 <put_str>
c0002385:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:16
   put_str("condition:");put_str((char*)condition);put_str("\n");
c0002388:	83 ec 0c             	sub    $0xc,%esp
c000238b:	68 30 b4 00 c0       	push   $0xc000b430
c0002390:	e8 db fd ff ff       	call   c0002170 <put_str>
c0002395:	83 c4 10             	add    $0x10,%esp
c0002398:	83 ec 0c             	sub    $0xc,%esp
c000239b:	ff 75 14             	pushl  0x14(%ebp)
c000239e:	e8 cd fd ff ff       	call   c0002170 <put_str>
c00023a3:	83 c4 10             	add    $0x10,%esp
c00023a6:	83 ec 0c             	sub    $0xc,%esp
c00023a9:	68 1c b4 00 c0       	push   $0xc000b41c
c00023ae:	e8 bd fd ff ff       	call   c0002170 <put_str>
c00023b3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/debug.c:17 (discriminator 1)
   while(1);
c00023b6:	eb fe                	jmp    c00023b6 <panic_spin+0xd4>

c00023b8 <bitmap_init>:
bitmap_init():
/work/x86_os_my/lib/kernel/bitmap.c:16
	uint8_t* bits;				位图空间
};
*/

/* 将位图btmp初始化 */
void bitmap_init(struct bitmap* btmp) {
c00023b8:	55                   	push   %ebp
c00023b9:	89 e5                	mov    %esp,%ebp
c00023bb:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/bitmap.c:17
	memset(btmp->bits, 0, btmp->btmp_bytes_len);   
c00023be:	8b 45 08             	mov    0x8(%ebp),%eax
c00023c1:	8b 10                	mov    (%eax),%edx
c00023c3:	8b 45 08             	mov    0x8(%ebp),%eax
c00023c6:	8b 40 04             	mov    0x4(%eax),%eax
c00023c9:	83 ec 04             	sub    $0x4,%esp
c00023cc:	52                   	push   %edx
c00023cd:	6a 00                	push   $0x0
c00023cf:	50                   	push   %eax
c00023d0:	e8 af 13 00 00       	call   c0003784 <memset>
c00023d5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:18
}
c00023d8:	90                   	nop
c00023d9:	c9                   	leave  
c00023da:	c3                   	ret    

c00023db <bitmap_scan_test>:
bitmap_scan_test():
/work/x86_os_my/lib/kernel/bitmap.c:23

/* 判断bit_idx位是否为1
若为1则返回true
否则返回false */
bool bitmap_scan_test(struct bitmap* btmp, uint32_t bit_idx) {
c00023db:	55                   	push   %ebp
c00023dc:	89 e5                	mov    %esp,%ebp
c00023de:	53                   	push   %ebx
c00023df:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:24
	uint32_t byte_idx = bit_idx / 8;    // 向下取整用于索引数组下标
c00023e2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00023e5:	c1 e8 03             	shr    $0x3,%eax
c00023e8:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:25
	uint32_t bit_odd  = bit_idx % 8;    // 取余用于索引数组内的位
c00023eb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00023ee:	83 e0 07             	and    $0x7,%eax
c00023f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:26
	return (btmp->bits[byte_idx] & (BITMAP_MASK << bit_odd));
c00023f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00023f7:	8b 50 04             	mov    0x4(%eax),%edx
c00023fa:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00023fd:	01 d0                	add    %edx,%eax
c00023ff:	0f b6 00             	movzbl (%eax),%eax
c0002402:	0f b6 d0             	movzbl %al,%edx
c0002405:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002408:	bb 01 00 00 00       	mov    $0x1,%ebx
c000240d:	89 c1                	mov    %eax,%ecx
c000240f:	d3 e3                	shl    %cl,%ebx
c0002411:	89 d8                	mov    %ebx,%eax
c0002413:	21 d0                	and    %edx,%eax
/work/x86_os_my/lib/kernel/bitmap.c:27
}
c0002415:	83 c4 10             	add    $0x10,%esp
c0002418:	5b                   	pop    %ebx
c0002419:	5d                   	pop    %ebp
c000241a:	c3                   	ret    

c000241b <bitmap_scan>:
bitmap_scan():
/work/x86_os_my/lib/kernel/bitmap.c:32

/* 在位图中申请连续cnt个位
成功：返回其起始位下标
失败：返回-1 */
int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {
c000241b:	55                   	push   %ebp
c000241c:	89 e5                	mov    %esp,%ebp
c000241e:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/lib/kernel/bitmap.c:33
	uint32_t idx_byte = 0;	 // 用于记录空闲位所在的字节
c0002421:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:35
	/* 先逐字节比较,蛮力法 */
	while (( 0xff == btmp->bits[idx_byte]) && (idx_byte < btmp->btmp_bytes_len)) {
c0002428:	eb 04                	jmp    c000242e <bitmap_scan+0x13>
/work/x86_os_my/lib/kernel/bitmap.c:37
		/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */
		idx_byte++;
c000242a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:35
成功：返回其起始位下标
失败：返回-1 */
int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {
	uint32_t idx_byte = 0;	 // 用于记录空闲位所在的字节
	/* 先逐字节比较,蛮力法 */
	while (( 0xff == btmp->bits[idx_byte]) && (idx_byte < btmp->btmp_bytes_len)) {
c000242e:	8b 45 08             	mov    0x8(%ebp),%eax
c0002431:	8b 50 04             	mov    0x4(%eax),%edx
c0002434:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002437:	01 d0                	add    %edx,%eax
c0002439:	0f b6 00             	movzbl (%eax),%eax
c000243c:	3c ff                	cmp    $0xff,%al
c000243e:	75 0a                	jne    c000244a <bitmap_scan+0x2f>
/work/x86_os_my/lib/kernel/bitmap.c:35 (discriminator 1)
c0002440:	8b 45 08             	mov    0x8(%ebp),%eax
c0002443:	8b 00                	mov    (%eax),%eax
c0002445:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0002448:	77 e0                	ja     c000242a <bitmap_scan+0xf>
/work/x86_os_my/lib/kernel/bitmap.c:39
		/* 1表示该位已分配,所以若为0xff,则表示该字节内已无空闲位,向下一字节继续找 */
		idx_byte++;
	}
	ASSERT(idx_byte < btmp->btmp_bytes_len);	//这里应该是"<="
c000244a:	8b 45 08             	mov    0x8(%ebp),%eax
c000244d:	8b 00                	mov    (%eax),%eax
c000244f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0002452:	77 19                	ja     c000246d <bitmap_scan+0x52>
/work/x86_os_my/lib/kernel/bitmap.c:39 (discriminator 1)
c0002454:	68 3c b4 00 c0       	push   $0xc000b43c
c0002459:	68 90 b4 00 c0       	push   $0xc000b490
c000245e:	6a 27                	push   $0x27
c0002460:	68 5c b4 00 c0       	push   $0xc000b45c
c0002465:	e8 78 fe ff ff       	call   c00022e2 <panic_spin>
c000246a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:40
	if (idx_byte == btmp->btmp_bytes_len) {		// 若该内存池找不到可用空间		
c000246d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002470:	8b 00                	mov    (%eax),%eax
c0002472:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0002475:	75 0a                	jne    c0002481 <bitmap_scan+0x66>
/work/x86_os_my/lib/kernel/bitmap.c:41
		return -1;
c0002477:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000247c:	e9 cd 00 00 00       	jmp    c000254e <bitmap_scan+0x133>
/work/x86_os_my/lib/kernel/bitmap.c:46
	}

	/* 若在位图数组范围内的某字节内找到了空闲位，
	 * 在该字节内逐位比对,返回空闲位的索引。*/
	int idx_bit = 0;
c0002481:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:48
	/* 和btmp->bits[idx_byte]这个字节逐位对比 */
	while ((uint8_t)(BITMAP_MASK << idx_bit) & btmp->bits[idx_byte]) { 
c0002488:	eb 04                	jmp    c000248e <bitmap_scan+0x73>
/work/x86_os_my/lib/kernel/bitmap.c:49
		idx_bit++;
c000248a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:48

	/* 若在位图数组范围内的某字节内找到了空闲位，
	 * 在该字节内逐位比对,返回空闲位的索引。*/
	int idx_bit = 0;
	/* 和btmp->bits[idx_byte]这个字节逐位对比 */
	while ((uint8_t)(BITMAP_MASK << idx_bit) & btmp->bits[idx_byte]) { 
c000248e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002491:	ba 01 00 00 00       	mov    $0x1,%edx
c0002496:	89 c1                	mov    %eax,%ecx
c0002498:	d3 e2                	shl    %cl,%edx
c000249a:	89 d0                	mov    %edx,%eax
c000249c:	0f b6 d0             	movzbl %al,%edx
c000249f:	8b 45 08             	mov    0x8(%ebp),%eax
c00024a2:	8b 48 04             	mov    0x4(%eax),%ecx
c00024a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00024a8:	01 c8                	add    %ecx,%eax
c00024aa:	0f b6 00             	movzbl (%eax),%eax
c00024ad:	0f b6 c0             	movzbl %al,%eax
c00024b0:	21 d0                	and    %edx,%eax
c00024b2:	85 c0                	test   %eax,%eax
c00024b4:	75 d4                	jne    c000248a <bitmap_scan+0x6f>
/work/x86_os_my/lib/kernel/bitmap.c:52
		idx_bit++;
	}
	
	int bit_idx_start = idx_byte * 8 + idx_bit;		// 空闲位在位图内的下标
c00024b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00024b9:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c00024c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00024c3:	01 d0                	add    %edx,%eax
c00024c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:53
	if (cnt == 1) {
c00024c8:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
c00024cc:	75 05                	jne    c00024d3 <bitmap_scan+0xb8>
/work/x86_os_my/lib/kernel/bitmap.c:54
		return bit_idx_start;
c00024ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00024d1:	eb 7b                	jmp    c000254e <bitmap_scan+0x133>
/work/x86_os_my/lib/kernel/bitmap.c:57
	}

	uint32_t bit_left = (btmp->btmp_bytes_len * 8 - bit_idx_start);	// 记录还有多少位可以判断
c00024d3:	8b 45 08             	mov    0x8(%ebp),%eax
c00024d6:	8b 00                	mov    (%eax),%eax
c00024d8:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c00024df:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00024e2:	29 c2                	sub    %eax,%edx
c00024e4:	89 d0                	mov    %edx,%eax
c00024e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:58
	uint32_t next_bit = bit_idx_start + 1;
c00024e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00024ec:	83 c0 01             	add    $0x1,%eax
c00024ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:59
	uint32_t count = 1;			// 用于记录找到的空闲位的个数
c00024f2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:61

	bit_idx_start = -1;			// 初始化为-1，若找不到连续的位就直接返回-1
c00024f9:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:62
	while (bit_left-- > 0) {
c0002500:	eb 3c                	jmp    c000253e <bitmap_scan+0x123>
/work/x86_os_my/lib/kernel/bitmap.c:63
		if (!(bitmap_scan_test(btmp, next_bit))) {	// 判断next_bit位是否为1,=1返回true，=0返回false
c0002502:	83 ec 08             	sub    $0x8,%esp
c0002505:	ff 75 e4             	pushl  -0x1c(%ebp)
c0002508:	ff 75 08             	pushl  0x8(%ebp)
c000250b:	e8 cb fe ff ff       	call   c00023db <bitmap_scan_test>
c0002510:	83 c4 10             	add    $0x10,%esp
c0002513:	85 c0                	test   %eax,%eax
c0002515:	75 06                	jne    c000251d <bitmap_scan+0x102>
/work/x86_os_my/lib/kernel/bitmap.c:64
			count++;
c0002517:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
c000251b:	eb 07                	jmp    c0002524 <bitmap_scan+0x109>
/work/x86_os_my/lib/kernel/bitmap.c:66
		} else {
			count = 0;			// 重新从0找cnt个连续的bit
c000251d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:69
		}
		
		if (count == cnt) {		// 已找到连续的cnt个空位
c0002524:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0002527:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000252a:	75 0e                	jne    c000253a <bitmap_scan+0x11f>
/work/x86_os_my/lib/kernel/bitmap.c:70
			bit_idx_start = next_bit - cnt + 1;
c000252c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000252f:	2b 45 0c             	sub    0xc(%ebp),%eax
c0002532:	83 c0 01             	add    $0x1,%eax
c0002535:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:71
			break;
c0002538:	eb 11                	jmp    c000254b <bitmap_scan+0x130>
/work/x86_os_my/lib/kernel/bitmap.c:73
		}
		next_bit++;
c000253a:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:62
	uint32_t bit_left = (btmp->btmp_bytes_len * 8 - bit_idx_start);	// 记录还有多少位可以判断
	uint32_t next_bit = bit_idx_start + 1;
	uint32_t count = 1;			// 用于记录找到的空闲位的个数

	bit_idx_start = -1;			// 初始化为-1，若找不到连续的位就直接返回-1
	while (bit_left-- > 0) {
c000253e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002541:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002544:	89 55 e8             	mov    %edx,-0x18(%ebp)
c0002547:	85 c0                	test   %eax,%eax
c0002549:	75 b7                	jne    c0002502 <bitmap_scan+0xe7>
/work/x86_os_my/lib/kernel/bitmap.c:75
			bit_idx_start = next_bit - cnt + 1;
			break;
		}
		next_bit++;
	}
	return bit_idx_start;
c000254b:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/lib/kernel/bitmap.c:76
}
c000254e:	c9                   	leave  
c000254f:	c3                   	ret    

c0002550 <bitmap_set>:
bitmap_set():
/work/x86_os_my/lib/kernel/bitmap.c:79

/* 将位图btmp的bit_idx位设置为value */
void bitmap_set(struct bitmap* btmp, uint32_t bit_idx, int8_t value) {
c0002550:	55                   	push   %ebp
c0002551:	89 e5                	mov    %esp,%ebp
c0002553:	56                   	push   %esi
c0002554:	53                   	push   %ebx
c0002555:	83 ec 20             	sub    $0x20,%esp
c0002558:	8b 45 10             	mov    0x10(%ebp),%eax
c000255b:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:80
	ASSERT((value == 0) || (value == 1));
c000255e:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c0002562:	74 1f                	je     c0002583 <bitmap_set+0x33>
/work/x86_os_my/lib/kernel/bitmap.c:80 (discriminator 1)
c0002564:	80 7d e4 01          	cmpb   $0x1,-0x1c(%ebp)
c0002568:	74 19                	je     c0002583 <bitmap_set+0x33>
/work/x86_os_my/lib/kernel/bitmap.c:80 (discriminator 2)
c000256a:	68 70 b4 00 c0       	push   $0xc000b470
c000256f:	68 9c b4 00 c0       	push   $0xc000b49c
c0002574:	6a 50                	push   $0x50
c0002576:	68 5c b4 00 c0       	push   $0xc000b45c
c000257b:	e8 62 fd ff ff       	call   c00022e2 <panic_spin>
c0002580:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/bitmap.c:81
	uint32_t byte_idx = bit_idx / 8;    // 向下取整用于索引数组下标
c0002583:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002586:	c1 e8 03             	shr    $0x3,%eax
c0002589:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:82
	uint32_t bit_odd  = bit_idx % 8;    // 取余用于索引数组内的位
c000258c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000258f:	83 e0 07             	and    $0x7,%eax
c0002592:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/kernel/bitmap.c:86

	/* 一般都会用个0x1这样的数对字节中的位操作,
	* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/
	if (value) {
c0002595:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c0002599:	74 2f                	je     c00025ca <bitmap_set+0x7a>
/work/x86_os_my/lib/kernel/bitmap.c:87
		btmp->bits[byte_idx] |= (BITMAP_MASK << bit_odd);
c000259b:	8b 45 08             	mov    0x8(%ebp),%eax
c000259e:	8b 50 04             	mov    0x4(%eax),%edx
c00025a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00025a4:	01 c2                	add    %eax,%edx
c00025a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00025a9:	8b 48 04             	mov    0x4(%eax),%ecx
c00025ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00025af:	01 c8                	add    %ecx,%eax
c00025b1:	0f b6 00             	movzbl (%eax),%eax
c00025b4:	89 c6                	mov    %eax,%esi
c00025b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00025b9:	bb 01 00 00 00       	mov    $0x1,%ebx
c00025be:	89 c1                	mov    %eax,%ecx
c00025c0:	d3 e3                	shl    %cl,%ebx
c00025c2:	89 d8                	mov    %ebx,%eax
c00025c4:	09 f0                	or     %esi,%eax
c00025c6:	88 02                	mov    %al,(%edx)
/work/x86_os_my/lib/kernel/bitmap.c:91
	} else {
		btmp->bits[byte_idx] &= ~(BITMAP_MASK << bit_odd);
	}
}
c00025c8:	eb 2f                	jmp    c00025f9 <bitmap_set+0xa9>
/work/x86_os_my/lib/kernel/bitmap.c:89
	/* 一般都会用个0x1这样的数对字节中的位操作,
	* 将1任意移动后再取反,或者先取反再移位,可用来对位置0操作。*/
	if (value) {
		btmp->bits[byte_idx] |= (BITMAP_MASK << bit_odd);
	} else {
		btmp->bits[byte_idx] &= ~(BITMAP_MASK << bit_odd);
c00025ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00025cd:	8b 50 04             	mov    0x4(%eax),%edx
c00025d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00025d3:	01 c2                	add    %eax,%edx
c00025d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00025d8:	8b 48 04             	mov    0x4(%eax),%ecx
c00025db:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00025de:	01 c8                	add    %ecx,%eax
c00025e0:	0f b6 00             	movzbl (%eax),%eax
c00025e3:	89 c3                	mov    %eax,%ebx
c00025e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00025e8:	be 01 00 00 00       	mov    $0x1,%esi
c00025ed:	89 c1                	mov    %eax,%ecx
c00025ef:	d3 e6                	shl    %cl,%esi
c00025f1:	89 f0                	mov    %esi,%eax
c00025f3:	f7 d0                	not    %eax
c00025f5:	21 d8                	and    %ebx,%eax
c00025f7:	88 02                	mov    %al,(%edx)
/work/x86_os_my/lib/kernel/bitmap.c:91
	}
}
c00025f9:	90                   	nop
c00025fa:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00025fd:	5b                   	pop    %ebx
c00025fe:	5e                   	pop    %esi
c00025ff:	5d                   	pop    %ebp
c0002600:	c3                   	ret    

c0002601 <vaddr_get>:
vaddr_get():
/work/x86_os_my/kernel/memory.c:66
struct pool kernel_pool, user_pool;		// 生成内核内存池和用户内存池
struct virtual_addr kernel_vaddr;		// 此结构是用来给内核分配虚拟地址

/* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页,
 * 成功则返回虚拟页的起始地址, 失败则返回NULL */
static void* vaddr_get(enum pool_flags pf, uint32_t pg_cnt) {
c0002601:	55                   	push   %ebp
c0002602:	89 e5                	mov    %esp,%ebp
c0002604:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:67
	int vaddr_start = 0, bit_idx_start = -1;
c0002607:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000260e:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:68
	uint32_t cnt = 0;
c0002615:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:69
	if (pf == PF_KERNEL) {
c000261c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0002620:	75 64                	jne    c0002686 <vaddr_get+0x85>
/work/x86_os_my/kernel/memory.c:71
		// 在位图中申请连续cnt个位 成功：返回其起始位下标
		bit_idx_start  = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
c0002622:	83 ec 08             	sub    $0x8,%esp
c0002625:	ff 75 0c             	pushl  0xc(%ebp)
c0002628:	68 48 fb 00 c0       	push   $0xc000fb48
c000262d:	e8 e9 fd ff ff       	call   c000241b <bitmap_scan>
c0002632:	83 c4 10             	add    $0x10,%esp
c0002635:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:72
		if (bit_idx_start == -1) {	//失败
c0002638:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c000263c:	75 2b                	jne    c0002669 <vaddr_get+0x68>
/work/x86_os_my/kernel/memory.c:73
			return NULL;
c000263e:	b8 00 00 00 00       	mov    $0x0,%eax
c0002643:	e9 cd 00 00 00       	jmp    c0002715 <vaddr_get+0x114>
/work/x86_os_my/kernel/memory.c:77
		}
		while(cnt < pg_cnt) {
			// 设置位图中的位，表示内存已被占用
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
c0002648:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000264b:	8d 50 01             	lea    0x1(%eax),%edx
c000264e:	89 55 f0             	mov    %edx,-0x10(%ebp)
c0002651:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002654:	01 d0                	add    %edx,%eax
c0002656:	83 ec 04             	sub    $0x4,%esp
c0002659:	6a 01                	push   $0x1
c000265b:	50                   	push   %eax
c000265c:	68 48 fb 00 c0       	push   $0xc000fb48
c0002661:	e8 ea fe ff ff       	call   c0002550 <bitmap_set>
c0002666:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:75
		// 在位图中申请连续cnt个位 成功：返回其起始位下标
		bit_idx_start  = bitmap_scan(&kernel_vaddr.vaddr_bitmap, pg_cnt);
		if (bit_idx_start == -1) {	//失败
			return NULL;
		}
		while(cnt < pg_cnt) {
c0002669:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000266c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000266f:	72 d7                	jb     c0002648 <vaddr_get+0x47>
/work/x86_os_my/kernel/memory.c:79
			// 设置位图中的位，表示内存已被占用
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
		}
		vaddr_start = kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
c0002671:	a1 50 fb 00 c0       	mov    0xc000fb50,%eax
c0002676:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0002679:	c1 e2 0c             	shl    $0xc,%edx
c000267c:	01 d0                	add    %edx,%eax
c000267e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002681:	e9 8c 00 00 00       	jmp    c0002712 <vaddr_get+0x111>
/work/x86_os_my/kernel/memory.c:81
	} else {
		struct task_struct* cur = running_thread();
c0002686:	e8 e0 14 00 00       	call   c0003b6b <running_thread>
c000268b:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:82
		bit_idx_start  = bitmap_scan(&cur->userprog_vaddr.vaddr_bitmap, pg_cnt);
c000268e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002691:	83 c0 58             	add    $0x58,%eax
c0002694:	83 ec 08             	sub    $0x8,%esp
c0002697:	ff 75 0c             	pushl  0xc(%ebp)
c000269a:	50                   	push   %eax
c000269b:	e8 7b fd ff ff       	call   c000241b <bitmap_scan>
c00026a0:	83 c4 10             	add    $0x10,%esp
c00026a3:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:83
		if (bit_idx_start == -1) {
c00026a6:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c00026aa:	75 2a                	jne    c00026d6 <vaddr_get+0xd5>
/work/x86_os_my/kernel/memory.c:84
			return NULL;
c00026ac:	b8 00 00 00 00       	mov    $0x0,%eax
c00026b1:	eb 62                	jmp    c0002715 <vaddr_get+0x114>
/work/x86_os_my/kernel/memory.c:87
		}
		while(cnt < pg_cnt) {
			bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
c00026b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00026b6:	8d 50 01             	lea    0x1(%eax),%edx
c00026b9:	89 55 f0             	mov    %edx,-0x10(%ebp)
c00026bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00026bf:	01 c2                	add    %eax,%edx
c00026c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00026c4:	83 c0 58             	add    $0x58,%eax
c00026c7:	83 ec 04             	sub    $0x4,%esp
c00026ca:	6a 01                	push   $0x1
c00026cc:	52                   	push   %edx
c00026cd:	50                   	push   %eax
c00026ce:	e8 7d fe ff ff       	call   c0002550 <bitmap_set>
c00026d3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:86
		struct task_struct* cur = running_thread();
		bit_idx_start  = bitmap_scan(&cur->userprog_vaddr.vaddr_bitmap, pg_cnt);
		if (bit_idx_start == -1) {
			return NULL;
		}
		while(cnt < pg_cnt) {
c00026d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00026d9:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00026dc:	72 d5                	jb     c00026b3 <vaddr_get+0xb2>
/work/x86_os_my/kernel/memory.c:89
			bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 1);
		}
		vaddr_start = cur->userprog_vaddr.vaddr_start + bit_idx_start * PG_SIZE;
c00026de:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00026e1:	8b 40 60             	mov    0x60(%eax),%eax
c00026e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00026e7:	c1 e2 0c             	shl    $0xc,%edx
c00026ea:	01 d0                	add    %edx,%eax
c00026ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:92

		/* (0xc0000000 - PG_SIZE)做为用户3级栈已经在start_process被分配 */
		ASSERT((uint32_t)vaddr_start < (0xc0000000 - PG_SIZE));
c00026ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00026f2:	3d ff ef ff bf       	cmp    $0xbfffefff,%eax
c00026f7:	76 19                	jbe    c0002712 <vaddr_get+0x111>
/work/x86_os_my/kernel/memory.c:92 (discriminator 1)
c00026f9:	68 a8 b4 00 c0       	push   $0xc000b4a8
c00026fe:	68 10 b8 00 c0       	push   $0xc000b810
c0002703:	6a 5c                	push   $0x5c
c0002705:	68 d7 b4 00 c0       	push   $0xc000b4d7
c000270a:	e8 d3 fb ff ff       	call   c00022e2 <panic_spin>
c000270f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:95
		
	}
	return (void*)vaddr_start;
c0002712:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:96
}
c0002715:	c9                   	leave  
c0002716:	c3                   	ret    

c0002717 <pte_ptr>:
pte_ptr():
/work/x86_os_my/kernel/memory.c:103
// 页表项 page table
/* 得到虚拟地址vaddr对应的pte指针*/
// 虚拟地址 vaddr 所在 pte 的"虚拟地址"!!!
// *pte 代表的是 pte 页表项的内容,
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页表项"属性
uint32_t* pte_ptr(uint32_t vaddr) {
c0002717:	55                   	push   %ebp
c0002718:	89 e5                	mov    %esp,%ebp
c000271a:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:108
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
					((vaddr & 0xffc00000) >> 10) + \
c000271d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002720:	25 00 00 c0 ff       	and    $0xffc00000,%eax
c0002725:	c1 e8 0a             	shr    $0xa,%eax
c0002728:	89 c2                	mov    %eax,%edx
/work/x86_os_my/kernel/memory.c:109
					PTE_IDX(vaddr) * 4);
c000272a:	8b 45 08             	mov    0x8(%ebp),%eax
c000272d:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c0002732:	c1 e8 0c             	shr    $0xc,%eax
c0002735:	c1 e0 02             	shl    $0x2,%eax
/work/x86_os_my/kernel/memory.c:108
uint32_t* pte_ptr(uint32_t vaddr) {
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
					((vaddr & 0xffc00000) >> 10) + \
c0002738:	01 d0                	add    %edx,%eax
c000273a:	2d 00 00 40 00       	sub    $0x400000,%eax
/work/x86_os_my/kernel/memory.c:107
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页表项"属性
uint32_t* pte_ptr(uint32_t vaddr) {
	/* 先找到页目录表 + \
	* 再用vaddr的pde部分做为索引，找到某一个页表 + \
	* 再用vaddr的pte部分作为索引，找到某一个页表项*/
	uint32_t* pte = (uint32_t*)(0xffc00000 + \
c000273f:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:110
					((vaddr & 0xffc00000) >> 10) + \
					PTE_IDX(vaddr) * 4);
	return pte;
c0002742:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/kernel/memory.c:111
}
c0002745:	c9                   	leave  
c0002746:	c3                   	ret    

c0002747 <pde_ptr>:
pde_ptr():
/work/x86_os_my/kernel/memory.c:118
// 页目录表项 page Directory table entry
/* 得到虚拟地址vaddr对应的pde的指针 */
// 虚拟地址 vaddr 所在 pde 的"虚拟地址"!!!
// *pde 代表的是 pde 页目录项的内容
// 也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的"页目录项"属性
uint32_t* pde_ptr(uint32_t vaddr) {
c0002747:	55                   	push   %ebp
c0002748:	89 e5                	mov    %esp,%ebp
c000274a:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:120
	/* 0xfffff是用来访问到页目录表本身所在的地址 */
	uint32_t* pde = (uint32_t*)((0xfffff000) + PDE_IDX(vaddr) * 4);
c000274d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002750:	c1 e8 16             	shr    $0x16,%eax
c0002753:	05 00 fc ff 3f       	add    $0x3ffffc00,%eax
c0002758:	c1 e0 02             	shl    $0x2,%eax
c000275b:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:121
	return pde;
c000275e:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/kernel/memory.c:122
}
c0002761:	c9                   	leave  
c0002762:	c3                   	ret    

c0002763 <palloc>:
palloc():
/work/x86_os_my/kernel/memory.c:126

/* 在m_pool指向的物理内存池中分配1个物理页,
 * 成功则返回页框的物理地址,失败则返回NULL */
static void* palloc(struct pool* m_pool) {
c0002763:	55                   	push   %ebp
c0002764:	89 e5                	mov    %esp,%ebp
c0002766:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:128
	/* 扫描或设置位图要保证原子操作 */
	int bit_idx = bitmap_scan(&m_pool->pool_bitmap, 1);    // 找一个物理页面
c0002769:	8b 45 08             	mov    0x8(%ebp),%eax
c000276c:	83 ec 08             	sub    $0x8,%esp
c000276f:	6a 01                	push   $0x1
c0002771:	50                   	push   %eax
c0002772:	e8 a4 fc ff ff       	call   c000241b <bitmap_scan>
c0002777:	83 c4 10             	add    $0x10,%esp
c000277a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:129
	if (bit_idx == -1 ) {
c000277d:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0002781:	75 07                	jne    c000278a <palloc+0x27>
/work/x86_os_my/kernel/memory.c:130
		return NULL;
c0002783:	b8 00 00 00 00       	mov    $0x0,%eax
c0002788:	eb 2b                	jmp    c00027b5 <palloc+0x52>
/work/x86_os_my/kernel/memory.c:132
	}
	bitmap_set(&m_pool->pool_bitmap, bit_idx, 1);	// 将此位bit_idx置1
c000278a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000278d:	8b 45 08             	mov    0x8(%ebp),%eax
c0002790:	83 ec 04             	sub    $0x4,%esp
c0002793:	6a 01                	push   $0x1
c0002795:	52                   	push   %edx
c0002796:	50                   	push   %eax
c0002797:	e8 b4 fd ff ff       	call   c0002550 <bitmap_set>
c000279c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:133
	uint32_t page_phyaddr = ((bit_idx * PG_SIZE) + m_pool->phy_addr_start);
c000279f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00027a2:	c1 e0 0c             	shl    $0xc,%eax
c00027a5:	89 c2                	mov    %eax,%edx
c00027a7:	8b 45 08             	mov    0x8(%ebp),%eax
c00027aa:	8b 40 08             	mov    0x8(%eax),%eax
c00027ad:	01 d0                	add    %edx,%eax
c00027af:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:134
	return (void*)page_phyaddr;
c00027b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/kernel/memory.c:135
}
c00027b5:	c9                   	leave  
c00027b6:	c3                   	ret    

c00027b7 <page_table_add>:
page_table_add():
/work/x86_os_my/kernel/memory.c:138

/* 页表中添加虚拟地址_vaddr与物理地址_page_phyaddr的映射 */
static void page_table_add(void* _vaddr, void* _page_phyaddr) {
c00027b7:	55                   	push   %ebp
c00027b8:	89 e5                	mov    %esp,%ebp
c00027ba:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:139
	uint32_t vaddr = (uint32_t)_vaddr, page_phyaddr = (uint32_t)_page_phyaddr;
c00027bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00027c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00027c3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00027c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:140
	uint32_t* pde = pde_ptr(vaddr);	//变量pde是虚拟地址!!!
c00027c9:	ff 75 f4             	pushl  -0xc(%ebp)
c00027cc:	e8 76 ff ff ff       	call   c0002747 <pde_ptr>
c00027d1:	83 c4 04             	add    $0x4,%esp
c00027d4:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:141
	uint32_t* pte = pte_ptr(vaddr);	//变量pte是虚拟地址!!!
c00027d7:	ff 75 f4             	pushl  -0xc(%ebp)
c00027da:	e8 38 ff ff ff       	call   c0002717 <pte_ptr>
c00027df:	83 c4 04             	add    $0x4,%esp
c00027e2:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:149
	* pde页目录项 pte页表项
	* 执行*pte可能会访问到空的pde。所以确保pde创建完成后才能执行*pte，否则会引发page_fault。
	* 因此在*pde为0时，*pte只能出现在下面else语句块中的*pde后面。
	* *********************************************************/
	/* 先在页目录内判断目录项的P位，若为1,则表示该表已存在 */
	if (*pde & 0x00000001) {			// 页目录项 存在
c00027e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00027e8:	8b 00                	mov    (%eax),%eax
c00027ea:	83 e0 01             	and    $0x1,%eax
c00027ed:	85 c0                	test   %eax,%eax
c00027ef:	74 64                	je     c0002855 <page_table_add+0x9e>
/work/x86_os_my/kernel/memory.c:150
		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
c00027f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00027f4:	8b 00                	mov    (%eax),%eax
c00027f6:	83 e0 01             	and    $0x1,%eax
c00027f9:	85 c0                	test   %eax,%eax
c00027fb:	74 1c                	je     c0002819 <page_table_add+0x62>
/work/x86_os_my/kernel/memory.c:150 (discriminator 1)
c00027fd:	68 e7 b4 00 c0       	push   $0xc000b4e7
c0002802:	68 1c b8 00 c0       	push   $0xc000b81c
c0002807:	68 96 00 00 00       	push   $0x96
c000280c:	68 d7 b4 00 c0       	push   $0xc000b4d7
c0002811:	e8 cc fa ff ff       	call   c00022e2 <panic_spin>
c0002816:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:152

		if (!(*pte & 0x00000001)) {		// 页表项pte不存在，创建PTE
c0002819:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000281c:	8b 00                	mov    (%eax),%eax
c000281e:	83 e0 01             	and    $0x1,%eax
c0002821:	85 c0                	test   %eax,%eax
c0002823:	75 12                	jne    c0002837 <page_table_add+0x80>
/work/x86_os_my/kernel/memory.c:153
			*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);		// 物理地址 | US=1,RW=1,P=1
c0002825:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002828:	83 c8 07             	or     $0x7,%eax
c000282b:	89 c2                	mov    %eax,%edx
c000282d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002830:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:173
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
	}
}
c0002832:	e9 8e 00 00 00       	jmp    c00028c5 <page_table_add+0x10e>
/work/x86_os_my/kernel/memory.c:155
		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic

		if (!(*pte & 0x00000001)) {		// 页表项pte不存在，创建PTE
			*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);		// 物理地址 | US=1,RW=1,P=1
		} else {						// 不会执行到这，因为上面的ASSERT
			PANIC("pte repeat");
c0002837:	68 fc b4 00 c0       	push   $0xc000b4fc
c000283c:	68 1c b8 00 c0       	push   $0xc000b81c
c0002841:	68 9b 00 00 00       	push   $0x9b
c0002846:	68 d7 b4 00 c0       	push   $0xc000b4d7
c000284b:	e8 92 fa ff ff       	call   c00022e2 <panic_spin>
c0002850:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:173
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
	}
}
c0002853:	eb 70                	jmp    c00028c5 <page_table_add+0x10e>
/work/x86_os_my/kernel/memory.c:159
		} else {						// 不会执行到这，因为上面的ASSERT
			PANIC("pte repeat");
		}
	} else {							// 页目录项不存在，先创建页目录，再创建页表项
		/* 页表中用到的页一律从内核空间分配 */
		uint32_t pde_phyaddr = (uint32_t)palloc(&kernel_pool);
c0002855:	83 ec 0c             	sub    $0xc,%esp
c0002858:	68 60 fb 00 c0       	push   $0xc000fb60
c000285d:	e8 01 ff ff ff       	call   c0002763 <palloc>
c0002862:	83 c4 10             	add    $0x10,%esp
c0002865:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:160
		*pde = (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 注意这行是pde_phyaddr，不是page_phyaddr!!!
c0002868:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000286b:	83 c8 07             	or     $0x7,%eax
c000286e:	89 c2                	mov    %eax,%edx
c0002870:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002873:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:168
		 * 访问物理地址 pde_phyaddr，需要找到它的虚拟地址！
		 * 只要用_vaddr的 PTE 取高20位即可。
		   搞得这么难理解，其实就是0xffc00000找到页目录表，然后加上vaddr的PDE在页目录表中的索引
		   (uint32_t*)(0xffc00000 + ((vaddr & 0xffc00000) >> 10))
		 */
		memset((void*)((int)pte & 0xfffff000), 0, PG_SIZE);
c0002875:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002878:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c000287d:	83 ec 04             	sub    $0x4,%esp
c0002880:	68 00 10 00 00       	push   $0x1000
c0002885:	6a 00                	push   $0x0
c0002887:	50                   	push   %eax
c0002888:	e8 f7 0e 00 00       	call   c0003784 <memset>
c000288d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:170

		ASSERT(!(*pte & 0x00000001));	// 页表项不存在才能往下执行，否则panic
c0002890:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002893:	8b 00                	mov    (%eax),%eax
c0002895:	83 e0 01             	and    $0x1,%eax
c0002898:	85 c0                	test   %eax,%eax
c000289a:	74 1c                	je     c00028b8 <page_table_add+0x101>
/work/x86_os_my/kernel/memory.c:170 (discriminator 1)
c000289c:	68 e7 b4 00 c0       	push   $0xc000b4e7
c00028a1:	68 1c b8 00 c0       	push   $0xc000b81c
c00028a6:	68 aa 00 00 00       	push   $0xaa
c00028ab:	68 d7 b4 00 c0       	push   $0xc000b4d7
c00028b0:	e8 2d fa ff ff       	call   c00022e2 <panic_spin>
c00028b5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:171
		*pte = (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);			// 物理地址 | US=1,RW=1,P=1
c00028b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00028bb:	83 c8 07             	or     $0x7,%eax
c00028be:	89 c2                	mov    %eax,%edx
c00028c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00028c3:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:173
	}
}
c00028c5:	90                   	nop
c00028c6:	c9                   	leave  
c00028c7:	c3                   	ret    

c00028c8 <malloc_page>:
malloc_page():
/work/x86_os_my/kernel/memory.c:176

/* 分配pg_cnt个页空间,成功则返回起始虚拟地址,失败时返回NULL */
void* malloc_page(enum pool_flags pf, uint32_t pg_cnt) {
c00028c8:	55                   	push   %ebp
c00028c9:	89 e5                	mov    %esp,%ebp
c00028cb:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:177
	ASSERT(pg_cnt > 0 && pg_cnt < 3840);
c00028ce:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00028d2:	74 09                	je     c00028dd <malloc_page+0x15>
/work/x86_os_my/kernel/memory.c:177 (discriminator 1)
c00028d4:	81 7d 0c ff 0e 00 00 	cmpl   $0xeff,0xc(%ebp)
c00028db:	76 1c                	jbe    c00028f9 <malloc_page+0x31>
/work/x86_os_my/kernel/memory.c:177 (discriminator 3)
c00028dd:	68 07 b5 00 c0       	push   $0xc000b507
c00028e2:	68 2c b8 00 c0       	push   $0xc000b82c
c00028e7:	68 b1 00 00 00       	push   $0xb1
c00028ec:	68 d7 b4 00 c0       	push   $0xc000b4d7
c00028f1:	e8 ec f9 ff ff       	call   c00022e2 <panic_spin>
c00028f6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:183
	/***********   malloc_page的原理是三个动作的合成:   ***********
		1 通过vaddr_get在虚拟内存池中申请虚拟地址
		2 通过palloc在物理内存池中申请物理页
		3 通过page_table_add将以上得到的虚拟地址和物理地址在页表中完成映射
	***************************************************************/
	void* vaddr_start = vaddr_get(pf, pg_cnt);
c00028f9:	83 ec 08             	sub    $0x8,%esp
c00028fc:	ff 75 0c             	pushl  0xc(%ebp)
c00028ff:	ff 75 08             	pushl  0x8(%ebp)
c0002902:	e8 fa fc ff ff       	call   c0002601 <vaddr_get>
c0002907:	83 c4 10             	add    $0x10,%esp
c000290a:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:184
	if (vaddr_start == NULL) {
c000290d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002911:	75 07                	jne    c000291a <malloc_page+0x52>
/work/x86_os_my/kernel/memory.c:185
		return NULL;
c0002913:	b8 00 00 00 00       	mov    $0x0,%eax
c0002918:	eb 6e                	jmp    c0002988 <malloc_page+0xc0>
/work/x86_os_my/kernel/memory.c:188
	}

	uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
c000291a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000291d:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0002920:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002923:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:189
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c0002926:	8b 45 08             	mov    0x8(%ebp),%eax
c0002929:	83 e0 01             	and    $0x1,%eax
c000292c:	85 c0                	test   %eax,%eax
c000292e:	74 07                	je     c0002937 <malloc_page+0x6f>
/work/x86_os_my/kernel/memory.c:189 (discriminator 1)
c0002930:	b8 60 fb 00 c0       	mov    $0xc000fb60,%eax
c0002935:	eb 05                	jmp    c000293c <malloc_page+0x74>
/work/x86_os_my/kernel/memory.c:189 (discriminator 2)
c0002937:	b8 60 fa 00 c0       	mov    $0xc000fa60,%eax
/work/x86_os_my/kernel/memory.c:189 (discriminator 4)
c000293c:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:192 (discriminator 4)

	/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
	while (cnt-- > 0) {
c000293f:	eb 37                	jmp    c0002978 <malloc_page+0xb0>
/work/x86_os_my/kernel/memory.c:193
		void* page_phyaddr = palloc(mem_pool);
c0002941:	83 ec 0c             	sub    $0xc,%esp
c0002944:	ff 75 e8             	pushl  -0x18(%ebp)
c0002947:	e8 17 fe ff ff       	call   c0002763 <palloc>
c000294c:	83 c4 10             	add    $0x10,%esp
c000294f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:194
		if (page_phyaddr == NULL) {  // 失败时要将曾经已申请的虚拟地址和物理页全部回滚，在将来完成内存回收时再补充
c0002952:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0002956:	75 07                	jne    c000295f <malloc_page+0x97>
/work/x86_os_my/kernel/memory.c:195
			return NULL;
c0002958:	b8 00 00 00 00       	mov    $0x0,%eax
c000295d:	eb 29                	jmp    c0002988 <malloc_page+0xc0>
/work/x86_os_my/kernel/memory.c:197
		}
		page_table_add((void*)vaddr, page_phyaddr); // 在页表中做映射 
c000295f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002962:	83 ec 08             	sub    $0x8,%esp
c0002965:	ff 75 e4             	pushl  -0x1c(%ebp)
c0002968:	50                   	push   %eax
c0002969:	e8 49 fe ff ff       	call   c00027b7 <page_table_add>
c000296e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:198
		vaddr += PG_SIZE;		 // 下一个虚拟页
c0002971:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:192

	uint32_t vaddr = (uint32_t)vaddr_start, cnt = pg_cnt;
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;

	/* 因为虚拟地址是连续的,但物理地址可以是不连续的,所以逐个做映射*/
	while (cnt-- > 0) {
c0002978:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000297b:	8d 50 ff             	lea    -0x1(%eax),%edx
c000297e:	89 55 f0             	mov    %edx,-0x10(%ebp)
c0002981:	85 c0                	test   %eax,%eax
c0002983:	75 bc                	jne    c0002941 <malloc_page+0x79>
/work/x86_os_my/kernel/memory.c:200
			return NULL;
		}
		page_table_add((void*)vaddr, page_phyaddr); // 在页表中做映射 
		vaddr += PG_SIZE;		 // 下一个虚拟页
	}
	return vaddr_start;
c0002985:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/kernel/memory.c:201
}
c0002988:	c9                   	leave  
c0002989:	c3                   	ret    

c000298a <get_kernel_pages>:
get_kernel_pages():
/work/x86_os_my/kernel/memory.c:204

/* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */
void* get_kernel_pages(uint32_t pg_cnt) {
c000298a:	55                   	push   %ebp
c000298b:	89 e5                	mov    %esp,%ebp
c000298d:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:205
	lock_acquire(&kernel_pool.lock);
c0002990:	83 ec 0c             	sub    $0xc,%esp
c0002993:	68 70 fb 00 c0       	push   $0xc000fb70
c0002998:	e8 a2 1d 00 00       	call   c000473f <lock_acquire>
c000299d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:206
	void* vaddr =  malloc_page(PF_KERNEL, pg_cnt);
c00029a0:	83 ec 08             	sub    $0x8,%esp
c00029a3:	ff 75 08             	pushl  0x8(%ebp)
c00029a6:	6a 01                	push   $0x1
c00029a8:	e8 1b ff ff ff       	call   c00028c8 <malloc_page>
c00029ad:	83 c4 10             	add    $0x10,%esp
c00029b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:207
	if (vaddr != NULL) {
c00029b3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00029b7:	74 17                	je     c00029d0 <get_kernel_pages+0x46>
/work/x86_os_my/kernel/memory.c:208
		memset(vaddr, 0, pg_cnt * PG_SIZE);
c00029b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00029bc:	c1 e0 0c             	shl    $0xc,%eax
c00029bf:	83 ec 04             	sub    $0x4,%esp
c00029c2:	50                   	push   %eax
c00029c3:	6a 00                	push   $0x0
c00029c5:	ff 75 f4             	pushl  -0xc(%ebp)
c00029c8:	e8 b7 0d 00 00       	call   c0003784 <memset>
c00029cd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:210
	}
	lock_release(&kernel_pool.lock);
c00029d0:	83 ec 0c             	sub    $0xc,%esp
c00029d3:	68 70 fb 00 c0       	push   $0xc000fb70
c00029d8:	e8 d9 1d 00 00       	call   c00047b6 <lock_release>
c00029dd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:211
	return vaddr;
c00029e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:212
}
c00029e3:	c9                   	leave  
c00029e4:	c3                   	ret    

c00029e5 <get_user_pages>:
get_user_pages():
/work/x86_os_my/kernel/memory.c:215

/* 在用户空间中申请4k内存,并返回其虚拟地址 */
void* get_user_pages(uint32_t pg_cnt) {
c00029e5:	55                   	push   %ebp
c00029e6:	89 e5                	mov    %esp,%ebp
c00029e8:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:216
	lock_acquire(&user_pool.lock);
c00029eb:	83 ec 0c             	sub    $0xc,%esp
c00029ee:	68 70 fa 00 c0       	push   $0xc000fa70
c00029f3:	e8 47 1d 00 00       	call   c000473f <lock_acquire>
c00029f8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:217
	void* vaddr = malloc_page(PF_USER, pg_cnt);
c00029fb:	83 ec 08             	sub    $0x8,%esp
c00029fe:	ff 75 08             	pushl  0x8(%ebp)
c0002a01:	6a 02                	push   $0x2
c0002a03:	e8 c0 fe ff ff       	call   c00028c8 <malloc_page>
c0002a08:	83 c4 10             	add    $0x10,%esp
c0002a0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:218
	if (vaddr != NULL) {
c0002a0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0002a12:	74 17                	je     c0002a2b <get_user_pages+0x46>
/work/x86_os_my/kernel/memory.c:219
		memset(vaddr, 0, pg_cnt * PG_SIZE);
c0002a14:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a17:	c1 e0 0c             	shl    $0xc,%eax
c0002a1a:	83 ec 04             	sub    $0x4,%esp
c0002a1d:	50                   	push   %eax
c0002a1e:	6a 00                	push   $0x0
c0002a20:	ff 75 f4             	pushl  -0xc(%ebp)
c0002a23:	e8 5c 0d 00 00       	call   c0003784 <memset>
c0002a28:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:221
	}
	lock_release(&user_pool.lock);
c0002a2b:	83 ec 0c             	sub    $0xc,%esp
c0002a2e:	68 70 fa 00 c0       	push   $0xc000fa70
c0002a33:	e8 7e 1d 00 00       	call   c00047b6 <lock_release>
c0002a38:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:222
	return vaddr;
c0002a3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:223
}
c0002a3e:	c9                   	leave  
c0002a3f:	c3                   	ret    

c0002a40 <get_a_page>:
get_a_page():
/work/x86_os_my/kernel/memory.c:227

/* 将虚拟地址vaddr与pf池中的物理地址关联,仅支持一页空间分配
 * 功能是，可以指定虚拟地址的内存分配 */
void* get_a_page(enum pool_flags pf, uint32_t vaddr) {
c0002a40:	55                   	push   %ebp
c0002a41:	89 e5                	mov    %esp,%ebp
c0002a43:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:228
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c0002a46:	8b 45 08             	mov    0x8(%ebp),%eax
c0002a49:	83 e0 01             	and    $0x1,%eax
c0002a4c:	85 c0                	test   %eax,%eax
c0002a4e:	74 07                	je     c0002a57 <get_a_page+0x17>
/work/x86_os_my/kernel/memory.c:228 (discriminator 1)
c0002a50:	b8 60 fb 00 c0       	mov    $0xc000fb60,%eax
c0002a55:	eb 05                	jmp    c0002a5c <get_a_page+0x1c>
/work/x86_os_my/kernel/memory.c:228 (discriminator 2)
c0002a57:	b8 60 fa 00 c0       	mov    $0xc000fa60,%eax
/work/x86_os_my/kernel/memory.c:228 (discriminator 4)
c0002a5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:229 (discriminator 4)
	lock_acquire(&mem_pool->lock);
c0002a5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002a62:	83 c0 10             	add    $0x10,%eax
c0002a65:	83 ec 0c             	sub    $0xc,%esp
c0002a68:	50                   	push   %eax
c0002a69:	e8 d1 1c 00 00       	call   c000473f <lock_acquire>
c0002a6e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:232 (discriminator 4)

	/* 先将虚拟地址对应的位图置1 */
	struct task_struct* cur = running_thread();
c0002a71:	e8 f5 10 00 00       	call   c0003b6b <running_thread>
c0002a76:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:233 (discriminator 4)
	int32_t bit_idx = -1;
c0002a79:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:235 (discriminator 4)

	if (cur->pgdir != NULL && pf == PF_USER) {
c0002a80:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002a83:	8b 40 54             	mov    0x54(%eax),%eax
c0002a86:	85 c0                	test   %eax,%eax
c0002a88:	74 55                	je     c0002adf <get_a_page+0x9f>
/work/x86_os_my/kernel/memory.c:235 (discriminator 1)
c0002a8a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0002a8e:	75 4f                	jne    c0002adf <get_a_page+0x9f>
/work/x86_os_my/kernel/memory.c:237
		/* 若当前是用户进程申请用户内存,就修改用户进程自己的虚拟地址池的 位图 */
		bit_idx = (vaddr - cur->userprog_vaddr.vaddr_start) / PG_SIZE;
c0002a90:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002a93:	8b 40 60             	mov    0x60(%eax),%eax
c0002a96:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002a99:	29 c2                	sub    %eax,%edx
c0002a9b:	89 d0                	mov    %edx,%eax
c0002a9d:	c1 e8 0c             	shr    $0xc,%eax
c0002aa0:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:238
		ASSERT(bit_idx > 0);
c0002aa3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002aa7:	7f 1c                	jg     c0002ac5 <get_a_page+0x85>
/work/x86_os_my/kernel/memory.c:238 (discriminator 1)
c0002aa9:	68 23 b5 00 c0       	push   $0xc000b523
c0002aae:	68 38 b8 00 c0       	push   $0xc000b838
c0002ab3:	68 ee 00 00 00       	push   $0xee
c0002ab8:	68 d7 b4 00 c0       	push   $0xc000b4d7
c0002abd:	e8 20 f8 ff ff       	call   c00022e2 <panic_spin>
c0002ac2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:239
		bitmap_set(&cur->userprog_vaddr.vaddr_bitmap, bit_idx, 1);
c0002ac5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002ac8:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0002acb:	83 c2 58             	add    $0x58,%edx
c0002ace:	83 ec 04             	sub    $0x4,%esp
c0002ad1:	6a 01                	push   $0x1
c0002ad3:	50                   	push   %eax
c0002ad4:	52                   	push   %edx
c0002ad5:	e8 76 fa ff ff       	call   c0002550 <bitmap_set>
c0002ada:	83 c4 10             	add    $0x10,%esp
c0002add:	eb 78                	jmp    c0002b57 <get_a_page+0x117>
/work/x86_os_my/kernel/memory.c:241

	} else if (cur->pgdir == NULL && pf == PF_KERNEL) {
c0002adf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002ae2:	8b 40 54             	mov    0x54(%eax),%eax
c0002ae5:	85 c0                	test   %eax,%eax
c0002ae7:	75 52                	jne    c0002b3b <get_a_page+0xfb>
/work/x86_os_my/kernel/memory.c:241 (discriminator 1)
c0002ae9:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c0002aed:	75 4c                	jne    c0002b3b <get_a_page+0xfb>
/work/x86_os_my/kernel/memory.c:243
		/* 如果是内核线程申请内核内存,就修改 kernel_vaddr */
		bit_idx = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
c0002aef:	a1 50 fb 00 c0       	mov    0xc000fb50,%eax
c0002af4:	8b 55 0c             	mov    0xc(%ebp),%edx
c0002af7:	29 c2                	sub    %eax,%edx
c0002af9:	89 d0                	mov    %edx,%eax
c0002afb:	c1 e8 0c             	shr    $0xc,%eax
c0002afe:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:244
		ASSERT(bit_idx > 0);
c0002b01:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0002b05:	7f 1c                	jg     c0002b23 <get_a_page+0xe3>
/work/x86_os_my/kernel/memory.c:244 (discriminator 1)
c0002b07:	68 23 b5 00 c0       	push   $0xc000b523
c0002b0c:	68 38 b8 00 c0       	push   $0xc000b838
c0002b11:	68 f4 00 00 00       	push   $0xf4
c0002b16:	68 d7 b4 00 c0       	push   $0xc000b4d7
c0002b1b:	e8 c2 f7 ff ff       	call   c00022e2 <panic_spin>
c0002b20:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:245
		bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx, 1);
c0002b23:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0002b26:	83 ec 04             	sub    $0x4,%esp
c0002b29:	6a 01                	push   $0x1
c0002b2b:	50                   	push   %eax
c0002b2c:	68 48 fb 00 c0       	push   $0xc000fb48
c0002b31:	e8 1a fa ff ff       	call   c0002550 <bitmap_set>
c0002b36:	83 c4 10             	add    $0x10,%esp
c0002b39:	eb 1c                	jmp    c0002b57 <get_a_page+0x117>
/work/x86_os_my/kernel/memory.c:248

	} else {
		PANIC("get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page");
c0002b3b:	68 30 b5 00 c0       	push   $0xc000b530
c0002b40:	68 38 b8 00 c0       	push   $0xc000b838
c0002b45:	68 f8 00 00 00       	push   $0xf8
c0002b4a:	68 d7 b4 00 c0       	push   $0xc000b4d7
c0002b4f:	e8 8e f7 ff ff       	call   c00022e2 <panic_spin>
c0002b54:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:251
	}

	void* page_phyaddr = palloc(mem_pool);
c0002b57:	83 ec 0c             	sub    $0xc,%esp
c0002b5a:	ff 75 f4             	pushl  -0xc(%ebp)
c0002b5d:	e8 01 fc ff ff       	call   c0002763 <palloc>
c0002b62:	83 c4 10             	add    $0x10,%esp
c0002b65:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:252
	if (page_phyaddr == NULL) {
c0002b68:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0002b6c:	75 19                	jne    c0002b87 <get_a_page+0x147>
/work/x86_os_my/kernel/memory.c:253
		lock_release(&mem_pool->lock);	//哈哈
c0002b6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002b71:	83 c0 10             	add    $0x10,%eax
c0002b74:	83 ec 0c             	sub    $0xc,%esp
c0002b77:	50                   	push   %eax
c0002b78:	e8 39 1c 00 00       	call   c00047b6 <lock_release>
c0002b7d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:254
		return NULL;
c0002b80:	b8 00 00 00 00       	mov    $0x0,%eax
c0002b85:	eb 27                	jmp    c0002bae <get_a_page+0x16e>
/work/x86_os_my/kernel/memory.c:256
	}
	page_table_add((void*)vaddr, page_phyaddr);
c0002b87:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002b8a:	83 ec 08             	sub    $0x8,%esp
c0002b8d:	ff 75 e8             	pushl  -0x18(%ebp)
c0002b90:	50                   	push   %eax
c0002b91:	e8 21 fc ff ff       	call   c00027b7 <page_table_add>
c0002b96:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:258
	
	lock_release(&mem_pool->lock);
c0002b99:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002b9c:	83 c0 10             	add    $0x10,%eax
c0002b9f:	83 ec 0c             	sub    $0xc,%esp
c0002ba2:	50                   	push   %eax
c0002ba3:	e8 0e 1c 00 00       	call   c00047b6 <lock_release>
c0002ba8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:259
	return (void*)vaddr;
c0002bab:	8b 45 0c             	mov    0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:260
}
c0002bae:	c9                   	leave  
c0002baf:	c3                   	ret    

c0002bb0 <get_a_page_without_opvaddrbitmap>:
get_a_page_without_opvaddrbitmap():
/work/x86_os_my/kernel/memory.c:265

/* 安装1页大小的vaddr，专门针对fork时不修改虚拟地址位图的情况
 * 函数功能和 get_a_page 类似，为 vaddr 分配一物理页，只是少了虚拟地址池位图的操作
 */
void* get_a_page_without_opvaddrbitmap(enum pool_flags pf, uint32_t vaddr) {
c0002bb0:	55                   	push   %ebp
c0002bb1:	89 e5                	mov    %esp,%ebp
c0002bb3:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:266
	struct pool* mem_pool = pf & PF_KERNEL ? &kernel_pool : &user_pool;
c0002bb6:	8b 45 08             	mov    0x8(%ebp),%eax
c0002bb9:	83 e0 01             	and    $0x1,%eax
c0002bbc:	85 c0                	test   %eax,%eax
c0002bbe:	74 07                	je     c0002bc7 <get_a_page_without_opvaddrbitmap+0x17>
/work/x86_os_my/kernel/memory.c:266 (discriminator 1)
c0002bc0:	b8 60 fb 00 c0       	mov    $0xc000fb60,%eax
c0002bc5:	eb 05                	jmp    c0002bcc <get_a_page_without_opvaddrbitmap+0x1c>
/work/x86_os_my/kernel/memory.c:266 (discriminator 2)
c0002bc7:	b8 60 fa 00 c0       	mov    $0xc000fa60,%eax
/work/x86_os_my/kernel/memory.c:266 (discriminator 4)
c0002bcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:267 (discriminator 4)
	lock_acquire(&mem_pool->lock);
c0002bcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002bd2:	83 c0 10             	add    $0x10,%eax
c0002bd5:	83 ec 0c             	sub    $0xc,%esp
c0002bd8:	50                   	push   %eax
c0002bd9:	e8 61 1b 00 00       	call   c000473f <lock_acquire>
c0002bde:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:268 (discriminator 4)
	void* page_phyaddr = palloc(mem_pool);
c0002be1:	83 ec 0c             	sub    $0xc,%esp
c0002be4:	ff 75 f4             	pushl  -0xc(%ebp)
c0002be7:	e8 77 fb ff ff       	call   c0002763 <palloc>
c0002bec:	83 c4 10             	add    $0x10,%esp
c0002bef:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:269 (discriminator 4)
	if (page_phyaddr == NULL) {
c0002bf2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0002bf6:	75 19                	jne    c0002c11 <get_a_page_without_opvaddrbitmap+0x61>
/work/x86_os_my/kernel/memory.c:270
		lock_release(&mem_pool->lock);
c0002bf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002bfb:	83 c0 10             	add    $0x10,%eax
c0002bfe:	83 ec 0c             	sub    $0xc,%esp
c0002c01:	50                   	push   %eax
c0002c02:	e8 af 1b 00 00       	call   c00047b6 <lock_release>
c0002c07:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:271
		return NULL;
c0002c0a:	b8 00 00 00 00       	mov    $0x0,%eax
c0002c0f:	eb 27                	jmp    c0002c38 <get_a_page_without_opvaddrbitmap+0x88>
/work/x86_os_my/kernel/memory.c:273
	}
	page_table_add((void*)vaddr, page_phyaddr);
c0002c11:	8b 45 0c             	mov    0xc(%ebp),%eax
c0002c14:	83 ec 08             	sub    $0x8,%esp
c0002c17:	ff 75 f0             	pushl  -0x10(%ebp)
c0002c1a:	50                   	push   %eax
c0002c1b:	e8 97 fb ff ff       	call   c00027b7 <page_table_add>
c0002c20:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:274
	lock_release(&mem_pool->lock);
c0002c23:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0002c26:	83 c0 10             	add    $0x10,%eax
c0002c29:	83 ec 0c             	sub    $0xc,%esp
c0002c2c:	50                   	push   %eax
c0002c2d:	e8 84 1b 00 00       	call   c00047b6 <lock_release>
c0002c32:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:275
	return (void*)vaddr;
c0002c35:	8b 45 0c             	mov    0xc(%ebp),%eax
/work/x86_os_my/kernel/memory.c:276
}
c0002c38:	c9                   	leave  
c0002c39:	c3                   	ret    

c0002c3a <addr_v2p>:
addr_v2p():
/work/x86_os_my/kernel/memory.c:279

/* 得到虚拟地址映射到的物理地址 */
uint32_t addr_v2p(uint32_t vaddr) {
c0002c3a:	55                   	push   %ebp
c0002c3b:	89 e5                	mov    %esp,%ebp
c0002c3d:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:280
	uint32_t* pte = pte_ptr(vaddr);
c0002c40:	ff 75 08             	pushl  0x8(%ebp)
c0002c43:	e8 cf fa ff ff       	call   c0002717 <pte_ptr>
c0002c48:	83 c4 04             	add    $0x4,%esp
c0002c4b:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:284
	/* (*pte)的内容是 vaddr 所在 pte 的内容，也就是 vaddr 最终所映射到的物理页框的 32 位地址中的高 20 位和 12 位的页表项属性，
	 * 因为页框都是自然页，低 12 位地址是 0，所以页表项 pte（和页目录项 pde）中只需要记录页框的高 20 位地址即可。
	 */
	return ((*pte & 0xfffff000) + (vaddr & 0x00000fff));
c0002c4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0002c51:	8b 00                	mov    (%eax),%eax
c0002c53:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0002c58:	89 c2                	mov    %eax,%edx
c0002c5a:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c5d:	25 ff 0f 00 00       	and    $0xfff,%eax
c0002c62:	01 d0                	add    %edx,%eax
/work/x86_os_my/kernel/memory.c:285
}
c0002c64:	c9                   	leave  
c0002c65:	c3                   	ret    

c0002c66 <arena2block>:
arena2block():
/work/x86_os_my/kernel/memory.c:299
|                     |
| +-----------------+ |
+-+  mem_block_desc |←+
  +-----------------+
*/
static struct mem_block* arena2block(struct arena* a, uint32_t idx) {
c0002c66:	55                   	push   %ebp
c0002c67:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/kernel/memory.c:300
	return (struct mem_block*)((uint32_t)a + sizeof(struct arena) + idx * a->desc->block_size);
c0002c69:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c6c:	8b 00                	mov    (%eax),%eax
c0002c6e:	8b 00                	mov    (%eax),%eax
c0002c70:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0002c74:	89 c2                	mov    %eax,%edx
c0002c76:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c79:	01 d0                	add    %edx,%eax
c0002c7b:	83 c0 0c             	add    $0xc,%eax
/work/x86_os_my/kernel/memory.c:301
}
c0002c7e:	5d                   	pop    %ebp
c0002c7f:	c3                   	ret    

c0002c80 <block2arena>:
block2arena():
/work/x86_os_my/kernel/memory.c:306

/* 返回内存块mem_block所在的arena地址
 * 取到了虚拟地址mem_block那一整页的地址
 */
static struct arena* block2arena(struct mem_block* b) {
c0002c80:	55                   	push   %ebp
c0002c81:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/kernel/memory.c:307
	return (struct arena*)((uint32_t)b & 0xfffff000);
c0002c83:	8b 45 08             	mov    0x8(%ebp),%eax
c0002c86:	25 00 f0 ff ff       	and    $0xfffff000,%eax
/work/x86_os_my/kernel/memory.c:308
}
c0002c8b:	5d                   	pop    %ebp
c0002c8c:	c3                   	ret    

c0002c8d <sys_malloc>:
sys_malloc():
/work/x86_os_my/kernel/memory.c:319
 * 3.内存块地址被返回给用户后，用户可以自由使用此内存块 mem_block
 *   会把此内存块中的 list_elem 型变量 free_elem 覆盖
 *   不过 arena->mem_block_desc->free_list 中的元素已经记录了 mem_block->list_elem 的地址
 *   使用时覆盖的，只是 mem_block 的内容。
 */
void* sys_malloc(uint32_t size) {
c0002c8d:	55                   	push   %ebp
c0002c8e:	89 e5                	mov    %esp,%ebp
c0002c90:	83 ec 38             	sub    $0x38,%esp
/work/x86_os_my/kernel/memory.c:324
	enum pool_flags PF;
	struct pool* mem_pool;
	uint32_t pool_size;
	struct mem_block_desc* descs;
	struct task_struct* cur_thread = running_thread();
c0002c93:	e8 d3 0e 00 00       	call   c0003b6b <running_thread>
c0002c98:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/kernel/memory.c:327

	/* 判断用哪个内存池*/
	if (cur_thread->pgdir == NULL) {	// 是内核线程
c0002c9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0002c9e:	8b 40 54             	mov    0x54(%eax),%eax
c0002ca1:	85 c0                	test   %eax,%eax
c0002ca3:	75 1f                	jne    c0002cc4 <sys_malloc+0x37>
/work/x86_os_my/kernel/memory.c:328
		PF = PF_KERNEL;
c0002ca5:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:329
		pool_size = kernel_pool.pool_size;
c0002cac:	a1 6c fb 00 c0       	mov    0xc000fb6c,%eax
c0002cb1:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:330
		mem_pool = &kernel_pool;
c0002cb4:	c7 45 f0 60 fb 00 c0 	movl   $0xc000fb60,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:331
		descs = k_block_descs;
c0002cbb:	c7 45 e8 a0 fa 00 c0 	movl   $0xc000faa0,-0x18(%ebp)
c0002cc2:	eb 1f                	jmp    c0002ce3 <sys_malloc+0x56>
/work/x86_os_my/kernel/memory.c:333
	} else {							// 用户进程pcb中的pgdir（页目录表）会在为其分配页表时创建【create_page_dir】
		PF = PF_USER;
c0002cc4:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:334
		pool_size = user_pool.pool_size;
c0002ccb:	a1 6c fa 00 c0       	mov    0xc000fa6c,%eax
c0002cd0:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:335
		mem_pool = &user_pool;
c0002cd3:	c7 45 f0 60 fa 00 c0 	movl   $0xc000fa60,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:336
		descs = cur_thread->u_block_desc;
c0002cda:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0002cdd:	83 c0 64             	add    $0x64,%eax
c0002ce0:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:340
	}

	/* 若申请的内存不在内存池容量范围内则直接返回NULL */
	if (!(size > 0 && size < pool_size)) {
c0002ce3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0002ce7:	74 08                	je     c0002cf1 <sys_malloc+0x64>
/work/x86_os_my/kernel/memory.c:340 (discriminator 1)
c0002ce9:	8b 45 08             	mov    0x8(%ebp),%eax
c0002cec:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0002cef:	72 0a                	jb     c0002cfb <sys_malloc+0x6e>
/work/x86_os_my/kernel/memory.c:341
		return NULL;
c0002cf1:	b8 00 00 00 00       	mov    $0x0,%eax
c0002cf6:	e9 c5 02 00 00       	jmp    c0002fc0 <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:346
	}

	struct arena* a;
	struct mem_block* b;
	lock_acquire(&mem_pool->lock);
c0002cfb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002cfe:	83 c0 10             	add    $0x10,%eax
c0002d01:	83 ec 0c             	sub    $0xc,%esp
c0002d04:	50                   	push   %eax
c0002d05:	e8 35 1a 00 00       	call   c000473f <lock_acquire>
c0002d0a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:349

	/* 超过最大内存块1024, 就分配页框 */
	if (size > 1024) {
c0002d0d:	81 7d 08 00 04 00 00 	cmpl   $0x400,0x8(%ebp)
c0002d14:	0f 86 94 00 00 00    	jbe    c0002dae <sys_malloc+0x121>
/work/x86_os_my/kernel/memory.c:350
		uint32_t page_cnt = DIV_ROUND_UP(size + sizeof(struct arena), PG_SIZE);	// 向上取整需要的页框数
c0002d1a:	8b 45 08             	mov    0x8(%ebp),%eax
c0002d1d:	05 0b 10 00 00       	add    $0x100b,%eax
c0002d22:	c1 e8 0c             	shr    $0xc,%eax
c0002d25:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/kernel/memory.c:352

		a = malloc_page(PF, page_cnt);
c0002d28:	83 ec 08             	sub    $0x8,%esp
c0002d2b:	ff 75 d8             	pushl  -0x28(%ebp)
c0002d2e:	ff 75 f4             	pushl  -0xc(%ebp)
c0002d31:	e8 92 fb ff ff       	call   c00028c8 <malloc_page>
c0002d36:	83 c4 10             	add    $0x10,%esp
c0002d39:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:353
		if (a != NULL) {
c0002d3c:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0002d40:	74 50                	je     c0002d92 <sys_malloc+0x105>
/work/x86_os_my/kernel/memory.c:354
			memset(a, 0, page_cnt * PG_SIZE);
c0002d42:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0002d45:	c1 e0 0c             	shl    $0xc,%eax
c0002d48:	83 ec 04             	sub    $0x4,%esp
c0002d4b:	50                   	push   %eax
c0002d4c:	6a 00                	push   $0x0
c0002d4e:	ff 75 d4             	pushl  -0x2c(%ebp)
c0002d51:	e8 2e 0a 00 00       	call   c0003784 <memset>
c0002d56:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:358

			// 【arena结构体初始化，情况1】
			/* 对于分配的大块页框,将desc置为NULL, cnt置为页框数, large置为true */
			a->desc = NULL;
c0002d59:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002d5c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/kernel/memory.c:359
			a->cnt = page_cnt;
c0002d62:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002d65:	8b 55 d8             	mov    -0x28(%ebp),%edx
c0002d68:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/kernel/memory.c:360
			a->large = true;
c0002d6b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002d6e:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/kernel/memory.c:362

			lock_release(&mem_pool->lock);
c0002d75:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002d78:	83 c0 10             	add    $0x10,%eax
c0002d7b:	83 ec 0c             	sub    $0xc,%esp
c0002d7e:	50                   	push   %eax
c0002d7f:	e8 32 1a 00 00       	call   c00047b6 <lock_release>
c0002d84:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:363
			return (void*)(a + 1);	// 跨过arena大小，把剩下的内存返回
c0002d87:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002d8a:	83 c0 0c             	add    $0xc,%eax
c0002d8d:	e9 2e 02 00 00       	jmp    c0002fc0 <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:365
		} else {
			lock_release(&mem_pool->lock);
c0002d92:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002d95:	83 c0 10             	add    $0x10,%eax
c0002d98:	83 ec 0c             	sub    $0xc,%esp
c0002d9b:	50                   	push   %eax
c0002d9c:	e8 15 1a 00 00       	call   c00047b6 <lock_release>
c0002da1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:366
			return NULL;
c0002da4:	b8 00 00 00 00       	mov    $0x0,%eax
c0002da9:	e9 12 02 00 00       	jmp    c0002fc0 <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:374
	} else {
	/* 若申请的内存小于等于1024,可在各种规格的mem_block_desc中去适配 */
		uint8_t desc_idx;

		/* 从内存块描述符中匹配合适的内存块规格 */
		for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c0002dae:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
c0002db2:	eb 25                	jmp    c0002dd9 <sys_malloc+0x14c>
/work/x86_os_my/kernel/memory.c:375
			if (size <= descs[desc_idx].block_size) {	// 从小往大后,找到后退出
c0002db4:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0002db8:	89 d0                	mov    %edx,%eax
c0002dba:	01 c0                	add    %eax,%eax
c0002dbc:	01 d0                	add    %edx,%eax
c0002dbe:	c1 e0 03             	shl    $0x3,%eax
c0002dc1:	89 c2                	mov    %eax,%edx
c0002dc3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002dc6:	01 d0                	add    %edx,%eax
c0002dc8:	8b 00                	mov    (%eax),%eax
c0002dca:	3b 45 08             	cmp    0x8(%ebp),%eax
c0002dcd:	73 12                	jae    c0002de1 <sys_malloc+0x154>
/work/x86_os_my/kernel/memory.c:374 (discriminator 2)
	} else {
	/* 若申请的内存小于等于1024,可在各种规格的mem_block_desc中去适配 */
		uint8_t desc_idx;

		/* 从内存块描述符中匹配合适的内存块规格 */
		for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c0002dcf:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
c0002dd3:	83 c0 01             	add    $0x1,%eax
c0002dd6:	88 45 e7             	mov    %al,-0x19(%ebp)
/work/x86_os_my/kernel/memory.c:374 (discriminator 1)
c0002dd9:	80 7d e7 06          	cmpb   $0x6,-0x19(%ebp)
c0002ddd:	76 d5                	jbe    c0002db4 <sys_malloc+0x127>
c0002ddf:	eb 01                	jmp    c0002de2 <sys_malloc+0x155>
/work/x86_os_my/kernel/memory.c:376
			if (size <= descs[desc_idx].block_size) {	// 从小往大后,找到后退出
				break;
c0002de1:	90                   	nop
/work/x86_os_my/kernel/memory.c:382
			}
		}

		/* 若mem_block_desc的free_list中已经没有可用的mem_block,
		 * 就创建新的arena提供mem_block */
		if (list_empty(&descs[desc_idx].free_list)) {
c0002de2:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0002de6:	89 d0                	mov    %edx,%eax
c0002de8:	01 c0                	add    %eax,%eax
c0002dea:	01 d0                	add    %edx,%eax
c0002dec:	c1 e0 03             	shl    $0x3,%eax
c0002def:	89 c2                	mov    %eax,%edx
c0002df1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002df4:	01 d0                	add    %edx,%eax
c0002df6:	83 c0 08             	add    $0x8,%eax
c0002df9:	83 ec 0c             	sub    $0xc,%esp
c0002dfc:	50                   	push   %eax
c0002dfd:	e8 53 16 00 00       	call   c0004455 <list_empty>
c0002e02:	83 c4 10             	add    $0x10,%esp
c0002e05:	85 c0                	test   %eax,%eax
c0002e07:	0f 84 31 01 00 00    	je     c0002f3e <sys_malloc+0x2b1>
/work/x86_os_my/kernel/memory.c:383
			a = malloc_page(PF, 1);       // 分配1页框做为arena
c0002e0d:	83 ec 08             	sub    $0x8,%esp
c0002e10:	6a 01                	push   $0x1
c0002e12:	ff 75 f4             	pushl  -0xc(%ebp)
c0002e15:	e8 ae fa ff ff       	call   c00028c8 <malloc_page>
c0002e1a:	83 c4 10             	add    $0x10,%esp
c0002e1d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:384
			if (a == NULL) {
c0002e20:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c0002e24:	75 1c                	jne    c0002e42 <sys_malloc+0x1b5>
/work/x86_os_my/kernel/memory.c:385
				lock_release(&mem_pool->lock);
c0002e26:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002e29:	83 c0 10             	add    $0x10,%eax
c0002e2c:	83 ec 0c             	sub    $0xc,%esp
c0002e2f:	50                   	push   %eax
c0002e30:	e8 81 19 00 00       	call   c00047b6 <lock_release>
c0002e35:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:386
				return NULL;
c0002e38:	b8 00 00 00 00       	mov    $0x0,%eax
c0002e3d:	e9 7e 01 00 00       	jmp    c0002fc0 <sys_malloc+0x333>
/work/x86_os_my/kernel/memory.c:388
			}
			memset(a, 0, PG_SIZE);
c0002e42:	83 ec 04             	sub    $0x4,%esp
c0002e45:	68 00 10 00 00       	push   $0x1000
c0002e4a:	6a 00                	push   $0x0
c0002e4c:	ff 75 d4             	pushl  -0x2c(%ebp)
c0002e4f:	e8 30 09 00 00       	call   c0003784 <memset>
c0002e54:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:392

			// 【arena结构体初始化，情况2】
			/* 对于分配的小块内存,将desc置为相应内存块描述符, cnt置为此arena可用的内存块数, large置为false */
			a->desc = &descs[desc_idx];
c0002e57:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0002e5b:	89 d0                	mov    %edx,%eax
c0002e5d:	01 c0                	add    %eax,%eax
c0002e5f:	01 d0                	add    %edx,%eax
c0002e61:	c1 e0 03             	shl    $0x3,%eax
c0002e64:	89 c2                	mov    %eax,%edx
c0002e66:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002e69:	01 c2                	add    %eax,%edx
c0002e6b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002e6e:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:393
			a->large = false;
c0002e70:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002e73:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/kernel/memory.c:394
			a->cnt = descs[desc_idx].blocks_per_arena;
c0002e7a:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0002e7e:	89 d0                	mov    %edx,%eax
c0002e80:	01 c0                	add    %eax,%eax
c0002e82:	01 d0                	add    %edx,%eax
c0002e84:	c1 e0 03             	shl    $0x3,%eax
c0002e87:	89 c2                	mov    %eax,%edx
c0002e89:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002e8c:	01 d0                	add    %edx,%eax
c0002e8e:	8b 50 04             	mov    0x4(%eax),%edx
c0002e91:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002e94:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/kernel/memory.c:396

			enum intr_status old_status = intr_disable();
c0002e97:	e8 a2 ea ff ff       	call   c000193e <intr_disable>
c0002e9c:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/kernel/memory.c:399
			/* 开始将arena拆分成内存块,并添加到内存块描述符的free_list中 */
			uint32_t block_idx;
			for (block_idx = 0; block_idx < descs[desc_idx].blocks_per_arena; block_idx++) {
c0002e9f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c0002ea6:	eb 68                	jmp    c0002f10 <sys_malloc+0x283>
/work/x86_os_my/kernel/memory.c:400
				b = arena2block(a, block_idx);
c0002ea8:	83 ec 08             	sub    $0x8,%esp
c0002eab:	ff 75 e0             	pushl  -0x20(%ebp)
c0002eae:	ff 75 d4             	pushl  -0x2c(%ebp)
c0002eb1:	e8 b0 fd ff ff       	call   c0002c66 <arena2block>
c0002eb6:	83 c4 10             	add    $0x10,%esp
c0002eb9:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/kernel/memory.c:401
				ASSERT(!elem_find(&a->desc->free_list, &b->free_elem));
c0002ebc:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0002ebf:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0002ec2:	8b 12                	mov    (%edx),%edx
c0002ec4:	83 c2 08             	add    $0x8,%edx
c0002ec7:	83 ec 08             	sub    $0x8,%esp
c0002eca:	50                   	push   %eax
c0002ecb:	52                   	push   %edx
c0002ecc:	e8 b7 14 00 00       	call   c0004388 <elem_find>
c0002ed1:	83 c4 10             	add    $0x10,%esp
c0002ed4:	85 c0                	test   %eax,%eax
c0002ed6:	74 1c                	je     c0002ef4 <sys_malloc+0x267>
/work/x86_os_my/kernel/memory.c:401 (discriminator 1)
c0002ed8:	68 84 b5 00 c0       	push   $0xc000b584
c0002edd:	68 44 b8 00 c0       	push   $0xc000b844
c0002ee2:	68 91 01 00 00       	push   $0x191
c0002ee7:	68 d7 b4 00 c0       	push   $0xc000b4d7
c0002eec:	e8 f1 f3 ff ff       	call   c00022e2 <panic_spin>
c0002ef1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:402 (discriminator 2)
				list_append(&a->desc->free_list, &b->free_elem);
c0002ef4:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0002ef7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0002efa:	8b 12                	mov    (%edx),%edx
c0002efc:	83 c2 08             	add    $0x8,%edx
c0002eff:	83 ec 08             	sub    $0x8,%esp
c0002f02:	50                   	push   %eax
c0002f03:	52                   	push   %edx
c0002f04:	e8 05 14 00 00       	call   c000430e <list_append>
c0002f09:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:399 (discriminator 2)
			a->cnt = descs[desc_idx].blocks_per_arena;

			enum intr_status old_status = intr_disable();
			/* 开始将arena拆分成内存块,并添加到内存块描述符的free_list中 */
			uint32_t block_idx;
			for (block_idx = 0; block_idx < descs[desc_idx].blocks_per_arena; block_idx++) {
c0002f0c:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
/work/x86_os_my/kernel/memory.c:399 (discriminator 1)
c0002f10:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0002f14:	89 d0                	mov    %edx,%eax
c0002f16:	01 c0                	add    %eax,%eax
c0002f18:	01 d0                	add    %edx,%eax
c0002f1a:	c1 e0 03             	shl    $0x3,%eax
c0002f1d:	89 c2                	mov    %eax,%edx
c0002f1f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002f22:	01 d0                	add    %edx,%eax
c0002f24:	8b 40 04             	mov    0x4(%eax),%eax
c0002f27:	3b 45 e0             	cmp    -0x20(%ebp),%eax
c0002f2a:	0f 87 78 ff ff ff    	ja     c0002ea8 <sys_malloc+0x21b>
/work/x86_os_my/kernel/memory.c:404
				b = arena2block(a, block_idx);
				ASSERT(!elem_find(&a->desc->free_list, &b->free_elem));
				list_append(&a->desc->free_list, &b->free_elem);
			}
			intr_set_status(old_status);
c0002f30:	83 ec 0c             	sub    $0xc,%esp
c0002f33:	ff 75 d0             	pushl  -0x30(%ebp)
c0002f36:	e8 2c ea ff ff       	call   c0001967 <intr_set_status>
c0002f3b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:408
		}

		/* 开始分配内存块 */
		b = elem2entry(struct mem_block, free_elem, list_pop(&(descs[desc_idx].free_list)));
c0002f3e:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0002f42:	89 d0                	mov    %edx,%eax
c0002f44:	01 c0                	add    %eax,%eax
c0002f46:	01 d0                	add    %edx,%eax
c0002f48:	c1 e0 03             	shl    $0x3,%eax
c0002f4b:	89 c2                	mov    %eax,%edx
c0002f4d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002f50:	01 d0                	add    %edx,%eax
c0002f52:	83 c0 08             	add    $0x8,%eax
c0002f55:	83 ec 0c             	sub    $0xc,%esp
c0002f58:	50                   	push   %eax
c0002f59:	e8 08 14 00 00       	call   c0004366 <list_pop>
c0002f5e:	83 c4 10             	add    $0x10,%esp
c0002f61:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/kernel/memory.c:409
		memset(b, 0, descs[desc_idx].block_size);
c0002f64:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
c0002f68:	89 d0                	mov    %edx,%eax
c0002f6a:	01 c0                	add    %eax,%eax
c0002f6c:	01 d0                	add    %edx,%eax
c0002f6e:	c1 e0 03             	shl    $0x3,%eax
c0002f71:	89 c2                	mov    %eax,%edx
c0002f73:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0002f76:	01 d0                	add    %edx,%eax
c0002f78:	8b 00                	mov    (%eax),%eax
c0002f7a:	83 ec 04             	sub    $0x4,%esp
c0002f7d:	50                   	push   %eax
c0002f7e:	6a 00                	push   $0x0
c0002f80:	ff 75 cc             	pushl  -0x34(%ebp)
c0002f83:	e8 fc 07 00 00       	call   c0003784 <memset>
c0002f88:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:411

		a = block2arena(b);	// 获取内存块b所在的arena
c0002f8b:	83 ec 0c             	sub    $0xc,%esp
c0002f8e:	ff 75 cc             	pushl  -0x34(%ebp)
c0002f91:	e8 ea fc ff ff       	call   c0002c80 <block2arena>
c0002f96:	83 c4 10             	add    $0x10,%esp
c0002f99:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:412
		a->cnt--;			// 将此arena中的空闲内存块数减1
c0002f9c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002f9f:	8b 40 04             	mov    0x4(%eax),%eax
c0002fa2:	8d 50 ff             	lea    -0x1(%eax),%edx
c0002fa5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0002fa8:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/kernel/memory.c:414

		lock_release(&mem_pool->lock);
c0002fab:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0002fae:	83 c0 10             	add    $0x10,%eax
c0002fb1:	83 ec 0c             	sub    $0xc,%esp
c0002fb4:	50                   	push   %eax
c0002fb5:	e8 fc 17 00 00       	call   c00047b6 <lock_release>
c0002fba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:415
		return (void*)b;
c0002fbd:	8b 45 cc             	mov    -0x34(%ebp),%eax
/work/x86_os_my/kernel/memory.c:417
	}
}
c0002fc0:	c9                   	leave  
c0002fc1:	c3                   	ret    

c0002fc2 <pfree>:
pfree():
/work/x86_os_my/kernel/memory.c:422

/* 将物理地址pg_phy_addr回收到物理内存池
 * 清理物理地址池位图
 */
void pfree(uint32_t pg_phy_addr) {
c0002fc2:	55                   	push   %ebp
c0002fc3:	89 e5                	mov    %esp,%ebp
c0002fc5:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:424
	struct pool* mem_pool;
	uint32_t bit_idx = 0;
c0002fc8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:425
	if (pg_phy_addr >= user_pool.phy_addr_start) {	// 用户物理内存池
c0002fcf:	a1 68 fa 00 c0       	mov    0xc000fa68,%eax
c0002fd4:	3b 45 08             	cmp    0x8(%ebp),%eax
c0002fd7:	77 1b                	ja     c0002ff4 <pfree+0x32>
/work/x86_os_my/kernel/memory.c:426
		mem_pool = &user_pool;
c0002fd9:	c7 45 f4 60 fa 00 c0 	movl   $0xc000fa60,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:427
		bit_idx = (pg_phy_addr - user_pool.phy_addr_start) / PG_SIZE;
c0002fe0:	a1 68 fa 00 c0       	mov    0xc000fa68,%eax
c0002fe5:	8b 55 08             	mov    0x8(%ebp),%edx
c0002fe8:	29 c2                	sub    %eax,%edx
c0002fea:	89 d0                	mov    %edx,%eax
c0002fec:	c1 e8 0c             	shr    $0xc,%eax
c0002fef:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0002ff2:	eb 19                	jmp    c000300d <pfree+0x4b>
/work/x86_os_my/kernel/memory.c:429
	} else {	// 内核物理内存池
		mem_pool = &kernel_pool;
c0002ff4:	c7 45 f4 60 fb 00 c0 	movl   $0xc000fb60,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:430
		bit_idx = (pg_phy_addr - kernel_pool.phy_addr_start) / PG_SIZE;
c0002ffb:	a1 68 fb 00 c0       	mov    0xc000fb68,%eax
c0003000:	8b 55 08             	mov    0x8(%ebp),%edx
c0003003:	29 c2                	sub    %eax,%edx
c0003005:	89 d0                	mov    %edx,%eax
c0003007:	c1 e8 0c             	shr    $0xc,%eax
c000300a:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:432
	}
	bitmap_set(&mem_pool->pool_bitmap, bit_idx, 0);	// 将位图中该位清0
c000300d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003010:	83 ec 04             	sub    $0x4,%esp
c0003013:	6a 00                	push   $0x0
c0003015:	ff 75 f0             	pushl  -0x10(%ebp)
c0003018:	50                   	push   %eax
c0003019:	e8 32 f5 ff ff       	call   c0002550 <bitmap_set>
c000301e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:433
}
c0003021:	90                   	nop
c0003022:	c9                   	leave  
c0003023:	c3                   	ret    

c0003024 <page_table_pte_remove>:
page_table_pte_remove():
/work/x86_os_my/kernel/memory.c:436

/* 去掉页表中虚拟地址vaddr的映射,只去掉vaddr对应的pte */
static void page_table_pte_remove(uint32_t vaddr) {
c0003024:	55                   	push   %ebp
c0003025:	89 e5                	mov    %esp,%ebp
c0003027:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/kernel/memory.c:437
	uint32_t* pte = pte_ptr(vaddr);
c000302a:	8b 45 08             	mov    0x8(%ebp),%eax
c000302d:	50                   	push   %eax
c000302e:	e8 e4 f6 ff ff       	call   c0002717 <pte_ptr>
c0003033:	83 c4 04             	add    $0x4,%esp
c0003036:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/kernel/memory.c:438
	*pte &= ~PG_P_1;	// 将页表项pte的P位置0
c0003039:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000303c:	8b 00                	mov    (%eax),%eax
c000303e:	83 e0 fe             	and    $0xfffffffe,%eax
c0003041:	89 c2                	mov    %eax,%edx
c0003043:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003046:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/kernel/memory.c:439
	asm volatile ("invlpg %0"::"m" (vaddr):"memory");	//更新tlb
c0003048:	0f 01 7d 08          	invlpg 0x8(%ebp)
/work/x86_os_my/kernel/memory.c:442
	/*更新 TLB 有两种方式，一是用 invlpg 指令更新单条虚拟地址条目，
	另外一个是重新加载 cr3 寄存器，这将直接清空 TLB，相当于更新整个页表。*/
}
c000304c:	90                   	nop
c000304d:	c9                   	leave  
c000304e:	c3                   	ret    

c000304f <vaddr_remove>:
vaddr_remove():
/work/x86_os_my/kernel/memory.c:447

/* 在虚拟地址池中释放以_vaddr起始的连续pg_cnt个虚拟页地址
 * 清理虚拟地址池位图
 */
static void vaddr_remove(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {
c000304f:	55                   	push   %ebp
c0003050:	89 e5                	mov    %esp,%ebp
c0003052:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:448
	uint32_t bit_idx_start = 0, vaddr = (uint32_t)_vaddr, cnt = 0;
c0003055:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c000305c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000305f:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0003062:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:450

	if (pf == PF_KERNEL) {	// 内核虚拟内存池
c0003069:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c000306d:	75 3f                	jne    c00030ae <vaddr_remove+0x5f>
/work/x86_os_my/kernel/memory.c:451
		bit_idx_start = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
c000306f:	a1 50 fb 00 c0       	mov    0xc000fb50,%eax
c0003074:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0003077:	29 c2                	sub    %eax,%edx
c0003079:	89 d0                	mov    %edx,%eax
c000307b:	c1 e8 0c             	shr    $0xc,%eax
c000307e:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:452
		while(cnt < pg_cnt) {
c0003081:	eb 21                	jmp    c00030a4 <vaddr_remove+0x55>
/work/x86_os_my/kernel/memory.c:453
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
c0003083:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003086:	8d 50 01             	lea    0x1(%eax),%edx
c0003089:	89 55 f4             	mov    %edx,-0xc(%ebp)
c000308c:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000308f:	01 d0                	add    %edx,%eax
c0003091:	83 ec 04             	sub    $0x4,%esp
c0003094:	6a 00                	push   $0x0
c0003096:	50                   	push   %eax
c0003097:	68 48 fb 00 c0       	push   $0xc000fb48
c000309c:	e8 af f4 ff ff       	call   c0002550 <bitmap_set>
c00030a1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:452
static void vaddr_remove(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {
	uint32_t bit_idx_start = 0, vaddr = (uint32_t)_vaddr, cnt = 0;

	if (pf == PF_KERNEL) {	// 内核虚拟内存池
		bit_idx_start = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
c00030a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00030a7:	3b 45 10             	cmp    0x10(%ebp),%eax
c00030aa:	72 d7                	jb     c0003083 <vaddr_remove+0x34>
/work/x86_os_my/kernel/memory.c:462
		bit_idx_start = (vaddr - cur_thread->userprog_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
			bitmap_set(&cur_thread->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	}
}
c00030ac:	eb 48                	jmp    c00030f6 <vaddr_remove+0xa7>
/work/x86_os_my/kernel/memory.c:456
		bit_idx_start = (vaddr - kernel_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	} else {	// 用户虚拟内存池
		struct task_struct* cur_thread = running_thread();
c00030ae:	e8 b8 0a 00 00       	call   c0003b6b <running_thread>
c00030b3:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:457
		bit_idx_start = (vaddr - cur_thread->userprog_vaddr.vaddr_start) / PG_SIZE;
c00030b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00030b9:	8b 40 60             	mov    0x60(%eax),%eax
c00030bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00030bf:	29 c2                	sub    %eax,%edx
c00030c1:	89 d0                	mov    %edx,%eax
c00030c3:	c1 e8 0c             	shr    $0xc,%eax
c00030c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:458
		while(cnt < pg_cnt) {
c00030c9:	eb 23                	jmp    c00030ee <vaddr_remove+0x9f>
/work/x86_os_my/kernel/memory.c:459
			bitmap_set(&cur_thread->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
c00030cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00030ce:	8d 50 01             	lea    0x1(%eax),%edx
c00030d1:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00030d4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00030d7:	01 c2                	add    %eax,%edx
c00030d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00030dc:	83 c0 58             	add    $0x58,%eax
c00030df:	83 ec 04             	sub    $0x4,%esp
c00030e2:	6a 00                	push   $0x0
c00030e4:	52                   	push   %edx
c00030e5:	50                   	push   %eax
c00030e6:	e8 65 f4 ff ff       	call   c0002550 <bitmap_set>
c00030eb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:458
			bitmap_set(&kernel_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	} else {	// 用户虚拟内存池
		struct task_struct* cur_thread = running_thread();
		bit_idx_start = (vaddr - cur_thread->userprog_vaddr.vaddr_start) / PG_SIZE;
		while(cnt < pg_cnt) {
c00030ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00030f1:	3b 45 10             	cmp    0x10(%ebp),%eax
c00030f4:	72 d5                	jb     c00030cb <vaddr_remove+0x7c>
/work/x86_os_my/kernel/memory.c:462
			bitmap_set(&cur_thread->userprog_vaddr.vaddr_bitmap, bit_idx_start + cnt++, 0);
		}
	}
}
c00030f6:	90                   	nop
c00030f7:	c9                   	leave  
c00030f8:	c3                   	ret    

c00030f9 <mfree_page>:
mfree_page():
/work/x86_os_my/kernel/memory.c:465

/* 释放以虚拟地址vaddr为起始的cnt个物理页框 */
void mfree_page(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {
c00030f9:	55                   	push   %ebp
c00030fa:	89 e5                	mov    %esp,%ebp
c00030fc:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:467
	uint32_t pg_phy_addr;
	uint32_t vaddr = (int32_t)_vaddr, page_cnt = 0;
c00030ff:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003102:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0003105:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:468
	ASSERT(pg_cnt >=1 && vaddr % PG_SIZE == 0);
c000310c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0003110:	74 0c                	je     c000311e <mfree_page+0x25>
/work/x86_os_my/kernel/memory.c:468 (discriminator 1)
c0003112:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003115:	25 ff 0f 00 00       	and    $0xfff,%eax
c000311a:	85 c0                	test   %eax,%eax
c000311c:	74 1c                	je     c000313a <mfree_page+0x41>
/work/x86_os_my/kernel/memory.c:468 (discriminator 3)
c000311e:	68 b4 b5 00 c0       	push   $0xc000b5b4
c0003123:	68 50 b8 00 c0       	push   $0xc000b850
c0003128:	68 d4 01 00 00       	push   $0x1d4
c000312d:	68 d7 b4 00 c0       	push   $0xc000b4d7
c0003132:	e8 ab f1 ff ff       	call   c00022e2 <panic_spin>
c0003137:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:469
	pg_phy_addr = addr_v2p(vaddr);
c000313a:	83 ec 0c             	sub    $0xc,%esp
c000313d:	ff 75 f4             	pushl  -0xc(%ebp)
c0003140:	e8 f5 fa ff ff       	call   c0002c3a <addr_v2p>
c0003145:	83 c4 10             	add    $0x10,%esp
c0003148:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:472

	/* 确保待释放的物理内存在低端1M+1k大小的页目录+1k大小的页表地址范围外【内核空间】 */
	ASSERT((pg_phy_addr % PG_SIZE) == 0 && pg_phy_addr >= 0x102000);
c000314b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000314e:	25 ff 0f 00 00       	and    $0xfff,%eax
c0003153:	85 c0                	test   %eax,%eax
c0003155:	75 09                	jne    c0003160 <mfree_page+0x67>
/work/x86_os_my/kernel/memory.c:472 (discriminator 1)
c0003157:	81 7d ec ff 1f 10 00 	cmpl   $0x101fff,-0x14(%ebp)
c000315e:	77 1c                	ja     c000317c <mfree_page+0x83>
/work/x86_os_my/kernel/memory.c:472 (discriminator 3)
c0003160:	68 d8 b5 00 c0       	push   $0xc000b5d8
c0003165:	68 50 b8 00 c0       	push   $0xc000b850
c000316a:	68 d8 01 00 00       	push   $0x1d8
c000316f:	68 d7 b4 00 c0       	push   $0xc000b4d7
c0003174:	e8 69 f1 ff ff       	call   c00022e2 <panic_spin>
c0003179:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:476

	/* 判断pg_phy_addr属于用户物理内存池还是内核物理内存池 */
	/* 位于user_pool内存池 */
	if (pg_phy_addr >= user_pool.phy_addr_start) {
c000317c:	a1 68 fa 00 c0       	mov    0xc000fa68,%eax
c0003181:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0003184:	0f 87 94 00 00 00    	ja     c000321e <mfree_page+0x125>
/work/x86_os_my/kernel/memory.c:477
		vaddr -= PG_SIZE;
c000318a:	81 6d f4 00 10 00 00 	subl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:478
		while (page_cnt < pg_cnt) {
c0003191:	eb 6a                	jmp    c00031fd <mfree_page+0x104>
/work/x86_os_my/kernel/memory.c:479
			vaddr += PG_SIZE;
c0003193:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:480
			pg_phy_addr = addr_v2p(vaddr);
c000319a:	83 ec 0c             	sub    $0xc,%esp
c000319d:	ff 75 f4             	pushl  -0xc(%ebp)
c00031a0:	e8 95 fa ff ff       	call   c0002c3a <addr_v2p>
c00031a5:	83 c4 10             	add    $0x10,%esp
c00031a8:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:483

			/* 确保物理地址属于用户物理内存池 */
			ASSERT((pg_phy_addr % PG_SIZE) == 0 && pg_phy_addr >= user_pool.phy_addr_start);
c00031ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00031ae:	25 ff 0f 00 00       	and    $0xfff,%eax
c00031b3:	85 c0                	test   %eax,%eax
c00031b5:	75 0a                	jne    c00031c1 <mfree_page+0xc8>
/work/x86_os_my/kernel/memory.c:483 (discriminator 1)
c00031b7:	a1 68 fa 00 c0       	mov    0xc000fa68,%eax
c00031bc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00031bf:	76 1c                	jbe    c00031dd <mfree_page+0xe4>
/work/x86_os_my/kernel/memory.c:483 (discriminator 3)
c00031c1:	68 10 b6 00 c0       	push   $0xc000b610
c00031c6:	68 50 b8 00 c0       	push   $0xc000b850
c00031cb:	68 e3 01 00 00       	push   $0x1e3
c00031d0:	68 d7 b4 00 c0       	push   $0xc000b4d7
c00031d5:	e8 08 f1 ff ff       	call   c00022e2 <panic_spin>
c00031da:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:486

			/* 先将对应的物理页框归还到内存池 */
			pfree(pg_phy_addr);
c00031dd:	83 ec 0c             	sub    $0xc,%esp
c00031e0:	ff 75 ec             	pushl  -0x14(%ebp)
c00031e3:	e8 da fd ff ff       	call   c0002fc2 <pfree>
c00031e8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:489

			/* 再从页表中清除此虚拟地址所在的页表项pte */
			page_table_pte_remove(vaddr);
c00031eb:	83 ec 0c             	sub    $0xc,%esp
c00031ee:	ff 75 f4             	pushl  -0xc(%ebp)
c00031f1:	e8 2e fe ff ff       	call   c0003024 <page_table_pte_remove>
c00031f6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:491

			page_cnt++;
c00031f9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:478

	/* 判断pg_phy_addr属于用户物理内存池还是内核物理内存池 */
	/* 位于user_pool内存池 */
	if (pg_phy_addr >= user_pool.phy_addr_start) {
		vaddr -= PG_SIZE;
		while (page_cnt < pg_cnt) {
c00031fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003200:	3b 45 10             	cmp    0x10(%ebp),%eax
c0003203:	72 8e                	jb     c0003193 <mfree_page+0x9a>
/work/x86_os_my/kernel/memory.c:494
			page_table_pte_remove(vaddr);

			page_cnt++;
		}
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);
c0003205:	83 ec 04             	sub    $0x4,%esp
c0003208:	ff 75 10             	pushl  0x10(%ebp)
c000320b:	ff 75 0c             	pushl  0xc(%ebp)
c000320e:	ff 75 08             	pushl  0x8(%ebp)
c0003211:	e8 39 fe ff ff       	call   c000304f <vaddr_remove>
c0003216:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:518
			page_cnt++;
		}
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);
	}
}
c0003219:	e9 99 00 00 00       	jmp    c00032b7 <mfree_page+0x1be>
/work/x86_os_my/kernel/memory.c:498
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);

	} else {
		/* 位于kernel_pool内存池 */
		vaddr -= PG_SIZE;
c000321e:	81 6d f4 00 10 00 00 	subl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:499
		while (page_cnt < pg_cnt) {
c0003225:	eb 74                	jmp    c000329b <mfree_page+0x1a2>
/work/x86_os_my/kernel/memory.c:500
			vaddr += PG_SIZE;
c0003227:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:501
			pg_phy_addr = addr_v2p(vaddr);
c000322e:	83 ec 0c             	sub    $0xc,%esp
c0003231:	ff 75 f4             	pushl  -0xc(%ebp)
c0003234:	e8 01 fa ff ff       	call   c0002c3a <addr_v2p>
c0003239:	83 c4 10             	add    $0x10,%esp
c000323c:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:504

			/* 确保待释放的物理内存只属于内核物理内存池 */
			ASSERT((pg_phy_addr % PG_SIZE) == 0 && pg_phy_addr >= kernel_pool.phy_addr_start && \
c000323f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0003242:	25 ff 0f 00 00       	and    $0xfff,%eax
c0003247:	85 c0                	test   %eax,%eax
c0003249:	75 14                	jne    c000325f <mfree_page+0x166>
/work/x86_os_my/kernel/memory.c:504 (discriminator 1)
c000324b:	a1 68 fb 00 c0       	mov    0xc000fb68,%eax
c0003250:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0003253:	77 0a                	ja     c000325f <mfree_page+0x166>
/work/x86_os_my/kernel/memory.c:504 (discriminator 3)
c0003255:	a1 68 fa 00 c0       	mov    0xc000fa68,%eax
c000325a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c000325d:	77 1c                	ja     c000327b <mfree_page+0x182>
/work/x86_os_my/kernel/memory.c:504 (discriminator 5)
c000325f:	68 58 b6 00 c0       	push   $0xc000b658
c0003264:	68 50 b8 00 c0       	push   $0xc000b850
c0003269:	68 f9 01 00 00       	push   $0x1f9
c000326e:	68 d7 b4 00 c0       	push   $0xc000b4d7
c0003273:	e8 6a f0 ff ff       	call   c00022e2 <panic_spin>
c0003278:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:508
					pg_phy_addr < user_pool.phy_addr_start);

			/* 先将对应的物理页框归还到内存池 */
			pfree(pg_phy_addr);
c000327b:	83 ec 0c             	sub    $0xc,%esp
c000327e:	ff 75 ec             	pushl  -0x14(%ebp)
c0003281:	e8 3c fd ff ff       	call   c0002fc2 <pfree>
c0003286:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:511

			/* 再从页表中清除此虚拟地址所在的页表项pte */
			page_table_pte_remove(vaddr);
c0003289:	83 ec 0c             	sub    $0xc,%esp
c000328c:	ff 75 f4             	pushl  -0xc(%ebp)
c000328f:	e8 90 fd ff ff       	call   c0003024 <page_table_pte_remove>
c0003294:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:513

			page_cnt++;
c0003297:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:499
		vaddr_remove(pf, _vaddr, pg_cnt);

	} else {
		/* 位于kernel_pool内存池 */
		vaddr -= PG_SIZE;
		while (page_cnt < pg_cnt) {
c000329b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000329e:	3b 45 10             	cmp    0x10(%ebp),%eax
c00032a1:	72 84                	jb     c0003227 <mfree_page+0x12e>
/work/x86_os_my/kernel/memory.c:516
			page_table_pte_remove(vaddr);

			page_cnt++;
		}
		/* 清空虚拟地址的位图中的相应位 */
		vaddr_remove(pf, _vaddr, pg_cnt);
c00032a3:	83 ec 04             	sub    $0x4,%esp
c00032a6:	ff 75 10             	pushl  0x10(%ebp)
c00032a9:	ff 75 0c             	pushl  0xc(%ebp)
c00032ac:	ff 75 08             	pushl  0x8(%ebp)
c00032af:	e8 9b fd ff ff       	call   c000304f <vaddr_remove>
c00032b4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:518
	}
}
c00032b7:	90                   	nop
c00032b8:	c9                   	leave  
c00032b9:	c3                   	ret    

c00032ba <sys_free>:
sys_free():
/work/x86_os_my/kernel/memory.c:521

/* 回收内存ptr */
void sys_free(void* ptr) {
c00032ba:	55                   	push   %ebp
c00032bb:	89 e5                	mov    %esp,%ebp
c00032bd:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/kernel/memory.c:522
	ASSERT(ptr != NULL);
c00032c0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00032c4:	75 1c                	jne    c00032e2 <sys_free+0x28>
/work/x86_os_my/kernel/memory.c:522 (discriminator 1)
c00032c6:	68 cc b6 00 c0       	push   $0xc000b6cc
c00032cb:	68 5c b8 00 c0       	push   $0xc000b85c
c00032d0:	68 0a 02 00 00       	push   $0x20a
c00032d5:	68 d7 b4 00 c0       	push   $0xc000b4d7
c00032da:	e8 03 f0 ff ff       	call   c00022e2 <panic_spin>
c00032df:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:523
	if (ptr != NULL) {
c00032e2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00032e6:	0f 84 b2 01 00 00    	je     c000349e <sys_free+0x1e4>
/work/x86_os_my/kernel/memory.c:528
		enum pool_flags PF;
		struct pool* mem_pool;

		/* 判断是线程还是进程 */
		if (running_thread()->pgdir == NULL) {
c00032ec:	e8 7a 08 00 00       	call   c0003b6b <running_thread>
c00032f1:	8b 40 54             	mov    0x54(%eax),%eax
c00032f4:	85 c0                	test   %eax,%eax
c00032f6:	75 36                	jne    c000332e <sys_free+0x74>
/work/x86_os_my/kernel/memory.c:529
			ASSERT((uint32_t)ptr >= K_HEAP_START);
c00032f8:	8b 45 08             	mov    0x8(%ebp),%eax
c00032fb:	3d ff ff 0f c0       	cmp    $0xc00fffff,%eax
c0003300:	77 1c                	ja     c000331e <sys_free+0x64>
/work/x86_os_my/kernel/memory.c:529 (discriminator 1)
c0003302:	68 d8 b6 00 c0       	push   $0xc000b6d8
c0003307:	68 5c b8 00 c0       	push   $0xc000b85c
c000330c:	68 11 02 00 00       	push   $0x211
c0003311:	68 d7 b4 00 c0       	push   $0xc000b4d7
c0003316:	e8 c7 ef ff ff       	call   c00022e2 <panic_spin>
c000331b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:530
			PF = PF_KERNEL;
c000331e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:531
			mem_pool = &kernel_pool;
c0003325:	c7 45 f0 60 fb 00 c0 	movl   $0xc000fb60,-0x10(%ebp)
c000332c:	eb 0e                	jmp    c000333c <sys_free+0x82>
/work/x86_os_my/kernel/memory.c:533
		} else {
			PF = PF_USER;
c000332e:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:534
			mem_pool = &user_pool;
c0003335:	c7 45 f0 60 fa 00 c0 	movl   $0xc000fa60,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:537
		}

		lock_acquire(&mem_pool->lock);
c000333c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000333f:	83 c0 10             	add    $0x10,%eax
c0003342:	83 ec 0c             	sub    $0xc,%esp
c0003345:	50                   	push   %eax
c0003346:	e8 f4 13 00 00       	call   c000473f <lock_acquire>
c000334b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:538
		struct mem_block* b = ptr;
c000334e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003351:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:539
		struct arena* a = block2arena(b);			// 把mem_block转换成arena,获取元信息
c0003354:	83 ec 0c             	sub    $0xc,%esp
c0003357:	ff 75 e8             	pushl  -0x18(%ebp)
c000335a:	e8 21 f9 ff ff       	call   c0002c80 <block2arena>
c000335f:	83 c4 10             	add    $0x10,%esp
c0003362:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/kernel/memory.c:540
		ASSERT(a->large == 0 || a->large == 1);
c0003365:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003368:	8b 40 08             	mov    0x8(%eax),%eax
c000336b:	85 c0                	test   %eax,%eax
c000336d:	74 27                	je     c0003396 <sys_free+0xdc>
/work/x86_os_my/kernel/memory.c:540 (discriminator 1)
c000336f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003372:	8b 40 08             	mov    0x8(%eax),%eax
c0003375:	83 f8 01             	cmp    $0x1,%eax
c0003378:	74 1c                	je     c0003396 <sys_free+0xdc>
/work/x86_os_my/kernel/memory.c:540 (discriminator 2)
c000337a:	68 f8 b6 00 c0       	push   $0xc000b6f8
c000337f:	68 5c b8 00 c0       	push   $0xc000b85c
c0003384:	68 1c 02 00 00       	push   $0x21c
c0003389:	68 d7 b4 00 c0       	push   $0xc000b4d7
c000338e:	e8 4f ef ff ff       	call   c00022e2 <panic_spin>
c0003393:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:541
		if (a->desc == NULL && a->large == true) {	// 大于1024的内存
c0003396:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0003399:	8b 00                	mov    (%eax),%eax
c000339b:	85 c0                	test   %eax,%eax
c000339d:	75 28                	jne    c00033c7 <sys_free+0x10d>
/work/x86_os_my/kernel/memory.c:541 (discriminator 1)
c000339f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00033a2:	8b 40 08             	mov    0x8(%eax),%eax
c00033a5:	83 f8 01             	cmp    $0x1,%eax
c00033a8:	75 1d                	jne    c00033c7 <sys_free+0x10d>
/work/x86_os_my/kernel/memory.c:542
			mfree_page(PF, a, a->cnt);
c00033aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00033ad:	8b 40 04             	mov    0x4(%eax),%eax
c00033b0:	83 ec 04             	sub    $0x4,%esp
c00033b3:	50                   	push   %eax
c00033b4:	ff 75 e4             	pushl  -0x1c(%ebp)
c00033b7:	ff 75 f4             	pushl  -0xc(%ebp)
c00033ba:	e8 3a fd ff ff       	call   c00030f9 <mfree_page>
c00033bf:	83 c4 10             	add    $0x10,%esp
c00033c2:	e9 c5 00 00 00       	jmp    c000348c <sys_free+0x1d2>
/work/x86_os_my/kernel/memory.c:546
		} else {									// 小于等于1024的内存块
			/* 先将内存块回收到free_list */
			// &b->free_elem == &b
			list_append(&a->desc->free_list, &b->free_elem);
c00033c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00033ca:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00033cd:	8b 12                	mov    (%edx),%edx
c00033cf:	83 c2 08             	add    $0x8,%edx
c00033d2:	83 ec 08             	sub    $0x8,%esp
c00033d5:	50                   	push   %eax
c00033d6:	52                   	push   %edx
c00033d7:	e8 32 0f 00 00       	call   c000430e <list_append>
c00033dc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:549

			/* 再判断此arena中的内存块是否都是空闲,如果是就释放arena */
			if (++a->cnt == a->desc->blocks_per_arena) {
c00033df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00033e2:	8b 40 04             	mov    0x4(%eax),%eax
c00033e5:	8d 50 01             	lea    0x1(%eax),%edx
c00033e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00033eb:	89 50 04             	mov    %edx,0x4(%eax)
c00033ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00033f1:	8b 50 04             	mov    0x4(%eax),%edx
c00033f4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00033f7:	8b 00                	mov    (%eax),%eax
c00033f9:	8b 40 04             	mov    0x4(%eax),%eax
c00033fc:	39 c2                	cmp    %eax,%edx
c00033fe:	0f 85 88 00 00 00    	jne    c000348c <sys_free+0x1d2>
/work/x86_os_my/kernel/memory.c:551
				uint32_t block_idx;
				for (block_idx = 0; block_idx < a->desc->blocks_per_arena; block_idx++) {
c0003404:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c000340b:	eb 5f                	jmp    c000346c <sys_free+0x1b2>
/work/x86_os_my/kernel/memory.c:552
					struct mem_block*  b = arena2block(a, block_idx);
c000340d:	83 ec 08             	sub    $0x8,%esp
c0003410:	ff 75 ec             	pushl  -0x14(%ebp)
c0003413:	ff 75 e4             	pushl  -0x1c(%ebp)
c0003416:	e8 4b f8 ff ff       	call   c0002c66 <arena2block>
c000341b:	83 c4 10             	add    $0x10,%esp
c000341e:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/kernel/memory.c:553
					ASSERT(elem_find(&a->desc->free_list, &b->free_elem));
c0003421:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0003424:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0003427:	8b 12                	mov    (%edx),%edx
c0003429:	83 c2 08             	add    $0x8,%edx
c000342c:	83 ec 08             	sub    $0x8,%esp
c000342f:	50                   	push   %eax
c0003430:	52                   	push   %edx
c0003431:	e8 52 0f 00 00       	call   c0004388 <elem_find>
c0003436:	83 c4 10             	add    $0x10,%esp
c0003439:	85 c0                	test   %eax,%eax
c000343b:	75 1c                	jne    c0003459 <sys_free+0x19f>
/work/x86_os_my/kernel/memory.c:553 (discriminator 1)
c000343d:	68 18 b7 00 c0       	push   $0xc000b718
c0003442:	68 5c b8 00 c0       	push   $0xc000b85c
c0003447:	68 29 02 00 00       	push   $0x229
c000344c:	68 d7 b4 00 c0       	push   $0xc000b4d7
c0003451:	e8 8c ee ff ff       	call   c00022e2 <panic_spin>
c0003456:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:554 (discriminator 2)
					list_remove(&b->free_elem);
c0003459:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000345c:	83 ec 0c             	sub    $0xc,%esp
c000345f:	50                   	push   %eax
c0003460:	e8 c7 0e 00 00       	call   c000432c <list_remove>
c0003465:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:551 (discriminator 2)
			list_append(&a->desc->free_list, &b->free_elem);

			/* 再判断此arena中的内存块是否都是空闲,如果是就释放arena */
			if (++a->cnt == a->desc->blocks_per_arena) {
				uint32_t block_idx;
				for (block_idx = 0; block_idx < a->desc->blocks_per_arena; block_idx++) {
c0003468:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:551 (discriminator 1)
c000346c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000346f:	8b 00                	mov    (%eax),%eax
c0003471:	8b 40 04             	mov    0x4(%eax),%eax
c0003474:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0003477:	77 94                	ja     c000340d <sys_free+0x153>
/work/x86_os_my/kernel/memory.c:556
					struct mem_block*  b = arena2block(a, block_idx);
					ASSERT(elem_find(&a->desc->free_list, &b->free_elem));
					list_remove(&b->free_elem);
				}
				mfree_page(PF, a, 1);
c0003479:	83 ec 04             	sub    $0x4,%esp
c000347c:	6a 01                	push   $0x1
c000347e:	ff 75 e4             	pushl  -0x1c(%ebp)
c0003481:	ff 75 f4             	pushl  -0xc(%ebp)
c0003484:	e8 70 fc ff ff       	call   c00030f9 <mfree_page>
c0003489:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:559
			}
		}
		lock_release(&mem_pool->lock);
c000348c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000348f:	83 c0 10             	add    $0x10,%eax
c0003492:	83 ec 0c             	sub    $0xc,%esp
c0003495:	50                   	push   %eax
c0003496:	e8 1b 13 00 00       	call   c00047b6 <lock_release>
c000349b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:561
	}
}
c000349e:	90                   	nop
c000349f:	c9                   	leave  
c00034a0:	c3                   	ret    

c00034a1 <mem_pool_init>:
mem_pool_init():
/work/x86_os_my/kernel/memory.c:564

/* 初始化内存池 */
static void mem_pool_init(uint32_t all_mem) {
c00034a1:	55                   	push   %ebp
c00034a2:	89 e5                	mov    %esp,%ebp
c00034a4:	83 ec 38             	sub    $0x38,%esp
/work/x86_os_my/kernel/memory.c:565
	put_str("   mem_pool_init start\n");
c00034a7:	83 ec 0c             	sub    $0xc,%esp
c00034aa:	68 46 b7 00 c0       	push   $0xc000b746
c00034af:	e8 bc ec ff ff       	call   c0002170 <put_str>
c00034b4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:566
	uint32_t page_table_size = PG_SIZE * 256;		// 页表大小= 1页的页目录表+第0和第768个页目录项指向同一个页表+
c00034b7:	c7 45 f4 00 00 10 00 	movl   $0x100000,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:568
													// 第769~1022个页目录项共指向254个页表,共256个页框
	uint32_t used_mem = page_table_size + 0x100000;	// 0x100000为低端1M内存
c00034be:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00034c1:	05 00 00 10 00       	add    $0x100000,%eax
c00034c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/kernel/memory.c:569
	uint32_t free_mem = all_mem - used_mem;
c00034c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00034cc:	2b 45 f0             	sub    -0x10(%ebp),%eax
c00034cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/kernel/memory.c:570
	uint16_t all_free_pages = free_mem / PG_SIZE;	// 1页为4k,不管总内存是不是4k的倍数,
c00034d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00034d5:	c1 e8 0c             	shr    $0xc,%eax
c00034d8:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
/work/x86_os_my/kernel/memory.c:572
													// 对于以页为单位的内存分配策略，不足1页的内存不用考虑了。
	uint16_t kernel_free_pages = all_free_pages / 2;
c00034dc:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c00034e0:	66 d1 e8             	shr    %ax
c00034e3:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
/work/x86_os_my/kernel/memory.c:573
	uint16_t user_free_pages = all_free_pages - kernel_free_pages;
c00034e7:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
c00034eb:	66 2b 45 e8          	sub    -0x18(%ebp),%ax
c00034ef:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
/work/x86_os_my/kernel/memory.c:577

	/* 为简化位图操作，余数不处理，坏处是这样做会丢内存。
	好处是不用做内存的越界检查,因为位图表示的内存少于实际物理内存*/
	uint32_t kbm_length = kernel_free_pages / 8;	// Kernel BitMap的长度,位图中的一位表示一页,以字节为单位
c00034f3:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c00034f7:	66 c1 e8 03          	shr    $0x3,%ax
c00034fb:	0f b7 c0             	movzwl %ax,%eax
c00034fe:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/kernel/memory.c:578
	uint32_t ubm_length = user_free_pages / 8;		// User BitMap的长度.
c0003501:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c0003505:	66 c1 e8 03          	shr    $0x3,%ax
c0003509:	0f b7 c0             	movzwl %ax,%eax
c000350c:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/kernel/memory.c:580

	uint32_t kp_start = used_mem;								// Kernel Pool start,内核内存池的起始地址
c000350f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003512:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/kernel/memory.c:581
	uint32_t up_start = kp_start + kernel_free_pages * PG_SIZE;	// User Pool start,用户内存池的起始地址
c0003515:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c0003519:	c1 e0 0c             	shl    $0xc,%eax
c000351c:	89 c2                	mov    %eax,%edx
c000351e:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0003521:	01 d0                	add    %edx,%eax
c0003523:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/kernel/memory.c:583

	kernel_pool.phy_addr_start = kp_start;
c0003526:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0003529:	a3 68 fb 00 c0       	mov    %eax,0xc000fb68
/work/x86_os_my/kernel/memory.c:584
	user_pool.phy_addr_start   = up_start;
c000352e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0003531:	a3 68 fa 00 c0       	mov    %eax,0xc000fa68
/work/x86_os_my/kernel/memory.c:586

	kernel_pool.pool_size = kernel_free_pages * PG_SIZE;
c0003536:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
c000353a:	c1 e0 0c             	shl    $0xc,%eax
c000353d:	a3 6c fb 00 c0       	mov    %eax,0xc000fb6c
/work/x86_os_my/kernel/memory.c:587
	user_pool.pool_size	 = user_free_pages * PG_SIZE;
c0003542:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
c0003546:	c1 e0 0c             	shl    $0xc,%eax
c0003549:	a3 6c fa 00 c0       	mov    %eax,0xc000fa6c
/work/x86_os_my/kernel/memory.c:589

	kernel_pool.pool_bitmap.btmp_bytes_len = kbm_length;
c000354e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0003551:	a3 60 fb 00 c0       	mov    %eax,0xc000fb60
/work/x86_os_my/kernel/memory.c:590
	user_pool.pool_bitmap.btmp_bytes_len	  = ubm_length;
c0003556:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0003559:	a3 60 fa 00 c0       	mov    %eax,0xc000fa60
/work/x86_os_my/kernel/memory.c:599
	*	而我们需要根据总内存大小在运行时，计算出位图的数组需要多少字节。
	*   所以改为指定一块内存来生成位图.
	*   ************************************************/
	// 内核使用的最高地址是0xc009f000,这是主线程的栈地址.(内核的大小预计为70K左右)
	// 32M内存占用的位图是2k.内核内存池的位图先定在MEM_BITMAP_BASE(0xc009a000)处.
	kernel_pool.pool_bitmap.bits = (void*)MEM_BITMAP_BASE;
c000355e:	c7 05 64 fb 00 c0 00 	movl   $0xc009a000,0xc000fb64
c0003565:	a0 09 c0 
/work/x86_os_my/kernel/memory.c:601
	/* 用户内存池的位图紧跟在内核内存池位图之后 */
	user_pool.pool_bitmap.bits = (void*)(MEM_BITMAP_BASE + kbm_length);
c0003568:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000356b:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c0003570:	a3 64 fa 00 c0       	mov    %eax,0xc000fa64
/work/x86_os_my/kernel/memory.c:604
	
	/******************** 输出内存池信息 **********************/
	put_str("      kernel_pool_bitmap_start:");put_int((int)kernel_pool.pool_bitmap.bits);
c0003575:	83 ec 0c             	sub    $0xc,%esp
c0003578:	68 60 b7 00 c0       	push   $0xc000b760
c000357d:	e8 ee eb ff ff       	call   c0002170 <put_str>
c0003582:	83 c4 10             	add    $0x10,%esp
c0003585:	a1 64 fb 00 c0       	mov    0xc000fb64,%eax
c000358a:	83 ec 0c             	sub    $0xc,%esp
c000358d:	50                   	push   %eax
c000358e:	e8 c8 ec ff ff       	call   c000225b <put_int>
c0003593:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:605
	put_str(" kernel_pool_phy_addr_start:");put_int(kernel_pool.phy_addr_start);
c0003596:	83 ec 0c             	sub    $0xc,%esp
c0003599:	68 80 b7 00 c0       	push   $0xc000b780
c000359e:	e8 cd eb ff ff       	call   c0002170 <put_str>
c00035a3:	83 c4 10             	add    $0x10,%esp
c00035a6:	a1 68 fb 00 c0       	mov    0xc000fb68,%eax
c00035ab:	83 ec 0c             	sub    $0xc,%esp
c00035ae:	50                   	push   %eax
c00035af:	e8 a7 ec ff ff       	call   c000225b <put_int>
c00035b4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:606
	put_str("\n");
c00035b7:	83 ec 0c             	sub    $0xc,%esp
c00035ba:	68 9d b7 00 c0       	push   $0xc000b79d
c00035bf:	e8 ac eb ff ff       	call   c0002170 <put_str>
c00035c4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:607
	put_str("      user_pool_bitmap_start:");put_int((int)user_pool.pool_bitmap.bits);
c00035c7:	83 ec 0c             	sub    $0xc,%esp
c00035ca:	68 9f b7 00 c0       	push   $0xc000b79f
c00035cf:	e8 9c eb ff ff       	call   c0002170 <put_str>
c00035d4:	83 c4 10             	add    $0x10,%esp
c00035d7:	a1 64 fa 00 c0       	mov    0xc000fa64,%eax
c00035dc:	83 ec 0c             	sub    $0xc,%esp
c00035df:	50                   	push   %eax
c00035e0:	e8 76 ec ff ff       	call   c000225b <put_int>
c00035e5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:608
	put_str(" user_pool_phy_addr_start:");put_int(user_pool.phy_addr_start);
c00035e8:	83 ec 0c             	sub    $0xc,%esp
c00035eb:	68 bd b7 00 c0       	push   $0xc000b7bd
c00035f0:	e8 7b eb ff ff       	call   c0002170 <put_str>
c00035f5:	83 c4 10             	add    $0x10,%esp
c00035f8:	a1 68 fa 00 c0       	mov    0xc000fa68,%eax
c00035fd:	83 ec 0c             	sub    $0xc,%esp
c0003600:	50                   	push   %eax
c0003601:	e8 55 ec ff ff       	call   c000225b <put_int>
c0003606:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:609
	put_str("\n");
c0003609:	83 ec 0c             	sub    $0xc,%esp
c000360c:	68 9d b7 00 c0       	push   $0xc000b79d
c0003611:	e8 5a eb ff ff       	call   c0002170 <put_str>
c0003616:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:612

	/* 将位图置0*/
	bitmap_init(&kernel_pool.pool_bitmap);
c0003619:	83 ec 0c             	sub    $0xc,%esp
c000361c:	68 60 fb 00 c0       	push   $0xc000fb60
c0003621:	e8 92 ed ff ff       	call   c00023b8 <bitmap_init>
c0003626:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:613
	bitmap_init(&user_pool.pool_bitmap);
c0003629:	83 ec 0c             	sub    $0xc,%esp
c000362c:	68 60 fa 00 c0       	push   $0xc000fa60
c0003631:	e8 82 ed ff ff       	call   c00023b8 <bitmap_init>
c0003636:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:615

	lock_init(&kernel_pool.lock);
c0003639:	83 ec 0c             	sub    $0xc,%esp
c000363c:	68 70 fb 00 c0       	push   $0xc000fb70
c0003641:	e8 1f 0f 00 00       	call   c0004565 <lock_init>
c0003646:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:616
	lock_init(&user_pool.lock);
c0003649:	83 ec 0c             	sub    $0xc,%esp
c000364c:	68 70 fa 00 c0       	push   $0xc000fa70
c0003651:	e8 0f 0f 00 00       	call   c0004565 <lock_init>
c0003656:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:620
	
	/* 下面初始化内核虚拟地址的位图(bp_len + bits数组),按实际物理内存大小生成数组。*/
	// 用于维护内核堆的虚拟地址,所以要和内核内存池大小一致
	kernel_vaddr.vaddr_bitmap.btmp_bytes_len = kbm_length;
c0003659:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000365c:	a3 48 fb 00 c0       	mov    %eax,0xc000fb48
/work/x86_os_my/kernel/memory.c:622
	/* 位图的数组指向一块未使用的内存,目前定位在内核内存池和用户内存池之外*/
	kernel_vaddr.vaddr_bitmap.bits = (void*)(MEM_BITMAP_BASE + kbm_length + ubm_length);
c0003661:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0003664:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0003667:	01 d0                	add    %edx,%eax
c0003669:	2d 00 60 f6 3f       	sub    $0x3ff66000,%eax
c000366e:	a3 4c fb 00 c0       	mov    %eax,0xc000fb4c
/work/x86_os_my/kernel/memory.c:624

	kernel_vaddr.vaddr_start = K_HEAP_START;
c0003673:	c7 05 50 fb 00 c0 00 	movl   $0xc0100000,0xc000fb50
c000367a:	00 10 c0 
/work/x86_os_my/kernel/memory.c:625
	bitmap_init(&kernel_vaddr.vaddr_bitmap);
c000367d:	83 ec 0c             	sub    $0xc,%esp
c0003680:	68 48 fb 00 c0       	push   $0xc000fb48
c0003685:	e8 2e ed ff ff       	call   c00023b8 <bitmap_init>
c000368a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:626
	put_str("   mem_pool_init done\n");
c000368d:	83 ec 0c             	sub    $0xc,%esp
c0003690:	68 d8 b7 00 c0       	push   $0xc000b7d8
c0003695:	e8 d6 ea ff ff       	call   c0002170 <put_str>
c000369a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:627
}
c000369d:	90                   	nop
c000369e:	c9                   	leave  
c000369f:	c3                   	ret    

c00036a0 <block_desc_init>:
block_desc_init():
/work/x86_os_my/kernel/memory.c:630

/* 为malloc做准备 */
void block_desc_init(struct mem_block_desc* desc_array) {
c00036a0:	55                   	push   %ebp
c00036a1:	89 e5                	mov    %esp,%ebp
c00036a3:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:631
   uint16_t desc_idx, block_size = 16;
c00036a6:	66 c7 45 f4 10 00    	movw   $0x10,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:634

   /* 初始化每个mem_block_desc描述符 */
   for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c00036ac:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
c00036b2:	eb 75                	jmp    c0003729 <block_desc_init+0x89>
/work/x86_os_my/kernel/memory.c:635 (discriminator 3)
      desc_array[desc_idx].block_size = block_size;
c00036b4:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c00036b8:	89 d0                	mov    %edx,%eax
c00036ba:	01 c0                	add    %eax,%eax
c00036bc:	01 d0                	add    %edx,%eax
c00036be:	c1 e0 03             	shl    $0x3,%eax
c00036c1:	89 c2                	mov    %eax,%edx
c00036c3:	8b 45 08             	mov    0x8(%ebp),%eax
c00036c6:	01 c2                	add    %eax,%edx
c00036c8:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
c00036cc:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/kernel/memory.c:638 (discriminator 3)

      /* 初始化arena中的内存块数量【注意计算方法】 */
      desc_array[desc_idx].blocks_per_arena = (PG_SIZE - sizeof(struct arena)) / block_size;
c00036ce:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c00036d2:	89 d0                	mov    %edx,%eax
c00036d4:	01 c0                	add    %eax,%eax
c00036d6:	01 d0                	add    %edx,%eax
c00036d8:	c1 e0 03             	shl    $0x3,%eax
c00036db:	89 c2                	mov    %eax,%edx
c00036dd:	8b 45 08             	mov    0x8(%ebp),%eax
c00036e0:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c00036e3:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c00036e8:	ba 00 00 00 00       	mov    $0x0,%edx
c00036ed:	66 f7 75 f4          	divw   -0xc(%ebp)
c00036f1:	0f b7 c0             	movzwl %ax,%eax
c00036f4:	89 41 04             	mov    %eax,0x4(%ecx)
/work/x86_os_my/kernel/memory.c:640 (discriminator 3)

      list_init(&desc_array[desc_idx].free_list);
c00036f7:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
c00036fb:	89 d0                	mov    %edx,%eax
c00036fd:	01 c0                	add    %eax,%eax
c00036ff:	01 d0                	add    %edx,%eax
c0003701:	c1 e0 03             	shl    $0x3,%eax
c0003704:	89 c2                	mov    %eax,%edx
c0003706:	8b 45 08             	mov    0x8(%ebp),%eax
c0003709:	01 d0                	add    %edx,%eax
c000370b:	83 c0 08             	add    $0x8,%eax
c000370e:	83 ec 0c             	sub    $0xc,%esp
c0003711:	50                   	push   %eax
c0003712:	e8 66 0b 00 00       	call   c000427d <list_init>
c0003717:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:642 (discriminator 3)

      block_size *= 2;		// 下一个规格内存块！
c000371a:	66 d1 65 f4          	shlw   -0xc(%ebp)
/work/x86_os_my/kernel/memory.c:634 (discriminator 3)
/* 为malloc做准备 */
void block_desc_init(struct mem_block_desc* desc_array) {
   uint16_t desc_idx, block_size = 16;

   /* 初始化每个mem_block_desc描述符 */
   for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {
c000371e:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0003722:	83 c0 01             	add    $0x1,%eax
c0003725:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/kernel/memory.c:634 (discriminator 1)
c0003729:	66 83 7d f6 06       	cmpw   $0x6,-0xa(%ebp)
c000372e:	76 84                	jbe    c00036b4 <block_desc_init+0x14>
/work/x86_os_my/kernel/memory.c:645
      list_init(&desc_array[desc_idx].free_list);

      block_size *= 2;		// 下一个规格内存块！
	  // 16/32/64/128/256/512/1024 总共 7 种规格
   }
}
c0003730:	90                   	nop
c0003731:	c9                   	leave  
c0003732:	c3                   	ret    

c0003733 <mem_init>:
mem_init():
/work/x86_os_my/kernel/memory.c:648

/* 内存管理部分初始化入口 */
void mem_init() {
c0003733:	55                   	push   %ebp
c0003734:	89 e5                	mov    %esp,%ebp
c0003736:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/kernel/memory.c:649
	put_str("mem_init start\n");
c0003739:	83 ec 0c             	sub    $0xc,%esp
c000373c:	68 ef b7 00 c0       	push   $0xc000b7ef
c0003741:	e8 2a ea ff ff       	call   c0002170 <put_str>
c0003746:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:650
	uint32_t mem_bytes_total = (*(uint32_t*)(0xb00));	//内存总数在汇编中获取，放到了地址0xb00处。
c0003749:	b8 00 0b 00 00       	mov    $0xb00,%eax
c000374e:	8b 00                	mov    (%eax),%eax
c0003750:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/kernel/memory.c:651
	mem_pool_init(mem_bytes_total);	// 初始化内存池
c0003753:	83 ec 0c             	sub    $0xc,%esp
c0003756:	ff 75 f4             	pushl  -0xc(%ebp)
c0003759:	e8 43 fd ff ff       	call   c00034a1 <mem_pool_init>
c000375e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:652
	block_desc_init(k_block_descs);	// 初始化mem_block_desc数组descs,为malloc做准备
c0003761:	83 ec 0c             	sub    $0xc,%esp
c0003764:	68 a0 fa 00 c0       	push   $0xc000faa0
c0003769:	e8 32 ff ff ff       	call   c00036a0 <block_desc_init>
c000376e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:653
	put_str("mem_init done\n");
c0003771:	83 ec 0c             	sub    $0xc,%esp
c0003774:	68 ff b7 00 c0       	push   $0xc000b7ff
c0003779:	e8 f2 e9 ff ff       	call   c0002170 <put_str>
c000377e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/kernel/memory.c:654
}
c0003781:	90                   	nop
c0003782:	c9                   	leave  
c0003783:	c3                   	ret    

c0003784 <memset>:
memset():
/work/x86_os_my/lib/string.c:6
#include "string.h"
#include "global.h"
#include "debug.h"

/* 将dst_起始的size个字节置为value */
void memset(void* dst_, uint8_t value, uint32_t size) {
c0003784:	55                   	push   %ebp
c0003785:	89 e5                	mov    %esp,%ebp
c0003787:	83 ec 28             	sub    $0x28,%esp
c000378a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000378d:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:7
   ASSERT(dst_ != NULL);
c0003790:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003794:	75 19                	jne    c00037af <memset+0x2b>
/work/x86_os_my/lib/string.c:7 (discriminator 1)
c0003796:	68 68 b8 00 c0       	push   $0xc000b868
c000379b:	68 dc b8 00 c0       	push   $0xc000b8dc
c00037a0:	6a 07                	push   $0x7
c00037a2:	68 75 b8 00 c0       	push   $0xc000b875
c00037a7:	e8 36 eb ff ff       	call   c00022e2 <panic_spin>
c00037ac:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:8
   uint8_t* dst = (uint8_t*)dst_;
c00037af:	8b 45 08             	mov    0x8(%ebp),%eax
c00037b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:9
   while (size-- > 0)
c00037b5:	eb 0f                	jmp    c00037c6 <memset+0x42>
/work/x86_os_my/lib/string.c:10
      *dst++ = value;
c00037b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00037ba:	8d 50 01             	lea    0x1(%eax),%edx
c00037bd:	89 55 f4             	mov    %edx,-0xc(%ebp)
c00037c0:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c00037c4:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/string.c:9

/* 将dst_起始的size个字节置为value */
void memset(void* dst_, uint8_t value, uint32_t size) {
   ASSERT(dst_ != NULL);
   uint8_t* dst = (uint8_t*)dst_;
   while (size-- > 0)
c00037c6:	8b 45 10             	mov    0x10(%ebp),%eax
c00037c9:	8d 50 ff             	lea    -0x1(%eax),%edx
c00037cc:	89 55 10             	mov    %edx,0x10(%ebp)
c00037cf:	85 c0                	test   %eax,%eax
c00037d1:	75 e4                	jne    c00037b7 <memset+0x33>
/work/x86_os_my/lib/string.c:11
      *dst++ = value;
}
c00037d3:	90                   	nop
c00037d4:	c9                   	leave  
c00037d5:	c3                   	ret    

c00037d6 <memcpy>:
memcpy():
/work/x86_os_my/lib/string.c:14

/* 将src_起始的size个字节复制到dst_ */
void memcpy(void* dst_, const void* src_, uint32_t size) {
c00037d6:	55                   	push   %ebp
c00037d7:	89 e5                	mov    %esp,%ebp
c00037d9:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:15
   ASSERT(dst_ != NULL && src_ != NULL);
c00037dc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00037e0:	74 06                	je     c00037e8 <memcpy+0x12>
/work/x86_os_my/lib/string.c:15 (discriminator 1)
c00037e2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00037e6:	75 19                	jne    c0003801 <memcpy+0x2b>
/work/x86_os_my/lib/string.c:15 (discriminator 3)
c00037e8:	68 82 b8 00 c0       	push   $0xc000b882
c00037ed:	68 e4 b8 00 c0       	push   $0xc000b8e4
c00037f2:	6a 0f                	push   $0xf
c00037f4:	68 75 b8 00 c0       	push   $0xc000b875
c00037f9:	e8 e4 ea ff ff       	call   c00022e2 <panic_spin>
c00037fe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:16
   uint8_t* dst = dst_;
c0003801:	8b 45 08             	mov    0x8(%ebp),%eax
c0003804:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:17
   const uint8_t* src = src_;
c0003807:	8b 45 0c             	mov    0xc(%ebp),%eax
c000380a:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:18
   while (size-- > 0)
c000380d:	eb 17                	jmp    c0003826 <memcpy+0x50>
/work/x86_os_my/lib/string.c:19
      *dst++ = *src++;
c000380f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003812:	8d 50 01             	lea    0x1(%eax),%edx
c0003815:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003818:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000381b:	8d 4a 01             	lea    0x1(%edx),%ecx
c000381e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0003821:	0f b6 12             	movzbl (%edx),%edx
c0003824:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/string.c:18
/* 将src_起始的size个字节复制到dst_ */
void memcpy(void* dst_, const void* src_, uint32_t size) {
   ASSERT(dst_ != NULL && src_ != NULL);
   uint8_t* dst = dst_;
   const uint8_t* src = src_;
   while (size-- > 0)
c0003826:	8b 45 10             	mov    0x10(%ebp),%eax
c0003829:	8d 50 ff             	lea    -0x1(%eax),%edx
c000382c:	89 55 10             	mov    %edx,0x10(%ebp)
c000382f:	85 c0                	test   %eax,%eax
c0003831:	75 dc                	jne    c000380f <memcpy+0x39>
/work/x86_os_my/lib/string.c:20
      *dst++ = *src++;
}
c0003833:	90                   	nop
c0003834:	c9                   	leave  
c0003835:	c3                   	ret    

c0003836 <memcmp>:
memcmp():
/work/x86_os_my/lib/string.c:23

/* 连续比较以地址a_和地址b_开头的size个字节,若相等则返回0,若a_大于b_返回+1,否则返回-1 */
int memcmp(const void* a_, const void* b_, uint32_t size) {
c0003836:	55                   	push   %ebp
c0003837:	89 e5                	mov    %esp,%ebp
c0003839:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:24
   const char* a = a_;
c000383c:	8b 45 08             	mov    0x8(%ebp),%eax
c000383f:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:25
   const char* b = b_;
c0003842:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003845:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:26
   ASSERT(a != NULL || b != NULL);
c0003848:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000384c:	75 57                	jne    c00038a5 <memcmp+0x6f>
/work/x86_os_my/lib/string.c:26 (discriminator 1)
c000384e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0003852:	75 51                	jne    c00038a5 <memcmp+0x6f>
/work/x86_os_my/lib/string.c:26 (discriminator 2)
c0003854:	68 9f b8 00 c0       	push   $0xc000b89f
c0003859:	68 ec b8 00 c0       	push   $0xc000b8ec
c000385e:	6a 1a                	push   $0x1a
c0003860:	68 75 b8 00 c0       	push   $0xc000b875
c0003865:	e8 78 ea ff ff       	call   c00022e2 <panic_spin>
c000386a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:27 (discriminator 2)
   while (size-- > 0) {
c000386d:	eb 36                	jmp    c00038a5 <memcmp+0x6f>
/work/x86_os_my/lib/string.c:28
      if(*a != *b) {
c000386f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003872:	0f b6 10             	movzbl (%eax),%edx
c0003875:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003878:	0f b6 00             	movzbl (%eax),%eax
c000387b:	38 c2                	cmp    %al,%dl
c000387d:	74 1e                	je     c000389d <memcmp+0x67>
/work/x86_os_my/lib/string.c:29
	 return *a > *b ? 1 : -1; 
c000387f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003882:	0f b6 10             	movzbl (%eax),%edx
c0003885:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003888:	0f b6 00             	movzbl (%eax),%eax
c000388b:	38 c2                	cmp    %al,%dl
c000388d:	7e 07                	jle    c0003896 <memcmp+0x60>
/work/x86_os_my/lib/string.c:29 (discriminator 1)
c000388f:	b8 01 00 00 00       	mov    $0x1,%eax
c0003894:	eb 21                	jmp    c00038b7 <memcmp+0x81>
/work/x86_os_my/lib/string.c:29 (discriminator 2)
c0003896:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000389b:	eb 1a                	jmp    c00038b7 <memcmp+0x81>
/work/x86_os_my/lib/string.c:31
      }
      a++;
c000389d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:32
      b++;
c00038a1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/string.c:27
/* 连续比较以地址a_和地址b_开头的size个字节,若相等则返回0,若a_大于b_返回+1,否则返回-1 */
int memcmp(const void* a_, const void* b_, uint32_t size) {
   const char* a = a_;
   const char* b = b_;
   ASSERT(a != NULL || b != NULL);
   while (size-- > 0) {
c00038a5:	8b 45 10             	mov    0x10(%ebp),%eax
c00038a8:	8d 50 ff             	lea    -0x1(%eax),%edx
c00038ab:	89 55 10             	mov    %edx,0x10(%ebp)
c00038ae:	85 c0                	test   %eax,%eax
c00038b0:	75 bd                	jne    c000386f <memcmp+0x39>
/work/x86_os_my/lib/string.c:34
	 return *a > *b ? 1 : -1; 
      }
      a++;
      b++;
   }
   return 0;
c00038b2:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/string.c:35
}
c00038b7:	c9                   	leave  
c00038b8:	c3                   	ret    

c00038b9 <strcpy>:
strcpy():
/work/x86_os_my/lib/string.c:38

/* 将字符串从src_复制到dst_ */
char* strcpy(char* dst_, const char* src_) {
c00038b9:	55                   	push   %ebp
c00038ba:	89 e5                	mov    %esp,%ebp
c00038bc:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:39
   ASSERT(dst_ != NULL && src_ != NULL);
c00038bf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00038c3:	74 06                	je     c00038cb <strcpy+0x12>
/work/x86_os_my/lib/string.c:39 (discriminator 1)
c00038c5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00038c9:	75 19                	jne    c00038e4 <strcpy+0x2b>
/work/x86_os_my/lib/string.c:39 (discriminator 3)
c00038cb:	68 82 b8 00 c0       	push   $0xc000b882
c00038d0:	68 f4 b8 00 c0       	push   $0xc000b8f4
c00038d5:	6a 27                	push   $0x27
c00038d7:	68 75 b8 00 c0       	push   $0xc000b875
c00038dc:	e8 01 ea ff ff       	call   c00022e2 <panic_spin>
c00038e1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:40
   char* r = dst_;		       // 用来返回目的字符串起始地址
c00038e4:	8b 45 08             	mov    0x8(%ebp),%eax
c00038e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:41
   while((*dst_++ = *src_++));
c00038ea:	90                   	nop
/work/x86_os_my/lib/string.c:41 (discriminator 1)
c00038eb:	8b 45 08             	mov    0x8(%ebp),%eax
c00038ee:	8d 50 01             	lea    0x1(%eax),%edx
c00038f1:	89 55 08             	mov    %edx,0x8(%ebp)
c00038f4:	8b 55 0c             	mov    0xc(%ebp),%edx
c00038f7:	8d 4a 01             	lea    0x1(%edx),%ecx
c00038fa:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c00038fd:	0f b6 12             	movzbl (%edx),%edx
c0003900:	88 10                	mov    %dl,(%eax)
c0003902:	0f b6 00             	movzbl (%eax),%eax
c0003905:	84 c0                	test   %al,%al
c0003907:	75 e2                	jne    c00038eb <strcpy+0x32>
/work/x86_os_my/lib/string.c:42
   return r;
c0003909:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:43
}
c000390c:	c9                   	leave  
c000390d:	c3                   	ret    

c000390e <strlen>:
strlen():
/work/x86_os_my/lib/string.c:46

/* 返回字符串长度 */
uint32_t strlen(const char* str) {
c000390e:	55                   	push   %ebp
c000390f:	89 e5                	mov    %esp,%ebp
c0003911:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:47
   ASSERT(str != NULL);
c0003914:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003918:	75 19                	jne    c0003933 <strlen+0x25>
/work/x86_os_my/lib/string.c:47 (discriminator 1)
c000391a:	68 b6 b8 00 c0       	push   $0xc000b8b6
c000391f:	68 fc b8 00 c0       	push   $0xc000b8fc
c0003924:	6a 2f                	push   $0x2f
c0003926:	68 75 b8 00 c0       	push   $0xc000b875
c000392b:	e8 b2 e9 ff ff       	call   c00022e2 <panic_spin>
c0003930:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:48
   const char* p = str;
c0003933:	8b 45 08             	mov    0x8(%ebp),%eax
c0003936:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:49
   while(*p++);
c0003939:	90                   	nop
/work/x86_os_my/lib/string.c:49 (discriminator 1)
c000393a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000393d:	8d 50 01             	lea    0x1(%eax),%edx
c0003940:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003943:	0f b6 00             	movzbl (%eax),%eax
c0003946:	84 c0                	test   %al,%al
c0003948:	75 f0                	jne    c000393a <strlen+0x2c>
/work/x86_os_my/lib/string.c:50
   return (p - str - 1);
c000394a:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000394d:	8b 45 08             	mov    0x8(%ebp),%eax
c0003950:	29 c2                	sub    %eax,%edx
c0003952:	89 d0                	mov    %edx,%eax
c0003954:	83 e8 01             	sub    $0x1,%eax
/work/x86_os_my/lib/string.c:51
}
c0003957:	c9                   	leave  
c0003958:	c3                   	ret    

c0003959 <strcmp>:
strcmp():
/work/x86_os_my/lib/string.c:54

/* 比较两个字符串,若a_中的字符大于b_中的字符返回1,相等时返回0,否则返回-1. */
int8_t strcmp (const char* a, const char* b) {
c0003959:	55                   	push   %ebp
c000395a:	89 e5                	mov    %esp,%ebp
c000395c:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/string.c:55
   ASSERT(a != NULL && b != NULL);
c000395f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003963:	74 06                	je     c000396b <strcmp+0x12>
/work/x86_os_my/lib/string.c:55 (discriminator 1)
c0003965:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0003969:	75 19                	jne    c0003984 <strcmp+0x2b>
/work/x86_os_my/lib/string.c:55 (discriminator 3)
c000396b:	68 c2 b8 00 c0       	push   $0xc000b8c2
c0003970:	68 04 b9 00 c0       	push   $0xc000b904
c0003975:	6a 37                	push   $0x37
c0003977:	68 75 b8 00 c0       	push   $0xc000b875
c000397c:	e8 61 e9 ff ff       	call   c00022e2 <panic_spin>
c0003981:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:56 (discriminator 1)
   while (*a != 0 && *a == *b) {
c0003984:	eb 08                	jmp    c000398e <strcmp+0x35>
/work/x86_os_my/lib/string.c:57
      a++;
c0003986:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:58
      b++;
c000398a:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
/work/x86_os_my/lib/string.c:56
}

/* 比较两个字符串,若a_中的字符大于b_中的字符返回1,相等时返回0,否则返回-1. */
int8_t strcmp (const char* a, const char* b) {
   ASSERT(a != NULL && b != NULL);
   while (*a != 0 && *a == *b) {
c000398e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003991:	0f b6 00             	movzbl (%eax),%eax
c0003994:	84 c0                	test   %al,%al
c0003996:	74 10                	je     c00039a8 <strcmp+0x4f>
/work/x86_os_my/lib/string.c:56 (discriminator 1)
c0003998:	8b 45 08             	mov    0x8(%ebp),%eax
c000399b:	0f b6 10             	movzbl (%eax),%edx
c000399e:	8b 45 0c             	mov    0xc(%ebp),%eax
c00039a1:	0f b6 00             	movzbl (%eax),%eax
c00039a4:	38 c2                	cmp    %al,%dl
c00039a6:	74 de                	je     c0003986 <strcmp+0x2d>
/work/x86_os_my/lib/string.c:62
      a++;
      b++;
   }
/* 如果*a小于*b就返回-1,否则就属于*a大于等于*b的情况。在后面的布尔表达式"*a > *b"中,
 * 若*a大于*b,表达式就等于1,否则就表达式不成立,也就是布尔值为0,恰恰表示*a等于*b */
   return *a < *b ? -1 : *a > *b;
c00039a8:	8b 45 08             	mov    0x8(%ebp),%eax
c00039ab:	0f b6 10             	movzbl (%eax),%edx
c00039ae:	8b 45 0c             	mov    0xc(%ebp),%eax
c00039b1:	0f b6 00             	movzbl (%eax),%eax
c00039b4:	38 c2                	cmp    %al,%dl
c00039b6:	7c 13                	jl     c00039cb <strcmp+0x72>
/work/x86_os_my/lib/string.c:62 (discriminator 1)
c00039b8:	8b 45 08             	mov    0x8(%ebp),%eax
c00039bb:	0f b6 10             	movzbl (%eax),%edx
c00039be:	8b 45 0c             	mov    0xc(%ebp),%eax
c00039c1:	0f b6 00             	movzbl (%eax),%eax
c00039c4:	38 c2                	cmp    %al,%dl
c00039c6:	0f 9f c0             	setg   %al
c00039c9:	eb 05                	jmp    c00039d0 <strcmp+0x77>
/work/x86_os_my/lib/string.c:62 (discriminator 2)
c00039cb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/lib/string.c:63 (discriminator 5)
}
c00039d0:	c9                   	leave  
c00039d1:	c3                   	ret    

c00039d2 <strchr>:
strchr():
/work/x86_os_my/lib/string.c:66

/* 从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strchr(const char* str, const uint8_t ch) {
c00039d2:	55                   	push   %ebp
c00039d3:	89 e5                	mov    %esp,%ebp
c00039d5:	83 ec 18             	sub    $0x18,%esp
c00039d8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00039db:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/lib/string.c:67
   ASSERT(str != NULL);
c00039de:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00039e2:	75 35                	jne    c0003a19 <strchr+0x47>
/work/x86_os_my/lib/string.c:67 (discriminator 1)
c00039e4:	68 b6 b8 00 c0       	push   $0xc000b8b6
c00039e9:	68 0c b9 00 c0       	push   $0xc000b90c
c00039ee:	6a 43                	push   $0x43
c00039f0:	68 75 b8 00 c0       	push   $0xc000b875
c00039f5:	e8 e8 e8 ff ff       	call   c00022e2 <panic_spin>
c00039fa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:68 (discriminator 1)
   while (*str != 0) {
c00039fd:	eb 1a                	jmp    c0003a19 <strchr+0x47>
/work/x86_os_my/lib/string.c:69
      if (*str == ch) {
c00039ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a02:	0f b6 00             	movzbl (%eax),%eax
c0003a05:	0f be d0             	movsbl %al,%edx
c0003a08:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0003a0c:	39 c2                	cmp    %eax,%edx
c0003a0e:	75 05                	jne    c0003a15 <strchr+0x43>
/work/x86_os_my/lib/string.c:70
	 return (char*)str;	    // 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.
c0003a10:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a13:	eb 13                	jmp    c0003a28 <strchr+0x56>
/work/x86_os_my/lib/string.c:72
      }
      str++;
c0003a15:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:68
}

/* 从左到右查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strchr(const char* str, const uint8_t ch) {
   ASSERT(str != NULL);
   while (*str != 0) {
c0003a19:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a1c:	0f b6 00             	movzbl (%eax),%eax
c0003a1f:	84 c0                	test   %al,%al
c0003a21:	75 dc                	jne    c00039ff <strchr+0x2d>
/work/x86_os_my/lib/string.c:74
      if (*str == ch) {
	 return (char*)str;	    // 需要强制转化成和返回值类型一样,否则编译器会报const属性丢失,下同.
      }
      str++;
   }
   return NULL;
c0003a23:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/string.c:75
}
c0003a28:	c9                   	leave  
c0003a29:	c3                   	ret    

c0003a2a <strrchr>:
strrchr():
/work/x86_os_my/lib/string.c:78

/* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strrchr(const char* str, const uint8_t ch) {
c0003a2a:	55                   	push   %ebp
c0003a2b:	89 e5                	mov    %esp,%ebp
c0003a2d:	83 ec 28             	sub    $0x28,%esp
c0003a30:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003a33:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:79
   ASSERT(str != NULL);
c0003a36:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003a3a:	75 19                	jne    c0003a55 <strrchr+0x2b>
/work/x86_os_my/lib/string.c:79 (discriminator 1)
c0003a3c:	68 b6 b8 00 c0       	push   $0xc000b8b6
c0003a41:	68 14 b9 00 c0       	push   $0xc000b914
c0003a46:	6a 4f                	push   $0x4f
c0003a48:	68 75 b8 00 c0       	push   $0xc000b875
c0003a4d:	e8 90 e8 ff ff       	call   c00022e2 <panic_spin>
c0003a52:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:80
   const char* last_char = NULL;
c0003a55:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/string.c:82
   /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/
   while (*str != 0) {
c0003a5c:	eb 1b                	jmp    c0003a79 <strrchr+0x4f>
/work/x86_os_my/lib/string.c:83
      if (*str == ch) {
c0003a5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a61:	0f b6 00             	movzbl (%eax),%eax
c0003a64:	0f be d0             	movsbl %al,%edx
c0003a67:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0003a6b:	39 c2                	cmp    %eax,%edx
c0003a6d:	75 06                	jne    c0003a75 <strrchr+0x4b>
/work/x86_os_my/lib/string.c:84
	 last_char = str;
c0003a6f:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a72:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:86
      }
      str++;
c0003a75:	83 45 08 01          	addl   $0x1,0x8(%ebp)
/work/x86_os_my/lib/string.c:82
/* 从后往前查找字符串str中首次出现字符ch的地址(不是下标,是地址) */
char* strrchr(const char* str, const uint8_t ch) {
   ASSERT(str != NULL);
   const char* last_char = NULL;
   /* 从头到尾遍历一次,若存在ch字符,last_char总是该字符最后一次出现在串中的地址(不是下标,是地址)*/
   while (*str != 0) {
c0003a79:	8b 45 08             	mov    0x8(%ebp),%eax
c0003a7c:	0f b6 00             	movzbl (%eax),%eax
c0003a7f:	84 c0                	test   %al,%al
c0003a81:	75 db                	jne    c0003a5e <strrchr+0x34>
/work/x86_os_my/lib/string.c:88
      if (*str == ch) {
	 last_char = str;
      }
      str++;
   }
   return (char*)last_char;
c0003a83:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:89
}
c0003a86:	c9                   	leave  
c0003a87:	c3                   	ret    

c0003a88 <strcat>:
strcat():
/work/x86_os_my/lib/string.c:92

/* 将字符串src_拼接到dst_后,将回拼接的串地址 */
char* strcat(char* dst_, const char* src_) {
c0003a88:	55                   	push   %ebp
c0003a89:	89 e5                	mov    %esp,%ebp
c0003a8b:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/string.c:93
   ASSERT(dst_ != NULL && src_ != NULL);
c0003a8e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003a92:	74 06                	je     c0003a9a <strcat+0x12>
/work/x86_os_my/lib/string.c:93 (discriminator 1)
c0003a94:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0003a98:	75 19                	jne    c0003ab3 <strcat+0x2b>
/work/x86_os_my/lib/string.c:93 (discriminator 3)
c0003a9a:	68 82 b8 00 c0       	push   $0xc000b882
c0003a9f:	68 1c b9 00 c0       	push   $0xc000b91c
c0003aa4:	6a 5d                	push   $0x5d
c0003aa6:	68 75 b8 00 c0       	push   $0xc000b875
c0003aab:	e8 32 e8 ff ff       	call   c00022e2 <panic_spin>
c0003ab0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:94
   char* str = dst_;
c0003ab3:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ab6:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/string.c:95
   while (*str++);
c0003ab9:	90                   	nop
/work/x86_os_my/lib/string.c:95 (discriminator 1)
c0003aba:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003abd:	8d 50 01             	lea    0x1(%eax),%edx
c0003ac0:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003ac3:	0f b6 00             	movzbl (%eax),%eax
c0003ac6:	84 c0                	test   %al,%al
c0003ac8:	75 f0                	jne    c0003aba <strcat+0x32>
/work/x86_os_my/lib/string.c:96
   --str;      // 别看错了，--str是独立的一句，并不是while的循环体
c0003aca:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:97
   while((*str++ = *src_++));	 // 当*str被赋值为0时,此时表达式不成立,正好添加了字符串结尾的0.
c0003ace:	90                   	nop
/work/x86_os_my/lib/string.c:97 (discriminator 1)
c0003acf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003ad2:	8d 50 01             	lea    0x1(%eax),%edx
c0003ad5:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0003ad8:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003adb:	8d 4a 01             	lea    0x1(%edx),%ecx
c0003ade:	89 4d 0c             	mov    %ecx,0xc(%ebp)
c0003ae1:	0f b6 12             	movzbl (%edx),%edx
c0003ae4:	88 10                	mov    %dl,(%eax)
c0003ae6:	0f b6 00             	movzbl (%eax),%eax
c0003ae9:	84 c0                	test   %al,%al
c0003aeb:	75 e2                	jne    c0003acf <strcat+0x47>
/work/x86_os_my/lib/string.c:98
   return dst_;
c0003aed:	8b 45 08             	mov    0x8(%ebp),%eax
/work/x86_os_my/lib/string.c:99
}
c0003af0:	c9                   	leave  
c0003af1:	c3                   	ret    

c0003af2 <strchrs>:
strchrs():
/work/x86_os_my/lib/string.c:102

/* 在字符串str中查找指定字符ch出现的次数 */
uint32_t strchrs(const char* str, uint8_t ch) {
c0003af2:	55                   	push   %ebp
c0003af3:	89 e5                	mov    %esp,%ebp
c0003af5:	83 ec 28             	sub    $0x28,%esp
c0003af8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0003afb:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/string.c:103
   ASSERT(str != NULL);
c0003afe:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0003b02:	75 19                	jne    c0003b1d <strchrs+0x2b>
/work/x86_os_my/lib/string.c:103 (discriminator 1)
c0003b04:	68 b6 b8 00 c0       	push   $0xc000b8b6
c0003b09:	68 24 b9 00 c0       	push   $0xc000b924
c0003b0e:	6a 67                	push   $0x67
c0003b10:	68 75 b8 00 c0       	push   $0xc000b875
c0003b15:	e8 c8 e7 ff ff       	call   c00022e2 <panic_spin>
c0003b1a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/string.c:104
   uint32_t ch_cnt = 0;
c0003b1d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/string.c:105
   const char* p = str;
c0003b24:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b27:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/string.c:106
   while(*p != 0) {
c0003b2a:	eb 19                	jmp    c0003b45 <strchrs+0x53>
/work/x86_os_my/lib/string.c:107
      if (*p == ch) {
c0003b2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003b2f:	0f b6 00             	movzbl (%eax),%eax
c0003b32:	0f be d0             	movsbl %al,%edx
c0003b35:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0003b39:	39 c2                	cmp    %eax,%edx
c0003b3b:	75 04                	jne    c0003b41 <strchrs+0x4f>
/work/x86_os_my/lib/string.c:108
	 ch_cnt++;
c0003b3d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/lib/string.c:110
      }
      p++;
c0003b41:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/lib/string.c:106
/* 在字符串str中查找指定字符ch出现的次数 */
uint32_t strchrs(const char* str, uint8_t ch) {
   ASSERT(str != NULL);
   uint32_t ch_cnt = 0;
   const char* p = str;
   while(*p != 0) {
c0003b45:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003b48:	0f b6 00             	movzbl (%eax),%eax
c0003b4b:	84 c0                	test   %al,%al
c0003b4d:	75 dd                	jne    c0003b2c <strchrs+0x3a>
/work/x86_os_my/lib/string.c:112
      if (*p == ch) {
	 ch_cnt++;
      }
      p++;
   }
   return ch_cnt;
c0003b4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/string.c:113
}
c0003b52:	c9                   	leave  
c0003b53:	c3                   	ret    

c0003b54 <idle>:
idle():
/work/x86_os_my/thread/thread.c:23

extern void switch_to(struct task_struct* cur, struct task_struct* next);
extern void init(void);

/* idle线程 */
static void idle(void* arg UNUSED) {
c0003b54:	55                   	push   %ebp
c0003b55:	89 e5                	mov    %esp,%ebp
c0003b57:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:25 (discriminator 1)
	while(1) {
		thread_block(TASK_BLOCKED);
c0003b5a:	83 ec 0c             	sub    $0xc,%esp
c0003b5d:	6a 02                	push   $0x2
c0003b5f:	e8 aa 04 00 00       	call   c000400e <thread_block>
c0003b64:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:29 (discriminator 1)
		//CPU停机
		//唯一能唤醒处理器的就是外部中断
		//执行hlt时必须要保证目前处在开中断的情况下
		asm volatile ("sti; hlt" : : : "memory");
c0003b67:	fb                   	sti    
c0003b68:	f4                   	hlt    
/work/x86_os_my/thread/thread.c:30 (discriminator 1)
	}
c0003b69:	eb ef                	jmp    c0003b5a <idle+0x6>

c0003b6b <running_thread>:
running_thread():
/work/x86_os_my/thread/thread.c:37

/* 返回线程 PCB 地址。
 * 各个线程所用的 0 级栈都是在自己的 PCB 当中，
 * 取当前栈指针的高 20 位，就是当前运行线程的 PCB（PCB是在自然页的起始地址！）
 */
struct task_struct* running_thread() {
c0003b6b:	55                   	push   %ebp
c0003b6c:	89 e5                	mov    %esp,%ebp
c0003b6e:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:39
	uint32_t esp;
	asm ("mov %%esp, %0" : "=g" (esp));	//esp寄存器的值，放入变量esp
c0003b71:	89 e0                	mov    %esp,%eax
c0003b73:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:40
	return (struct task_struct*)(esp & 0xfffff000);
c0003b76:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003b79:	25 00 f0 ff ff       	and    $0xfffff000,%eax
/work/x86_os_my/thread/thread.c:41
}
c0003b7e:	c9                   	leave  
c0003b7f:	c3                   	ret    

c0003b80 <kernel_thread>:
kernel_thread():
/work/x86_os_my/thread/thread.c:44

/* 由kernel_thread去执行function(func_arg) */
static void kernel_thread(thread_func* function, void* func_arg) {
c0003b80:	55                   	push   %ebp
c0003b81:	89 e5                	mov    %esp,%ebp
c0003b83:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:50
	/* 线程的首次运行是由时钟中断处理函数调用任务调度器 schedule 完成的，
	 * 进入中断后处理器会自动关中断，
	 * 因此在执行 function 前要打开中断，否则 kernel_thread 中的 function 在关中断的情况下运行，
	 * 也就是时钟中断被屏蔽了，再也不会调度到新的线程，function 会独享处理器。
	 */
	intr_enable();
c0003b86:	e8 8a dd ff ff       	call   c0001915 <intr_enable>
/work/x86_os_my/thread/thread.c:51
	function(func_arg); 
c0003b8b:	83 ec 0c             	sub    $0xc,%esp
c0003b8e:	ff 75 0c             	pushl  0xc(%ebp)
c0003b91:	8b 45 08             	mov    0x8(%ebp),%eax
c0003b94:	ff d0                	call   *%eax
c0003b96:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:52
}
c0003b99:	90                   	nop
c0003b9a:	c9                   	leave  
c0003b9b:	c3                   	ret    

c0003b9c <allocate_pid>:
allocate_pid():
/work/x86_os_my/thread/thread.c:55

/* 分配pid */
static pid_t allocate_pid(void) {
c0003b9c:	55                   	push   %ebp
c0003b9d:	89 e5                	mov    %esp,%ebp
c0003b9f:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:57
   static pid_t next_pid = 0;
   lock_acquire(&pid_lock);
c0003ba2:	83 ec 0c             	sub    $0xc,%esp
c0003ba5:	68 b4 fb 00 c0       	push   $0xc000fbb4
c0003baa:	e8 90 0b 00 00       	call   c000473f <lock_acquire>
c0003baf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:58
   next_pid++;
c0003bb2:	0f b7 05 6c f5 00 c0 	movzwl 0xc000f56c,%eax
c0003bb9:	83 c0 01             	add    $0x1,%eax
c0003bbc:	66 a3 6c f5 00 c0    	mov    %ax,0xc000f56c
/work/x86_os_my/thread/thread.c:59
   lock_release(&pid_lock);
c0003bc2:	83 ec 0c             	sub    $0xc,%esp
c0003bc5:	68 b4 fb 00 c0       	push   $0xc000fbb4
c0003bca:	e8 e7 0b 00 00       	call   c00047b6 <lock_release>
c0003bcf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:60
   return next_pid;
c0003bd2:	0f b7 05 6c f5 00 c0 	movzwl 0xc000f56c,%eax
/work/x86_os_my/thread/thread.c:61
}
c0003bd9:	c9                   	leave  
c0003bda:	c3                   	ret    

c0003bdb <fork_pid>:
fork_pid():
/work/x86_os_my/thread/thread.c:64

/* fork进程时为其分配pid，只是再封装一次 allocate_pid */
pid_t fork_pid(void) {
c0003bdb:	55                   	push   %ebp
c0003bdc:	89 e5                	mov    %esp,%ebp
c0003bde:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:65
	return allocate_pid();
c0003be1:	e8 b6 ff ff ff       	call   c0003b9c <allocate_pid>
/work/x86_os_my/thread/thread.c:66
}
c0003be6:	c9                   	leave  
c0003be7:	c3                   	ret    

c0003be8 <thread_create>:
thread_create():
/work/x86_os_my/thread/thread.c:69

/* 初始化线程栈结构体 struct thread_stack */
void thread_create(struct task_struct* pthread, thread_func function, void* func_arg) {
c0003be8:	55                   	push   %ebp
c0003be9:	89 e5                	mov    %esp,%ebp
c0003beb:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/thread/thread.c:73
	/* 先预留中断使用栈的空间 
	 *（1）将来线程进入中断后，位于 kernel.S 中的中断代码会通过此栈来保存上下文。
	 *（2）将来实现用户进程时，会将用户进程的初始信息放在中断栈中。*/
	pthread->self_kstack -= sizeof(struct intr_stack);
c0003bee:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bf1:	8b 00                	mov    (%eax),%eax
c0003bf3:	8d 90 d0 fe ff ff    	lea    -0x130(%eax),%edx
c0003bf9:	8b 45 08             	mov    0x8(%ebp),%eax
c0003bfc:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:76

	/* 再留出线程栈空间（unused_retaddr 所在的栈）*/
	pthread->self_kstack -= sizeof(struct thread_stack);
c0003bfe:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c01:	8b 00                	mov    (%eax),%eax
c0003c03:	8d 50 80             	lea    -0x80(%eax),%edx
c0003c06:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c09:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:77
	struct thread_stack* kthread_stack = (struct thread_stack*)pthread->self_kstack;
c0003c0b:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c0e:	8b 00                	mov    (%eax),%eax
c0003c10:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/thread/thread.c:85
	 * kernel_thread 并不是通过 call 指令调用的，而是通过 ret 来执行的，
	 * 因此无法按照正常的函数调用形式传递 kernel_thread 所需要的参数，
	 * 这样调用是不行的： kernel_thread(function, func_arg)，
	 * 只能将参数放在 kernel_thread 所用的栈中，即处理器进入 kernel_thread 函数体时，
	 * 栈顶为返回地址，栈顶+4 为参数function，栈顶+8 为参数func_arg */
	kthread_stack->eip = kernel_thread;
c0003c13:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003c16:	c7 40 10 80 3b 00 c0 	movl   $0xc0003b80,0x10(%eax)
/work/x86_os_my/thread/thread.c:86
	kthread_stack->function = function;
c0003c1d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003c20:	8b 55 0c             	mov    0xc(%ebp),%edx
c0003c23:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/thread.c:87
	kthread_stack->func_arg = func_arg;
c0003c26:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003c29:	8b 55 10             	mov    0x10(%ebp),%edx
c0003c2c:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/thread/thread.c:88
	kthread_stack->ebp = kthread_stack->ebx = kthread_stack->esi = kthread_stack->edi = 0;
c0003c2f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003c32:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c0003c39:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003c3c:	8b 50 08             	mov    0x8(%eax),%edx
c0003c3f:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003c42:	89 50 0c             	mov    %edx,0xc(%eax)
c0003c45:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003c48:	8b 50 0c             	mov    0xc(%eax),%edx
c0003c4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003c4e:	89 50 04             	mov    %edx,0x4(%eax)
c0003c51:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003c54:	8b 50 04             	mov    0x4(%eax),%edx
c0003c57:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0003c5a:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:89
}
c0003c5c:	90                   	nop
c0003c5d:	c9                   	leave  
c0003c5e:	c3                   	ret    

c0003c5f <init_thread>:
init_thread():
/work/x86_os_my/thread/thread.c:92

/* 初始化线程PCB结构体 struct task_struct */
void init_thread(struct task_struct* pthread, char* name, int prio) {
c0003c5f:	55                   	push   %ebp
c0003c60:	89 e5                	mov    %esp,%ebp
c0003c62:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:93
	memset(pthread, 0, sizeof(*pthread));	//清空PCB
c0003c65:	83 ec 04             	sub    $0x4,%esp
c0003c68:	68 18 01 00 00       	push   $0x118
c0003c6d:	6a 00                	push   $0x0
c0003c6f:	ff 75 08             	pushl  0x8(%ebp)
c0003c72:	e8 0d fb ff ff       	call   c0003784 <memset>
c0003c77:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:94
	pthread->pid = allocate_pid();
c0003c7a:	e8 1d ff ff ff       	call   c0003b9c <allocate_pid>
c0003c7f:	89 c2                	mov    %eax,%edx
c0003c81:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c84:	66 89 50 04          	mov    %dx,0x4(%eax)
/work/x86_os_my/thread/thread.c:95
	strcpy(pthread->name, name);
c0003c88:	8b 45 08             	mov    0x8(%ebp),%eax
c0003c8b:	83 c0 0c             	add    $0xc,%eax
c0003c8e:	83 ec 08             	sub    $0x8,%esp
c0003c91:	ff 75 0c             	pushl  0xc(%ebp)
c0003c94:	50                   	push   %eax
c0003c95:	e8 1f fc ff ff       	call   c00038b9 <strcpy>
c0003c9a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:97

	if (pthread == g_main_thread) {
c0003c9d:	a1 b0 fb 00 c0       	mov    0xc000fbb0,%eax
c0003ca2:	39 45 08             	cmp    %eax,0x8(%ebp)
c0003ca5:	75 0c                	jne    c0003cb3 <init_thread+0x54>
/work/x86_os_my/thread/thread.c:99
		/* 由于把main函数也封装成一个线程,并且它一直是运行的,故将其直接设为TASK_RUNNING */
		pthread->status = TASK_RUNNING;
c0003ca7:	8b 45 08             	mov    0x8(%ebp),%eax
c0003caa:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c0003cb1:	eb 0a                	jmp    c0003cbd <init_thread+0x5e>
/work/x86_os_my/thread/thread.c:101
	} else {
		pthread->status = TASK_READY;
c0003cb3:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cb6:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:107
	}

	/* self_kstack是线程自己在内核态下使用的栈顶地址 
	 * 线程自己在 0 特权级下所用的栈，在线程创建之初，
	 * 它被初始化为线程 PCB 的最顶端，即(uint32_t)pthread + PG_SIZE。*/
	pthread->self_kstack = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c0003cbd:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cc0:	05 00 10 00 00       	add    $0x1000,%eax
c0003cc5:	89 c2                	mov    %eax,%edx
c0003cc7:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cca:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/thread.c:108
	pthread->priority = prio;
c0003ccc:	8b 45 10             	mov    0x10(%ebp),%eax
c0003ccf:	89 c2                	mov    %eax,%edx
c0003cd1:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cd4:	88 50 1c             	mov    %dl,0x1c(%eax)
/work/x86_os_my/thread/thread.c:109
	pthread->ticks = prio;
c0003cd7:	8b 45 10             	mov    0x10(%ebp),%eax
c0003cda:	89 c2                	mov    %eax,%edx
c0003cdc:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cdf:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/thread/thread.c:110
	pthread->elapsed_ticks = 0;
c0003ce2:	8b 45 08             	mov    0x8(%ebp),%eax
c0003ce5:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
/work/x86_os_my/thread/thread.c:111
	pthread->pgdir = NULL;
c0003cec:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cef:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
/work/x86_os_my/thread/thread.c:114

	/* 预留标准输入输出 */
	pthread->fd_table[0] = 0;
c0003cf6:	8b 45 08             	mov    0x8(%ebp),%eax
c0003cf9:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
/work/x86_os_my/thread/thread.c:115
	pthread->fd_table[1] = 1;
c0003d00:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d03:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
/work/x86_os_my/thread/thread.c:116
	pthread->fd_table[2] = 2;
c0003d0a:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d0d:	c7 40 2c 02 00 00 00 	movl   $0x2,0x2c(%eax)
/work/x86_os_my/thread/thread.c:118
	/* 其余的全置为-1 */
	uint8_t fd_idx = 3;
c0003d14:	c6 45 f7 03          	movb   $0x3,-0x9(%ebp)
/work/x86_os_my/thread/thread.c:119
	while (fd_idx < MAX_FILES_OPEN_PER_PROC) {
c0003d18:	eb 1c                	jmp    c0003d36 <init_thread+0xd7>
/work/x86_os_my/thread/thread.c:120
		pthread->fd_table[fd_idx] = -1;
c0003d1a:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0003d1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d21:	83 c2 08             	add    $0x8,%edx
c0003d24:	c7 44 90 04 ff ff ff 	movl   $0xffffffff,0x4(%eax,%edx,4)
c0003d2b:	ff 
/work/x86_os_my/thread/thread.c:121
		fd_idx++;
c0003d2c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0003d30:	83 c0 01             	add    $0x1,%eax
c0003d33:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/thread/thread.c:119
	pthread->fd_table[0] = 0;
	pthread->fd_table[1] = 1;
	pthread->fd_table[2] = 2;
	/* 其余的全置为-1 */
	uint8_t fd_idx = 3;
	while (fd_idx < MAX_FILES_OPEN_PER_PROC) {
c0003d36:	80 7d f7 07          	cmpb   $0x7,-0x9(%ebp)
c0003d3a:	76 de                	jbe    c0003d1a <init_thread+0xbb>
/work/x86_os_my/thread/thread.c:124
		pthread->fd_table[fd_idx] = -1;
		fd_idx++;
	}

	pthread->cwd_inode_nr = 0;			// 以根目录做为默认工作路径
c0003d3c:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d3f:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%eax)
c0003d46:	00 00 00 
/work/x86_os_my/thread/thread.c:125
	pthread->parent_pid = -1;			// -1表示没有父进程
c0003d49:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d4c:	66 c7 80 10 01 00 00 	movw   $0xffff,0x110(%eax)
c0003d53:	ff ff 
/work/x86_os_my/thread/thread.c:126
	pthread->stack_magic = 0x19870916;	// 自定义的魔数
c0003d55:	8b 45 08             	mov    0x8(%ebp),%eax
c0003d58:	c7 80 14 01 00 00 16 	movl   $0x19870916,0x114(%eax)
c0003d5f:	09 87 19 
/work/x86_os_my/thread/thread.c:127
}
c0003d62:	90                   	nop
c0003d63:	c9                   	leave  
c0003d64:	c3                   	ret    

c0003d65 <thread_start>:
thread_start():
/work/x86_os_my/thread/thread.c:130

/* 创建线程 */
struct task_struct* thread_start(char* name, int prio, thread_func function, void* func_arg) {
c0003d65:	55                   	push   %ebp
c0003d66:	89 e5                	mov    %esp,%ebp
c0003d68:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:132
	/* pcb都位于内核空间,包括用户进程的pcb也是在内核空间 */
	struct task_struct* thread = get_kernel_pages(1);
c0003d6b:	83 ec 0c             	sub    $0xc,%esp
c0003d6e:	6a 01                	push   $0x1
c0003d70:	e8 15 ec ff ff       	call   c000298a <get_kernel_pages>
c0003d75:	83 c4 10             	add    $0x10,%esp
c0003d78:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:134

	init_thread(thread, name, prio);			//初始化线程PCB
c0003d7b:	83 ec 04             	sub    $0x4,%esp
c0003d7e:	ff 75 0c             	pushl  0xc(%ebp)
c0003d81:	ff 75 08             	pushl  0x8(%ebp)
c0003d84:	ff 75 f4             	pushl  -0xc(%ebp)
c0003d87:	e8 d3 fe ff ff       	call   c0003c5f <init_thread>
c0003d8c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:135
	thread_create(thread, function, func_arg);	//初始化线程栈结构体
c0003d8f:	83 ec 04             	sub    $0x4,%esp
c0003d92:	ff 75 14             	pushl  0x14(%ebp)
c0003d95:	ff 75 10             	pushl  0x10(%ebp)
c0003d98:	ff 75 f4             	pushl  -0xc(%ebp)
c0003d9b:	e8 48 fe ff ff       	call   c0003be8 <thread_create>
c0003da0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:137
	
	ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));	// 确保之前不在队列中
c0003da3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003da6:	83 c0 44             	add    $0x44,%eax
c0003da9:	83 ec 08             	sub    $0x8,%esp
c0003dac:	50                   	push   %eax
c0003dad:	68 8c fb 00 c0       	push   $0xc000fb8c
c0003db2:	e8 d1 05 00 00       	call   c0004388 <elem_find>
c0003db7:	83 c4 10             	add    $0x10,%esp
c0003dba:	85 c0                	test   %eax,%eax
c0003dbc:	74 1c                	je     c0003dda <thread_start+0x75>
/work/x86_os_my/thread/thread.c:137 (discriminator 1)
c0003dbe:	68 2c b9 00 c0       	push   $0xc000b92c
c0003dc3:	68 b8 bb 00 c0       	push   $0xc000bbb8
c0003dc8:	68 89 00 00 00       	push   $0x89
c0003dcd:	68 61 b9 00 c0       	push   $0xc000b961
c0003dd2:	e8 0b e5 ff ff       	call   c00022e2 <panic_spin>
c0003dd7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:138
	list_append(&thread_ready_list, &thread->general_tag);			// 加入就绪线程队列
c0003dda:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003ddd:	83 c0 44             	add    $0x44,%eax
c0003de0:	83 ec 08             	sub    $0x8,%esp
c0003de3:	50                   	push   %eax
c0003de4:	68 8c fb 00 c0       	push   $0xc000fb8c
c0003de9:	e8 20 05 00 00       	call   c000430e <list_append>
c0003dee:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:140

	ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
c0003df1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003df4:	83 c0 4c             	add    $0x4c,%eax
c0003df7:	83 ec 08             	sub    $0x8,%esp
c0003dfa:	50                   	push   %eax
c0003dfb:	68 9c fb 00 c0       	push   $0xc000fb9c
c0003e00:	e8 83 05 00 00       	call   c0004388 <elem_find>
c0003e05:	83 c4 10             	add    $0x10,%esp
c0003e08:	85 c0                	test   %eax,%eax
c0003e0a:	74 1c                	je     c0003e28 <thread_start+0xc3>
/work/x86_os_my/thread/thread.c:140 (discriminator 1)
c0003e0c:	68 74 b9 00 c0       	push   $0xc000b974
c0003e11:	68 b8 bb 00 c0       	push   $0xc000bbb8
c0003e16:	68 8c 00 00 00       	push   $0x8c
c0003e1b:	68 61 b9 00 c0       	push   $0xc000b961
c0003e20:	e8 bd e4 ff ff       	call   c00022e2 <panic_spin>
c0003e25:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:141
	list_append(&thread_all_list, &thread->all_list_tag);			// 加入全部线程队列
c0003e28:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003e2b:	83 c0 4c             	add    $0x4c,%eax
c0003e2e:	83 ec 08             	sub    $0x8,%esp
c0003e31:	50                   	push   %eax
c0003e32:	68 9c fb 00 c0       	push   $0xc000fb9c
c0003e37:	e8 d2 04 00 00       	call   c000430e <list_append>
c0003e3c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:157
	 * 在执行 ret 后，esp 指向的数值被弹岀到 eip。
	 * 处理器会去执行 kernel_thread 函数。
	 * 在执行 kernel_thread 时，处理器以为栈顶是返回地址，其实只是一个假的占位置的变量 unused_retaddr！
	 * 接着会调用函数 function(func_arg) */
	//asm volatile ("movl %0, %%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret" : : "g" (thread->self_kstack) : "memory");
	return thread;
c0003e3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/thread/thread.c:158
}
c0003e42:	c9                   	leave  
c0003e43:	c3                   	ret    

c0003e44 <make_main_thread>:
make_main_thread():
/work/x86_os_my/thread/thread.c:162


/* 将kernel中的main函数完善为主线程 */
static void make_main_thread(void) {
c0003e44:	55                   	push   %ebp
c0003e45:	89 e5                	mov    %esp,%ebp
c0003e47:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:167
	/* 因为main线程早已运行,咱们在loader.S中进入内核时的mov esp, 0xc009f000设置了栈顶，也预留了pcb, 地址为0xc009e000
	 * 主线程不需要再为PCB申请页，只需要通过 init_thread 填充PCB成员：名称和优先级等。
	 * 也不需要再通过 thread_create 构造它的线程栈。
	 */
	g_main_thread = running_thread();	//用栈指针的高20位，当做当前线程的PCB
c0003e4a:	e8 1c fd ff ff       	call   c0003b6b <running_thread>
c0003e4f:	a3 b0 fb 00 c0       	mov    %eax,0xc000fbb0
/work/x86_os_my/thread/thread.c:168
	init_thread(g_main_thread, "main", 31);
c0003e54:	a1 b0 fb 00 c0       	mov    0xc000fbb0,%eax
c0003e59:	83 ec 04             	sub    $0x4,%esp
c0003e5c:	6a 1f                	push   $0x1f
c0003e5e:	68 a8 b9 00 c0       	push   $0xc000b9a8
c0003e63:	50                   	push   %eax
c0003e64:	e8 f6 fd ff ff       	call   c0003c5f <init_thread>
c0003e69:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:172

	/* main函数是当前线程,当前线程不在thread_ready_list中,
	 * 所以只将其加在thread_all_list中. */
	ASSERT(!elem_find(&thread_all_list, &g_main_thread->all_list_tag));
c0003e6c:	a1 b0 fb 00 c0       	mov    0xc000fbb0,%eax
c0003e71:	83 c0 4c             	add    $0x4c,%eax
c0003e74:	83 ec 08             	sub    $0x8,%esp
c0003e77:	50                   	push   %eax
c0003e78:	68 9c fb 00 c0       	push   $0xc000fb9c
c0003e7d:	e8 06 05 00 00       	call   c0004388 <elem_find>
c0003e82:	83 c4 10             	add    $0x10,%esp
c0003e85:	85 c0                	test   %eax,%eax
c0003e87:	74 1c                	je     c0003ea5 <make_main_thread+0x61>
/work/x86_os_my/thread/thread.c:172 (discriminator 1)
c0003e89:	68 b0 b9 00 c0       	push   $0xc000b9b0
c0003e8e:	68 c8 bb 00 c0       	push   $0xc000bbc8
c0003e93:	68 ac 00 00 00       	push   $0xac
c0003e98:	68 61 b9 00 c0       	push   $0xc000b961
c0003e9d:	e8 40 e4 ff ff       	call   c00022e2 <panic_spin>
c0003ea2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:173
	list_append(&thread_all_list, &g_main_thread->all_list_tag);
c0003ea5:	a1 b0 fb 00 c0       	mov    0xc000fbb0,%eax
c0003eaa:	83 c0 4c             	add    $0x4c,%eax
c0003ead:	83 ec 08             	sub    $0x8,%esp
c0003eb0:	50                   	push   %eax
c0003eb1:	68 9c fb 00 c0       	push   $0xc000fb9c
c0003eb6:	e8 53 04 00 00       	call   c000430e <list_append>
c0003ebb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:174
}
c0003ebe:	90                   	nop
c0003ebf:	c9                   	leave  
c0003ec0:	c3                   	ret    

c0003ec1 <schedule>:
schedule():
/work/x86_os_my/thread/thread.c:184
（2）调度器 schedule。
（3）任务切换函数 switch_to。
*/
/* 实现任务调度 */
void schedule()
{
c0003ec1:	55                   	push   %ebp
c0003ec2:	89 e5                	mov    %esp,%ebp
c0003ec4:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:185
	ASSERT(intr_get_status() == INTR_OFF);
c0003ec7:	e8 b9 da ff ff       	call   c0001985 <intr_get_status>
c0003ecc:	85 c0                	test   %eax,%eax
c0003ece:	74 1c                	je     c0003eec <schedule+0x2b>
/work/x86_os_my/thread/thread.c:185 (discriminator 1)
c0003ed0:	68 eb b9 00 c0       	push   $0xc000b9eb
c0003ed5:	68 dc bb 00 c0       	push   $0xc000bbdc
c0003eda:	68 b9 00 00 00       	push   $0xb9
c0003edf:	68 61 b9 00 c0       	push   $0xc000b961
c0003ee4:	e8 f9 e3 ff ff       	call   c00022e2 <panic_spin>
c0003ee9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:188

	/* 换下 */
	struct task_struct* cur = running_thread(); 
c0003eec:	e8 7a fc ff ff       	call   c0003b6b <running_thread>
c0003ef1:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:189
	if (cur->status == TASK_RUNNING) { // 若此线程只是cpu时间片到了,将其加入到就绪队列尾
c0003ef4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003ef7:	8b 40 08             	mov    0x8(%eax),%eax
c0003efa:	85 c0                	test   %eax,%eax
c0003efc:	75 65                	jne    c0003f63 <schedule+0xa2>
/work/x86_os_my/thread/thread.c:190
		ASSERT(!elem_find(&thread_ready_list, &cur->general_tag));
c0003efe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003f01:	83 c0 44             	add    $0x44,%eax
c0003f04:	83 ec 08             	sub    $0x8,%esp
c0003f07:	50                   	push   %eax
c0003f08:	68 8c fb 00 c0       	push   $0xc000fb8c
c0003f0d:	e8 76 04 00 00       	call   c0004388 <elem_find>
c0003f12:	83 c4 10             	add    $0x10,%esp
c0003f15:	85 c0                	test   %eax,%eax
c0003f17:	74 1c                	je     c0003f35 <schedule+0x74>
/work/x86_os_my/thread/thread.c:190 (discriminator 1)
c0003f19:	68 0c ba 00 c0       	push   $0xc000ba0c
c0003f1e:	68 dc bb 00 c0       	push   $0xc000bbdc
c0003f23:	68 be 00 00 00       	push   $0xbe
c0003f28:	68 61 b9 00 c0       	push   $0xc000b961
c0003f2d:	e8 b0 e3 ff ff       	call   c00022e2 <panic_spin>
c0003f32:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:191
		list_append(&thread_ready_list, &cur->general_tag);
c0003f35:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003f38:	83 c0 44             	add    $0x44,%eax
c0003f3b:	83 ec 08             	sub    $0x8,%esp
c0003f3e:	50                   	push   %eax
c0003f3f:	68 8c fb 00 c0       	push   $0xc000fb8c
c0003f44:	e8 c5 03 00 00       	call   c000430e <list_append>
c0003f49:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:192
		cur->ticks = cur->priority;     // 重新将当前线程的ticks再重置为其priority;
c0003f4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003f4f:	0f b6 50 1c          	movzbl 0x1c(%eax),%edx
c0003f53:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003f56:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/thread/thread.c:193
		cur->status = TASK_READY;
c0003f59:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0003f5c:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:200
		/* 若此线程需要某事件发生后才能继续上cpu运行,
		不需要将其加入队列,因为当前线程不在就绪队列中。*/
	}

	/* 如果就绪队列中没有可运行的任务,就唤醒idle */
	if (list_empty(&thread_ready_list)) {
c0003f63:	83 ec 0c             	sub    $0xc,%esp
c0003f66:	68 8c fb 00 c0       	push   $0xc000fb8c
c0003f6b:	e8 e5 04 00 00       	call   c0004455 <list_empty>
c0003f70:	83 c4 10             	add    $0x10,%esp
c0003f73:	85 c0                	test   %eax,%eax
c0003f75:	74 11                	je     c0003f88 <schedule+0xc7>
/work/x86_os_my/thread/thread.c:201
		thread_unblock(idle_thread);
c0003f77:	a1 ac fb 00 c0       	mov    0xc000fbac,%eax
c0003f7c:	83 ec 0c             	sub    $0xc,%esp
c0003f7f:	50                   	push   %eax
c0003f80:	e8 ec 00 00 00       	call   c0004071 <thread_unblock>
c0003f85:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:205
	}
	
	/* 换上 */
	ASSERT(!list_empty(&thread_ready_list));
c0003f88:	83 ec 0c             	sub    $0xc,%esp
c0003f8b:	68 8c fb 00 c0       	push   $0xc000fb8c
c0003f90:	e8 c0 04 00 00       	call   c0004455 <list_empty>
c0003f95:	83 c4 10             	add    $0x10,%esp
c0003f98:	85 c0                	test   %eax,%eax
c0003f9a:	74 1c                	je     c0003fb8 <schedule+0xf7>
/work/x86_os_my/thread/thread.c:205 (discriminator 1)
c0003f9c:	68 40 ba 00 c0       	push   $0xc000ba40
c0003fa1:	68 dc bb 00 c0       	push   $0xc000bbdc
c0003fa6:	68 cd 00 00 00       	push   $0xcd
c0003fab:	68 61 b9 00 c0       	push   $0xc000b961
c0003fb0:	e8 2d e3 ff ff       	call   c00022e2 <panic_spin>
c0003fb5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:206
	g_thread_tag = NULL;	  // g_thread_tag清空
c0003fb8:	c7 05 68 f5 00 c0 00 	movl   $0x0,0xc000f568
c0003fbf:	00 00 00 
/work/x86_os_my/thread/thread.c:208
	/* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */
	g_thread_tag = list_pop(&thread_ready_list);   
c0003fc2:	83 ec 0c             	sub    $0xc,%esp
c0003fc5:	68 8c fb 00 c0       	push   $0xc000fb8c
c0003fca:	e8 97 03 00 00       	call   c0004366 <list_pop>
c0003fcf:	83 c4 10             	add    $0x10,%esp
c0003fd2:	a3 68 f5 00 c0       	mov    %eax,0xc000f568
/work/x86_os_my/thread/thread.c:209
	struct task_struct* next = elem2entry(struct task_struct, general_tag, g_thread_tag);
c0003fd7:	a1 68 f5 00 c0       	mov    0xc000f568,%eax
c0003fdc:	83 e8 44             	sub    $0x44,%eax
c0003fdf:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:210
	next->status = TASK_RUNNING;
c0003fe2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0003fe5:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/thread/thread.c:214
	
	/* 1.激活线程或进程的页表,【更新CR3寄存器】
	 * 2.用户进程，更新tss中的esp0为进程的特权级0的栈 */
	process_activate(next);
c0003fec:	83 ec 0c             	sub    $0xc,%esp
c0003fef:	ff 75 f0             	pushl  -0x10(%ebp)
c0003ff2:	e8 0b 11 00 00       	call   c0005102 <process_activate>
c0003ff7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:216

	switch_to(cur, next);
c0003ffa:	83 ec 08             	sub    $0x8,%esp
c0003ffd:	ff 75 f0             	pushl  -0x10(%ebp)
c0004000:	ff 75 f4             	pushl  -0xc(%ebp)
c0004003:	e8 68 04 00 00       	call   c0004470 <switch_to>
c0004008:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:217
}
c000400b:	90                   	nop
c000400c:	c9                   	leave  
c000400d:	c3                   	ret    

c000400e <thread_block>:
thread_block():
/work/x86_os_my/thread/thread.c:220

/* 当前线程将自己阻塞,标志其状态为stat. */
void thread_block(enum task_status stat) {
c000400e:	55                   	push   %ebp
c000400f:	89 e5                	mov    %esp,%ebp
c0004011:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:222
	/* stat取值为TASK_BLOCKED,TASK_WAITING,TASK_HANGING,也就是只有这三种状态才不会被调度*/
	ASSERT(((stat == TASK_BLOCKED) || (stat == TASK_WAITING) || (stat == TASK_HANGING)));
c0004014:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0004018:	74 28                	je     c0004042 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:222 (discriminator 1)
c000401a:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c000401e:	74 22                	je     c0004042 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:222 (discriminator 2)
c0004020:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
c0004024:	74 1c                	je     c0004042 <thread_block+0x34>
/work/x86_os_my/thread/thread.c:222 (discriminator 3)
c0004026:	68 60 ba 00 c0       	push   $0xc000ba60
c000402b:	68 e8 bb 00 c0       	push   $0xc000bbe8
c0004030:	68 de 00 00 00       	push   $0xde
c0004035:	68 61 b9 00 c0       	push   $0xc000b961
c000403a:	e8 a3 e2 ff ff       	call   c00022e2 <panic_spin>
c000403f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:223
	enum intr_status old_status = intr_disable();
c0004042:	e8 f7 d8 ff ff       	call   c000193e <intr_disable>
c0004047:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:225
	
	struct task_struct* cur_thread = running_thread();
c000404a:	e8 1c fb ff ff       	call   c0003b6b <running_thread>
c000404f:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:226
	cur_thread->status = stat;
c0004052:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0004055:	8b 55 08             	mov    0x8(%ebp),%edx
c0004058:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/thread/thread.c:227
	schedule();
c000405b:	e8 61 fe ff ff       	call   c0003ec1 <schedule>
/work/x86_os_my/thread/thread.c:230
	
	/* 待当前线程被解除阻塞后才继续运行下面的intr_set_status */
	intr_set_status(old_status);
c0004060:	83 ec 0c             	sub    $0xc,%esp
c0004063:	ff 75 f4             	pushl  -0xc(%ebp)
c0004066:	e8 fc d8 ff ff       	call   c0001967 <intr_set_status>
c000406b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:231
}
c000406e:	90                   	nop
c000406f:	c9                   	leave  
c0004070:	c3                   	ret    

c0004071 <thread_unblock>:
thread_unblock():
/work/x86_os_my/thread/thread.c:234

/* 将线程pthread解除阻塞 */
void thread_unblock(struct task_struct* pthread) {
c0004071:	55                   	push   %ebp
c0004072:	89 e5                	mov    %esp,%ebp
c0004074:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:235
	enum intr_status old_status = intr_disable();
c0004077:	e8 c2 d8 ff ff       	call   c000193e <intr_disable>
c000407c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:236
	ASSERT(((pthread->status == TASK_BLOCKED) || (pthread->status == TASK_WAITING) || (pthread->status == TASK_HANGING)));
c000407f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004082:	8b 40 08             	mov    0x8(%eax),%eax
c0004085:	83 f8 02             	cmp    $0x2,%eax
c0004088:	74 32                	je     c00040bc <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:236 (discriminator 1)
c000408a:	8b 45 08             	mov    0x8(%ebp),%eax
c000408d:	8b 40 08             	mov    0x8(%eax),%eax
c0004090:	83 f8 03             	cmp    $0x3,%eax
c0004093:	74 27                	je     c00040bc <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:236 (discriminator 2)
c0004095:	8b 45 08             	mov    0x8(%ebp),%eax
c0004098:	8b 40 08             	mov    0x8(%eax),%eax
c000409b:	83 f8 04             	cmp    $0x4,%eax
c000409e:	74 1c                	je     c00040bc <thread_unblock+0x4b>
/work/x86_os_my/thread/thread.c:236 (discriminator 3)
c00040a0:	68 b0 ba 00 c0       	push   $0xc000bab0
c00040a5:	68 f8 bb 00 c0       	push   $0xc000bbf8
c00040aa:	68 ec 00 00 00       	push   $0xec
c00040af:	68 61 b9 00 c0       	push   $0xc000b961
c00040b4:	e8 29 e2 ff ff       	call   c00022e2 <panic_spin>
c00040b9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:238
	
	if (pthread->status != TASK_READY) {
c00040bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00040bf:	8b 40 08             	mov    0x8(%eax),%eax
c00040c2:	83 f8 01             	cmp    $0x1,%eax
c00040c5:	0f 84 8f 00 00 00    	je     c000415a <thread_unblock+0xe9>
/work/x86_os_my/thread/thread.c:239
		ASSERT(!elem_find(&thread_ready_list, &pthread->general_tag));
c00040cb:	8b 45 08             	mov    0x8(%ebp),%eax
c00040ce:	83 c0 44             	add    $0x44,%eax
c00040d1:	83 ec 08             	sub    $0x8,%esp
c00040d4:	50                   	push   %eax
c00040d5:	68 8c fb 00 c0       	push   $0xc000fb8c
c00040da:	e8 a9 02 00 00       	call   c0004388 <elem_find>
c00040df:	83 c4 10             	add    $0x10,%esp
c00040e2:	85 c0                	test   %eax,%eax
c00040e4:	74 1c                	je     c0004102 <thread_unblock+0x91>
/work/x86_os_my/thread/thread.c:239 (discriminator 1)
c00040e6:	68 20 bb 00 c0       	push   $0xc000bb20
c00040eb:	68 f8 bb 00 c0       	push   $0xc000bbf8
c00040f0:	68 ef 00 00 00       	push   $0xef
c00040f5:	68 61 b9 00 c0       	push   $0xc000b961
c00040fa:	e8 e3 e1 ff ff       	call   c00022e2 <panic_spin>
c00040ff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:240
		if (elem_find(&thread_ready_list, &pthread->general_tag)) {
c0004102:	8b 45 08             	mov    0x8(%ebp),%eax
c0004105:	83 c0 44             	add    $0x44,%eax
c0004108:	83 ec 08             	sub    $0x8,%esp
c000410b:	50                   	push   %eax
c000410c:	68 8c fb 00 c0       	push   $0xc000fb8c
c0004111:	e8 72 02 00 00       	call   c0004388 <elem_find>
c0004116:	83 c4 10             	add    $0x10,%esp
c0004119:	85 c0                	test   %eax,%eax
c000411b:	74 1c                	je     c0004139 <thread_unblock+0xc8>
/work/x86_os_my/thread/thread.c:241
			PANIC("thread_unblock: blocked thread in ready_list\n");
c000411d:	68 58 bb 00 c0       	push   $0xc000bb58
c0004122:	68 f8 bb 00 c0       	push   $0xc000bbf8
c0004127:	68 f1 00 00 00       	push   $0xf1
c000412c:	68 61 b9 00 c0       	push   $0xc000b961
c0004131:	e8 ac e1 ff ff       	call   c00022e2 <panic_spin>
c0004136:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:243
		}
		list_push(&thread_ready_list, &pthread->general_tag);	// 放到队列的最前面,使其尽快得到调度
c0004139:	8b 45 08             	mov    0x8(%ebp),%eax
c000413c:	83 c0 44             	add    $0x44,%eax
c000413f:	83 ec 08             	sub    $0x8,%esp
c0004142:	50                   	push   %eax
c0004143:	68 8c fb 00 c0       	push   $0xc000fb8c
c0004148:	e8 a3 01 00 00       	call   c00042f0 <list_push>
c000414d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:244
		pthread->status = TASK_READY;
c0004150:	8b 45 08             	mov    0x8(%ebp),%eax
c0004153:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:247
	}
	
	intr_set_status(old_status);
c000415a:	83 ec 0c             	sub    $0xc,%esp
c000415d:	ff 75 f4             	pushl  -0xc(%ebp)
c0004160:	e8 02 d8 ff ff       	call   c0001967 <intr_set_status>
c0004165:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:248
}
c0004168:	90                   	nop
c0004169:	c9                   	leave  
c000416a:	c3                   	ret    

c000416b <thread_yield>:
thread_yield():
/work/x86_os_my/thread/thread.c:251

/* 主动让出cpu，换其它线程运行，但状态仍是ready */
void thread_yield(void) {
c000416b:	55                   	push   %ebp
c000416c:	89 e5                	mov    %esp,%ebp
c000416e:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/thread.c:252
	struct task_struct* cur = running_thread();
c0004171:	e8 f5 f9 ff ff       	call   c0003b6b <running_thread>
c0004176:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/thread.c:253
	enum intr_status old_status = intr_disable();
c0004179:	e8 c0 d7 ff ff       	call   c000193e <intr_disable>
c000417e:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/thread.c:254
	ASSERT(!elem_find(&thread_ready_list, &cur->general_tag));
c0004181:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004184:	83 c0 44             	add    $0x44,%eax
c0004187:	83 ec 08             	sub    $0x8,%esp
c000418a:	50                   	push   %eax
c000418b:	68 8c fb 00 c0       	push   $0xc000fb8c
c0004190:	e8 f3 01 00 00       	call   c0004388 <elem_find>
c0004195:	83 c4 10             	add    $0x10,%esp
c0004198:	85 c0                	test   %eax,%eax
c000419a:	74 1c                	je     c00041b8 <thread_yield+0x4d>
/work/x86_os_my/thread/thread.c:254 (discriminator 1)
c000419c:	68 0c ba 00 c0       	push   $0xc000ba0c
c00041a1:	68 08 bc 00 c0       	push   $0xc000bc08
c00041a6:	68 fe 00 00 00       	push   $0xfe
c00041ab:	68 61 b9 00 c0       	push   $0xc000b961
c00041b0:	e8 2d e1 ff ff       	call   c00022e2 <panic_spin>
c00041b5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:255
	list_append(&thread_ready_list, &cur->general_tag);
c00041b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00041bb:	83 c0 44             	add    $0x44,%eax
c00041be:	83 ec 08             	sub    $0x8,%esp
c00041c1:	50                   	push   %eax
c00041c2:	68 8c fb 00 c0       	push   $0xc000fb8c
c00041c7:	e8 42 01 00 00       	call   c000430e <list_append>
c00041cc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:256
	cur->status = TASK_READY;
c00041cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00041d2:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/thread/thread.c:257
	schedule();
c00041d9:	e8 e3 fc ff ff       	call   c0003ec1 <schedule>
/work/x86_os_my/thread/thread.c:258
	intr_set_status(old_status);
c00041de:	83 ec 0c             	sub    $0xc,%esp
c00041e1:	ff 75 f0             	pushl  -0x10(%ebp)
c00041e4:	e8 7e d7 ff ff       	call   c0001967 <intr_set_status>
c00041e9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:259
}
c00041ec:	90                   	nop
c00041ed:	c9                   	leave  
c00041ee:	c3                   	ret    

c00041ef <thread_init>:
thread_init():
/work/x86_os_my/thread/thread.c:262

/* 初始化线程环境 */
void thread_init(void) {
c00041ef:	55                   	push   %ebp
c00041f0:	89 e5                	mov    %esp,%ebp
c00041f2:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/thread.c:263
	put_str("thread_init start\n");
c00041f5:	83 ec 0c             	sub    $0xc,%esp
c00041f8:	68 86 bb 00 c0       	push   $0xc000bb86
c00041fd:	e8 6e df ff ff       	call   c0002170 <put_str>
c0004202:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:264
	list_init(&thread_ready_list);
c0004205:	83 ec 0c             	sub    $0xc,%esp
c0004208:	68 8c fb 00 c0       	push   $0xc000fb8c
c000420d:	e8 6b 00 00 00       	call   c000427d <list_init>
c0004212:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:265
	list_init(&thread_all_list);
c0004215:	83 ec 0c             	sub    $0xc,%esp
c0004218:	68 9c fb 00 c0       	push   $0xc000fb9c
c000421d:	e8 5b 00 00 00       	call   c000427d <list_init>
c0004222:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:266
	lock_init(&pid_lock);
c0004225:	83 ec 0c             	sub    $0xc,%esp
c0004228:	68 b4 fb 00 c0       	push   $0xc000fbb4
c000422d:	e8 33 03 00 00       	call   c0004565 <lock_init>
c0004232:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:268
	/* 先创建第一个用户进程:init */
	process_execute(init, "init");	// 放在第一个初始化,这是第一个进程,init进程的pid为1
c0004235:	83 ec 08             	sub    $0x8,%esp
c0004238:	68 99 bb 00 c0       	push   $0xc000bb99
c000423d:	68 28 15 00 c0       	push   $0xc0001528
c0004242:	e8 cd 0f 00 00       	call   c0005214 <process_execute>
c0004247:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:270
	/* 将当前main函数创建为线程 */
	make_main_thread();
c000424a:	e8 f5 fb ff ff       	call   c0003e44 <make_main_thread>
/work/x86_os_my/thread/thread.c:272
	/* 创建idle线程 */
	idle_thread = thread_start("idle", 10, idle, NULL);
c000424f:	6a 00                	push   $0x0
c0004251:	68 54 3b 00 c0       	push   $0xc0003b54
c0004256:	6a 0a                	push   $0xa
c0004258:	68 9e bb 00 c0       	push   $0xc000bb9e
c000425d:	e8 03 fb ff ff       	call   c0003d65 <thread_start>
c0004262:	83 c4 10             	add    $0x10,%esp
c0004265:	a3 ac fb 00 c0       	mov    %eax,0xc000fbac
/work/x86_os_my/thread/thread.c:273
	put_str("thread_init done\n");
c000426a:	83 ec 0c             	sub    $0xc,%esp
c000426d:	68 a3 bb 00 c0       	push   $0xc000bba3
c0004272:	e8 f9 de ff ff       	call   c0002170 <put_str>
c0004277:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/thread.c:274
}
c000427a:	90                   	nop
c000427b:	c9                   	leave  
c000427c:	c3                   	ret    

c000427d <list_init>:
list_init():
/work/x86_os_my/lib/kernel/list.c:6
#include "list.h"
#include "interrupt.h"
/* 注意关中断的操作：临界区 */

/* 初始化双向链表list */
void list_init (struct list* list) {
c000427d:	55                   	push   %ebp
c000427e:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/lib/kernel/list.c:7
	list->head.prev = NULL;
c0004280:	8b 45 08             	mov    0x8(%ebp),%eax
c0004283:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/lib/kernel/list.c:8
	list->head.next = &list->tail;
c0004289:	8b 45 08             	mov    0x8(%ebp),%eax
c000428c:	8d 50 08             	lea    0x8(%eax),%edx
c000428f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004292:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:9
	list->tail.prev = &list->head;
c0004295:	8b 55 08             	mov    0x8(%ebp),%edx
c0004298:	8b 45 08             	mov    0x8(%ebp),%eax
c000429b:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/lib/kernel/list.c:10
	list->tail.next = NULL;
c000429e:	8b 45 08             	mov    0x8(%ebp),%eax
c00042a1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/lib/kernel/list.c:11
}
c00042a8:	90                   	nop
c00042a9:	5d                   	pop    %ebp
c00042aa:	c3                   	ret    

c00042ab <list_insert_before>:
list_insert_before():
/work/x86_os_my/lib/kernel/list.c:14

/* 把链表元素elem插入在元素before之前 */
void list_insert_before(struct list_elem* before, struct list_elem* elem) { 
c00042ab:	55                   	push   %ebp
c00042ac:	89 e5                	mov    %esp,%ebp
c00042ae:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:15
	enum intr_status old_status = intr_disable();
c00042b1:	e8 88 d6 ff ff       	call   c000193e <intr_disable>
c00042b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:18

	/* 将before前驱元素的后继元素更新为elem, 暂时使before脱离链表*/ 
	before->prev->next = elem; 
c00042b9:	8b 45 08             	mov    0x8(%ebp),%eax
c00042bc:	8b 00                	mov    (%eax),%eax
c00042be:	8b 55 0c             	mov    0xc(%ebp),%edx
c00042c1:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:22

	/* 更新elem自己的前驱结点为before的前驱,
	* 更新elem自己的后继结点为before, 于是before又回到链表 */
	elem->prev = before->prev;
c00042c4:	8b 45 08             	mov    0x8(%ebp),%eax
c00042c7:	8b 10                	mov    (%eax),%edx
c00042c9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00042cc:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:23
	elem->next = before;
c00042ce:	8b 45 0c             	mov    0xc(%ebp),%eax
c00042d1:	8b 55 08             	mov    0x8(%ebp),%edx
c00042d4:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:26

	/* 更新before的前驱结点为elem */
	before->prev = elem;
c00042d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00042da:	8b 55 0c             	mov    0xc(%ebp),%edx
c00042dd:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:28

	intr_set_status(old_status);
c00042df:	83 ec 0c             	sub    $0xc,%esp
c00042e2:	ff 75 f4             	pushl  -0xc(%ebp)
c00042e5:	e8 7d d6 ff ff       	call   c0001967 <intr_set_status>
c00042ea:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:29
}
c00042ed:	90                   	nop
c00042ee:	c9                   	leave  
c00042ef:	c3                   	ret    

c00042f0 <list_push>:
list_push():
/work/x86_os_my/lib/kernel/list.c:32

/* 添加元素到列表队首,类似栈push操作 */
void list_push(struct list* plist, struct list_elem* elem) {
c00042f0:	55                   	push   %ebp
c00042f1:	89 e5                	mov    %esp,%ebp
c00042f3:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/list.c:33
	list_insert_before(plist->head.next, elem); // 在队头插入elem
c00042f6:	8b 45 08             	mov    0x8(%ebp),%eax
c00042f9:	8b 40 04             	mov    0x4(%eax),%eax
c00042fc:	83 ec 08             	sub    $0x8,%esp
c00042ff:	ff 75 0c             	pushl  0xc(%ebp)
c0004302:	50                   	push   %eax
c0004303:	e8 a3 ff ff ff       	call   c00042ab <list_insert_before>
c0004308:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:34
}
c000430b:	90                   	nop
c000430c:	c9                   	leave  
c000430d:	c3                   	ret    

c000430e <list_append>:
list_append():
/work/x86_os_my/lib/kernel/list.c:37

/* 追加元素到链表队尾,类似队列的先进先出操作 */
void list_append(struct list* plist, struct list_elem* elem) {
c000430e:	55                   	push   %ebp
c000430f:	89 e5                	mov    %esp,%ebp
c0004311:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/lib/kernel/list.c:38
	list_insert_before(&plist->tail, elem);     // 在队尾的前面插入
c0004314:	8b 45 08             	mov    0x8(%ebp),%eax
c0004317:	83 c0 08             	add    $0x8,%eax
c000431a:	83 ec 08             	sub    $0x8,%esp
c000431d:	ff 75 0c             	pushl  0xc(%ebp)
c0004320:	50                   	push   %eax
c0004321:	e8 85 ff ff ff       	call   c00042ab <list_insert_before>
c0004326:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:39
}
c0004329:	90                   	nop
c000432a:	c9                   	leave  
c000432b:	c3                   	ret    

c000432c <list_remove>:
list_remove():
/work/x86_os_my/lib/kernel/list.c:42

/* 使元素pelem脱离链表 */
void list_remove(struct list_elem* pelem) {
c000432c:	55                   	push   %ebp
c000432d:	89 e5                	mov    %esp,%ebp
c000432f:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:43
	enum intr_status old_status = intr_disable();
c0004332:	e8 07 d6 ff ff       	call   c000193e <intr_disable>
c0004337:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:45

	pelem->prev->next = pelem->next;
c000433a:	8b 45 08             	mov    0x8(%ebp),%eax
c000433d:	8b 00                	mov    (%eax),%eax
c000433f:	8b 55 08             	mov    0x8(%ebp),%edx
c0004342:	8b 52 04             	mov    0x4(%edx),%edx
c0004345:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/lib/kernel/list.c:46
	pelem->next->prev = pelem->prev;
c0004348:	8b 45 08             	mov    0x8(%ebp),%eax
c000434b:	8b 40 04             	mov    0x4(%eax),%eax
c000434e:	8b 55 08             	mov    0x8(%ebp),%edx
c0004351:	8b 12                	mov    (%edx),%edx
c0004353:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/lib/kernel/list.c:48

	intr_set_status(old_status);
c0004355:	83 ec 0c             	sub    $0xc,%esp
c0004358:	ff 75 f4             	pushl  -0xc(%ebp)
c000435b:	e8 07 d6 ff ff       	call   c0001967 <intr_set_status>
c0004360:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:49
}
c0004363:	90                   	nop
c0004364:	c9                   	leave  
c0004365:	c3                   	ret    

c0004366 <list_pop>:
list_pop():
/work/x86_os_my/lib/kernel/list.c:52

/* 将链表第一个元素弹出并返回,类似栈的pop操作 */
struct list_elem* list_pop(struct list* plist) {
c0004366:	55                   	push   %ebp
c0004367:	89 e5                	mov    %esp,%ebp
c0004369:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:53
	struct list_elem* elem = plist->head.next;
c000436c:	8b 45 08             	mov    0x8(%ebp),%eax
c000436f:	8b 40 04             	mov    0x4(%eax),%eax
c0004372:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:54
	list_remove(elem);
c0004375:	83 ec 0c             	sub    $0xc,%esp
c0004378:	ff 75 f4             	pushl  -0xc(%ebp)
c000437b:	e8 ac ff ff ff       	call   c000432c <list_remove>
c0004380:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:55
	return elem;
c0004383:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/lib/kernel/list.c:56
} 
c0004386:	c9                   	leave  
c0004387:	c3                   	ret    

c0004388 <elem_find>:
elem_find():
/work/x86_os_my/lib/kernel/list.c:59

/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */
bool elem_find(struct list* plist, struct list_elem* obj_elem) {
c0004388:	55                   	push   %ebp
c0004389:	89 e5                	mov    %esp,%ebp
c000438b:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:60
	struct list_elem* elem = plist->head.next;
c000438e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004391:	8b 40 04             	mov    0x4(%eax),%eax
c0004394:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:61
	while (elem != &plist->tail) {
c0004397:	eb 18                	jmp    c00043b1 <elem_find+0x29>
/work/x86_os_my/lib/kernel/list.c:62
	if (elem == obj_elem) {
c0004399:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000439c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c000439f:	75 07                	jne    c00043a8 <elem_find+0x20>
/work/x86_os_my/lib/kernel/list.c:63
		return true;
c00043a1:	b8 01 00 00 00       	mov    $0x1,%eax
c00043a6:	eb 19                	jmp    c00043c1 <elem_find+0x39>
/work/x86_os_my/lib/kernel/list.c:65
	}
		elem = elem->next;
c00043a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00043ab:	8b 40 04             	mov    0x4(%eax),%eax
c00043ae:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:61
} 

/* 从链表中查找元素obj_elem,成功时返回true,失败时返回false */
bool elem_find(struct list* plist, struct list_elem* obj_elem) {
	struct list_elem* elem = plist->head.next;
	while (elem != &plist->tail) {
c00043b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00043b4:	83 c0 08             	add    $0x8,%eax
c00043b7:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c00043ba:	75 dd                	jne    c0004399 <elem_find+0x11>
/work/x86_os_my/lib/kernel/list.c:67
	if (elem == obj_elem) {
		return true;
	}
		elem = elem->next;
	}
	return false;
c00043bc:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/kernel/list.c:68
}
c00043c1:	c9                   	leave  
c00043c2:	c3                   	ret    

c00043c3 <list_traversal>:
list_traversal():
/work/x86_os_my/lib/kernel/list.c:74

/* 把列表plist中的每个元素elem和arg传给回调函数func,
 * arg给func用来判断elem是否符合条件.
 * 本函数的功能是遍历列表内所有元素,逐个判断是否有符合条件的元素。
 * 找到符合条件的元素返回元素指针,否则返回NULL. */
struct list_elem* list_traversal(struct list* plist, function func, int arg) {
c00043c3:	55                   	push   %ebp
c00043c4:	89 e5                	mov    %esp,%ebp
c00043c6:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/kernel/list.c:75
	struct list_elem* elem = plist->head.next;
c00043c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00043cc:	8b 40 04             	mov    0x4(%eax),%eax
c00043cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:77
	/* 如果队列为空,就必然没有符合条件的结点,故直接返回NULL */
	if (list_empty(plist)) { 
c00043d2:	83 ec 0c             	sub    $0xc,%esp
c00043d5:	ff 75 08             	pushl  0x8(%ebp)
c00043d8:	e8 78 00 00 00       	call   c0004455 <list_empty>
c00043dd:	83 c4 10             	add    $0x10,%esp
c00043e0:	85 c0                	test   %eax,%eax
c00043e2:	74 2a                	je     c000440e <list_traversal+0x4b>
/work/x86_os_my/lib/kernel/list.c:78
		return NULL;
c00043e4:	b8 00 00 00 00       	mov    $0x0,%eax
c00043e9:	eb 33                	jmp    c000441e <list_traversal+0x5b>
/work/x86_os_my/lib/kernel/list.c:82
	}

	while (elem != &plist->tail) {
	if (func(elem, arg)) {		// func返回ture则认为该元素在回调函数中符合条件,命中,故停止继续遍历
c00043eb:	83 ec 08             	sub    $0x8,%esp
c00043ee:	ff 75 10             	pushl  0x10(%ebp)
c00043f1:	ff 75 f4             	pushl  -0xc(%ebp)
c00043f4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00043f7:	ff d0                	call   *%eax
c00043f9:	83 c4 10             	add    $0x10,%esp
c00043fc:	85 c0                	test   %eax,%eax
c00043fe:	74 05                	je     c0004405 <list_traversal+0x42>
/work/x86_os_my/lib/kernel/list.c:83
		return elem;
c0004400:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004403:	eb 19                	jmp    c000441e <list_traversal+0x5b>
/work/x86_os_my/lib/kernel/list.c:85
	}
		elem = elem->next;		// 若回调函数func返回false,则继续遍历
c0004405:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004408:	8b 40 04             	mov    0x4(%eax),%eax
c000440b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/list.c:81
	/* 如果队列为空,就必然没有符合条件的结点,故直接返回NULL */
	if (list_empty(plist)) { 
		return NULL;
	}

	while (elem != &plist->tail) {
c000440e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004411:	83 c0 08             	add    $0x8,%eax
c0004414:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0004417:	75 d2                	jne    c00043eb <list_traversal+0x28>
/work/x86_os_my/lib/kernel/list.c:87
	if (func(elem, arg)) {		// func返回ture则认为该元素在回调函数中符合条件,命中,故停止继续遍历
		return elem;
	}
		elem = elem->next;		// 若回调函数func返回false,则继续遍历
	}
	return NULL;
c0004419:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/lib/kernel/list.c:88
}
c000441e:	c9                   	leave  
c000441f:	c3                   	ret    

c0004420 <list_len>:
list_len():
/work/x86_os_my/lib/kernel/list.c:91

/* 返回链表长度 */
uint32_t list_len(struct list* plist) {
c0004420:	55                   	push   %ebp
c0004421:	89 e5                	mov    %esp,%ebp
c0004423:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/kernel/list.c:92
	struct list_elem* elem = plist->head.next;
c0004426:	8b 45 08             	mov    0x8(%ebp),%eax
c0004429:	8b 40 04             	mov    0x4(%eax),%eax
c000442c:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:93
	uint32_t length = 0;
c000442f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
/work/x86_os_my/lib/kernel/list.c:94
	while (elem != &plist->tail) {
c0004436:	eb 0d                	jmp    c0004445 <list_len+0x25>
/work/x86_os_my/lib/kernel/list.c:95
		length++; 
c0004438:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
/work/x86_os_my/lib/kernel/list.c:96
		elem = elem->next;
c000443c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000443f:	8b 40 04             	mov    0x4(%eax),%eax
c0004442:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/lib/kernel/list.c:94

/* 返回链表长度 */
uint32_t list_len(struct list* plist) {
	struct list_elem* elem = plist->head.next;
	uint32_t length = 0;
	while (elem != &plist->tail) {
c0004445:	8b 45 08             	mov    0x8(%ebp),%eax
c0004448:	83 c0 08             	add    $0x8,%eax
c000444b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
c000444e:	75 e8                	jne    c0004438 <list_len+0x18>
/work/x86_os_my/lib/kernel/list.c:98
		length++; 
		elem = elem->next;
	}
	return length;
c0004450:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/kernel/list.c:99
}
c0004453:	c9                   	leave  
c0004454:	c3                   	ret    

c0004455 <list_empty>:
list_empty():
/work/x86_os_my/lib/kernel/list.c:102

/* 判断链表是否为空,空时返回true,否则返回false */
bool list_empty(struct list* plist) {		// 判断队列是否为空
c0004455:	55                   	push   %ebp
c0004456:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/lib/kernel/list.c:103
	return (plist->head.next == &plist->tail ? true : false);
c0004458:	8b 45 08             	mov    0x8(%ebp),%eax
c000445b:	8b 40 04             	mov    0x4(%eax),%eax
c000445e:	8b 55 08             	mov    0x8(%ebp),%edx
c0004461:	83 c2 08             	add    $0x8,%edx
c0004464:	39 d0                	cmp    %edx,%eax
c0004466:	0f 94 c0             	sete   %al
c0004469:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/lib/kernel/list.c:104
}
c000446c:	5d                   	pop    %ebp
c000446d:	c3                   	ret    
c000446e:	66 90                	xchg   %ax,%ax

c0004470 <switch_to>:
switch_to():
c0004470:	56                   	push   %esi
c0004471:	57                   	push   %edi
c0004472:	53                   	push   %ebx
c0004473:	55                   	push   %ebp
c0004474:	8b 44 24 14          	mov    0x14(%esp),%eax
c0004478:	89 20                	mov    %esp,(%eax)
c000447a:	8b 44 24 18          	mov    0x18(%esp),%eax
c000447e:	8b 20                	mov    (%eax),%esp
c0004480:	5d                   	pop    %ebp
c0004481:	5b                   	pop    %ebx
c0004482:	5f                   	pop    %edi
c0004483:	5e                   	pop    %esi
c0004484:	c3                   	ret    

c0004485 <console_init>:
console_init():
/work/x86_os_my/device/console.c:9
#include "sync.h"
#include "thread.h"
static struct lock console_lock;	// 控制台锁

/* 初始化终端 */
void console_init() {
c0004485:	55                   	push   %ebp
c0004486:	89 e5                	mov    %esp,%ebp
c0004488:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:10
	lock_init(&console_lock);
c000448b:	83 ec 0c             	sub    $0xc,%esp
c000448e:	68 70 f5 00 c0       	push   $0xc000f570
c0004493:	e8 cd 00 00 00       	call   c0004565 <lock_init>
c0004498:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:11
}
c000449b:	90                   	nop
c000449c:	c9                   	leave  
c000449d:	c3                   	ret    

c000449e <console_acquire>:
console_acquire():
/work/x86_os_my/device/console.c:14

/* 获取终端 */
void console_acquire() {
c000449e:	55                   	push   %ebp
c000449f:	89 e5                	mov    %esp,%ebp
c00044a1:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:15
	lock_acquire(&console_lock);
c00044a4:	83 ec 0c             	sub    $0xc,%esp
c00044a7:	68 70 f5 00 c0       	push   $0xc000f570
c00044ac:	e8 8e 02 00 00       	call   c000473f <lock_acquire>
c00044b1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:16
}
c00044b4:	90                   	nop
c00044b5:	c9                   	leave  
c00044b6:	c3                   	ret    

c00044b7 <console_release>:
console_release():
/work/x86_os_my/device/console.c:19

/* 释放终端 */
void console_release() {
c00044b7:	55                   	push   %ebp
c00044b8:	89 e5                	mov    %esp,%ebp
c00044ba:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:20
	lock_release(&console_lock);
c00044bd:	83 ec 0c             	sub    $0xc,%esp
c00044c0:	68 70 f5 00 c0       	push   $0xc000f570
c00044c5:	e8 ec 02 00 00       	call   c00047b6 <lock_release>
c00044ca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:21
}
c00044cd:	90                   	nop
c00044ce:	c9                   	leave  
c00044cf:	c3                   	ret    

c00044d0 <console_put_str>:
console_put_str():
/work/x86_os_my/device/console.c:24

/* 终端中输出字符串 */
void console_put_str(char* str) {
c00044d0:	55                   	push   %ebp
c00044d1:	89 e5                	mov    %esp,%ebp
c00044d3:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:25
	console_acquire();
c00044d6:	e8 c3 ff ff ff       	call   c000449e <console_acquire>
/work/x86_os_my/device/console.c:26
	put_str(str);
c00044db:	83 ec 0c             	sub    $0xc,%esp
c00044de:	ff 75 08             	pushl  0x8(%ebp)
c00044e1:	e8 8a dc ff ff       	call   c0002170 <put_str>
c00044e6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:27
	console_release();
c00044e9:	e8 c9 ff ff ff       	call   c00044b7 <console_release>
/work/x86_os_my/device/console.c:28
}
c00044ee:	90                   	nop
c00044ef:	c9                   	leave  
c00044f0:	c3                   	ret    

c00044f1 <console_put_char>:
console_put_char():
/work/x86_os_my/device/console.c:31

/* 终端中输出字符 */
void console_put_char(uint8_t char_asci) {
c00044f1:	55                   	push   %ebp
c00044f2:	89 e5                	mov    %esp,%ebp
c00044f4:	83 ec 18             	sub    $0x18,%esp
c00044f7:	8b 45 08             	mov    0x8(%ebp),%eax
c00044fa:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/console.c:32
	console_acquire();
c00044fd:	e8 9c ff ff ff       	call   c000449e <console_acquire>
/work/x86_os_my/device/console.c:33
	put_char(char_asci);
c0004502:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0004506:	83 ec 0c             	sub    $0xc,%esp
c0004509:	50                   	push   %eax
c000450a:	e8 7f dc ff ff       	call   c000218e <put_char>
c000450f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:34
	console_release();
c0004512:	e8 a0 ff ff ff       	call   c00044b7 <console_release>
/work/x86_os_my/device/console.c:35
}
c0004517:	90                   	nop
c0004518:	c9                   	leave  
c0004519:	c3                   	ret    

c000451a <console_put_int>:
console_put_int():
/work/x86_os_my/device/console.c:38

/* 终端中输出16进制整数 */
void console_put_int(uint32_t num) {
c000451a:	55                   	push   %ebp
c000451b:	89 e5                	mov    %esp,%ebp
c000451d:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/console.c:39
	console_acquire();
c0004520:	e8 79 ff ff ff       	call   c000449e <console_acquire>
/work/x86_os_my/device/console.c:40
	put_int(num);
c0004525:	83 ec 0c             	sub    $0xc,%esp
c0004528:	ff 75 08             	pushl  0x8(%ebp)
c000452b:	e8 2b dd ff ff       	call   c000225b <put_int>
c0004530:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/console.c:41
	console_release();
c0004533:	e8 7f ff ff ff       	call   c00044b7 <console_release>
/work/x86_os_my/device/console.c:42
}
c0004538:	90                   	nop
c0004539:	c9                   	leave  
c000453a:	c3                   	ret    

c000453b <sema_init>:
sema_init():
/work/x86_os_my/thread/sync.c:8
#include "global.h"
#include "debug.h"
#include "interrupt.h"

/* 初始化信号量 */
void sema_init(struct semaphore* psema, uint8_t value) {
c000453b:	55                   	push   %ebp
c000453c:	89 e5                	mov    %esp,%ebp
c000453e:	83 ec 18             	sub    $0x18,%esp
c0004541:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004544:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:9
	psema->value = value;       // 为信号量赋初值
c0004547:	8b 45 08             	mov    0x8(%ebp),%eax
c000454a:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c000454e:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:10
	list_init(&psema->waiters); //初始化信号量的等待队列
c0004550:	8b 45 08             	mov    0x8(%ebp),%eax
c0004553:	83 c0 04             	add    $0x4,%eax
c0004556:	83 ec 0c             	sub    $0xc,%esp
c0004559:	50                   	push   %eax
c000455a:	e8 1e fd ff ff       	call   c000427d <list_init>
c000455f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:11
}
c0004562:	90                   	nop
c0004563:	c9                   	leave  
c0004564:	c3                   	ret    

c0004565 <lock_init>:
lock_init():
/work/x86_os_my/thread/sync.c:14

/* 初始化锁plock */
void lock_init(struct lock* plock) {
c0004565:	55                   	push   %ebp
c0004566:	89 e5                	mov    %esp,%ebp
c0004568:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/thread/sync.c:15
	plock->holder = NULL;
c000456b:	8b 45 08             	mov    0x8(%ebp),%eax
c000456e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:16
	plock->holder_repeat_nr = 0;
c0004574:	8b 45 08             	mov    0x8(%ebp),%eax
c0004577:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:17
	sema_init(&plock->semaphore, 1);  // 信号量初值为1
c000457e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004581:	83 c0 04             	add    $0x4,%eax
c0004584:	83 ec 08             	sub    $0x8,%esp
c0004587:	6a 01                	push   $0x1
c0004589:	50                   	push   %eax
c000458a:	e8 ac ff ff ff       	call   c000453b <sema_init>
c000458f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:18
}
c0004592:	90                   	nop
c0004593:	c9                   	leave  
c0004594:	c3                   	ret    

c0004595 <sema_down>:
sema_down():
/work/x86_os_my/thread/sync.c:21

/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
c0004595:	55                   	push   %ebp
c0004596:	89 e5                	mov    %esp,%ebp
c0004598:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:23
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
c000459b:	e8 9e d3 ff ff       	call   c000193e <intr_disable>
c00045a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:25
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c00045a3:	e9 98 00 00 00       	jmp    c0004640 <sema_down+0xab>
/work/x86_os_my/thread/sync.c:26
		ASSERT(!elem_find(&psema->waiters, &running_thread()->general_tag));
c00045a8:	e8 be f5 ff ff       	call   c0003b6b <running_thread>
c00045ad:	8d 50 44             	lea    0x44(%eax),%edx
c00045b0:	8b 45 08             	mov    0x8(%ebp),%eax
c00045b3:	83 c0 04             	add    $0x4,%eax
c00045b6:	83 ec 08             	sub    $0x8,%esp
c00045b9:	52                   	push   %edx
c00045ba:	50                   	push   %eax
c00045bb:	e8 c8 fd ff ff       	call   c0004388 <elem_find>
c00045c0:	83 c4 10             	add    $0x10,%esp
c00045c3:	85 c0                	test   %eax,%eax
c00045c5:	74 19                	je     c00045e0 <sema_down+0x4b>
/work/x86_os_my/thread/sync.c:26 (discriminator 1)
c00045c7:	68 18 bc 00 c0       	push   $0xc000bc18
c00045cc:	68 1c bd 00 c0       	push   $0xc000bd1c
c00045d1:	6a 1a                	push   $0x1a
c00045d3:	68 54 bc 00 c0       	push   $0xc000bc54
c00045d8:	e8 05 dd ff ff       	call   c00022e2 <panic_spin>
c00045dd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:28
		/* 当前线程不应该已在信号量的waiters队列中 */
		if (elem_find(&psema->waiters, &running_thread()->general_tag)) {
c00045e0:	e8 86 f5 ff ff       	call   c0003b6b <running_thread>
c00045e5:	8d 50 44             	lea    0x44(%eax),%edx
c00045e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00045eb:	83 c0 04             	add    $0x4,%eax
c00045ee:	83 ec 08             	sub    $0x8,%esp
c00045f1:	52                   	push   %edx
c00045f2:	50                   	push   %eax
c00045f3:	e8 90 fd ff ff       	call   c0004388 <elem_find>
c00045f8:	83 c4 10             	add    $0x10,%esp
c00045fb:	85 c0                	test   %eax,%eax
c00045fd:	74 19                	je     c0004618 <sema_down+0x83>
/work/x86_os_my/thread/sync.c:29
			PANIC("sema_down: thread blocked has been in waiters_list\n");
c00045ff:	68 64 bc 00 c0       	push   $0xc000bc64
c0004604:	68 1c bd 00 c0       	push   $0xc000bd1c
c0004609:	6a 1d                	push   $0x1d
c000460b:	68 54 bc 00 c0       	push   $0xc000bc54
c0004610:	e8 cd dc ff ff       	call   c00022e2 <panic_spin>
c0004615:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:32
		}
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
c0004618:	e8 4e f5 ff ff       	call   c0003b6b <running_thread>
c000461d:	8d 50 44             	lea    0x44(%eax),%edx
c0004620:	8b 45 08             	mov    0x8(%ebp),%eax
c0004623:	83 c0 04             	add    $0x4,%eax
c0004626:	83 ec 08             	sub    $0x8,%esp
c0004629:	52                   	push   %edx
c000462a:	50                   	push   %eax
c000462b:	e8 de fc ff ff       	call   c000430e <list_append>
c0004630:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:33
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
c0004633:	83 ec 0c             	sub    $0xc,%esp
c0004636:	6a 02                	push   $0x2
c0004638:	e8 d1 f9 ff ff       	call   c000400e <thread_block>
c000463d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:25
/* 信号量down操作 */
void sema_down(struct semaphore* psema) {
	/* 关中断来保证原子操作 */
	enum intr_status old_status = intr_disable();
	
	while(psema->value == 0) {			// 若value为0,表示已经被别人持有【while多次判断】
c0004640:	8b 45 08             	mov    0x8(%ebp),%eax
c0004643:	0f b6 00             	movzbl (%eax),%eax
c0004646:	84 c0                	test   %al,%al
c0004648:	0f 84 5a ff ff ff    	je     c00045a8 <sema_down+0x13>
/work/x86_os_my/thread/sync.c:36
		/* 若信号量的值等于0,则当前线程把自己加入该锁的等待队列,然后阻塞自己 */
		list_append(&psema->waiters, &running_thread()->general_tag);
		thread_block(TASK_BLOCKED);		// 阻塞线程,直到被唤醒
	}
	/* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*/
	psema->value--;
c000464e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004651:	0f b6 00             	movzbl (%eax),%eax
c0004654:	8d 50 ff             	lea    -0x1(%eax),%edx
c0004657:	8b 45 08             	mov    0x8(%ebp),%eax
c000465a:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:37
	ASSERT(psema->value == 0);
c000465c:	8b 45 08             	mov    0x8(%ebp),%eax
c000465f:	0f b6 00             	movzbl (%eax),%eax
c0004662:	84 c0                	test   %al,%al
c0004664:	74 19                	je     c000467f <sema_down+0xea>
/work/x86_os_my/thread/sync.c:37 (discriminator 1)
c0004666:	68 98 bc 00 c0       	push   $0xc000bc98
c000466b:	68 1c bd 00 c0       	push   $0xc000bd1c
c0004670:	6a 25                	push   $0x25
c0004672:	68 54 bc 00 c0       	push   $0xc000bc54
c0004677:	e8 66 dc ff ff       	call   c00022e2 <panic_spin>
c000467c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:40
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c000467f:	83 ec 0c             	sub    $0xc,%esp
c0004682:	ff 75 f4             	pushl  -0xc(%ebp)
c0004685:	e8 dd d2 ff ff       	call   c0001967 <intr_set_status>
c000468a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:41
}
c000468d:	90                   	nop
c000468e:	c9                   	leave  
c000468f:	c3                   	ret    

c0004690 <sema_up>:
sema_up():
/work/x86_os_my/thread/sync.c:44

/* 信号量的up操作 */
void sema_up(struct semaphore* psema) {
c0004690:	55                   	push   %ebp
c0004691:	89 e5                	mov    %esp,%ebp
c0004693:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/thread/sync.c:46
	/* 关中断,保证原子操作 */
	enum intr_status old_status = intr_disable();
c0004696:	e8 a3 d2 ff ff       	call   c000193e <intr_disable>
c000469b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/thread/sync.c:48
	
	ASSERT(psema->value == 0);
c000469e:	8b 45 08             	mov    0x8(%ebp),%eax
c00046a1:	0f b6 00             	movzbl (%eax),%eax
c00046a4:	84 c0                	test   %al,%al
c00046a6:	74 19                	je     c00046c1 <sema_up+0x31>
/work/x86_os_my/thread/sync.c:48 (discriminator 1)
c00046a8:	68 98 bc 00 c0       	push   $0xc000bc98
c00046ad:	68 28 bd 00 c0       	push   $0xc000bd28
c00046b2:	6a 30                	push   $0x30
c00046b4:	68 54 bc 00 c0       	push   $0xc000bc54
c00046b9:	e8 24 dc ff ff       	call   c00022e2 <panic_spin>
c00046be:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:49
	if (!list_empty(&psema->waiters)) {
c00046c1:	8b 45 08             	mov    0x8(%ebp),%eax
c00046c4:	83 c0 04             	add    $0x4,%eax
c00046c7:	83 ec 0c             	sub    $0xc,%esp
c00046ca:	50                   	push   %eax
c00046cb:	e8 85 fd ff ff       	call   c0004455 <list_empty>
c00046d0:	83 c4 10             	add    $0x10,%esp
c00046d3:	85 c0                	test   %eax,%eax
c00046d5:	75 26                	jne    c00046fd <sema_up+0x6d>
/work/x86_os_my/thread/sync.c:50
		struct task_struct* thread_blocked = elem2entry(struct task_struct, general_tag, list_pop(&psema->waiters));
c00046d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00046da:	83 c0 04             	add    $0x4,%eax
c00046dd:	83 ec 0c             	sub    $0xc,%esp
c00046e0:	50                   	push   %eax
c00046e1:	e8 80 fc ff ff       	call   c0004366 <list_pop>
c00046e6:	83 c4 10             	add    $0x10,%esp
c00046e9:	83 e8 44             	sub    $0x44,%eax
c00046ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/thread/sync.c:51
		thread_unblock(thread_blocked);
c00046ef:	83 ec 0c             	sub    $0xc,%esp
c00046f2:	ff 75 f0             	pushl  -0x10(%ebp)
c00046f5:	e8 77 f9 ff ff       	call   c0004071 <thread_unblock>
c00046fa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:53
	}
	psema->value++;
c00046fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0004700:	0f b6 00             	movzbl (%eax),%eax
c0004703:	8d 50 01             	lea    0x1(%eax),%edx
c0004706:	8b 45 08             	mov    0x8(%ebp),%eax
c0004709:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/thread/sync.c:54
	ASSERT(psema->value == 1);
c000470b:	8b 45 08             	mov    0x8(%ebp),%eax
c000470e:	0f b6 00             	movzbl (%eax),%eax
c0004711:	3c 01                	cmp    $0x1,%al
c0004713:	74 19                	je     c000472e <sema_up+0x9e>
/work/x86_os_my/thread/sync.c:54 (discriminator 1)
c0004715:	68 aa bc 00 c0       	push   $0xc000bcaa
c000471a:	68 28 bd 00 c0       	push   $0xc000bd28
c000471f:	6a 36                	push   $0x36
c0004721:	68 54 bc 00 c0       	push   $0xc000bc54
c0004726:	e8 b7 db ff ff       	call   c00022e2 <panic_spin>
c000472b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:57
	
	/* 恢复之前的中断状态 */
	intr_set_status(old_status);
c000472e:	83 ec 0c             	sub    $0xc,%esp
c0004731:	ff 75 f4             	pushl  -0xc(%ebp)
c0004734:	e8 2e d2 ff ff       	call   c0001967 <intr_set_status>
c0004739:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:58
}
c000473c:	90                   	nop
c000473d:	c9                   	leave  
c000473e:	c3                   	ret    

c000473f <lock_acquire>:
lock_acquire():
/work/x86_os_my/thread/sync.c:61

/* 获取锁plock */
void lock_acquire(struct lock* plock) {
c000473f:	55                   	push   %ebp
c0004740:	89 e5                	mov    %esp,%ebp
c0004742:	53                   	push   %ebx
c0004743:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:63
	/* 排除曾经自己已经持有锁但还未将其释放的情况。*/
	if (plock->holder != running_thread()) {
c0004746:	8b 45 08             	mov    0x8(%ebp),%eax
c0004749:	8b 18                	mov    (%eax),%ebx
c000474b:	e8 1b f4 ff ff       	call   c0003b6b <running_thread>
c0004750:	39 c3                	cmp    %eax,%ebx
c0004752:	74 4d                	je     c00047a1 <lock_acquire+0x62>
/work/x86_os_my/thread/sync.c:64
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
c0004754:	8b 45 08             	mov    0x8(%ebp),%eax
c0004757:	83 c0 04             	add    $0x4,%eax
c000475a:	83 ec 0c             	sub    $0xc,%esp
c000475d:	50                   	push   %eax
c000475e:	e8 32 fe ff ff       	call   c0004595 <sema_down>
c0004763:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:65
		plock->holder = running_thread();
c0004766:	e8 00 f4 ff ff       	call   c0003b6b <running_thread>
c000476b:	89 c2                	mov    %eax,%edx
c000476d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004770:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/thread/sync.c:66
		ASSERT(plock->holder_repeat_nr == 0);
c0004772:	8b 45 08             	mov    0x8(%ebp),%eax
c0004775:	8b 40 18             	mov    0x18(%eax),%eax
c0004778:	85 c0                	test   %eax,%eax
c000477a:	74 19                	je     c0004795 <lock_acquire+0x56>
/work/x86_os_my/thread/sync.c:66 (discriminator 1)
c000477c:	68 bc bc 00 c0       	push   $0xc000bcbc
c0004781:	68 30 bd 00 c0       	push   $0xc000bd30
c0004786:	6a 42                	push   $0x42
c0004788:	68 54 bc 00 c0       	push   $0xc000bc54
c000478d:	e8 50 db ff ff       	call   c00022e2 <panic_spin>
c0004792:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:67
		plock->holder_repeat_nr = 1;
c0004795:	8b 45 08             	mov    0x8(%ebp),%eax
c0004798:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	} else {
		plock->holder_repeat_nr++;
	}
}
c000479f:	eb 0f                	jmp    c00047b0 <lock_acquire+0x71>
/work/x86_os_my/thread/sync.c:69
		sema_down(&plock->semaphore);	// 对信号量P操作,原子操作
		plock->holder = running_thread();
		ASSERT(plock->holder_repeat_nr == 0);
		plock->holder_repeat_nr = 1;
	} else {
		plock->holder_repeat_nr++;
c00047a1:	8b 45 08             	mov    0x8(%ebp),%eax
c00047a4:	8b 40 18             	mov    0x18(%eax),%eax
c00047a7:	8d 50 01             	lea    0x1(%eax),%edx
c00047aa:	8b 45 08             	mov    0x8(%ebp),%eax
c00047ad:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:71
	}
}
c00047b0:	90                   	nop
c00047b1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00047b4:	c9                   	leave  
c00047b5:	c3                   	ret    

c00047b6 <lock_release>:
lock_release():
/work/x86_os_my/thread/sync.c:74

/* 释放锁plock */
void lock_release(struct lock* plock) {
c00047b6:	55                   	push   %ebp
c00047b7:	89 e5                	mov    %esp,%ebp
c00047b9:	53                   	push   %ebx
c00047ba:	83 ec 04             	sub    $0x4,%esp
/work/x86_os_my/thread/sync.c:75
	ASSERT(plock->holder == running_thread());
c00047bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00047c0:	8b 18                	mov    (%eax),%ebx
c00047c2:	e8 a4 f3 ff ff       	call   c0003b6b <running_thread>
c00047c7:	39 c3                	cmp    %eax,%ebx
c00047c9:	74 19                	je     c00047e4 <lock_release+0x2e>
/work/x86_os_my/thread/sync.c:75 (discriminator 1)
c00047cb:	68 dc bc 00 c0       	push   $0xc000bcdc
c00047d0:	68 40 bd 00 c0       	push   $0xc000bd40
c00047d5:	6a 4b                	push   $0x4b
c00047d7:	68 54 bc 00 c0       	push   $0xc000bc54
c00047dc:	e8 01 db ff ff       	call   c00022e2 <panic_spin>
c00047e1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:76
	if (plock->holder_repeat_nr > 1) {
c00047e4:	8b 45 08             	mov    0x8(%ebp),%eax
c00047e7:	8b 40 18             	mov    0x18(%eax),%eax
c00047ea:	83 f8 01             	cmp    $0x1,%eax
c00047ed:	76 11                	jbe    c0004800 <lock_release+0x4a>
/work/x86_os_my/thread/sync.c:77
		plock->holder_repeat_nr--;
c00047ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00047f2:	8b 40 18             	mov    0x18(%eax),%eax
c00047f5:	8d 50 ff             	lea    -0x1(%eax),%edx
c00047f8:	8b 45 08             	mov    0x8(%ebp),%eax
c00047fb:	89 50 18             	mov    %edx,0x18(%eax)
/work/x86_os_my/thread/sync.c:78
		return;
c00047fe:	eb 49                	jmp    c0004849 <lock_release+0x93>
/work/x86_os_my/thread/sync.c:80
	}
	ASSERT(plock->holder_repeat_nr == 1);
c0004800:	8b 45 08             	mov    0x8(%ebp),%eax
c0004803:	8b 40 18             	mov    0x18(%eax),%eax
c0004806:	83 f8 01             	cmp    $0x1,%eax
c0004809:	74 19                	je     c0004824 <lock_release+0x6e>
/work/x86_os_my/thread/sync.c:80 (discriminator 1)
c000480b:	68 fe bc 00 c0       	push   $0xc000bcfe
c0004810:	68 40 bd 00 c0       	push   $0xc000bd40
c0004815:	6a 50                	push   $0x50
c0004817:	68 54 bc 00 c0       	push   $0xc000bc54
c000481c:	e8 c1 da ff ff       	call   c00022e2 <panic_spin>
c0004821:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:82

	plock->holder = NULL;			// 把锁的持有者置空放在V操作之前
c0004824:	8b 45 08             	mov    0x8(%ebp),%eax
c0004827:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/thread/sync.c:83
	plock->holder_repeat_nr = 0;
c000482d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004830:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
/work/x86_os_my/thread/sync.c:84
	sema_up(&plock->semaphore);		// 信号量的V操作,也是原子操作
c0004837:	8b 45 08             	mov    0x8(%ebp),%eax
c000483a:	83 c0 04             	add    $0x4,%eax
c000483d:	83 ec 0c             	sub    $0xc,%esp
c0004840:	50                   	push   %eax
c0004841:	e8 4a fe ff ff       	call   c0004690 <sema_up>
c0004846:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/thread/sync.c:85
}
c0004849:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c000484c:	c9                   	leave  
c000484d:	c3                   	ret    

c000484e <inb>:
inb():
/work/x86_os_my/lib/kernel/io.h:36
   asm volatile ("cld; rep outsw" : "+S" (addr), "+c" (word_cnt) : "d" (port));
/******************************************************/
}

/* 将从端口port读入的一个字节返回 */
static inline uint8_t inb(uint16_t port) {
c000484e:	55                   	push   %ebp
c000484f:	89 e5                	mov    %esp,%ebp
c0004851:	83 ec 14             	sub    $0x14,%esp
c0004854:	8b 45 08             	mov    0x8(%ebp),%eax
c0004857:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/io.h:38
   uint8_t data;
   asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c000485b:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c000485f:	89 c2                	mov    %eax,%edx
c0004861:	ec                   	in     (%dx),%al
c0004862:	88 45 ff             	mov    %al,-0x1(%ebp)
/work/x86_os_my/lib/kernel/io.h:39
   return data;
c0004865:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
/work/x86_os_my/lib/kernel/io.h:40
}
c0004869:	c9                   	leave  
c000486a:	c3                   	ret    

c000486b <intr_keyboard_handler>:
intr_keyboard_handler():
/work/x86_os_my/device/keyboard.c:111
/* 0x3A */	{caps_lock_char, caps_lock_char}
/*其它按键暂不处理*/
};

/* 键盘中断处理程序 */
static void intr_keyboard_handler(void) {
c000486b:	55                   	push   %ebp
c000486c:	89 e5                	mov    %esp,%ebp
c000486e:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/device/keyboard.c:114

/* 这次中断发生前的上一次中断,以下任意三个键是否有按下 */
   bool ctrl_down_last = ctrl_status;	  
c0004871:	a1 8c f5 00 c0       	mov    0xc000f58c,%eax
c0004876:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/device/keyboard.c:115
   bool shift_down_last = shift_status;
c0004879:	a1 90 f5 00 c0       	mov    0xc000f590,%eax
c000487e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/device/keyboard.c:116
   bool caps_lock_last = caps_lock_status;
c0004881:	a1 98 f5 00 c0       	mov    0xc000f598,%eax
c0004886:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/device/keyboard.c:119

   bool break_code;
   uint16_t scancode = inb(KBD_BUF_PORT);
c0004889:	6a 60                	push   $0x60
c000488b:	e8 be ff ff ff       	call   c000484e <inb>
c0004890:	83 c4 04             	add    $0x4,%esp
c0004893:	0f b6 c0             	movzbl %al,%eax
c0004896:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:123

/* 若扫描码是e0开头的,表示此键的按下将产生多个扫描码,
 * 所以马上结束此次中断处理函数,等待下一个扫描码进来*/ 
   if (scancode == 0xe0) { 
c000489a:	66 81 7d f6 e0 00    	cmpw   $0xe0,-0xa(%ebp)
c00048a0:	75 0f                	jne    c00048b1 <intr_keyboard_handler+0x46>
/work/x86_os_my/device/keyboard.c:124
      ext_scancode = true;    // 打开e0标记
c00048a2:	c7 05 9c f5 00 c0 01 	movl   $0x1,0xc000f59c
c00048a9:	00 00 00 
/work/x86_os_my/device/keyboard.c:125
      return;
c00048ac:	e9 50 02 00 00       	jmp    c0004b01 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:129
   }

/* 如果上次是以0xe0开头,将扫描码合并 */
   if (ext_scancode) {
c00048b1:	a1 9c f5 00 c0       	mov    0xc000f59c,%eax
c00048b6:	85 c0                	test   %eax,%eax
c00048b8:	74 10                	je     c00048ca <intr_keyboard_handler+0x5f>
/work/x86_os_my/device/keyboard.c:130
      scancode = ((0xe000) | scancode);
c00048ba:	66 81 4d f6 00 e0    	orw    $0xe000,-0xa(%ebp)
/work/x86_os_my/device/keyboard.c:131
      ext_scancode = false;   // 关闭e0标记
c00048c0:	c7 05 9c f5 00 c0 00 	movl   $0x0,0xc000f59c
c00048c7:	00 00 00 
/work/x86_os_my/device/keyboard.c:134
   }   

   break_code = ((scancode & 0x0080) != 0);   // 获取break_code
c00048ca:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c00048ce:	25 80 00 00 00       	and    $0x80,%eax
c00048d3:	85 c0                	test   %eax,%eax
c00048d5:	0f 95 c0             	setne  %al
c00048d8:	0f b6 c0             	movzbl %al,%eax
c00048db:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/device/keyboard.c:136
   
   if (break_code) {   // 若是断码break_code(按键弹起时产生的扫描码)
c00048de:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c00048e2:	74 6a                	je     c000494e <intr_keyboard_handler+0xe3>
/work/x86_os_my/device/keyboard.c:140

   /* 由于ctrl_r 和alt_r的make_code和break_code都是两字节,
   所以可用下面的方法取make_code,多字节的扫描码暂不处理 */
      uint16_t make_code = (scancode &= 0xff7f);   // 得到其make_code(按键按下时产生的扫描码)
c00048e4:	66 81 65 f6 7f ff    	andw   $0xff7f,-0xa(%ebp)
c00048ea:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c00048ee:	66 89 45 da          	mov    %ax,-0x26(%ebp)
/work/x86_os_my/device/keyboard.c:143

   /* 若是任意以下三个键弹起了,将状态置为false */
      if (make_code == ctrl_l_make || make_code == ctrl_r_make) {
c00048f2:	66 83 7d da 1d       	cmpw   $0x1d,-0x26(%ebp)
c00048f7:	74 08                	je     c0004901 <intr_keyboard_handler+0x96>
/work/x86_os_my/device/keyboard.c:143 (discriminator 1)
c00048f9:	66 81 7d da 1d e0    	cmpw   $0xe01d,-0x26(%ebp)
c00048ff:	75 0c                	jne    c000490d <intr_keyboard_handler+0xa2>
/work/x86_os_my/device/keyboard.c:144
	 ctrl_status = false;
c0004901:	c7 05 8c f5 00 c0 00 	movl   $0x0,0xc000f58c
c0004908:	00 00 00 
c000490b:	eb 3c                	jmp    c0004949 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:145
      } else if (make_code == shift_l_make || make_code == shift_r_make) {
c000490d:	66 83 7d da 2a       	cmpw   $0x2a,-0x26(%ebp)
c0004912:	74 07                	je     c000491b <intr_keyboard_handler+0xb0>
/work/x86_os_my/device/keyboard.c:145 (discriminator 1)
c0004914:	66 83 7d da 36       	cmpw   $0x36,-0x26(%ebp)
c0004919:	75 0c                	jne    c0004927 <intr_keyboard_handler+0xbc>
/work/x86_os_my/device/keyboard.c:146
	 shift_status = false;
c000491b:	c7 05 90 f5 00 c0 00 	movl   $0x0,0xc000f590
c0004922:	00 00 00 
c0004925:	eb 22                	jmp    c0004949 <intr_keyboard_handler+0xde>
/work/x86_os_my/device/keyboard.c:147
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
c0004927:	66 83 7d da 38       	cmpw   $0x38,-0x26(%ebp)
c000492c:	74 0c                	je     c000493a <intr_keyboard_handler+0xcf>
/work/x86_os_my/device/keyboard.c:147 (discriminator 1)
c000492e:	66 81 7d da 38 e0    	cmpw   $0xe038,-0x26(%ebp)
c0004934:	0f 85 c0 01 00 00    	jne    c0004afa <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:148
	 alt_status = false;
c000493a:	c7 05 94 f5 00 c0 00 	movl   $0x0,0xc000f594
c0004941:	00 00 00 
/work/x86_os_my/device/keyboard.c:151
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c0004944:	e9 b1 01 00 00       	jmp    c0004afa <intr_keyboard_handler+0x28f>
c0004949:	e9 ac 01 00 00       	jmp    c0004afa <intr_keyboard_handler+0x28f>
/work/x86_os_my/device/keyboard.c:155

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
c000494e:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c0004953:	74 07                	je     c000495c <intr_keyboard_handler+0xf1>
/work/x86_os_my/device/keyboard.c:155 (discriminator 1)
c0004955:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c000495a:	76 14                	jbe    c0004970 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:155 (discriminator 3)
c000495c:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c0004962:	74 0c                	je     c0004970 <intr_keyboard_handler+0x105>
/work/x86_os_my/device/keyboard.c:156
	       (scancode == alt_r_make) || \
c0004964:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c000496a:	0f 85 78 01 00 00    	jne    c0004ae8 <intr_keyboard_handler+0x27d>
/work/x86_os_my/device/keyboard.c:158
	       (scancode == ctrl_r_make)) {
      bool shift = false;  // 判断是否与shift组合,用来在一维数组中索引对应的字符
c0004970:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:159
      if ((scancode < 0x0e) || (scancode == 0x29) || \
c0004977:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%ebp)
c000497c:	76 3f                	jbe    c00049bd <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 1)
c000497e:	66 83 7d f6 29       	cmpw   $0x29,-0xa(%ebp)
c0004983:	74 38                	je     c00049bd <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:159 (discriminator 2)
c0004985:	66 83 7d f6 1a       	cmpw   $0x1a,-0xa(%ebp)
c000498a:	74 31                	je     c00049bd <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160
	 (scancode == 0x1a) || (scancode == 0x1b) || \
c000498c:	66 83 7d f6 1b       	cmpw   $0x1b,-0xa(%ebp)
c0004991:	74 2a                	je     c00049bd <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:160 (discriminator 1)
c0004993:	66 83 7d f6 2b       	cmpw   $0x2b,-0xa(%ebp)
c0004998:	74 23                	je     c00049bd <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161
	 (scancode == 0x2b) || (scancode == 0x27) || \
c000499a:	66 83 7d f6 27       	cmpw   $0x27,-0xa(%ebp)
c000499f:	74 1c                	je     c00049bd <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:161 (discriminator 1)
c00049a1:	66 83 7d f6 28       	cmpw   $0x28,-0xa(%ebp)
c00049a6:	74 15                	je     c00049bd <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162
	 (scancode == 0x28) || (scancode == 0x33) || \
c00049a8:	66 83 7d f6 33       	cmpw   $0x33,-0xa(%ebp)
c00049ad:	74 0e                	je     c00049bd <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:162 (discriminator 1)
c00049af:	66 83 7d f6 34       	cmpw   $0x34,-0xa(%ebp)
c00049b4:	74 07                	je     c00049bd <intr_keyboard_handler+0x152>
/work/x86_os_my/device/keyboard.c:163
	 (scancode == 0x34) || (scancode == 0x35)) {  
c00049b6:	66 83 7d f6 35       	cmpw   $0x35,-0xa(%ebp)
c00049bb:	75 0f                	jne    c00049cc <intr_keyboard_handler+0x161>
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c00049bd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00049c1:	74 3a                	je     c00049fd <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:177
	    shift = true;
c00049c3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:176
		     0x28 字符'\''
		     0x33 字符','
		     0x34 字符'.'
		     0x35 字符'/' 
	    *******************************/
	 if (shift_down_last) {  // 如果同时按下了shift键
c00049ca:	eb 31                	jmp    c00049fd <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:180
	    shift = true;
	 }
      } else {	  // 默认为字母键
	 if (shift_down_last && caps_lock_last) {  // 如果shift和capslock同时按下
c00049cc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00049d0:	74 0f                	je     c00049e1 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:180 (discriminator 1)
c00049d2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c00049d6:	74 09                	je     c00049e1 <intr_keyboard_handler+0x176>
/work/x86_os_my/device/keyboard.c:181
	    shift = false;
c00049d8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00049df:	eb 1c                	jmp    c00049fd <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:182
	 } else if (shift_down_last || caps_lock_last) { // 如果shift和capslock任意被按下
c00049e1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00049e5:	75 06                	jne    c00049ed <intr_keyboard_handler+0x182>
/work/x86_os_my/device/keyboard.c:182 (discriminator 1)
c00049e7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c00049eb:	74 09                	je     c00049f6 <intr_keyboard_handler+0x18b>
/work/x86_os_my/device/keyboard.c:183
	    shift = true;
c00049ed:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c00049f4:	eb 07                	jmp    c00049fd <intr_keyboard_handler+0x192>
/work/x86_os_my/device/keyboard.c:185
	 } else {
	    shift = false;
c00049f6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/keyboard.c:189
	 }
      }

      uint8_t index = (scancode &= 0x00ff);  // 将扫描码的高字节置0,主要是针对高字节是e0的扫描码.
c00049fd:	66 81 65 f6 ff 00    	andw   $0xff,-0xa(%ebp)
c0004a03:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c0004a07:	88 45 d9             	mov    %al,-0x27(%ebp)
/work/x86_os_my/device/keyboard.c:190
      char cur_char = keymap[index][shift];  // 在数组中找到对应的字符
c0004a0a:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
c0004a0e:	8d 14 00             	lea    (%eax,%eax,1),%edx
c0004a11:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0004a14:	01 d0                	add    %edx,%eax
c0004a16:	05 e0 f0 00 c0       	add    $0xc000f0e0,%eax
c0004a1b:	0f b6 00             	movzbl (%eax),%eax
c0004a1e:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:193

   /* 如果cur_char不为0,也就是ascii码为除'\0'外的字符就加入键盘缓冲区中 */
      if (cur_char) {
c0004a21:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c0004a25:	74 54                	je     c0004a7b <intr_keyboard_handler+0x210>
/work/x86_os_my/device/keyboard.c:200
     /*****************  快捷键ctrl+l和ctrl+u的处理 *********************
      * 下面是把ctrl+l和ctrl+u这两种组合键产生的字符置为:
      * cur_char的asc码-字符a的asc码, 此差值比较小,
      * 属于asc码表中不可见的字符部分.故不会产生可见字符.
      * 我们在shell中将ascii值为l-a和u-a的分别处理为清屏和删除输入的快捷键*/
	 if ((ctrl_down_last && cur_char == 'l') || (ctrl_down_last && cur_char == 'u')) {
c0004a27:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0004a2b:	74 06                	je     c0004a33 <intr_keyboard_handler+0x1c8>
/work/x86_os_my/device/keyboard.c:200 (discriminator 1)
c0004a2d:	80 7d ef 6c          	cmpb   $0x6c,-0x11(%ebp)
c0004a31:	74 0c                	je     c0004a3f <intr_keyboard_handler+0x1d4>
/work/x86_os_my/device/keyboard.c:200 (discriminator 3)
c0004a33:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0004a37:	74 10                	je     c0004a49 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:200 (discriminator 4)
c0004a39:	80 7d ef 75          	cmpb   $0x75,-0x11(%ebp)
c0004a3d:	75 0a                	jne    c0004a49 <intr_keyboard_handler+0x1de>
/work/x86_os_my/device/keyboard.c:201
	    cur_char -= 'a';
c0004a3f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c0004a43:	83 e8 61             	sub    $0x61,%eax
c0004a46:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/device/keyboard.c:207
	 }
      /****************************************************************/
      
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
c0004a49:	83 ec 0c             	sub    $0xc,%esp
c0004a4c:	68 e0 fb 00 c0       	push   $0xc000fbe0
c0004a51:	e8 58 01 00 00       	call   c0004bae <ioq_full>
c0004a56:	83 c4 10             	add    $0x10,%esp
c0004a59:	85 c0                	test   %eax,%eax
c0004a5b:	0f 85 9c 00 00 00    	jne    c0004afd <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:208
	    ioq_putchar(&kbd_buf, cur_char);
c0004a61:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
c0004a65:	83 ec 08             	sub    $0x8,%esp
c0004a68:	50                   	push   %eax
c0004a69:	68 e0 fb 00 c0       	push   $0xc000fbe0
c0004a6e:	e8 0d 03 00 00       	call   c0004d80 <ioq_putchar>
c0004a73:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:210
	 }
	 return;
c0004a76:	e9 82 00 00 00       	jmp    c0004afd <intr_keyboard_handler+0x292>
/work/x86_os_my/device/keyboard.c:214
      }

      /* 记录本次是否按下了下面几类控制键之一,供下次键入时判断组合键 */
      if (scancode == ctrl_l_make || scancode == ctrl_r_make) {
c0004a7b:	66 83 7d f6 1d       	cmpw   $0x1d,-0xa(%ebp)
c0004a80:	74 08                	je     c0004a8a <intr_keyboard_handler+0x21f>
/work/x86_os_my/device/keyboard.c:214 (discriminator 1)
c0004a82:	66 81 7d f6 1d e0    	cmpw   $0xe01d,-0xa(%ebp)
c0004a88:	75 0c                	jne    c0004a96 <intr_keyboard_handler+0x22b>
/work/x86_os_my/device/keyboard.c:215
	 ctrl_status = true;
c0004a8a:	c7 05 8c f5 00 c0 01 	movl   $0x1,0xc000f58c
c0004a91:	00 00 00 
c0004a94:	eb 50                	jmp    c0004ae6 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:216
      } else if (scancode == shift_l_make || scancode == shift_r_make) {
c0004a96:	66 83 7d f6 2a       	cmpw   $0x2a,-0xa(%ebp)
c0004a9b:	74 07                	je     c0004aa4 <intr_keyboard_handler+0x239>
/work/x86_os_my/device/keyboard.c:216 (discriminator 1)
c0004a9d:	66 83 7d f6 36       	cmpw   $0x36,-0xa(%ebp)
c0004aa2:	75 0c                	jne    c0004ab0 <intr_keyboard_handler+0x245>
/work/x86_os_my/device/keyboard.c:217
	 shift_status = true;
c0004aa4:	c7 05 90 f5 00 c0 01 	movl   $0x1,0xc000f590
c0004aab:	00 00 00 
c0004aae:	eb 36                	jmp    c0004ae6 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:218
      } else if (scancode == alt_l_make || scancode == alt_r_make) {
c0004ab0:	66 83 7d f6 38       	cmpw   $0x38,-0xa(%ebp)
c0004ab5:	74 08                	je     c0004abf <intr_keyboard_handler+0x254>
/work/x86_os_my/device/keyboard.c:218 (discriminator 1)
c0004ab7:	66 81 7d f6 38 e0    	cmpw   $0xe038,-0xa(%ebp)
c0004abd:	75 0c                	jne    c0004acb <intr_keyboard_handler+0x260>
/work/x86_os_my/device/keyboard.c:219
	 alt_status = true;
c0004abf:	c7 05 94 f5 00 c0 01 	movl   $0x1,0xc000f594
c0004ac6:	00 00 00 
c0004ac9:	eb 1b                	jmp    c0004ae6 <intr_keyboard_handler+0x27b>
/work/x86_os_my/device/keyboard.c:220
      } else if (scancode == caps_lock_make) {
c0004acb:	66 83 7d f6 3a       	cmpw   $0x3a,-0xa(%ebp)
c0004ad0:	75 2e                	jne    c0004b00 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:223
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
c0004ad2:	a1 98 f5 00 c0       	mov    0xc000f598,%eax
c0004ad7:	85 c0                	test   %eax,%eax
c0004ad9:	0f 94 c0             	sete   %al
c0004adc:	0f b6 c0             	movzbl %al,%eax
c0004adf:	a3 98 f5 00 c0       	mov    %eax,0xc000f598
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c0004ae4:	eb 1a                	jmp    c0004b00 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:157 (discriminator 3)
c0004ae6:	eb 18                	jmp    c0004b00 <intr_keyboard_handler+0x295>
/work/x86_os_my/device/keyboard.c:226
      /* 不管之前是否有按下caps_lock键,当再次按下时则状态取反,
       * 即:已经开启时,再按下同样的键是关闭。关闭时按下表示开启。*/
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
c0004ae8:	83 ec 0c             	sub    $0xc,%esp
c0004aeb:	68 4d bd 00 c0       	push   $0xc000bd4d
c0004af0:	e8 7b d6 ff ff       	call   c0002170 <put_str>
c0004af5:	83 c4 10             	add    $0x10,%esp
c0004af8:	eb 07                	jmp    c0004b01 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:151
	 shift_status = false;
      } else if (make_code == alt_l_make || make_code == alt_r_make) {
	 alt_status = false;
      } /* 由于caps_lock不是弹起后关闭,所以需要单独处理 */

      return;   // 直接返回结束此次中断处理程序
c0004afa:	90                   	nop
c0004afb:	eb 04                	jmp    c0004b01 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:210
   /* 若kbd_buf中未满并且待加入的cur_char不为0,
    * 则将其加入到缓冲区kbd_buf中 */
	 if (!ioq_full(&kbd_buf)) {
	    ioq_putchar(&kbd_buf, cur_char);
	 }
	 return;
c0004afd:	90                   	nop
c0004afe:	eb 01                	jmp    c0004b01 <intr_keyboard_handler+0x296>
/work/x86_os_my/device/keyboard.c:157

   } 
   /* 若为通码,只处理数组中定义的键以及alt_right和ctrl键,全是make_code */
   else if ((scancode > 0x00 && scancode < 0x3b) || \
	       (scancode == alt_r_make) || \
	       (scancode == ctrl_r_make)) {
c0004b00:	90                   	nop
/work/x86_os_my/device/keyboard.c:228
	 caps_lock_status = !caps_lock_status;
      }
   } else {
      put_str("unknown key\n");
   }
}
c0004b01:	c9                   	leave  
c0004b02:	c3                   	ret    

c0004b03 <keyboard_init>:
keyboard_init():
/work/x86_os_my/device/keyboard.c:231

/* 键盘初始化 */
void keyboard_init() {
c0004b03:	55                   	push   %ebp
c0004b04:	89 e5                	mov    %esp,%ebp
c0004b06:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/keyboard.c:232
   put_str("keyboard init start\n");
c0004b09:	83 ec 0c             	sub    $0xc,%esp
c0004b0c:	68 5a bd 00 c0       	push   $0xc000bd5a
c0004b11:	e8 5a d6 ff ff       	call   c0002170 <put_str>
c0004b16:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:233
   ioqueue_init(&kbd_buf);
c0004b19:	83 ec 0c             	sub    $0xc,%esp
c0004b1c:	68 e0 fb 00 c0       	push   $0xc000fbe0
c0004b21:	e8 28 00 00 00       	call   c0004b4e <ioqueue_init>
c0004b26:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:234
   register_handler(0x21, intr_keyboard_handler);
c0004b29:	83 ec 08             	sub    $0x8,%esp
c0004b2c:	68 6b 48 00 c0       	push   $0xc000486b
c0004b31:	6a 21                	push   $0x21
c0004b33:	e8 71 ce ff ff       	call   c00019a9 <register_handler>
c0004b38:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:235
   put_str("keyboard init done\n");
c0004b3b:	83 ec 0c             	sub    $0xc,%esp
c0004b3e:	68 6f bd 00 c0       	push   $0xc000bd6f
c0004b43:	e8 28 d6 ff ff       	call   c0002170 <put_str>
c0004b48:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/keyboard.c:236
}
c0004b4b:	90                   	nop
c0004b4c:	c9                   	leave  
c0004b4d:	c3                   	ret    

c0004b4e <ioqueue_init>:
ioqueue_init():
/work/x86_os_my/device/ioqueue.c:7
#include "interrupt.h"
#include "global.h"
#include "debug.h"

/* 初始化io队列ioq */
void ioqueue_init(struct ioqueue* ioq) {
c0004b4e:	55                   	push   %ebp
c0004b4f:	89 e5                	mov    %esp,%ebp
c0004b51:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:8
   lock_init(&ioq->lock);     // 初始化io队列的锁
c0004b54:	8b 45 08             	mov    0x8(%ebp),%eax
c0004b57:	83 ec 0c             	sub    $0xc,%esp
c0004b5a:	50                   	push   %eax
c0004b5b:	e8 05 fa ff ff       	call   c0004565 <lock_init>
c0004b60:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:9
   ioq->producer = ioq->consumer = NULL;  // 生产者和消费者置空
c0004b63:	8b 45 08             	mov    0x8(%ebp),%eax
c0004b66:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c0004b6d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004b70:	8b 50 20             	mov    0x20(%eax),%edx
c0004b73:	8b 45 08             	mov    0x8(%ebp),%eax
c0004b76:	89 50 1c             	mov    %edx,0x1c(%eax)
/work/x86_os_my/device/ioqueue.c:10
   ioq->head = ioq->tail = 0; // 队列的首尾指针指向缓冲区数组第0个位置
c0004b79:	8b 45 08             	mov    0x8(%ebp),%eax
c0004b7c:	c7 40 68 00 00 00 00 	movl   $0x0,0x68(%eax)
c0004b83:	8b 45 08             	mov    0x8(%ebp),%eax
c0004b86:	8b 50 68             	mov    0x68(%eax),%edx
c0004b89:	8b 45 08             	mov    0x8(%ebp),%eax
c0004b8c:	89 50 64             	mov    %edx,0x64(%eax)
/work/x86_os_my/device/ioqueue.c:11
}
c0004b8f:	90                   	nop
c0004b90:	c9                   	leave  
c0004b91:	c3                   	ret    

c0004b92 <next_pos>:
next_pos():
/work/x86_os_my/device/ioqueue.c:14

/* 返回pos在缓冲区中的下一个位置值 */
static int32_t next_pos(int32_t pos) {
c0004b92:	55                   	push   %ebp
c0004b93:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/device/ioqueue.c:15
   return (pos + 1) % bufsize; 
c0004b95:	8b 45 08             	mov    0x8(%ebp),%eax
c0004b98:	8d 50 01             	lea    0x1(%eax),%edx
c0004b9b:	89 d0                	mov    %edx,%eax
c0004b9d:	c1 f8 1f             	sar    $0x1f,%eax
c0004ba0:	c1 e8 1a             	shr    $0x1a,%eax
c0004ba3:	01 c2                	add    %eax,%edx
c0004ba5:	83 e2 3f             	and    $0x3f,%edx
c0004ba8:	29 c2                	sub    %eax,%edx
c0004baa:	89 d0                	mov    %edx,%eax
/work/x86_os_my/device/ioqueue.c:16
}
c0004bac:	5d                   	pop    %ebp
c0004bad:	c3                   	ret    

c0004bae <ioq_full>:
ioq_full():
/work/x86_os_my/device/ioqueue.c:19

/* 判断队列是否已满 */
bool ioq_full(struct ioqueue* ioq) {
c0004bae:	55                   	push   %ebp
c0004baf:	89 e5                	mov    %esp,%ebp
c0004bb1:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:20
   ASSERT(intr_get_status() == INTR_OFF);
c0004bb4:	e8 cc cd ff ff       	call   c0001985 <intr_get_status>
c0004bb9:	85 c0                	test   %eax,%eax
c0004bbb:	74 19                	je     c0004bd6 <ioq_full+0x28>
/work/x86_os_my/device/ioqueue.c:20 (discriminator 1)
c0004bbd:	68 84 bd 00 c0       	push   $0xc000bd84
c0004bc2:	68 e8 bd 00 c0       	push   $0xc000bde8
c0004bc7:	6a 14                	push   $0x14
c0004bc9:	68 a2 bd 00 c0       	push   $0xc000bda2
c0004bce:	e8 0f d7 ff ff       	call   c00022e2 <panic_spin>
c0004bd3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:21
   return next_pos(ioq->head) == ioq->tail;
c0004bd6:	8b 45 08             	mov    0x8(%ebp),%eax
c0004bd9:	8b 40 64             	mov    0x64(%eax),%eax
c0004bdc:	83 ec 0c             	sub    $0xc,%esp
c0004bdf:	50                   	push   %eax
c0004be0:	e8 ad ff ff ff       	call   c0004b92 <next_pos>
c0004be5:	83 c4 10             	add    $0x10,%esp
c0004be8:	89 c2                	mov    %eax,%edx
c0004bea:	8b 45 08             	mov    0x8(%ebp),%eax
c0004bed:	8b 40 68             	mov    0x68(%eax),%eax
c0004bf0:	39 c2                	cmp    %eax,%edx
c0004bf2:	0f 94 c0             	sete   %al
c0004bf5:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:22
}
c0004bf8:	c9                   	leave  
c0004bf9:	c3                   	ret    

c0004bfa <ioq_empty>:
ioq_empty():
/work/x86_os_my/device/ioqueue.c:25

/* 判断队列是否已空 */
static bool ioq_empty(struct ioqueue* ioq) {
c0004bfa:	55                   	push   %ebp
c0004bfb:	89 e5                	mov    %esp,%ebp
c0004bfd:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:26
   ASSERT(intr_get_status() == INTR_OFF);
c0004c00:	e8 80 cd ff ff       	call   c0001985 <intr_get_status>
c0004c05:	85 c0                	test   %eax,%eax
c0004c07:	74 19                	je     c0004c22 <ioq_empty+0x28>
/work/x86_os_my/device/ioqueue.c:26 (discriminator 1)
c0004c09:	68 84 bd 00 c0       	push   $0xc000bd84
c0004c0e:	68 f4 bd 00 c0       	push   $0xc000bdf4
c0004c13:	6a 1a                	push   $0x1a
c0004c15:	68 a2 bd 00 c0       	push   $0xc000bda2
c0004c1a:	e8 c3 d6 ff ff       	call   c00022e2 <panic_spin>
c0004c1f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:27
   return ioq->head == ioq->tail;
c0004c22:	8b 45 08             	mov    0x8(%ebp),%eax
c0004c25:	8b 50 64             	mov    0x64(%eax),%edx
c0004c28:	8b 45 08             	mov    0x8(%ebp),%eax
c0004c2b:	8b 40 68             	mov    0x68(%eax),%eax
c0004c2e:	39 c2                	cmp    %eax,%edx
c0004c30:	0f 94 c0             	sete   %al
c0004c33:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/device/ioqueue.c:28
}
c0004c36:	c9                   	leave  
c0004c37:	c3                   	ret    

c0004c38 <ioq_wait>:
ioq_wait():
/work/x86_os_my/device/ioqueue.c:31

/* 使当前生产者或消费者在此缓冲区上等待 */
static void ioq_wait(struct task_struct** waiter) {
c0004c38:	55                   	push   %ebp
c0004c39:	89 e5                	mov    %esp,%ebp
c0004c3b:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:32
   ASSERT(*waiter == NULL && waiter != NULL);
c0004c3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004c41:	8b 00                	mov    (%eax),%eax
c0004c43:	85 c0                	test   %eax,%eax
c0004c45:	75 06                	jne    c0004c4d <ioq_wait+0x15>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 1)
c0004c47:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0004c4b:	75 19                	jne    c0004c66 <ioq_wait+0x2e>
/work/x86_os_my/device/ioqueue.c:32 (discriminator 3)
c0004c4d:	68 b4 bd 00 c0       	push   $0xc000bdb4
c0004c52:	68 00 be 00 c0       	push   $0xc000be00
c0004c57:	6a 20                	push   $0x20
c0004c59:	68 a2 bd 00 c0       	push   $0xc000bda2
c0004c5e:	e8 7f d6 ff ff       	call   c00022e2 <panic_spin>
c0004c63:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:33
   *waiter = running_thread();
c0004c66:	e8 00 ef ff ff       	call   c0003b6b <running_thread>
c0004c6b:	89 c2                	mov    %eax,%edx
c0004c6d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004c70:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ioqueue.c:34
   thread_block(TASK_BLOCKED);
c0004c72:	83 ec 0c             	sub    $0xc,%esp
c0004c75:	6a 02                	push   $0x2
c0004c77:	e8 92 f3 ff ff       	call   c000400e <thread_block>
c0004c7c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:35
}
c0004c7f:	90                   	nop
c0004c80:	c9                   	leave  
c0004c81:	c3                   	ret    

c0004c82 <wakeup>:
wakeup():
/work/x86_os_my/device/ioqueue.c:38

/* 唤醒waiter */
static void wakeup(struct task_struct** waiter) {
c0004c82:	55                   	push   %ebp
c0004c83:	89 e5                	mov    %esp,%ebp
c0004c85:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/device/ioqueue.c:39
   ASSERT(*waiter != NULL);
c0004c88:	8b 45 08             	mov    0x8(%ebp),%eax
c0004c8b:	8b 00                	mov    (%eax),%eax
c0004c8d:	85 c0                	test   %eax,%eax
c0004c8f:	75 19                	jne    c0004caa <wakeup+0x28>
/work/x86_os_my/device/ioqueue.c:39 (discriminator 1)
c0004c91:	68 d6 bd 00 c0       	push   $0xc000bdd6
c0004c96:	68 0c be 00 c0       	push   $0xc000be0c
c0004c9b:	6a 27                	push   $0x27
c0004c9d:	68 a2 bd 00 c0       	push   $0xc000bda2
c0004ca2:	e8 3b d6 ff ff       	call   c00022e2 <panic_spin>
c0004ca7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:40
   thread_unblock(*waiter); 
c0004caa:	8b 45 08             	mov    0x8(%ebp),%eax
c0004cad:	8b 00                	mov    (%eax),%eax
c0004caf:	83 ec 0c             	sub    $0xc,%esp
c0004cb2:	50                   	push   %eax
c0004cb3:	e8 b9 f3 ff ff       	call   c0004071 <thread_unblock>
c0004cb8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:41
   *waiter = NULL;
c0004cbb:	8b 45 08             	mov    0x8(%ebp),%eax
c0004cbe:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/device/ioqueue.c:42
}
c0004cc4:	90                   	nop
c0004cc5:	c9                   	leave  
c0004cc6:	c3                   	ret    

c0004cc7 <ioq_getchar>:
ioq_getchar():
/work/x86_os_my/device/ioqueue.c:45

/* 消费者从ioq队列中获取一个字符 */
char ioq_getchar(struct ioqueue* ioq) {
c0004cc7:	55                   	push   %ebp
c0004cc8:	89 e5                	mov    %esp,%ebp
c0004cca:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ioqueue.c:46
   ASSERT(intr_get_status() == INTR_OFF);
c0004ccd:	e8 b3 cc ff ff       	call   c0001985 <intr_get_status>
c0004cd2:	85 c0                	test   %eax,%eax
c0004cd4:	74 4b                	je     c0004d21 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:46 (discriminator 1)
c0004cd6:	68 84 bd 00 c0       	push   $0xc000bd84
c0004cdb:	68 14 be 00 c0       	push   $0xc000be14
c0004ce0:	6a 2e                	push   $0x2e
c0004ce2:	68 a2 bd 00 c0       	push   $0xc000bda2
c0004ce7:	e8 f6 d5 ff ff       	call   c00022e2 <panic_spin>
c0004cec:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51 (discriminator 1)

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c0004cef:	eb 30                	jmp    c0004d21 <ioq_getchar+0x5a>
/work/x86_os_my/device/ioqueue.c:52
      lock_acquire(&ioq->lock);	 
c0004cf1:	8b 45 08             	mov    0x8(%ebp),%eax
c0004cf4:	83 ec 0c             	sub    $0xc,%esp
c0004cf7:	50                   	push   %eax
c0004cf8:	e8 42 fa ff ff       	call   c000473f <lock_acquire>
c0004cfd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:53
      ioq_wait(&ioq->consumer);
c0004d00:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d03:	83 c0 20             	add    $0x20,%eax
c0004d06:	83 ec 0c             	sub    $0xc,%esp
c0004d09:	50                   	push   %eax
c0004d0a:	e8 29 ff ff ff       	call   c0004c38 <ioq_wait>
c0004d0f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:54
      lock_release(&ioq->lock);
c0004d12:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d15:	83 ec 0c             	sub    $0xc,%esp
c0004d18:	50                   	push   %eax
c0004d19:	e8 98 fa ff ff       	call   c00047b6 <lock_release>
c0004d1e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:51
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)为空,把消费者ioq->consumer记为当前线程自己,
 * 目的是将来生产者往缓冲区里装商品后,生产者知道唤醒哪个消费者,
 * 也就是唤醒当前线程自己*/
   while (ioq_empty(ioq)) {
c0004d21:	83 ec 0c             	sub    $0xc,%esp
c0004d24:	ff 75 08             	pushl  0x8(%ebp)
c0004d27:	e8 ce fe ff ff       	call   c0004bfa <ioq_empty>
c0004d2c:	83 c4 10             	add    $0x10,%esp
c0004d2f:	85 c0                	test   %eax,%eax
c0004d31:	75 be                	jne    c0004cf1 <ioq_getchar+0x2a>
/work/x86_os_my/device/ioqueue.c:57
      lock_acquire(&ioq->lock);	 
      ioq_wait(&ioq->consumer);
      lock_release(&ioq->lock);
   }

   char byte = ioq->buf[ioq->tail];	  // 从缓冲区中取出
c0004d33:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d36:	8b 40 68             	mov    0x68(%eax),%eax
c0004d39:	8b 55 08             	mov    0x8(%ebp),%edx
c0004d3c:	0f b6 44 02 24       	movzbl 0x24(%edx,%eax,1),%eax
c0004d41:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ioqueue.c:58
   ioq->tail = next_pos(ioq->tail);	  // 把读游标移到下一位置
c0004d44:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d47:	8b 40 68             	mov    0x68(%eax),%eax
c0004d4a:	83 ec 0c             	sub    $0xc,%esp
c0004d4d:	50                   	push   %eax
c0004d4e:	e8 3f fe ff ff       	call   c0004b92 <next_pos>
c0004d53:	83 c4 10             	add    $0x10,%esp
c0004d56:	89 c2                	mov    %eax,%edx
c0004d58:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d5b:	89 50 68             	mov    %edx,0x68(%eax)
/work/x86_os_my/device/ioqueue.c:60

   if (ioq->producer != NULL) {
c0004d5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d61:	8b 40 1c             	mov    0x1c(%eax),%eax
c0004d64:	85 c0                	test   %eax,%eax
c0004d66:	74 12                	je     c0004d7a <ioq_getchar+0xb3>
/work/x86_os_my/device/ioqueue.c:61
      wakeup(&ioq->producer);		  // 唤醒生产者
c0004d68:	8b 45 08             	mov    0x8(%ebp),%eax
c0004d6b:	83 c0 1c             	add    $0x1c,%eax
c0004d6e:	83 ec 0c             	sub    $0xc,%esp
c0004d71:	50                   	push   %eax
c0004d72:	e8 0b ff ff ff       	call   c0004c82 <wakeup>
c0004d77:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:64
   }

   return byte; 
c0004d7a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
/work/x86_os_my/device/ioqueue.c:65
}
c0004d7e:	c9                   	leave  
c0004d7f:	c3                   	ret    

c0004d80 <ioq_putchar>:
ioq_putchar():
/work/x86_os_my/device/ioqueue.c:68

/* 生产者往ioq队列中写入一个字符byte */
void ioq_putchar(struct ioqueue* ioq, char byte) {
c0004d80:	55                   	push   %ebp
c0004d81:	89 e5                	mov    %esp,%ebp
c0004d83:	83 ec 18             	sub    $0x18,%esp
c0004d86:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004d89:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/device/ioqueue.c:69
   ASSERT(intr_get_status() == INTR_OFF);
c0004d8c:	e8 f4 cb ff ff       	call   c0001985 <intr_get_status>
c0004d91:	85 c0                	test   %eax,%eax
c0004d93:	74 4b                	je     c0004de0 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:69 (discriminator 1)
c0004d95:	68 84 bd 00 c0       	push   $0xc000bd84
c0004d9a:	68 20 be 00 c0       	push   $0xc000be20
c0004d9f:	6a 45                	push   $0x45
c0004da1:	68 a2 bd 00 c0       	push   $0xc000bda2
c0004da6:	e8 37 d5 ff ff       	call   c00022e2 <panic_spin>
c0004dab:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74 (discriminator 1)

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c0004dae:	eb 30                	jmp    c0004de0 <ioq_putchar+0x60>
/work/x86_os_my/device/ioqueue.c:75
      lock_acquire(&ioq->lock);
c0004db0:	8b 45 08             	mov    0x8(%ebp),%eax
c0004db3:	83 ec 0c             	sub    $0xc,%esp
c0004db6:	50                   	push   %eax
c0004db7:	e8 83 f9 ff ff       	call   c000473f <lock_acquire>
c0004dbc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:76
      ioq_wait(&ioq->producer);
c0004dbf:	8b 45 08             	mov    0x8(%ebp),%eax
c0004dc2:	83 c0 1c             	add    $0x1c,%eax
c0004dc5:	83 ec 0c             	sub    $0xc,%esp
c0004dc8:	50                   	push   %eax
c0004dc9:	e8 6a fe ff ff       	call   c0004c38 <ioq_wait>
c0004dce:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:77
      lock_release(&ioq->lock);
c0004dd1:	8b 45 08             	mov    0x8(%ebp),%eax
c0004dd4:	83 ec 0c             	sub    $0xc,%esp
c0004dd7:	50                   	push   %eax
c0004dd8:	e8 d9 f9 ff ff       	call   c00047b6 <lock_release>
c0004ddd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:74
   ASSERT(intr_get_status() == INTR_OFF);

/* 若缓冲区(队列)已经满了,把生产者ioq->producer记为自己,
 * 为的是当缓冲区里的东西被消费者取完后让消费者知道唤醒哪个生产者,
 * 也就是唤醒当前线程自己*/
   while (ioq_full(ioq)) {
c0004de0:	83 ec 0c             	sub    $0xc,%esp
c0004de3:	ff 75 08             	pushl  0x8(%ebp)
c0004de6:	e8 c3 fd ff ff       	call   c0004bae <ioq_full>
c0004deb:	83 c4 10             	add    $0x10,%esp
c0004dee:	85 c0                	test   %eax,%eax
c0004df0:	75 be                	jne    c0004db0 <ioq_putchar+0x30>
/work/x86_os_my/device/ioqueue.c:79
      lock_acquire(&ioq->lock);
      ioq_wait(&ioq->producer);
      lock_release(&ioq->lock);
   }
   ioq->buf[ioq->head] = byte;      // 把字节放入缓冲区中
c0004df2:	8b 45 08             	mov    0x8(%ebp),%eax
c0004df5:	8b 40 64             	mov    0x64(%eax),%eax
c0004df8:	8b 55 08             	mov    0x8(%ebp),%edx
c0004dfb:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
c0004dff:	88 4c 02 24          	mov    %cl,0x24(%edx,%eax,1)
/work/x86_os_my/device/ioqueue.c:80
   ioq->head = next_pos(ioq->head); // 把写游标移到下一位置
c0004e03:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e06:	8b 40 64             	mov    0x64(%eax),%eax
c0004e09:	83 ec 0c             	sub    $0xc,%esp
c0004e0c:	50                   	push   %eax
c0004e0d:	e8 80 fd ff ff       	call   c0004b92 <next_pos>
c0004e12:	83 c4 10             	add    $0x10,%esp
c0004e15:	89 c2                	mov    %eax,%edx
c0004e17:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e1a:	89 50 64             	mov    %edx,0x64(%eax)
/work/x86_os_my/device/ioqueue.c:82

   if (ioq->consumer != NULL) {
c0004e1d:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e20:	8b 40 20             	mov    0x20(%eax),%eax
c0004e23:	85 c0                	test   %eax,%eax
c0004e25:	74 12                	je     c0004e39 <ioq_putchar+0xb9>
/work/x86_os_my/device/ioqueue.c:83
      wakeup(&ioq->consumer);          // 唤醒消费者
c0004e27:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e2a:	83 c0 20             	add    $0x20,%eax
c0004e2d:	83 ec 0c             	sub    $0xc,%esp
c0004e30:	50                   	push   %eax
c0004e31:	e8 4c fe ff ff       	call   c0004c82 <wakeup>
c0004e36:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ioqueue.c:85
   }
}
c0004e39:	90                   	nop
c0004e3a:	c9                   	leave  
c0004e3b:	c3                   	ret    

c0004e3c <update_tss_esp>:
update_tss_esp():
/work/x86_os_my/userprog/tss.c:40
	uint32_t io_base;
}; 
static struct tss g_tss;

/* 更新tss中esp0字段的值为pthread的0级栈 */
void update_tss_esp(struct task_struct* pthread) {
c0004e3c:	55                   	push   %ebp
c0004e3d:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/userprog/tss.c:41
	g_tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c0004e3f:	8b 45 08             	mov    0x8(%ebp),%eax
c0004e42:	05 00 10 00 00       	add    $0x1000,%eax
c0004e47:	a3 a4 f5 00 c0       	mov    %eax,0xc000f5a4
/work/x86_os_my/userprog/tss.c:42
}
c0004e4c:	90                   	nop
c0004e4d:	5d                   	pop    %ebp
c0004e4e:	c3                   	ret    

c0004e4f <make_gdt_desc>:
make_gdt_desc():
/work/x86_os_my/userprog/tss.c:45

/* c语言方式，创建gdt描述符 */
static struct gdt_desc make_gdt_desc(uint32_t* desc_addr, uint32_t limit, uint8_t attr_low, uint8_t attr_high) {
c0004e4f:	55                   	push   %ebp
c0004e50:	89 e5                	mov    %esp,%ebp
c0004e52:	83 ec 18             	sub    $0x18,%esp
c0004e55:	8b 55 14             	mov    0x14(%ebp),%edx
c0004e58:	8b 45 18             	mov    0x18(%ebp),%eax
c0004e5b:	88 55 ec             	mov    %dl,-0x14(%ebp)
c0004e5e:	88 45 e8             	mov    %al,-0x18(%ebp)
/work/x86_os_my/userprog/tss.c:46
	uint32_t desc_base = (uint32_t)desc_addr;
c0004e61:	8b 45 0c             	mov    0xc(%ebp),%eax
c0004e64:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/userprog/tss.c:48
	struct gdt_desc desc;
	desc.limit_low_word = limit & 0x0000ffff;
c0004e67:	8b 45 10             	mov    0x10(%ebp),%eax
c0004e6a:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/userprog/tss.c:49
	desc.base_low_word = desc_base & 0x0000ffff;
c0004e6e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004e71:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
/work/x86_os_my/userprog/tss.c:50
	desc.base_mid_byte = ((desc_base & 0x00ff0000) >> 16);
c0004e75:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004e78:	25 00 00 ff 00       	and    $0xff0000,%eax
c0004e7d:	c1 e8 10             	shr    $0x10,%eax
c0004e80:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/userprog/tss.c:51
	desc.attr_low_byte = (uint8_t)(attr_low);
c0004e83:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0004e87:	88 45 f9             	mov    %al,-0x7(%ebp)
/work/x86_os_my/userprog/tss.c:52
	desc.limit_high_attr_high = (((limit & 0x000f0000) >> 16) + (uint8_t)(attr_high));
c0004e8a:	8b 45 10             	mov    0x10(%ebp),%eax
c0004e8d:	25 00 00 0f 00       	and    $0xf0000,%eax
c0004e92:	c1 e8 10             	shr    $0x10,%eax
c0004e95:	89 c2                	mov    %eax,%edx
c0004e97:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
c0004e9b:	01 d0                	add    %edx,%eax
c0004e9d:	88 45 fa             	mov    %al,-0x6(%ebp)
/work/x86_os_my/userprog/tss.c:53
	desc.base_high_byte = desc_base >> 24;
c0004ea0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0004ea3:	c1 e8 18             	shr    $0x18,%eax
c0004ea6:	88 45 fb             	mov    %al,-0x5(%ebp)
/work/x86_os_my/userprog/tss.c:54
	return desc;
c0004ea9:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0004eac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004eaf:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0004eb2:	89 01                	mov    %eax,(%ecx)
c0004eb4:	89 51 04             	mov    %edx,0x4(%ecx)
/work/x86_os_my/userprog/tss.c:55
}
c0004eb7:	8b 45 08             	mov    0x8(%ebp),%eax
c0004eba:	c9                   	leave  
c0004ebb:	c2 04 00             	ret    $0x4

c0004ebe <tss_init>:
tss_init():
/work/x86_os_my/userprog/tss.c:61

/* 在gdt中创建tss描述符
 * 重新加载 gdt
 * 加载 tr
 */
void tss_init() {
c0004ebe:	55                   	push   %ebp
c0004ebf:	89 e5                	mov    %esp,%ebp
c0004ec1:	53                   	push   %ebx
c0004ec2:	83 ec 24             	sub    $0x24,%esp
/work/x86_os_my/userprog/tss.c:62
	put_str("tss_init start\n");
c0004ec5:	83 ec 0c             	sub    $0xc,%esp
c0004ec8:	68 2c be 00 c0       	push   $0xc000be2c
c0004ecd:	e8 9e d2 ff ff       	call   c0002170 <put_str>
c0004ed2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:63
	uint32_t tss_size = sizeof(g_tss);
c0004ed5:	c7 45 f4 6c 00 00 00 	movl   $0x6c,-0xc(%ebp)
/work/x86_os_my/userprog/tss.c:64
	memset(&g_tss, 0, tss_size);
c0004edc:	83 ec 04             	sub    $0x4,%esp
c0004edf:	ff 75 f4             	pushl  -0xc(%ebp)
c0004ee2:	6a 00                	push   $0x0
c0004ee4:	68 a0 f5 00 c0       	push   $0xc000f5a0
c0004ee9:	e8 96 e8 ff ff       	call   c0003784 <memset>
c0004eee:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:66
	
	g_tss.ss0 = SELECTOR_K_STACK;	// 0 级栈段的选择子 
c0004ef1:	c7 05 a8 f5 00 c0 10 	movl   $0x10,0xc000f5a8
c0004ef8:	00 00 00 
/work/x86_os_my/userprog/tss.c:67
	g_tss.io_base = tss_size;		// 当 IO 位图的偏移地址大于等于 TSS 大小减 1 时，就表示没有 IO 位图。
c0004efb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004efe:	a3 08 f6 00 c0       	mov    %eax,0xc000f608
/work/x86_os_my/userprog/tss.c:75
	 * 内核地址 0xC000_0900 是映射到 0x900 的 
	 * 在GDT中，第 0 个段描述符不可用，第 1 个为代码段，第 2 个为数据段和栈，第 3 个为显存段
	 */

	/* 在gdt中添加dpl为0的TSS描述符 */
	*((struct gdt_desc*)0xc0000920) = make_gdt_desc((uint32_t*)&g_tss, tss_size - 1, TSS_ATTR_LOW, TSS_ATTR_HIGH);
c0004f03:	bb 20 09 00 c0       	mov    $0xc0000920,%ebx
c0004f08:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0004f0b:	8d 50 ff             	lea    -0x1(%eax),%edx
c0004f0e:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0004f11:	83 ec 0c             	sub    $0xc,%esp
c0004f14:	68 80 00 00 00       	push   $0x80
c0004f19:	68 89 00 00 00       	push   $0x89
c0004f1e:	52                   	push   %edx
c0004f1f:	68 a0 f5 00 c0       	push   $0xc000f5a0
c0004f24:	50                   	push   %eax
c0004f25:	e8 25 ff ff ff       	call   c0004e4f <make_gdt_desc>
c0004f2a:	83 c4 1c             	add    $0x1c,%esp
c0004f2d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0004f30:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0004f33:	89 03                	mov    %eax,(%ebx)
c0004f35:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:78

	/* 在gdt中添加dpl为3的,用户级,数据段和代码段描述符 */
	*((struct gdt_desc*)0xc0000928) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_CODE_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
c0004f38:	bb 28 09 00 c0       	mov    $0xc0000928,%ebx
c0004f3d:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0004f40:	83 ec 0c             	sub    $0xc,%esp
c0004f43:	68 c0 00 00 00       	push   $0xc0
c0004f48:	68 f8 00 00 00       	push   $0xf8
c0004f4d:	68 ff ff 0f 00       	push   $0xfffff
c0004f52:	6a 00                	push   $0x0
c0004f54:	50                   	push   %eax
c0004f55:	e8 f5 fe ff ff       	call   c0004e4f <make_gdt_desc>
c0004f5a:	83 c4 1c             	add    $0x1c,%esp
c0004f5d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0004f60:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0004f63:	89 03                	mov    %eax,(%ebx)
c0004f65:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:79
	*((struct gdt_desc*)0xc0000930) = make_gdt_desc((uint32_t*)0, 0xfffff, GDT_DATA_ATTR_LOW_DPL3, GDT_ATTR_HIGH);
c0004f68:	bb 30 09 00 c0       	mov    $0xc0000930,%ebx
c0004f6d:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0004f70:	83 ec 0c             	sub    $0xc,%esp
c0004f73:	68 c0 00 00 00       	push   $0xc0
c0004f78:	68 f2 00 00 00       	push   $0xf2
c0004f7d:	68 ff ff 0f 00       	push   $0xfffff
c0004f82:	6a 00                	push   $0x0
c0004f84:	50                   	push   %eax
c0004f85:	e8 c5 fe ff ff       	call   c0004e4f <make_gdt_desc>
c0004f8a:	83 c4 1c             	add    $0x1c,%esp
c0004f8d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0004f90:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0004f93:	89 03                	mov    %eax,(%ebx)
c0004f95:	89 53 04             	mov    %edx,0x4(%ebx)
/work/x86_os_my/userprog/tss.c:83

	/* GDTR 16位的limit、32位的段基址 */
	// 先转换成 uint32_t 后，再将其转换成 uint64_t 位（不可一步到位转为 uint64_t）
	uint64_t gdt_operand = ((8 * 7 - 1) | ((uint64_t)(uint32_t)0xc0000900 << 16));   // 7个描述符大小
c0004f98:	c7 45 e8 37 00 00 09 	movl   $0x9000037,-0x18(%ebp)
c0004f9f:	c7 45 ec 00 c0 00 00 	movl   $0xc000,-0x14(%ebp)
/work/x86_os_my/userprog/tss.c:84
	asm volatile ("lgdt %0" : : "m" (gdt_operand));
c0004fa6:	0f 01 55 e8          	lgdtl  -0x18(%ebp)
/work/x86_os_my/userprog/tss.c:85
	asm volatile ("ltr %w0" : : "r" (SELECTOR_TSS));
c0004faa:	b8 20 00 00 00       	mov    $0x20,%eax
c0004faf:	0f 00 d8             	ltr    %ax
/work/x86_os_my/userprog/tss.c:86
	put_str("tss_init and ltr done\n");
c0004fb2:	83 ec 0c             	sub    $0xc,%esp
c0004fb5:	68 3c be 00 c0       	push   $0xc000be3c
c0004fba:	e8 b1 d1 ff ff       	call   c0002170 <put_str>
c0004fbf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/tss.c:87
}
c0004fc2:	90                   	nop
c0004fc3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0004fc6:	c9                   	leave  
c0004fc7:	c3                   	ret    

c0004fc8 <start_process>:
start_process():
/work/x86_os_my/userprog/process.c:17
extern void intr_exit(void);

/* 构建用户进程初始上下文信息
 * 填充用户进程的中断栈，并将中断栈的信息，利用iretd填充到 CPU 中
 */
void start_process(void* filename_) {
c0004fc8:	55                   	push   %ebp
c0004fc9:	89 e5                	mov    %esp,%ebp
c0004fcb:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:18
	void* function = filename_;
c0004fce:	8b 45 08             	mov    0x8(%ebp),%eax
c0004fd1:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:19
	struct task_struct* cur = running_thread();
c0004fd4:	e8 92 eb ff ff       	call   c0003b6b <running_thread>
c0004fd9:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:20
	cur->self_kstack += sizeof(struct thread_stack);
c0004fdc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0004fdf:	8b 00                	mov    (%eax),%eax
c0004fe1:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
c0004fe7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0004fea:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/process.c:21
	struct intr_stack* proc_stack = (struct intr_stack*)cur->self_kstack;	 
c0004fec:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0004fef:	8b 00                	mov    (%eax),%eax
c0004ff1:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/userprog/process.c:22
	proc_stack->edi = proc_stack->esi = proc_stack->ebp = proc_stack->esp_dummy = 0;
c0004ff4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0004ff7:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
c0004ffe:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005001:	8b 50 10             	mov    0x10(%eax),%edx
c0005004:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005007:	89 50 0c             	mov    %edx,0xc(%eax)
c000500a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000500d:	8b 50 0c             	mov    0xc(%eax),%edx
c0005010:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005013:	89 50 08             	mov    %edx,0x8(%eax)
c0005016:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005019:	8b 50 08             	mov    0x8(%eax),%edx
c000501c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000501f:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/userprog/process.c:23
	proc_stack->ebx = proc_stack->edx = proc_stack->ecx = proc_stack->eax = 0;
c0005022:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005025:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
c000502c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000502f:	8b 50 20             	mov    0x20(%eax),%edx
c0005032:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005035:	89 50 1c             	mov    %edx,0x1c(%eax)
c0005038:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000503b:	8b 50 1c             	mov    0x1c(%eax),%edx
c000503e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005041:	89 50 18             	mov    %edx,0x18(%eax)
c0005044:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005047:	8b 50 18             	mov    0x18(%eax),%edx
c000504a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000504d:	89 50 14             	mov    %edx,0x14(%eax)
/work/x86_os_my/userprog/process.c:28
	/* 在iretd返回时，如果发现未来的 CPL（也就是内核栈中 CS.RPL，或者说是返回到的用户进程的代码段CS.CPL）
	 * 权限低于（数值上大于） CPU 中段寄存器（如 DS、 ES、 FS、 GS）中选择子指向的内存段的 DPL，
	 * CPU 会自动将相应段寄存器的选择子置为 0 
	 * 这里gs的选择子在iretd返回后，会被自动清零。*/
	proc_stack->gs = 0;					// 用户态用不上,直接初始为0
c0005050:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005053:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
/work/x86_os_my/userprog/process.c:29
	proc_stack->ds = proc_stack->es = proc_stack->fs = SELECTOR_U_DATA;		// 用户级数据段
c000505a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000505d:	c7 40 28 33 00 00 00 	movl   $0x33,0x28(%eax)
c0005064:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005067:	8b 50 28             	mov    0x28(%eax),%edx
c000506a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000506d:	89 50 2c             	mov    %edx,0x2c(%eax)
c0005070:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005073:	8b 50 2c             	mov    0x2c(%eax),%edx
c0005076:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005079:	89 50 30             	mov    %edx,0x30(%eax)
/work/x86_os_my/userprog/process.c:33

	/* 中断栈中，上边几个是中断处理函数手动压栈的，下边几个是硬件自动压栈的 */

	proc_stack->eip = function;			// 待执行的用户程序地址
c000507c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000507f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005082:	89 50 38             	mov    %edx,0x38(%eax)
/work/x86_os_my/userprog/process.c:34
	proc_stack->cs = SELECTOR_U_CODE;	// 用户级代码段
c0005085:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005088:	c7 40 3c 2b 00 00 00 	movl   $0x2b,0x3c(%eax)
/work/x86_os_my/userprog/process.c:35
	proc_stack->eflags = (EFLAGS_IOPL_0 | EFLAGS_MBS | EFLAGS_IF_1);
c000508f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005092:	c7 40 40 02 02 00 00 	movl   $0x202,0x40(%eax)
/work/x86_os_my/userprog/process.c:44
	 * process_activate 使用户进程页表生效【已经把CR3寄存器 更新为 用户进程的页表了】
	 * start_process    为用户进程创建3特权级栈【所以申请的内存空间来自用户进程的页表】
	 * 
	 * USER_STACK3_VADDR=(0xc0000000 - 0x1000)
	 */
	proc_stack->esp = (void*)((uint32_t)get_a_page(PF_USER, USER_STACK3_VADDR) + PG_SIZE) ;
c0005099:	83 ec 08             	sub    $0x8,%esp
c000509c:	68 00 f0 ff bf       	push   $0xbffff000
c00050a1:	6a 02                	push   $0x2
c00050a3:	e8 98 d9 ff ff       	call   c0002a40 <get_a_page>
c00050a8:	83 c4 10             	add    $0x10,%esp
c00050ab:	05 00 10 00 00       	add    $0x1000,%eax
c00050b0:	89 c2                	mov    %eax,%edx
c00050b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00050b5:	89 50 44             	mov    %edx,0x44(%eax)
/work/x86_os_my/userprog/process.c:45
	proc_stack->ss = SELECTOR_U_DATA;
c00050b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00050bb:	c7 40 48 33 00 00 00 	movl   $0x33,0x48(%eax)
/work/x86_os_my/userprog/process.c:52
	/* 将 esp 替换为 proc_stack
	 * 通过 jmp intr_exit 那里的一系列 pop 指令和 iretd 指令，
	 * 将 proc_stack 中的数据载入 CPU 的寄存器，
	 * 从而使程序“假装”退出中断，进入特权级 3
	 */
	asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (proc_stack) : "memory");
c00050c2:	8b 65 ec             	mov    -0x14(%ebp),%esp
c00050c5:	e9 46 cb ff ff       	jmp    c0001c10 <intr_exit>
/work/x86_os_my/userprog/process.c:53
}
c00050ca:	90                   	nop
c00050cb:	c9                   	leave  
c00050cc:	c3                   	ret    

c00050cd <page_dir_activate>:
page_dir_activate():
/work/x86_os_my/userprog/process.c:56

/* 更新CR3寄存器，激活页目录表 */
void page_dir_activate(struct task_struct* p_thread) {
c00050cd:	55                   	push   %ebp
c00050ce:	89 e5                	mov    %esp,%ebp
c00050d0:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:59
	
	/* 若为"内核线程",需要重新填充页表为0x100000 */
	uint32_t pagedir_phy_addr = 0x100000;	// 默认为内核的页目录物理地址,也就是内核线程所用的页目录表
c00050d3:	c7 45 f4 00 00 10 00 	movl   $0x100000,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:62
	
	/* "用户态进程"有自己的页目录表 */
	if (p_thread->pgdir != NULL) {
c00050da:	8b 45 08             	mov    0x8(%ebp),%eax
c00050dd:	8b 40 54             	mov    0x54(%eax),%eax
c00050e0:	85 c0                	test   %eax,%eax
c00050e2:	74 15                	je     c00050f9 <page_dir_activate+0x2c>
/work/x86_os_my/userprog/process.c:63
		pagedir_phy_addr = addr_v2p((uint32_t)p_thread->pgdir);
c00050e4:	8b 45 08             	mov    0x8(%ebp),%eax
c00050e7:	8b 40 54             	mov    0x54(%eax),%eax
c00050ea:	83 ec 0c             	sub    $0xc,%esp
c00050ed:	50                   	push   %eax
c00050ee:	e8 47 db ff ff       	call   c0002c3a <addr_v2p>
c00050f3:	83 c4 10             	add    $0x10,%esp
c00050f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:69
	}

	/* 更新页目录寄存器cr3,使新页表生效
	 * 实现进程间，虚拟地址空间的隔离。
	 */
	asm volatile ("movl %0, %%cr3" : : "r" (pagedir_phy_addr) : "memory");
c00050f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00050fc:	0f 22 d8             	mov    %eax,%cr3
/work/x86_os_my/userprog/process.c:70
}
c00050ff:	90                   	nop
c0005100:	c9                   	leave  
c0005101:	c3                   	ret    

c0005102 <process_activate>:
process_activate():
/work/x86_os_my/userprog/process.c:76

/* 1.激活线程或进程的页表,【更新CR3寄存器】
 * 2.用户进程，更新tss中的esp0为进程的特权级0的栈
 * 【只有在任务调度时（中断时），才会切换页表及更新 0 级栈，因此 process_activate 是被"中断执行流"的 schedule 调用的！】
 */
void process_activate(struct task_struct* p_thread) {
c0005102:	55                   	push   %ebp
c0005103:	89 e5                	mov    %esp,%ebp
c0005105:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/process.c:77
	ASSERT(p_thread != NULL);
c0005108:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000510c:	75 19                	jne    c0005127 <process_activate+0x25>
/work/x86_os_my/userprog/process.c:77 (discriminator 1)
c000510e:	68 54 be 00 c0       	push   $0xc000be54
c0005113:	68 10 bf 00 c0       	push   $0xc000bf10
c0005118:	6a 4d                	push   $0x4d
c000511a:	68 65 be 00 c0       	push   $0xc000be65
c000511f:	e8 be d1 ff ff       	call   c00022e2 <panic_spin>
c0005124:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:80
	
	/* 激活该进程或线程的页目录表【重新加载了CR3】 */
	page_dir_activate(p_thread);
c0005127:	83 ec 0c             	sub    $0xc,%esp
c000512a:	ff 75 08             	pushl  0x8(%ebp)
c000512d:	e8 9b ff ff ff       	call   c00050cd <page_dir_activate>
c0005132:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:83

	/* 内核线程特权级本身就是0,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */
	if (p_thread->pgdir != NULL) {
c0005135:	8b 45 08             	mov    0x8(%ebp),%eax
c0005138:	8b 40 54             	mov    0x54(%eax),%eax
c000513b:	85 c0                	test   %eax,%eax
c000513d:	74 0e                	je     c000514d <process_activate+0x4b>
/work/x86_os_my/userprog/process.c:86
		/* 若为用户进程,更新该进程的esp0,用于此进程被中断时保留上下文 
		 * 需要从tss中获取0特权级栈地址 */
		update_tss_esp(p_thread);	//就一行：g_tss.esp0 = (uint32_t*)((uint32_t)pthread + PG_SIZE);
c000513f:	83 ec 0c             	sub    $0xc,%esp
c0005142:	ff 75 08             	pushl  0x8(%ebp)
c0005145:	e8 f2 fc ff ff       	call   c0004e3c <update_tss_esp>
c000514a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:88
	}
}
c000514d:	90                   	nop
c000514e:	c9                   	leave  
c000514f:	c3                   	ret    

c0005150 <create_page_dir>:
create_page_dir():
/work/x86_os_my/userprog/process.c:97
 * 
 * 要确保用户进程，在自己的地址空间中，能够访问到内核。
 * 即：任意进程的页目录表中，用户进程占第 0~767 个页目录项，内核占第 768~1023 个页目录项。
 * 0x300 = 768
 */
uint32_t* create_page_dir(void) {
c0005150:	55                   	push   %ebp
c0005151:	89 e5                	mov    %esp,%ebp
c0005153:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:100

	/* 用户进程的页表不能让用户直接访问到,所以在内核空间来申请 */
	uint32_t* page_dir_vaddr = get_kernel_pages(1);
c0005156:	83 ec 0c             	sub    $0xc,%esp
c0005159:	6a 01                	push   $0x1
c000515b:	e8 2a d8 ff ff       	call   c000298a <get_kernel_pages>
c0005160:	83 c4 10             	add    $0x10,%esp
c0005163:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:101
	if (page_dir_vaddr == NULL) {
c0005166:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000516a:	75 17                	jne    c0005183 <create_page_dir+0x33>
/work/x86_os_my/userprog/process.c:102
		console_put_str("create_page_dir: get_kernel_page failed!");
c000516c:	83 ec 0c             	sub    $0xc,%esp
c000516f:	68 78 be 00 c0       	push   $0xc000be78
c0005174:	e8 57 f3 ff ff       	call   c00044d0 <console_put_str>
c0005179:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:103
		return NULL;
c000517c:	b8 00 00 00 00       	mov    $0x0,%eax
c0005181:	eb 43                	jmp    c00051c6 <create_page_dir+0x76>
/work/x86_os_my/userprog/process.c:109
	}

	/*** 1 复制内核的页目录表  ***/
	// page_dir_vaddr + 0x300*4 是内核页目录的第768项
	// 复制的页目录项个数=1024/4
	memcpy((uint32_t*)((uint32_t)page_dir_vaddr + 0x300*4), (uint32_t*)(0xfffff000+0x300*4), 1024);
c0005183:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005186:	05 00 0c 00 00       	add    $0xc00,%eax
c000518b:	83 ec 04             	sub    $0x4,%esp
c000518e:	68 00 04 00 00       	push   $0x400
c0005193:	68 00 fc ff ff       	push   $0xfffffc00
c0005198:	50                   	push   %eax
c0005199:	e8 38 e6 ff ff       	call   c00037d6 <memcpy>
c000519e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:113

	/*** 2 更新页目录表地址 ***/
	// 页目录表地址是页目录的最后一项
	uint32_t new_page_dir_phy_addr = addr_v2p((uint32_t)page_dir_vaddr);
c00051a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00051a4:	83 ec 0c             	sub    $0xc,%esp
c00051a7:	50                   	push   %eax
c00051a8:	e8 8d da ff ff       	call   c0002c3a <addr_v2p>
c00051ad:	83 c4 10             	add    $0x10,%esp
c00051b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:114
	page_dir_vaddr[1023] = new_page_dir_phy_addr | PG_US_U | PG_RW_W | PG_P_1;
c00051b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00051b6:	05 fc 0f 00 00       	add    $0xffc,%eax
c00051bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00051be:	83 ca 07             	or     $0x7,%edx
c00051c1:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/process.c:116

	return page_dir_vaddr;
c00051c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/userprog/process.c:117
}
c00051c6:	c9                   	leave  
c00051c7:	c3                   	ret    

c00051c8 <create_user_vaddr_bitmap>:
create_user_vaddr_bitmap():
/work/x86_os_my/userprog/process.c:120

/* 创建用户进程虚拟地址位图 */
void create_user_vaddr_bitmap(struct task_struct* user_prog) {
c00051c8:	55                   	push   %ebp
c00051c9:	89 e5                	mov    %esp,%ebp
c00051cb:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:121
   user_prog->userprog_vaddr.vaddr_start = USER_VADDR_START;	// linux用户程序入口地址 0x80480000
c00051ce:	8b 45 08             	mov    0x8(%ebp),%eax
c00051d1:	c7 40 60 00 80 04 08 	movl   $0x8048000,0x60(%eax)
/work/x86_os_my/userprog/process.c:122
   uint32_t bitmap_pg_cnt = DIV_ROUND_UP((0xc0000000 - USER_VADDR_START) / PG_SIZE / 8 , PG_SIZE);
c00051d8:	c7 45 f4 17 00 00 00 	movl   $0x17,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:123
   user_prog->userprog_vaddr.vaddr_bitmap.bits = get_kernel_pages(bitmap_pg_cnt);
c00051df:	83 ec 0c             	sub    $0xc,%esp
c00051e2:	ff 75 f4             	pushl  -0xc(%ebp)
c00051e5:	e8 a0 d7 ff ff       	call   c000298a <get_kernel_pages>
c00051ea:	83 c4 10             	add    $0x10,%esp
c00051ed:	89 c2                	mov    %eax,%edx
c00051ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00051f2:	89 50 5c             	mov    %edx,0x5c(%eax)
/work/x86_os_my/userprog/process.c:124
   user_prog->userprog_vaddr.vaddr_bitmap.btmp_bytes_len = (0xc0000000 - USER_VADDR_START) / PG_SIZE / 8;
c00051f5:	8b 45 08             	mov    0x8(%ebp),%eax
c00051f8:	c7 40 58 f7 6f 01 00 	movl   $0x16ff7,0x58(%eax)
/work/x86_os_my/userprog/process.c:125
   bitmap_init(&user_prog->userprog_vaddr.vaddr_bitmap);
c00051ff:	8b 45 08             	mov    0x8(%ebp),%eax
c0005202:	83 c0 58             	add    $0x58,%eax
c0005205:	83 ec 0c             	sub    $0xc,%esp
c0005208:	50                   	push   %eax
c0005209:	e8 aa d1 ff ff       	call   c00023b8 <bitmap_init>
c000520e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:126
}
c0005211:	90                   	nop
c0005212:	c9                   	leave  
c0005213:	c3                   	ret    

c0005214 <process_execute>:
process_execute():
/work/x86_os_my/userprog/process.c:129

/* 创建用户进程 */
void process_execute(void* filename, char* name) {
c0005214:	55                   	push   %ebp
c0005215:	89 e5                	mov    %esp,%ebp
c0005217:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/process.c:131
   /* pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 */
   struct task_struct* thread = get_kernel_pages(1);
c000521a:	83 ec 0c             	sub    $0xc,%esp
c000521d:	6a 01                	push   $0x1
c000521f:	e8 66 d7 ff ff       	call   c000298a <get_kernel_pages>
c0005224:	83 c4 10             	add    $0x10,%esp
c0005227:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/process.c:132
   init_thread(thread, name, default_prio);			//初始化线程PCB结构体 struct task_struct
c000522a:	83 ec 04             	sub    $0x4,%esp
c000522d:	6a 1f                	push   $0x1f
c000522f:	ff 75 0c             	pushl  0xc(%ebp)
c0005232:	ff 75 f4             	pushl  -0xc(%ebp)
c0005235:	e8 25 ea ff ff       	call   c0003c5f <init_thread>
c000523a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:133
   create_user_vaddr_bitmap(thread);				//【进程新增】创建用户进程，虚拟地址空间位图
c000523d:	83 ec 0c             	sub    $0xc,%esp
c0005240:	ff 75 f4             	pushl  -0xc(%ebp)
c0005243:	e8 80 ff ff ff       	call   c00051c8 <create_user_vaddr_bitmap>
c0005248:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:134
   thread_create(thread, start_process, filename);	//初始化线程栈结构体 struct thread_stack
c000524b:	83 ec 04             	sub    $0x4,%esp
c000524e:	ff 75 08             	pushl  0x8(%ebp)
c0005251:	68 c8 4f 00 c0       	push   $0xc0004fc8
c0005256:	ff 75 f4             	pushl  -0xc(%ebp)
c0005259:	e8 8a e9 ff ff       	call   c0003be8 <thread_create>
c000525e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:135
   thread->pgdir = create_page_dir();				//【进程新增】创建用户进程，页目录表
c0005261:	e8 ea fe ff ff       	call   c0005150 <create_page_dir>
c0005266:	89 c2                	mov    %eax,%edx
c0005268:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000526b:	89 50 54             	mov    %edx,0x54(%eax)
/work/x86_os_my/userprog/process.c:136
   block_desc_init(thread->u_block_desc);
c000526e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005271:	83 c0 64             	add    $0x64,%eax
c0005274:	83 ec 0c             	sub    $0xc,%esp
c0005277:	50                   	push   %eax
c0005278:	e8 23 e4 ff ff       	call   c00036a0 <block_desc_init>
c000527d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:138
   
   enum intr_status old_status = intr_disable();
c0005280:	e8 b9 c6 ff ff       	call   c000193e <intr_disable>
c0005285:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/process.c:139
   ASSERT(!elem_find(&thread_ready_list, &thread->general_tag));
c0005288:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000528b:	83 c0 44             	add    $0x44,%eax
c000528e:	83 ec 08             	sub    $0x8,%esp
c0005291:	50                   	push   %eax
c0005292:	68 8c fb 00 c0       	push   $0xc000fb8c
c0005297:	e8 ec f0 ff ff       	call   c0004388 <elem_find>
c000529c:	83 c4 10             	add    $0x10,%esp
c000529f:	85 c0                	test   %eax,%eax
c00052a1:	74 1c                	je     c00052bf <process_execute+0xab>
/work/x86_os_my/userprog/process.c:139 (discriminator 1)
c00052a3:	68 a4 be 00 c0       	push   $0xc000bea4
c00052a8:	68 24 bf 00 c0       	push   $0xc000bf24
c00052ad:	68 8b 00 00 00       	push   $0x8b
c00052b2:	68 65 be 00 c0       	push   $0xc000be65
c00052b7:	e8 26 d0 ff ff       	call   c00022e2 <panic_spin>
c00052bc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:140
   list_append(&thread_ready_list, &thread->general_tag);
c00052bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00052c2:	83 c0 44             	add    $0x44,%eax
c00052c5:	83 ec 08             	sub    $0x8,%esp
c00052c8:	50                   	push   %eax
c00052c9:	68 8c fb 00 c0       	push   $0xc000fb8c
c00052ce:	e8 3b f0 ff ff       	call   c000430e <list_append>
c00052d3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:141
   ASSERT(!elem_find(&thread_all_list, &thread->all_list_tag));
c00052d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00052d9:	83 c0 4c             	add    $0x4c,%eax
c00052dc:	83 ec 08             	sub    $0x8,%esp
c00052df:	50                   	push   %eax
c00052e0:	68 9c fb 00 c0       	push   $0xc000fb9c
c00052e5:	e8 9e f0 ff ff       	call   c0004388 <elem_find>
c00052ea:	83 c4 10             	add    $0x10,%esp
c00052ed:	85 c0                	test   %eax,%eax
c00052ef:	74 1c                	je     c000530d <process_execute+0xf9>
/work/x86_os_my/userprog/process.c:141 (discriminator 1)
c00052f1:	68 dc be 00 c0       	push   $0xc000bedc
c00052f6:	68 24 bf 00 c0       	push   $0xc000bf24
c00052fb:	68 8d 00 00 00       	push   $0x8d
c0005300:	68 65 be 00 c0       	push   $0xc000be65
c0005305:	e8 d8 cf ff ff       	call   c00022e2 <panic_spin>
c000530a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:142
   list_append(&thread_all_list, &thread->all_list_tag);
c000530d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005310:	83 c0 4c             	add    $0x4c,%eax
c0005313:	83 ec 08             	sub    $0x8,%esp
c0005316:	50                   	push   %eax
c0005317:	68 9c fb 00 c0       	push   $0xc000fb9c
c000531c:	e8 ed ef ff ff       	call   c000430e <list_append>
c0005321:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:143
   intr_set_status(old_status);
c0005324:	83 ec 0c             	sub    $0xc,%esp
c0005327:	ff 75 f0             	pushl  -0x10(%ebp)
c000532a:	e8 38 c6 ff ff       	call   c0001967 <intr_set_status>
c000532f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/process.c:144
}
c0005332:	90                   	nop
c0005333:	c9                   	leave  
c0005334:	c3                   	ret    

c0005335 <getpid>:
getpid():
/work/x86_os_my/lib/user/syscall.c:53
   );							       \
   retval;						       \
})

/* 返回当前任务pid */
uint32_t getpid() {
c0005335:	55                   	push   %ebp
c0005336:	89 e5                	mov    %esp,%ebp
c0005338:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:54
	return _syscall0(SYS_GETPID);
c000533b:	b8 00 00 00 00       	mov    $0x0,%eax
c0005340:	cd 80                	int    $0x80
c0005342:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0005345:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:55
}
c0005348:	c9                   	leave  
c0005349:	c3                   	ret    

c000534a <write>:
write():
/work/x86_os_my/lib/user/syscall.c:58

/* 把buf中count个字符写入文件描述符fd */
uint32_t write(int32_t fd, const void* buf, uint32_t count) {
c000534a:	55                   	push   %ebp
c000534b:	89 e5                	mov    %esp,%ebp
c000534d:	53                   	push   %ebx
c000534e:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:59
	return _syscall3(SYS_WRITE, fd, buf, count);
c0005351:	b8 01 00 00 00       	mov    $0x1,%eax
c0005356:	8b 5d 08             	mov    0x8(%ebp),%ebx
c0005359:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c000535c:	8b 55 10             	mov    0x10(%ebp),%edx
c000535f:	cd 80                	int    $0x80
c0005361:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005364:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:60
}
c0005367:	83 c4 10             	add    $0x10,%esp
c000536a:	5b                   	pop    %ebx
c000536b:	5d                   	pop    %ebp
c000536c:	c3                   	ret    

c000536d <malloc>:
malloc():
/work/x86_os_my/lib/user/syscall.c:63

/* 申请size字节大小的内存,并返回结果 */
void* malloc(uint32_t size) {
c000536d:	55                   	push   %ebp
c000536e:	89 e5                	mov    %esp,%ebp
c0005370:	53                   	push   %ebx
c0005371:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:64
	return (void*)_syscall1(SYS_MALLOC, size);
c0005374:	b8 02 00 00 00       	mov    $0x2,%eax
c0005379:	8b 55 08             	mov    0x8(%ebp),%edx
c000537c:	89 d3                	mov    %edx,%ebx
c000537e:	cd 80                	int    $0x80
c0005380:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0005383:	8b 45 f8             	mov    -0x8(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:65
}
c0005386:	83 c4 10             	add    $0x10,%esp
c0005389:	5b                   	pop    %ebx
c000538a:	5d                   	pop    %ebp
c000538b:	c3                   	ret    

c000538c <free>:
free():
/work/x86_os_my/lib/user/syscall.c:68

/* 释放ptr指向的内存 */
void free(void* ptr) {
c000538c:	55                   	push   %ebp
c000538d:	89 e5                	mov    %esp,%ebp
c000538f:	53                   	push   %ebx
c0005390:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:69
	_syscall1(SYS_FREE, ptr);
c0005393:	b8 03 00 00 00       	mov    $0x3,%eax
c0005398:	8b 55 08             	mov    0x8(%ebp),%edx
c000539b:	89 d3                	mov    %edx,%ebx
c000539d:	cd 80                	int    $0x80
c000539f:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/lib/user/syscall.c:70
}
c00053a2:	90                   	nop
c00053a3:	83 c4 10             	add    $0x10,%esp
c00053a6:	5b                   	pop    %ebx
c00053a7:	5d                   	pop    %ebp
c00053a8:	c3                   	ret    

c00053a9 <fork>:
fork():
/work/x86_os_my/lib/user/syscall.c:73

/* 派生子进程,返回子进程pid */
pid_t fork(void){
c00053a9:	55                   	push   %ebp
c00053aa:	89 e5                	mov    %esp,%ebp
c00053ac:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/lib/user/syscall.c:74
	return _syscall0(SYS_FORK);
c00053af:	b8 04 00 00 00       	mov    $0x4,%eax
c00053b4:	cd 80                	int    $0x80
c00053b6:	89 45 fc             	mov    %eax,-0x4(%ebp)
c00053b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
/work/x86_os_my/lib/user/syscall.c:75
}
c00053bc:	c9                   	leave  
c00053bd:	c3                   	ret    

c00053be <sys_getpid>:
sys_getpid():
/work/x86_os_my/userprog/syscall-init.c:17
#define syscall_nr 32 
typedef void* syscall;
syscall syscall_table[syscall_nr];

/* 返回当前任务的pid */
uint32_t sys_getpid(void) {
c00053be:	55                   	push   %ebp
c00053bf:	89 e5                	mov    %esp,%ebp
c00053c1:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/syscall-init.c:18
	return running_thread()->pid;
c00053c4:	e8 a2 e7 ff ff       	call   c0003b6b <running_thread>
c00053c9:	0f b7 40 04          	movzwl 0x4(%eax),%eax
c00053cd:	98                   	cwtl   
/work/x86_os_my/userprog/syscall-init.c:19
}
c00053ce:	c9                   	leave  
c00053cf:	c3                   	ret    

c00053d0 <syscall_init>:
syscall_init():
/work/x86_os_my/userprog/syscall-init.c:22

/* 初始化系统调用 */
void syscall_init(void) {
c00053d0:	55                   	push   %ebp
c00053d1:	89 e5                	mov    %esp,%ebp
c00053d3:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/userprog/syscall-init.c:23
	put_str("syscall_init start\n");
c00053d6:	83 ec 0c             	sub    $0xc,%esp
c00053d9:	68 34 bf 00 c0       	push   $0xc000bf34
c00053de:	e8 8d cd ff ff       	call   c0002170 <put_str>
c00053e3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:24
	syscall_table[SYS_GETPID]	= sys_getpid;
c00053e6:	c7 05 60 fc 00 c0 be 	movl   $0xc00053be,0xc000fc60
c00053ed:	53 00 c0 
/work/x86_os_my/userprog/syscall-init.c:25
	syscall_table[SYS_WRITE]	= sys_write;
c00053f0:	c7 05 64 fc 00 c0 76 	movl   $0xc0007176,0xc000fc64
c00053f7:	71 00 c0 
/work/x86_os_my/userprog/syscall-init.c:26
	syscall_table[SYS_MALLOC]	= sys_malloc;
c00053fa:	c7 05 68 fc 00 c0 8d 	movl   $0xc0002c8d,0xc000fc68
c0005401:	2c 00 c0 
/work/x86_os_my/userprog/syscall-init.c:27
	syscall_table[SYS_FREE]		= sys_free;
c0005404:	c7 05 6c fc 00 c0 ba 	movl   $0xc00032ba,0xc000fc6c
c000540b:	32 00 c0 
/work/x86_os_my/userprog/syscall-init.c:28
	syscall_table[SYS_FORK]		= sys_fork;
c000540e:	c7 05 70 fc 00 c0 11 	movl   $0xc000af11,0xc000fc70
c0005415:	af 00 c0 
/work/x86_os_my/userprog/syscall-init.c:29
	put_str("syscall_init done\n");
c0005418:	83 ec 0c             	sub    $0xc,%esp
c000541b:	68 48 bf 00 c0       	push   $0xc000bf48
c0005420:	e8 4b cd ff ff       	call   c0002170 <put_str>
c0005425:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/syscall-init.c:30
}
c0005428:	90                   	nop
c0005429:	c9                   	leave  
c000542a:	c3                   	ret    

c000542b <itoa>:
itoa():
/work/x86_os_my/lib/stdio.c:13
#define va_start(ap, v) ap = (va_list)&v	// 把ap指向第一个固定参数v
#define va_arg(ap, t) *((t*)(ap += 4))		// ap指向下一个参数并返回其值
#define va_end(ap) ap = NULL				// 清除ap

/* 将整型转换成字符(integer to ascii) */
static void itoa(uint32_t value, char** buf_ptr_addr, uint8_t base) {
c000542b:	55                   	push   %ebp
c000542c:	89 e5                	mov    %esp,%ebp
c000542e:	83 ec 28             	sub    $0x28,%esp
c0005431:	8b 45 10             	mov    0x10(%ebp),%eax
c0005434:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/lib/stdio.c:14
	uint32_t m = value % base;	// 求模,最先掉下来的是最低位【比如base是16代表16进制】 
c0005437:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c000543b:	8b 45 08             	mov    0x8(%ebp),%eax
c000543e:	ba 00 00 00 00       	mov    $0x0,%edx
c0005443:	f7 f1                	div    %ecx
c0005445:	89 55 f4             	mov    %edx,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:15
	uint32_t i = value / base;	// 取整
c0005448:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c000544c:	8b 45 08             	mov    0x8(%ebp),%eax
c000544f:	ba 00 00 00 00       	mov    $0x0,%edx
c0005454:	f7 f1                	div    %ecx
c0005456:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/stdio.c:16
	if (i) {
c0005459:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000545d:	74 16                	je     c0005475 <itoa+0x4a>
/work/x86_os_my/lib/stdio.c:17
		itoa(i, buf_ptr_addr, base);	// 如果倍数不为0则递归调用。
c000545f:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0005463:	83 ec 04             	sub    $0x4,%esp
c0005466:	50                   	push   %eax
c0005467:	ff 75 0c             	pushl  0xc(%ebp)
c000546a:	ff 75 f0             	pushl  -0x10(%ebp)
c000546d:	e8 b9 ff ff ff       	call   c000542b <itoa>
c0005472:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:19
	}
	if (m < 10) {	// 如果余数是0~9
c0005475:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0005479:	77 17                	ja     c0005492 <itoa+0x67>
/work/x86_os_my/lib/stdio.c:20
		*((*buf_ptr_addr)++) = m + '0';			// 将数字0~9转换为字符'0'~'9'
c000547b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000547e:	8b 00                	mov    (%eax),%eax
c0005480:	8d 48 01             	lea    0x1(%eax),%ecx
c0005483:	8b 55 0c             	mov    0xc(%ebp),%edx
c0005486:	89 0a                	mov    %ecx,(%edx)
c0005488:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000548b:	83 c2 30             	add    $0x30,%edx
c000548e:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:24
	} else {		// 否则余数是A~F
		*((*buf_ptr_addr)++) = m - 10 + 'A';	// 将数字A~F转换为字符'A'~'F'
	}
}
c0005490:	eb 15                	jmp    c00054a7 <itoa+0x7c>
/work/x86_os_my/lib/stdio.c:22
		itoa(i, buf_ptr_addr, base);	// 如果倍数不为0则递归调用。
	}
	if (m < 10) {	// 如果余数是0~9
		*((*buf_ptr_addr)++) = m + '0';			// 将数字0~9转换为字符'0'~'9'
	} else {		// 否则余数是A~F
		*((*buf_ptr_addr)++) = m - 10 + 'A';	// 将数字A~F转换为字符'A'~'F'
c0005492:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005495:	8b 00                	mov    (%eax),%eax
c0005497:	8d 48 01             	lea    0x1(%eax),%ecx
c000549a:	8b 55 0c             	mov    0xc(%ebp),%edx
c000549d:	89 0a                	mov    %ecx,(%edx)
c000549f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00054a2:	83 c2 37             	add    $0x37,%edx
c00054a5:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:24
	}
}
c00054a7:	90                   	nop
c00054a8:	c9                   	leave  
c00054a9:	c3                   	ret    

c00054aa <vsprintf>:
vsprintf():
/work/x86_os_my/lib/stdio.c:27

/* 将参数ap按照格式format输出到字符串str,并返回替换后str长度 */
uint32_t vsprintf(char* str, const char* format, va_list ap) {
c00054aa:	55                   	push   %ebp
c00054ab:	89 e5                	mov    %esp,%ebp
c00054ad:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/lib/stdio.c:28
	char* buf_ptr = str;
c00054b0:	8b 45 08             	mov    0x8(%ebp),%eax
c00054b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/stdio.c:29
	const char* index_ptr = format;
c00054b6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00054b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:30
	char index_char = *index_ptr;
c00054bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00054bf:	0f b6 00             	movzbl (%eax),%eax
c00054c2:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:33
	int32_t arg_int;
	char* arg_str;
	while(index_char) {
c00054c5:	e9 43 01 00 00       	jmp    c000560d <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:34
		if (index_char != '%') {
c00054ca:	80 7d f3 25          	cmpb   $0x25,-0xd(%ebp)
c00054ce:	74 21                	je     c00054f1 <vsprintf+0x47>
/work/x86_os_my/lib/stdio.c:35
			*(buf_ptr++) = index_char;
c00054d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00054d3:	8d 50 01             	lea    0x1(%eax),%edx
c00054d6:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c00054d9:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
c00054dd:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:36
			index_char = *(++index_ptr);
c00054df:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00054e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00054e6:	0f b6 00             	movzbl (%eax),%eax
c00054e9:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:37
			continue;
c00054ec:	e9 1c 01 00 00       	jmp    c000560d <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:39
		}
		index_char = *(++index_ptr);	 // 得到%后面的字符
c00054f1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00054f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00054f8:	0f b6 00             	movzbl (%eax),%eax
c00054fb:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:40
		switch(index_char) {
c00054fe:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
c0005502:	83 f8 64             	cmp    $0x64,%eax
c0005505:	0f 84 8e 00 00 00    	je     c0005599 <vsprintf+0xef>
c000550b:	83 f8 64             	cmp    $0x64,%eax
c000550e:	7f 0a                	jg     c000551a <vsprintf+0x70>
c0005510:	83 f8 63             	cmp    $0x63,%eax
c0005513:	74 60                	je     c0005575 <vsprintf+0xcb>
c0005515:	e9 f3 00 00 00       	jmp    c000560d <vsprintf+0x163>
c000551a:	83 f8 73             	cmp    $0x73,%eax
c000551d:	74 0e                	je     c000552d <vsprintf+0x83>
c000551f:	83 f8 78             	cmp    $0x78,%eax
c0005522:	0f 84 b6 00 00 00    	je     c00055de <vsprintf+0x134>
c0005528:	e9 e0 00 00 00       	jmp    c000560d <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:42
			case 's':
			arg_str = va_arg(ap, char*);
c000552d:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c0005531:	8b 45 10             	mov    0x10(%ebp),%eax
c0005534:	8b 00                	mov    (%eax),%eax
c0005536:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/lib/stdio.c:43
			strcpy(buf_ptr, arg_str);
c0005539:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000553c:	83 ec 08             	sub    $0x8,%esp
c000553f:	ff 75 e8             	pushl  -0x18(%ebp)
c0005542:	50                   	push   %eax
c0005543:	e8 71 e3 ff ff       	call   c00038b9 <strcpy>
c0005548:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:44
			buf_ptr += strlen(arg_str);
c000554b:	83 ec 0c             	sub    $0xc,%esp
c000554e:	ff 75 e8             	pushl  -0x18(%ebp)
c0005551:	e8 b8 e3 ff ff       	call   c000390e <strlen>
c0005556:	83 c4 10             	add    $0x10,%esp
c0005559:	89 c2                	mov    %eax,%edx
c000555b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000555e:	01 d0                	add    %edx,%eax
c0005560:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/lib/stdio.c:45
			index_char = *(++index_ptr);
c0005563:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0005567:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000556a:	0f b6 00             	movzbl (%eax),%eax
c000556d:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:46
			break;
c0005570:	e9 98 00 00 00       	jmp    c000560d <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:49

			case 'c':
			*(buf_ptr++) = va_arg(ap, char);
c0005575:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0005578:	8d 50 01             	lea    0x1(%eax),%edx
c000557b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c000557e:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c0005582:	8b 55 10             	mov    0x10(%ebp),%edx
c0005585:	0f b6 12             	movzbl (%edx),%edx
c0005588:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/lib/stdio.c:50
			index_char = *(++index_ptr);
c000558a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c000558e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005591:	0f b6 00             	movzbl (%eax),%eax
c0005594:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:51
			break;
c0005597:	eb 74                	jmp    c000560d <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:54

			case 'd':
			arg_int = va_arg(ap, int);
c0005599:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c000559d:	8b 45 10             	mov    0x10(%ebp),%eax
c00055a0:	8b 00                	mov    (%eax),%eax
c00055a2:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/stdio.c:56
			/* 若是负数, 将其转为正数后,再正数前面输出个负号'-'. */
			if (arg_int < 0) {
c00055a5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00055a9:	79 0f                	jns    c00055ba <vsprintf+0x110>
/work/x86_os_my/lib/stdio.c:57
				arg_int = 0 - arg_int;
c00055ab:	f7 5d ec             	negl   -0x14(%ebp)
/work/x86_os_my/lib/stdio.c:58
				*buf_ptr++ = '-';
c00055ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00055b1:	8d 50 01             	lea    0x1(%eax),%edx
c00055b4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c00055b7:	c6 00 2d             	movb   $0x2d,(%eax)
/work/x86_os_my/lib/stdio.c:60
			}
			itoa(arg_int, &buf_ptr, 10); 
c00055ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00055bd:	83 ec 04             	sub    $0x4,%esp
c00055c0:	6a 0a                	push   $0xa
c00055c2:	8d 55 e4             	lea    -0x1c(%ebp),%edx
c00055c5:	52                   	push   %edx
c00055c6:	50                   	push   %eax
c00055c7:	e8 5f fe ff ff       	call   c000542b <itoa>
c00055cc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:61
			index_char = *(++index_ptr);
c00055cf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00055d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00055d6:	0f b6 00             	movzbl (%eax),%eax
c00055d9:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:62
			break;
c00055dc:	eb 2f                	jmp    c000560d <vsprintf+0x163>
/work/x86_os_my/lib/stdio.c:65

			case 'x':
			arg_int = va_arg(ap, int);
c00055de:	83 45 10 04          	addl   $0x4,0x10(%ebp)
c00055e2:	8b 45 10             	mov    0x10(%ebp),%eax
c00055e5:	8b 00                	mov    (%eax),%eax
c00055e7:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/lib/stdio.c:66
			itoa(arg_int, &buf_ptr, 16); 
c00055ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00055ed:	83 ec 04             	sub    $0x4,%esp
c00055f0:	6a 10                	push   $0x10
c00055f2:	8d 55 e4             	lea    -0x1c(%ebp),%edx
c00055f5:	52                   	push   %edx
c00055f6:	50                   	push   %eax
c00055f7:	e8 2f fe ff ff       	call   c000542b <itoa>
c00055fc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:67
			index_char = *(++index_ptr); // 跳过格式字符并更新index_char
c00055ff:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0005603:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005606:	0f b6 00             	movzbl (%eax),%eax
c0005609:	88 45 f3             	mov    %al,-0xd(%ebp)
/work/x86_os_my/lib/stdio.c:68
			break;
c000560c:	90                   	nop
/work/x86_os_my/lib/stdio.c:33
	char* buf_ptr = str;
	const char* index_ptr = format;
	char index_char = *index_ptr;
	int32_t arg_int;
	char* arg_str;
	while(index_char) {
c000560d:	80 7d f3 00          	cmpb   $0x0,-0xd(%ebp)
c0005611:	0f 85 b3 fe ff ff    	jne    c00054ca <vsprintf+0x20>
/work/x86_os_my/lib/stdio.c:71
			itoa(arg_int, &buf_ptr, 16); 
			index_char = *(++index_ptr); // 跳过格式字符并更新index_char
			break;
		}
	}
	return strlen(str);
c0005617:	83 ec 0c             	sub    $0xc,%esp
c000561a:	ff 75 08             	pushl  0x8(%ebp)
c000561d:	e8 ec e2 ff ff       	call   c000390e <strlen>
c0005622:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:72
}
c0005625:	c9                   	leave  
c0005626:	c3                   	ret    

c0005627 <sprintf>:
sprintf():
/work/x86_os_my/lib/stdio.c:75

/* 同printf不同的地方就是字符串不是写到终端,而是写到buf中 */
uint32_t sprintf(char* buf, const char* format, ...) {
c0005627:	55                   	push   %ebp
c0005628:	89 e5                	mov    %esp,%ebp
c000562a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/lib/stdio.c:78
	va_list args;
	uint32_t retval;
	va_start(args, format);
c000562d:	8d 45 0c             	lea    0xc(%ebp),%eax
c0005630:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:79
	retval = vsprintf(buf, format, args);
c0005633:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005636:	83 ec 04             	sub    $0x4,%esp
c0005639:	ff 75 f4             	pushl  -0xc(%ebp)
c000563c:	50                   	push   %eax
c000563d:	ff 75 08             	pushl  0x8(%ebp)
c0005640:	e8 65 fe ff ff       	call   c00054aa <vsprintf>
c0005645:	83 c4 10             	add    $0x10,%esp
c0005648:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/lib/stdio.c:80
	va_end(args);
c000564b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:81
	return retval;
c0005652:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/lib/stdio.c:82
}
c0005655:	c9                   	leave  
c0005656:	c3                   	ret    

c0005657 <printf>:
printf():
/work/x86_os_my/lib/stdio.c:85

/* 格式化输出字符串format */
uint32_t printf(const char* format, ...) {
c0005657:	55                   	push   %ebp
c0005658:	89 e5                	mov    %esp,%ebp
c000565a:	57                   	push   %edi
c000565b:	81 ec 14 04 00 00    	sub    $0x414,%esp
/work/x86_os_my/lib/stdio.c:87
	va_list args;
	va_start(args, format);	       // 使args指向format
c0005661:	8d 45 08             	lea    0x8(%ebp),%eax
c0005664:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:88
	char buf[1024] = {0};	       // 用于存储拼接后的字符串
c0005667:	8d 95 f4 fb ff ff    	lea    -0x40c(%ebp),%edx
c000566d:	b8 00 00 00 00       	mov    $0x0,%eax
c0005672:	b9 00 01 00 00       	mov    $0x100,%ecx
c0005677:	89 d7                	mov    %edx,%edi
c0005679:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/lib/stdio.c:89
	vsprintf(buf, format, args);
c000567b:	8b 45 08             	mov    0x8(%ebp),%eax
c000567e:	83 ec 04             	sub    $0x4,%esp
c0005681:	ff 75 f4             	pushl  -0xc(%ebp)
c0005684:	50                   	push   %eax
c0005685:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c000568b:	50                   	push   %eax
c000568c:	e8 19 fe ff ff       	call   c00054aa <vsprintf>
c0005691:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:90
	va_end(args);
c0005694:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/stdio.c:91
	return write(1, buf, strlen(buf));
c000569b:	83 ec 0c             	sub    $0xc,%esp
c000569e:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c00056a4:	50                   	push   %eax
c00056a5:	e8 64 e2 ff ff       	call   c000390e <strlen>
c00056aa:	83 c4 10             	add    $0x10,%esp
c00056ad:	83 ec 04             	sub    $0x4,%esp
c00056b0:	50                   	push   %eax
c00056b1:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c00056b7:	50                   	push   %eax
c00056b8:	6a 01                	push   $0x1
c00056ba:	e8 8b fc ff ff       	call   c000534a <write>
c00056bf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/stdio.c:92
}
c00056c2:	8b 7d fc             	mov    -0x4(%ebp),%edi
c00056c5:	c9                   	leave  
c00056c6:	c3                   	ret    

c00056c7 <outb>:
outb():
/work/x86_os_my/lib/kernel/io.h:17
#define __LIB_IO_H
#include "stdint.h"
//inline省去了函数调用开支

/* 向端口port写入一个字节*/
static inline void outb(uint16_t port, uint8_t data) {
c00056c7:	55                   	push   %ebp
c00056c8:	89 e5                	mov    %esp,%ebp
c00056ca:	83 ec 08             	sub    $0x8,%esp
c00056cd:	8b 55 08             	mov    0x8(%ebp),%edx
c00056d0:	8b 45 0c             	mov    0xc(%ebp),%eax
c00056d3:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c00056d7:	88 45 f8             	mov    %al,-0x8(%ebp)
/work/x86_os_my/lib/kernel/io.h:21
/*********************************************************
 a表示用寄存器al或ax或eax,对端口指定N表示0~255, d表示用dx存储端口号, 
 %b0表示对应al,%w1表示对应dx */ 
   asm volatile ( "outb %b0, %w1" : : "a" (data), "Nd" (port));    
c00056da:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c00056de:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c00056e2:	ee                   	out    %al,(%dx)
/work/x86_os_my/lib/kernel/io.h:23
/******************************************************/
}
c00056e3:	90                   	nop
c00056e4:	c9                   	leave  
c00056e5:	c3                   	ret    

c00056e6 <outsw>:
outsw():
/work/x86_os_my/lib/kernel/io.h:26

/* 将addr处起始的word_cnt个字写入端口port */
static inline void outsw(uint16_t port, const void* addr, uint32_t word_cnt) {
c00056e6:	55                   	push   %ebp
c00056e7:	89 e5                	mov    %esp,%ebp
c00056e9:	56                   	push   %esi
c00056ea:	53                   	push   %ebx
c00056eb:	83 ec 04             	sub    $0x4,%esp
c00056ee:	8b 45 08             	mov    0x8(%ebp),%eax
c00056f1:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/io.h:31
/*********************************************************
   +表示此限制即做输入又做输出.
   outsw是把ds:esi处的16位的内容写入port端口, 我们在设置段描述符时, 
   已经将ds,es,ss段的选择子都设置为相同的值了,此时不用担心数据错乱。*/
   asm volatile ("cld; rep outsw" : "+S" (addr), "+c" (word_cnt) : "d" (port));
c00056f5:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c00056f9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c00056fc:	8b 45 10             	mov    0x10(%ebp),%eax
c00056ff:	89 cb                	mov    %ecx,%ebx
c0005701:	89 de                	mov    %ebx,%esi
c0005703:	89 c1                	mov    %eax,%ecx
c0005705:	fc                   	cld    
c0005706:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
c0005709:	89 c8                	mov    %ecx,%eax
c000570b:	89 f3                	mov    %esi,%ebx
c000570d:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c0005710:	89 45 10             	mov    %eax,0x10(%ebp)
/work/x86_os_my/lib/kernel/io.h:33
/******************************************************/
}
c0005713:	90                   	nop
c0005714:	83 c4 04             	add    $0x4,%esp
c0005717:	5b                   	pop    %ebx
c0005718:	5e                   	pop    %esi
c0005719:	5d                   	pop    %ebp
c000571a:	c3                   	ret    

c000571b <inb>:
inb():
/work/x86_os_my/lib/kernel/io.h:36

/* 将从端口port读入的一个字节返回 */
static inline uint8_t inb(uint16_t port) {
c000571b:	55                   	push   %ebp
c000571c:	89 e5                	mov    %esp,%ebp
c000571e:	83 ec 14             	sub    $0x14,%esp
c0005721:	8b 45 08             	mov    0x8(%ebp),%eax
c0005724:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
/work/x86_os_my/lib/kernel/io.h:38
   uint8_t data;
   asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0005728:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c000572c:	89 c2                	mov    %eax,%edx
c000572e:	ec                   	in     (%dx),%al
c000572f:	88 45 ff             	mov    %al,-0x1(%ebp)
/work/x86_os_my/lib/kernel/io.h:39
   return data;
c0005732:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
/work/x86_os_my/lib/kernel/io.h:40
}
c0005736:	c9                   	leave  
c0005737:	c3                   	ret    

c0005738 <insw>:
insw():
/work/x86_os_my/lib/kernel/io.h:43

/* 将从端口port读入的word_cnt个字写入addr */
static inline void insw(uint16_t port, void* addr, uint32_t word_cnt) {
c0005738:	55                   	push   %ebp
c0005739:	89 e5                	mov    %esp,%ebp
c000573b:	57                   	push   %edi
c000573c:	53                   	push   %ebx
c000573d:	83 ec 04             	sub    $0x4,%esp
c0005740:	8b 45 08             	mov    0x8(%ebp),%eax
c0005743:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/io.h:48
/******************************************************
   insw是将从端口port处读入的16位内容写入es:edi指向的内存,
   我们在设置段描述符时, 已经将ds,es,ss段的选择子都设置为相同的值了,
   此时不用担心数据错乱。*/
   asm volatile ("cld; rep insw" : "+D" (addr), "+c" (word_cnt) : "d" (port) : "memory");
c0005747:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c000574b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c000574e:	8b 45 10             	mov    0x10(%ebp),%eax
c0005751:	89 cb                	mov    %ecx,%ebx
c0005753:	89 df                	mov    %ebx,%edi
c0005755:	89 c1                	mov    %eax,%ecx
c0005757:	fc                   	cld    
c0005758:	66 f3 6d             	rep insw (%dx),%es:(%edi)
c000575b:	89 c8                	mov    %ecx,%eax
c000575d:	89 fb                	mov    %edi,%ebx
c000575f:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c0005762:	89 45 10             	mov    %eax,0x10(%ebp)
/work/x86_os_my/lib/kernel/io.h:50
/******************************************************/
}
c0005765:	90                   	nop
c0005766:	83 c4 04             	add    $0x4,%esp
c0005769:	5b                   	pop    %ebx
c000576a:	5f                   	pop    %edi
c000576b:	5d                   	pop    %ebp
c000576c:	c3                   	ret    

c000576d <select_disk>:
select_disk():
/work/x86_os_my/device/ide.c:78
} __attribute__ ((packed));


/////////////////////////////////////// ide驱动部分 ////////////////////////////////////////////////
/* 选择读写的硬盘 */
static void select_disk(struct disk* hd) {
c000576d:	55                   	push   %ebp
c000576e:	89 e5                	mov    %esp,%ebp
c0005770:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/device/ide.c:79
	uint8_t reg_device = BIT_DEV_MBS | BIT_DEV_LBA;
c0005773:	c6 45 ff e0          	movb   $0xe0,-0x1(%ebp)
/work/x86_os_my/device/ide.c:80
	if (hd->dev_no == 1) {	// 若是从盘就置DEV位为1
c0005777:	8b 45 08             	mov    0x8(%ebp),%eax
c000577a:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
c000577e:	3c 01                	cmp    $0x1,%al
c0005780:	75 04                	jne    c0005786 <select_disk+0x19>
/work/x86_os_my/device/ide.c:81
		reg_device |= BIT_DEV_DEV;
c0005782:	80 4d ff 10          	orb    $0x10,-0x1(%ebp)
/work/x86_os_my/device/ide.c:83
	}
	outb(reg_dev(hd->my_channel), reg_device);
c0005786:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c000578a:	8b 45 08             	mov    0x8(%ebp),%eax
c000578d:	8b 40 08             	mov    0x8(%eax),%eax
c0005790:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005794:	83 c0 06             	add    $0x6,%eax
c0005797:	0f b7 c0             	movzwl %ax,%eax
c000579a:	52                   	push   %edx
c000579b:	50                   	push   %eax
c000579c:	e8 26 ff ff ff       	call   c00056c7 <outb>
c00057a1:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/ide.c:84
}
c00057a4:	90                   	nop
c00057a5:	c9                   	leave  
c00057a6:	c3                   	ret    

c00057a7 <select_sector>:
select_sector():
/work/x86_os_my/device/ide.c:87

/* 向硬盘控制器写入起始扇区地址及要读写的扇区数 */
static void select_sector(struct disk* hd, uint32_t lba, uint8_t sec_cnt) {
c00057a7:	55                   	push   %ebp
c00057a8:	89 e5                	mov    %esp,%ebp
c00057aa:	83 ec 28             	sub    $0x28,%esp
c00057ad:	8b 45 10             	mov    0x10(%ebp),%eax
c00057b0:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/device/ide.c:88
	ASSERT(lba <= max_lba);
c00057b3:	81 7d 0c ff 7f 02 00 	cmpl   $0x27fff,0xc(%ebp)
c00057ba:	76 19                	jbe    c00057d5 <select_sector+0x2e>
/work/x86_os_my/device/ide.c:88 (discriminator 1)
c00057bc:	68 5c bf 00 c0       	push   $0xc000bf5c
c00057c1:	68 f4 c0 00 c0       	push   $0xc000c0f4
c00057c6:	6a 58                	push   $0x58
c00057c8:	68 6b bf 00 c0       	push   $0xc000bf6b
c00057cd:	e8 10 cb ff ff       	call   c00022e2 <panic_spin>
c00057d2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:89
	struct ide_channel* channel = hd->my_channel;
c00057d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00057d8:	8b 40 08             	mov    0x8(%eax),%eax
c00057db:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:92

	/* 写入要读写的扇区数*/
	outb(reg_sect_cnt(channel), sec_cnt);	// 如果sec_cnt为0,则表示写入256个扇区
c00057de:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
c00057e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00057e5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00057e9:	83 c0 02             	add    $0x2,%eax
c00057ec:	0f b7 c0             	movzwl %ax,%eax
c00057ef:	83 ec 08             	sub    $0x8,%esp
c00057f2:	52                   	push   %edx
c00057f3:	50                   	push   %eax
c00057f4:	e8 ce fe ff ff       	call   c00056c7 <outb>
c00057f9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:95

	/* 写入lba地址(即扇区号) */
	outb(reg_lba_l(channel), lba);			// lba地址的低8位,不用单独取出低8位.outb函数中的汇编指令outb %b0, %w1会只用al。
c00057fc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00057ff:	0f b6 d0             	movzbl %al,%edx
c0005802:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005805:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005809:	83 c0 03             	add    $0x3,%eax
c000580c:	0f b7 c0             	movzwl %ax,%eax
c000580f:	83 ec 08             	sub    $0x8,%esp
c0005812:	52                   	push   %edx
c0005813:	50                   	push   %eax
c0005814:	e8 ae fe ff ff       	call   c00056c7 <outb>
c0005819:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:96
	outb(reg_lba_m(channel), lba >> 8);		// lba地址的8~15位
c000581c:	8b 45 0c             	mov    0xc(%ebp),%eax
c000581f:	c1 e8 08             	shr    $0x8,%eax
c0005822:	0f b6 d0             	movzbl %al,%edx
c0005825:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005828:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c000582c:	83 c0 04             	add    $0x4,%eax
c000582f:	0f b7 c0             	movzwl %ax,%eax
c0005832:	83 ec 08             	sub    $0x8,%esp
c0005835:	52                   	push   %edx
c0005836:	50                   	push   %eax
c0005837:	e8 8b fe ff ff       	call   c00056c7 <outb>
c000583c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:97
	outb(reg_lba_h(channel), lba >> 16);	// lba地址的16~23位
c000583f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005842:	c1 e8 10             	shr    $0x10,%eax
c0005845:	0f b6 d0             	movzbl %al,%edx
c0005848:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000584b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c000584f:	83 c0 05             	add    $0x5,%eax
c0005852:	0f b7 c0             	movzwl %ax,%eax
c0005855:	83 ec 08             	sub    $0x8,%esp
c0005858:	52                   	push   %edx
c0005859:	50                   	push   %eax
c000585a:	e8 68 fe ff ff       	call   c00056c7 <outb>
c000585f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:101

	/* 因为lba地址的24~27位要存储在device寄存器的0～3位,
	* 无法单独写入这4位,所以在此处把device寄存器再重新写入一次*/
	outb(reg_dev(channel), BIT_DEV_MBS | BIT_DEV_LBA | (hd->dev_no == 1 ? BIT_DEV_DEV : 0) | lba >> 24);
c0005862:	8b 45 08             	mov    0x8(%ebp),%eax
c0005865:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
c0005869:	3c 01                	cmp    $0x1,%al
c000586b:	75 07                	jne    c0005874 <select_sector+0xcd>
/work/x86_os_my/device/ide.c:101 (discriminator 1)
c000586d:	ba f0 ff ff ff       	mov    $0xfffffff0,%edx
c0005872:	eb 05                	jmp    c0005879 <select_sector+0xd2>
/work/x86_os_my/device/ide.c:101 (discriminator 2)
c0005874:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
/work/x86_os_my/device/ide.c:101 (discriminator 4)
c0005879:	8b 45 0c             	mov    0xc(%ebp),%eax
c000587c:	c1 e8 18             	shr    $0x18,%eax
c000587f:	09 d0                	or     %edx,%eax
c0005881:	0f b6 d0             	movzbl %al,%edx
c0005884:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005887:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c000588b:	83 c0 06             	add    $0x6,%eax
c000588e:	0f b7 c0             	movzwl %ax,%eax
c0005891:	83 ec 08             	sub    $0x8,%esp
c0005894:	52                   	push   %edx
c0005895:	50                   	push   %eax
c0005896:	e8 2c fe ff ff       	call   c00056c7 <outb>
c000589b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:102 (discriminator 4)
}
c000589e:	90                   	nop
c000589f:	c9                   	leave  
c00058a0:	c3                   	ret    

c00058a1 <cmd_out>:
cmd_out():
/work/x86_os_my/device/ide.c:105

/* 向通道channel发命令cmd */
static void cmd_out(struct ide_channel* channel, uint8_t cmd) {
c00058a1:	55                   	push   %ebp
c00058a2:	89 e5                	mov    %esp,%ebp
c00058a4:	83 ec 04             	sub    $0x4,%esp
c00058a7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00058aa:	88 45 fc             	mov    %al,-0x4(%ebp)
/work/x86_os_my/device/ide.c:107
	/* 只要向硬盘发出了命令便将此标记置为true,硬盘中断处理程序需要根据它来判断 */
	channel->expecting_intr = true;
c00058ad:	8b 45 08             	mov    0x8(%ebp),%eax
c00058b0:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
/work/x86_os_my/device/ide.c:108
	outb(reg_cmd(channel), cmd);
c00058b7:	0f b6 55 fc          	movzbl -0x4(%ebp),%edx
c00058bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00058be:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00058c2:	83 c0 07             	add    $0x7,%eax
c00058c5:	0f b7 c0             	movzwl %ax,%eax
c00058c8:	52                   	push   %edx
c00058c9:	50                   	push   %eax
c00058ca:	e8 f8 fd ff ff       	call   c00056c7 <outb>
c00058cf:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/ide.c:109
}
c00058d2:	90                   	nop
c00058d3:	c9                   	leave  
c00058d4:	c3                   	ret    

c00058d5 <read_from_sector>:
read_from_sector():
/work/x86_os_my/device/ide.c:112

/* 硬盘读入sec_cnt个扇区的数据到buf */
static void read_from_sector(struct disk* hd, void* buf, uint8_t sec_cnt) {
c00058d5:	55                   	push   %ebp
c00058d6:	89 e5                	mov    %esp,%ebp
c00058d8:	83 ec 14             	sub    $0x14,%esp
c00058db:	8b 45 10             	mov    0x10(%ebp),%eax
c00058de:	88 45 ec             	mov    %al,-0x14(%ebp)
/work/x86_os_my/device/ide.c:114
	uint32_t size_in_byte;
	if (sec_cnt == 0) {
c00058e1:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
c00058e5:	75 09                	jne    c00058f0 <read_from_sector+0x1b>
/work/x86_os_my/device/ide.c:116
		/* 因为sec_cnt是8位变量,由主调函数将其赋值时,若为256则会将最高位的1丢掉变为0 */
		size_in_byte = 256 * 512;
c00058e7:	c7 45 fc 00 00 02 00 	movl   $0x20000,-0x4(%ebp)
c00058ee:	eb 0a                	jmp    c00058fa <read_from_sector+0x25>
/work/x86_os_my/device/ide.c:118
	} else { 
		size_in_byte = sec_cnt * 512; 
c00058f0:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c00058f4:	c1 e0 09             	shl    $0x9,%eax
c00058f7:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/device/ide.c:120
	}
	insw(reg_data(hd->my_channel), buf, size_in_byte / 2);
c00058fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00058fd:	d1 e8                	shr    %eax
c00058ff:	89 c2                	mov    %eax,%edx
c0005901:	8b 45 08             	mov    0x8(%ebp),%eax
c0005904:	8b 40 08             	mov    0x8(%eax),%eax
c0005907:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c000590b:	0f b7 c0             	movzwl %ax,%eax
c000590e:	52                   	push   %edx
c000590f:	ff 75 0c             	pushl  0xc(%ebp)
c0005912:	50                   	push   %eax
c0005913:	e8 20 fe ff ff       	call   c0005738 <insw>
c0005918:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/device/ide.c:121
}
c000591b:	90                   	nop
c000591c:	c9                   	leave  
c000591d:	c3                   	ret    

c000591e <write2sector>:
write2sector():
/work/x86_os_my/device/ide.c:124

/* 将buf中sec_cnt扇区的数据写入硬盘 */
static void write2sector(struct disk* hd, void* buf, uint8_t sec_cnt) {
c000591e:	55                   	push   %ebp
c000591f:	89 e5                	mov    %esp,%ebp
c0005921:	83 ec 14             	sub    $0x14,%esp
c0005924:	8b 45 10             	mov    0x10(%ebp),%eax
c0005927:	88 45 ec             	mov    %al,-0x14(%ebp)
/work/x86_os_my/device/ide.c:126
	uint32_t size_in_byte;
	if (sec_cnt == 0) {
c000592a:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
c000592e:	75 09                	jne    c0005939 <write2sector+0x1b>
/work/x86_os_my/device/ide.c:128
		/* 因为sec_cnt是8位变量,由主调函数将其赋值时,若为256则会将最高位的1丢掉变为0 */
		size_in_byte = 256 * 512;
c0005930:	c7 45 fc 00 00 02 00 	movl   $0x20000,-0x4(%ebp)
c0005937:	eb 0a                	jmp    c0005943 <write2sector+0x25>
/work/x86_os_my/device/ide.c:130
	} else { 
		size_in_byte = sec_cnt * 512; 
c0005939:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c000593d:	c1 e0 09             	shl    $0x9,%eax
c0005940:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/device/ide.c:132
	}
	outsw(reg_data(hd->my_channel), buf, size_in_byte / 2);
c0005943:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0005946:	d1 e8                	shr    %eax
c0005948:	89 c2                	mov    %eax,%edx
c000594a:	8b 45 08             	mov    0x8(%ebp),%eax
c000594d:	8b 40 08             	mov    0x8(%eax),%eax
c0005950:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005954:	0f b7 c0             	movzwl %ax,%eax
c0005957:	52                   	push   %edx
c0005958:	ff 75 0c             	pushl  0xc(%ebp)
c000595b:	50                   	push   %eax
c000595c:	e8 85 fd ff ff       	call   c00056e6 <outsw>
c0005961:	83 c4 0c             	add    $0xc,%esp
/work/x86_os_my/device/ide.c:133
}
c0005964:	90                   	nop
c0005965:	c9                   	leave  
c0005966:	c3                   	ret    

c0005967 <busy_wait>:
busy_wait():
/work/x86_os_my/device/ide.c:136

/* 等待30秒 */
static bool busy_wait(struct disk* hd) {
c0005967:	55                   	push   %ebp
c0005968:	89 e5                	mov    %esp,%ebp
c000596a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ide.c:137
	struct ide_channel* channel = hd->my_channel;
c000596d:	8b 45 08             	mov    0x8(%ebp),%eax
c0005970:	8b 40 08             	mov    0x8(%eax),%eax
c0005973:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:138
	uint16_t time_limit = 30 * 1000;	// 可以等待30000毫秒
c0005976:	66 c7 45 f6 30 75    	movw   $0x7530,-0xa(%ebp)
/work/x86_os_my/device/ide.c:139
	while (time_limit -= 10 >= 0) {
c000597c:	eb 45                	jmp    c00059c3 <busy_wait+0x5c>
/work/x86_os_my/device/ide.c:140
		if (!(inb(reg_status(channel)) & BIT_STAT_BSY)) {
c000597e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005981:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0005985:	83 c0 07             	add    $0x7,%eax
c0005988:	0f b7 c0             	movzwl %ax,%eax
c000598b:	50                   	push   %eax
c000598c:	e8 8a fd ff ff       	call   c000571b <inb>
c0005991:	83 c4 04             	add    $0x4,%esp
c0005994:	84 c0                	test   %al,%al
c0005996:	78 1e                	js     c00059b6 <busy_wait+0x4f>
/work/x86_os_my/device/ide.c:141
			return (inb(reg_status(channel)) & BIT_STAT_DRQ);
c0005998:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000599b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c000599f:	83 c0 07             	add    $0x7,%eax
c00059a2:	0f b7 c0             	movzwl %ax,%eax
c00059a5:	50                   	push   %eax
c00059a6:	e8 70 fd ff ff       	call   c000571b <inb>
c00059ab:	83 c4 04             	add    $0x4,%esp
c00059ae:	0f b6 c0             	movzbl %al,%eax
c00059b1:	83 e0 08             	and    $0x8,%eax
c00059b4:	eb 1e                	jmp    c00059d4 <busy_wait+0x6d>
/work/x86_os_my/device/ide.c:143
		} else {
			mtime_sleep(10);			// 睡眠10毫秒
c00059b6:	83 ec 0c             	sub    $0xc,%esp
c00059b9:	6a 0a                	push   $0xa
c00059bb:	e8 a8 c1 ff ff       	call   c0001b68 <mtime_sleep>
c00059c0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:139

/* 等待30秒 */
static bool busy_wait(struct disk* hd) {
	struct ide_channel* channel = hd->my_channel;
	uint16_t time_limit = 30 * 1000;	// 可以等待30000毫秒
	while (time_limit -= 10 >= 0) {
c00059c3:	66 83 6d f6 01       	subw   $0x1,-0xa(%ebp)
c00059c8:	66 83 7d f6 00       	cmpw   $0x0,-0xa(%ebp)
c00059cd:	75 af                	jne    c000597e <busy_wait+0x17>
/work/x86_os_my/device/ide.c:146
			return (inb(reg_status(channel)) & BIT_STAT_DRQ);
		} else {
			mtime_sleep(10);			// 睡眠10毫秒
		}
	}
	return false;
c00059cf:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/device/ide.c:147
}
c00059d4:	c9                   	leave  
c00059d5:	c3                   	ret    

c00059d6 <ide_read>:
ide_read():
/work/x86_os_my/device/ide.c:150

/* 从硬盘读取sec_cnt个扇区到buf */
void ide_read(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt) { 
c00059d6:	55                   	push   %ebp
c00059d7:	89 e5                	mov    %esp,%ebp
c00059d9:	83 ec 58             	sub    $0x58,%esp
/work/x86_os_my/device/ide.c:151
	ASSERT(lba <= max_lba);
c00059dc:	81 7d 0c ff 7f 02 00 	cmpl   $0x27fff,0xc(%ebp)
c00059e3:	76 1c                	jbe    c0005a01 <ide_read+0x2b>
/work/x86_os_my/device/ide.c:151 (discriminator 1)
c00059e5:	68 5c bf 00 c0       	push   $0xc000bf5c
c00059ea:	68 04 c1 00 c0       	push   $0xc000c104
c00059ef:	68 97 00 00 00       	push   $0x97
c00059f4:	68 6b bf 00 c0       	push   $0xc000bf6b
c00059f9:	e8 e4 c8 ff ff       	call   c00022e2 <panic_spin>
c00059fe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:152
	ASSERT(sec_cnt > 0);
c0005a01:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0005a05:	75 1c                	jne    c0005a23 <ide_read+0x4d>
/work/x86_os_my/device/ide.c:152 (discriminator 1)
c0005a07:	68 78 bf 00 c0       	push   $0xc000bf78
c0005a0c:	68 04 c1 00 c0       	push   $0xc000c104
c0005a11:	68 98 00 00 00       	push   $0x98
c0005a16:	68 6b bf 00 c0       	push   $0xc000bf6b
c0005a1b:	e8 c2 c8 ff ff       	call   c00022e2 <panic_spin>
c0005a20:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:153
	lock_acquire (&hd->my_channel->lock);
c0005a23:	8b 45 08             	mov    0x8(%ebp),%eax
c0005a26:	8b 40 08             	mov    0x8(%eax),%eax
c0005a29:	83 c0 0c             	add    $0xc,%eax
c0005a2c:	83 ec 0c             	sub    $0xc,%esp
c0005a2f:	50                   	push   %eax
c0005a30:	e8 0a ed ff ff       	call   c000473f <lock_acquire>
c0005a35:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:156

	/* 1 先选择操作的硬盘 */
	select_disk(hd);
c0005a38:	83 ec 0c             	sub    $0xc,%esp
c0005a3b:	ff 75 08             	pushl  0x8(%ebp)
c0005a3e:	e8 2a fd ff ff       	call   c000576d <select_disk>
c0005a43:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:159

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
c0005a46:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/ide.c:160
	while(secs_done < sec_cnt) {
c0005a4d:	e9 d4 00 00 00       	jmp    c0005b26 <ide_read+0x150>
/work/x86_os_my/device/ide.c:161
		if ((secs_done + 256) <= sec_cnt) {
c0005a52:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005a55:	05 00 01 00 00       	add    $0x100,%eax
c0005a5a:	3b 45 14             	cmp    0x14(%ebp),%eax
c0005a5d:	77 09                	ja     c0005a68 <ide_read+0x92>
/work/x86_os_my/device/ide.c:162
			secs_op = 256;
c0005a5f:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
c0005a66:	eb 09                	jmp    c0005a71 <ide_read+0x9b>
/work/x86_os_my/device/ide.c:164
		} else {
			secs_op = sec_cnt - secs_done;
c0005a68:	8b 45 14             	mov    0x14(%ebp),%eax
c0005a6b:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0005a6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:168
		}

		/* 2 写入待读入的扇区数和起始扇区号 */
		select_sector(hd, lba + secs_done, secs_op);
c0005a71:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005a74:	0f b6 c0             	movzbl %al,%eax
c0005a77:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0005a7a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0005a7d:	01 ca                	add    %ecx,%edx
c0005a7f:	83 ec 04             	sub    $0x4,%esp
c0005a82:	50                   	push   %eax
c0005a83:	52                   	push   %edx
c0005a84:	ff 75 08             	pushl  0x8(%ebp)
c0005a87:	e8 1b fd ff ff       	call   c00057a7 <select_sector>
c0005a8c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:171

		/* 3 执行的命令写入reg_cmd寄存器 */
		cmd_out(hd->my_channel, CMD_READ_SECTOR);	// 准备开始读数据
c0005a8f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005a92:	8b 40 08             	mov    0x8(%eax),%eax
c0005a95:	83 ec 08             	sub    $0x8,%esp
c0005a98:	6a 20                	push   $0x20
c0005a9a:	50                   	push   %eax
c0005a9b:	e8 01 fe ff ff       	call   c00058a1 <cmd_out>
c0005aa0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:176

		/*********************   阻塞自己的时机  ***********************
		在硬盘已经开始工作(开始在内部读数据或写数据)后才能阻塞自己,现在硬盘已经开始忙了,
		将自己阻塞,等待硬盘完成读操作后通过中断处理程序唤醒自己*/
		sema_down(&hd->my_channel->disk_done);
c0005aa3:	8b 45 08             	mov    0x8(%ebp),%eax
c0005aa6:	8b 40 08             	mov    0x8(%eax),%eax
c0005aa9:	83 c0 2c             	add    $0x2c,%eax
c0005aac:	83 ec 0c             	sub    $0xc,%esp
c0005aaf:	50                   	push   %eax
c0005ab0:	e8 e0 ea ff ff       	call   c0004595 <sema_down>
c0005ab5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:181
		/*************************************************************/

		/* 4 检测硬盘状态是否可读 */
		/* 醒来后开始执行下面代码*/
		if (!busy_wait(hd)) {	// 若失败
c0005ab8:	83 ec 0c             	sub    $0xc,%esp
c0005abb:	ff 75 08             	pushl  0x8(%ebp)
c0005abe:	e8 a4 fe ff ff       	call   c0005967 <busy_wait>
c0005ac3:	83 c4 10             	add    $0x10,%esp
c0005ac6:	85 c0                	test   %eax,%eax
c0005ac8:	75 33                	jne    c0005afd <ide_read+0x127>
/work/x86_os_my/device/ide.c:183
			char error[64];
			sprintf(error, "%s read sector %d failed!!!!!!\n", hd->name, lba);
c0005aca:	8b 45 08             	mov    0x8(%ebp),%eax
c0005acd:	ff 75 0c             	pushl  0xc(%ebp)
c0005ad0:	50                   	push   %eax
c0005ad1:	68 84 bf 00 c0       	push   $0xc000bf84
c0005ad6:	8d 45 b0             	lea    -0x50(%ebp),%eax
c0005ad9:	50                   	push   %eax
c0005ada:	e8 48 fb ff ff       	call   c0005627 <sprintf>
c0005adf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:184
			PANIC(error);
c0005ae2:	8d 45 b0             	lea    -0x50(%ebp),%eax
c0005ae5:	50                   	push   %eax
c0005ae6:	68 04 c1 00 c0       	push   $0xc000c104
c0005aeb:	68 b8 00 00 00       	push   $0xb8
c0005af0:	68 6b bf 00 c0       	push   $0xc000bf6b
c0005af5:	e8 e8 c7 ff ff       	call   c00022e2 <panic_spin>
c0005afa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:188
		}

		/* 5 把数据从硬盘的缓冲区中读出 */
		read_from_sector(hd, (void*)((uint32_t)buf + secs_done * 512), secs_op);
c0005afd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005b00:	0f b6 c0             	movzbl %al,%eax
c0005b03:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0005b06:	89 d1                	mov    %edx,%ecx
c0005b08:	c1 e1 09             	shl    $0x9,%ecx
c0005b0b:	8b 55 10             	mov    0x10(%ebp),%edx
c0005b0e:	01 ca                	add    %ecx,%edx
c0005b10:	83 ec 04             	sub    $0x4,%esp
c0005b13:	50                   	push   %eax
c0005b14:	52                   	push   %edx
c0005b15:	ff 75 08             	pushl  0x8(%ebp)
c0005b18:	e8 b8 fd ff ff       	call   c00058d5 <read_from_sector>
c0005b1d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:189
		secs_done += secs_op;
c0005b20:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005b23:	01 45 f0             	add    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:160
	/* 1 先选择操作的硬盘 */
	select_disk(hd);

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
	while(secs_done < sec_cnt) {
c0005b26:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005b29:	3b 45 14             	cmp    0x14(%ebp),%eax
c0005b2c:	0f 82 20 ff ff ff    	jb     c0005a52 <ide_read+0x7c>
/work/x86_os_my/device/ide.c:191

		/* 5 把数据从硬盘的缓冲区中读出 */
		read_from_sector(hd, (void*)((uint32_t)buf + secs_done * 512), secs_op);
		secs_done += secs_op;
	}
	lock_release(&hd->my_channel->lock);
c0005b32:	8b 45 08             	mov    0x8(%ebp),%eax
c0005b35:	8b 40 08             	mov    0x8(%eax),%eax
c0005b38:	83 c0 0c             	add    $0xc,%eax
c0005b3b:	83 ec 0c             	sub    $0xc,%esp
c0005b3e:	50                   	push   %eax
c0005b3f:	e8 72 ec ff ff       	call   c00047b6 <lock_release>
c0005b44:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:192
}
c0005b47:	90                   	nop
c0005b48:	c9                   	leave  
c0005b49:	c3                   	ret    

c0005b4a <ide_write>:
ide_write():
/work/x86_os_my/device/ide.c:195

/* 将buf中sec_cnt扇区数据写入硬盘 */
void ide_write(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt) {
c0005b4a:	55                   	push   %ebp
c0005b4b:	89 e5                	mov    %esp,%ebp
c0005b4d:	83 ec 58             	sub    $0x58,%esp
/work/x86_os_my/device/ide.c:196
	ASSERT(lba <= max_lba);
c0005b50:	81 7d 0c ff 7f 02 00 	cmpl   $0x27fff,0xc(%ebp)
c0005b57:	76 1c                	jbe    c0005b75 <ide_write+0x2b>
/work/x86_os_my/device/ide.c:196 (discriminator 1)
c0005b59:	68 5c bf 00 c0       	push   $0xc000bf5c
c0005b5e:	68 10 c1 00 c0       	push   $0xc000c110
c0005b63:	68 c4 00 00 00       	push   $0xc4
c0005b68:	68 6b bf 00 c0       	push   $0xc000bf6b
c0005b6d:	e8 70 c7 ff ff       	call   c00022e2 <panic_spin>
c0005b72:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:197
	ASSERT(sec_cnt > 0);
c0005b75:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c0005b79:	75 1c                	jne    c0005b97 <ide_write+0x4d>
/work/x86_os_my/device/ide.c:197 (discriminator 1)
c0005b7b:	68 78 bf 00 c0       	push   $0xc000bf78
c0005b80:	68 10 c1 00 c0       	push   $0xc000c110
c0005b85:	68 c5 00 00 00       	push   $0xc5
c0005b8a:	68 6b bf 00 c0       	push   $0xc000bf6b
c0005b8f:	e8 4e c7 ff ff       	call   c00022e2 <panic_spin>
c0005b94:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:198
	lock_acquire (&hd->my_channel->lock);
c0005b97:	8b 45 08             	mov    0x8(%ebp),%eax
c0005b9a:	8b 40 08             	mov    0x8(%eax),%eax
c0005b9d:	83 c0 0c             	add    $0xc,%eax
c0005ba0:	83 ec 0c             	sub    $0xc,%esp
c0005ba3:	50                   	push   %eax
c0005ba4:	e8 96 eb ff ff       	call   c000473f <lock_acquire>
c0005ba9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:201

	/* 1 先选择操作的硬盘 */
	select_disk(hd);
c0005bac:	83 ec 0c             	sub    $0xc,%esp
c0005baf:	ff 75 08             	pushl  0x8(%ebp)
c0005bb2:	e8 b6 fb ff ff       	call   c000576d <select_disk>
c0005bb7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:204

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
c0005bba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/device/ide.c:205
	while(secs_done < sec_cnt) {
c0005bc1:	e9 d4 00 00 00       	jmp    c0005c9a <ide_write+0x150>
/work/x86_os_my/device/ide.c:206
		if ((secs_done + 256) <= sec_cnt) {
c0005bc6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005bc9:	05 00 01 00 00       	add    $0x100,%eax
c0005bce:	3b 45 14             	cmp    0x14(%ebp),%eax
c0005bd1:	77 09                	ja     c0005bdc <ide_write+0x92>
/work/x86_os_my/device/ide.c:207
			secs_op = 256;
c0005bd3:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
c0005bda:	eb 09                	jmp    c0005be5 <ide_write+0x9b>
/work/x86_os_my/device/ide.c:209
		} else {
			secs_op = sec_cnt - secs_done;
c0005bdc:	8b 45 14             	mov    0x14(%ebp),%eax
c0005bdf:	2b 45 f0             	sub    -0x10(%ebp),%eax
c0005be2:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:213
		}

		/* 2 写入待写入的扇区数和起始扇区号 */
		select_sector(hd, lba + secs_done, secs_op);
c0005be5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005be8:	0f b6 c0             	movzbl %al,%eax
c0005beb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0005bee:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0005bf1:	01 ca                	add    %ecx,%edx
c0005bf3:	83 ec 04             	sub    $0x4,%esp
c0005bf6:	50                   	push   %eax
c0005bf7:	52                   	push   %edx
c0005bf8:	ff 75 08             	pushl  0x8(%ebp)
c0005bfb:	e8 a7 fb ff ff       	call   c00057a7 <select_sector>
c0005c00:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:216

		/* 3 执行的命令写入reg_cmd寄存器 */
		cmd_out(hd->my_channel, CMD_WRITE_SECTOR);	// 准备开始写数据
c0005c03:	8b 45 08             	mov    0x8(%ebp),%eax
c0005c06:	8b 40 08             	mov    0x8(%eax),%eax
c0005c09:	83 ec 08             	sub    $0x8,%esp
c0005c0c:	6a 30                	push   $0x30
c0005c0e:	50                   	push   %eax
c0005c0f:	e8 8d fc ff ff       	call   c00058a1 <cmd_out>
c0005c14:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:219

		/* 4 检测硬盘状态是否可读 */
		if (!busy_wait(hd)) {	// 若失败
c0005c17:	83 ec 0c             	sub    $0xc,%esp
c0005c1a:	ff 75 08             	pushl  0x8(%ebp)
c0005c1d:	e8 45 fd ff ff       	call   c0005967 <busy_wait>
c0005c22:	83 c4 10             	add    $0x10,%esp
c0005c25:	85 c0                	test   %eax,%eax
c0005c27:	75 33                	jne    c0005c5c <ide_write+0x112>
/work/x86_os_my/device/ide.c:221
			char error[64];
			sprintf(error, "%s write sector %d failed!!!!!!\n", hd->name, lba);
c0005c29:	8b 45 08             	mov    0x8(%ebp),%eax
c0005c2c:	ff 75 0c             	pushl  0xc(%ebp)
c0005c2f:	50                   	push   %eax
c0005c30:	68 a4 bf 00 c0       	push   $0xc000bfa4
c0005c35:	8d 45 b0             	lea    -0x50(%ebp),%eax
c0005c38:	50                   	push   %eax
c0005c39:	e8 e9 f9 ff ff       	call   c0005627 <sprintf>
c0005c3e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:222
			PANIC(error);
c0005c41:	8d 45 b0             	lea    -0x50(%ebp),%eax
c0005c44:	50                   	push   %eax
c0005c45:	68 10 c1 00 c0       	push   $0xc000c110
c0005c4a:	68 de 00 00 00       	push   $0xde
c0005c4f:	68 6b bf 00 c0       	push   $0xc000bf6b
c0005c54:	e8 89 c6 ff ff       	call   c00022e2 <panic_spin>
c0005c59:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:226
		}

		/* 5 将数据写入硬盘 */
		write2sector(hd, (void*)((uint32_t)buf + secs_done * 512), secs_op);
c0005c5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005c5f:	0f b6 c0             	movzbl %al,%eax
c0005c62:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0005c65:	89 d1                	mov    %edx,%ecx
c0005c67:	c1 e1 09             	shl    $0x9,%ecx
c0005c6a:	8b 55 10             	mov    0x10(%ebp),%edx
c0005c6d:	01 ca                	add    %ecx,%edx
c0005c6f:	83 ec 04             	sub    $0x4,%esp
c0005c72:	50                   	push   %eax
c0005c73:	52                   	push   %edx
c0005c74:	ff 75 08             	pushl  0x8(%ebp)
c0005c77:	e8 a2 fc ff ff       	call   c000591e <write2sector>
c0005c7c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:229

		/* 在硬盘响应期间阻塞自己 */
		sema_down(&hd->my_channel->disk_done);
c0005c7f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005c82:	8b 40 08             	mov    0x8(%eax),%eax
c0005c85:	83 c0 2c             	add    $0x2c,%eax
c0005c88:	83 ec 0c             	sub    $0xc,%esp
c0005c8b:	50                   	push   %eax
c0005c8c:	e8 04 e9 ff ff       	call   c0004595 <sema_down>
c0005c91:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:230
		secs_done += secs_op;
c0005c94:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0005c97:	01 45 f0             	add    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:205
	/* 1 先选择操作的硬盘 */
	select_disk(hd);

	uint32_t secs_op;		// 每次操作的扇区数
	uint32_t secs_done = 0;	// 已完成的扇区数
	while(secs_done < sec_cnt) {
c0005c9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005c9d:	3b 45 14             	cmp    0x14(%ebp),%eax
c0005ca0:	0f 82 20 ff ff ff    	jb     c0005bc6 <ide_write+0x7c>
/work/x86_os_my/device/ide.c:233
		/* 在硬盘响应期间阻塞自己 */
		sema_down(&hd->my_channel->disk_done);
		secs_done += secs_op;
	}
	/* 醒来后开始释放锁*/
	lock_release(&hd->my_channel->lock);
c0005ca6:	8b 45 08             	mov    0x8(%ebp),%eax
c0005ca9:	8b 40 08             	mov    0x8(%eax),%eax
c0005cac:	83 c0 0c             	add    $0xc,%eax
c0005caf:	83 ec 0c             	sub    $0xc,%esp
c0005cb2:	50                   	push   %eax
c0005cb3:	e8 fe ea ff ff       	call   c00047b6 <lock_release>
c0005cb8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:234
}
c0005cbb:	90                   	nop
c0005cbc:	c9                   	leave  
c0005cbd:	c3                   	ret    

c0005cbe <swap_pairs_bytes>:
swap_pairs_bytes():
/work/x86_os_my/device/ide.c:238

/////////////////////////////////////// 读取分区表部分 ////////////////////////////////////////////////
/* 将dst中len个相邻字节交换位置后存入buf */
static void swap_pairs_bytes(const char* dst, char* buf, uint32_t len) {
c0005cbe:	55                   	push   %ebp
c0005cbf:	89 e5                	mov    %esp,%ebp
c0005cc1:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/device/ide.c:240
	uint8_t idx;
	for (idx = 0; idx < len; idx += 2) {
c0005cc4:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
c0005cc8:	eb 37                	jmp    c0005d01 <swap_pairs_bytes+0x43>
/work/x86_os_my/device/ide.c:242 (discriminator 3)
		/* buf中存储dst中两相邻元素交换位置后的字符串*/
		buf[idx + 1] = *dst++;
c0005cca:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c0005cce:	8d 50 01             	lea    0x1(%eax),%edx
c0005cd1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005cd4:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c0005cd7:	8b 45 08             	mov    0x8(%ebp),%eax
c0005cda:	8d 50 01             	lea    0x1(%eax),%edx
c0005cdd:	89 55 08             	mov    %edx,0x8(%ebp)
c0005ce0:	0f b6 00             	movzbl (%eax),%eax
c0005ce3:	88 01                	mov    %al,(%ecx)
/work/x86_os_my/device/ide.c:243 (discriminator 3)
		buf[idx]     = *dst++;
c0005ce5:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c0005ce9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005cec:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c0005cef:	8b 45 08             	mov    0x8(%ebp),%eax
c0005cf2:	8d 50 01             	lea    0x1(%eax),%edx
c0005cf5:	89 55 08             	mov    %edx,0x8(%ebp)
c0005cf8:	0f b6 00             	movzbl (%eax),%eax
c0005cfb:	88 01                	mov    %al,(%ecx)
/work/x86_os_my/device/ide.c:240 (discriminator 3)

/////////////////////////////////////// 读取分区表部分 ////////////////////////////////////////////////
/* 将dst中len个相邻字节交换位置后存入buf */
static void swap_pairs_bytes(const char* dst, char* buf, uint32_t len) {
	uint8_t idx;
	for (idx = 0; idx < len; idx += 2) {
c0005cfd:	80 45 ff 02          	addb   $0x2,-0x1(%ebp)
/work/x86_os_my/device/ide.c:240 (discriminator 1)
c0005d01:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c0005d05:	3b 45 10             	cmp    0x10(%ebp),%eax
c0005d08:	72 c0                	jb     c0005cca <swap_pairs_bytes+0xc>
/work/x86_os_my/device/ide.c:245
		/* buf中存储dst中两相邻元素交换位置后的字符串*/
		buf[idx + 1] = *dst++;
		buf[idx]     = *dst++;
	}
	buf[idx] = '\0';
c0005d0a:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c0005d0e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005d11:	01 d0                	add    %edx,%eax
c0005d13:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/device/ide.c:246
}
c0005d16:	90                   	nop
c0005d17:	c9                   	leave  
c0005d18:	c3                   	ret    

c0005d19 <identify_disk>:
identify_disk():
/work/x86_os_my/device/ide.c:249

/* 获得硬盘参数信息 */
static void identify_disk(struct disk* hd) {
c0005d19:	55                   	push   %ebp
c0005d1a:	89 e5                	mov    %esp,%ebp
c0005d1c:	81 ec 98 02 00 00    	sub    $0x298,%esp
/work/x86_os_my/device/ide.c:251
	char id_info[512];
	select_disk(hd);
c0005d22:	ff 75 08             	pushl  0x8(%ebp)
c0005d25:	e8 43 fa ff ff       	call   c000576d <select_disk>
c0005d2a:	83 c4 04             	add    $0x4,%esp
/work/x86_os_my/device/ide.c:252
	cmd_out(hd->my_channel, CMD_IDENTIFY);
c0005d2d:	8b 45 08             	mov    0x8(%ebp),%eax
c0005d30:	8b 40 08             	mov    0x8(%eax),%eax
c0005d33:	68 ec 00 00 00       	push   $0xec
c0005d38:	50                   	push   %eax
c0005d39:	e8 63 fb ff ff       	call   c00058a1 <cmd_out>
c0005d3e:	83 c4 08             	add    $0x8,%esp
/work/x86_os_my/device/ide.c:255
	/* 向硬盘发送指令后便通过信号量阻塞自己,
	* 待硬盘处理完成后,通过中断处理程序将自己唤醒 */
	sema_down(&hd->my_channel->disk_done);
c0005d41:	8b 45 08             	mov    0x8(%ebp),%eax
c0005d44:	8b 40 08             	mov    0x8(%eax),%eax
c0005d47:	83 c0 2c             	add    $0x2c,%eax
c0005d4a:	83 ec 0c             	sub    $0xc,%esp
c0005d4d:	50                   	push   %eax
c0005d4e:	e8 42 e8 ff ff       	call   c0004595 <sema_down>
c0005d53:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:258

	/* 醒来后开始执行下面代码*/
	if (!busy_wait(hd)) {     //  若失败
c0005d56:	83 ec 0c             	sub    $0xc,%esp
c0005d59:	ff 75 08             	pushl  0x8(%ebp)
c0005d5c:	e8 06 fc ff ff       	call   c0005967 <busy_wait>
c0005d61:	83 c4 10             	add    $0x10,%esp
c0005d64:	85 c0                	test   %eax,%eax
c0005d66:	75 39                	jne    c0005da1 <identify_disk+0x88>
/work/x86_os_my/device/ide.c:260
		char error[64];
		sprintf(error, "%s identify failed!!!!!!\n", hd->name);
c0005d68:	8b 45 08             	mov    0x8(%ebp),%eax
c0005d6b:	83 ec 04             	sub    $0x4,%esp
c0005d6e:	50                   	push   %eax
c0005d6f:	68 c5 bf 00 c0       	push   $0xc000bfc5
c0005d74:	8d 85 70 fd ff ff    	lea    -0x290(%ebp),%eax
c0005d7a:	50                   	push   %eax
c0005d7b:	e8 a7 f8 ff ff       	call   c0005627 <sprintf>
c0005d80:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:261
		PANIC(error);
c0005d83:	8d 85 70 fd ff ff    	lea    -0x290(%ebp),%eax
c0005d89:	50                   	push   %eax
c0005d8a:	68 1c c1 00 c0       	push   $0xc000c11c
c0005d8f:	68 05 01 00 00       	push   $0x105
c0005d94:	68 6b bf 00 c0       	push   $0xc000bf6b
c0005d99:	e8 44 c5 ff ff       	call   c00022e2 <panic_spin>
c0005d9e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:263
	}
	read_from_sector(hd, id_info, 1);
c0005da1:	83 ec 04             	sub    $0x4,%esp
c0005da4:	6a 01                	push   $0x1
c0005da6:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c0005dac:	50                   	push   %eax
c0005dad:	ff 75 08             	pushl  0x8(%ebp)
c0005db0:	e8 20 fb ff ff       	call   c00058d5 <read_from_sector>
c0005db5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:266

	char buf[64];
	uint8_t sn_start = 10 * 2, sn_len = 20, md_start = 27 * 2, md_len = 40;
c0005db8:	c6 45 f7 14          	movb   $0x14,-0x9(%ebp)
c0005dbc:	c6 45 f6 14          	movb   $0x14,-0xa(%ebp)
c0005dc0:	c6 45 f5 36          	movb   $0x36,-0xb(%ebp)
c0005dc4:	c6 45 f4 28          	movb   $0x28,-0xc(%ebp)
/work/x86_os_my/device/ide.c:267
	swap_pairs_bytes(&id_info[sn_start], buf, sn_len);
c0005dc8:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0005dcc:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0005dd0:	8d 8d f0 fd ff ff    	lea    -0x210(%ebp),%ecx
c0005dd6:	01 ca                	add    %ecx,%edx
c0005dd8:	83 ec 04             	sub    $0x4,%esp
c0005ddb:	50                   	push   %eax
c0005ddc:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c0005de2:	50                   	push   %eax
c0005de3:	52                   	push   %edx
c0005de4:	e8 d5 fe ff ff       	call   c0005cbe <swap_pairs_bytes>
c0005de9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:268
	printk("   disk %s info:\n      SN: %s\n", hd->name, buf);
c0005dec:	8b 45 08             	mov    0x8(%ebp),%eax
c0005def:	83 ec 04             	sub    $0x4,%esp
c0005df2:	8d 95 b0 fd ff ff    	lea    -0x250(%ebp),%edx
c0005df8:	52                   	push   %edx
c0005df9:	50                   	push   %eax
c0005dfa:	68 e0 bf 00 c0       	push   $0xc000bfe0
c0005dff:	e8 4b 06 00 00       	call   c000644f <printk>
c0005e04:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:269
	memset(buf, 0, sizeof(buf));
c0005e07:	83 ec 04             	sub    $0x4,%esp
c0005e0a:	6a 40                	push   $0x40
c0005e0c:	6a 00                	push   $0x0
c0005e0e:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c0005e14:	50                   	push   %eax
c0005e15:	e8 6a d9 ff ff       	call   c0003784 <memset>
c0005e1a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:270
	swap_pairs_bytes(&id_info[md_start], buf, md_len);
c0005e1d:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0005e21:	0f b6 55 f5          	movzbl -0xb(%ebp),%edx
c0005e25:	8d 8d f0 fd ff ff    	lea    -0x210(%ebp),%ecx
c0005e2b:	01 ca                	add    %ecx,%edx
c0005e2d:	83 ec 04             	sub    $0x4,%esp
c0005e30:	50                   	push   %eax
c0005e31:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c0005e37:	50                   	push   %eax
c0005e38:	52                   	push   %edx
c0005e39:	e8 80 fe ff ff       	call   c0005cbe <swap_pairs_bytes>
c0005e3e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:271
	printk("      MODULE: %s\n", buf);
c0005e41:	83 ec 08             	sub    $0x8,%esp
c0005e44:	8d 85 b0 fd ff ff    	lea    -0x250(%ebp),%eax
c0005e4a:	50                   	push   %eax
c0005e4b:	68 ff bf 00 c0       	push   $0xc000bfff
c0005e50:	e8 fa 05 00 00       	call   c000644f <printk>
c0005e55:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:272
	uint32_t sectors = *(uint32_t*)&id_info[60 * 2];
c0005e58:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
c0005e5e:	83 c0 78             	add    $0x78,%eax
c0005e61:	8b 00                	mov    (%eax),%eax
c0005e63:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:273
	printk("      SECTORS: %d\n", sectors);
c0005e66:	83 ec 08             	sub    $0x8,%esp
c0005e69:	ff 75 f0             	pushl  -0x10(%ebp)
c0005e6c:	68 11 c0 00 c0       	push   $0xc000c011
c0005e71:	e8 d9 05 00 00       	call   c000644f <printk>
c0005e76:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:274
	printk("      CAPACITY: %dMB\n", sectors * 512 / 1024 / 1024);
c0005e79:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005e7c:	c1 e0 09             	shl    $0x9,%eax
c0005e7f:	c1 e8 14             	shr    $0x14,%eax
c0005e82:	83 ec 08             	sub    $0x8,%esp
c0005e85:	50                   	push   %eax
c0005e86:	68 24 c0 00 c0       	push   $0xc000c024
c0005e8b:	e8 bf 05 00 00       	call   c000644f <printk>
c0005e90:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:275
}
c0005e93:	90                   	nop
c0005e94:	c9                   	leave  
c0005e95:	c3                   	ret    

c0005e96 <partition_scan>:
partition_scan():
/work/x86_os_my/device/ide.c:278

/* 扫描硬盘hd中地址为ext_lba的扇区中的所有分区 */
static void partition_scan(struct disk* hd, uint32_t ext_lba) {
c0005e96:	55                   	push   %ebp
c0005e97:	89 e5                	mov    %esp,%ebp
c0005e99:	53                   	push   %ebx
c0005e9a:	83 ec 14             	sub    $0x14,%esp
/work/x86_os_my/device/ide.c:279
	struct boot_sector* bs = sys_malloc(sizeof(struct boot_sector));
c0005e9d:	83 ec 0c             	sub    $0xc,%esp
c0005ea0:	68 00 02 00 00       	push   $0x200
c0005ea5:	e8 e3 cd ff ff       	call   c0002c8d <sys_malloc>
c0005eaa:	83 c4 10             	add    $0x10,%esp
c0005ead:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/device/ide.c:280
	ide_read(hd, ext_lba, bs, 1);
c0005eb0:	6a 01                	push   $0x1
c0005eb2:	ff 75 ec             	pushl  -0x14(%ebp)
c0005eb5:	ff 75 0c             	pushl  0xc(%ebp)
c0005eb8:	ff 75 08             	pushl  0x8(%ebp)
c0005ebb:	e8 16 fb ff ff       	call   c00059d6 <ide_read>
c0005ec0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:281
	uint8_t part_idx = 0;
c0005ec3:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/device/ide.c:282
	struct partition_table_entry* p = bs->partition_table;
c0005ec7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0005eca:	05 be 01 00 00       	add    $0x1be,%eax
c0005ecf:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:285

	/* 遍历分区表4个分区表项 */
	while (part_idx++ < 4) {
c0005ed2:	e9 53 02 00 00       	jmp    c000612a <partition_scan+0x294>
/work/x86_os_my/device/ide.c:286
		if (p->fs_type == 0x5) {	// 若为扩展分区
c0005ed7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005eda:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0005ede:	3c 05                	cmp    $0x5,%al
c0005ee0:	75 50                	jne    c0005f32 <partition_scan+0x9c>
/work/x86_os_my/device/ide.c:287
			if (ext_lba_base != 0) {
c0005ee2:	a1 0c f6 00 c0       	mov    0xc000f60c,%eax
c0005ee7:	85 c0                	test   %eax,%eax
c0005ee9:	74 22                	je     c0005f0d <partition_scan+0x77>
/work/x86_os_my/device/ide.c:289
				/* 子扩展分区的start_lba是相对于主引导扇区中的总扩展分区地址 */
				partition_scan(hd, p->start_lba + ext_lba_base);
c0005eeb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005eee:	8b 40 08             	mov    0x8(%eax),%eax
c0005ef1:	8b 15 0c f6 00 c0    	mov    0xc000f60c,%edx
c0005ef7:	01 d0                	add    %edx,%eax
c0005ef9:	83 ec 08             	sub    $0x8,%esp
c0005efc:	50                   	push   %eax
c0005efd:	ff 75 08             	pushl  0x8(%ebp)
c0005f00:	e8 91 ff ff ff       	call   c0005e96 <partition_scan>
c0005f05:	83 c4 10             	add    $0x10,%esp
c0005f08:	e9 19 02 00 00       	jmp    c0006126 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:292
			} else {	// ext_lba_base为0表示是第一次读取引导块,也就是主引导记录所在的扇区
				/* 记录下扩展分区的起始lba地址,后面所有的扩展分区地址都相对于此 */
				ext_lba_base = p->start_lba;
c0005f0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005f10:	8b 40 08             	mov    0x8(%eax),%eax
c0005f13:	a3 0c f6 00 c0       	mov    %eax,0xc000f60c
/work/x86_os_my/device/ide.c:293
				partition_scan(hd, p->start_lba);
c0005f18:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005f1b:	8b 40 08             	mov    0x8(%eax),%eax
c0005f1e:	83 ec 08             	sub    $0x8,%esp
c0005f21:	50                   	push   %eax
c0005f22:	ff 75 08             	pushl  0x8(%ebp)
c0005f25:	e8 6c ff ff ff       	call   c0005e96 <partition_scan>
c0005f2a:	83 c4 10             	add    $0x10,%esp
c0005f2d:	e9 f4 01 00 00       	jmp    c0006126 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:295
			}
		} else if (p->fs_type != 0) {	// 若是有效的分区类型
c0005f32:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005f35:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0005f39:	84 c0                	test   %al,%al
c0005f3b:	0f 84 e5 01 00 00    	je     c0006126 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:296
			if (ext_lba == 0) {	// 此时全是主分区
c0005f41:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0005f45:	0f 85 f9 00 00 00    	jne    c0006044 <partition_scan+0x1ae>
/work/x86_os_my/device/ide.c:297
				hd->prim_parts[p_no].start_lba = ext_lba + p->start_lba;
c0005f4b:	0f b6 05 10 f6 00 c0 	movzbl 0xc000f610,%eax
c0005f52:	0f b6 c8             	movzbl %al,%ecx
c0005f55:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005f58:	8b 50 08             	mov    0x8(%eax),%edx
c0005f5b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0005f5e:	01 c2                	add    %eax,%edx
c0005f60:	8b 45 08             	mov    0x8(%ebp),%eax
c0005f63:	c1 e1 06             	shl    $0x6,%ecx
c0005f66:	01 c8                	add    %ecx,%eax
c0005f68:	83 c0 10             	add    $0x10,%eax
c0005f6b:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ide.c:298
				hd->prim_parts[p_no].sec_cnt = p->sec_cnt;
c0005f6d:	0f b6 05 10 f6 00 c0 	movzbl 0xc000f610,%eax
c0005f74:	0f b6 c8             	movzbl %al,%ecx
c0005f77:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0005f7a:	8b 40 0c             	mov    0xc(%eax),%eax
c0005f7d:	8b 55 08             	mov    0x8(%ebp),%edx
c0005f80:	c1 e1 06             	shl    $0x6,%ecx
c0005f83:	01 ca                	add    %ecx,%edx
c0005f85:	83 c2 14             	add    $0x14,%edx
c0005f88:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:299
				hd->prim_parts[p_no].my_disk = hd;
c0005f8a:	0f b6 05 10 f6 00 c0 	movzbl 0xc000f610,%eax
c0005f91:	0f b6 d0             	movzbl %al,%edx
c0005f94:	8b 45 08             	mov    0x8(%ebp),%eax
c0005f97:	c1 e2 06             	shl    $0x6,%edx
c0005f9a:	01 d0                	add    %edx,%eax
c0005f9c:	8d 50 18             	lea    0x18(%eax),%edx
c0005f9f:	8b 45 08             	mov    0x8(%ebp),%eax
c0005fa2:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:300
				list_append(&partition_list, &hd->prim_parts[p_no].part_tag);
c0005fa4:	0f b6 05 10 f6 00 c0 	movzbl 0xc000f610,%eax
c0005fab:	0f b6 c0             	movzbl %al,%eax
c0005fae:	c1 e0 06             	shl    $0x6,%eax
c0005fb1:	8d 50 10             	lea    0x10(%eax),%edx
c0005fb4:	8b 45 08             	mov    0x8(%ebp),%eax
c0005fb7:	01 d0                	add    %edx,%eax
c0005fb9:	83 c0 0c             	add    $0xc,%eax
c0005fbc:	83 ec 08             	sub    $0x8,%esp
c0005fbf:	50                   	push   %eax
c0005fc0:	68 c0 09 01 c0       	push   $0xc00109c0
c0005fc5:	e8 44 e3 ff ff       	call   c000430e <list_append>
c0005fca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:301
				sprintf(hd->prim_parts[p_no].name, "%s%d", hd->name, p_no + 1);
c0005fcd:	0f b6 05 10 f6 00 c0 	movzbl 0xc000f610,%eax
c0005fd4:	0f b6 c0             	movzbl %al,%eax
c0005fd7:	8d 48 01             	lea    0x1(%eax),%ecx
c0005fda:	8b 45 08             	mov    0x8(%ebp),%eax
c0005fdd:	0f b6 15 10 f6 00 c0 	movzbl 0xc000f610,%edx
c0005fe4:	0f b6 d2             	movzbl %dl,%edx
c0005fe7:	c1 e2 06             	shl    $0x6,%edx
c0005fea:	8d 5a 20             	lea    0x20(%edx),%ebx
c0005fed:	8b 55 08             	mov    0x8(%ebp),%edx
c0005ff0:	01 da                	add    %ebx,%edx
c0005ff2:	83 c2 04             	add    $0x4,%edx
c0005ff5:	51                   	push   %ecx
c0005ff6:	50                   	push   %eax
c0005ff7:	68 3a c0 00 c0       	push   $0xc000c03a
c0005ffc:	52                   	push   %edx
c0005ffd:	e8 25 f6 ff ff       	call   c0005627 <sprintf>
c0006002:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:302
				p_no++;
c0006005:	0f b6 05 10 f6 00 c0 	movzbl 0xc000f610,%eax
c000600c:	83 c0 01             	add    $0x1,%eax
c000600f:	a2 10 f6 00 c0       	mov    %al,0xc000f610
/work/x86_os_my/device/ide.c:303
				ASSERT(p_no < 4);	// 0,1,2,3
c0006014:	0f b6 05 10 f6 00 c0 	movzbl 0xc000f610,%eax
c000601b:	3c 03                	cmp    $0x3,%al
c000601d:	0f 86 03 01 00 00    	jbe    c0006126 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:303 (discriminator 1)
c0006023:	68 3f c0 00 c0       	push   $0xc000c03f
c0006028:	68 2c c1 00 c0       	push   $0xc000c12c
c000602d:	68 2f 01 00 00       	push   $0x12f
c0006032:	68 6b bf 00 c0       	push   $0xc000bf6b
c0006037:	e8 a6 c2 ff ff       	call   c00022e2 <panic_spin>
c000603c:	83 c4 10             	add    $0x10,%esp
c000603f:	e9 e2 00 00 00       	jmp    c0006126 <partition_scan+0x290>
/work/x86_os_my/device/ide.c:305
			} else {
				hd->logic_parts[l_no].start_lba = ext_lba + p->start_lba;
c0006044:	0f b6 05 11 f6 00 c0 	movzbl 0xc000f611,%eax
c000604b:	0f b6 c8             	movzbl %al,%ecx
c000604e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006051:	8b 50 08             	mov    0x8(%eax),%edx
c0006054:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006057:	01 c2                	add    %eax,%edx
c0006059:	8b 45 08             	mov    0x8(%ebp),%eax
c000605c:	c1 e1 06             	shl    $0x6,%ecx
c000605f:	01 c8                	add    %ecx,%eax
c0006061:	05 10 01 00 00       	add    $0x110,%eax
c0006066:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/device/ide.c:306
				hd->logic_parts[l_no].sec_cnt = p->sec_cnt;
c0006068:	0f b6 05 11 f6 00 c0 	movzbl 0xc000f611,%eax
c000606f:	0f b6 c8             	movzbl %al,%ecx
c0006072:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006075:	8b 40 0c             	mov    0xc(%eax),%eax
c0006078:	8b 55 08             	mov    0x8(%ebp),%edx
c000607b:	c1 e1 06             	shl    $0x6,%ecx
c000607e:	01 ca                	add    %ecx,%edx
c0006080:	81 c2 14 01 00 00    	add    $0x114,%edx
c0006086:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:307
				hd->logic_parts[l_no].my_disk = hd;
c0006088:	0f b6 05 11 f6 00 c0 	movzbl 0xc000f611,%eax
c000608f:	0f b6 d0             	movzbl %al,%edx
c0006092:	8b 45 08             	mov    0x8(%ebp),%eax
c0006095:	c1 e2 06             	shl    $0x6,%edx
c0006098:	01 d0                	add    %edx,%eax
c000609a:	8d 90 18 01 00 00    	lea    0x118(%eax),%edx
c00060a0:	8b 45 08             	mov    0x8(%ebp),%eax
c00060a3:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/device/ide.c:308
				list_append(&partition_list, &hd->logic_parts[l_no].part_tag);
c00060a5:	0f b6 05 11 f6 00 c0 	movzbl 0xc000f611,%eax
c00060ac:	0f b6 c0             	movzbl %al,%eax
c00060af:	c1 e0 06             	shl    $0x6,%eax
c00060b2:	8d 90 10 01 00 00    	lea    0x110(%eax),%edx
c00060b8:	8b 45 08             	mov    0x8(%ebp),%eax
c00060bb:	01 d0                	add    %edx,%eax
c00060bd:	83 c0 0c             	add    $0xc,%eax
c00060c0:	83 ec 08             	sub    $0x8,%esp
c00060c3:	50                   	push   %eax
c00060c4:	68 c0 09 01 c0       	push   $0xc00109c0
c00060c9:	e8 40 e2 ff ff       	call   c000430e <list_append>
c00060ce:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:309
				sprintf(hd->logic_parts[l_no].name, "%s%d", hd->name, l_no + 5);	// 逻辑分区数字是从5开始,主分区是1～4.
c00060d1:	0f b6 05 11 f6 00 c0 	movzbl 0xc000f611,%eax
c00060d8:	0f b6 c0             	movzbl %al,%eax
c00060db:	8d 48 05             	lea    0x5(%eax),%ecx
c00060de:	8b 45 08             	mov    0x8(%ebp),%eax
c00060e1:	0f b6 15 11 f6 00 c0 	movzbl 0xc000f611,%edx
c00060e8:	0f b6 d2             	movzbl %dl,%edx
c00060eb:	c1 e2 06             	shl    $0x6,%edx
c00060ee:	8d 9a 20 01 00 00    	lea    0x120(%edx),%ebx
c00060f4:	8b 55 08             	mov    0x8(%ebp),%edx
c00060f7:	01 da                	add    %ebx,%edx
c00060f9:	83 c2 04             	add    $0x4,%edx
c00060fc:	51                   	push   %ecx
c00060fd:	50                   	push   %eax
c00060fe:	68 3a c0 00 c0       	push   $0xc000c03a
c0006103:	52                   	push   %edx
c0006104:	e8 1e f5 ff ff       	call   c0005627 <sprintf>
c0006109:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:310
				l_no++;
c000610c:	0f b6 05 11 f6 00 c0 	movzbl 0xc000f611,%eax
c0006113:	83 c0 01             	add    $0x1,%eax
c0006116:	a2 11 f6 00 c0       	mov    %al,0xc000f611
/work/x86_os_my/device/ide.c:311
				if (l_no >= 8)	// 只支持8个逻辑分区,避免数组越界
c000611b:	0f b6 05 11 f6 00 c0 	movzbl 0xc000f611,%eax
c0006122:	3c 07                	cmp    $0x7,%al
c0006124:	77 26                	ja     c000614c <partition_scan+0x2b6>
/work/x86_os_my/device/ide.c:315
					return;
			}
		}
		p++;
c0006126:	83 45 f0 10          	addl   $0x10,-0x10(%ebp)
/work/x86_os_my/device/ide.c:285
	ide_read(hd, ext_lba, bs, 1);
	uint8_t part_idx = 0;
	struct partition_table_entry* p = bs->partition_table;

	/* 遍历分区表4个分区表项 */
	while (part_idx++ < 4) {
c000612a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000612e:	8d 50 01             	lea    0x1(%eax),%edx
c0006131:	88 55 f7             	mov    %dl,-0x9(%ebp)
c0006134:	3c 03                	cmp    $0x3,%al
c0006136:	0f 86 9b fd ff ff    	jbe    c0005ed7 <partition_scan+0x41>
/work/x86_os_my/device/ide.c:317
					return;
			}
		}
		p++;
	}
	sys_free(bs);
c000613c:	83 ec 0c             	sub    $0xc,%esp
c000613f:	ff 75 ec             	pushl  -0x14(%ebp)
c0006142:	e8 73 d1 ff ff       	call   c00032ba <sys_free>
c0006147:	83 c4 10             	add    $0x10,%esp
c000614a:	eb 01                	jmp    c000614d <partition_scan+0x2b7>
/work/x86_os_my/device/ide.c:312
				hd->logic_parts[l_no].my_disk = hd;
				list_append(&partition_list, &hd->logic_parts[l_no].part_tag);
				sprintf(hd->logic_parts[l_no].name, "%s%d", hd->name, l_no + 5);	// 逻辑分区数字是从5开始,主分区是1～4.
				l_no++;
				if (l_no >= 8)	// 只支持8个逻辑分区,避免数组越界
					return;
c000614c:	90                   	nop
/work/x86_os_my/device/ide.c:318
			}
		}
		p++;
	}
	sys_free(bs);
}
c000614d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0006150:	c9                   	leave  
c0006151:	c3                   	ret    

c0006152 <partition_info>:
partition_info():
/work/x86_os_my/device/ide.c:321

/* 打印分区信息 */
static bool partition_info(struct list_elem* pelem, int arg UNUSED) {
c0006152:	55                   	push   %ebp
c0006153:	89 e5                	mov    %esp,%ebp
c0006155:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ide.c:322
	struct partition* part = elem2entry(struct partition, part_tag, pelem);
c0006158:	8b 45 08             	mov    0x8(%ebp),%eax
c000615b:	83 e8 0c             	sub    $0xc,%eax
c000615e:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/device/ide.c:323
	printk("   %s start_lba:0x%x, sec_cnt:0x%x\n",part->name, part->start_lba, part->sec_cnt);
c0006161:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0006164:	8b 50 04             	mov    0x4(%eax),%edx
c0006167:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000616a:	8b 00                	mov    (%eax),%eax
c000616c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c000616f:	83 c1 14             	add    $0x14,%ecx
c0006172:	52                   	push   %edx
c0006173:	50                   	push   %eax
c0006174:	51                   	push   %ecx
c0006175:	68 48 c0 00 c0       	push   $0xc000c048
c000617a:	e8 d0 02 00 00       	call   c000644f <printk>
c000617f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:327

	/* 在此处return false与函数本身功能无关,
	 * 只是为了让主调函数list_traversal继续向下遍历元素 */
	return false;
c0006182:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/device/ide.c:328
}
c0006187:	c9                   	leave  
c0006188:	c3                   	ret    

c0006189 <intr_hd_handler>:
intr_hd_handler():
/work/x86_os_my/device/ide.c:331

/* 硬盘中断处理程序 */
void intr_hd_handler(uint8_t irq_no) {
c0006189:	55                   	push   %ebp
c000618a:	89 e5                	mov    %esp,%ebp
c000618c:	83 ec 28             	sub    $0x28,%esp
c000618f:	8b 45 08             	mov    0x8(%ebp),%eax
c0006192:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/device/ide.c:332
	ASSERT(irq_no == 0x2e || irq_no == 0x2f);
c0006195:	80 7d e4 2e          	cmpb   $0x2e,-0x1c(%ebp)
c0006199:	74 22                	je     c00061bd <intr_hd_handler+0x34>
/work/x86_os_my/device/ide.c:332 (discriminator 1)
c000619b:	80 7d e4 2f          	cmpb   $0x2f,-0x1c(%ebp)
c000619f:	74 1c                	je     c00061bd <intr_hd_handler+0x34>
/work/x86_os_my/device/ide.c:332 (discriminator 2)
c00061a1:	68 6c c0 00 c0       	push   $0xc000c06c
c00061a6:	68 3c c1 00 c0       	push   $0xc000c13c
c00061ab:	68 4c 01 00 00       	push   $0x14c
c00061b0:	68 6b bf 00 c0       	push   $0xc000bf6b
c00061b5:	e8 28 c1 ff ff       	call   c00022e2 <panic_spin>
c00061ba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:333
	uint8_t ch_no = irq_no - 0x2e;
c00061bd:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c00061c1:	83 e8 2e             	sub    $0x2e,%eax
c00061c4:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ide.c:334
	struct ide_channel* channel = &channels[ch_no];
c00061c7:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00061cb:	69 c0 60 06 00 00    	imul   $0x660,%eax,%eax
c00061d1:	05 00 fd 00 c0       	add    $0xc000fd00,%eax
c00061d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:335
	ASSERT(channel->irq_no == irq_no);
c00061d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00061dc:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c00061e0:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c00061e3:	74 1c                	je     c0006201 <intr_hd_handler+0x78>
/work/x86_os_my/device/ide.c:335 (discriminator 1)
c00061e5:	68 8d c0 00 c0       	push   $0xc000c08d
c00061ea:	68 3c c1 00 c0       	push   $0xc000c13c
c00061ef:	68 4f 01 00 00       	push   $0x14f
c00061f4:	68 6b bf 00 c0       	push   $0xc000bf6b
c00061f9:	e8 e4 c0 ff ff       	call   c00022e2 <panic_spin>
c00061fe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:338
	/* 不必担心此中断是否对应的是这一次的expecting_intr,
	* 每次读写硬盘时会申请锁,从而保证了同步一致性 */
	if (channel->expecting_intr) {
c0006201:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006204:	8b 40 28             	mov    0x28(%eax),%eax
c0006207:	85 c0                	test   %eax,%eax
c0006209:	74 35                	je     c0006240 <intr_hd_handler+0xb7>
/work/x86_os_my/device/ide.c:339
		channel->expecting_intr = false;
c000620b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000620e:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
/work/x86_os_my/device/ide.c:340
		sema_up(&channel->disk_done);
c0006215:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006218:	83 c0 2c             	add    $0x2c,%eax
c000621b:	83 ec 0c             	sub    $0xc,%esp
c000621e:	50                   	push   %eax
c000621f:	e8 6c e4 ff ff       	call   c0004690 <sema_up>
c0006224:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:343

		/* 读取状态寄存器使硬盘控制器认为此次的中断已被处理,从而硬盘可以继续执行新的读写 */
		inb(reg_status(channel));
c0006227:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000622a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c000622e:	83 c0 07             	add    $0x7,%eax
c0006231:	0f b7 c0             	movzwl %ax,%eax
c0006234:	83 ec 0c             	sub    $0xc,%esp
c0006237:	50                   	push   %eax
c0006238:	e8 de f4 ff ff       	call   c000571b <inb>
c000623d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:345
	}
}
c0006240:	90                   	nop
c0006241:	c9                   	leave  
c0006242:	c3                   	ret    

c0006243 <ide_init>:
ide_init():
/work/x86_os_my/device/ide.c:348

/* 硬盘数据结构初始化 */
void ide_init() {
c0006243:	55                   	push   %ebp
c0006244:	89 e5                	mov    %esp,%ebp
c0006246:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/device/ide.c:349
	printk("ide_init start\n");
c0006249:	83 ec 0c             	sub    $0xc,%esp
c000624c:	68 a7 c0 00 c0       	push   $0xc000c0a7
c0006251:	e8 f9 01 00 00       	call   c000644f <printk>
c0006256:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:350
	uint8_t hd_cnt = *((uint8_t*)(0x475));	// 获取硬盘的数量
c0006259:	b8 75 04 00 00       	mov    $0x475,%eax
c000625e:	0f b6 00             	movzbl (%eax),%eax
c0006261:	88 45 f5             	mov    %al,-0xb(%ebp)
/work/x86_os_my/device/ide.c:351
	ASSERT(hd_cnt > 0);
c0006264:	80 7d f5 00          	cmpb   $0x0,-0xb(%ebp)
c0006268:	75 1c                	jne    c0006286 <ide_init+0x43>
/work/x86_os_my/device/ide.c:351 (discriminator 1)
c000626a:	68 b7 c0 00 c0       	push   $0xc000c0b7
c000626f:	68 4c c1 00 c0       	push   $0xc000c14c
c0006274:	68 5f 01 00 00       	push   $0x15f
c0006279:	68 6b bf 00 c0       	push   $0xc000bf6b
c000627e:	e8 5f c0 ff ff       	call   c00022e2 <panic_spin>
c0006283:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:352
	list_init(&partition_list);
c0006286:	83 ec 0c             	sub    $0xc,%esp
c0006289:	68 c0 09 01 c0       	push   $0xc00109c0
c000628e:	e8 ea df ff ff       	call   c000427d <list_init>
c0006293:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:353
	channel_cnt = DIV_ROUND_UP(hd_cnt, 2);	// 一个ide通道上有两个硬盘,根据硬盘数量反推有几个ide通道
c0006296:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
c000629a:	83 c0 01             	add    $0x1,%eax
c000629d:	89 c2                	mov    %eax,%edx
c000629f:	c1 ea 1f             	shr    $0x1f,%edx
c00062a2:	01 d0                	add    %edx,%eax
c00062a4:	d1 f8                	sar    %eax
c00062a6:	a2 e0 fc 00 c0       	mov    %al,0xc000fce0
/work/x86_os_my/device/ide.c:355
	struct ide_channel* channel;
	uint8_t channel_no = 0, dev_no = 0;
c00062ab:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
c00062af:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
/work/x86_os_my/device/ide.c:358

	/* 处理每个通道上的硬盘 */
	while (channel_no < channel_cnt) {
c00062b3:	e9 4d 01 00 00       	jmp    c0006405 <ide_init+0x1c2>
/work/x86_os_my/device/ide.c:359
		channel = &channels[channel_no];
c00062b8:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00062bc:	69 c0 60 06 00 00    	imul   $0x660,%eax,%eax
c00062c2:	05 00 fd 00 c0       	add    $0xc000fd00,%eax
c00062c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/device/ide.c:360
		sprintf(channel->name, "ide%d", channel_no);
c00062ca:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c00062ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00062d1:	83 ec 04             	sub    $0x4,%esp
c00062d4:	52                   	push   %edx
c00062d5:	68 c2 c0 00 c0       	push   $0xc000c0c2
c00062da:	50                   	push   %eax
c00062db:	e8 47 f3 ff ff       	call   c0005627 <sprintf>
c00062e0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:363

		/* 为每个ide通道初始化端口基址及中断向量 */
		switch (channel_no) {
c00062e3:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00062e7:	85 c0                	test   %eax,%eax
c00062e9:	74 07                	je     c00062f2 <ide_init+0xaf>
c00062eb:	83 f8 01             	cmp    $0x1,%eax
c00062ee:	74 14                	je     c0006304 <ide_init+0xc1>
c00062f0:	eb 23                	jmp    c0006315 <ide_init+0xd2>
/work/x86_os_my/device/ide.c:365
			case 0:
			channel->port_base	 = 0x1f0;	// ide0通道的起始端口号是0x1f0
c00062f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00062f5:	66 c7 40 08 f0 01    	movw   $0x1f0,0x8(%eax)
/work/x86_os_my/device/ide.c:366
			channel->irq_no	 = 0x20 + 14;	// 从片8259a上倒数第二的中断引脚,温盘,也就是ide0通道的的中断向量号
c00062fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00062fe:	c6 40 0a 2e          	movb   $0x2e,0xa(%eax)
/work/x86_os_my/device/ide.c:367
			break;
c0006302:	eb 11                	jmp    c0006315 <ide_init+0xd2>
/work/x86_os_my/device/ide.c:370
			
			case 1:
			channel->port_base	 = 0x170;	// ide1通道的起始端口号是0x170
c0006304:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006307:	66 c7 40 08 70 01    	movw   $0x170,0x8(%eax)
/work/x86_os_my/device/ide.c:371
			channel->irq_no	 = 0x20 + 15;	// 从8259A上的最后一个中断引脚,我们用来响应ide1通道上的硬盘中断
c000630d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006310:	c6 40 0a 2f          	movb   $0x2f,0xa(%eax)
/work/x86_os_my/device/ide.c:372
			break;
c0006314:	90                   	nop
/work/x86_os_my/device/ide.c:375
		}

		channel->expecting_intr = false;	// 未向硬盘写入指令时不期待硬盘的中断
c0006315:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006318:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
/work/x86_os_my/device/ide.c:376
		lock_init(&channel->lock);
c000631f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006322:	83 c0 0c             	add    $0xc,%eax
c0006325:	83 ec 0c             	sub    $0xc,%esp
c0006328:	50                   	push   %eax
c0006329:	e8 37 e2 ff ff       	call   c0004565 <lock_init>
c000632e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:380

		/* 初始化为0,目的是向硬盘控制器请求数据后,硬盘驱动sema_down此信号量会阻塞线程,
		直到硬盘完成后通过发中断,由中断处理程序将此信号量sema_up,唤醒线程. */
		sema_init(&channel->disk_done, 0);
c0006331:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006334:	83 c0 2c             	add    $0x2c,%eax
c0006337:	83 ec 08             	sub    $0x8,%esp
c000633a:	6a 00                	push   $0x0
c000633c:	50                   	push   %eax
c000633d:	e8 f9 e1 ff ff       	call   c000453b <sema_init>
c0006342:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:381
		register_handler(channel->irq_no, intr_hd_handler);
c0006345:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006348:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c000634c:	0f b6 c0             	movzbl %al,%eax
c000634f:	83 ec 08             	sub    $0x8,%esp
c0006352:	68 89 61 00 c0       	push   $0xc0006189
c0006357:	50                   	push   %eax
c0006358:	e8 4c b6 ff ff       	call   c00019a9 <register_handler>
c000635d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:384

		/* 分别获取两个硬盘的参数及分区信息 */
		while (dev_no < 2) {
c0006360:	e9 88 00 00 00       	jmp    c00063ed <ide_init+0x1aa>
/work/x86_os_my/device/ide.c:385
			struct disk* hd = &channel->devices[dev_no];
c0006365:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c0006369:	69 c0 10 03 00 00    	imul   $0x310,%eax,%eax
c000636f:	8d 50 40             	lea    0x40(%eax),%edx
c0006372:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006375:	01 d0                	add    %edx,%eax
c0006377:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/device/ide.c:386
			hd->my_channel = channel;
c000637a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000637d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0006380:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/device/ide.c:387
			hd->dev_no = dev_no;
c0006383:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0006386:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
c000638a:	88 50 0c             	mov    %dl,0xc(%eax)
/work/x86_os_my/device/ide.c:388
			sprintf(hd->name, "sd%c", 'a' + channel_no * 2 + dev_no);
c000638d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0006391:	01 c0                	add    %eax,%eax
c0006393:	8d 50 61             	lea    0x61(%eax),%edx
c0006396:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c000639a:	01 c2                	add    %eax,%edx
c000639c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000639f:	83 ec 04             	sub    $0x4,%esp
c00063a2:	52                   	push   %edx
c00063a3:	68 c8 c0 00 c0       	push   $0xc000c0c8
c00063a8:	50                   	push   %eax
c00063a9:	e8 79 f2 ff ff       	call   c0005627 <sprintf>
c00063ae:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:389
			identify_disk(hd);		// 获取硬盘参数
c00063b1:	83 ec 0c             	sub    $0xc,%esp
c00063b4:	ff 75 ec             	pushl  -0x14(%ebp)
c00063b7:	e8 5d f9 ff ff       	call   c0005d19 <identify_disk>
c00063bc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:390
			if (dev_no != 0) {		// 内核本身的裸硬盘(hd60M.img)不处理
c00063bf:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c00063c3:	74 10                	je     c00063d5 <ide_init+0x192>
/work/x86_os_my/device/ide.c:391
				partition_scan(hd, 0);	// 扫描该硬盘上的分区
c00063c5:	83 ec 08             	sub    $0x8,%esp
c00063c8:	6a 00                	push   $0x0
c00063ca:	ff 75 ec             	pushl  -0x14(%ebp)
c00063cd:	e8 c4 fa ff ff       	call   c0005e96 <partition_scan>
c00063d2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:393
			}
			p_no = 0, l_no = 0;
c00063d5:	c6 05 10 f6 00 c0 00 	movb   $0x0,0xc000f610
c00063dc:	c6 05 11 f6 00 c0 00 	movb   $0x0,0xc000f611
/work/x86_os_my/device/ide.c:394
			dev_no++;
c00063e3:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c00063e7:	83 c0 01             	add    $0x1,%eax
c00063ea:	88 45 f6             	mov    %al,-0xa(%ebp)
/work/x86_os_my/device/ide.c:384
		直到硬盘完成后通过发中断,由中断处理程序将此信号量sema_up,唤醒线程. */
		sema_init(&channel->disk_done, 0);
		register_handler(channel->irq_no, intr_hd_handler);

		/* 分别获取两个硬盘的参数及分区信息 */
		while (dev_no < 2) {
c00063ed:	80 7d f6 01          	cmpb   $0x1,-0xa(%ebp)
c00063f1:	0f 86 6e ff ff ff    	jbe    c0006365 <ide_init+0x122>
/work/x86_os_my/device/ide.c:396
				partition_scan(hd, 0);	// 扫描该硬盘上的分区
			}
			p_no = 0, l_no = 0;
			dev_no++;
		}
		dev_no = 0;		// 将硬盘驱动器号置0,为下一个channel的两个硬盘初始化。
c00063f7:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
/work/x86_os_my/device/ide.c:397
		channel_no++;	// 下一个channel
c00063fb:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00063ff:	83 c0 01             	add    $0x1,%eax
c0006402:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/device/ide.c:358
	channel_cnt = DIV_ROUND_UP(hd_cnt, 2);	// 一个ide通道上有两个硬盘,根据硬盘数量反推有几个ide通道
	struct ide_channel* channel;
	uint8_t channel_no = 0, dev_no = 0;

	/* 处理每个通道上的硬盘 */
	while (channel_no < channel_cnt) {
c0006405:	0f b6 05 e0 fc 00 c0 	movzbl 0xc000fce0,%eax
c000640c:	38 45 f7             	cmp    %al,-0x9(%ebp)
c000640f:	0f 82 a3 fe ff ff    	jb     c00062b8 <ide_init+0x75>
/work/x86_os_my/device/ide.c:400
		}
		dev_no = 0;		// 将硬盘驱动器号置0,为下一个channel的两个硬盘初始化。
		channel_no++;	// 下一个channel
	}

	printk("\n   all partition info\n");
c0006415:	83 ec 0c             	sub    $0xc,%esp
c0006418:	68 cd c0 00 c0       	push   $0xc000c0cd
c000641d:	e8 2d 00 00 00       	call   c000644f <printk>
c0006422:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:402
	/* 打印所有分区信息 */
	list_traversal(&partition_list, partition_info, (int)NULL);
c0006425:	83 ec 04             	sub    $0x4,%esp
c0006428:	6a 00                	push   $0x0
c000642a:	68 52 61 00 c0       	push   $0xc0006152
c000642f:	68 c0 09 01 c0       	push   $0xc00109c0
c0006434:	e8 8a df ff ff       	call   c00043c3 <list_traversal>
c0006439:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:403
	printk("ide_init done\n");
c000643c:	83 ec 0c             	sub    $0xc,%esp
c000643f:	68 e5 c0 00 c0       	push   $0xc000c0e5
c0006444:	e8 06 00 00 00       	call   c000644f <printk>
c0006449:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/device/ide.c:404
}
c000644c:	90                   	nop
c000644d:	c9                   	leave  
c000644e:	c3                   	ret    

c000644f <printk>:
printk():
/work/x86_os_my/lib/kernel/stdio-kernel.c:11

#define va_start(args, first_fix) args = (va_list)&first_fix
#define va_end(args) args = NULL

/* 供内核使用的格式化输出函数 */
void printk(const char* format, ...) {
c000644f:	55                   	push   %ebp
c0006450:	89 e5                	mov    %esp,%ebp
c0006452:	57                   	push   %edi
c0006453:	81 ec 14 04 00 00    	sub    $0x414,%esp
/work/x86_os_my/lib/kernel/stdio-kernel.c:13
	va_list args;
	va_start(args, format);
c0006459:	8d 45 08             	lea    0x8(%ebp),%eax
c000645c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/lib/kernel/stdio-kernel.c:14
	char buf[1024] = {0};
c000645f:	8d 95 f4 fb ff ff    	lea    -0x40c(%ebp),%edx
c0006465:	b8 00 00 00 00       	mov    $0x0,%eax
c000646a:	b9 00 01 00 00       	mov    $0x100,%ecx
c000646f:	89 d7                	mov    %edx,%edi
c0006471:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/lib/kernel/stdio-kernel.c:15
	vsprintf(buf, format, args);
c0006473:	8b 45 08             	mov    0x8(%ebp),%eax
c0006476:	83 ec 04             	sub    $0x4,%esp
c0006479:	ff 75 f4             	pushl  -0xc(%ebp)
c000647c:	50                   	push   %eax
c000647d:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c0006483:	50                   	push   %eax
c0006484:	e8 21 f0 ff ff       	call   c00054aa <vsprintf>
c0006489:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/stdio-kernel.c:16
	va_end(args);
c000648c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/lib/kernel/stdio-kernel.c:17
	console_put_str(buf);
c0006493:	83 ec 0c             	sub    $0xc,%esp
c0006496:	8d 85 f4 fb ff ff    	lea    -0x40c(%ebp),%eax
c000649c:	50                   	push   %eax
c000649d:	e8 2e e0 ff ff       	call   c00044d0 <console_put_str>
c00064a2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/lib/kernel/stdio-kernel.c:18
}
c00064a5:	90                   	nop
c00064a6:	8b 7d fc             	mov    -0x4(%ebp),%edi
c00064a9:	c9                   	leave  
c00064aa:	c3                   	ret    

c00064ab <mount_partition>:
mount_partition():
/work/x86_os_my/fs/fs.c:25
把该分区文件系统的元信息从硬盘上读出来加载到内存中，
这样硬盘资源的变化都用内存中元信息来跟踪，
如果有写操作，及时将内存中的元信息同步写入到硬盘以持久化。
*/
//sb_buf没释放！
static bool mount_partition(struct list_elem* pelem, int arg) {
c00064ab:	55                   	push   %ebp
c00064ac:	89 e5                	mov    %esp,%ebp
c00064ae:	53                   	push   %ebx
c00064af:	83 ec 14             	sub    $0x14,%esp
/work/x86_os_my/fs/fs.c:26
	char* part_name = (char*)arg;	// sdb1
c00064b2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00064b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:27
	struct partition* part = elem2entry(struct partition, part_tag, pelem);	// 根据pelem找到partition
c00064b8:	8b 45 08             	mov    0x8(%ebp),%eax
c00064bb:	83 e8 0c             	sub    $0xc,%eax
c00064be:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:28
	if (!strcmp(part->name, part_name)) {	//名字一致
c00064c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00064c4:	83 c0 14             	add    $0x14,%eax
c00064c7:	83 ec 08             	sub    $0x8,%esp
c00064ca:	ff 75 f4             	pushl  -0xc(%ebp)
c00064cd:	50                   	push   %eax
c00064ce:	e8 86 d4 ff ff       	call   c0003959 <strcmp>
c00064d3:	83 c4 10             	add    $0x10,%esp
c00064d6:	84 c0                	test   %al,%al
c00064d8:	0f 85 ce 01 00 00    	jne    c00066ac <mount_partition+0x201>
/work/x86_os_my/fs/fs.c:29
		cur_part = part;
c00064de:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00064e1:	a3 d0 09 01 c0       	mov    %eax,0xc00109d0
/work/x86_os_my/fs/fs.c:30
		struct disk* hd = cur_part->my_disk;
c00064e6:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00064eb:	8b 40 08             	mov    0x8(%eax),%eax
c00064ee:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:31
		struct super_block* sb_buf = (struct super_block*)sys_malloc(SECTOR_SIZE);
c00064f1:	83 ec 0c             	sub    $0xc,%esp
c00064f4:	68 00 02 00 00       	push   $0x200
c00064f9:	e8 8f c7 ff ff       	call   c0002c8d <sys_malloc>
c00064fe:	83 c4 10             	add    $0x10,%esp
c0006501:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:35

		/* 在内存中创建分区cur_part的超级块 */
		// super_block 占用了1个扇区，但是它后边有很多数据是pad只做填充用
		cur_part->sb = (struct super_block*)sys_malloc(sizeof(struct super_block));
c0006504:	8b 1d d0 09 01 c0    	mov    0xc00109d0,%ebx
c000650a:	83 ec 0c             	sub    $0xc,%esp
c000650d:	68 00 02 00 00       	push   $0x200
c0006512:	e8 76 c7 ff ff       	call   c0002c8d <sys_malloc>
c0006517:	83 c4 10             	add    $0x10,%esp
c000651a:	89 43 1c             	mov    %eax,0x1c(%ebx)
/work/x86_os_my/fs/fs.c:36
		if (cur_part->sb == NULL) {
c000651d:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0006522:	8b 40 1c             	mov    0x1c(%eax),%eax
c0006525:	85 c0                	test   %eax,%eax
c0006527:	75 19                	jne    c0006542 <mount_partition+0x97>
/work/x86_os_my/fs/fs.c:37
			PANIC("alloc memory failed!");
c0006529:	68 58 c1 00 c0       	push   $0xc000c158
c000652e:	68 2c c9 00 c0       	push   $0xc000c92c
c0006533:	6a 25                	push   $0x25
c0006535:	68 6d c1 00 c0       	push   $0xc000c16d
c000653a:	e8 a3 bd ff ff       	call   c00022e2 <panic_spin>
c000653f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:41
		}

		/* 读入超级块 */
		memset(sb_buf, 0, SECTOR_SIZE);
c0006542:	83 ec 04             	sub    $0x4,%esp
c0006545:	68 00 02 00 00       	push   $0x200
c000654a:	6a 00                	push   $0x0
c000654c:	ff 75 e8             	pushl  -0x18(%ebp)
c000654f:	e8 30 d2 ff ff       	call   c0003784 <memset>
c0006554:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:42
		ide_read(hd, cur_part->start_lba + 1, sb_buf, 1);
c0006557:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000655c:	8b 00                	mov    (%eax),%eax
c000655e:	83 c0 01             	add    $0x1,%eax
c0006561:	6a 01                	push   $0x1
c0006563:	ff 75 e8             	pushl  -0x18(%ebp)
c0006566:	50                   	push   %eax
c0006567:	ff 75 ec             	pushl  -0x14(%ebp)
c000656a:	e8 67 f4 ff ff       	call   c00059d6 <ide_read>
c000656f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:44
		// 拷贝给 cur_part->sb
		memcpy(cur_part->sb, sb_buf, sizeof(struct super_block));
c0006572:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0006577:	8b 40 1c             	mov    0x1c(%eax),%eax
c000657a:	83 ec 04             	sub    $0x4,%esp
c000657d:	68 00 02 00 00       	push   $0x200
c0006582:	ff 75 e8             	pushl  -0x18(%ebp)
c0006585:	50                   	push   %eax
c0006586:	e8 4b d2 ff ff       	call   c00037d6 <memcpy>
c000658b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:47

		/* 读入块位图 */
		cur_part->block_bitmap.bits = (uint8_t*)sys_malloc(sb_buf->block_bitmap_sects * SECTOR_SIZE);
c000658e:	8b 1d d0 09 01 c0    	mov    0xc00109d0,%ebx
c0006594:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0006597:	8b 40 14             	mov    0x14(%eax),%eax
c000659a:	c1 e0 09             	shl    $0x9,%eax
c000659d:	83 ec 0c             	sub    $0xc,%esp
c00065a0:	50                   	push   %eax
c00065a1:	e8 e7 c6 ff ff       	call   c0002c8d <sys_malloc>
c00065a6:	83 c4 10             	add    $0x10,%esp
c00065a9:	89 43 24             	mov    %eax,0x24(%ebx)
/work/x86_os_my/fs/fs.c:48
		if (cur_part->block_bitmap.bits == NULL) {
c00065ac:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00065b1:	8b 40 24             	mov    0x24(%eax),%eax
c00065b4:	85 c0                	test   %eax,%eax
c00065b6:	75 19                	jne    c00065d1 <mount_partition+0x126>
/work/x86_os_my/fs/fs.c:49
			PANIC("alloc memory failed!");
c00065b8:	68 58 c1 00 c0       	push   $0xc000c158
c00065bd:	68 2c c9 00 c0       	push   $0xc000c92c
c00065c2:	6a 31                	push   $0x31
c00065c4:	68 6d c1 00 c0       	push   $0xc000c16d
c00065c9:	e8 14 bd ff ff       	call   c00022e2 <panic_spin>
c00065ce:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:51
		}
		cur_part->block_bitmap.btmp_bytes_len = sb_buf->block_bitmap_sects * SECTOR_SIZE;
c00065d1:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00065d6:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00065d9:	8b 52 14             	mov    0x14(%edx),%edx
c00065dc:	c1 e2 09             	shl    $0x9,%edx
c00065df:	89 50 20             	mov    %edx,0x20(%eax)
/work/x86_os_my/fs/fs.c:52
		ide_read(hd, sb_buf->block_bitmap_lba, cur_part->block_bitmap.bits, sb_buf->block_bitmap_sects);
c00065e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00065e5:	8b 48 14             	mov    0x14(%eax),%ecx
c00065e8:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00065ed:	8b 50 24             	mov    0x24(%eax),%edx
c00065f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00065f3:	8b 40 10             	mov    0x10(%eax),%eax
c00065f6:	51                   	push   %ecx
c00065f7:	52                   	push   %edx
c00065f8:	50                   	push   %eax
c00065f9:	ff 75 ec             	pushl  -0x14(%ebp)
c00065fc:	e8 d5 f3 ff ff       	call   c00059d6 <ide_read>
c0006601:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:55

		/* 读入inode位图 */
		cur_part->inode_bitmap.bits = (uint8_t*)sys_malloc(sb_buf->inode_bitmap_sects * SECTOR_SIZE);
c0006604:	8b 1d d0 09 01 c0    	mov    0xc00109d0,%ebx
c000660a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000660d:	8b 40 1c             	mov    0x1c(%eax),%eax
c0006610:	c1 e0 09             	shl    $0x9,%eax
c0006613:	83 ec 0c             	sub    $0xc,%esp
c0006616:	50                   	push   %eax
c0006617:	e8 71 c6 ff ff       	call   c0002c8d <sys_malloc>
c000661c:	83 c4 10             	add    $0x10,%esp
c000661f:	89 43 2c             	mov    %eax,0x2c(%ebx)
/work/x86_os_my/fs/fs.c:56
		if (cur_part->inode_bitmap.bits == NULL) {
c0006622:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0006627:	8b 40 2c             	mov    0x2c(%eax),%eax
c000662a:	85 c0                	test   %eax,%eax
c000662c:	75 19                	jne    c0006647 <mount_partition+0x19c>
/work/x86_os_my/fs/fs.c:57
			PANIC("alloc memory failed!");
c000662e:	68 58 c1 00 c0       	push   $0xc000c158
c0006633:	68 2c c9 00 c0       	push   $0xc000c92c
c0006638:	6a 39                	push   $0x39
c000663a:	68 6d c1 00 c0       	push   $0xc000c16d
c000663f:	e8 9e bc ff ff       	call   c00022e2 <panic_spin>
c0006644:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:59
		}
		cur_part->inode_bitmap.btmp_bytes_len = sb_buf->inode_bitmap_sects * SECTOR_SIZE;
c0006647:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000664c:	8b 55 e8             	mov    -0x18(%ebp),%edx
c000664f:	8b 52 1c             	mov    0x1c(%edx),%edx
c0006652:	c1 e2 09             	shl    $0x9,%edx
c0006655:	89 50 28             	mov    %edx,0x28(%eax)
/work/x86_os_my/fs/fs.c:60
		ide_read(hd, sb_buf->inode_bitmap_lba, cur_part->inode_bitmap.bits, sb_buf->inode_bitmap_sects);
c0006658:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000665b:	8b 48 1c             	mov    0x1c(%eax),%ecx
c000665e:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0006663:	8b 50 2c             	mov    0x2c(%eax),%edx
c0006666:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0006669:	8b 40 18             	mov    0x18(%eax),%eax
c000666c:	51                   	push   %ecx
c000666d:	52                   	push   %edx
c000666e:	50                   	push   %eax
c000666f:	ff 75 ec             	pushl  -0x14(%ebp)
c0006672:	e8 5f f3 ff ff       	call   c00059d6 <ide_read>
c0006677:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:63


		list_init(&cur_part->open_inodes);	// 本分区打开的inode队列！
c000667a:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000667f:	83 c0 30             	add    $0x30,%eax
c0006682:	83 ec 0c             	sub    $0xc,%esp
c0006685:	50                   	push   %eax
c0006686:	e8 f2 db ff ff       	call   c000427d <list_init>
c000668b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:66


		printk("mount %s done!\n", part->name);
c000668e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006691:	83 c0 14             	add    $0x14,%eax
c0006694:	83 ec 08             	sub    $0x8,%esp
c0006697:	50                   	push   %eax
c0006698:	68 75 c1 00 c0       	push   $0xc000c175
c000669d:	e8 ad fd ff ff       	call   c000644f <printk>
c00066a2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:68
		/* 返回true时list_traversal才会停止遍历,减少了后面元素无意义的遍历. */
		return true;
c00066a5:	b8 01 00 00 00       	mov    $0x1,%eax
c00066aa:	eb 05                	jmp    c00066b1 <mount_partition+0x206>
/work/x86_os_my/fs/fs.c:70
	}//if (!strcmp(part->name, part_name))
	return false;	// list_traversal继续遍历
c00066ac:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/fs.c:71
}
c00066b1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00066b4:	c9                   	leave  
c00066b5:	c3                   	ret    

c00066b6 <partition_format>:
partition_format():
/work/x86_os_my/fs/fs.c:87
	| 操作系统引导块，超级块，空闲块位图，inode位图，inode数组，根目录，空闲块区域 |
	+------------------------------------------------------------------------------+
	partition结构见ide.h
	MAX_FILES_PER_PART == 4096
****************************************************************************************/
static void partition_format(struct partition* part) {
c00066b6:	55                   	push   %ebp
c00066b7:	89 e5                	mov    %esp,%ebp
c00066b9:	57                   	push   %edi
c00066ba:	56                   	push   %esi
c00066bb:	53                   	push   %ebx
c00066bc:	81 ec 7c 02 00 00    	sub    $0x27c,%esp
/work/x86_os_my/fs/fs.c:89
	/* 为方便实现，inode管理的数据块，一个块大小是一扇区 */
	uint32_t boot_sector_sects = 1;		//引导块
c00066c2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
/work/x86_os_my/fs/fs.c:90
	uint32_t super_block_sects = 1;		//超级块
c00066c9:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
/work/x86_os_my/fs/fs.c:91
	uint32_t inode_bitmap_sects = DIV_ROUND_UP(MAX_FILES_PER_PART, BITS_PER_SECTOR);	// inode位图占几个扇区.最多支持4096个文件
c00066d0:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
/work/x86_os_my/fs/fs.c:92
	uint32_t inode_table_sects = DIV_ROUND_UP((sizeof(struct inode) * MAX_FILES_PER_PART), SECTOR_SIZE);	//inode数组占几个扇区
c00066d7:	c7 45 d4 60 02 00 00 	movl   $0x260,-0x2c(%ebp)
/work/x86_os_my/fs/fs.c:93
	uint32_t used_sects = boot_sector_sects + super_block_sects + inode_bitmap_sects + inode_table_sects;
c00066de:	8b 55 e0             	mov    -0x20(%ebp),%edx
c00066e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00066e4:	01 c2                	add    %eax,%edx
c00066e6:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00066e9:	01 c2                	add    %eax,%edx
c00066eb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00066ee:	01 d0                	add    %edx,%eax
c00066f0:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/fs/fs.c:94
	uint32_t free_sects = part->sec_cnt - used_sects;  
c00066f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00066f6:	8b 40 04             	mov    0x4(%eax),%eax
c00066f9:	2b 45 d0             	sub    -0x30(%ebp),%eax
c00066fc:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/fs/fs.c:98

	/************** 简单处理块位图占据的扇区数 ***************/
	uint32_t block_bitmap_sects;	//空闲块位图占几个扇区
	block_bitmap_sects = DIV_ROUND_UP(free_sects, BITS_PER_SECTOR);		//free_sects空闲块位图要占几个扇区
c00066ff:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0006702:	05 ff 0f 00 00       	add    $0xfff,%eax
c0006707:	c1 e8 0c             	shr    $0xc,%eax
c000670a:	89 45 c8             	mov    %eax,-0x38(%ebp)
/work/x86_os_my/fs/fs.c:100
	/* 再算一次空闲块数量 */
	uint32_t block_bitmap_bit_len = free_sects - block_bitmap_sects;	//block_bitmap_bit_len 是位图长度，也是空闲块数量
c000670d:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0006710:	2b 45 c8             	sub    -0x38(%ebp),%eax
c0006713:	89 45 c4             	mov    %eax,-0x3c(%ebp)
/work/x86_os_my/fs/fs.c:101
	block_bitmap_sects = DIV_ROUND_UP(block_bitmap_bit_len, BITS_PER_SECTOR); 
c0006716:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c0006719:	05 ff 0f 00 00       	add    $0xfff,%eax
c000671e:	c1 e8 0c             	shr    $0xc,%eax
c0006721:	89 45 c8             	mov    %eax,-0x38(%ebp)
/work/x86_os_my/fs/fs.c:106
	/*********************************************************/

	/* 超级块初始化 */
	struct super_block sb;		//局部变量在栈中512字节
	sb.magic = 0x19590318;
c0006724:	c7 85 a4 fd ff ff 18 	movl   $0x19590318,-0x25c(%ebp)
c000672b:	03 59 19 
/work/x86_os_my/fs/fs.c:107
	sb.sec_cnt = part->sec_cnt;
c000672e:	8b 45 08             	mov    0x8(%ebp),%eax
c0006731:	8b 40 04             	mov    0x4(%eax),%eax
c0006734:	89 85 a8 fd ff ff    	mov    %eax,-0x258(%ebp)
/work/x86_os_my/fs/fs.c:108
	sb.inode_cnt = MAX_FILES_PER_PART;
c000673a:	c7 85 ac fd ff ff 00 	movl   $0x1000,-0x254(%ebp)
c0006741:	10 00 00 
/work/x86_os_my/fs/fs.c:109
	sb.part_lba_base = part->start_lba;
c0006744:	8b 45 08             	mov    0x8(%ebp),%eax
c0006747:	8b 00                	mov    (%eax),%eax
c0006749:	89 85 b0 fd ff ff    	mov    %eax,-0x250(%ebp)
/work/x86_os_my/fs/fs.c:111

	sb.block_bitmap_lba = sb.part_lba_base + 2;	// 第0块是引导块,第1块是超级块
c000674f:	8b 85 b0 fd ff ff    	mov    -0x250(%ebp),%eax
c0006755:	83 c0 02             	add    $0x2,%eax
c0006758:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
/work/x86_os_my/fs/fs.c:112
	sb.block_bitmap_sects = block_bitmap_sects;	// 空闲块位图占几个扇区
c000675e:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0006761:	89 85 b8 fd ff ff    	mov    %eax,-0x248(%ebp)
/work/x86_os_my/fs/fs.c:114

	sb.inode_bitmap_lba = sb.block_bitmap_lba + sb.block_bitmap_sects;
c0006767:	8b 95 b4 fd ff ff    	mov    -0x24c(%ebp),%edx
c000676d:	8b 85 b8 fd ff ff    	mov    -0x248(%ebp),%eax
c0006773:	01 d0                	add    %edx,%eax
c0006775:	89 85 bc fd ff ff    	mov    %eax,-0x244(%ebp)
/work/x86_os_my/fs/fs.c:115
	sb.inode_bitmap_sects = inode_bitmap_sects;	// inode位图占几个扇区
c000677b:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000677e:	89 85 c0 fd ff ff    	mov    %eax,-0x240(%ebp)
/work/x86_os_my/fs/fs.c:117

	sb.inode_table_lba = sb.inode_bitmap_lba + sb.inode_bitmap_sects;
c0006784:	8b 95 bc fd ff ff    	mov    -0x244(%ebp),%edx
c000678a:	8b 85 c0 fd ff ff    	mov    -0x240(%ebp),%eax
c0006790:	01 d0                	add    %edx,%eax
c0006792:	89 85 c4 fd ff ff    	mov    %eax,-0x23c(%ebp)
/work/x86_os_my/fs/fs.c:118
	sb.inode_table_sects = inode_table_sects;	// inode数组占几个扇区
c0006798:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000679b:	89 85 c8 fd ff ff    	mov    %eax,-0x238(%ebp)
/work/x86_os_my/fs/fs.c:120

	sb.data_start_lba = sb.inode_table_lba + sb.inode_table_sects;	// 数据区开始的第一个扇区号
c00067a1:	8b 95 c4 fd ff ff    	mov    -0x23c(%ebp),%edx
c00067a7:	8b 85 c8 fd ff ff    	mov    -0x238(%ebp),%eax
c00067ad:	01 d0                	add    %edx,%eax
c00067af:	89 85 cc fd ff ff    	mov    %eax,-0x234(%ebp)
/work/x86_os_my/fs/fs.c:122

	sb.root_inode_no = 0;	//根目录的inode号是0
c00067b5:	c7 85 d0 fd ff ff 00 	movl   $0x0,-0x230(%ebp)
c00067bc:	00 00 00 
/work/x86_os_my/fs/fs.c:123
	sb.dir_entry_size = sizeof(struct dir_entry);
c00067bf:	c7 85 d4 fd ff ff 18 	movl   $0x18,-0x22c(%ebp)
c00067c6:	00 00 00 
/work/x86_os_my/fs/fs.c:125

	printk("%s info:\n", part->name);
c00067c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00067cc:	83 c0 14             	add    $0x14,%eax
c00067cf:	83 ec 08             	sub    $0x8,%esp
c00067d2:	50                   	push   %eax
c00067d3:	68 85 c1 00 c0       	push   $0xc000c185
c00067d8:	e8 72 fc ff ff       	call   c000644f <printk>
c00067dd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:126
	printk("   magic:0x%x\n   part_lba_base:0x%x\n   all_sectors:0x%x\n   inode_cnt:0x%x\n   block_bitmap_lba:0x%x\n   block_bitmap_sectors:0x%x\n   inode_bitmap_lba:0x%x\n   inode_bitmap_sectors:0x%x\n   inode_table_lba:0x%x\n   inode_table_sectors:0x%x\n   data_start_lba:0x%x\n", sb.magic, sb.part_lba_base, sb.sec_cnt, sb.inode_cnt, sb.block_bitmap_lba, sb.block_bitmap_sects, sb.inode_bitmap_lba, sb.inode_bitmap_sects, sb.inode_table_lba, sb.inode_table_sects, sb.data_start_lba);
c00067e0:	8b 95 cc fd ff ff    	mov    -0x234(%ebp),%edx
c00067e6:	8b 9d c8 fd ff ff    	mov    -0x238(%ebp),%ebx
c00067ec:	8b bd c4 fd ff ff    	mov    -0x23c(%ebp),%edi
c00067f2:	8b 85 c0 fd ff ff    	mov    -0x240(%ebp),%eax
c00067f8:	89 85 94 fd ff ff    	mov    %eax,-0x26c(%ebp)
c00067fe:	8b b5 bc fd ff ff    	mov    -0x244(%ebp),%esi
c0006804:	89 b5 90 fd ff ff    	mov    %esi,-0x270(%ebp)
c000680a:	8b 8d b8 fd ff ff    	mov    -0x248(%ebp),%ecx
c0006810:	89 8d 8c fd ff ff    	mov    %ecx,-0x274(%ebp)
c0006816:	8b 85 b4 fd ff ff    	mov    -0x24c(%ebp),%eax
c000681c:	89 85 88 fd ff ff    	mov    %eax,-0x278(%ebp)
c0006822:	8b b5 ac fd ff ff    	mov    -0x254(%ebp),%esi
c0006828:	89 b5 84 fd ff ff    	mov    %esi,-0x27c(%ebp)
c000682e:	8b b5 a8 fd ff ff    	mov    -0x258(%ebp),%esi
c0006834:	8b 8d b0 fd ff ff    	mov    -0x250(%ebp),%ecx
c000683a:	8b 85 a4 fd ff ff    	mov    -0x25c(%ebp),%eax
c0006840:	52                   	push   %edx
c0006841:	53                   	push   %ebx
c0006842:	57                   	push   %edi
c0006843:	ff b5 94 fd ff ff    	pushl  -0x26c(%ebp)
c0006849:	ff b5 90 fd ff ff    	pushl  -0x270(%ebp)
c000684f:	ff b5 8c fd ff ff    	pushl  -0x274(%ebp)
c0006855:	ff b5 88 fd ff ff    	pushl  -0x278(%ebp)
c000685b:	ff b5 84 fd ff ff    	pushl  -0x27c(%ebp)
c0006861:	56                   	push   %esi
c0006862:	51                   	push   %ecx
c0006863:	50                   	push   %eax
c0006864:	68 90 c1 00 c0       	push   $0xc000c190
c0006869:	e8 e1 fb ff ff       	call   c000644f <printk>
c000686e:	83 c4 30             	add    $0x30,%esp
/work/x86_os_my/fs/fs.c:130


	/***** 1 将超级块写入本分区的1号扇区 *****/
	struct disk* hd = part->my_disk;	// 分区所属的硬盘
c0006871:	8b 45 08             	mov    0x8(%ebp),%eax
c0006874:	8b 40 08             	mov    0x8(%eax),%eax
c0006877:	89 45 c0             	mov    %eax,-0x40(%ebp)
/work/x86_os_my/fs/fs.c:132
	// void ide_write(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt);
	ide_write(hd, part->start_lba + 1, &sb, 1);
c000687a:	8b 45 08             	mov    0x8(%ebp),%eax
c000687d:	8b 00                	mov    (%eax),%eax
c000687f:	8d 50 01             	lea    0x1(%eax),%edx
c0006882:	6a 01                	push   $0x1
c0006884:	8d 85 a4 fd ff ff    	lea    -0x25c(%ebp),%eax
c000688a:	50                   	push   %eax
c000688b:	52                   	push   %edx
c000688c:	ff 75 c0             	pushl  -0x40(%ebp)
c000688f:	e8 b6 f2 ff ff       	call   c0005b4a <ide_write>
c0006894:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:133
	printk("   super_block_lba:0x%x\n", part->start_lba + 1);
c0006897:	8b 45 08             	mov    0x8(%ebp),%eax
c000689a:	8b 00                	mov    (%eax),%eax
c000689c:	83 c0 01             	add    $0x1,%eax
c000689f:	83 ec 08             	sub    $0x8,%esp
c00068a2:	50                   	push   %eax
c00068a3:	68 92 c2 00 c0       	push   $0xc000c292
c00068a8:	e8 a2 fb ff ff       	call   c000644f <printk>
c00068ad:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:137


	/* 他们三个写到硬盘上：block_bitmap_sects/inode_bitmap_sects/inode_table_sects 缓冲区选三者最大的 */
	uint32_t buf_size = (sb.block_bitmap_sects >= sb.inode_bitmap_sects ? sb.block_bitmap_sects : sb.inode_bitmap_sects);
c00068b0:	8b 95 b8 fd ff ff    	mov    -0x248(%ebp),%edx
c00068b6:	8b 85 c0 fd ff ff    	mov    -0x240(%ebp),%eax
c00068bc:	39 c2                	cmp    %eax,%edx
c00068be:	0f 43 c2             	cmovae %edx,%eax
c00068c1:	89 45 bc             	mov    %eax,-0x44(%ebp)
/work/x86_os_my/fs/fs.c:138
	buf_size = (buf_size >= sb.inode_table_sects ? buf_size : sb.inode_table_sects) * SECTOR_SIZE;
c00068c4:	8b 95 c8 fd ff ff    	mov    -0x238(%ebp),%edx
c00068ca:	8b 45 bc             	mov    -0x44(%ebp),%eax
c00068cd:	39 c2                	cmp    %eax,%edx
c00068cf:	0f 43 c2             	cmovae %edx,%eax
c00068d2:	c1 e0 09             	shl    $0x9,%eax
c00068d5:	89 45 bc             	mov    %eax,-0x44(%ebp)
/work/x86_os_my/fs/fs.c:139
	uint8_t* buf = (uint8_t*)sys_malloc(buf_size);	// 申请的内存由内存管理系统清0后返回
c00068d8:	83 ec 0c             	sub    $0xc,%esp
c00068db:	ff 75 bc             	pushl  -0x44(%ebp)
c00068de:	e8 aa c3 ff ff       	call   c0002c8d <sys_malloc>
c00068e3:	83 c4 10             	add    $0x10,%esp
c00068e6:	89 45 b8             	mov    %eax,-0x48(%ebp)
/work/x86_os_my/fs/fs.c:144


	/***** 2 将块位图初始化并写入sb.block_bitmap_lba *****/
	/* 初始化块位图 block_bitmap */
	buf[0] |= 0x01;	// 第0个块预留给根目录,位图中先占位
c00068e9:	8b 45 b8             	mov    -0x48(%ebp),%eax
c00068ec:	0f b6 00             	movzbl (%eax),%eax
c00068ef:	83 c8 01             	or     $0x1,%eax
c00068f2:	89 c2                	mov    %eax,%edx
c00068f4:	8b 45 b8             	mov    -0x48(%ebp),%eax
c00068f7:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/fs/fs.c:145
	uint32_t block_bitmap_last_byte = block_bitmap_bit_len / 8;		//block_bitmap_bit_len 是位图长度，也是空闲块数量
c00068f9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c00068fc:	c1 e8 03             	shr    $0x3,%eax
c00068ff:	89 45 b4             	mov    %eax,-0x4c(%ebp)
/work/x86_os_my/fs/fs.c:146
	uint8_t  block_bitmap_last_bit  = block_bitmap_bit_len % 8;
c0006902:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c0006905:	83 e0 07             	and    $0x7,%eax
c0006908:	88 45 b3             	mov    %al,-0x4d(%ebp)
/work/x86_os_my/fs/fs.c:147
	uint32_t last_size = SECTOR_SIZE - (block_bitmap_last_byte % SECTOR_SIZE);	// last_size是位图占用的最后一个扇区中，不足一扇区的空闲部分
c000690b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c000690e:	25 ff 01 00 00       	and    $0x1ff,%eax
c0006913:	ba 00 02 00 00       	mov    $0x200,%edx
c0006918:	29 c2                	sub    %eax,%edx
c000691a:	89 d0                	mov    %edx,%eax
c000691c:	89 45 ac             	mov    %eax,-0x54(%ebp)
/work/x86_os_my/fs/fs.c:150

	// 1 空闲块位图最后一字节，到最后一字节所在扇区的末尾，全置为占用（空闲块位图所在扇区的空闲部分）
	memset(&buf[block_bitmap_last_byte], 0xff, last_size);
c000691f:	8b 55 b8             	mov    -0x48(%ebp),%edx
c0006922:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0006925:	01 d0                	add    %edx,%eax
c0006927:	83 ec 04             	sub    $0x4,%esp
c000692a:	ff 75 ac             	pushl  -0x54(%ebp)
c000692d:	68 ff 00 00 00       	push   $0xff
c0006932:	50                   	push   %eax
c0006933:	e8 4c ce ff ff       	call   c0003784 <memset>
c0006938:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:153

	// 2 上一步中最后一字节内，有效的位重新置0
	uint8_t bit_idx = 0;
c000693b:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
/work/x86_os_my/fs/fs.c:154
	while (bit_idx <= block_bitmap_last_bit) {
c000693f:	eb 37                	jmp    c0006978 <partition_format+0x2c2>
/work/x86_os_my/fs/fs.c:155
		buf[block_bitmap_last_byte] &= ~(1 << bit_idx++);
c0006941:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
c0006945:	8d 50 01             	lea    0x1(%eax),%edx
c0006948:	88 55 e7             	mov    %dl,-0x19(%ebp)
c000694b:	0f b6 c0             	movzbl %al,%eax
c000694e:	ba 01 00 00 00       	mov    $0x1,%edx
c0006953:	89 c1                	mov    %eax,%ecx
c0006955:	d3 e2                	shl    %cl,%edx
c0006957:	89 d0                	mov    %edx,%eax
c0006959:	f7 d0                	not    %eax
c000695b:	89 c3                	mov    %eax,%ebx
c000695d:	8b 55 b8             	mov    -0x48(%ebp),%edx
c0006960:	8b 45 b4             	mov    -0x4c(%ebp),%eax
c0006963:	01 d0                	add    %edx,%eax
c0006965:	8b 4d b8             	mov    -0x48(%ebp),%ecx
c0006968:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c000696b:	01 ca                	add    %ecx,%edx
c000696d:	0f b6 12             	movzbl (%edx),%edx
c0006970:	89 d1                	mov    %edx,%ecx
c0006972:	89 da                	mov    %ebx,%edx
c0006974:	21 ca                	and    %ecx,%edx
c0006976:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/fs/fs.c:154
	// 1 空闲块位图最后一字节，到最后一字节所在扇区的末尾，全置为占用（空闲块位图所在扇区的空闲部分）
	memset(&buf[block_bitmap_last_byte], 0xff, last_size);

	// 2 上一步中最后一字节内，有效的位重新置0
	uint8_t bit_idx = 0;
	while (bit_idx <= block_bitmap_last_bit) {
c0006978:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
c000697c:	3a 45 b3             	cmp    -0x4d(%ebp),%al
c000697f:	76 c0                	jbe    c0006941 <partition_format+0x28b>
/work/x86_os_my/fs/fs.c:158
		buf[block_bitmap_last_byte] &= ~(1 << bit_idx++);
	}
	// 3 写回到硬盘 空闲块位图 区域
	ide_write(hd, sb.block_bitmap_lba, buf, sb.block_bitmap_sects);
c0006981:	8b 95 b8 fd ff ff    	mov    -0x248(%ebp),%edx
c0006987:	8b 85 b4 fd ff ff    	mov    -0x24c(%ebp),%eax
c000698d:	52                   	push   %edx
c000698e:	ff 75 b8             	pushl  -0x48(%ebp)
c0006991:	50                   	push   %eax
c0006992:	ff 75 c0             	pushl  -0x40(%ebp)
c0006995:	e8 b0 f1 ff ff       	call   c0005b4a <ide_write>
c000699a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:162


	/***** 3 将inode位图初始化并写入sb.inode_bitmap_lba *****/
	memset(buf, 0, buf_size);
c000699d:	83 ec 04             	sub    $0x4,%esp
c00069a0:	ff 75 bc             	pushl  -0x44(%ebp)
c00069a3:	6a 00                	push   $0x0
c00069a5:	ff 75 b8             	pushl  -0x48(%ebp)
c00069a8:	e8 d7 cd ff ff       	call   c0003784 <memset>
c00069ad:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:163
	buf[0] |= 0x1;	// 第0个inode分给了根目录
c00069b0:	8b 45 b8             	mov    -0x48(%ebp),%eax
c00069b3:	0f b6 00             	movzbl (%eax),%eax
c00069b6:	83 c8 01             	or     $0x1,%eax
c00069b9:	89 c2                	mov    %eax,%edx
c00069bb:	8b 45 b8             	mov    -0x48(%ebp),%eax
c00069be:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/fs/fs.c:167
	/* 最多4096个文件，inode位图4096个bit，正好占用1扇区，inode_bitmap_sects等于1
	 * 不像block_bitmap，在inode_bitmap的扇区中，没有多余的空闲无效位 */
	// 写回到硬盘 inode位图 区域
	ide_write(hd, sb.inode_bitmap_lba, buf, sb.inode_bitmap_sects);
c00069c0:	8b 95 c0 fd ff ff    	mov    -0x240(%ebp),%edx
c00069c6:	8b 85 bc fd ff ff    	mov    -0x244(%ebp),%eax
c00069cc:	52                   	push   %edx
c00069cd:	ff 75 b8             	pushl  -0x48(%ebp)
c00069d0:	50                   	push   %eax
c00069d1:	ff 75 c0             	pushl  -0x40(%ebp)
c00069d4:	e8 71 f1 ff ff       	call   c0005b4a <ide_write>
c00069d9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:172


	/***** 4 将inode数组初始化并写入sb.inode_table_lba *****/
	/* 处理inode_table中的第0项，即根目录所在的inode */
	memset(buf, 0, buf_size);
c00069dc:	83 ec 04             	sub    $0x4,%esp
c00069df:	ff 75 bc             	pushl  -0x44(%ebp)
c00069e2:	6a 00                	push   $0x0
c00069e4:	ff 75 b8             	pushl  -0x48(%ebp)
c00069e7:	e8 98 cd ff ff       	call   c0003784 <memset>
c00069ec:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:173
	struct inode* i = (struct inode*)buf;
c00069ef:	8b 45 b8             	mov    -0x48(%ebp),%eax
c00069f2:	89 45 a8             	mov    %eax,-0x58(%ebp)
/work/x86_os_my/fs/fs.c:174
	i->i_size = sb.dir_entry_size * 2;		// .和..	// 所有目录项大小之和
c00069f5:	8b 85 d4 fd ff ff    	mov    -0x22c(%ebp),%eax
c00069fb:	8d 14 00             	lea    (%eax,%eax,1),%edx
c00069fe:	8b 45 a8             	mov    -0x58(%ebp),%eax
c0006a01:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/fs.c:175
	i->i_no = 0;   // 根目录占inode数组中第0个inode
c0006a04:	8b 45 a8             	mov    -0x58(%ebp),%eax
c0006a07:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:179
	// inode管理的是数据块（对于我们来说就是扇区）
	// 此处是指定根目录这个inode管理的数据块的位置
	// i_sectors数组后边的元素都是0 没用到
	i->i_sectors[0] = sb.data_start_lba;
c0006a0d:	8b 95 cc fd ff ff    	mov    -0x234(%ebp),%edx
c0006a13:	8b 45 a8             	mov    -0x58(%ebp),%eax
c0006a16:	89 50 10             	mov    %edx,0x10(%eax)
/work/x86_os_my/fs/fs.c:182
	// 写到硬盘 inode数组
	// 其实我们只处理了第0项
	ide_write(hd, sb.inode_table_lba, buf, sb.inode_table_sects);
c0006a19:	8b 95 c8 fd ff ff    	mov    -0x238(%ebp),%edx
c0006a1f:	8b 85 c4 fd ff ff    	mov    -0x23c(%ebp),%eax
c0006a25:	52                   	push   %edx
c0006a26:	ff 75 b8             	pushl  -0x48(%ebp)
c0006a29:	50                   	push   %eax
c0006a2a:	ff 75 c0             	pushl  -0x40(%ebp)
c0006a2d:	e8 18 f1 ff ff       	call   c0005b4a <ide_write>
c0006a32:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:188


	/***** 5 将根目录初始化并写入sb.data_start_lba *****/
	/* 写入根目录的两个目录项.和.. */
	// inode不知道数据块中是普通文件，还是目录。但是目录项知道。
	memset(buf, 0, buf_size);
c0006a35:	83 ec 04             	sub    $0x4,%esp
c0006a38:	ff 75 bc             	pushl  -0x44(%ebp)
c0006a3b:	6a 00                	push   $0x0
c0006a3d:	ff 75 b8             	pushl  -0x48(%ebp)
c0006a40:	e8 3f cd ff ff       	call   c0003784 <memset>
c0006a45:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:189
	struct dir_entry* p_de = (struct dir_entry*)buf;
c0006a48:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0006a4b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
/work/x86_os_my/fs/fs.c:192

	/* 初始化当前目录"." */
	memcpy(p_de->filename, ".", 1);
c0006a4e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c0006a51:	83 ec 04             	sub    $0x4,%esp
c0006a54:	6a 01                	push   $0x1
c0006a56:	68 ab c2 00 c0       	push   $0xc000c2ab
c0006a5b:	50                   	push   %eax
c0006a5c:	e8 75 cd ff ff       	call   c00037d6 <memcpy>
c0006a61:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:193
	p_de->i_no = 0;	// 目录或文件对应的inode编号
c0006a64:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c0006a67:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
/work/x86_os_my/fs/fs.c:194
	p_de->f_type = FT_DIRECTORY;
c0006a6e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c0006a71:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%eax)
/work/x86_os_my/fs/fs.c:196

	p_de++;
c0006a78:	83 45 a4 18          	addl   $0x18,-0x5c(%ebp)
/work/x86_os_my/fs/fs.c:199

	/* 初始化当前目录父目录".." */
	memcpy(p_de->filename, "..", 2);
c0006a7c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c0006a7f:	83 ec 04             	sub    $0x4,%esp
c0006a82:	6a 02                	push   $0x2
c0006a84:	68 ad c2 00 c0       	push   $0xc000c2ad
c0006a89:	50                   	push   %eax
c0006a8a:	e8 47 cd ff ff       	call   c00037d6 <memcpy>
c0006a8f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:200
	p_de->i_no = 0;	// 根目录的父目录依然是根目录自己
c0006a92:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c0006a95:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
/work/x86_os_my/fs/fs.c:201
	p_de->f_type = FT_DIRECTORY;
c0006a9c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
c0006a9f:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%eax)
/work/x86_os_my/fs/fs.c:204

	/* sb.data_start_lba已经分配给了根目录，我们把根目录的目录项放进去 */
	ide_write(hd, sb.data_start_lba, buf, 1);
c0006aa6:	8b 85 cc fd ff ff    	mov    -0x234(%ebp),%eax
c0006aac:	6a 01                	push   $0x1
c0006aae:	ff 75 b8             	pushl  -0x48(%ebp)
c0006ab1:	50                   	push   %eax
c0006ab2:	ff 75 c0             	pushl  -0x40(%ebp)
c0006ab5:	e8 90 f0 ff ff       	call   c0005b4a <ide_write>
c0006aba:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:207


	printk("   root_dir_lba:0x%x\n", sb.data_start_lba);
c0006abd:	8b 85 cc fd ff ff    	mov    -0x234(%ebp),%eax
c0006ac3:	83 ec 08             	sub    $0x8,%esp
c0006ac6:	50                   	push   %eax
c0006ac7:	68 b0 c2 00 c0       	push   $0xc000c2b0
c0006acc:	e8 7e f9 ff ff       	call   c000644f <printk>
c0006ad1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:208
	printk("%s format done\n", part->name);
c0006ad4:	8b 45 08             	mov    0x8(%ebp),%eax
c0006ad7:	83 c0 14             	add    $0x14,%eax
c0006ada:	83 ec 08             	sub    $0x8,%esp
c0006add:	50                   	push   %eax
c0006ade:	68 c6 c2 00 c0       	push   $0xc000c2c6
c0006ae3:	e8 67 f9 ff ff       	call   c000644f <printk>
c0006ae8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:209
	sys_free(buf);
c0006aeb:	83 ec 0c             	sub    $0xc,%esp
c0006aee:	ff 75 b8             	pushl  -0x48(%ebp)
c0006af1:	e8 c4 c7 ff ff       	call   c00032ba <sys_free>
c0006af6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:210
}
c0006af9:	90                   	nop
c0006afa:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0006afd:	5b                   	pop    %ebx
c0006afe:	5e                   	pop    %esi
c0006aff:	5f                   	pop    %edi
c0006b00:	5d                   	pop    %ebp
c0006b01:	c3                   	ret    

c0006b02 <path_parse>:
path_parse():
/work/x86_os_my/fs/fs.c:215


/* 将最上层路径名称解析出来，比如pathname="a/b/c"得到name_store="a"
 * 返回剩下的目录 "b/c" */
static char* path_parse(char* pathname, char* name_store) {
c0006b02:	55                   	push   %ebp
c0006b03:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/fs/fs.c:216
	if (pathname[0] == '/') {	// 根目录不需要单独解析
c0006b05:	8b 45 08             	mov    0x8(%ebp),%eax
c0006b08:	0f b6 00             	movzbl (%eax),%eax
c0006b0b:	3c 2f                	cmp    $0x2f,%al
c0006b0d:	75 27                	jne    c0006b36 <path_parse+0x34>
/work/x86_os_my/fs/fs.c:218 (discriminator 1)
		/* 路径中出现1个或多个连续的字符'/',将这些'/'跳过,如"///a/b" */
		while(*(++pathname) == '/');
c0006b0f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0006b13:	8b 45 08             	mov    0x8(%ebp),%eax
c0006b16:	0f b6 00             	movzbl (%eax),%eax
c0006b19:	3c 2f                	cmp    $0x2f,%al
c0006b1b:	74 f2                	je     c0006b0f <path_parse+0xd>
/work/x86_os_my/fs/fs.c:222
	}

	/* 开始一般的路径解析 */
	while (*pathname != '/' && *pathname != 0) {
c0006b1d:	eb 17                	jmp    c0006b36 <path_parse+0x34>
/work/x86_os_my/fs/fs.c:223
		*name_store++ = *pathname++;
c0006b1f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006b22:	8d 50 01             	lea    0x1(%eax),%edx
c0006b25:	89 55 0c             	mov    %edx,0xc(%ebp)
c0006b28:	8b 55 08             	mov    0x8(%ebp),%edx
c0006b2b:	8d 4a 01             	lea    0x1(%edx),%ecx
c0006b2e:	89 4d 08             	mov    %ecx,0x8(%ebp)
c0006b31:	0f b6 12             	movzbl (%edx),%edx
c0006b34:	88 10                	mov    %dl,(%eax)
/work/x86_os_my/fs/fs.c:222
		/* 路径中出现1个或多个连续的字符'/',将这些'/'跳过,如"///a/b" */
		while(*(++pathname) == '/');
	}

	/* 开始一般的路径解析 */
	while (*pathname != '/' && *pathname != 0) {
c0006b36:	8b 45 08             	mov    0x8(%ebp),%eax
c0006b39:	0f b6 00             	movzbl (%eax),%eax
c0006b3c:	3c 2f                	cmp    $0x2f,%al
c0006b3e:	74 0a                	je     c0006b4a <path_parse+0x48>
/work/x86_os_my/fs/fs.c:222 (discriminator 1)
c0006b40:	8b 45 08             	mov    0x8(%ebp),%eax
c0006b43:	0f b6 00             	movzbl (%eax),%eax
c0006b46:	84 c0                	test   %al,%al
c0006b48:	75 d5                	jne    c0006b1f <path_parse+0x1d>
/work/x86_os_my/fs/fs.c:226
		*name_store++ = *pathname++;
	}

	if (pathname[0] == 0) {   // 若路径字符串为空则返回NULL
c0006b4a:	8b 45 08             	mov    0x8(%ebp),%eax
c0006b4d:	0f b6 00             	movzbl (%eax),%eax
c0006b50:	84 c0                	test   %al,%al
c0006b52:	75 07                	jne    c0006b5b <path_parse+0x59>
/work/x86_os_my/fs/fs.c:227
		return NULL;
c0006b54:	b8 00 00 00 00       	mov    $0x0,%eax
c0006b59:	eb 03                	jmp    c0006b5e <path_parse+0x5c>
/work/x86_os_my/fs/fs.c:229
	}
	return pathname;
c0006b5b:	8b 45 08             	mov    0x8(%ebp),%eax
/work/x86_os_my/fs/fs.c:230
}
c0006b5e:	5d                   	pop    %ebp
c0006b5f:	c3                   	ret    

c0006b60 <path_depth_cnt>:
path_depth_cnt():
/work/x86_os_my/fs/fs.c:233

/* 返回路径深度,比如/a/b/c,深度为3 */
int32_t path_depth_cnt(char* pathname) {
c0006b60:	55                   	push   %ebp
c0006b61:	89 e5                	mov    %esp,%ebp
c0006b63:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/fs/fs.c:234
	ASSERT(pathname != NULL);
c0006b66:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0006b6a:	75 1c                	jne    c0006b88 <path_depth_cnt+0x28>
/work/x86_os_my/fs/fs.c:234 (discriminator 1)
c0006b6c:	68 d6 c2 00 c0       	push   $0xc000c2d6
c0006b71:	68 3c c9 00 c0       	push   $0xc000c93c
c0006b76:	68 ea 00 00 00       	push   $0xea
c0006b7b:	68 6d c1 00 c0       	push   $0xc000c16d
c0006b80:	e8 5d b7 ff ff       	call   c00022e2 <panic_spin>
c0006b85:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:235
	char* p = pathname;
c0006b88:	8b 45 08             	mov    0x8(%ebp),%eax
c0006b8b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:237
	char name[MAX_FILE_NAME_LEN];	// 用于path_parse的参数做路径解析
	uint32_t depth = 0;
c0006b8e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:240

	/* 解析路径,从中拆分出各级名称 */
	p = path_parse(p, name);
c0006b95:	83 ec 08             	sub    $0x8,%esp
c0006b98:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0006b9b:	50                   	push   %eax
c0006b9c:	ff 75 f4             	pushl  -0xc(%ebp)
c0006b9f:	e8 5e ff ff ff       	call   c0006b02 <path_parse>
c0006ba4:	83 c4 10             	add    $0x10,%esp
c0006ba7:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:241
	while (name[0]) {
c0006baa:	eb 32                	jmp    c0006bde <path_depth_cnt+0x7e>
/work/x86_os_my/fs/fs.c:242
		depth++;
c0006bac:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:243
		memset(name, 0, MAX_FILE_NAME_LEN);
c0006bb0:	83 ec 04             	sub    $0x4,%esp
c0006bb3:	6a 10                	push   $0x10
c0006bb5:	6a 00                	push   $0x0
c0006bb7:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0006bba:	50                   	push   %eax
c0006bbb:	e8 c4 cb ff ff       	call   c0003784 <memset>
c0006bc0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:244
		if (p) {	// 如果p不等于NULL,继续分析路径
c0006bc3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0006bc7:	74 15                	je     c0006bde <path_depth_cnt+0x7e>
/work/x86_os_my/fs/fs.c:245
			p  = path_parse(p, name);
c0006bc9:	83 ec 08             	sub    $0x8,%esp
c0006bcc:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0006bcf:	50                   	push   %eax
c0006bd0:	ff 75 f4             	pushl  -0xc(%ebp)
c0006bd3:	e8 2a ff ff ff       	call   c0006b02 <path_parse>
c0006bd8:	83 c4 10             	add    $0x10,%esp
c0006bdb:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:241
	char name[MAX_FILE_NAME_LEN];	// 用于path_parse的参数做路径解析
	uint32_t depth = 0;

	/* 解析路径,从中拆分出各级名称 */
	p = path_parse(p, name);
	while (name[0]) {
c0006bde:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
c0006be2:	84 c0                	test   %al,%al
c0006be4:	75 c6                	jne    c0006bac <path_depth_cnt+0x4c>
/work/x86_os_my/fs/fs.c:248
		memset(name, 0, MAX_FILE_NAME_LEN);
		if (p) {	// 如果p不等于NULL,继续分析路径
			p  = path_parse(p, name);
		}
	}
	return depth;
c0006be6:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/fs/fs.c:249
}
c0006be9:	c9                   	leave  
c0006bea:	c3                   	ret    

c0006beb <search_file>:
search_file():
/work/x86_os_my/fs/fs.c:258
 * 全局变量 struct dir root_dir 定义在 dir.c
 * 也支持 /./a 或者 /../b 会把.和..当做一个目录项继续往下层找
 * /a/b/c若c不存在，那么 searched_record.searched_path 是 /a/b/c
 * 注意下边三种return的地方，是三种情况！
 */
static int search_file(const char* pathname, struct path_search_record* searched_record) {
c0006beb:	55                   	push   %ebp
c0006bec:	89 e5                	mov    %esp,%ebp
c0006bee:	83 ec 48             	sub    $0x48,%esp
/work/x86_os_my/fs/fs.c:260
	/* 如果待查找的是根目录,为避免下面无用的查找,直接返回已知根目录信息 */
	if (!strcmp(pathname, "/") || !strcmp(pathname, "/.") || !strcmp(pathname, "/..")) {
c0006bf1:	83 ec 08             	sub    $0x8,%esp
c0006bf4:	68 e7 c2 00 c0       	push   $0xc000c2e7
c0006bf9:	ff 75 08             	pushl  0x8(%ebp)
c0006bfc:	e8 58 cd ff ff       	call   c0003959 <strcmp>
c0006c01:	83 c4 10             	add    $0x10,%esp
c0006c04:	84 c0                	test   %al,%al
c0006c06:	74 2e                	je     c0006c36 <search_file+0x4b>
/work/x86_os_my/fs/fs.c:260 (discriminator 1)
c0006c08:	83 ec 08             	sub    $0x8,%esp
c0006c0b:	68 e9 c2 00 c0       	push   $0xc000c2e9
c0006c10:	ff 75 08             	pushl  0x8(%ebp)
c0006c13:	e8 41 cd ff ff       	call   c0003959 <strcmp>
c0006c18:	83 c4 10             	add    $0x10,%esp
c0006c1b:	84 c0                	test   %al,%al
c0006c1d:	74 17                	je     c0006c36 <search_file+0x4b>
/work/x86_os_my/fs/fs.c:260 (discriminator 2)
c0006c1f:	83 ec 08             	sub    $0x8,%esp
c0006c22:	68 ec c2 00 c0       	push   $0xc000c2ec
c0006c27:	ff 75 08             	pushl  0x8(%ebp)
c0006c2a:	e8 2a cd ff ff       	call   c0003959 <strcmp>
c0006c2f:	83 c4 10             	add    $0x10,%esp
c0006c32:	84 c0                	test   %al,%al
c0006c34:	75 2a                	jne    c0006c60 <search_file+0x75>
/work/x86_os_my/fs/fs.c:261
		searched_record->parent_dir = &root_dir;	// 直接父目录
c0006c36:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006c39:	c7 80 00 02 00 00 60 	movl   $0xc0010b60,0x200(%eax)
c0006c40:	0b 01 c0 
/work/x86_os_my/fs/fs.c:262
		searched_record->file_type = FT_DIRECTORY;	// FT_UNKNOWN代表没找到，找到才有类型是文件或目录
c0006c43:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006c46:	c7 80 04 02 00 00 02 	movl   $0x2,0x204(%eax)
c0006c4d:	00 00 00 
/work/x86_os_my/fs/fs.c:263
		searched_record->searched_path[0] = 0;		// 搜索过的路径置空
c0006c50:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006c53:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:264
		return 0;
c0006c56:	b8 00 00 00 00       	mov    $0x0,%eax
c0006c5b:	e9 08 02 00 00       	jmp    c0006e68 <search_file+0x27d>
/work/x86_os_my/fs/fs.c:267
	}

	uint32_t path_len = strlen(pathname);
c0006c60:	83 ec 0c             	sub    $0xc,%esp
c0006c63:	ff 75 08             	pushl  0x8(%ebp)
c0006c66:	e8 a3 cc ff ff       	call   c000390e <strlen>
c0006c6b:	83 c4 10             	add    $0x10,%esp
c0006c6e:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:269
	/* 保证pathname至少是这样的路径/x且小于最大长度 */
	ASSERT(pathname[0] == '/' && path_len > 1 && path_len < MAX_PATH_LEN);
c0006c71:	8b 45 08             	mov    0x8(%ebp),%eax
c0006c74:	0f b6 00             	movzbl (%eax),%eax
c0006c77:	3c 2f                	cmp    $0x2f,%al
c0006c79:	75 0f                	jne    c0006c8a <search_file+0x9f>
/work/x86_os_my/fs/fs.c:269 (discriminator 1)
c0006c7b:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
c0006c7f:	76 09                	jbe    c0006c8a <search_file+0x9f>
/work/x86_os_my/fs/fs.c:269 (discriminator 3)
c0006c81:	81 7d e8 ff 01 00 00 	cmpl   $0x1ff,-0x18(%ebp)
c0006c88:	76 1c                	jbe    c0006ca6 <search_file+0xbb>
/work/x86_os_my/fs/fs.c:269 (discriminator 5)
c0006c8a:	68 f0 c2 00 c0       	push   $0xc000c2f0
c0006c8f:	68 4c c9 00 c0       	push   $0xc000c94c
c0006c94:	68 0d 01 00 00       	push   $0x10d
c0006c99:	68 6d c1 00 c0       	push   $0xc000c16d
c0006c9e:	e8 3f b6 ff ff       	call   c00022e2 <panic_spin>
c0006ca3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:270
	char* sub_path = (char*)pathname;
c0006ca6:	8b 45 08             	mov    0x8(%ebp),%eax
c0006ca9:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:271
	struct dir* parent_dir = &root_dir;
c0006cac:	c7 45 f0 60 0b 01 c0 	movl   $0xc0010b60,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:275
	struct dir_entry dir_e;

	/* 数组name每次的值分别是各级目录的名字："a","b","c" */
	char name[MAX_FILE_NAME_LEN] = {0};
c0006cb3:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
c0006cba:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
c0006cc1:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
c0006cc8:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
/work/x86_os_my/fs/fs.c:277

	searched_record->parent_dir = parent_dir;	// 直接父目录
c0006ccf:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006cd2:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0006cd5:	89 90 00 02 00 00    	mov    %edx,0x200(%eax)
/work/x86_os_my/fs/fs.c:278
	searched_record->file_type = FT_UNKNOWN;	// 初始值代表没找到，找到才有类型是文件或目录
c0006cdb:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006cde:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%eax)
c0006ce5:	00 00 00 
/work/x86_os_my/fs/fs.c:279
	uint32_t parent_inode_no = 0;  // 备份各层解析出来的路径，的父目录，的inode号
c0006ce8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:281

	sub_path = path_parse(sub_path, name);
c0006cef:	83 ec 08             	sub    $0x8,%esp
c0006cf2:	8d 45 c0             	lea    -0x40(%ebp),%eax
c0006cf5:	50                   	push   %eax
c0006cf6:	ff 75 f4             	pushl  -0xc(%ebp)
c0006cf9:	e8 04 fe ff ff       	call   c0006b02 <path_parse>
c0006cfe:	83 c4 10             	add    $0x10,%esp
c0006d01:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:282
	while (name[0]) {	   // 若第一个字符就是结束符,结束循环
c0006d04:	e9 0f 01 00 00       	jmp    c0006e18 <search_file+0x22d>
/work/x86_os_my/fs/fs.c:284
		/* 记录查找过的路径,但不能超过searched_path的长度512字节 */
		ASSERT(strlen(searched_record->searched_path) < 512);
c0006d09:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006d0c:	83 ec 0c             	sub    $0xc,%esp
c0006d0f:	50                   	push   %eax
c0006d10:	e8 f9 cb ff ff       	call   c000390e <strlen>
c0006d15:	83 c4 10             	add    $0x10,%esp
c0006d18:	3d ff 01 00 00       	cmp    $0x1ff,%eax
c0006d1d:	76 1c                	jbe    c0006d3b <search_file+0x150>
/work/x86_os_my/fs/fs.c:284 (discriminator 1)
c0006d1f:	68 30 c3 00 c0       	push   $0xc000c330
c0006d24:	68 4c c9 00 c0       	push   $0xc000c94c
c0006d29:	68 1c 01 00 00       	push   $0x11c
c0006d2e:	68 6d c1 00 c0       	push   $0xc000c16d
c0006d33:	e8 aa b5 ff ff       	call   c00022e2 <panic_spin>
c0006d38:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:287

		/* 追加到已存在的父目录 */
		strcat(searched_record->searched_path, "/");
c0006d3b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006d3e:	83 ec 08             	sub    $0x8,%esp
c0006d41:	68 e7 c2 00 c0       	push   $0xc000c2e7
c0006d46:	50                   	push   %eax
c0006d47:	e8 3c cd ff ff       	call   c0003a88 <strcat>
c0006d4c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:288
		strcat(searched_record->searched_path, name);
c0006d4f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006d52:	83 ec 08             	sub    $0x8,%esp
c0006d55:	8d 55 c0             	lea    -0x40(%ebp),%edx
c0006d58:	52                   	push   %edx
c0006d59:	50                   	push   %eax
c0006d5a:	e8 29 cd ff ff       	call   c0003a88 <strcat>
c0006d5f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:291

		/* 在所给的目录中查找目录项，找到后将目录项填入dir_e */
		if (false != search_dir_entry(cur_part, parent_dir, name, &dir_e)) {
c0006d62:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0006d67:	8d 55 d0             	lea    -0x30(%ebp),%edx
c0006d6a:	52                   	push   %edx
c0006d6b:	8d 55 c0             	lea    -0x40(%ebp),%edx
c0006d6e:	52                   	push   %edx
c0006d6f:	ff 75 f0             	pushl  -0x10(%ebp)
c0006d72:	50                   	push   %eax
c0006d73:	e8 d8 2f 00 00       	call   c0009d50 <search_dir_entry>
c0006d78:	83 c4 10             	add    $0x10,%esp
c0006d7b:	85 c0                	test   %eax,%eax
c0006d7d:	0f 84 8e 00 00 00    	je     c0006e11 <search_file+0x226>
/work/x86_os_my/fs/fs.c:292
			memset(name, 0, MAX_FILE_NAME_LEN);
c0006d83:	83 ec 04             	sub    $0x4,%esp
c0006d86:	6a 10                	push   $0x10
c0006d88:	6a 00                	push   $0x0
c0006d8a:	8d 45 c0             	lea    -0x40(%ebp),%eax
c0006d8d:	50                   	push   %eax
c0006d8e:	e8 f1 c9 ff ff       	call   c0003784 <memset>
c0006d93:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:294
			/* 若sub_path不等于NULL，也就是搜索未结束，继续拆分路径 */
			if (sub_path) {
c0006d96:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0006d9a:	74 15                	je     c0006db1 <search_file+0x1c6>
/work/x86_os_my/fs/fs.c:295
				sub_path = path_parse(sub_path, name);
c0006d9c:	83 ec 08             	sub    $0x8,%esp
c0006d9f:	8d 45 c0             	lea    -0x40(%ebp),%eax
c0006da2:	50                   	push   %eax
c0006da3:	ff 75 f4             	pushl  -0xc(%ebp)
c0006da6:	e8 57 fd ff ff       	call   c0006b02 <path_parse>
c0006dab:	83 c4 10             	add    $0x10,%esp
c0006dae:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:298
			}

			if (FT_DIRECTORY == dir_e.f_type) {			// 如果被打开的是目录
c0006db1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0006db4:	83 f8 02             	cmp    $0x2,%eax
c0006db7:	75 3e                	jne    c0006df7 <search_file+0x20c>
/work/x86_os_my/fs/fs.c:299
				parent_inode_no = parent_dir->inode->i_no;
c0006db9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006dbc:	8b 00                	mov    (%eax),%eax
c0006dbe:	8b 00                	mov    (%eax),%eax
c0006dc0:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:300
				dir_close(parent_dir);
c0006dc3:	83 ec 0c             	sub    $0xc,%esp
c0006dc6:	ff 75 f0             	pushl  -0x10(%ebp)
c0006dc9:	e8 5a 31 00 00       	call   c0009f28 <dir_close>
c0006dce:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:302

				parent_dir = dir_open(cur_part, dir_e.i_no);
c0006dd1:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0006dd4:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0006dd9:	83 ec 08             	sub    $0x8,%esp
c0006ddc:	52                   	push   %edx
c0006ddd:	50                   	push   %eax
c0006dde:	e8 2d 2f 00 00       	call   c0009d10 <dir_open>
c0006de3:	83 c4 10             	add    $0x10,%esp
c0006de6:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:303
				searched_record->parent_dir = parent_dir;	// 更新直接父目录
c0006de9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006dec:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0006def:	89 90 00 02 00 00    	mov    %edx,0x200(%eax)
/work/x86_os_my/fs/fs.c:304
				continue;
c0006df5:	eb 21                	jmp    c0006e18 <search_file+0x22d>
/work/x86_os_my/fs/fs.c:305
			} else if (FT_REGULAR == dir_e.f_type) {	// 若是普通文件
c0006df7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0006dfa:	83 f8 01             	cmp    $0x1,%eax
c0006dfd:	75 19                	jne    c0006e18 <search_file+0x22d>
/work/x86_os_my/fs/fs.c:310
				/* 如果搜索路径为 /a/b 但是目录下只有文件a 此时也会返回文件a的inode号【中间某个目录不存在】
				 * 由主调函数根据 searched_record.searched_path 判断："提供的 pathname 是否正确，是否处理完了"
				 * 【情况1】
				 */
				searched_record->file_type = FT_REGULAR;
c0006dff:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006e02:	c7 80 04 02 00 00 01 	movl   $0x1,0x204(%eax)
c0006e09:	00 00 00 
/work/x86_os_my/fs/fs.c:311
				return dir_e.i_no;
c0006e0c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0006e0f:	eb 57                	jmp    c0006e68 <search_file+0x27d>
/work/x86_os_my/fs/fs.c:319
			/* 找不到目录项时，要留着 parent_dir 不要关闭，
			 * 主调函数需要据此知道在哪个目录中创建文件，此时的 searched_record->parent_dir 指向父目录，主调函数负责关闭该目录
			 * 主调函数，创建新文件的话需要在 parent_dir 中创建
			 * 【情况2】
			 */
			return -1;
c0006e11:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0006e16:	eb 50                	jmp    c0006e68 <search_file+0x27d>
/work/x86_os_my/fs/fs.c:282
	searched_record->parent_dir = parent_dir;	// 直接父目录
	searched_record->file_type = FT_UNKNOWN;	// 初始值代表没找到，找到才有类型是文件或目录
	uint32_t parent_inode_no = 0;  // 备份各层解析出来的路径，的父目录，的inode号

	sub_path = path_parse(sub_path, name);
	while (name[0]) {	   // 若第一个字符就是结束符,结束循环
c0006e18:	0f b6 45 c0          	movzbl -0x40(%ebp),%eax
c0006e1c:	84 c0                	test   %al,%al
c0006e1e:	0f 85 e5 fe ff ff    	jne    c0006d09 <search_file+0x11e>
/work/x86_os_my/fs/fs.c:330
	 * 此时 searched_record-> parent_dir 是路径 pathname 中的最后一级目录 c，并不是倒数第二级的父目录 b
	 * 要保证，无论搜索目标是普通文件，还是目录，searched_record->parent_dir 中记录的都应该是父目录！
	 * 因此要关闭目录c，重新打开目录b
	 * 【情况3】
	 */
	dir_close(searched_record->parent_dir);
c0006e24:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006e27:	8b 80 00 02 00 00    	mov    0x200(%eax),%eax
c0006e2d:	83 ec 0c             	sub    $0xc,%esp
c0006e30:	50                   	push   %eax
c0006e31:	e8 f2 30 00 00       	call   c0009f28 <dir_close>
c0006e36:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:331
	searched_record->parent_dir = dir_open(cur_part, parent_inode_no);
c0006e39:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0006e3e:	83 ec 08             	sub    $0x8,%esp
c0006e41:	ff 75 ec             	pushl  -0x14(%ebp)
c0006e44:	50                   	push   %eax
c0006e45:	e8 c6 2e 00 00       	call   c0009d10 <dir_open>
c0006e4a:	83 c4 10             	add    $0x10,%esp
c0006e4d:	89 c2                	mov    %eax,%edx
c0006e4f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006e52:	89 90 00 02 00 00    	mov    %edx,0x200(%eax)
/work/x86_os_my/fs/fs.c:332
	searched_record->file_type = FT_DIRECTORY;
c0006e58:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006e5b:	c7 80 04 02 00 00 02 	movl   $0x2,0x204(%eax)
c0006e62:	00 00 00 
/work/x86_os_my/fs/fs.c:333
	return dir_e.i_no;	//目录c的inode号
c0006e65:	8b 45 e0             	mov    -0x20(%ebp),%eax
/work/x86_os_my/fs/fs.c:334 (discriminator 1)
}
c0006e68:	c9                   	leave  
c0006e69:	c3                   	ret    

c0006e6a <sys_open>:
sys_open():
/work/x86_os_my/fs/fs.c:341
/* 打开或创建文件成功后,返回文件描述符,否则返回-1
 * 对应 file.c 中的 file_create
 *
 * open(const char * pathname, (O_CREAT|O_WRONLY|O_TRUNC));
 */
int32_t sys_open(const char* pathname, uint8_t flags) {
c0006e6a:	55                   	push   %ebp
c0006e6b:	89 e5                	mov    %esp,%ebp
c0006e6d:	53                   	push   %ebx
c0006e6e:	81 ec 34 02 00 00    	sub    $0x234,%esp
c0006e74:	8b 45 0c             	mov    0xc(%ebp),%eax
c0006e77:	88 85 d4 fd ff ff    	mov    %al,-0x22c(%ebp)
/work/x86_os_my/fs/fs.c:343
	/* 对目录要用dir_open,这里只有open文件 */
	if (pathname[strlen(pathname) - 1] == '/') {
c0006e7d:	83 ec 0c             	sub    $0xc,%esp
c0006e80:	ff 75 08             	pushl  0x8(%ebp)
c0006e83:	e8 86 ca ff ff       	call   c000390e <strlen>
c0006e88:	83 c4 10             	add    $0x10,%esp
c0006e8b:	8d 50 ff             	lea    -0x1(%eax),%edx
c0006e8e:	8b 45 08             	mov    0x8(%ebp),%eax
c0006e91:	01 d0                	add    %edx,%eax
c0006e93:	0f b6 00             	movzbl (%eax),%eax
c0006e96:	3c 2f                	cmp    $0x2f,%al
c0006e98:	75 1d                	jne    c0006eb7 <sys_open+0x4d>
/work/x86_os_my/fs/fs.c:344
		printk("can`t open a directory %s\n", pathname);
c0006e9a:	83 ec 08             	sub    $0x8,%esp
c0006e9d:	ff 75 08             	pushl  0x8(%ebp)
c0006ea0:	68 5d c3 00 c0       	push   $0xc000c35d
c0006ea5:	e8 a5 f5 ff ff       	call   c000644f <printk>
c0006eaa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:345
		return -1;
c0006ead:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0006eb2:	e9 10 02 00 00       	jmp    c00070c7 <sys_open+0x25d>
/work/x86_os_my/fs/fs.c:347
	}
	ASSERT(flags <= 7);
c0006eb7:	80 bd d4 fd ff ff 07 	cmpb   $0x7,-0x22c(%ebp)
c0006ebe:	76 1c                	jbe    c0006edc <sys_open+0x72>
/work/x86_os_my/fs/fs.c:347 (discriminator 1)
c0006ec0:	68 78 c3 00 c0       	push   $0xc000c378
c0006ec5:	68 58 c9 00 c0       	push   $0xc000c958
c0006eca:	68 5b 01 00 00       	push   $0x15b
c0006ecf:	68 6d c1 00 c0       	push   $0xc000c16d
c0006ed4:	e8 09 b4 ff ff       	call   c00022e2 <panic_spin>
c0006ed9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:348
	int32_t fd = -1;	// 默认为找不到
c0006edc:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:351

	struct path_search_record searched_record;
	memset(&searched_record, 0, sizeof(struct path_search_record));
c0006ee3:	83 ec 04             	sub    $0x4,%esp
c0006ee6:	68 08 02 00 00       	push   $0x208
c0006eeb:	6a 00                	push   $0x0
c0006eed:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c0006ef3:	50                   	push   %eax
c0006ef4:	e8 8b c8 ff ff       	call   c0003784 <memset>
c0006ef9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:354

	/* 记录目录深度.帮助判断中间某个目录不存在的情况 */
	uint32_t pathname_depth = path_depth_cnt((char*)pathname);
c0006efc:	83 ec 0c             	sub    $0xc,%esp
c0006eff:	ff 75 08             	pushl  0x8(%ebp)
c0006f02:	e8 59 fc ff ff       	call   c0006b60 <path_depth_cnt>
c0006f07:	83 c4 10             	add    $0x10,%esp
c0006f0a:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:357

	/* 先检查文件是否存在 */
	int inode_no = search_file(pathname, &searched_record);
c0006f0d:	83 ec 08             	sub    $0x8,%esp
c0006f10:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c0006f16:	50                   	push   %eax
c0006f17:	ff 75 08             	pushl  0x8(%ebp)
c0006f1a:	e8 cc fc ff ff       	call   c0006beb <search_file>
c0006f1f:	83 c4 10             	add    $0x10,%esp
c0006f22:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:358
	bool found = (inode_no != -1 ? true : false);
c0006f25:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c0006f29:	0f 95 c0             	setne  %al
c0006f2c:	0f b6 c0             	movzbl %al,%eax
c0006f2f:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:360

	if (searched_record.file_type == FT_DIRECTORY) {
c0006f32:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0006f35:	83 f8 02             	cmp    $0x2,%eax
c0006f38:	75 29                	jne    c0006f63 <sys_open+0xf9>
/work/x86_os_my/fs/fs.c:361
		printk("can`t open a direcotry with open(), use opendir() to instead\n");
c0006f3a:	83 ec 0c             	sub    $0xc,%esp
c0006f3d:	68 84 c3 00 c0       	push   $0xc000c384
c0006f42:	e8 08 f5 ff ff       	call   c000644f <printk>
c0006f47:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:362
		dir_close(searched_record.parent_dir);	//主调函数负责关闭该目录
c0006f4a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0006f4d:	83 ec 0c             	sub    $0xc,%esp
c0006f50:	50                   	push   %eax
c0006f51:	e8 d2 2f 00 00       	call   c0009f28 <dir_close>
c0006f56:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:363
		return -1;
c0006f59:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0006f5e:	e9 64 01 00 00       	jmp    c00070c7 <sys_open+0x25d>
/work/x86_os_my/fs/fs.c:366
	}

	uint32_t path_searched_depth = path_depth_cnt(searched_record.searched_path);
c0006f63:	83 ec 0c             	sub    $0xc,%esp
c0006f66:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c0006f6c:	50                   	push   %eax
c0006f6d:	e8 ee fb ff ff       	call   c0006b60 <path_depth_cnt>
c0006f72:	83 c4 10             	add    $0x10,%esp
c0006f75:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/fs.c:370

	/* 先判断是否把pathname的各层目录都访问到了 */
	// 【search_file情况1】说明并没有访问到全部的路径,某个中间目录是不存在的【是一个同名的普通文件】
	if (pathname_depth != path_searched_depth) {
c0006f78:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0006f7b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0006f7e:	74 33                	je     c0006fb3 <sys_open+0x149>
/work/x86_os_my/fs/fs.c:371
		printk("cannot access %s: Not a directory, subpath %s is`t exist\n",
c0006f80:	83 ec 04             	sub    $0x4,%esp
c0006f83:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c0006f89:	50                   	push   %eax
c0006f8a:	ff 75 08             	pushl  0x8(%ebp)
c0006f8d:	68 c4 c3 00 c0       	push   $0xc000c3c4
c0006f92:	e8 b8 f4 ff ff       	call   c000644f <printk>
c0006f97:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:373
			pathname, searched_record.searched_path);
		dir_close(searched_record.parent_dir);
c0006f9a:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0006f9d:	83 ec 0c             	sub    $0xc,%esp
c0006fa0:	50                   	push   %eax
c0006fa1:	e8 82 2f 00 00       	call   c0009f28 <dir_close>
c0006fa6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:374
		return -1;
c0006fa9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0006fae:	e9 14 01 00 00       	jmp    c00070c7 <sys_open+0x25d>
/work/x86_os_my/fs/fs.c:379
	}

	// 【search_file情况2】若是在最后一个路径上没找到
	// 并且此时也不是要创建文件,直接返回-1 */
	if (!found && !(flags & O_CREAT)) {
c0006fb3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0006fb7:	75 56                	jne    c000700f <sys_open+0x1a5>
/work/x86_os_my/fs/fs.c:379 (discriminator 1)
c0006fb9:	0f b6 85 d4 fd ff ff 	movzbl -0x22c(%ebp),%eax
c0006fc0:	83 e0 04             	and    $0x4,%eax
c0006fc3:	85 c0                	test   %eax,%eax
c0006fc5:	75 48                	jne    c000700f <sys_open+0x1a5>
/work/x86_os_my/fs/fs.c:381
		printk("in path %s, file %s is`t exist\n",
			searched_record.searched_path, (strrchr(searched_record.searched_path, '/') + 1));
c0006fc7:	83 ec 08             	sub    $0x8,%esp
c0006fca:	6a 2f                	push   $0x2f
c0006fcc:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c0006fd2:	50                   	push   %eax
c0006fd3:	e8 52 ca ff ff       	call   c0003a2a <strrchr>
c0006fd8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:380
	}

	// 【search_file情况2】若是在最后一个路径上没找到
	// 并且此时也不是要创建文件,直接返回-1 */
	if (!found && !(flags & O_CREAT)) {
		printk("in path %s, file %s is`t exist\n",
c0006fdb:	83 c0 01             	add    $0x1,%eax
c0006fde:	83 ec 04             	sub    $0x4,%esp
c0006fe1:	50                   	push   %eax
c0006fe2:	8d 85 dc fd ff ff    	lea    -0x224(%ebp),%eax
c0006fe8:	50                   	push   %eax
c0006fe9:	68 00 c4 00 c0       	push   $0xc000c400
c0006fee:	e8 5c f4 ff ff       	call   c000644f <printk>
c0006ff3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:382
			searched_record.searched_path, (strrchr(searched_record.searched_path, '/') + 1));
		dir_close(searched_record.parent_dir);
c0006ff6:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0006ff9:	83 ec 0c             	sub    $0xc,%esp
c0006ffc:	50                   	push   %eax
c0006ffd:	e8 26 2f 00 00       	call   c0009f28 <dir_close>
c0007002:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:383
		return -1;
c0007005:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000700a:	e9 b8 00 00 00       	jmp    c00070c7 <sys_open+0x25d>
/work/x86_os_my/fs/fs.c:384
	} else if (found && flags & O_CREAT) {	// 若要创建的文件已存在，相同目录下不可以有同名文件，返回-1
c000700f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0007013:	74 37                	je     c000704c <sys_open+0x1e2>
/work/x86_os_my/fs/fs.c:384 (discriminator 1)
c0007015:	0f b6 85 d4 fd ff ff 	movzbl -0x22c(%ebp),%eax
c000701c:	83 e0 04             	and    $0x4,%eax
c000701f:	85 c0                	test   %eax,%eax
c0007021:	74 29                	je     c000704c <sys_open+0x1e2>
/work/x86_os_my/fs/fs.c:385
		printk("%s has already exist!\n", pathname);
c0007023:	83 ec 08             	sub    $0x8,%esp
c0007026:	ff 75 08             	pushl  0x8(%ebp)
c0007029:	68 20 c4 00 c0       	push   $0xc000c420
c000702e:	e8 1c f4 ff ff       	call   c000644f <printk>
c0007033:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:386
		dir_close(searched_record.parent_dir);
c0007036:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0007039:	83 ec 0c             	sub    $0xc,%esp
c000703c:	50                   	push   %eax
c000703d:	e8 e6 2e 00 00       	call   c0009f28 <dir_close>
c0007042:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:387
		return -1;
c0007045:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000704a:	eb 7b                	jmp    c00070c7 <sys_open+0x25d>
/work/x86_os_my/fs/fs.c:390
	}

	switch (flags & O_CREAT) {	// sys_open("xxx", O_CREAT|O_XXX)
c000704c:	0f b6 85 d4 fd ff ff 	movzbl -0x22c(%ebp),%eax
c0007053:	83 e0 04             	and    $0x4,%eax
c0007056:	83 f8 04             	cmp    $0x4,%eax
c0007059:	75 4f                	jne    c00070aa <sys_open+0x240>
/work/x86_os_my/fs/fs.c:392
		case O_CREAT:
		printk("creating file\n");
c000705b:	83 ec 0c             	sub    $0xc,%esp
c000705e:	68 37 c4 00 c0       	push   $0xc000c437
c0007063:	e8 e7 f3 ff ff       	call   c000644f <printk>
c0007068:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:394
		// 【search_file情况3】主调函数用到此目录，在该目录下创建文件
		fd = file_create(searched_record.parent_dir, (strrchr(pathname, '/') + 1), flags);
c000706b:	0f b6 9d d4 fd ff ff 	movzbl -0x22c(%ebp),%ebx
c0007072:	83 ec 08             	sub    $0x8,%esp
c0007075:	6a 2f                	push   $0x2f
c0007077:	ff 75 08             	pushl  0x8(%ebp)
c000707a:	e8 ab c9 ff ff       	call   c0003a2a <strrchr>
c000707f:	83 c4 10             	add    $0x10,%esp
c0007082:	8d 50 01             	lea    0x1(%eax),%edx
c0007085:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0007088:	83 ec 04             	sub    $0x4,%esp
c000708b:	53                   	push   %ebx
c000708c:	52                   	push   %edx
c000708d:	50                   	push   %eax
c000708e:	e8 f2 1c 00 00       	call   c0008d85 <file_create>
c0007093:	83 c4 10             	add    $0x10,%esp
c0007096:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:395
		dir_close(searched_record.parent_dir);
c0007099:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000709c:	83 ec 0c             	sub    $0xc,%esp
c000709f:	50                   	push   %eax
c00070a0:	e8 83 2e 00 00       	call   c0009f28 <dir_close>
c00070a5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:396
		break;
c00070a8:	eb 1a                	jmp    c00070c4 <sys_open+0x25a>
/work/x86_os_my/fs/fs.c:400

		default:
		/* 其余情况均为打开已存在文件: O_RDONLY,O_WRONLY,O_RDWR */
		fd = file_open(inode_no, flags);
c00070aa:	0f b6 95 d4 fd ff ff 	movzbl -0x22c(%ebp),%edx
c00070b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00070b4:	83 ec 08             	sub    $0x8,%esp
c00070b7:	52                   	push   %edx
c00070b8:	50                   	push   %eax
c00070b9:	e8 89 1f 00 00       	call   c0009047 <file_open>
c00070be:	83 c4 10             	add    $0x10,%esp
c00070c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:405
	}

	/* 此fd是指任务pcb->fd_table数组中的元素下标,
	 * 并不是指全局file_table中的下标 */
	return fd;
c00070c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:406 (discriminator 1)
}
c00070c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00070ca:	c9                   	leave  
c00070cb:	c3                   	ret    

c00070cc <fd_local2global>:
fd_local2global():
/work/x86_os_my/fs/fs.c:409

/* 将文件描述符转化为文件表的下标 */
static uint32_t fd_local2global(uint32_t local_fd) {
c00070cc:	55                   	push   %ebp
c00070cd:	89 e5                	mov    %esp,%ebp
c00070cf:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/fs.c:410
	struct task_struct* cur = running_thread();
c00070d2:	e8 94 ca ff ff       	call   c0003b6b <running_thread>
c00070d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:411
	int32_t global_fd = cur->fd_table[local_fd];
c00070da:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00070dd:	8b 55 08             	mov    0x8(%ebp),%edx
c00070e0:	83 c2 08             	add    $0x8,%edx
c00070e3:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
c00070e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:412
	ASSERT(global_fd >= 0 && global_fd < MAX_FILE_OPEN);
c00070ea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c00070ee:	78 06                	js     c00070f6 <fd_local2global+0x2a>
/work/x86_os_my/fs/fs.c:412 (discriminator 1)
c00070f0:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
c00070f4:	7e 1c                	jle    c0007112 <fd_local2global+0x46>
/work/x86_os_my/fs/fs.c:412 (discriminator 3)
c00070f6:	68 48 c4 00 c0       	push   $0xc000c448
c00070fb:	68 64 c9 00 c0       	push   $0xc000c964
c0007100:	68 9c 01 00 00       	push   $0x19c
c0007105:	68 6d c1 00 c0       	push   $0xc000c16d
c000710a:	e8 d3 b1 ff ff       	call   c00022e2 <panic_spin>
c000710f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:413
	return (uint32_t)global_fd;
c0007112:	8b 45 f0             	mov    -0x10(%ebp),%eax
/work/x86_os_my/fs/fs.c:414
}
c0007115:	c9                   	leave  
c0007116:	c3                   	ret    

c0007117 <sys_close>:
sys_close():
/work/x86_os_my/fs/fs.c:417

/* 关闭文件描述符fd指向的文件,成功返回0,否则返回-1 */
int32_t sys_close(int32_t fd) {
c0007117:	55                   	push   %ebp
c0007118:	89 e5                	mov    %esp,%ebp
c000711a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/fs.c:418
	int32_t ret = -1;   // 返回值默认为-1,即失败
c000711d:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:419
	if (fd > 2) {
c0007124:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0007128:	7e 47                	jle    c0007171 <sys_close+0x5a>
/work/x86_os_my/fs/fs.c:420
		uint32_t _fd = fd_local2global(fd);
c000712a:	8b 45 08             	mov    0x8(%ebp),%eax
c000712d:	83 ec 0c             	sub    $0xc,%esp
c0007130:	50                   	push   %eax
c0007131:	e8 96 ff ff ff       	call   c00070cc <fd_local2global>
c0007136:	83 c4 10             	add    $0x10,%esp
c0007139:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:421
		ret = file_close(&file_table[_fd]);
c000713c:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000713f:	89 d0                	mov    %edx,%eax
c0007141:	01 c0                	add    %eax,%eax
c0007143:	01 d0                	add    %edx,%eax
c0007145:	c1 e0 02             	shl    $0x2,%eax
c0007148:	05 e0 09 01 c0       	add    $0xc00109e0,%eax
c000714d:	83 ec 0c             	sub    $0xc,%esp
c0007150:	50                   	push   %eax
c0007151:	e8 0a 20 00 00       	call   c0009160 <file_close>
c0007156:	83 c4 10             	add    $0x10,%esp
c0007159:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:422
		running_thread()->fd_table[fd] = -1; // 使该文件描述符位可用
c000715c:	e8 0a ca ff ff       	call   c0003b6b <running_thread>
c0007161:	89 c2                	mov    %eax,%edx
c0007163:	8b 45 08             	mov    0x8(%ebp),%eax
c0007166:	83 c0 08             	add    $0x8,%eax
c0007169:	c7 44 82 04 ff ff ff 	movl   $0xffffffff,0x4(%edx,%eax,4)
c0007170:	ff 
/work/x86_os_my/fs/fs.c:424
	}
	return ret;
c0007171:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:425
}
c0007174:	c9                   	leave  
c0007175:	c3                   	ret    

c0007176 <sys_write>:
sys_write():
/work/x86_os_my/fs/fs.c:428

/* 将buf中连续count个字节写入文件描述符fd,成功则返回写入的字节数,失败返回-1 */
int32_t sys_write(int32_t fd, const void* buf, uint32_t count) {
c0007176:	55                   	push   %ebp
c0007177:	89 e5                	mov    %esp,%ebp
c0007179:	57                   	push   %edi
c000717a:	81 ec 14 04 00 00    	sub    $0x414,%esp
/work/x86_os_my/fs/fs.c:429
   if (fd < 0) {
c0007180:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0007184:	79 1a                	jns    c00071a0 <sys_write+0x2a>
/work/x86_os_my/fs/fs.c:430
      printk("sys_write: fd error\n");
c0007186:	83 ec 0c             	sub    $0xc,%esp
c0007189:	68 74 c4 00 c0       	push   $0xc000c474
c000718e:	e8 bc f2 ff ff       	call   c000644f <printk>
c0007193:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:431
      return -1;
c0007196:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000719b:	e9 ba 00 00 00       	jmp    c000725a <sys_write+0xe4>
/work/x86_os_my/fs/fs.c:433
   }
   if (fd == stdout_no) {
c00071a0:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c00071a4:	75 43                	jne    c00071e9 <sys_write+0x73>
/work/x86_os_my/fs/fs.c:434
      char tmp_buf[1024] = {0};
c00071a6:	8d 95 ec fb ff ff    	lea    -0x414(%ebp),%edx
c00071ac:	b8 00 00 00 00       	mov    $0x0,%eax
c00071b1:	b9 00 01 00 00       	mov    $0x100,%ecx
c00071b6:	89 d7                	mov    %edx,%edi
c00071b8:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/fs/fs.c:435
      memcpy(tmp_buf, buf, count);
c00071ba:	83 ec 04             	sub    $0x4,%esp
c00071bd:	ff 75 10             	pushl  0x10(%ebp)
c00071c0:	ff 75 0c             	pushl  0xc(%ebp)
c00071c3:	8d 85 ec fb ff ff    	lea    -0x414(%ebp),%eax
c00071c9:	50                   	push   %eax
c00071ca:	e8 07 c6 ff ff       	call   c00037d6 <memcpy>
c00071cf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:436
      console_put_str(tmp_buf);
c00071d2:	83 ec 0c             	sub    $0xc,%esp
c00071d5:	8d 85 ec fb ff ff    	lea    -0x414(%ebp),%eax
c00071db:	50                   	push   %eax
c00071dc:	e8 ef d2 ff ff       	call   c00044d0 <console_put_str>
c00071e1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:437
      return count;
c00071e4:	8b 45 10             	mov    0x10(%ebp),%eax
c00071e7:	eb 71                	jmp    c000725a <sys_write+0xe4>
/work/x86_os_my/fs/fs.c:439
   }
   uint32_t _fd = fd_local2global(fd);
c00071e9:	8b 45 08             	mov    0x8(%ebp),%eax
c00071ec:	83 ec 0c             	sub    $0xc,%esp
c00071ef:	50                   	push   %eax
c00071f0:	e8 d7 fe ff ff       	call   c00070cc <fd_local2global>
c00071f5:	83 c4 10             	add    $0x10,%esp
c00071f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:440
   struct file* wr_file = &file_table[_fd];
c00071fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00071fe:	89 d0                	mov    %edx,%eax
c0007200:	01 c0                	add    %eax,%eax
c0007202:	01 d0                	add    %edx,%eax
c0007204:	c1 e0 02             	shl    $0x2,%eax
c0007207:	05 e0 09 01 c0       	add    $0xc00109e0,%eax
c000720c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:441
   if (wr_file->fd_flag & O_WRONLY || wr_file->fd_flag & O_RDWR) {
c000720f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0007212:	8b 40 04             	mov    0x4(%eax),%eax
c0007215:	83 e0 01             	and    $0x1,%eax
c0007218:	85 c0                	test   %eax,%eax
c000721a:	75 0d                	jne    c0007229 <sys_write+0xb3>
/work/x86_os_my/fs/fs.c:441 (discriminator 1)
c000721c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000721f:	8b 40 04             	mov    0x4(%eax),%eax
c0007222:	83 e0 02             	and    $0x2,%eax
c0007225:	85 c0                	test   %eax,%eax
c0007227:	74 1c                	je     c0007245 <sys_write+0xcf>
/work/x86_os_my/fs/fs.c:442
      uint32_t bytes_written  = file_write(wr_file, buf, count);
c0007229:	83 ec 04             	sub    $0x4,%esp
c000722c:	ff 75 10             	pushl  0x10(%ebp)
c000722f:	ff 75 0c             	pushl  0xc(%ebp)
c0007232:	ff 75 f0             	pushl  -0x10(%ebp)
c0007235:	e8 69 1f 00 00       	call   c00091a3 <file_write>
c000723a:	83 c4 10             	add    $0x10,%esp
c000723d:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:443
      return bytes_written;
c0007240:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0007243:	eb 15                	jmp    c000725a <sys_write+0xe4>
/work/x86_os_my/fs/fs.c:445
   } else {
      console_put_str("sys_write: not allowed to write file without flag O_RDWR or O_WRONLY\n");
c0007245:	83 ec 0c             	sub    $0xc,%esp
c0007248:	68 8c c4 00 c0       	push   $0xc000c48c
c000724d:	e8 7e d2 ff ff       	call   c00044d0 <console_put_str>
c0007252:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:446
      return -1;
c0007255:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/fs/fs.c:448 (discriminator 1)
   }
}
c000725a:	8b 7d fc             	mov    -0x4(%ebp),%edi
c000725d:	c9                   	leave  
c000725e:	c3                   	ret    

c000725f <sys_read>:
sys_read():
/work/x86_os_my/fs/fs.c:451

/* 从文件描述符fd指向的文件中读取count个字节到buf,若成功则返回读出的字节数,到文件尾则返回-1 */
int32_t sys_read(int32_t fd, void* buf, uint32_t count) {
c000725f:	55                   	push   %ebp
c0007260:	89 e5                	mov    %esp,%ebp
c0007262:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/fs.c:452
	if (fd < 0) {
c0007265:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0007269:	79 17                	jns    c0007282 <sys_read+0x23>
/work/x86_os_my/fs/fs.c:453
		printk("sys_read: fd error\n");
c000726b:	83 ec 0c             	sub    $0xc,%esp
c000726e:	68 d2 c4 00 c0       	push   $0xc000c4d2
c0007273:	e8 d7 f1 ff ff       	call   c000644f <printk>
c0007278:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:454
		return -1;
c000727b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007280:	eb 57                	jmp    c00072d9 <sys_read+0x7a>
/work/x86_os_my/fs/fs.c:456
	}
	ASSERT(buf != NULL);
c0007282:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0007286:	75 1c                	jne    c00072a4 <sys_read+0x45>
/work/x86_os_my/fs/fs.c:456 (discriminator 1)
c0007288:	68 e6 c4 00 c0       	push   $0xc000c4e6
c000728d:	68 74 c9 00 c0       	push   $0xc000c974
c0007292:	68 c8 01 00 00       	push   $0x1c8
c0007297:	68 6d c1 00 c0       	push   $0xc000c16d
c000729c:	e8 41 b0 ff ff       	call   c00022e2 <panic_spin>
c00072a1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:457
	uint32_t _fd = fd_local2global(fd);
c00072a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00072a7:	83 ec 0c             	sub    $0xc,%esp
c00072aa:	50                   	push   %eax
c00072ab:	e8 1c fe ff ff       	call   c00070cc <fd_local2global>
c00072b0:	83 c4 10             	add    $0x10,%esp
c00072b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:458
	return file_read(&file_table[_fd], buf, count);
c00072b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00072b9:	89 d0                	mov    %edx,%eax
c00072bb:	01 c0                	add    %eax,%eax
c00072bd:	01 d0                	add    %edx,%eax
c00072bf:	c1 e0 02             	shl    $0x2,%eax
c00072c2:	05 e0 09 01 c0       	add    $0xc00109e0,%eax
c00072c7:	83 ec 04             	sub    $0x4,%esp
c00072ca:	ff 75 10             	pushl  0x10(%ebp)
c00072cd:	ff 75 0c             	pushl  0xc(%ebp)
c00072d0:	50                   	push   %eax
c00072d1:	e8 61 26 00 00       	call   c0009937 <file_read>
c00072d6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:459
}
c00072d9:	c9                   	leave  
c00072da:	c3                   	ret    

c00072db <sys_lseek>:
sys_lseek():
/work/x86_os_my/fs/fs.c:462

/* 重置用于文件读写指针,成功时返回新的偏移量,出错时返回-1 */
int32_t sys_lseek(int32_t fd, int32_t offset, uint8_t whence) {
c00072db:	55                   	push   %ebp
c00072dc:	89 e5                	mov    %esp,%ebp
c00072de:	83 ec 28             	sub    $0x28,%esp
c00072e1:	8b 45 10             	mov    0x10(%ebp),%eax
c00072e4:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/fs/fs.c:463
	if (fd < 0) {
c00072e7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00072eb:	79 1a                	jns    c0007307 <sys_lseek+0x2c>
/work/x86_os_my/fs/fs.c:464
		printk("sys_lseek: fd error\n");
c00072ed:	83 ec 0c             	sub    $0xc,%esp
c00072f0:	68 f2 c4 00 c0       	push   $0xc000c4f2
c00072f5:	e8 55 f1 ff ff       	call   c000644f <printk>
c00072fa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:465
		return -1;
c00072fd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007302:	e9 bd 00 00 00       	jmp    c00073c4 <sys_lseek+0xe9>
/work/x86_os_my/fs/fs.c:467
	}
	ASSERT(whence > 0 && whence < 4);
c0007307:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
c000730b:	74 06                	je     c0007313 <sys_lseek+0x38>
/work/x86_os_my/fs/fs.c:467 (discriminator 1)
c000730d:	80 7d e4 03          	cmpb   $0x3,-0x1c(%ebp)
c0007311:	76 1c                	jbe    c000732f <sys_lseek+0x54>
/work/x86_os_my/fs/fs.c:467 (discriminator 3)
c0007313:	68 07 c5 00 c0       	push   $0xc000c507
c0007318:	68 80 c9 00 c0       	push   $0xc000c980
c000731d:	68 d3 01 00 00       	push   $0x1d3
c0007322:	68 6d c1 00 c0       	push   $0xc000c16d
c0007327:	e8 b6 af ff ff       	call   c00022e2 <panic_spin>
c000732c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:468
	uint32_t _fd = fd_local2global(fd);
c000732f:	8b 45 08             	mov    0x8(%ebp),%eax
c0007332:	83 ec 0c             	sub    $0xc,%esp
c0007335:	50                   	push   %eax
c0007336:	e8 91 fd ff ff       	call   c00070cc <fd_local2global>
c000733b:	83 c4 10             	add    $0x10,%esp
c000733e:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:469
	struct file* pf = &file_table[_fd];
c0007341:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007344:	89 d0                	mov    %edx,%eax
c0007346:	01 c0                	add    %eax,%eax
c0007348:	01 d0                	add    %edx,%eax
c000734a:	c1 e0 02             	shl    $0x2,%eax
c000734d:	05 e0 09 01 c0       	add    $0xc00109e0,%eax
c0007352:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:470
	int32_t new_pos = 0;	//新的偏移量必须位于文件大小之内
c0007355:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:471
	int32_t file_size = (int32_t)pf->fd_inode->i_size;
c000735c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000735f:	8b 40 08             	mov    0x8(%eax),%eax
c0007362:	8b 40 04             	mov    0x4(%eax),%eax
c0007365:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:472
	switch (whence) {
c0007368:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c000736c:	83 f8 02             	cmp    $0x2,%eax
c000736f:	74 12                	je     c0007383 <sys_lseek+0xa8>
c0007371:	83 f8 03             	cmp    $0x3,%eax
c0007374:	74 1e                	je     c0007394 <sys_lseek+0xb9>
c0007376:	83 f8 01             	cmp    $0x1,%eax
c0007379:	75 24                	jne    c000739f <sys_lseek+0xc4>
/work/x86_os_my/fs/fs.c:475
		/* SEEK_SET 新的读写位置是相对于文件开头再增加offset个位移量 */
		case SEEK_SET:
		new_pos = offset;
c000737b:	8b 45 0c             	mov    0xc(%ebp),%eax
c000737e:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:476
		break;
c0007381:	eb 1c                	jmp    c000739f <sys_lseek+0xc4>
/work/x86_os_my/fs/fs.c:480

		/* SEEK_CUR 新的读写位置是相对于当前的位置增加offset个位移量 */
		case SEEK_CUR:	// offse可正可负
		new_pos = (int32_t)pf->fd_pos + offset;
c0007383:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0007386:	8b 00                	mov    (%eax),%eax
c0007388:	89 c2                	mov    %eax,%edx
c000738a:	8b 45 0c             	mov    0xc(%ebp),%eax
c000738d:	01 d0                	add    %edx,%eax
c000738f:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:481
		break;
c0007392:	eb 0b                	jmp    c000739f <sys_lseek+0xc4>
/work/x86_os_my/fs/fs.c:485

		/* SEEK_END 新的读写位置是相对于文件尺寸再增加offset个位移量 */
		case SEEK_END:	// 此情况下,offset应该为负值
		new_pos = file_size + offset;
c0007394:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0007397:	8b 45 0c             	mov    0xc(%ebp),%eax
c000739a:	01 d0                	add    %edx,%eax
c000739c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:487
	}
	if (new_pos < 0 || new_pos > (file_size - 1)) {
c000739f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00073a3:	78 0b                	js     c00073b0 <sys_lseek+0xd5>
/work/x86_os_my/fs/fs.c:487 (discriminator 1)
c00073a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00073a8:	83 e8 01             	sub    $0x1,%eax
c00073ab:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00073ae:	7d 07                	jge    c00073b7 <sys_lseek+0xdc>
/work/x86_os_my/fs/fs.c:488
		return -1;
c00073b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00073b5:	eb 0d                	jmp    c00073c4 <sys_lseek+0xe9>
/work/x86_os_my/fs/fs.c:490
	}
	pf->fd_pos = new_pos;
c00073b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00073ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00073bd:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/fs.c:491
	return pf->fd_pos;
c00073bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00073c2:	8b 00                	mov    (%eax),%eax
/work/x86_os_my/fs/fs.c:492
}
c00073c4:	c9                   	leave  
c00073c5:	c3                   	ret    

c00073c6 <sys_unlink>:
sys_unlink():
/work/x86_os_my/fs/fs.c:496

/* 删除文件(非目录),成功返回0,失败返回-1 */
// 全局变量 file_table 定义在 file.h
int32_t sys_unlink(const char* pathname) {
c00073c6:	55                   	push   %ebp
c00073c7:	89 e5                	mov    %esp,%ebp
c00073c9:	81 ec 28 02 00 00    	sub    $0x228,%esp
/work/x86_os_my/fs/fs.c:497
	ASSERT(strlen(pathname) < MAX_PATH_LEN);
c00073cf:	83 ec 0c             	sub    $0xc,%esp
c00073d2:	ff 75 08             	pushl  0x8(%ebp)
c00073d5:	e8 34 c5 ff ff       	call   c000390e <strlen>
c00073da:	83 c4 10             	add    $0x10,%esp
c00073dd:	3d ff 01 00 00       	cmp    $0x1ff,%eax
c00073e2:	76 1c                	jbe    c0007400 <sys_unlink+0x3a>
/work/x86_os_my/fs/fs.c:497 (discriminator 1)
c00073e4:	68 20 c5 00 c0       	push   $0xc000c520
c00073e9:	68 8c c9 00 c0       	push   $0xc000c98c
c00073ee:	68 f1 01 00 00       	push   $0x1f1
c00073f3:	68 6d c1 00 c0       	push   $0xc000c16d
c00073f8:	e8 e5 ae ff ff       	call   c00022e2 <panic_spin>
c00073fd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:501

	/* 先检查待删除的文件是否存在 */
	struct path_search_record searched_record;
	memset(&searched_record, 0, sizeof(struct path_search_record));
c0007400:	83 ec 04             	sub    $0x4,%esp
c0007403:	68 08 02 00 00       	push   $0x208
c0007408:	6a 00                	push   $0x0
c000740a:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
c0007410:	50                   	push   %eax
c0007411:	e8 6e c3 ff ff       	call   c0003784 <memset>
c0007416:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:502
	int inode_no = search_file(pathname, &searched_record);
c0007419:	83 ec 08             	sub    $0x8,%esp
c000741c:	8d 85 e0 fd ff ff    	lea    -0x220(%ebp),%eax
c0007422:	50                   	push   %eax
c0007423:	ff 75 08             	pushl  0x8(%ebp)
c0007426:	e8 c0 f7 ff ff       	call   c0006beb <search_file>
c000742b:	83 c4 10             	add    $0x10,%esp
c000742e:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:503
	ASSERT(inode_no != 0);
c0007431:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0007435:	75 1c                	jne    c0007453 <sys_unlink+0x8d>
/work/x86_os_my/fs/fs.c:503 (discriminator 1)
c0007437:	68 40 c5 00 c0       	push   $0xc000c540
c000743c:	68 8c c9 00 c0       	push   $0xc000c98c
c0007441:	68 f7 01 00 00       	push   $0x1f7
c0007446:	68 6d c1 00 c0       	push   $0xc000c16d
c000744b:	e8 92 ae ff ff       	call   c00022e2 <panic_spin>
c0007450:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:504
	if (inode_no == -1) {
c0007453:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0007457:	75 2c                	jne    c0007485 <sys_unlink+0xbf>
/work/x86_os_my/fs/fs.c:505
		printk("file %s not found!\n", pathname);
c0007459:	83 ec 08             	sub    $0x8,%esp
c000745c:	ff 75 08             	pushl  0x8(%ebp)
c000745f:	68 4e c5 00 c0       	push   $0xc000c54e
c0007464:	e8 e6 ef ff ff       	call   c000644f <printk>
c0007469:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:506
		dir_close(searched_record.parent_dir);
c000746c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000746f:	83 ec 0c             	sub    $0xc,%esp
c0007472:	50                   	push   %eax
c0007473:	e8 b0 2a 00 00       	call   c0009f28 <dir_close>
c0007478:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:507
		return -1;
c000747b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007480:	e9 62 01 00 00       	jmp    c00075e7 <sys_unlink+0x221>
/work/x86_os_my/fs/fs.c:509
	}
	if (searched_record.file_type == FT_DIRECTORY) {	//存在同名的目录，而不是文件
c0007485:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0007488:	83 f8 02             	cmp    $0x2,%eax
c000748b:	75 29                	jne    c00074b6 <sys_unlink+0xf0>
/work/x86_os_my/fs/fs.c:510
		printk("can`t delete a direcotry with unlink(), use rmdir() to instead\n");
c000748d:	83 ec 0c             	sub    $0xc,%esp
c0007490:	68 64 c5 00 c0       	push   $0xc000c564
c0007495:	e8 b5 ef ff ff       	call   c000644f <printk>
c000749a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:511
		dir_close(searched_record.parent_dir);
c000749d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00074a0:	83 ec 0c             	sub    $0xc,%esp
c00074a3:	50                   	push   %eax
c00074a4:	e8 7f 2a 00 00       	call   c0009f28 <dir_close>
c00074a9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:512
		return -1;
c00074ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00074b1:	e9 31 01 00 00       	jmp    c00075e7 <sys_unlink+0x221>
/work/x86_os_my/fs/fs.c:516
	}

	/* 检查是否在已打开文件列表(文件表)中 */
	uint32_t file_idx = 0;
c00074b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:517
	while (file_idx < MAX_FILE_OPEN) {
c00074bd:	eb 37                	jmp    c00074f6 <sys_unlink+0x130>
/work/x86_os_my/fs/fs.c:518
		if (file_table[file_idx].fd_inode != NULL && (uint32_t)inode_no == file_table[file_idx].fd_inode->i_no) {
c00074bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00074c2:	89 d0                	mov    %edx,%eax
c00074c4:	01 c0                	add    %eax,%eax
c00074c6:	01 d0                	add    %edx,%eax
c00074c8:	c1 e0 02             	shl    $0x2,%eax
c00074cb:	05 e8 09 01 c0       	add    $0xc00109e8,%eax
c00074d0:	8b 00                	mov    (%eax),%eax
c00074d2:	85 c0                	test   %eax,%eax
c00074d4:	74 1c                	je     c00074f2 <sys_unlink+0x12c>
/work/x86_os_my/fs/fs.c:518 (discriminator 1)
c00074d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00074d9:	89 d0                	mov    %edx,%eax
c00074db:	01 c0                	add    %eax,%eax
c00074dd:	01 d0                	add    %edx,%eax
c00074df:	c1 e0 02             	shl    $0x2,%eax
c00074e2:	05 e8 09 01 c0       	add    $0xc00109e8,%eax
c00074e7:	8b 00                	mov    (%eax),%eax
c00074e9:	8b 10                	mov    (%eax),%edx
c00074eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00074ee:	39 c2                	cmp    %eax,%edx
c00074f0:	74 0c                	je     c00074fe <sys_unlink+0x138>
/work/x86_os_my/fs/fs.c:521
			break;
		}
		file_idx++;
c00074f2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:517
		return -1;
	}

	/* 检查是否在已打开文件列表(文件表)中 */
	uint32_t file_idx = 0;
	while (file_idx < MAX_FILE_OPEN) {
c00074f6:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
c00074fa:	76 c3                	jbe    c00074bf <sys_unlink+0xf9>
c00074fc:	eb 01                	jmp    c00074ff <sys_unlink+0x139>
/work/x86_os_my/fs/fs.c:519
		if (file_table[file_idx].fd_inode != NULL && (uint32_t)inode_no == file_table[file_idx].fd_inode->i_no) {
			break;
c00074fe:	90                   	nop
/work/x86_os_my/fs/fs.c:523
		}
		file_idx++;
	}
	if (file_idx < MAX_FILE_OPEN) {
c00074ff:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
c0007503:	77 2c                	ja     c0007531 <sys_unlink+0x16b>
/work/x86_os_my/fs/fs.c:524
		dir_close(searched_record.parent_dir);
c0007505:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0007508:	83 ec 0c             	sub    $0xc,%esp
c000750b:	50                   	push   %eax
c000750c:	e8 17 2a 00 00       	call   c0009f28 <dir_close>
c0007511:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:525
		printk("file %s is in use, not allow to delete!\n", pathname);
c0007514:	83 ec 08             	sub    $0x8,%esp
c0007517:	ff 75 08             	pushl  0x8(%ebp)
c000751a:	68 a4 c5 00 c0       	push   $0xc000c5a4
c000751f:	e8 2b ef ff ff       	call   c000644f <printk>
c0007524:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:526
		return -1;
c0007527:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000752c:	e9 b6 00 00 00       	jmp    c00075e7 <sys_unlink+0x221>
/work/x86_os_my/fs/fs.c:528
	}
	ASSERT(file_idx == MAX_FILE_OPEN);
c0007531:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
c0007535:	74 1c                	je     c0007553 <sys_unlink+0x18d>
/work/x86_os_my/fs/fs.c:528 (discriminator 1)
c0007537:	68 cd c5 00 c0       	push   $0xc000c5cd
c000753c:	68 8c c9 00 c0       	push   $0xc000c98c
c0007541:	68 10 02 00 00       	push   $0x210
c0007546:	68 6d c1 00 c0       	push   $0xc000c16d
c000754b:	e8 92 ad ff ff       	call   c00022e2 <panic_spin>
c0007550:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:531

	/* 为delete_dir_entry申请缓冲区 */
	void* io_buf = sys_malloc(SECTOR_SIZE + SECTOR_SIZE);
c0007553:	83 ec 0c             	sub    $0xc,%esp
c0007556:	68 00 04 00 00       	push   $0x400
c000755b:	e8 2d b7 ff ff       	call   c0002c8d <sys_malloc>
c0007560:	83 c4 10             	add    $0x10,%esp
c0007563:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:532
	if (io_buf == NULL) {
c0007566:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c000756a:	75 26                	jne    c0007592 <sys_unlink+0x1cc>
/work/x86_os_my/fs/fs.c:533
		dir_close(searched_record.parent_dir);
c000756c:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000756f:	83 ec 0c             	sub    $0xc,%esp
c0007572:	50                   	push   %eax
c0007573:	e8 b0 29 00 00       	call   c0009f28 <dir_close>
c0007578:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:534
		printk("sys_unlink: malloc for io_buf failed\n");
c000757b:	83 ec 0c             	sub    $0xc,%esp
c000757e:	68 e8 c5 00 c0       	push   $0xc000c5e8
c0007583:	e8 c7 ee ff ff       	call   c000644f <printk>
c0007588:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:535
		return -1;
c000758b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007590:	eb 55                	jmp    c00075e7 <sys_unlink+0x221>
/work/x86_os_my/fs/fs.c:538
	}

	struct dir* parent_dir = searched_record.parent_dir;
c0007592:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0007595:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:539
	delete_dir_entry(cur_part, parent_dir, inode_no, io_buf);	// 删除目录项 dir.c
c0007598:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000759b:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00075a0:	ff 75 ec             	pushl  -0x14(%ebp)
c00075a3:	52                   	push   %edx
c00075a4:	ff 75 e8             	pushl  -0x18(%ebp)
c00075a7:	50                   	push   %eax
c00075a8:	e8 3a 2e 00 00       	call   c000a3e7 <delete_dir_entry>
c00075ad:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:540
	inode_release(cur_part, inode_no);							// 删除inode inode.c
c00075b0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00075b3:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00075b8:	83 ec 08             	sub    $0x8,%esp
c00075bb:	52                   	push   %edx
c00075bc:	50                   	push   %eax
c00075bd:	e8 51 13 00 00       	call   c0008913 <inode_release>
c00075c2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:541
	sys_free(io_buf);
c00075c5:	83 ec 0c             	sub    $0xc,%esp
c00075c8:	ff 75 ec             	pushl  -0x14(%ebp)
c00075cb:	e8 ea bc ff ff       	call   c00032ba <sys_free>
c00075d0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:542
	dir_close(searched_record.parent_dir);
c00075d3:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00075d6:	83 ec 0c             	sub    $0xc,%esp
c00075d9:	50                   	push   %eax
c00075da:	e8 49 29 00 00       	call   c0009f28 <dir_close>
c00075df:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:543
	return 0;	// 成功删除文件
c00075e2:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/fs.c:544 (discriminator 1)
}
c00075e7:	c9                   	leave  
c00075e8:	c3                   	ret    

c00075e9 <sys_mkdir>:
sys_mkdir():
/work/x86_os_my/fs/fs.c:555
（3）为新目录分配 1 个块存储该目录中的目录项。
（4）在新目录中创建两个目录项“.”和“..”，这是每个目录都必须存在的两个目录项。
（5）在新目录的父目录中添加新目录的目录项。
（6）将以上资源的变更同步到硬盘。
 */
int32_t sys_mkdir(const char* pathname) {
c00075e9:	55                   	push   %ebp
c00075ea:	89 e5                	mov    %esp,%ebp
c00075ec:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
/work/x86_os_my/fs/fs.c:556
	uint8_t rollback_step = 0;	       // 用于操作失败时回滚各资源状态
c00075f2:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:557
	void* io_buf = sys_malloc(SECTOR_SIZE * 2);
c00075f6:	83 ec 0c             	sub    $0xc,%esp
c00075f9:	68 00 04 00 00       	push   $0x400
c00075fe:	e8 8a b6 ff ff       	call   c0002c8d <sys_malloc>
c0007603:	83 c4 10             	add    $0x10,%esp
c0007606:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:558
	if (io_buf == NULL) {
c0007609:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c000760d:	75 1a                	jne    c0007629 <sys_mkdir+0x40>
/work/x86_os_my/fs/fs.c:559
		printk("sys_mkdir: sys_malloc for io_buf failed\n");
c000760f:	83 ec 0c             	sub    $0xc,%esp
c0007612:	68 10 c6 00 c0       	push   $0xc000c610
c0007617:	e8 33 ee ff ff       	call   c000644f <printk>
c000761c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:560
		return -1;
c000761f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0007624:	e9 ae 03 00 00       	jmp    c00079d7 <sys_mkdir+0x3ee>
/work/x86_os_my/fs/fs.c:564
	}

	struct path_search_record searched_record;
	memset(&searched_record, 0, sizeof(struct path_search_record));
c0007629:	83 ec 04             	sub    $0x4,%esp
c000762c:	68 08 02 00 00       	push   $0x208
c0007631:	6a 00                	push   $0x0
c0007633:	8d 85 c8 fd ff ff    	lea    -0x238(%ebp),%eax
c0007639:	50                   	push   %eax
c000763a:	e8 45 c1 ff ff       	call   c0003784 <memset>
c000763f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:565
	int inode_no = -1;
c0007642:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:566
	inode_no = search_file(pathname, &searched_record);
c0007649:	83 ec 08             	sub    $0x8,%esp
c000764c:	8d 85 c8 fd ff ff    	lea    -0x238(%ebp),%eax
c0007652:	50                   	push   %eax
c0007653:	ff 75 08             	pushl  0x8(%ebp)
c0007656:	e8 90 f5 ff ff       	call   c0006beb <search_file>
c000765b:	83 c4 10             	add    $0x10,%esp
c000765e:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:567
	if (inode_no != -1) {      // 如果找到了同名目录或文件,失败返回
c0007661:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0007665:	74 1c                	je     c0007683 <sys_mkdir+0x9a>
/work/x86_os_my/fs/fs.c:568
		printk("sys_mkdir: file or directory %s exist!\n", pathname);
c0007667:	83 ec 08             	sub    $0x8,%esp
c000766a:	ff 75 08             	pushl  0x8(%ebp)
c000766d:	68 3c c6 00 c0       	push   $0xc000c63c
c0007672:	e8 d8 ed ff ff       	call   c000644f <printk>
c0007677:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:569
		rollback_step = 1;
c000767a:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:570
		goto rollback;
c000767e:	e9 08 03 00 00       	jmp    c000798b <sys_mkdir+0x3a2>
/work/x86_os_my/fs/fs.c:572
	} else {	     // 若未找到,也要判断是在最终目录没找到还是某个中间目录不存在
		uint32_t pathname_depth = path_depth_cnt((char*)pathname);
c0007683:	83 ec 0c             	sub    $0xc,%esp
c0007686:	ff 75 08             	pushl  0x8(%ebp)
c0007689:	e8 d2 f4 ff ff       	call   c0006b60 <path_depth_cnt>
c000768e:	83 c4 10             	add    $0x10,%esp
c0007691:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:573
		uint32_t path_searched_depth = path_depth_cnt(searched_record.searched_path);
c0007694:	83 ec 0c             	sub    $0xc,%esp
c0007697:	8d 85 c8 fd ff ff    	lea    -0x238(%ebp),%eax
c000769d:	50                   	push   %eax
c000769e:	e8 bd f4 ff ff       	call   c0006b60 <path_depth_cnt>
c00076a3:	83 c4 10             	add    $0x10,%esp
c00076a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/fs.c:575
		/* 先判断是否把pathname的各层目录都访问到了,即是否在某个中间目录就失败了 */
		if (pathname_depth != path_searched_depth) {   // 说明并没有访问到全部的路径,某个中间目录是不存在的
c00076a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00076ac:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c00076af:	74 23                	je     c00076d4 <sys_mkdir+0xeb>
/work/x86_os_my/fs/fs.c:576
			printk("sys_mkdir: can`t access %s, subpath %s is`t exist\n", pathname, searched_record.searched_path);
c00076b1:	83 ec 04             	sub    $0x4,%esp
c00076b4:	8d 85 c8 fd ff ff    	lea    -0x238(%ebp),%eax
c00076ba:	50                   	push   %eax
c00076bb:	ff 75 08             	pushl  0x8(%ebp)
c00076be:	68 64 c6 00 c0       	push   $0xc000c664
c00076c3:	e8 87 ed ff ff       	call   c000644f <printk>
c00076c8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:577
			rollback_step = 1;
c00076cb:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:578
			goto rollback;
c00076cf:	e9 b7 02 00 00       	jmp    c000798b <sys_mkdir+0x3a2>
/work/x86_os_my/fs/fs.c:582
		}
	}

	struct dir* parent_dir = searched_record.parent_dir;	//被创建目录所在的父目录
c00076d4:	8b 45 c8             	mov    -0x38(%ebp),%eax
c00076d7:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/fs.c:584
	/* 目录名称后可能会有字符'/',所以最好直接用searched_record.searched_path,无'/' */
	char* dirname = strrchr(searched_record.searched_path, '/') + 1;	//获取 pathname 的最后一级目录名
c00076da:	83 ec 08             	sub    $0x8,%esp
c00076dd:	6a 2f                	push   $0x2f
c00076df:	8d 85 c8 fd ff ff    	lea    -0x238(%ebp),%eax
c00076e5:	50                   	push   %eax
c00076e6:	e8 3f c3 ff ff       	call   c0003a2a <strrchr>
c00076eb:	83 c4 10             	add    $0x10,%esp
c00076ee:	83 c0 01             	add    $0x1,%eax
c00076f1:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/fs.c:586

	inode_no = inode_bitmap_alloc(cur_part);
c00076f4:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00076f9:	83 ec 0c             	sub    $0xc,%esp
c00076fc:	50                   	push   %eax
c00076fd:	e8 62 15 00 00       	call   c0008c64 <inode_bitmap_alloc>
c0007702:	83 c4 10             	add    $0x10,%esp
c0007705:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:587
	if (inode_no == -1) {
c0007708:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c000770c:	75 19                	jne    c0007727 <sys_mkdir+0x13e>
/work/x86_os_my/fs/fs.c:588
		printk("sys_mkdir: allocate inode failed\n");
c000770e:	83 ec 0c             	sub    $0xc,%esp
c0007711:	68 98 c6 00 c0       	push   $0xc000c698
c0007716:	e8 34 ed ff ff       	call   c000644f <printk>
c000771b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:589
		rollback_step = 1;
c000771e:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:590
		goto rollback;
c0007722:	e9 64 02 00 00       	jmp    c000798b <sys_mkdir+0x3a2>
/work/x86_os_my/fs/fs.c:594
	}

	struct inode new_dir_inode;
	inode_init(inode_no, &new_dir_inode);	    // 初始化i结点
c0007727:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000772a:	83 ec 08             	sub    $0x8,%esp
c000772d:	8d 95 7c fd ff ff    	lea    -0x284(%ebp),%edx
c0007733:	52                   	push   %edx
c0007734:	50                   	push   %eax
c0007735:	e8 12 14 00 00       	call   c0008b4c <inode_init>
c000773a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:596

	uint32_t block_bitmap_idx = 0;     // 用来记录block对应于block_bitmap中的索引
c000773d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
/work/x86_os_my/fs/fs.c:597
	int32_t block_lba = -1;
c0007744:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
/work/x86_os_my/fs/fs.c:599
	/* 为目录分配一个块,用来写入目录.和.. */
	block_lba = block_bitmap_alloc(cur_part);
c000774b:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0007750:	83 ec 0c             	sub    $0xc,%esp
c0007753:	50                   	push   %eax
c0007754:	e8 52 15 00 00       	call   c0008cab <block_bitmap_alloc>
c0007759:	83 c4 10             	add    $0x10,%esp
c000775c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/fs/fs.c:600
	if (block_lba == -1) {
c000775f:	83 7d d4 ff          	cmpl   $0xffffffff,-0x2c(%ebp)
c0007763:	75 19                	jne    c000777e <sys_mkdir+0x195>
/work/x86_os_my/fs/fs.c:601
		printk("sys_mkdir: block_bitmap_alloc for create directory failed\n");
c0007765:	83 ec 0c             	sub    $0xc,%esp
c0007768:	68 bc c6 00 c0       	push   $0xc000c6bc
c000776d:	e8 dd ec ff ff       	call   c000644f <printk>
c0007772:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:602
		rollback_step = 2;
c0007775:	c6 45 f7 02          	movb   $0x2,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:603
		goto rollback;
c0007779:	e9 0d 02 00 00       	jmp    c000798b <sys_mkdir+0x3a2>
/work/x86_os_my/fs/fs.c:605
	}
	new_dir_inode.i_sectors[0] = block_lba;
c000777e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0007781:	89 85 8c fd ff ff    	mov    %eax,-0x274(%ebp)
/work/x86_os_my/fs/fs.c:607
	/* 每分配一个块就将位图同步到硬盘 */
	block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c0007787:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c000778a:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000778f:	8b 40 1c             	mov    0x1c(%eax),%eax
c0007792:	8b 40 28             	mov    0x28(%eax),%eax
c0007795:	29 c2                	sub    %eax,%edx
c0007797:	89 d0                	mov    %edx,%eax
c0007799:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/fs.c:608
	ASSERT(block_bitmap_idx != 0);
c000779c:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c00077a0:	75 1c                	jne    c00077be <sys_mkdir+0x1d5>
/work/x86_os_my/fs/fs.c:608 (discriminator 1)
c00077a2:	68 f7 c6 00 c0       	push   $0xc000c6f7
c00077a7:	68 98 c9 00 c0       	push   $0xc000c998
c00077ac:	68 60 02 00 00       	push   $0x260
c00077b1:	68 6d c1 00 c0       	push   $0xc000c16d
c00077b6:	e8 27 ab ff ff       	call   c00022e2 <panic_spin>
c00077bb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:609
	bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c00077be:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00077c3:	83 ec 04             	sub    $0x4,%esp
c00077c6:	6a 01                	push   $0x1
c00077c8:	ff 75 d8             	pushl  -0x28(%ebp)
c00077cb:	50                   	push   %eax
c00077cc:	e8 2c 15 00 00       	call   c0008cfd <bitmap_sync>
c00077d1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:612

	/* 将当前目录的目录项'.'和'..'写入目录 */
	memset(io_buf, 0, SECTOR_SIZE * 2);	 // 清空io_buf
c00077d4:	83 ec 04             	sub    $0x4,%esp
c00077d7:	68 00 04 00 00       	push   $0x400
c00077dc:	6a 00                	push   $0x0
c00077de:	ff 75 ec             	pushl  -0x14(%ebp)
c00077e1:	e8 9e bf ff ff       	call   c0003784 <memset>
c00077e6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:613
	struct dir_entry* p_de = (struct dir_entry*)io_buf;
c00077e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00077ec:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/fs/fs.c:616

	/* 初始化当前目录"." */
	memcpy(p_de->filename, ".", 1);
c00077ef:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00077f2:	83 ec 04             	sub    $0x4,%esp
c00077f5:	6a 01                	push   $0x1
c00077f7:	68 ab c2 00 c0       	push   $0xc000c2ab
c00077fc:	50                   	push   %eax
c00077fd:	e8 d4 bf ff ff       	call   c00037d6 <memcpy>
c0007802:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:617
	p_de->i_no = inode_no ;
c0007805:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007808:	8b 45 d0             	mov    -0x30(%ebp),%eax
c000780b:	89 50 10             	mov    %edx,0x10(%eax)
/work/x86_os_my/fs/fs.c:618
	p_de->f_type = FT_DIRECTORY;
c000780e:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0007811:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%eax)
/work/x86_os_my/fs/fs.c:620

	p_de++;
c0007818:	83 45 d0 18          	addl   $0x18,-0x30(%ebp)
/work/x86_os_my/fs/fs.c:622
	/* 初始化当前目录".." */
	memcpy(p_de->filename, "..", 2);
c000781c:	8b 45 d0             	mov    -0x30(%ebp),%eax
c000781f:	83 ec 04             	sub    $0x4,%esp
c0007822:	6a 02                	push   $0x2
c0007824:	68 ad c2 00 c0       	push   $0xc000c2ad
c0007829:	50                   	push   %eax
c000782a:	e8 a7 bf ff ff       	call   c00037d6 <memcpy>
c000782f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:623
	p_de->i_no = parent_dir->inode->i_no;
c0007832:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0007835:	8b 00                	mov    (%eax),%eax
c0007837:	8b 10                	mov    (%eax),%edx
c0007839:	8b 45 d0             	mov    -0x30(%ebp),%eax
c000783c:	89 50 10             	mov    %edx,0x10(%eax)
/work/x86_os_my/fs/fs.c:624
	p_de->f_type = FT_DIRECTORY;
c000783f:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0007842:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%eax)
/work/x86_os_my/fs/fs.c:625
	ide_write(cur_part->my_disk, new_dir_inode.i_sectors[0], io_buf, 1);
c0007849:	8b 95 8c fd ff ff    	mov    -0x274(%ebp),%edx
c000784f:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0007854:	8b 40 08             	mov    0x8(%eax),%eax
c0007857:	6a 01                	push   $0x1
c0007859:	ff 75 ec             	pushl  -0x14(%ebp)
c000785c:	52                   	push   %edx
c000785d:	50                   	push   %eax
c000785e:	e8 e7 e2 ff ff       	call   c0005b4a <ide_write>
c0007863:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:627

	new_dir_inode.i_size = 2 * cur_part->sb->dir_entry_size;
c0007866:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000786b:	8b 40 1c             	mov    0x1c(%eax),%eax
c000786e:	8b 40 30             	mov    0x30(%eax),%eax
c0007871:	01 c0                	add    %eax,%eax
c0007873:	89 85 80 fd ff ff    	mov    %eax,-0x280(%ebp)
/work/x86_os_my/fs/fs.c:631

	/* 在父目录中添加自己的目录项 */
	struct dir_entry new_dir_entry;
	memset(&new_dir_entry, 0, sizeof(struct dir_entry));
c0007879:	83 ec 04             	sub    $0x4,%esp
c000787c:	6a 18                	push   $0x18
c000787e:	6a 00                	push   $0x0
c0007880:	8d 85 64 fd ff ff    	lea    -0x29c(%ebp),%eax
c0007886:	50                   	push   %eax
c0007887:	e8 f8 be ff ff       	call   c0003784 <memset>
c000788c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:632
	create_dir_entry(dirname, inode_no, FT_DIRECTORY, &new_dir_entry);
c000788f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0007892:	8d 95 64 fd ff ff    	lea    -0x29c(%ebp),%edx
c0007898:	52                   	push   %edx
c0007899:	6a 02                	push   $0x2
c000789b:	50                   	push   %eax
c000789c:	ff 75 dc             	pushl  -0x24(%ebp)
c000789f:	e8 b7 26 00 00       	call   c0009f5b <create_dir_entry>
c00078a4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:633
	memset(io_buf, 0, SECTOR_SIZE * 2);	 // 清空io_buf
c00078a7:	83 ec 04             	sub    $0x4,%esp
c00078aa:	68 00 04 00 00       	push   $0x400
c00078af:	6a 00                	push   $0x0
c00078b1:	ff 75 ec             	pushl  -0x14(%ebp)
c00078b4:	e8 cb be ff ff       	call   c0003784 <memset>
c00078b9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:634
	if (!sync_dir_entry(parent_dir, &new_dir_entry, io_buf)) {	  // sync_dir_entry中将block_bitmap通过bitmap_sync同步到硬盘
c00078bc:	83 ec 04             	sub    $0x4,%esp
c00078bf:	ff 75 ec             	pushl  -0x14(%ebp)
c00078c2:	8d 85 64 fd ff ff    	lea    -0x29c(%ebp),%eax
c00078c8:	50                   	push   %eax
c00078c9:	ff 75 e0             	pushl  -0x20(%ebp)
c00078cc:	e8 fb 26 00 00       	call   c0009fcc <sync_dir_entry>
c00078d1:	83 c4 10             	add    $0x10,%esp
c00078d4:	85 c0                	test   %eax,%eax
c00078d6:	75 19                	jne    c00078f1 <sys_mkdir+0x308>
/work/x86_os_my/fs/fs.c:635
		printk("sys_mkdir: sync_dir_entry to disk failed!\n");
c00078d8:	83 ec 0c             	sub    $0xc,%esp
c00078db:	68 10 c7 00 c0       	push   $0xc000c710
c00078e0:	e8 6a eb ff ff       	call   c000644f <printk>
c00078e5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:636
		rollback_step = 2;
c00078e8:	c6 45 f7 02          	movb   $0x2,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:637
		goto rollback;
c00078ec:	e9 9a 00 00 00       	jmp    c000798b <sys_mkdir+0x3a2>
/work/x86_os_my/fs/fs.c:641
	}

	/* 父目录的inode同步到硬盘 */
	memset(io_buf, 0, SECTOR_SIZE * 2);
c00078f1:	83 ec 04             	sub    $0x4,%esp
c00078f4:	68 00 04 00 00       	push   $0x400
c00078f9:	6a 00                	push   $0x0
c00078fb:	ff 75 ec             	pushl  -0x14(%ebp)
c00078fe:	e8 81 be ff ff       	call   c0003784 <memset>
c0007903:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:642
	inode_sync(cur_part, parent_dir->inode, io_buf);
c0007906:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0007909:	8b 10                	mov    (%eax),%edx
c000790b:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0007910:	83 ec 04             	sub    $0x4,%esp
c0007913:	ff 75 ec             	pushl  -0x14(%ebp)
c0007916:	52                   	push   %edx
c0007917:	50                   	push   %eax
c0007918:	e8 fb 0b 00 00       	call   c0008518 <inode_sync>
c000791d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:645

	/* 将新创建目录的inode同步到硬盘 */
	memset(io_buf, 0, SECTOR_SIZE * 2);
c0007920:	83 ec 04             	sub    $0x4,%esp
c0007923:	68 00 04 00 00       	push   $0x400
c0007928:	6a 00                	push   $0x0
c000792a:	ff 75 ec             	pushl  -0x14(%ebp)
c000792d:	e8 52 be ff ff       	call   c0003784 <memset>
c0007932:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:646
	inode_sync(cur_part, &new_dir_inode, io_buf);
c0007935:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000793a:	83 ec 04             	sub    $0x4,%esp
c000793d:	ff 75 ec             	pushl  -0x14(%ebp)
c0007940:	8d 95 7c fd ff ff    	lea    -0x284(%ebp),%edx
c0007946:	52                   	push   %edx
c0007947:	50                   	push   %eax
c0007948:	e8 cb 0b 00 00       	call   c0008518 <inode_sync>
c000794d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:649

	/* 将inode位图同步到硬盘 */
	bitmap_sync(cur_part, inode_no, INODE_BITMAP);
c0007950:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007953:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0007958:	83 ec 04             	sub    $0x4,%esp
c000795b:	6a 00                	push   $0x0
c000795d:	52                   	push   %edx
c000795e:	50                   	push   %eax
c000795f:	e8 99 13 00 00       	call   c0008cfd <bitmap_sync>
c0007964:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:651

	sys_free(io_buf);
c0007967:	83 ec 0c             	sub    $0xc,%esp
c000796a:	ff 75 ec             	pushl  -0x14(%ebp)
c000796d:	e8 48 b9 ff ff       	call   c00032ba <sys_free>
c0007972:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:654

	/* 关闭所创建目录的父目录 */
	dir_close(searched_record.parent_dir);
c0007975:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0007978:	83 ec 0c             	sub    $0xc,%esp
c000797b:	50                   	push   %eax
c000797c:	e8 a7 25 00 00       	call   c0009f28 <dir_close>
c0007981:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:655
	return 0;
c0007984:	b8 00 00 00 00       	mov    $0x0,%eax
c0007989:	eb 4c                	jmp    c00079d7 <sys_mkdir+0x3ee>
/work/x86_os_my/fs/fs.c:659

	/*创建文件或目录需要创建相关的多个资源,若某步失败则会执行到下面的回滚步骤 */
rollback:	     // 因为某步骤操作失败而回滚
	switch (rollback_step) {
c000798b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000798f:	83 f8 01             	cmp    $0x1,%eax
c0007992:	74 20                	je     c00079b4 <sys_mkdir+0x3cb>
c0007994:	83 f8 02             	cmp    $0x2,%eax
c0007997:	75 2b                	jne    c00079c4 <sys_mkdir+0x3db>
/work/x86_os_my/fs/fs.c:661
		case 2:
		bitmap_set(&cur_part->inode_bitmap, inode_no, 0);	 // 如果新文件的inode创建失败,之前位图中分配的inode_no也要恢复
c0007999:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000799c:	8b 15 d0 09 01 c0    	mov    0xc00109d0,%edx
c00079a2:	83 c2 28             	add    $0x28,%edx
c00079a5:	83 ec 04             	sub    $0x4,%esp
c00079a8:	6a 00                	push   $0x0
c00079aa:	50                   	push   %eax
c00079ab:	52                   	push   %edx
c00079ac:	e8 9f ab ff ff       	call   c0002550 <bitmap_set>
c00079b1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:664
		case 1:
		/* 关闭所创建目录的父目录 */
		dir_close(searched_record.parent_dir);
c00079b4:	8b 45 c8             	mov    -0x38(%ebp),%eax
c00079b7:	83 ec 0c             	sub    $0xc,%esp
c00079ba:	50                   	push   %eax
c00079bb:	e8 68 25 00 00       	call   c0009f28 <dir_close>
c00079c0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:665
		break;
c00079c3:	90                   	nop
/work/x86_os_my/fs/fs.c:667
	}
	sys_free(io_buf);
c00079c4:	83 ec 0c             	sub    $0xc,%esp
c00079c7:	ff 75 ec             	pushl  -0x14(%ebp)
c00079ca:	e8 eb b8 ff ff       	call   c00032ba <sys_free>
c00079cf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:668
	return -1;
c00079d2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/fs/fs.c:669 (discriminator 1)
}
c00079d7:	c9                   	leave  
c00079d8:	c3                   	ret    

c00079d9 <sys_opendir>:
sys_opendir():
/work/x86_os_my/fs/fs.c:672

/* 目录打开成功后返回目录指针,失败返回NULL */
struct dir* sys_opendir(const char* name) {
c00079d9:	55                   	push   %ebp
c00079da:	89 e5                	mov    %esp,%ebp
c00079dc:	81 ec 18 02 00 00    	sub    $0x218,%esp
/work/x86_os_my/fs/fs.c:673
	ASSERT(strlen(name) < MAX_PATH_LEN);
c00079e2:	83 ec 0c             	sub    $0xc,%esp
c00079e5:	ff 75 08             	pushl  0x8(%ebp)
c00079e8:	e8 21 bf ff ff       	call   c000390e <strlen>
c00079ed:	83 c4 10             	add    $0x10,%esp
c00079f0:	3d ff 01 00 00       	cmp    $0x1ff,%eax
c00079f5:	76 1c                	jbe    c0007a13 <sys_opendir+0x3a>
/work/x86_os_my/fs/fs.c:673 (discriminator 1)
c00079f7:	68 3b c7 00 c0       	push   $0xc000c73b
c00079fc:	68 a4 c9 00 c0       	push   $0xc000c9a4
c0007a01:	68 a1 02 00 00       	push   $0x2a1
c0007a06:	68 6d c1 00 c0       	push   $0xc000c16d
c0007a0b:	e8 d2 a8 ff ff       	call   c00022e2 <panic_spin>
c0007a10:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:675
	/* 如果是根目录'/',直接返回&root_dir */
	if (name[0] == '/' && (name[1] == 0 || name[0] == '.')) {
c0007a13:	8b 45 08             	mov    0x8(%ebp),%eax
c0007a16:	0f b6 00             	movzbl (%eax),%eax
c0007a19:	3c 2f                	cmp    $0x2f,%al
c0007a1b:	75 21                	jne    c0007a3e <sys_opendir+0x65>
/work/x86_os_my/fs/fs.c:675 (discriminator 1)
c0007a1d:	8b 45 08             	mov    0x8(%ebp),%eax
c0007a20:	83 c0 01             	add    $0x1,%eax
c0007a23:	0f b6 00             	movzbl (%eax),%eax
c0007a26:	84 c0                	test   %al,%al
c0007a28:	74 0a                	je     c0007a34 <sys_opendir+0x5b>
/work/x86_os_my/fs/fs.c:675 (discriminator 2)
c0007a2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0007a2d:	0f b6 00             	movzbl (%eax),%eax
c0007a30:	3c 2e                	cmp    $0x2e,%al
c0007a32:	75 0a                	jne    c0007a3e <sys_opendir+0x65>
/work/x86_os_my/fs/fs.c:676
		return &root_dir;
c0007a34:	b8 60 0b 01 c0       	mov    $0xc0010b60,%eax
c0007a39:	e9 a9 00 00 00       	jmp    c0007ae7 <sys_opendir+0x10e>
/work/x86_os_my/fs/fs.c:681
	}

	/* 先检查待打开的目录是否存在 */
	struct path_search_record searched_record;
	memset(&searched_record, 0, sizeof(struct path_search_record));
c0007a3e:	83 ec 04             	sub    $0x4,%esp
c0007a41:	68 08 02 00 00       	push   $0x208
c0007a46:	6a 00                	push   $0x0
c0007a48:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c0007a4e:	50                   	push   %eax
c0007a4f:	e8 30 bd ff ff       	call   c0003784 <memset>
c0007a54:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:682
	int inode_no = search_file(name, &searched_record);
c0007a57:	83 ec 08             	sub    $0x8,%esp
c0007a5a:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c0007a60:	50                   	push   %eax
c0007a61:	ff 75 08             	pushl  0x8(%ebp)
c0007a64:	e8 82 f1 ff ff       	call   c0006beb <search_file>
c0007a69:	83 c4 10             	add    $0x10,%esp
c0007a6c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:683
	struct dir* ret = NULL;
c0007a6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:684
	if (inode_no == -1) {	 // 如果找不到目录,提示不存在的路径
c0007a76:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0007a7a:	75 1c                	jne    c0007a98 <sys_opendir+0xbf>
/work/x86_os_my/fs/fs.c:685
		printk("In %s, sub path %s not exist\n", name, searched_record.searched_path);
c0007a7c:	83 ec 04             	sub    $0x4,%esp
c0007a7f:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c0007a85:	50                   	push   %eax
c0007a86:	ff 75 08             	pushl  0x8(%ebp)
c0007a89:	68 57 c7 00 c0       	push   $0xc000c757
c0007a8e:	e8 bc e9 ff ff       	call   c000644f <printk>
c0007a93:	83 c4 10             	add    $0x10,%esp
c0007a96:	eb 3d                	jmp    c0007ad5 <sys_opendir+0xfc>
/work/x86_os_my/fs/fs.c:687
	} else {
		if (searched_record.file_type == FT_REGULAR) {
c0007a98:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0007a9b:	83 f8 01             	cmp    $0x1,%eax
c0007a9e:	75 15                	jne    c0007ab5 <sys_opendir+0xdc>
/work/x86_os_my/fs/fs.c:688
			printk("%s is regular file!\n", name);
c0007aa0:	83 ec 08             	sub    $0x8,%esp
c0007aa3:	ff 75 08             	pushl  0x8(%ebp)
c0007aa6:	68 75 c7 00 c0       	push   $0xc000c775
c0007aab:	e8 9f e9 ff ff       	call   c000644f <printk>
c0007ab0:	83 c4 10             	add    $0x10,%esp
c0007ab3:	eb 20                	jmp    c0007ad5 <sys_opendir+0xfc>
/work/x86_os_my/fs/fs.c:689
		} else if (searched_record.file_type == FT_DIRECTORY) {
c0007ab5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0007ab8:	83 f8 02             	cmp    $0x2,%eax
c0007abb:	75 18                	jne    c0007ad5 <sys_opendir+0xfc>
/work/x86_os_my/fs/fs.c:690
			ret = dir_open(cur_part, inode_no);
c0007abd:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007ac0:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0007ac5:	83 ec 08             	sub    $0x8,%esp
c0007ac8:	52                   	push   %edx
c0007ac9:	50                   	push   %eax
c0007aca:	e8 41 22 00 00       	call   c0009d10 <dir_open>
c0007acf:	83 c4 10             	add    $0x10,%esp
c0007ad2:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:693
		}
	}
	dir_close(searched_record.parent_dir);
c0007ad5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0007ad8:	83 ec 0c             	sub    $0xc,%esp
c0007adb:	50                   	push   %eax
c0007adc:	e8 47 24 00 00       	call   c0009f28 <dir_close>
c0007ae1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:694
	return ret;
c0007ae4:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:695 (discriminator 1)
}
c0007ae7:	c9                   	leave  
c0007ae8:	c3                   	ret    

c0007ae9 <sys_closedir>:
sys_closedir():
/work/x86_os_my/fs/fs.c:698

/* 成功关闭目录dir返回0,失败返回-1 */
int32_t sys_closedir(struct dir* dir) {
c0007ae9:	55                   	push   %ebp
c0007aea:	89 e5                	mov    %esp,%ebp
c0007aec:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/fs.c:699
	int32_t ret = -1;
c0007aef:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:700
	if (dir != NULL) {
c0007af6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0007afa:	74 15                	je     c0007b11 <sys_closedir+0x28>
/work/x86_os_my/fs/fs.c:701
		dir_close(dir);
c0007afc:	83 ec 0c             	sub    $0xc,%esp
c0007aff:	ff 75 08             	pushl  0x8(%ebp)
c0007b02:	e8 21 24 00 00       	call   c0009f28 <dir_close>
c0007b07:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:702
		ret = 0;
c0007b0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:704
	}
	return ret;
c0007b11:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:705
}
c0007b14:	c9                   	leave  
c0007b15:	c3                   	ret    

c0007b16 <sys_readdir>:
sys_readdir():
/work/x86_os_my/fs/fs.c:708

/* 读取目录dir的1个目录项,成功后返回其目录项地址,到目录尾时或出错时返回NULL */
struct dir_entry* sys_readdir(struct dir* dir) {
c0007b16:	55                   	push   %ebp
c0007b17:	89 e5                	mov    %esp,%ebp
c0007b19:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/fs/fs.c:709
	ASSERT(dir != NULL);
c0007b1c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0007b20:	75 1c                	jne    c0007b3e <sys_readdir+0x28>
/work/x86_os_my/fs/fs.c:709 (discriminator 1)
c0007b22:	68 8a c7 00 c0       	push   $0xc000c78a
c0007b27:	68 b0 c9 00 c0       	push   $0xc000c9b0
c0007b2c:	68 c5 02 00 00       	push   $0x2c5
c0007b31:	68 6d c1 00 c0       	push   $0xc000c16d
c0007b36:	e8 a7 a7 ff ff       	call   c00022e2 <panic_spin>
c0007b3b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:710
	return dir_read(dir);
c0007b3e:	83 ec 0c             	sub    $0xc,%esp
c0007b41:	ff 75 08             	pushl  0x8(%ebp)
c0007b44:	e8 06 2d 00 00       	call   c000a84f <dir_read>
c0007b49:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:711
}
c0007b4c:	c9                   	leave  
c0007b4d:	c3                   	ret    

c0007b4e <sys_rewinddir>:
sys_rewinddir():
/work/x86_os_my/fs/fs.c:714

/* 把目录dir的指针dir_pos置0 */
void sys_rewinddir(struct dir* dir) {
c0007b4e:	55                   	push   %ebp
c0007b4f:	89 e5                	mov    %esp,%ebp
/work/x86_os_my/fs/fs.c:715
	dir->dir_pos = 0;
c0007b51:	8b 45 08             	mov    0x8(%ebp),%eax
c0007b54:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
/work/x86_os_my/fs/fs.c:716
}
c0007b5b:	90                   	nop
c0007b5c:	5d                   	pop    %ebp
c0007b5d:	c3                   	ret    

c0007b5e <sys_rmdir>:
sys_rmdir():
/work/x86_os_my/fs/fs.c:719

/* 删除空目录,成功时返回0,失败时返回-1*/
int32_t sys_rmdir(const char* pathname) {
c0007b5e:	55                   	push   %ebp
c0007b5f:	89 e5                	mov    %esp,%ebp
c0007b61:	81 ec 28 02 00 00    	sub    $0x228,%esp
/work/x86_os_my/fs/fs.c:722
	/* 先检查待删除的文件是否存在 */
	struct path_search_record searched_record;
	memset(&searched_record, 0, sizeof(struct path_search_record));
c0007b67:	83 ec 04             	sub    $0x4,%esp
c0007b6a:	68 08 02 00 00       	push   $0x208
c0007b6f:	6a 00                	push   $0x0
c0007b71:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0007b77:	50                   	push   %eax
c0007b78:	e8 07 bc ff ff       	call   c0003784 <memset>
c0007b7d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:723
	int inode_no = search_file(pathname, &searched_record);
c0007b80:	83 ec 08             	sub    $0x8,%esp
c0007b83:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0007b89:	50                   	push   %eax
c0007b8a:	ff 75 08             	pushl  0x8(%ebp)
c0007b8d:	e8 59 f0 ff ff       	call   c0006beb <search_file>
c0007b92:	83 c4 10             	add    $0x10,%esp
c0007b95:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:724
	ASSERT(inode_no != 0);
c0007b98:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0007b9c:	75 1c                	jne    c0007bba <sys_rmdir+0x5c>
/work/x86_os_my/fs/fs.c:724 (discriminator 1)
c0007b9e:	68 40 c5 00 c0       	push   $0xc000c540
c0007ba3:	68 bc c9 00 c0       	push   $0xc000c9bc
c0007ba8:	68 d4 02 00 00       	push   $0x2d4
c0007bad:	68 6d c1 00 c0       	push   $0xc000c16d
c0007bb2:	e8 2b a7 ff ff       	call   c00022e2 <panic_spin>
c0007bb7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:725
	int retval = -1;	// 默认返回值
c0007bba:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:726
	if (inode_no == -1) {
c0007bc1:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0007bc5:	75 1f                	jne    c0007be6 <sys_rmdir+0x88>
/work/x86_os_my/fs/fs.c:727
		printk("In %s, sub path %s not exist\n", pathname, searched_record.searched_path);
c0007bc7:	83 ec 04             	sub    $0x4,%esp
c0007bca:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0007bd0:	50                   	push   %eax
c0007bd1:	ff 75 08             	pushl  0x8(%ebp)
c0007bd4:	68 57 c7 00 c0       	push   $0xc000c757
c0007bd9:	e8 71 e8 ff ff       	call   c000644f <printk>
c0007bde:	83 c4 10             	add    $0x10,%esp
c0007be1:	e9 87 00 00 00       	jmp    c0007c6d <sys_rmdir+0x10f>
/work/x86_os_my/fs/fs.c:729
	} else {
		if (searched_record.file_type == FT_REGULAR) {
c0007be6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0007be9:	83 f8 01             	cmp    $0x1,%eax
c0007bec:	75 15                	jne    c0007c03 <sys_rmdir+0xa5>
/work/x86_os_my/fs/fs.c:730
			printk("%s is regular file!\n", pathname);
c0007bee:	83 ec 08             	sub    $0x8,%esp
c0007bf1:	ff 75 08             	pushl  0x8(%ebp)
c0007bf4:	68 75 c7 00 c0       	push   $0xc000c775
c0007bf9:	e8 51 e8 ff ff       	call   c000644f <printk>
c0007bfe:	83 c4 10             	add    $0x10,%esp
c0007c01:	eb 6a                	jmp    c0007c6d <sys_rmdir+0x10f>
/work/x86_os_my/fs/fs.c:732
		} else {
			struct dir* dir = dir_open(cur_part, inode_no);
c0007c03:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0007c06:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0007c0b:	83 ec 08             	sub    $0x8,%esp
c0007c0e:	52                   	push   %edx
c0007c0f:	50                   	push   %eax
c0007c10:	e8 fb 20 00 00       	call   c0009d10 <dir_open>
c0007c15:	83 c4 10             	add    $0x10,%esp
c0007c18:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:733
			if (!dir_is_empty(dir)) {	 // 非空目录不可删除
c0007c1b:	83 ec 0c             	sub    $0xc,%esp
c0007c1e:	ff 75 ec             	pushl  -0x14(%ebp)
c0007c21:	e8 11 2e 00 00       	call   c000aa37 <dir_is_empty>
c0007c26:	83 c4 10             	add    $0x10,%esp
c0007c29:	85 c0                	test   %eax,%eax
c0007c2b:	75 15                	jne    c0007c42 <sys_rmdir+0xe4>
/work/x86_os_my/fs/fs.c:734
				printk("dir %s is not empty, it is not allowed to delete a nonempty directory!\n", pathname);
c0007c2d:	83 ec 08             	sub    $0x8,%esp
c0007c30:	ff 75 08             	pushl  0x8(%ebp)
c0007c33:	68 98 c7 00 c0       	push   $0xc000c798
c0007c38:	e8 12 e8 ff ff       	call   c000644f <printk>
c0007c3d:	83 c4 10             	add    $0x10,%esp
c0007c40:	eb 1d                	jmp    c0007c5f <sys_rmdir+0x101>
/work/x86_os_my/fs/fs.c:736
			} else {
				if (!dir_remove(searched_record.parent_dir, dir)) {
c0007c42:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0007c45:	83 ec 08             	sub    $0x8,%esp
c0007c48:	ff 75 ec             	pushl  -0x14(%ebp)
c0007c4b:	50                   	push   %eax
c0007c4c:	e8 11 2e 00 00       	call   c000aa62 <dir_remove>
c0007c51:	83 c4 10             	add    $0x10,%esp
c0007c54:	85 c0                	test   %eax,%eax
c0007c56:	75 07                	jne    c0007c5f <sys_rmdir+0x101>
/work/x86_os_my/fs/fs.c:737
					retval = 0;
c0007c58:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:740
				}
			}
			dir_close(dir);
c0007c5f:	83 ec 0c             	sub    $0xc,%esp
c0007c62:	ff 75 ec             	pushl  -0x14(%ebp)
c0007c65:	e8 be 22 00 00       	call   c0009f28 <dir_close>
c0007c6a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:743
		}
	}
	dir_close(searched_record.parent_dir);
c0007c6d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0007c70:	83 ec 0c             	sub    $0xc,%esp
c0007c73:	50                   	push   %eax
c0007c74:	e8 af 22 00 00       	call   c0009f28 <dir_close>
c0007c79:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:744
	return retval;
c0007c7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:745
}
c0007c7f:	c9                   	leave  
c0007c80:	c3                   	ret    

c0007c81 <get_parent_dir_inode_nr>:
get_parent_dir_inode_nr():
/work/x86_os_my/fs/fs.c:748

/* 获得父目录的inode编号 */
static uint32_t get_parent_dir_inode_nr(uint32_t child_inode_nr, void* io_buf) {
c0007c81:	55                   	push   %ebp
c0007c82:	89 e5                	mov    %esp,%ebp
c0007c84:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/fs.c:749
   struct inode* child_dir_inode = inode_open(cur_part, child_inode_nr);
c0007c87:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0007c8c:	83 ec 08             	sub    $0x8,%esp
c0007c8f:	ff 75 08             	pushl  0x8(%ebp)
c0007c92:	50                   	push   %eax
c0007c93:	e8 a7 09 00 00       	call   c000863f <inode_open>
c0007c98:	83 c4 10             	add    $0x10,%esp
c0007c9b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:751
   /* 目录中的目录项".."中包括父目录inode编号,".."位于目录的第0块 */
   uint32_t block_lba = child_dir_inode->i_sectors[0];
c0007c9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0007ca1:	8b 40 10             	mov    0x10(%eax),%eax
c0007ca4:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:752
   ASSERT(block_lba >= cur_part->sb->data_start_lba);
c0007ca7:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0007cac:	8b 40 1c             	mov    0x1c(%eax),%eax
c0007caf:	8b 40 28             	mov    0x28(%eax),%eax
c0007cb2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0007cb5:	76 1c                	jbe    c0007cd3 <get_parent_dir_inode_nr+0x52>
/work/x86_os_my/fs/fs.c:752 (discriminator 1)
c0007cb7:	68 e0 c7 00 c0       	push   $0xc000c7e0
c0007cbc:	68 c8 c9 00 c0       	push   $0xc000c9c8
c0007cc1:	68 f0 02 00 00       	push   $0x2f0
c0007cc6:	68 6d c1 00 c0       	push   $0xc000c16d
c0007ccb:	e8 12 a6 ff ff       	call   c00022e2 <panic_spin>
c0007cd0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:753
   inode_close(child_dir_inode);
c0007cd3:	83 ec 0c             	sub    $0xc,%esp
c0007cd6:	ff 75 f4             	pushl  -0xc(%ebp)
c0007cd9:	e8 a7 0a 00 00       	call   c0008785 <inode_close>
c0007cde:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:754
   ide_read(cur_part->my_disk, block_lba, io_buf, 1);
c0007ce1:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0007ce6:	8b 40 08             	mov    0x8(%eax),%eax
c0007ce9:	6a 01                	push   $0x1
c0007ceb:	ff 75 0c             	pushl  0xc(%ebp)
c0007cee:	ff 75 f0             	pushl  -0x10(%ebp)
c0007cf1:	50                   	push   %eax
c0007cf2:	e8 df dc ff ff       	call   c00059d6 <ide_read>
c0007cf7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:755
   struct dir_entry* dir_e = (struct dir_entry*)io_buf;
c0007cfa:	8b 45 0c             	mov    0xc(%ebp),%eax
c0007cfd:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:757
   /* 第0个目录项是".",第1个目录项是".." */
   ASSERT(dir_e[1].i_no < 4096 && dir_e[1].f_type == FT_DIRECTORY);
c0007d00:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0007d03:	83 c0 18             	add    $0x18,%eax
c0007d06:	8b 40 10             	mov    0x10(%eax),%eax
c0007d09:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c0007d0e:	77 0e                	ja     c0007d1e <get_parent_dir_inode_nr+0x9d>
/work/x86_os_my/fs/fs.c:757 (discriminator 1)
c0007d10:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0007d13:	83 c0 18             	add    $0x18,%eax
c0007d16:	8b 40 14             	mov    0x14(%eax),%eax
c0007d19:	83 f8 02             	cmp    $0x2,%eax
c0007d1c:	74 1c                	je     c0007d3a <get_parent_dir_inode_nr+0xb9>
/work/x86_os_my/fs/fs.c:757 (discriminator 3)
c0007d1e:	68 0c c8 00 c0       	push   $0xc000c80c
c0007d23:	68 c8 c9 00 c0       	push   $0xc000c9c8
c0007d28:	68 f5 02 00 00       	push   $0x2f5
c0007d2d:	68 6d c1 00 c0       	push   $0xc000c16d
c0007d32:	e8 ab a5 ff ff       	call   c00022e2 <panic_spin>
c0007d37:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:758
   return dir_e[1].i_no;	// 返回..即父目录的inode编号
c0007d3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0007d3d:	83 c0 18             	add    $0x18,%eax
c0007d40:	8b 40 10             	mov    0x10(%eax),%eax
/work/x86_os_my/fs/fs.c:759
}
c0007d43:	c9                   	leave  
c0007d44:	c3                   	ret    

c0007d45 <get_child_dir_name>:
get_child_dir_name():
/work/x86_os_my/fs/fs.c:763

/* 在inode编号为p_inode_nr的目录中查找inode编号为c_inode_nr的子目录的名字,
 * 将名字存入缓冲区path.成功返回0,失败返-1 */
static int get_child_dir_name(uint32_t p_inode_nr, uint32_t c_inode_nr, char* path, void* io_buf) {
c0007d45:	55                   	push   %ebp
c0007d46:	89 e5                	mov    %esp,%ebp
c0007d48:	57                   	push   %edi
c0007d49:	81 ec 54 02 00 00    	sub    $0x254,%esp
/work/x86_os_my/fs/fs.c:764
	struct inode* parent_dir_inode = inode_open(cur_part, p_inode_nr);
c0007d4f:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0007d54:	83 ec 08             	sub    $0x8,%esp
c0007d57:	ff 75 08             	pushl  0x8(%ebp)
c0007d5a:	50                   	push   %eax
c0007d5b:	e8 df 08 00 00       	call   c000863f <inode_open>
c0007d60:	83 c4 10             	add    $0x10,%esp
c0007d63:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:766
	/* 填充all_blocks,将该目录的所占扇区地址全部写入all_blocks */
	uint8_t block_idx = 0;
c0007d66:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:767
	uint32_t all_blocks[140] = {0}, block_cnt = 12;
c0007d6a:	8d 95 ac fd ff ff    	lea    -0x254(%ebp),%edx
c0007d70:	b8 00 00 00 00       	mov    $0x0,%eax
c0007d75:	b9 8c 00 00 00       	mov    $0x8c,%ecx
c0007d7a:	89 d7                	mov    %edx,%edi
c0007d7c:	f3 ab                	rep stos %eax,%es:(%edi)
c0007d7e:	c7 45 f0 0c 00 00 00 	movl   $0xc,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:768
	while (block_idx < 12) {
c0007d85:	eb 22                	jmp    c0007da9 <get_child_dir_name+0x64>
/work/x86_os_my/fs/fs.c:769
		all_blocks[block_idx] = parent_dir_inode->i_sectors[block_idx];
c0007d87:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0007d8b:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
c0007d8f:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0007d92:	83 c1 04             	add    $0x4,%ecx
c0007d95:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
c0007d98:	89 94 85 ac fd ff ff 	mov    %edx,-0x254(%ebp,%eax,4)
/work/x86_os_my/fs/fs.c:770
		block_idx++;
c0007d9f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0007da3:	83 c0 01             	add    $0x1,%eax
c0007da6:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:768
static int get_child_dir_name(uint32_t p_inode_nr, uint32_t c_inode_nr, char* path, void* io_buf) {
	struct inode* parent_dir_inode = inode_open(cur_part, p_inode_nr);
	/* 填充all_blocks,将该目录的所占扇区地址全部写入all_blocks */
	uint8_t block_idx = 0;
	uint32_t all_blocks[140] = {0}, block_cnt = 12;
	while (block_idx < 12) {
c0007da9:	80 7d f7 0b          	cmpb   $0xb,-0x9(%ebp)
c0007dad:	76 d8                	jbe    c0007d87 <get_child_dir_name+0x42>
/work/x86_os_my/fs/fs.c:772
		all_blocks[block_idx] = parent_dir_inode->i_sectors[block_idx];
		block_idx++;
	}
	if (parent_dir_inode->i_sectors[12]) {	// 若包含了一级间接块表,将共读入all_blocks.
c0007daf:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0007db2:	8b 40 40             	mov    0x40(%eax),%eax
c0007db5:	85 c0                	test   %eax,%eax
c0007db7:	74 2c                	je     c0007de5 <get_child_dir_name+0xa0>
/work/x86_os_my/fs/fs.c:773
		ide_read(cur_part->my_disk, parent_dir_inode->i_sectors[12], all_blocks + 12, 1);
c0007db9:	8d 85 ac fd ff ff    	lea    -0x254(%ebp),%eax
c0007dbf:	83 c0 30             	add    $0x30,%eax
c0007dc2:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0007dc5:	8b 4a 40             	mov    0x40(%edx),%ecx
c0007dc8:	8b 15 d0 09 01 c0    	mov    0xc00109d0,%edx
c0007dce:	8b 52 08             	mov    0x8(%edx),%edx
c0007dd1:	6a 01                	push   $0x1
c0007dd3:	50                   	push   %eax
c0007dd4:	51                   	push   %ecx
c0007dd5:	52                   	push   %edx
c0007dd6:	e8 fb db ff ff       	call   c00059d6 <ide_read>
c0007ddb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:774
		block_cnt = 140;
c0007dde:	c7 45 f0 8c 00 00 00 	movl   $0x8c,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:776
	}
	inode_close(parent_dir_inode);
c0007de5:	83 ec 0c             	sub    $0xc,%esp
c0007de8:	ff 75 e8             	pushl  -0x18(%ebp)
c0007deb:	e8 95 09 00 00       	call   c0008785 <inode_close>
c0007df0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:778

	struct dir_entry* dir_e = (struct dir_entry*)io_buf;
c0007df3:	8b 45 14             	mov    0x14(%ebp),%eax
c0007df6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/fs.c:779
	uint32_t dir_entry_size = cur_part->sb->dir_entry_size;
c0007df9:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0007dfe:	8b 40 1c             	mov    0x1c(%eax),%eax
c0007e01:	8b 40 30             	mov    0x30(%eax),%eax
c0007e04:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/fs.c:780
	uint32_t dir_entrys_per_sec = (512 / dir_entry_size);
c0007e07:	b8 00 02 00 00       	mov    $0x200,%eax
c0007e0c:	ba 00 00 00 00       	mov    $0x0,%edx
c0007e11:	f7 75 e0             	divl   -0x20(%ebp)
c0007e14:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/fs.c:781
	block_idx = 0;
c0007e17:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:783
	/* 遍历所有块 */
	while(block_idx < block_cnt) {
c0007e1b:	e9 b1 00 00 00       	jmp    c0007ed1 <get_child_dir_name+0x18c>
/work/x86_os_my/fs/fs.c:784
		if(all_blocks[block_idx]) {      // 如果相应块不为空则读入相应块
c0007e20:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0007e24:	8b 84 85 ac fd ff ff 	mov    -0x254(%ebp,%eax,4),%eax
c0007e2b:	85 c0                	test   %eax,%eax
c0007e2d:	0f 84 94 00 00 00    	je     c0007ec7 <get_child_dir_name+0x182>
/work/x86_os_my/fs/fs.c:785
			ide_read(cur_part->my_disk, all_blocks[block_idx], io_buf, 1);
c0007e33:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0007e37:	8b 94 85 ac fd ff ff 	mov    -0x254(%ebp,%eax,4),%edx
c0007e3e:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0007e43:	8b 40 08             	mov    0x8(%eax),%eax
c0007e46:	6a 01                	push   $0x1
c0007e48:	ff 75 14             	pushl  0x14(%ebp)
c0007e4b:	52                   	push   %edx
c0007e4c:	50                   	push   %eax
c0007e4d:	e8 84 db ff ff       	call   c00059d6 <ide_read>
c0007e52:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:786
			uint8_t dir_e_idx = 0;
c0007e55:	c6 45 ef 00          	movb   $0x0,-0x11(%ebp)
/work/x86_os_my/fs/fs.c:788
			/* 遍历每个目录项 */
			while(dir_e_idx < dir_entrys_per_sec) {
c0007e59:	eb 63                	jmp    c0007ebe <get_child_dir_name+0x179>
/work/x86_os_my/fs/fs.c:789
				if ((dir_e + dir_e_idx)->i_no == c_inode_nr) {
c0007e5b:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c0007e5f:	89 d0                	mov    %edx,%eax
c0007e61:	01 c0                	add    %eax,%eax
c0007e63:	01 d0                	add    %edx,%eax
c0007e65:	c1 e0 03             	shl    $0x3,%eax
c0007e68:	89 c2                	mov    %eax,%edx
c0007e6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0007e6d:	01 d0                	add    %edx,%eax
c0007e6f:	8b 40 10             	mov    0x10(%eax),%eax
c0007e72:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0007e75:	75 3d                	jne    c0007eb4 <get_child_dir_name+0x16f>
/work/x86_os_my/fs/fs.c:790
					strcat(path, "/");
c0007e77:	83 ec 08             	sub    $0x8,%esp
c0007e7a:	68 e7 c2 00 c0       	push   $0xc000c2e7
c0007e7f:	ff 75 10             	pushl  0x10(%ebp)
c0007e82:	e8 01 bc ff ff       	call   c0003a88 <strcat>
c0007e87:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:791
					strcat(path, (dir_e + dir_e_idx)->filename);
c0007e8a:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c0007e8e:	89 d0                	mov    %edx,%eax
c0007e90:	01 c0                	add    %eax,%eax
c0007e92:	01 d0                	add    %edx,%eax
c0007e94:	c1 e0 03             	shl    $0x3,%eax
c0007e97:	89 c2                	mov    %eax,%edx
c0007e99:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0007e9c:	01 d0                	add    %edx,%eax
c0007e9e:	83 ec 08             	sub    $0x8,%esp
c0007ea1:	50                   	push   %eax
c0007ea2:	ff 75 10             	pushl  0x10(%ebp)
c0007ea5:	e8 de bb ff ff       	call   c0003a88 <strcat>
c0007eaa:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:792
					return 0;
c0007ead:	b8 00 00 00 00       	mov    $0x0,%eax
c0007eb2:	eb 2f                	jmp    c0007ee3 <get_child_dir_name+0x19e>
/work/x86_os_my/fs/fs.c:794
				}
				dir_e_idx++;
c0007eb4:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c0007eb8:	83 c0 01             	add    $0x1,%eax
c0007ebb:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/fs/fs.c:788
	while(block_idx < block_cnt) {
		if(all_blocks[block_idx]) {      // 如果相应块不为空则读入相应块
			ide_read(cur_part->my_disk, all_blocks[block_idx], io_buf, 1);
			uint8_t dir_e_idx = 0;
			/* 遍历每个目录项 */
			while(dir_e_idx < dir_entrys_per_sec) {
c0007ebe:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c0007ec2:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c0007ec5:	72 94                	jb     c0007e5b <get_child_dir_name+0x116>
/work/x86_os_my/fs/fs.c:797
					return 0;
				}
				dir_e_idx++;
			}
		}
		block_idx++;
c0007ec7:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0007ecb:	83 c0 01             	add    $0x1,%eax
c0007ece:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:783
	struct dir_entry* dir_e = (struct dir_entry*)io_buf;
	uint32_t dir_entry_size = cur_part->sb->dir_entry_size;
	uint32_t dir_entrys_per_sec = (512 / dir_entry_size);
	block_idx = 0;
	/* 遍历所有块 */
	while(block_idx < block_cnt) {
c0007ed1:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0007ed5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0007ed8:	0f 82 42 ff ff ff    	jb     c0007e20 <get_child_dir_name+0xdb>
/work/x86_os_my/fs/fs.c:799
				dir_e_idx++;
			}
		}
		block_idx++;
	}
	return -1;
c0007ede:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/fs/fs.c:800 (discriminator 1)
}
c0007ee3:	8b 7d fc             	mov    -0x4(%ebp),%edi
c0007ee6:	c9                   	leave  
c0007ee7:	c3                   	ret    

c0007ee8 <sys_getcwd>:
sys_getcwd():
/work/x86_os_my/fs/fs.c:805

/* 把当前工作目录绝对路径写入buf, size是buf的大小.
 当buf为NULL时,由操作系统分配存储工作路径的空间并返回地址
 失败则返回NULL */
char* sys_getcwd(char* buf, uint32_t size) {
c0007ee8:	55                   	push   %ebp
c0007ee9:	89 e5                	mov    %esp,%ebp
c0007eeb:	57                   	push   %edi
c0007eec:	53                   	push   %ebx
c0007eed:	81 ec 20 02 00 00    	sub    $0x220,%esp
/work/x86_os_my/fs/fs.c:808
	/* 确保buf不为空,若用户进程提供的buf为NULL,
	系统调用getcwd中要为用户进程通过malloc分配内存 */
	ASSERT(buf != NULL);
c0007ef3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0007ef7:	75 1c                	jne    c0007f15 <sys_getcwd+0x2d>
/work/x86_os_my/fs/fs.c:808 (discriminator 1)
c0007ef9:	68 e6 c4 00 c0       	push   $0xc000c4e6
c0007efe:	68 e0 c9 00 c0       	push   $0xc000c9e0
c0007f03:	68 28 03 00 00       	push   $0x328
c0007f08:	68 6d c1 00 c0       	push   $0xc000c16d
c0007f0d:	e8 d0 a3 ff ff       	call   c00022e2 <panic_spin>
c0007f12:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:809
	void* io_buf = sys_malloc(SECTOR_SIZE);
c0007f15:	83 ec 0c             	sub    $0xc,%esp
c0007f18:	68 00 02 00 00       	push   $0x200
c0007f1d:	e8 6b ad ff ff       	call   c0002c8d <sys_malloc>
c0007f22:	83 c4 10             	add    $0x10,%esp
c0007f25:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:810
	if (io_buf == NULL) {
c0007f28:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0007f2c:	75 0a                	jne    c0007f38 <sys_getcwd+0x50>
/work/x86_os_my/fs/fs.c:811
		return NULL;
c0007f2e:	b8 00 00 00 00       	mov    $0x0,%eax
c0007f33:	e9 8f 01 00 00       	jmp    c00080c7 <sys_getcwd+0x1df>
/work/x86_os_my/fs/fs.c:814
	}

	struct task_struct* cur_thread = running_thread();
c0007f38:	e8 2e bc ff ff       	call   c0003b6b <running_thread>
c0007f3d:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:815
	int32_t parent_inode_nr = 0;
c0007f40:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:816
	int32_t child_inode_nr = cur_thread->cwd_inode_nr;
c0007f47:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0007f4a:	8b 80 0c 01 00 00    	mov    0x10c(%eax),%eax
c0007f50:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:817
	ASSERT(child_inode_nr >= 0 && child_inode_nr < 4096);	// inode位图，最大支持4096个inode
c0007f53:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0007f57:	78 09                	js     c0007f62 <sys_getcwd+0x7a>
/work/x86_os_my/fs/fs.c:817 (discriminator 1)
c0007f59:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%ebp)
c0007f60:	7e 1c                	jle    c0007f7e <sys_getcwd+0x96>
/work/x86_os_my/fs/fs.c:817 (discriminator 3)
c0007f62:	68 44 c8 00 c0       	push   $0xc000c844
c0007f67:	68 e0 c9 00 c0       	push   $0xc000c9e0
c0007f6c:	68 31 03 00 00       	push   $0x331
c0007f71:	68 6d c1 00 c0       	push   $0xc000c16d
c0007f76:	e8 67 a3 ff ff       	call   c00022e2 <panic_spin>
c0007f7b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:819
	/* 若当前目录是根目录,直接返回'/' */
	if (child_inode_nr == 0) {
c0007f7e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0007f82:	75 17                	jne    c0007f9b <sys_getcwd+0xb3>
/work/x86_os_my/fs/fs.c:820
		buf[0] = '/';
c0007f84:	8b 45 08             	mov    0x8(%ebp),%eax
c0007f87:	c6 00 2f             	movb   $0x2f,(%eax)
/work/x86_os_my/fs/fs.c:821
		buf[1] = 0;
c0007f8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0007f8d:	83 c0 01             	add    $0x1,%eax
c0007f90:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:822
		return buf;
c0007f93:	8b 45 08             	mov    0x8(%ebp),%eax
c0007f96:	e9 2c 01 00 00       	jmp    c00080c7 <sys_getcwd+0x1df>
/work/x86_os_my/fs/fs.c:825
	}

	memset(buf, 0, size);
c0007f9b:	83 ec 04             	sub    $0x4,%esp
c0007f9e:	ff 75 0c             	pushl  0xc(%ebp)
c0007fa1:	6a 00                	push   $0x0
c0007fa3:	ff 75 08             	pushl  0x8(%ebp)
c0007fa6:	e8 d9 b7 ff ff       	call   c0003784 <memset>
c0007fab:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:826
	char full_path_reverse[MAX_PATH_LEN] = {0};	// 用来做全路径缓冲区
c0007fae:	8d 85 e2 fd ff ff    	lea    -0x21e(%ebp),%eax
c0007fb4:	b9 00 02 00 00       	mov    $0x200,%ecx
c0007fb9:	bb 00 00 00 00       	mov    $0x0,%ebx
c0007fbe:	89 18                	mov    %ebx,(%eax)
c0007fc0:	89 5c 08 fc          	mov    %ebx,-0x4(%eax,%ecx,1)
c0007fc4:	8d 50 04             	lea    0x4(%eax),%edx
c0007fc7:	83 e2 fc             	and    $0xfffffffc,%edx
c0007fca:	29 d0                	sub    %edx,%eax
c0007fcc:	01 c1                	add    %eax,%ecx
c0007fce:	83 e1 fc             	and    $0xfffffffc,%ecx
c0007fd1:	c1 e9 02             	shr    $0x2,%ecx
c0007fd4:	89 d7                	mov    %edx,%edi
c0007fd6:	89 d8                	mov    %ebx,%eax
c0007fd8:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/fs/fs.c:831

	/* 从下往上逐层找父目录,直到找到根目录为止.
	 * 当child_inode_nr为根目录的inode编号(0)时停止,
	 * 即已经查看完根目录中的目录项 */
	while ((child_inode_nr)) {
c0007fda:	eb 52                	jmp    c000802e <sys_getcwd+0x146>
/work/x86_os_my/fs/fs.c:832
		parent_inode_nr = get_parent_dir_inode_nr(child_inode_nr, io_buf);
c0007fdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0007fdf:	83 ec 08             	sub    $0x8,%esp
c0007fe2:	ff 75 f0             	pushl  -0x10(%ebp)
c0007fe5:	50                   	push   %eax
c0007fe6:	e8 96 fc ff ff       	call   c0007c81 <get_parent_dir_inode_nr>
c0007feb:	83 c4 10             	add    $0x10,%esp
c0007fee:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:833
		if (get_child_dir_name(parent_inode_nr, child_inode_nr, full_path_reverse, io_buf) == -1) {	// 或未找到名字,失败退出
c0007ff1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0007ff4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0007ff7:	ff 75 f0             	pushl  -0x10(%ebp)
c0007ffa:	8d 8d e2 fd ff ff    	lea    -0x21e(%ebp),%ecx
c0008000:	51                   	push   %ecx
c0008001:	52                   	push   %edx
c0008002:	50                   	push   %eax
c0008003:	e8 3d fd ff ff       	call   c0007d45 <get_child_dir_name>
c0008008:	83 c4 10             	add    $0x10,%esp
c000800b:	83 f8 ff             	cmp    $0xffffffff,%eax
c000800e:	75 18                	jne    c0008028 <sys_getcwd+0x140>
/work/x86_os_my/fs/fs.c:834
			sys_free(io_buf);
c0008010:	83 ec 0c             	sub    $0xc,%esp
c0008013:	ff 75 f0             	pushl  -0x10(%ebp)
c0008016:	e8 9f b2 ff ff       	call   c00032ba <sys_free>
c000801b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:835
			return NULL;
c000801e:	b8 00 00 00 00       	mov    $0x0,%eax
c0008023:	e9 9f 00 00 00       	jmp    c00080c7 <sys_getcwd+0x1df>
/work/x86_os_my/fs/fs.c:837
		}
		child_inode_nr = parent_inode_nr;
c0008028:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000802b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:831
	char full_path_reverse[MAX_PATH_LEN] = {0};	// 用来做全路径缓冲区

	/* 从下往上逐层找父目录,直到找到根目录为止.
	 * 当child_inode_nr为根目录的inode编号(0)时停止,
	 * 即已经查看完根目录中的目录项 */
	while ((child_inode_nr)) {
c000802e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0008032:	75 a8                	jne    c0007fdc <sys_getcwd+0xf4>
/work/x86_os_my/fs/fs.c:839
			sys_free(io_buf);
			return NULL;
		}
		child_inode_nr = parent_inode_nr;
	}
	ASSERT(strlen(full_path_reverse) <= size);
c0008034:	83 ec 0c             	sub    $0xc,%esp
c0008037:	8d 85 e2 fd ff ff    	lea    -0x21e(%ebp),%eax
c000803d:	50                   	push   %eax
c000803e:	e8 cb b8 ff ff       	call   c000390e <strlen>
c0008043:	83 c4 10             	add    $0x10,%esp
c0008046:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0008049:	76 4e                	jbe    c0008099 <sys_getcwd+0x1b1>
/work/x86_os_my/fs/fs.c:839 (discriminator 1)
c000804b:	68 74 c8 00 c0       	push   $0xc000c874
c0008050:	68 e0 c9 00 c0       	push   $0xc000c9e0
c0008055:	68 47 03 00 00       	push   $0x347
c000805a:	68 6d c1 00 c0       	push   $0xc000c16d
c000805f:	e8 7e a2 ff ff       	call   c00022e2 <panic_spin>
c0008064:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:844 (discriminator 1)
	/* 至此 full_path_reverse 中的路径是反着的,
	 * 即子目录在前(左),父目录在后(右) ,
	 * 现将full_path_reverse中的路径反置 */
	char* last_slash;	// 用于记录字符串中最后一个斜杠地址
	while ((last_slash = strrchr(full_path_reverse, '/'))) {
c0008067:	eb 30                	jmp    c0008099 <sys_getcwd+0x1b1>
/work/x86_os_my/fs/fs.c:845
		uint16_t len = strlen(buf);
c0008069:	83 ec 0c             	sub    $0xc,%esp
c000806c:	ff 75 08             	pushl  0x8(%ebp)
c000806f:	e8 9a b8 ff ff       	call   c000390e <strlen>
c0008074:	83 c4 10             	add    $0x10,%esp
c0008077:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
/work/x86_os_my/fs/fs.c:846
		strcpy(buf + len, last_slash);
c000807b:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
c000807f:	8b 45 08             	mov    0x8(%ebp),%eax
c0008082:	01 d0                	add    %edx,%eax
c0008084:	83 ec 08             	sub    $0x8,%esp
c0008087:	ff 75 e4             	pushl  -0x1c(%ebp)
c000808a:	50                   	push   %eax
c000808b:	e8 29 b8 ff ff       	call   c00038b9 <strcpy>
c0008090:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:848
		/* 在full_path_reverse中添加结束字符,做为下一次执行strcpy中last_slash的边界 */
		*last_slash = 0;
c0008093:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0008096:	c6 00 00             	movb   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:844
	ASSERT(strlen(full_path_reverse) <= size);
	/* 至此 full_path_reverse 中的路径是反着的,
	 * 即子目录在前(左),父目录在后(右) ,
	 * 现将full_path_reverse中的路径反置 */
	char* last_slash;	// 用于记录字符串中最后一个斜杠地址
	while ((last_slash = strrchr(full_path_reverse, '/'))) {
c0008099:	83 ec 08             	sub    $0x8,%esp
c000809c:	6a 2f                	push   $0x2f
c000809e:	8d 85 e2 fd ff ff    	lea    -0x21e(%ebp),%eax
c00080a4:	50                   	push   %eax
c00080a5:	e8 80 b9 ff ff       	call   c0003a2a <strrchr>
c00080aa:	83 c4 10             	add    $0x10,%esp
c00080ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c00080b0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00080b4:	75 b3                	jne    c0008069 <sys_getcwd+0x181>
/work/x86_os_my/fs/fs.c:850
		uint16_t len = strlen(buf);
		strcpy(buf + len, last_slash);
		/* 在full_path_reverse中添加结束字符,做为下一次执行strcpy中last_slash的边界 */
		*last_slash = 0;
	}
	sys_free(io_buf);
c00080b6:	83 ec 0c             	sub    $0xc,%esp
c00080b9:	ff 75 f0             	pushl  -0x10(%ebp)
c00080bc:	e8 f9 b1 ff ff       	call   c00032ba <sys_free>
c00080c1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:851
	return buf;
c00080c4:	8b 45 08             	mov    0x8(%ebp),%eax
/work/x86_os_my/fs/fs.c:852 (discriminator 2)
}
c00080c7:	8d 65 f8             	lea    -0x8(%ebp),%esp
c00080ca:	5b                   	pop    %ebx
c00080cb:	5f                   	pop    %edi
c00080cc:	5d                   	pop    %ebp
c00080cd:	c3                   	ret    

c00080ce <sys_chdir>:
sys_chdir():
/work/x86_os_my/fs/fs.c:855

/* 更改当前工作目录为绝对路径path,成功则返回0,失败返回-1 */
int32_t sys_chdir(const char* path) {
c00080ce:	55                   	push   %ebp
c00080cf:	89 e5                	mov    %esp,%ebp
c00080d1:	81 ec 18 02 00 00    	sub    $0x218,%esp
/work/x86_os_my/fs/fs.c:856
	int32_t ret = -1;
c00080d7:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:858
	struct path_search_record searched_record;
	memset(&searched_record, 0, sizeof(struct path_search_record));
c00080de:	83 ec 04             	sub    $0x4,%esp
c00080e1:	68 08 02 00 00       	push   $0x208
c00080e6:	6a 00                	push   $0x0
c00080e8:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c00080ee:	50                   	push   %eax
c00080ef:	e8 90 b6 ff ff       	call   c0003784 <memset>
c00080f4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:859
	int inode_no = search_file(path, &searched_record);
c00080f7:	83 ec 08             	sub    $0x8,%esp
c00080fa:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
c0008100:	50                   	push   %eax
c0008101:	ff 75 08             	pushl  0x8(%ebp)
c0008104:	e8 e2 ea ff ff       	call   c0006beb <search_file>
c0008109:	83 c4 10             	add    $0x10,%esp
c000810c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:860
	if (inode_no != -1) {
c000810f:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0008113:	74 34                	je     c0008149 <sys_chdir+0x7b>
/work/x86_os_my/fs/fs.c:861
		if (searched_record.file_type == FT_DIRECTORY) {
c0008115:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008118:	83 f8 02             	cmp    $0x2,%eax
c000811b:	75 19                	jne    c0008136 <sys_chdir+0x68>
/work/x86_os_my/fs/fs.c:862
			running_thread()->cwd_inode_nr = inode_no;
c000811d:	e8 49 ba ff ff       	call   c0003b6b <running_thread>
c0008122:	89 c2                	mov    %eax,%edx
c0008124:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0008127:	89 82 0c 01 00 00    	mov    %eax,0x10c(%edx)
/work/x86_os_my/fs/fs.c:863
			ret = 0;
c000812d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0008134:	eb 13                	jmp    c0008149 <sys_chdir+0x7b>
/work/x86_os_my/fs/fs.c:865
		} else {
			printk("sys_chdir: %s is regular file or other!\n", path);
c0008136:	83 ec 08             	sub    $0x8,%esp
c0008139:	ff 75 08             	pushl  0x8(%ebp)
c000813c:	68 98 c8 00 c0       	push   $0xc000c898
c0008141:	e8 09 e3 ff ff       	call   c000644f <printk>
c0008146:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:868
		}
	}
	dir_close(searched_record.parent_dir);
c0008149:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000814c:	83 ec 0c             	sub    $0xc,%esp
c000814f:	50                   	push   %eax
c0008150:	e8 d3 1d 00 00       	call   c0009f28 <dir_close>
c0008155:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:869
	return ret;
c0008158:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:870
}
c000815b:	c9                   	leave  
c000815c:	c3                   	ret    

c000815d <sys_stat>:
sys_stat():
/work/x86_os_my/fs/fs.c:873

/* 在buf中填充文件结构相关信息,成功时返回0,失败返回-1 */
int32_t sys_stat(const char* path, struct stat* buf) {
c000815d:	55                   	push   %ebp
c000815e:	89 e5                	mov    %esp,%ebp
c0008160:	81 ec 28 02 00 00    	sub    $0x228,%esp
/work/x86_os_my/fs/fs.c:875
	/* 若直接查看根目录'/' */
	if (!strcmp(path, "/") || !strcmp(path, "/.") || !strcmp(path, "/..")) {
c0008166:	83 ec 08             	sub    $0x8,%esp
c0008169:	68 e7 c2 00 c0       	push   $0xc000c2e7
c000816e:	ff 75 08             	pushl  0x8(%ebp)
c0008171:	e8 e3 b7 ff ff       	call   c0003959 <strcmp>
c0008176:	83 c4 10             	add    $0x10,%esp
c0008179:	84 c0                	test   %al,%al
c000817b:	74 2e                	je     c00081ab <sys_stat+0x4e>
/work/x86_os_my/fs/fs.c:875 (discriminator 1)
c000817d:	83 ec 08             	sub    $0x8,%esp
c0008180:	68 e9 c2 00 c0       	push   $0xc000c2e9
c0008185:	ff 75 08             	pushl  0x8(%ebp)
c0008188:	e8 cc b7 ff ff       	call   c0003959 <strcmp>
c000818d:	83 c4 10             	add    $0x10,%esp
c0008190:	84 c0                	test   %al,%al
c0008192:	74 17                	je     c00081ab <sys_stat+0x4e>
/work/x86_os_my/fs/fs.c:875 (discriminator 2)
c0008194:	83 ec 08             	sub    $0x8,%esp
c0008197:	68 ec c2 00 c0       	push   $0xc000c2ec
c000819c:	ff 75 08             	pushl  0x8(%ebp)
c000819f:	e8 b5 b7 ff ff       	call   c0003959 <strcmp>
c00081a4:	83 c4 10             	add    $0x10,%esp
c00081a7:	84 c0                	test   %al,%al
c00081a9:	75 2b                	jne    c00081d6 <sys_stat+0x79>
/work/x86_os_my/fs/fs.c:876
		buf->st_filetype = FT_DIRECTORY;
c00081ab:	8b 45 0c             	mov    0xc(%ebp),%eax
c00081ae:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
/work/x86_os_my/fs/fs.c:877
		buf->st_ino = 0;
c00081b5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00081b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:878
		buf->st_size = root_dir.inode->i_size;
c00081be:	a1 60 0b 01 c0       	mov    0xc0010b60,%eax
c00081c3:	8b 50 04             	mov    0x4(%eax),%edx
c00081c6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00081c9:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/fs.c:879
		return 0;
c00081cc:	b8 00 00 00 00       	mov    $0x0,%eax
c00081d1:	e9 af 00 00 00       	jmp    c0008285 <sys_stat+0x128>
/work/x86_os_my/fs/fs.c:882
	}

	int32_t ret = -1;	// 默认返回值
c00081d6:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
/work/x86_os_my/fs/fs.c:884
	struct path_search_record searched_record;
	memset(&searched_record, 0, sizeof(struct path_search_record));   // 记得初始化或清0,否则栈中信息不知道是什么
c00081dd:	83 ec 04             	sub    $0x4,%esp
c00081e0:	68 08 02 00 00       	push   $0x208
c00081e5:	6a 00                	push   $0x0
c00081e7:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c00081ed:	50                   	push   %eax
c00081ee:	e8 91 b5 ff ff       	call   c0003784 <memset>
c00081f3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:885
	int inode_no = search_file(path, &searched_record);
c00081f6:	83 ec 08             	sub    $0x8,%esp
c00081f9:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c00081ff:	50                   	push   %eax
c0008200:	ff 75 08             	pushl  0x8(%ebp)
c0008203:	e8 e3 e9 ff ff       	call   c0006beb <search_file>
c0008208:	83 c4 10             	add    $0x10,%esp
c000820b:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:886
	if (inode_no != -1) {
c000820e:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0008212:	74 4c                	je     c0008260 <sys_stat+0x103>
/work/x86_os_my/fs/fs.c:887
		struct inode* obj_inode = inode_open(cur_part, inode_no);   // 只为获得文件大小
c0008214:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008217:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000821c:	83 ec 08             	sub    $0x8,%esp
c000821f:	52                   	push   %edx
c0008220:	50                   	push   %eax
c0008221:	e8 19 04 00 00       	call   c000863f <inode_open>
c0008226:	83 c4 10             	add    $0x10,%esp
c0008229:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:888
		buf->st_size = obj_inode->i_size;
c000822c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000822f:	8b 50 04             	mov    0x4(%eax),%edx
c0008232:	8b 45 0c             	mov    0xc(%ebp),%eax
c0008235:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/fs.c:889
		inode_close(obj_inode);
c0008238:	83 ec 0c             	sub    $0xc,%esp
c000823b:	ff 75 ec             	pushl  -0x14(%ebp)
c000823e:	e8 42 05 00 00       	call   c0008785 <inode_close>
c0008243:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:890
		buf->st_filetype = searched_record.file_type;
c0008246:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0008249:	8b 45 0c             	mov    0xc(%ebp),%eax
c000824c:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/fs/fs.c:891
		buf->st_ino = inode_no;
c000824f:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008252:	8b 45 0c             	mov    0xc(%ebp),%eax
c0008255:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/fs.c:892
		ret = 0;
c0008257:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000825e:	eb 13                	jmp    c0008273 <sys_stat+0x116>
/work/x86_os_my/fs/fs.c:894
	} else {
		printk("sys_stat: %s not found\n", path);
c0008260:	83 ec 08             	sub    $0x8,%esp
c0008263:	ff 75 08             	pushl  0x8(%ebp)
c0008266:	68 c1 c8 00 c0       	push   $0xc000c8c1
c000826b:	e8 df e1 ff ff       	call   c000644f <printk>
c0008270:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:896
	}
	dir_close(searched_record.parent_dir);
c0008273:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0008276:	83 ec 0c             	sub    $0xc,%esp
c0008279:	50                   	push   %eax
c000827a:	e8 a9 1c 00 00       	call   c0009f28 <dir_close>
c000827f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:897
	return ret;
c0008282:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/fs.c:898 (discriminator 1)
}
c0008285:	c9                   	leave  
c0008286:	c3                   	ret    

c0008287 <filesys_init>:
filesys_init():
/work/x86_os_my/fs/fs.c:910
 * 只支持 partition_format 函数创建的文件系统，其魔数等于 0x19590318
 * 三层循环：遍历通道，遍历通道中的硬盘，遍历硬盘上的分区
 * 全局变量 channel_cnt 通道数，定义在 ide.c
 * 全局变量 channels 结构体，定义在 ide.c
 */
void filesys_init() {
c0008287:	55                   	push   %ebp
c0008288:	89 e5                	mov    %esp,%ebp
c000828a:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/fs/fs.c:911
	uint8_t channel_no = 0, dev_no, part_idx = 0;
c000828d:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
c0008291:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
/work/x86_os_my/fs/fs.c:914

	/* sb_buf用来存储从硬盘上读入的超级块 */
	struct super_block* sb_buf = (struct super_block*)sys_malloc(SECTOR_SIZE);
c0008295:	83 ec 0c             	sub    $0xc,%esp
c0008298:	68 00 02 00 00       	push   $0x200
c000829d:	e8 eb a9 ff ff       	call   c0002c8d <sys_malloc>
c00082a2:	83 c4 10             	add    $0x10,%esp
c00082a5:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/fs.c:915
	if (sb_buf == NULL) {
c00082a8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c00082ac:	75 1c                	jne    c00082ca <filesys_init+0x43>
/work/x86_os_my/fs/fs.c:916
		PANIC("alloc memory failed!");
c00082ae:	68 58 c1 00 c0       	push   $0xc000c158
c00082b3:	68 ec c9 00 c0       	push   $0xc000c9ec
c00082b8:	68 94 03 00 00       	push   $0x394
c00082bd:	68 6d c1 00 c0       	push   $0xc000c16d
c00082c2:	e8 1b a0 ff ff       	call   c00022e2 <panic_spin>
c00082c7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:919
	}

	printk("searching filesystem......\n");
c00082ca:	83 ec 0c             	sub    $0xc,%esp
c00082cd:	68 d9 c8 00 c0       	push   $0xc000c8d9
c00082d2:	e8 78 e1 ff ff       	call   c000644f <printk>
c00082d7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:921
	/* 遍历通道 */
	while (channel_no < channel_cnt) {
c00082da:	e9 1a 01 00 00       	jmp    c00083f9 <filesys_init+0x172>
/work/x86_os_my/fs/fs.c:922
		dev_no = 0;
c00082df:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
/work/x86_os_my/fs/fs.c:924
		/* 遍历通道里的硬盘 */
		while(dev_no < 2) {
c00082e3:	e9 fd 00 00 00       	jmp    c00083e5 <filesys_init+0x15e>
/work/x86_os_my/fs/fs.c:925
			if (dev_no == 0) {		// 跨过裸盘hd60M.img
c00082e8:	80 7d f6 00          	cmpb   $0x0,-0xa(%ebp)
c00082ec:	75 0f                	jne    c00082fd <filesys_init+0x76>
/work/x86_os_my/fs/fs.c:926
				dev_no++;
c00082ee:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c00082f2:	83 c0 01             	add    $0x1,%eax
c00082f5:	88 45 f6             	mov    %al,-0xa(%ebp)
/work/x86_os_my/fs/fs.c:927
				continue;
c00082f8:	e9 e8 00 00 00       	jmp    c00083e5 <filesys_init+0x15e>
/work/x86_os_my/fs/fs.c:929
			}
			struct disk* hd = &channels[channel_no].devices[dev_no];
c00082fd:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008301:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
c0008305:	69 d2 10 03 00 00    	imul   $0x310,%edx,%edx
c000830b:	69 c0 60 06 00 00    	imul   $0x660,%eax,%eax
c0008311:	01 d0                	add    %edx,%eax
c0008313:	83 c0 40             	add    $0x40,%eax
c0008316:	05 00 fd 00 c0       	add    $0xc000fd00,%eax
c000831b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/fs.c:930
			struct partition* part = hd->prim_parts;	// 主分区数组
c000831e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0008321:	83 c0 10             	add    $0x10,%eax
c0008324:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:932
			/* 遍历硬盘里的分区 */
			while(part_idx < 12) {						// 4个主分区+8个逻辑
c0008327:	e9 a5 00 00 00       	jmp    c00083d1 <filesys_init+0x14a>
/work/x86_os_my/fs/fs.c:933
				if (part_idx == 4) {
c000832c:	80 7d f5 04          	cmpb   $0x4,-0xb(%ebp)
c0008330:	75 0b                	jne    c000833d <filesys_init+0xb6>
/work/x86_os_my/fs/fs.c:934
					part = hd->logic_parts;				// 逻辑分区数组
c0008332:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0008335:	05 10 01 00 00       	add    $0x110,%eax
c000833a:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:939
				}

				/* channels数组是全局变量,默认值为0
				 * 固 channels.disk.partition.sec_cnt 在未初始化时，也为0 */
				if (part->sec_cnt != 0) {	// 如果分区存在，以sec_cnt是否为0当判断依据
c000833d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0008340:	8b 40 04             	mov    0x4(%eax),%eax
c0008343:	85 c0                	test   %eax,%eax
c0008345:	74 7c                	je     c00083c3 <filesys_init+0x13c>
/work/x86_os_my/fs/fs.c:940
					memset(sb_buf, 0, SECTOR_SIZE);
c0008347:	83 ec 04             	sub    $0x4,%esp
c000834a:	68 00 02 00 00       	push   $0x200
c000834f:	6a 00                	push   $0x0
c0008351:	ff 75 e8             	pushl  -0x18(%ebp)
c0008354:	e8 2b b4 ff ff       	call   c0003784 <memset>
c0008359:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:943

					/* 读出分区的超级块，根据魔数判断是否存在我们定义的文件系统  */
					ide_read(hd, part->start_lba + 1, sb_buf, 1);
c000835c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000835f:	8b 00                	mov    (%eax),%eax
c0008361:	83 c0 01             	add    $0x1,%eax
c0008364:	6a 01                	push   $0x1
c0008366:	ff 75 e8             	pushl  -0x18(%ebp)
c0008369:	50                   	push   %eax
c000836a:	ff 75 e4             	pushl  -0x1c(%ebp)
c000836d:	e8 64 d6 ff ff       	call   c00059d6 <ide_read>
c0008372:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:944
					if (sb_buf->magic == 0x19590318) {
c0008375:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0008378:	8b 00                	mov    (%eax),%eax
c000837a:	3d 18 03 59 19       	cmp    $0x19590318,%eax
c000837f:	75 19                	jne    c000839a <filesys_init+0x113>
/work/x86_os_my/fs/fs.c:945
						printk("%s has filesystem\n", part->name);
c0008381:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0008384:	83 c0 14             	add    $0x14,%eax
c0008387:	83 ec 08             	sub    $0x8,%esp
c000838a:	50                   	push   %eax
c000838b:	68 f5 c8 00 c0       	push   $0xc000c8f5
c0008390:	e8 ba e0 ff ff       	call   c000644f <printk>
c0008395:	83 c4 10             	add    $0x10,%esp
c0008398:	eb 29                	jmp    c00083c3 <filesys_init+0x13c>
/work/x86_os_my/fs/fs.c:948
					} else {
						// 不存在我们的文件系统，则进行格式化
						printk("formatting %s`s partition %s......\n", hd->name, part->name);
c000839a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000839d:	8d 50 14             	lea    0x14(%eax),%edx
c00083a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00083a3:	83 ec 04             	sub    $0x4,%esp
c00083a6:	52                   	push   %edx
c00083a7:	50                   	push   %eax
c00083a8:	68 08 c9 00 c0       	push   $0xc000c908
c00083ad:	e8 9d e0 ff ff       	call   c000644f <printk>
c00083b2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:949
						partition_format(part);
c00083b5:	83 ec 0c             	sub    $0xc,%esp
c00083b8:	ff 75 f0             	pushl  -0x10(%ebp)
c00083bb:	e8 f6 e2 ff ff       	call   c00066b6 <partition_format>
c00083c0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:952
					}
				}
				part_idx++;
c00083c3:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
c00083c7:	83 c0 01             	add    $0x1,%eax
c00083ca:	88 45 f5             	mov    %al,-0xb(%ebp)
/work/x86_os_my/fs/fs.c:953
				part++;
c00083cd:	83 45 f0 40          	addl   $0x40,-0x10(%ebp)
/work/x86_os_my/fs/fs.c:932
				continue;
			}
			struct disk* hd = &channels[channel_no].devices[dev_no];
			struct partition* part = hd->prim_parts;	// 主分区数组
			/* 遍历硬盘里的分区 */
			while(part_idx < 12) {						// 4个主分区+8个逻辑
c00083d1:	80 7d f5 0b          	cmpb   $0xb,-0xb(%ebp)
c00083d5:	0f 86 51 ff ff ff    	jbe    c000832c <filesys_init+0xa5>
/work/x86_os_my/fs/fs.c:955
					}
				}
				part_idx++;
				part++;
			}	/* end of 遍历分区 */
			dev_no++;
c00083db:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c00083df:	83 c0 01             	add    $0x1,%eax
c00083e2:	88 45 f6             	mov    %al,-0xa(%ebp)
/work/x86_os_my/fs/fs.c:924
	printk("searching filesystem......\n");
	/* 遍历通道 */
	while (channel_no < channel_cnt) {
		dev_no = 0;
		/* 遍历通道里的硬盘 */
		while(dev_no < 2) {
c00083e5:	80 7d f6 01          	cmpb   $0x1,-0xa(%ebp)
c00083e9:	0f 86 f9 fe ff ff    	jbe    c00082e8 <filesys_init+0x61>
/work/x86_os_my/fs/fs.c:957
				part_idx++;
				part++;
			}	/* end of 遍历分区 */
			dev_no++;
		}	/* end of 遍历硬盘 */
		channel_no++;
c00083ef:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00083f3:	83 c0 01             	add    $0x1,%eax
c00083f6:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/fs.c:921
		PANIC("alloc memory failed!");
	}

	printk("searching filesystem......\n");
	/* 遍历通道 */
	while (channel_no < channel_cnt) {
c00083f9:	0f b6 05 e0 fc 00 c0 	movzbl 0xc000fce0,%eax
c0008400:	38 45 f7             	cmp    %al,-0x9(%ebp)
c0008403:	0f 82 d6 fe ff ff    	jb     c00082df <filesys_init+0x58>
/work/x86_os_my/fs/fs.c:959
			}	/* end of 遍历分区 */
			dev_no++;
		}	/* end of 遍历硬盘 */
		channel_no++;
	}	/* end of 遍历通道 */
	sys_free(sb_buf);
c0008409:	83 ec 0c             	sub    $0xc,%esp
c000840c:	ff 75 e8             	pushl  -0x18(%ebp)
c000840f:	e8 a6 ae ff ff       	call   c00032ba <sys_free>
c0008414:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:964


	/* 挂载分区 */
	/* 默认操作的分区 */
	char default_part[8] = "sdb1";
c0008417:	c7 45 dc 73 64 62 31 	movl   $0x31626473,-0x24(%ebp)
c000841e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
/work/x86_os_my/fs/fs.c:975
	参数：
	partition_list 是所有分区的链表
	mount_partition 是挂载分区的函数
	(int)default_part 将数组地址转换成整型作为 mount_partition 的参数
	*/
	list_traversal(&partition_list, mount_partition, (int)default_part);
c0008425:	8d 45 dc             	lea    -0x24(%ebp),%eax
c0008428:	83 ec 04             	sub    $0x4,%esp
c000842b:	50                   	push   %eax
c000842c:	68 ab 64 00 c0       	push   $0xc00064ab
c0008431:	68 c0 09 01 c0       	push   $0xc00109c0
c0008436:	e8 88 bf ff ff       	call   c00043c3 <list_traversal>
c000843b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:979


	/* 将当前分区的根目录打开 + 初始化文件表 */
	open_root_dir(cur_part);
c000843e:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0008443:	83 ec 0c             	sub    $0xc,%esp
c0008446:	50                   	push   %eax
c0008447:	e8 94 18 00 00       	call   c0009ce0 <open_root_dir>
c000844c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/fs.c:980
	uint32_t fd_idx = 0;
c000844f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/fs.c:981
	while (fd_idx < MAX_FILE_OPEN) {
c0008456:	eb 1d                	jmp    c0008475 <filesys_init+0x1ee>
/work/x86_os_my/fs/fs.c:982
		file_table[fd_idx++].fd_inode = NULL;
c0008458:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000845b:	8d 42 01             	lea    0x1(%edx),%eax
c000845e:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0008461:	89 d0                	mov    %edx,%eax
c0008463:	01 c0                	add    %eax,%eax
c0008465:	01 d0                	add    %edx,%eax
c0008467:	c1 e0 02             	shl    $0x2,%eax
c000846a:	05 e8 09 01 c0       	add    $0xc00109e8,%eax
c000846f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/fs.c:981


	/* 将当前分区的根目录打开 + 初始化文件表 */
	open_root_dir(cur_part);
	uint32_t fd_idx = 0;
	while (fd_idx < MAX_FILE_OPEN) {
c0008475:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
c0008479:	76 dd                	jbe    c0008458 <filesys_init+0x1d1>
/work/x86_os_my/fs/fs.c:984
		file_table[fd_idx++].fd_inode = NULL;
	}
}
c000847b:	90                   	nop
c000847c:	c9                   	leave  
c000847d:	c3                   	ret    

c000847e <inode_locate>:
inode_locate():
/work/x86_os_my/fs/inode.c:23
};

/* 获取inode所在的扇区和扇区内的偏移量
 * out: inode_pos
 */
static void inode_locate(struct partition* part, uint32_t inode_no, struct inode_position* inode_pos) {
c000847e:	55                   	push   %ebp
c000847f:	89 e5                	mov    %esp,%ebp
c0008481:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/fs/inode.c:25
	/* inode_table在硬盘上是连续的 */
	ASSERT(inode_no < 4096);
c0008484:	81 7d 0c ff 0f 00 00 	cmpl   $0xfff,0xc(%ebp)
c000848b:	76 19                	jbe    c00084a6 <inode_locate+0x28>
/work/x86_os_my/fs/inode.c:25 (discriminator 1)
c000848d:	68 fc c9 00 c0       	push   $0xc000c9fc
c0008492:	68 84 ca 00 c0       	push   $0xc000ca84
c0008497:	6a 19                	push   $0x19
c0008499:	68 0c ca 00 c0       	push   $0xc000ca0c
c000849e:	e8 3f 9e ff ff       	call   c00022e2 <panic_spin>
c00084a3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:26
	uint32_t inode_table_lba = part->sb->inode_table_lba;
c00084a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00084a9:	8b 40 1c             	mov    0x1c(%eax),%eax
c00084ac:	8b 40 20             	mov    0x20(%eax),%eax
c00084af:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/inode.c:28

	uint32_t inode_size = sizeof(struct inode);
c00084b2:	c7 45 f0 4c 00 00 00 	movl   $0x4c,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:29
	uint32_t off_size = inode_no * inode_size;	// 第inode_no号inode相对于inode_table_lba的字节偏移量
c00084b9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00084bc:	0f af 45 f0          	imul   -0x10(%ebp),%eax
c00084c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:30
	uint32_t off_sec  = off_size / 512;			// 第inode_no号inode相对于inode_table_lba的扇区偏移量
c00084c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00084c6:	c1 e8 09             	shr    $0x9,%eax
c00084c9:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/inode.c:31
	uint32_t off_size_in_sec = off_size % 512;	// 待查找的inode所在扇区中的起始地址
c00084cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00084cf:	25 ff 01 00 00       	and    $0x1ff,%eax
c00084d4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/inode.c:34

	/* 判断此inode是否跨越2个扇区 */
	uint32_t left_in_sec = 512 - off_size_in_sec;
c00084d7:	b8 00 02 00 00       	mov    $0x200,%eax
c00084dc:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c00084df:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/inode.c:36
	// 若扇区内剩下的空间不足以容纳一个inode,必然是inode跨越了2个扇区
	if (left_in_sec < inode_size ) {
c00084e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00084e5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00084e8:	73 0b                	jae    c00084f5 <inode_locate+0x77>
/work/x86_os_my/fs/inode.c:37
		inode_pos->two_sec = true;	//跨越了
c00084ea:	8b 45 10             	mov    0x10(%ebp),%eax
c00084ed:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
c00084f3:	eb 09                	jmp    c00084fe <inode_locate+0x80>
/work/x86_os_my/fs/inode.c:39
	} else {
		inode_pos->two_sec = false;
c00084f5:	8b 45 10             	mov    0x10(%ebp),%eax
c00084f8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/inode.c:41
	}
	inode_pos->sec_lba = inode_table_lba + off_sec;
c00084fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0008501:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0008504:	01 c2                	add    %eax,%edx
c0008506:	8b 45 10             	mov    0x10(%ebp),%eax
c0008509:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/inode.c:42
	inode_pos->off_size = off_size_in_sec;
c000850c:	8b 45 10             	mov    0x10(%ebp),%eax
c000850f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0008512:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/fs/inode.c:43
}
c0008515:	90                   	nop
c0008516:	c9                   	leave  
c0008517:	c3                   	ret    

c0008518 <inode_sync>:
inode_sync():
/work/x86_os_my/fs/inode.c:51
io_buf是用于硬盘io的缓冲区，它由主调函数提供！
原因是
一般情况下把内存中的数据同步到硬盘都是最后的操作，其前已经做了大量工作，
若到这最后一步时才申请内存失败，前面的所有操作都白费了，还要回滚到之前的旧状态，代价太大
*/
void inode_sync(struct partition* part, struct inode* inode, void* io_buf) {
c0008518:	55                   	push   %ebp
c0008519:	89 e5                	mov    %esp,%ebp
c000851b:	83 ec 68             	sub    $0x68,%esp
/work/x86_os_my/fs/inode.c:52
	uint8_t inode_no = inode->i_no;
c000851e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0008521:	8b 00                	mov    (%eax),%eax
c0008523:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/inode.c:54
	struct inode_position inode_pos;
	inode_locate(part, inode_no, &inode_pos);	// inode位置信息会存入inode_pos
c0008526:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000852a:	83 ec 04             	sub    $0x4,%esp
c000852d:	8d 55 e4             	lea    -0x1c(%ebp),%edx
c0008530:	52                   	push   %edx
c0008531:	50                   	push   %eax
c0008532:	ff 75 08             	pushl  0x8(%ebp)
c0008535:	e8 44 ff ff ff       	call   c000847e <inode_locate>
c000853a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:55
	ASSERT(inode_pos.sec_lba <= (part->start_lba + part->sec_cnt));
c000853d:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0008540:	8b 45 08             	mov    0x8(%ebp),%eax
c0008543:	8b 08                	mov    (%eax),%ecx
c0008545:	8b 45 08             	mov    0x8(%ebp),%eax
c0008548:	8b 40 04             	mov    0x4(%eax),%eax
c000854b:	01 c8                	add    %ecx,%eax
c000854d:	39 c2                	cmp    %eax,%edx
c000854f:	76 19                	jbe    c000856a <inode_sync+0x52>
/work/x86_os_my/fs/inode.c:55 (discriminator 1)
c0008551:	68 18 ca 00 c0       	push   $0xc000ca18
c0008556:	68 94 ca 00 c0       	push   $0xc000ca94
c000855b:	6a 37                	push   $0x37
c000855d:	68 0c ca 00 c0       	push   $0xc000ca0c
c0008562:	e8 7b 9d ff ff       	call   c00022e2 <panic_spin>
c0008567:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:62
	/* 硬盘中的inode中的成员inode_tag和i_open_cnts是不需要的，
	* 它们只在内存中有效，记录链表位置和被多少进程共享，
	* 将inode同步到硬盘时,清掉这三项即可。
	*/
	struct inode pure_inode;
	memcpy(&pure_inode, inode, sizeof(struct inode));
c000856a:	83 ec 04             	sub    $0x4,%esp
c000856d:	6a 4c                	push   $0x4c
c000856f:	ff 75 0c             	pushl  0xc(%ebp)
c0008572:	8d 45 98             	lea    -0x68(%ebp),%eax
c0008575:	50                   	push   %eax
c0008576:	e8 5b b2 ff ff       	call   c00037d6 <memcpy>
c000857b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:63
	pure_inode.i_open_cnts = 0;
c000857e:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
/work/x86_os_my/fs/inode.c:64
	pure_inode.write_deny = false;	// 置为false,以保证在硬盘中读出时为可写
c0008585:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
/work/x86_os_my/fs/inode.c:65
	pure_inode.inode_tag.prev = pure_inode.inode_tag.next = NULL;
c000858c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
c0008593:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0008596:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/inode.c:67

	char* inode_buf = (char*)io_buf;
c0008599:	8b 45 10             	mov    0x10(%ebp),%eax
c000859c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:69
	// 若inode结构，跨了两个扇区,就要读出两个扇区再写入两个扇区
	if (inode_pos.two_sec) {
c000859f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00085a2:	85 c0                	test   %eax,%eax
c00085a4:	74 4c                	je     c00085f2 <inode_sync+0xda>
/work/x86_os_my/fs/inode.c:72
		/* 读写硬盘是以扇区为单位的
		所以需要将待写入的inode结构拼入到这2个扇区的中间位置 */
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 2);	// inode_table在格式化时，写入硬盘是连续写入的，所以读入2块扇区
c00085a6:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00085a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00085ac:	8b 40 08             	mov    0x8(%eax),%eax
c00085af:	6a 02                	push   $0x2
c00085b1:	ff 75 f0             	pushl  -0x10(%ebp)
c00085b4:	52                   	push   %edx
c00085b5:	50                   	push   %eax
c00085b6:	e8 1b d4 ff ff       	call   c00059d6 <ide_read>
c00085bb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:73
		memcpy((inode_buf + inode_pos.off_size), &pure_inode, sizeof(struct inode));	// inode_buf+inode在扇区中的偏移
c00085be:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00085c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00085c4:	01 c2                	add    %eax,%edx
c00085c6:	83 ec 04             	sub    $0x4,%esp
c00085c9:	6a 4c                	push   $0x4c
c00085cb:	8d 45 98             	lea    -0x68(%ebp),%eax
c00085ce:	50                   	push   %eax
c00085cf:	52                   	push   %edx
c00085d0:	e8 01 b2 ff ff       	call   c00037d6 <memcpy>
c00085d5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:74
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
c00085d8:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00085db:	8b 45 08             	mov    0x8(%ebp),%eax
c00085de:	8b 40 08             	mov    0x8(%eax),%eax
c00085e1:	6a 02                	push   $0x2
c00085e3:	ff 75 f0             	pushl  -0x10(%ebp)
c00085e6:	52                   	push   %edx
c00085e7:	50                   	push   %eax
c00085e8:	e8 5d d5 ff ff       	call   c0005b4a <ide_write>
c00085ed:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:81
		// 若inode结构，只在一个扇区中
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
		memcpy((inode_buf + inode_pos.off_size), &pure_inode, sizeof(struct inode));	// inode_buf+inode在扇区中的偏移
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
	}
}
c00085f0:	eb 4a                	jmp    c000863c <inode_sync+0x124>
/work/x86_os_my/fs/inode.c:77
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 2);	// inode_table在格式化时，写入硬盘是连续写入的，所以读入2块扇区
		memcpy((inode_buf + inode_pos.off_size), &pure_inode, sizeof(struct inode));	// inode_buf+inode在扇区中的偏移
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
	} else {
		// 若inode结构，只在一个扇区中
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
c00085f2:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00085f5:	8b 45 08             	mov    0x8(%ebp),%eax
c00085f8:	8b 40 08             	mov    0x8(%eax),%eax
c00085fb:	6a 01                	push   $0x1
c00085fd:	ff 75 f0             	pushl  -0x10(%ebp)
c0008600:	52                   	push   %edx
c0008601:	50                   	push   %eax
c0008602:	e8 cf d3 ff ff       	call   c00059d6 <ide_read>
c0008607:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:78
		memcpy((inode_buf + inode_pos.off_size), &pure_inode, sizeof(struct inode));	// inode_buf+inode在扇区中的偏移
c000860a:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000860d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0008610:	01 c2                	add    %eax,%edx
c0008612:	83 ec 04             	sub    $0x4,%esp
c0008615:	6a 4c                	push   $0x4c
c0008617:	8d 45 98             	lea    -0x68(%ebp),%eax
c000861a:	50                   	push   %eax
c000861b:	52                   	push   %edx
c000861c:	e8 b5 b1 ff ff       	call   c00037d6 <memcpy>
c0008621:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:79
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
c0008624:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0008627:	8b 45 08             	mov    0x8(%ebp),%eax
c000862a:	8b 40 08             	mov    0x8(%eax),%eax
c000862d:	6a 01                	push   $0x1
c000862f:	ff 75 f0             	pushl  -0x10(%ebp)
c0008632:	52                   	push   %edx
c0008633:	50                   	push   %eax
c0008634:	e8 11 d5 ff ff       	call   c0005b4a <ide_write>
c0008639:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:81
	}
}
c000863c:	90                   	nop
c000863d:	c9                   	leave  
c000863e:	c3                   	ret    

c000863f <inode_open>:
inode_open():
/work/x86_os_my/fs/inode.c:84

/* 根据i结点号，获取到相应的inode结构，插入到inode缓存队列，并返回它 */
struct inode* inode_open(struct partition* part, uint32_t inode_no) {
c000863f:	55                   	push   %ebp
c0008640:	89 e5                	mov    %esp,%ebp
c0008642:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/fs/inode.c:86
	/* 1.先在已打开inode链表中找inode，此链表作用是提速 */
	struct list_elem* elem = part->open_inodes.head.next;
c0008645:	8b 45 08             	mov    0x8(%ebp),%eax
c0008648:	8b 40 34             	mov    0x34(%eax),%eax
c000864b:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/inode.c:88
	struct inode* inode_found;
	while (elem != &part->open_inodes.tail) {
c000864e:	eb 33                	jmp    c0008683 <inode_open+0x44>
/work/x86_os_my/fs/inode.c:89
		inode_found = elem2entry(struct inode, inode_tag, elem);
c0008650:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0008653:	83 e8 44             	sub    $0x44,%eax
c0008656:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:90
		if (inode_found->i_no == inode_no) {
c0008659:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000865c:	8b 00                	mov    (%eax),%eax
c000865e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0008661:	75 17                	jne    c000867a <inode_open+0x3b>
/work/x86_os_my/fs/inode.c:91
			inode_found->i_open_cnts++;
c0008663:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008666:	8b 40 08             	mov    0x8(%eax),%eax
c0008669:	8d 50 01             	lea    0x1(%eax),%edx
c000866c:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000866f:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/fs/inode.c:92
			return inode_found;
c0008672:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008675:	e9 09 01 00 00       	jmp    c0008783 <inode_open+0x144>
/work/x86_os_my/fs/inode.c:94
		}
		elem = elem->next;
c000867a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000867d:	8b 40 04             	mov    0x4(%eax),%eax
c0008680:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/inode.c:88
/* 根据i结点号，获取到相应的inode结构，插入到inode缓存队列，并返回它 */
struct inode* inode_open(struct partition* part, uint32_t inode_no) {
	/* 1.先在已打开inode链表中找inode，此链表作用是提速 */
	struct list_elem* elem = part->open_inodes.head.next;
	struct inode* inode_found;
	while (elem != &part->open_inodes.tail) {
c0008683:	8b 45 08             	mov    0x8(%ebp),%eax
c0008686:	83 c0 38             	add    $0x38,%eax
c0008689:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c000868c:	75 c2                	jne    c0008650 <inode_open+0x11>
/work/x86_os_my/fs/inode.c:100
	}

	
	/* 2.open_inodes链表中找不到，从硬盘上读入此inode并加入到inode缓存链表 */
	struct inode_position inode_pos;	// 记录inode位置的结构
	inode_locate(part, inode_no, &inode_pos);
c000868e:	83 ec 04             	sub    $0x4,%esp
c0008691:	8d 45 d8             	lea    -0x28(%ebp),%eax
c0008694:	50                   	push   %eax
c0008695:	ff 75 0c             	pushl  0xc(%ebp)
c0008698:	ff 75 08             	pushl  0x8(%ebp)
c000869b:	e8 de fd ff ff       	call   c000847e <inode_locate>
c00086a0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:104

	/* 为使通过sys_malloc创建的新inode被所有任务共享，需要将inode置于内核空间
	故临时将cur_pbc->pgdir置为NULL，sys_malloc就会以为是从内核空间分配 */
	struct task_struct* cur = running_thread();
c00086a3:	e8 c3 b4 ff ff       	call   c0003b6b <running_thread>
c00086a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/inode.c:105
	uint32_t* cur_pagedir_bak = cur->pgdir;
c00086ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00086ae:	8b 40 54             	mov    0x54(%eax),%eax
c00086b1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/inode.c:106
	cur->pgdir = NULL;
c00086b4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00086b7:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
/work/x86_os_my/fs/inode.c:107
	inode_found = (struct inode*)sys_malloc(sizeof(struct inode));
c00086be:	83 ec 0c             	sub    $0xc,%esp
c00086c1:	6a 4c                	push   $0x4c
c00086c3:	e8 c5 a5 ff ff       	call   c0002c8d <sys_malloc>
c00086c8:	83 c4 10             	add    $0x10,%esp
c00086cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:108
	cur->pgdir = cur_pagedir_bak;	// 恢复pgdir
c00086ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00086d1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00086d4:	89 50 54             	mov    %edx,0x54(%eax)
/work/x86_os_my/fs/inode.c:111

	char* inode_buf;
	if (inode_pos.two_sec) {	// inode结构跨扇区了
c00086d7:	8b 45 d8             	mov    -0x28(%ebp),%eax
c00086da:	85 c0                	test   %eax,%eax
c00086dc:	74 2d                	je     c000870b <inode_open+0xcc>
/work/x86_os_my/fs/inode.c:112
		inode_buf = (char*)sys_malloc(1024);
c00086de:	83 ec 0c             	sub    $0xc,%esp
c00086e1:	68 00 04 00 00       	push   $0x400
c00086e6:	e8 a2 a5 ff ff       	call   c0002c8d <sys_malloc>
c00086eb:	83 c4 10             	add    $0x10,%esp
c00086ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:114
		// inode_table在格式化时，写入硬盘是连续写入的，所以可以连续读入2块扇区
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
c00086f1:	8b 55 dc             	mov    -0x24(%ebp),%edx
c00086f4:	8b 45 08             	mov    0x8(%ebp),%eax
c00086f7:	8b 40 08             	mov    0x8(%eax),%eax
c00086fa:	6a 02                	push   $0x2
c00086fc:	ff 75 f0             	pushl  -0x10(%ebp)
c00086ff:	52                   	push   %edx
c0008700:	50                   	push   %eax
c0008701:	e8 d0 d2 ff ff       	call   c00059d6 <ide_read>
c0008706:	83 c4 10             	add    $0x10,%esp
c0008709:	eb 2b                	jmp    c0008736 <inode_open+0xf7>
/work/x86_os_my/fs/inode.c:116
	} else {
		inode_buf = (char*)sys_malloc(512);
c000870b:	83 ec 0c             	sub    $0xc,%esp
c000870e:	68 00 02 00 00       	push   $0x200
c0008713:	e8 75 a5 ff ff       	call   c0002c8d <sys_malloc>
c0008718:	83 c4 10             	add    $0x10,%esp
c000871b:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:117
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
c000871e:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0008721:	8b 45 08             	mov    0x8(%ebp),%eax
c0008724:	8b 40 08             	mov    0x8(%eax),%eax
c0008727:	6a 01                	push   $0x1
c0008729:	ff 75 f0             	pushl  -0x10(%ebp)
c000872c:	52                   	push   %edx
c000872d:	50                   	push   %eax
c000872e:	e8 a3 d2 ff ff       	call   c00059d6 <ide_read>
c0008733:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:119
	}
	memcpy(inode_found, inode_buf + inode_pos.off_size, sizeof(struct inode));	// inode_buf+inode在扇区中的偏移
c0008736:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0008739:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000873c:	01 d0                	add    %edx,%eax
c000873e:	83 ec 04             	sub    $0x4,%esp
c0008741:	6a 4c                	push   $0x4c
c0008743:	50                   	push   %eax
c0008744:	ff 75 ec             	pushl  -0x14(%ebp)
c0008747:	e8 8a b0 ff ff       	call   c00037d6 <memcpy>
c000874c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:123

	
	/* 3.马上要用这个inode，固插入到队首 */
	list_push(&part->open_inodes, &inode_found->inode_tag);
c000874f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008752:	8d 50 44             	lea    0x44(%eax),%edx
c0008755:	8b 45 08             	mov    0x8(%ebp),%eax
c0008758:	83 c0 30             	add    $0x30,%eax
c000875b:	83 ec 08             	sub    $0x8,%esp
c000875e:	52                   	push   %edx
c000875f:	50                   	push   %eax
c0008760:	e8 8b bb ff ff       	call   c00042f0 <list_push>
c0008765:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:124
	inode_found->i_open_cnts = 1;
c0008768:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000876b:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/fs/inode.c:126

	sys_free(inode_buf);
c0008772:	83 ec 0c             	sub    $0xc,%esp
c0008775:	ff 75 f0             	pushl  -0x10(%ebp)
c0008778:	e8 3d ab ff ff       	call   c00032ba <sys_free>
c000877d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:127
	return inode_found;
c0008780:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/fs/inode.c:128 (discriminator 1)
}
c0008783:	c9                   	leave  
c0008784:	c3                   	ret    

c0008785 <inode_close>:
inode_close():
/work/x86_os_my/fs/inode.c:132

/* 关闭inode或减少inode的打开数 */
//1.从inode队列踢掉 2.释放内核内存池中的这个inode内存
void inode_close(struct inode* inode) {
c0008785:	55                   	push   %ebp
c0008786:	89 e5                	mov    %esp,%ebp
c0008788:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/inode.c:134
	/* 若没有进程再打开此文件,将此inode去掉并释放空间 */
	enum intr_status old_status = intr_disable();
c000878b:	e8 ae 91 ff ff       	call   c000193e <intr_disable>
c0008790:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/inode.c:135
	if (--inode->i_open_cnts == 0) {
c0008793:	8b 45 08             	mov    0x8(%ebp),%eax
c0008796:	8b 40 08             	mov    0x8(%eax),%eax
c0008799:	8d 50 ff             	lea    -0x1(%eax),%edx
c000879c:	8b 45 08             	mov    0x8(%ebp),%eax
c000879f:	89 50 08             	mov    %edx,0x8(%eax)
c00087a2:	8b 45 08             	mov    0x8(%ebp),%eax
c00087a5:	8b 40 08             	mov    0x8(%eax),%eax
c00087a8:	85 c0                	test   %eax,%eax
c00087aa:	75 44                	jne    c00087f0 <inode_close+0x6b>
/work/x86_os_my/fs/inode.c:136
		list_remove(&inode->inode_tag);
c00087ac:	8b 45 08             	mov    0x8(%ebp),%eax
c00087af:	83 c0 44             	add    $0x44,%eax
c00087b2:	83 ec 0c             	sub    $0xc,%esp
c00087b5:	50                   	push   %eax
c00087b6:	e8 71 bb ff ff       	call   c000432c <list_remove>
c00087bb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:139
		/* inode结构在内核空间，释放时要释放到内核内存池。
		pgdir为NULL时，sys_free认为是内核空间 */
		struct task_struct* cur = running_thread();
c00087be:	e8 a8 b3 ff ff       	call   c0003b6b <running_thread>
c00087c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:140
		uint32_t* cur_pagedir_bak = cur->pgdir;	// 进程自己页目录表的虚拟地址，加载到cr3时需转成物理地址
c00087c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00087c9:	8b 40 54             	mov    0x54(%eax),%eax
c00087cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:141
		cur->pgdir = NULL;
c00087cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00087d2:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
/work/x86_os_my/fs/inode.c:142
		sys_free(inode);
c00087d9:	83 ec 0c             	sub    $0xc,%esp
c00087dc:	ff 75 08             	pushl  0x8(%ebp)
c00087df:	e8 d6 aa ff ff       	call   c00032ba <sys_free>
c00087e4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:143
		cur->pgdir = cur_pagedir_bak;
c00087e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00087ea:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00087ed:	89 50 54             	mov    %edx,0x54(%eax)
/work/x86_os_my/fs/inode.c:145
	}
	intr_set_status(old_status);
c00087f0:	83 ec 0c             	sub    $0xc,%esp
c00087f3:	ff 75 f4             	pushl  -0xc(%ebp)
c00087f6:	e8 6c 91 ff ff       	call   c0001967 <intr_set_status>
c00087fb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:146
}
c00087fe:	90                   	nop
c00087ff:	c9                   	leave  
c0008800:	c3                   	ret    

c0008801 <inode_delete>:
inode_delete():
/work/x86_os_my/fs/inode.c:149

/* 将硬盘分区part上，inode管理的数据块清空 */
void inode_delete(struct partition* part, uint32_t inode_no, void* io_buf) {
c0008801:	55                   	push   %ebp
c0008802:	89 e5                	mov    %esp,%ebp
c0008804:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/inode.c:150
	ASSERT(inode_no < 4096);
c0008807:	81 7d 0c ff 0f 00 00 	cmpl   $0xfff,0xc(%ebp)
c000880e:	76 1c                	jbe    c000882c <inode_delete+0x2b>
/work/x86_os_my/fs/inode.c:150 (discriminator 1)
c0008810:	68 fc c9 00 c0       	push   $0xc000c9fc
c0008815:	68 a0 ca 00 c0       	push   $0xc000caa0
c000881a:	68 96 00 00 00       	push   $0x96
c000881f:	68 0c ca 00 c0       	push   $0xc000ca0c
c0008824:	e8 b9 9a ff ff       	call   c00022e2 <panic_spin>
c0008829:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:152
	struct inode_position inode_pos;
	inode_locate(part, inode_no, &inode_pos);	// 获取inode所在的扇区和扇区内的偏移量【这里是 inode_table 的空间】
c000882c:	83 ec 04             	sub    $0x4,%esp
c000882f:	8d 45 e8             	lea    -0x18(%ebp),%eax
c0008832:	50                   	push   %eax
c0008833:	ff 75 0c             	pushl  0xc(%ebp)
c0008836:	ff 75 08             	pushl  0x8(%ebp)
c0008839:	e8 40 fc ff ff       	call   c000847e <inode_locate>
c000883e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:153
	ASSERT(inode_pos.sec_lba <= (part->start_lba + part->sec_cnt));
c0008841:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0008844:	8b 45 08             	mov    0x8(%ebp),%eax
c0008847:	8b 08                	mov    (%eax),%ecx
c0008849:	8b 45 08             	mov    0x8(%ebp),%eax
c000884c:	8b 40 04             	mov    0x4(%eax),%eax
c000884f:	01 c8                	add    %ecx,%eax
c0008851:	39 c2                	cmp    %eax,%edx
c0008853:	76 1c                	jbe    c0008871 <inode_delete+0x70>
/work/x86_os_my/fs/inode.c:153 (discriminator 1)
c0008855:	68 18 ca 00 c0       	push   $0xc000ca18
c000885a:	68 a0 ca 00 c0       	push   $0xc000caa0
c000885f:	68 99 00 00 00       	push   $0x99
c0008864:	68 0c ca 00 c0       	push   $0xc000ca0c
c0008869:	e8 74 9a ff ff       	call   c00022e2 <panic_spin>
c000886e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:155

	char* inode_buf = (char*)io_buf;
c0008871:	8b 45 10             	mov    0x10(%ebp),%eax
c0008874:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/inode.c:156
	if (inode_pos.two_sec) {	// inode跨扇区,读入2个扇区
c0008877:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000887a:	85 c0                	test   %eax,%eax
c000887c:	74 4a                	je     c00088c8 <inode_delete+0xc7>
/work/x86_os_my/fs/inode.c:158
		/* 将原硬盘上的内容先读出来 */
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
c000887e:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0008881:	8b 45 08             	mov    0x8(%ebp),%eax
c0008884:	8b 40 08             	mov    0x8(%eax),%eax
c0008887:	6a 02                	push   $0x2
c0008889:	ff 75 f4             	pushl  -0xc(%ebp)
c000888c:	52                   	push   %edx
c000888d:	50                   	push   %eax
c000888e:	e8 43 d1 ff ff       	call   c00059d6 <ide_read>
c0008893:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:160
		/* 将inode_buf清0 */
		memset((inode_buf + inode_pos.off_size), 0, sizeof(struct inode));	//清零 inode_table 中的一个 inode 结构
c0008896:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008899:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000889c:	01 d0                	add    %edx,%eax
c000889e:	83 ec 04             	sub    $0x4,%esp
c00088a1:	6a 4c                	push   $0x4c
c00088a3:	6a 00                	push   $0x0
c00088a5:	50                   	push   %eax
c00088a6:	e8 d9 ae ff ff       	call   c0003784 <memset>
c00088ab:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:162
		/* 用清0的内存数据覆盖磁盘 */
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
c00088ae:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00088b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00088b4:	8b 40 08             	mov    0x8(%eax),%eax
c00088b7:	6a 02                	push   $0x2
c00088b9:	ff 75 f4             	pushl  -0xc(%ebp)
c00088bc:	52                   	push   %edx
c00088bd:	50                   	push   %eax
c00088be:	e8 87 d2 ff ff       	call   c0005b4a <ide_write>
c00088c3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:171
		/* 将inode_buf清0 */
		memset((inode_buf + inode_pos.off_size), 0, sizeof(struct inode));
		/* 用清0的内存数据覆盖磁盘 */
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
	}
}
c00088c6:	eb 48                	jmp    c0008910 <inode_delete+0x10f>
/work/x86_os_my/fs/inode.c:165
		memset((inode_buf + inode_pos.off_size), 0, sizeof(struct inode));	//清零 inode_table 中的一个 inode 结构
		/* 用清0的内存数据覆盖磁盘 */
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 2);
	} else {	// 未跨扇区,只读入1个扇区就好
		/* 将原硬盘上的内容先读出来 */
		ide_read(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
c00088c8:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00088cb:	8b 45 08             	mov    0x8(%ebp),%eax
c00088ce:	8b 40 08             	mov    0x8(%eax),%eax
c00088d1:	6a 01                	push   $0x1
c00088d3:	ff 75 f4             	pushl  -0xc(%ebp)
c00088d6:	52                   	push   %edx
c00088d7:	50                   	push   %eax
c00088d8:	e8 f9 d0 ff ff       	call   c00059d6 <ide_read>
c00088dd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:167
		/* 将inode_buf清0 */
		memset((inode_buf + inode_pos.off_size), 0, sizeof(struct inode));
c00088e0:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00088e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00088e6:	01 d0                	add    %edx,%eax
c00088e8:	83 ec 04             	sub    $0x4,%esp
c00088eb:	6a 4c                	push   $0x4c
c00088ed:	6a 00                	push   $0x0
c00088ef:	50                   	push   %eax
c00088f0:	e8 8f ae ff ff       	call   c0003784 <memset>
c00088f5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:169
		/* 用清0的内存数据覆盖磁盘 */
		ide_write(part->my_disk, inode_pos.sec_lba, inode_buf, 1);
c00088f8:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00088fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00088fe:	8b 40 08             	mov    0x8(%eax),%eax
c0008901:	6a 01                	push   $0x1
c0008903:	ff 75 f4             	pushl  -0xc(%ebp)
c0008906:	52                   	push   %edx
c0008907:	50                   	push   %eax
c0008908:	e8 3d d2 ff ff       	call   c0005b4a <ide_write>
c000890d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:171
	}
}
c0008910:	90                   	nop
c0008911:	c9                   	leave  
c0008912:	c3                   	ret    

c0008913 <inode_release>:
inode_release():
/work/x86_os_my/fs/inode.c:179
（1）inode 位图
（2）inode_table
（3）inode 中 i_sectors[0～11]中的直接块和一级间接索引块表 i_sectors[12]中的间接块
（4）一级间接索引块表本身的扇区地址
 */
void inode_release(struct partition* part, uint32_t inode_no) {
c0008913:	55                   	push   %ebp
c0008914:	89 e5                	mov    %esp,%ebp
c0008916:	57                   	push   %edi
c0008917:	81 ec 44 02 00 00    	sub    $0x244,%esp
/work/x86_os_my/fs/inode.c:180
	struct inode* inode_to_del = inode_open(part, inode_no);
c000891d:	83 ec 08             	sub    $0x8,%esp
c0008920:	ff 75 0c             	pushl  0xc(%ebp)
c0008923:	ff 75 08             	pushl  0x8(%ebp)
c0008926:	e8 14 fd ff ff       	call   c000863f <inode_open>
c000892b:	83 c4 10             	add    $0x10,%esp
c000892e:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/inode.c:181
	ASSERT(inode_to_del->i_no == inode_no);
c0008931:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0008934:	8b 00                	mov    (%eax),%eax
c0008936:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0008939:	74 1c                	je     c0008957 <inode_release+0x44>
/work/x86_os_my/fs/inode.c:181 (discriminator 1)
c000893b:	68 50 ca 00 c0       	push   $0xc000ca50
c0008940:	68 b0 ca 00 c0       	push   $0xc000cab0
c0008945:	68 b5 00 00 00       	push   $0xb5
c000894a:	68 0c ca 00 c0       	push   $0xc000ca0c
c000894f:	e8 8e 99 ff ff       	call   c00022e2 <panic_spin>
c0008954:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:184

	/* 1 回收inode占用的所有块 */
	uint8_t block_idx = 0, block_cnt = 12;
c0008957:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
c000895b:	c6 45 f6 0c          	movb   $0xc,-0xa(%ebp)
/work/x86_os_my/fs/inode.c:186
	uint32_t block_bitmap_idx;
	uint32_t all_blocks[140] = {0};	  //12个直接块+128个间接块
c000895f:	8d 95 b8 fd ff ff    	lea    -0x248(%ebp),%edx
c0008965:	b8 00 00 00 00       	mov    $0x0,%eax
c000896a:	b9 8c 00 00 00       	mov    $0x8c,%ecx
c000896f:	89 d7                	mov    %edx,%edi
c0008971:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/fs/inode.c:189

	/* a 先将前12个直接块存入all_blocks */
	while (block_idx < 12) {
c0008973:	eb 22                	jmp    c0008997 <inode_release+0x84>
/work/x86_os_my/fs/inode.c:190
		all_blocks[block_idx] = inode_to_del->i_sectors[block_idx];
c0008975:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008979:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
c000897d:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008980:	83 c1 04             	add    $0x4,%ecx
c0008983:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
c0008986:	89 94 85 b8 fd ff ff 	mov    %edx,-0x248(%ebp,%eax,4)
/work/x86_os_my/fs/inode.c:191
		block_idx++;
c000898d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008991:	83 c0 01             	add    $0x1,%eax
c0008994:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/inode.c:189
	uint8_t block_idx = 0, block_cnt = 12;
	uint32_t block_bitmap_idx;
	uint32_t all_blocks[140] = {0};	  //12个直接块+128个间接块

	/* a 先将前12个直接块存入all_blocks */
	while (block_idx < 12) {
c0008997:	80 7d f7 0b          	cmpb   $0xb,-0x9(%ebp)
c000899b:	76 d8                	jbe    c0008975 <inode_release+0x62>
/work/x86_os_my/fs/inode.c:194
		all_blocks[block_idx] = inode_to_del->i_sectors[block_idx];
		block_idx++;
	}
	/* b 如果一级间接块表存在，将其128个间接块读到all_blocks[12~]，并释放一级间接块表所占的扇区 */
	if (inode_to_del->i_sectors[12] != 0) {
c000899d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00089a0:	8b 40 40             	mov    0x40(%eax),%eax
c00089a3:	85 c0                	test   %eax,%eax
c00089a5:	0f 84 8b 00 00 00    	je     c0008a36 <inode_release+0x123>
/work/x86_os_my/fs/inode.c:195
		ide_read(part->my_disk, inode_to_del->i_sectors[12], all_blocks + 12, 1);
c00089ab:	8d 85 b8 fd ff ff    	lea    -0x248(%ebp),%eax
c00089b1:	83 c0 30             	add    $0x30,%eax
c00089b4:	8b 55 f0             	mov    -0x10(%ebp),%edx
c00089b7:	8b 4a 40             	mov    0x40(%edx),%ecx
c00089ba:	8b 55 08             	mov    0x8(%ebp),%edx
c00089bd:	8b 52 08             	mov    0x8(%edx),%edx
c00089c0:	6a 01                	push   $0x1
c00089c2:	50                   	push   %eax
c00089c3:	51                   	push   %ecx
c00089c4:	52                   	push   %edx
c00089c5:	e8 0c d0 ff ff       	call   c00059d6 <ide_read>
c00089ca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:196
		block_cnt = 140;
c00089cd:	c6 45 f6 8c          	movb   $0x8c,-0xa(%ebp)
/work/x86_os_my/fs/inode.c:199

		/* 回收一级间接块表占用的扇区 */
		block_bitmap_idx = inode_to_del->i_sectors[12] - part->sb->data_start_lba;
c00089d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00089d4:	8b 50 40             	mov    0x40(%eax),%edx
c00089d7:	8b 45 08             	mov    0x8(%ebp),%eax
c00089da:	8b 40 1c             	mov    0x1c(%eax),%eax
c00089dd:	8b 40 28             	mov    0x28(%eax),%eax
c00089e0:	29 c2                	sub    %eax,%edx
c00089e2:	89 d0                	mov    %edx,%eax
c00089e4:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:200
		ASSERT(block_bitmap_idx > 0);
c00089e7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c00089eb:	75 1c                	jne    c0008a09 <inode_release+0xf6>
/work/x86_os_my/fs/inode.c:200 (discriminator 1)
c00089ed:	68 6f ca 00 c0       	push   $0xc000ca6f
c00089f2:	68 b0 ca 00 c0       	push   $0xc000cab0
c00089f7:	68 c8 00 00 00       	push   $0xc8
c00089fc:	68 0c ca 00 c0       	push   $0xc000ca0c
c0008a01:	e8 dc 98 ff ff       	call   c00022e2 <panic_spin>
c0008a06:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:201
		bitmap_set(&part->block_bitmap, block_bitmap_idx, 0);
c0008a09:	8b 45 08             	mov    0x8(%ebp),%eax
c0008a0c:	83 c0 20             	add    $0x20,%eax
c0008a0f:	83 ec 04             	sub    $0x4,%esp
c0008a12:	6a 00                	push   $0x0
c0008a14:	ff 75 ec             	pushl  -0x14(%ebp)
c0008a17:	50                   	push   %eax
c0008a18:	e8 33 9b ff ff       	call   c0002550 <bitmap_set>
c0008a1d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:202
		bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c0008a20:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0008a25:	83 ec 04             	sub    $0x4,%esp
c0008a28:	6a 01                	push   $0x1
c0008a2a:	ff 75 ec             	pushl  -0x14(%ebp)
c0008a2d:	50                   	push   %eax
c0008a2e:	e8 ca 02 00 00       	call   c0008cfd <bitmap_sync>
c0008a33:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:205
	}
	/* c inode所有的块地址已经收集到all_blocks中，下面逐个回收 */
	block_idx = 0;
c0008a36:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/inode.c:206
	while (block_idx < block_cnt) {
c0008a3a:	e9 8a 00 00 00       	jmp    c0008ac9 <inode_release+0x1b6>
/work/x86_os_my/fs/inode.c:207
		if (all_blocks[block_idx] != 0) {
c0008a3f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008a43:	8b 84 85 b8 fd ff ff 	mov    -0x248(%ebp,%eax,4),%eax
c0008a4a:	85 c0                	test   %eax,%eax
c0008a4c:	74 71                	je     c0008abf <inode_release+0x1ac>
/work/x86_os_my/fs/inode.c:208
			block_bitmap_idx = 0;
c0008a4e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:209
			block_bitmap_idx = all_blocks[block_idx] - part->sb->data_start_lba;
c0008a55:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008a59:	8b 94 85 b8 fd ff ff 	mov    -0x248(%ebp,%eax,4),%edx
c0008a60:	8b 45 08             	mov    0x8(%ebp),%eax
c0008a63:	8b 40 1c             	mov    0x1c(%eax),%eax
c0008a66:	8b 40 28             	mov    0x28(%eax),%eax
c0008a69:	29 c2                	sub    %eax,%edx
c0008a6b:	89 d0                	mov    %edx,%eax
c0008a6d:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/inode.c:210
			ASSERT(block_bitmap_idx > 0);
c0008a70:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0008a74:	75 1c                	jne    c0008a92 <inode_release+0x17f>
/work/x86_os_my/fs/inode.c:210 (discriminator 1)
c0008a76:	68 6f ca 00 c0       	push   $0xc000ca6f
c0008a7b:	68 b0 ca 00 c0       	push   $0xc000cab0
c0008a80:	68 d2 00 00 00       	push   $0xd2
c0008a85:	68 0c ca 00 c0       	push   $0xc000ca0c
c0008a8a:	e8 53 98 ff ff       	call   c00022e2 <panic_spin>
c0008a8f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:211
			bitmap_set(&part->block_bitmap, block_bitmap_idx, 0);
c0008a92:	8b 45 08             	mov    0x8(%ebp),%eax
c0008a95:	83 c0 20             	add    $0x20,%eax
c0008a98:	83 ec 04             	sub    $0x4,%esp
c0008a9b:	6a 00                	push   $0x0
c0008a9d:	ff 75 ec             	pushl  -0x14(%ebp)
c0008aa0:	50                   	push   %eax
c0008aa1:	e8 aa 9a ff ff       	call   c0002550 <bitmap_set>
c0008aa6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:212
			bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c0008aa9:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0008aae:	83 ec 04             	sub    $0x4,%esp
c0008ab1:	6a 01                	push   $0x1
c0008ab3:	ff 75 ec             	pushl  -0x14(%ebp)
c0008ab6:	50                   	push   %eax
c0008ab7:	e8 41 02 00 00       	call   c0008cfd <bitmap_sync>
c0008abc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:214
		}
		block_idx++;
c0008abf:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008ac3:	83 c0 01             	add    $0x1,%eax
c0008ac6:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/inode.c:206
		bitmap_set(&part->block_bitmap, block_bitmap_idx, 0);
		bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
	}
	/* c inode所有的块地址已经收集到all_blocks中，下面逐个回收 */
	block_idx = 0;
	while (block_idx < block_cnt) {
c0008ac9:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008acd:	3a 45 f6             	cmp    -0xa(%ebp),%al
c0008ad0:	0f 82 69 ff ff ff    	jb     c0008a3f <inode_release+0x12c>
/work/x86_os_my/fs/inode.c:218
		}
		block_idx++;
	}

	/*2 回收该inode所占用的inode */
	bitmap_set(&part->inode_bitmap, inode_no, 0);
c0008ad6:	8b 45 08             	mov    0x8(%ebp),%eax
c0008ad9:	83 c0 28             	add    $0x28,%eax
c0008adc:	83 ec 04             	sub    $0x4,%esp
c0008adf:	6a 00                	push   $0x0
c0008ae1:	ff 75 0c             	pushl  0xc(%ebp)
c0008ae4:	50                   	push   %eax
c0008ae5:	e8 66 9a ff ff       	call   c0002550 <bitmap_set>
c0008aea:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:219
	bitmap_sync(cur_part, inode_no, INODE_BITMAP);
c0008aed:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0008af2:	83 ec 04             	sub    $0x4,%esp
c0008af5:	6a 00                	push   $0x0
c0008af7:	ff 75 0c             	pushl  0xc(%ebp)
c0008afa:	50                   	push   %eax
c0008afb:	e8 fd 01 00 00       	call   c0008cfd <bitmap_sync>
c0008b00:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:225

	/******     以下inode_delete是调试用的    ******
	 * 此函数会在 inode_table 中将此inode清0，
	 * 但实际上只需要在inode位图中清零相应位即可。
	 * 硬盘上的数据更不需要清0，可以直接覆盖 */
	void* io_buf = sys_malloc(1024);
c0008b03:	83 ec 0c             	sub    $0xc,%esp
c0008b06:	68 00 04 00 00       	push   $0x400
c0008b0b:	e8 7d a1 ff ff       	call   c0002c8d <sys_malloc>
c0008b10:	83 c4 10             	add    $0x10,%esp
c0008b13:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/inode.c:226
	inode_delete(part, inode_no, io_buf);
c0008b16:	83 ec 04             	sub    $0x4,%esp
c0008b19:	ff 75 e8             	pushl  -0x18(%ebp)
c0008b1c:	ff 75 0c             	pushl  0xc(%ebp)
c0008b1f:	ff 75 08             	pushl  0x8(%ebp)
c0008b22:	e8 da fc ff ff       	call   c0008801 <inode_delete>
c0008b27:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:227
	sys_free(io_buf);
c0008b2a:	83 ec 0c             	sub    $0xc,%esp
c0008b2d:	ff 75 e8             	pushl  -0x18(%ebp)
c0008b30:	e8 85 a7 ff ff       	call   c00032ba <sys_free>
c0008b35:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:230
	/***********************************************/

	inode_close(inode_to_del);
c0008b38:	83 ec 0c             	sub    $0xc,%esp
c0008b3b:	ff 75 f0             	pushl  -0x10(%ebp)
c0008b3e:	e8 42 fc ff ff       	call   c0008785 <inode_close>
c0008b43:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/inode.c:231
}
c0008b46:	90                   	nop
c0008b47:	8b 7d fc             	mov    -0x4(%ebp),%edi
c0008b4a:	c9                   	leave  
c0008b4b:	c3                   	ret    

c0008b4c <inode_init>:
inode_init():
/work/x86_os_my/fs/inode.c:234

/* 初始化一个inode结构，inode号是inode_no */
void inode_init(uint32_t inode_no, struct inode* new_inode) {
c0008b4c:	55                   	push   %ebp
c0008b4d:	89 e5                	mov    %esp,%ebp
c0008b4f:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/fs/inode.c:235
	new_inode->i_no = inode_no;
c0008b52:	8b 45 0c             	mov    0xc(%ebp),%eax
c0008b55:	8b 55 08             	mov    0x8(%ebp),%edx
c0008b58:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/inode.c:236
	new_inode->i_size = 0;
c0008b5a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0008b5d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
/work/x86_os_my/fs/inode.c:237
	new_inode->i_open_cnts = 0;
c0008b64:	8b 45 0c             	mov    0xc(%ebp),%eax
c0008b67:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/fs/inode.c:238
	new_inode->write_deny = false;
c0008b6e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0008b71:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/fs/inode.c:241

	/* 初始化块索引数组i_sector */
	uint8_t sec_idx = 0;
c0008b78:	c6 45 ff 00          	movb   $0x0,-0x1(%ebp)
/work/x86_os_my/fs/inode.c:242
	while (sec_idx < 13) {
c0008b7c:	eb 1b                	jmp    c0008b99 <inode_init+0x4d>
/work/x86_os_my/fs/inode.c:244
		/* i_sectors[12]为一级间接块地址 */
		new_inode->i_sectors[sec_idx] = 0;
c0008b7e:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c0008b82:	8b 45 0c             	mov    0xc(%ebp),%eax
c0008b85:	83 c2 04             	add    $0x4,%edx
c0008b88:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
/work/x86_os_my/fs/inode.c:245
		sec_idx++;
c0008b8f:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
c0008b93:	83 c0 01             	add    $0x1,%eax
c0008b96:	88 45 ff             	mov    %al,-0x1(%ebp)
/work/x86_os_my/fs/inode.c:242
	new_inode->i_open_cnts = 0;
	new_inode->write_deny = false;

	/* 初始化块索引数组i_sector */
	uint8_t sec_idx = 0;
	while (sec_idx < 13) {
c0008b99:	80 7d ff 0c          	cmpb   $0xc,-0x1(%ebp)
c0008b9d:	76 df                	jbe    c0008b7e <inode_init+0x32>
/work/x86_os_my/fs/inode.c:250
		sec_idx++;
	}
	/*为什么不提前分配inode管理的数据块（对我们来说是块=扇区）
	1.不知道文件大小，因此不知道分配多少个扇区合适
	2.文件创建后未必马上会写数据*/
}
c0008b9f:	90                   	nop
c0008ba0:	c9                   	leave  
c0008ba1:	c3                   	ret    

c0008ba2 <get_free_slot_in_global>:
get_free_slot_in_global():
/work/x86_os_my/fs/file.c:19

/* 文件表 */
struct file file_table[MAX_FILE_OPEN];

/* 从文件表 file_table 中获取一个空闲位,成功返回下标,失败返回-1 */
int32_t get_free_slot_in_global(void) {
c0008ba2:	55                   	push   %ebp
c0008ba3:	89 e5                	mov    %esp,%ebp
c0008ba5:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/file.c:20
	uint32_t fd_idx = 3;
c0008ba8:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
/work/x86_os_my/fs/file.c:21
	while (fd_idx < MAX_FILE_OPEN) {
c0008baf:	eb 1b                	jmp    c0008bcc <get_free_slot_in_global+0x2a>
/work/x86_os_my/fs/file.c:22
		if (file_table[fd_idx].fd_inode == NULL) {
c0008bb1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0008bb4:	89 d0                	mov    %edx,%eax
c0008bb6:	01 c0                	add    %eax,%eax
c0008bb8:	01 d0                	add    %edx,%eax
c0008bba:	c1 e0 02             	shl    $0x2,%eax
c0008bbd:	05 e8 09 01 c0       	add    $0xc00109e8,%eax
c0008bc2:	8b 00                	mov    (%eax),%eax
c0008bc4:	85 c0                	test   %eax,%eax
c0008bc6:	74 0c                	je     c0008bd4 <get_free_slot_in_global+0x32>
/work/x86_os_my/fs/file.c:25
			break;
		}
		fd_idx++;
c0008bc8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/file.c:21
struct file file_table[MAX_FILE_OPEN];

/* 从文件表 file_table 中获取一个空闲位,成功返回下标,失败返回-1 */
int32_t get_free_slot_in_global(void) {
	uint32_t fd_idx = 3;
	while (fd_idx < MAX_FILE_OPEN) {
c0008bcc:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
c0008bd0:	76 df                	jbe    c0008bb1 <get_free_slot_in_global+0xf>
c0008bd2:	eb 01                	jmp    c0008bd5 <get_free_slot_in_global+0x33>
/work/x86_os_my/fs/file.c:23
		if (file_table[fd_idx].fd_inode == NULL) {
			break;
c0008bd4:	90                   	nop
/work/x86_os_my/fs/file.c:27
		}
		fd_idx++;
	}
	if (fd_idx == MAX_FILE_OPEN) {
c0008bd5:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
c0008bd9:	75 17                	jne    c0008bf2 <get_free_slot_in_global+0x50>
/work/x86_os_my/fs/file.c:28
		printk("exceed max open files\n");
c0008bdb:	83 ec 0c             	sub    $0xc,%esp
c0008bde:	68 c0 ca 00 c0       	push   $0xc000cac0
c0008be3:	e8 67 d8 ff ff       	call   c000644f <printk>
c0008be8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:29
		return -1;
c0008beb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0008bf0:	eb 03                	jmp    c0008bf5 <get_free_slot_in_global+0x53>
/work/x86_os_my/fs/file.c:31
	}
	return fd_idx;
c0008bf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/file.c:32
}
c0008bf5:	c9                   	leave  
c0008bf6:	c3                   	ret    

c0008bf7 <pcb_fd_install>:
pcb_fd_install():
/work/x86_os_my/fs/file.c:36

/* 将 file_table 的下标，安装到，线程PCB中文件描述符数组 fd_table
 * 成功返回 fd_table 的下标（即文件描述符）,失败返回-1 */
int32_t pcb_fd_install(int32_t globa_fd_idx) {
c0008bf7:	55                   	push   %ebp
c0008bf8:	89 e5                	mov    %esp,%ebp
c0008bfa:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/file.c:37
	struct task_struct* cur = running_thread();
c0008bfd:	e8 69 af ff ff       	call   c0003b6b <running_thread>
c0008c02:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:38
	uint8_t local_fd_idx = 3;	// 跨过stdin,stdout,stderr
c0008c05:	c6 45 f7 03          	movb   $0x3,-0x9(%ebp)
/work/x86_os_my/fs/file.c:39
	while (local_fd_idx < MAX_FILES_OPEN_PER_PROC) {
c0008c09:	eb 30                	jmp    c0008c3b <pcb_fd_install+0x44>
/work/x86_os_my/fs/file.c:40
		if (cur->fd_table[local_fd_idx] == -1) {	// -1表示free_slot,可用
c0008c0b:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0008c0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0008c12:	83 c2 08             	add    $0x8,%edx
c0008c15:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
c0008c19:	83 f8 ff             	cmp    $0xffffffff,%eax
c0008c1c:	75 13                	jne    c0008c31 <pcb_fd_install+0x3a>
/work/x86_os_my/fs/file.c:41
			cur->fd_table[local_fd_idx] = globa_fd_idx;
c0008c1e:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0008c22:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0008c25:	8d 4a 08             	lea    0x8(%edx),%ecx
c0008c28:	8b 55 08             	mov    0x8(%ebp),%edx
c0008c2b:	89 54 88 04          	mov    %edx,0x4(%eax,%ecx,4)
/work/x86_os_my/fs/file.c:42
			break;
c0008c2f:	eb 10                	jmp    c0008c41 <pcb_fd_install+0x4a>
/work/x86_os_my/fs/file.c:44
		}
		local_fd_idx++;
c0008c31:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008c35:	83 c0 01             	add    $0x1,%eax
c0008c38:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/file.c:39
/* 将 file_table 的下标，安装到，线程PCB中文件描述符数组 fd_table
 * 成功返回 fd_table 的下标（即文件描述符）,失败返回-1 */
int32_t pcb_fd_install(int32_t globa_fd_idx) {
	struct task_struct* cur = running_thread();
	uint8_t local_fd_idx = 3;	// 跨过stdin,stdout,stderr
	while (local_fd_idx < MAX_FILES_OPEN_PER_PROC) {
c0008c3b:	80 7d f7 07          	cmpb   $0x7,-0x9(%ebp)
c0008c3f:	76 ca                	jbe    c0008c0b <pcb_fd_install+0x14>
/work/x86_os_my/fs/file.c:46
			cur->fd_table[local_fd_idx] = globa_fd_idx;
			break;
		}
		local_fd_idx++;
	}
	if (local_fd_idx == MAX_FILES_OPEN_PER_PROC) {
c0008c41:	80 7d f7 08          	cmpb   $0x8,-0x9(%ebp)
c0008c45:	75 17                	jne    c0008c5e <pcb_fd_install+0x67>
/work/x86_os_my/fs/file.c:47
		printk("exceed max open files_per_proc\n");
c0008c47:	83 ec 0c             	sub    $0xc,%esp
c0008c4a:	68 d8 ca 00 c0       	push   $0xc000cad8
c0008c4f:	e8 fb d7 ff ff       	call   c000644f <printk>
c0008c54:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:48
		return -1;
c0008c57:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0008c5c:	eb 04                	jmp    c0008c62 <pcb_fd_install+0x6b>
/work/x86_os_my/fs/file.c:50
	}
	return local_fd_idx;
c0008c5e:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
/work/x86_os_my/fs/file.c:51
}
c0008c62:	c9                   	leave  
c0008c63:	c3                   	ret    

c0008c64 <inode_bitmap_alloc>:
inode_bitmap_alloc():
/work/x86_os_my/fs/file.c:54

/* 从分区的inode位图中，分配一个i结点，返回"inode号" */
int32_t inode_bitmap_alloc(struct partition* part) {
c0008c64:	55                   	push   %ebp
c0008c65:	89 e5                	mov    %esp,%ebp
c0008c67:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/file.c:55
	int32_t bit_idx = bitmap_scan(&part->inode_bitmap, 1);
c0008c6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0008c6d:	83 c0 28             	add    $0x28,%eax
c0008c70:	83 ec 08             	sub    $0x8,%esp
c0008c73:	6a 01                	push   $0x1
c0008c75:	50                   	push   %eax
c0008c76:	e8 a0 97 ff ff       	call   c000241b <bitmap_scan>
c0008c7b:	83 c4 10             	add    $0x10,%esp
c0008c7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:56
	if (bit_idx == -1) {
c0008c81:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0008c85:	75 07                	jne    c0008c8e <inode_bitmap_alloc+0x2a>
/work/x86_os_my/fs/file.c:57
		return -1;
c0008c87:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0008c8c:	eb 1b                	jmp    c0008ca9 <inode_bitmap_alloc+0x45>
/work/x86_os_my/fs/file.c:59
	}
	bitmap_set(&part->inode_bitmap, bit_idx, 1);
c0008c8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0008c91:	8b 55 08             	mov    0x8(%ebp),%edx
c0008c94:	83 c2 28             	add    $0x28,%edx
c0008c97:	83 ec 04             	sub    $0x4,%esp
c0008c9a:	6a 01                	push   $0x1
c0008c9c:	50                   	push   %eax
c0008c9d:	52                   	push   %edx
c0008c9e:	e8 ad 98 ff ff       	call   c0002550 <bitmap_set>
c0008ca3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:60
	return bit_idx;
c0008ca6:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/file.c:61
}
c0008ca9:	c9                   	leave  
c0008caa:	c3                   	ret    

c0008cab <block_bitmap_alloc>:
block_bitmap_alloc():
/work/x86_os_my/fs/file.c:64
   
/* 从分区的block位图中，分配1个扇区，返回"扇区地址" 【操作的是 空闲块区域 】*/
int32_t block_bitmap_alloc(struct partition* part) {
c0008cab:	55                   	push   %ebp
c0008cac:	89 e5                	mov    %esp,%ebp
c0008cae:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/file.c:65
	int32_t bit_idx = bitmap_scan(&part->block_bitmap, 1);
c0008cb1:	8b 45 08             	mov    0x8(%ebp),%eax
c0008cb4:	83 c0 20             	add    $0x20,%eax
c0008cb7:	83 ec 08             	sub    $0x8,%esp
c0008cba:	6a 01                	push   $0x1
c0008cbc:	50                   	push   %eax
c0008cbd:	e8 59 97 ff ff       	call   c000241b <bitmap_scan>
c0008cc2:	83 c4 10             	add    $0x10,%esp
c0008cc5:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:66
	if (bit_idx == -1) {
c0008cc8:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c0008ccc:	75 07                	jne    c0008cd5 <block_bitmap_alloc+0x2a>
/work/x86_os_my/fs/file.c:67
		return -1;
c0008cce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0008cd3:	eb 26                	jmp    c0008cfb <block_bitmap_alloc+0x50>
/work/x86_os_my/fs/file.c:69
	}
	bitmap_set(&part->block_bitmap, bit_idx, 1);
c0008cd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0008cd8:	8b 55 08             	mov    0x8(%ebp),%edx
c0008cdb:	83 c2 20             	add    $0x20,%edx
c0008cde:	83 ec 04             	sub    $0x4,%esp
c0008ce1:	6a 01                	push   $0x1
c0008ce3:	50                   	push   %eax
c0008ce4:	52                   	push   %edx
c0008ce5:	e8 66 98 ff ff       	call   c0002550 <bitmap_set>
c0008cea:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:71
	/* 和inode_bitmap_malloc不同,此处返回的不是位图索引,而是具体可用的扇区地址 */
	return (part->sb->data_start_lba + bit_idx);
c0008ced:	8b 45 08             	mov    0x8(%ebp),%eax
c0008cf0:	8b 40 1c             	mov    0x1c(%eax),%eax
c0008cf3:	8b 50 28             	mov    0x28(%eax),%edx
c0008cf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0008cf9:	01 d0                	add    %edx,%eax
/work/x86_os_my/fs/file.c:72
} 
c0008cfb:	c9                   	leave  
c0008cfc:	c3                   	ret    

c0008cfd <bitmap_sync>:
bitmap_sync():
/work/x86_os_my/fs/file.c:76

/* 将内存中bitmap第bit_idx位所在的那个512字节，同步到硬盘中bitmap第bit_idx位所在的扇区 */
// 硬盘以扇区为读写单位
void bitmap_sync(struct partition* part, uint32_t bit_idx, uint8_t btmp_type) {
c0008cfd:	55                   	push   %ebp
c0008cfe:	89 e5                	mov    %esp,%ebp
c0008d00:	83 ec 28             	sub    $0x28,%esp
c0008d03:	8b 45 10             	mov    0x10(%ebp),%eax
c0008d06:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:77
	uint32_t off_sec = bit_idx / 4096;			// dst(硬盘中): bit_idx 相对于位图起始lba，在后边的第几个扇区(512*8=4096)
c0008d09:	8b 45 0c             	mov    0xc(%ebp),%eax
c0008d0c:	c1 e8 0c             	shr    $0xc,%eax
c0008d0f:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:78
	uint32_t off_size = off_sec * BLOCK_SIZE;	// src(内存中): bit_idx 相对于位图数组bits，以512字节为单位，在后边的第几个单位处
c0008d12:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008d15:	c1 e0 09             	shl    $0x9,%eax
c0008d18:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:84
												// off_size是，第 bit_idx位所在位图中以 512 字节为单位的起始地址。BLOCK_SIZE=512
	uint32_t sec_lba;
	uint8_t* bitmap_off;

	/* 需要被同步到硬盘的位图只有inode_bitmap和block_bitmap */
	switch (btmp_type) {
c0008d1b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0008d1f:	85 c0                	test   %eax,%eax
c0008d21:	74 07                	je     c0008d2a <bitmap_sync+0x2d>
c0008d23:	83 f8 01             	cmp    $0x1,%eax
c0008d26:	74 23                	je     c0008d4b <bitmap_sync+0x4e>
c0008d28:	eb 41                	jmp    c0008d6b <bitmap_sync+0x6e>
/work/x86_os_my/fs/file.c:86
		case INODE_BITMAP:
		sec_lba = part->sb->inode_bitmap_lba + off_sec;
c0008d2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0008d2d:	8b 40 1c             	mov    0x1c(%eax),%eax
c0008d30:	8b 50 18             	mov    0x18(%eax),%edx
c0008d33:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008d36:	01 d0                	add    %edx,%eax
c0008d38:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:87
		bitmap_off = part->inode_bitmap.bits + off_size;
c0008d3b:	8b 45 08             	mov    0x8(%ebp),%eax
c0008d3e:	8b 50 2c             	mov    0x2c(%eax),%edx
c0008d41:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0008d44:	01 d0                	add    %edx,%eax
c0008d46:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:88
		break;
c0008d49:	eb 20                	jmp    c0008d6b <bitmap_sync+0x6e>
/work/x86_os_my/fs/file.c:91

		case BLOCK_BITMAP: 
		sec_lba = part->sb->block_bitmap_lba + off_sec;
c0008d4b:	8b 45 08             	mov    0x8(%ebp),%eax
c0008d4e:	8b 40 1c             	mov    0x1c(%eax),%eax
c0008d51:	8b 50 10             	mov    0x10(%eax),%edx
c0008d54:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0008d57:	01 d0                	add    %edx,%eax
c0008d59:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:92
		bitmap_off = part->block_bitmap.bits + off_size;
c0008d5c:	8b 45 08             	mov    0x8(%ebp),%eax
c0008d5f:	8b 50 24             	mov    0x24(%eax),%edx
c0008d62:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0008d65:	01 d0                	add    %edx,%eax
c0008d67:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:93
		break;
c0008d6a:	90                   	nop
/work/x86_os_my/fs/file.c:95
	}
	ide_write(part->my_disk, sec_lba, bitmap_off, 1);	// 将bitmap_off中1个扇区的数据写入硬盘sec_lba处
c0008d6b:	8b 45 08             	mov    0x8(%ebp),%eax
c0008d6e:	8b 40 08             	mov    0x8(%eax),%eax
c0008d71:	6a 01                	push   $0x1
c0008d73:	ff 75 f0             	pushl  -0x10(%ebp)
c0008d76:	ff 75 f4             	pushl  -0xc(%ebp)
c0008d79:	50                   	push   %eax
c0008d7a:	e8 cb cd ff ff       	call   c0005b4a <ide_write>
c0008d7f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:96
}
c0008d82:	90                   	nop
c0008d83:	c9                   	leave  
c0008d84:	c3                   	ret    

c0008d85 <file_create>:
file_create():
/work/x86_os_my/fs/file.c:114
此新增加的文件对应的目录项，需要写入该目录的 inode->i_sectors[]中的某个扇区，
原有扇区可能已满，所以有可能要申请新扇区来存储目录项。【sync_dir_entry】
4. 若其中某步操作失败，需要回滚之前已成功的操作。
5. inode_bitmap、 block_bitmap、新文件的 inode 及文件所在目录的 inode，这些位于内存中已经被改变的数据要同步到硬盘。
*/
int32_t file_create(struct dir* parent_dir, char* filename, uint8_t flag) {
c0008d85:	55                   	push   %ebp
c0008d86:	89 e5                	mov    %esp,%ebp
c0008d88:	83 ec 48             	sub    $0x48,%esp
c0008d8b:	8b 45 10             	mov    0x10(%ebp),%eax
c0008d8e:	88 45 c4             	mov    %al,-0x3c(%ebp)
/work/x86_os_my/fs/file.c:116
	/* 后续操作的公共缓冲区 */
	void* io_buf = sys_malloc(1024);	//跨扇区的数据，会操作2个扇区
c0008d91:	83 ec 0c             	sub    $0xc,%esp
c0008d94:	68 00 04 00 00       	push   $0x400
c0008d99:	e8 ef 9e ff ff       	call   c0002c8d <sys_malloc>
c0008d9e:	83 c4 10             	add    $0x10,%esp
c0008da1:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:117
	if (io_buf == NULL) {
c0008da4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0008da8:	75 1a                	jne    c0008dc4 <file_create+0x3f>
/work/x86_os_my/fs/file.c:118
		printk("in file_creat: sys_malloc for io_buf failed\n");
c0008daa:	83 ec 0c             	sub    $0xc,%esp
c0008dad:	68 f8 ca 00 c0       	push   $0xc000caf8
c0008db2:	e8 98 d6 ff ff       	call   c000644f <printk>
c0008db7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:119
		return -1;
c0008dba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0008dbf:	e9 81 02 00 00       	jmp    c0009045 <file_create+0x2c0>
/work/x86_os_my/fs/file.c:122
	}

	uint8_t rollback_step = 0;	// 用于操作失败时回滚各资源状态
c0008dc4:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/file.c:125

	/* 1.为新文件从分区inode位图中，分配inode号 */
	int32_t inode_no = inode_bitmap_alloc(cur_part); 
c0008dc8:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0008dcd:	83 ec 0c             	sub    $0xc,%esp
c0008dd0:	50                   	push   %eax
c0008dd1:	e8 8e fe ff ff       	call   c0008c64 <inode_bitmap_alloc>
c0008dd6:	83 c4 10             	add    $0x10,%esp
c0008dd9:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:126
	if (inode_no == -1) {
c0008ddc:	83 7d e8 ff          	cmpl   $0xffffffff,-0x18(%ebp)
c0008de0:	75 1a                	jne    c0008dfc <file_create+0x77>
/work/x86_os_my/fs/file.c:127
		printk("in file_creat: allocate inode failed\n");
c0008de2:	83 ec 0c             	sub    $0xc,%esp
c0008de5:	68 28 cb 00 c0       	push   $0xc000cb28
c0008dea:	e8 60 d6 ff ff       	call   c000644f <printk>
c0008def:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:128
		return -1;
c0008df2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0008df7:	e9 49 02 00 00       	jmp    c0009045 <file_create+0x2c0>
/work/x86_os_my/fs/file.c:133
	}

	/* 2.堆中分配inode节点，不可以是栈中的局部变量！
	 * 因为 file_table 中的 fd_inode 指针要指向它. */
	struct inode* new_file_inode = (struct inode*)sys_malloc(sizeof(struct inode)); 
c0008dfc:	83 ec 0c             	sub    $0xc,%esp
c0008dff:	6a 4c                	push   $0x4c
c0008e01:	e8 87 9e ff ff       	call   c0002c8d <sys_malloc>
c0008e06:	83 c4 10             	add    $0x10,%esp
c0008e09:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:134
	if (new_file_inode == NULL) {
c0008e0c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0008e10:	75 19                	jne    c0008e2b <file_create+0xa6>
/work/x86_os_my/fs/file.c:135
		printk("file_create: sys_malloc for inode failded\n");
c0008e12:	83 ec 0c             	sub    $0xc,%esp
c0008e15:	68 50 cb 00 c0       	push   $0xc000cb50
c0008e1a:	e8 30 d6 ff ff       	call   c000644f <printk>
c0008e1f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:136
		rollback_step = 1;
c0008e22:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
/work/x86_os_my/fs/file.c:137
		goto rollback;
c0008e26:	e9 a7 01 00 00       	jmp    c0008fd2 <file_create+0x24d>
/work/x86_os_my/fs/file.c:139
	}
	inode_init(inode_no, new_file_inode);	    // 初始化inode
c0008e2b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0008e2e:	83 ec 08             	sub    $0x8,%esp
c0008e31:	ff 75 e4             	pushl  -0x1c(%ebp)
c0008e34:	50                   	push   %eax
c0008e35:	e8 12 fd ff ff       	call   c0008b4c <inode_init>
c0008e3a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:142

	/* 3.申请一个file_table数组的下标 */
	int fd_idx = get_free_slot_in_global();
c0008e3d:	e8 60 fd ff ff       	call   c0008ba2 <get_free_slot_in_global>
c0008e42:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:143
	if (fd_idx == -1) {
c0008e45:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c0008e49:	75 19                	jne    c0008e64 <file_create+0xdf>
/work/x86_os_my/fs/file.c:144
		printk("exceed max open files\n");
c0008e4b:	83 ec 0c             	sub    $0xc,%esp
c0008e4e:	68 c0 ca 00 c0       	push   $0xc000cac0
c0008e53:	e8 f7 d5 ff ff       	call   c000644f <printk>
c0008e58:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:145
		rollback_step = 2;
c0008e5b:	c6 45 f7 02          	movb   $0x2,-0x9(%ebp)
/work/x86_os_my/fs/file.c:146
		goto rollback;
c0008e5f:	e9 6e 01 00 00       	jmp    c0008fd2 <file_create+0x24d>
/work/x86_os_my/fs/file.c:150
	}

	// 4.填充文件表中的文件结构
	file_table[fd_idx].fd_inode = new_file_inode;
c0008e64:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008e67:	89 d0                	mov    %edx,%eax
c0008e69:	01 c0                	add    %eax,%eax
c0008e6b:	01 d0                	add    %edx,%eax
c0008e6d:	c1 e0 02             	shl    $0x2,%eax
c0008e70:	8d 90 e8 09 01 c0    	lea    -0x3ffef618(%eax),%edx
c0008e76:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0008e79:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/file.c:151
	file_table[fd_idx].fd_pos = 0;
c0008e7b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008e7e:	89 d0                	mov    %edx,%eax
c0008e80:	01 c0                	add    %eax,%eax
c0008e82:	01 d0                	add    %edx,%eax
c0008e84:	c1 e0 02             	shl    $0x2,%eax
c0008e87:	05 e0 09 01 c0       	add    $0xc00109e0,%eax
c0008e8c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/file.c:152
	file_table[fd_idx].fd_flag = flag;
c0008e92:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
c0008e96:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008e99:	89 d0                	mov    %edx,%eax
c0008e9b:	01 c0                	add    %eax,%eax
c0008e9d:	01 d0                	add    %edx,%eax
c0008e9f:	c1 e0 02             	shl    $0x2,%eax
c0008ea2:	05 e4 09 01 c0       	add    $0xc00109e4,%eax
c0008ea7:	89 08                	mov    %ecx,(%eax)
/work/x86_os_my/fs/file.c:153
	file_table[fd_idx].fd_inode->write_deny = false;
c0008ea9:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008eac:	89 d0                	mov    %edx,%eax
c0008eae:	01 c0                	add    %eax,%eax
c0008eb0:	01 d0                	add    %edx,%eax
c0008eb2:	c1 e0 02             	shl    $0x2,%eax
c0008eb5:	05 e8 09 01 c0       	add    $0xc00109e8,%eax
c0008eba:	8b 00                	mov    (%eax),%eax
c0008ebc:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/fs/file.c:156

	struct dir_entry new_dir_entry;
	memset(&new_dir_entry, 0, sizeof(struct dir_entry));
c0008ec3:	83 ec 04             	sub    $0x4,%esp
c0008ec6:	6a 18                	push   $0x18
c0008ec8:	6a 00                	push   $0x0
c0008eca:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0008ecd:	50                   	push   %eax
c0008ece:	e8 b1 a8 ff ff       	call   c0003784 <memset>
c0008ed3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:159

	// create_dir_entry在内存中初始化目录项p_de，只是内存操作不会返回失败
	create_dir_entry(filename, inode_no, FT_REGULAR, &new_dir_entry);
c0008ed6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0008ed9:	8d 55 cc             	lea    -0x34(%ebp),%edx
c0008edc:	52                   	push   %edx
c0008edd:	6a 01                	push   $0x1
c0008edf:	50                   	push   %eax
c0008ee0:	ff 75 0c             	pushl  0xc(%ebp)
c0008ee3:	e8 73 10 00 00       	call   c0009f5b <create_dir_entry>
c0008ee8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:164


	/* 同步内存数据到硬盘 */
	/* a 在目录parent_dir下安装目录项new_dir_entry, 写入硬盘后返回true, 否则false【dir.c】 */
	if (!sync_dir_entry(parent_dir, &new_dir_entry, io_buf)) {
c0008eeb:	83 ec 04             	sub    $0x4,%esp
c0008eee:	ff 75 ec             	pushl  -0x14(%ebp)
c0008ef1:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0008ef4:	50                   	push   %eax
c0008ef5:	ff 75 08             	pushl  0x8(%ebp)
c0008ef8:	e8 cf 10 00 00       	call   c0009fcc <sync_dir_entry>
c0008efd:	83 c4 10             	add    $0x10,%esp
c0008f00:	85 c0                	test   %eax,%eax
c0008f02:	75 19                	jne    c0008f1d <file_create+0x198>
/work/x86_os_my/fs/file.c:165
		printk("sync dir_entry to disk failed\n");
c0008f04:	83 ec 0c             	sub    $0xc,%esp
c0008f07:	68 7c cb 00 c0       	push   $0xc000cb7c
c0008f0c:	e8 3e d5 ff ff       	call   c000644f <printk>
c0008f11:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:166
		rollback_step = 3;
c0008f14:	c6 45 f7 03          	movb   $0x3,-0x9(%ebp)
/work/x86_os_my/fs/file.c:167
		goto rollback;
c0008f18:	e9 b5 00 00 00       	jmp    c0008fd2 <file_create+0x24d>
/work/x86_os_my/fs/file.c:171
	}

	/* b sync_dir_entry 会改变父目录 inode 中的信息，因此，将父目录inode的内容同步到硬盘【inode.c】 */
	memset(io_buf, 0, 1024);
c0008f1d:	83 ec 04             	sub    $0x4,%esp
c0008f20:	68 00 04 00 00       	push   $0x400
c0008f25:	6a 00                	push   $0x0
c0008f27:	ff 75 ec             	pushl  -0x14(%ebp)
c0008f2a:	e8 55 a8 ff ff       	call   c0003784 <memset>
c0008f2f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:172
	inode_sync(cur_part, parent_dir->inode, io_buf);
c0008f32:	8b 45 08             	mov    0x8(%ebp),%eax
c0008f35:	8b 10                	mov    (%eax),%edx
c0008f37:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0008f3c:	83 ec 04             	sub    $0x4,%esp
c0008f3f:	ff 75 ec             	pushl  -0x14(%ebp)
c0008f42:	52                   	push   %edx
c0008f43:	50                   	push   %eax
c0008f44:	e8 cf f5 ff ff       	call   c0008518 <inode_sync>
c0008f49:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:175

	/* c 将新创建文件的inode内容同步到硬盘 */
	memset(io_buf, 0, 1024);
c0008f4c:	83 ec 04             	sub    $0x4,%esp
c0008f4f:	68 00 04 00 00       	push   $0x400
c0008f54:	6a 00                	push   $0x0
c0008f56:	ff 75 ec             	pushl  -0x14(%ebp)
c0008f59:	e8 26 a8 ff ff       	call   c0003784 <memset>
c0008f5e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:176
	inode_sync(cur_part, new_file_inode, io_buf);
c0008f61:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0008f66:	83 ec 04             	sub    $0x4,%esp
c0008f69:	ff 75 ec             	pushl  -0x14(%ebp)
c0008f6c:	ff 75 e4             	pushl  -0x1c(%ebp)
c0008f6f:	50                   	push   %eax
c0008f70:	e8 a3 f5 ff ff       	call   c0008518 <inode_sync>
c0008f75:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:179

	/* d 将inode_bitmap位图同步到硬盘【file.c】 */
	bitmap_sync(cur_part, inode_no, INODE_BITMAP);
c0008f78:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0008f7b:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0008f80:	83 ec 04             	sub    $0x4,%esp
c0008f83:	6a 00                	push   $0x0
c0008f85:	52                   	push   %edx
c0008f86:	50                   	push   %eax
c0008f87:	e8 71 fd ff ff       	call   c0008cfd <bitmap_sync>
c0008f8c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:182

	/* e 将创建的文件i结点添加到open_inodes链表 */
	list_push(&cur_part->open_inodes, &new_file_inode->inode_tag);
c0008f8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0008f92:	8d 50 44             	lea    0x44(%eax),%edx
c0008f95:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0008f9a:	83 c0 30             	add    $0x30,%eax
c0008f9d:	83 ec 08             	sub    $0x8,%esp
c0008fa0:	52                   	push   %edx
c0008fa1:	50                   	push   %eax
c0008fa2:	e8 49 b3 ff ff       	call   c00042f0 <list_push>
c0008fa7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:183
	new_file_inode->i_open_cnts = 1;
c0008faa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0008fad:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/fs/file.c:186


	sys_free(io_buf);
c0008fb4:	83 ec 0c             	sub    $0xc,%esp
c0008fb7:	ff 75 ec             	pushl  -0x14(%ebp)
c0008fba:	e8 fb a2 ff ff       	call   c00032ba <sys_free>
c0008fbf:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:187
	return pcb_fd_install(fd_idx);	// 将 file_table 的下标，安装到，线程PCB中文件描述符数组 fd_table【file.c】
c0008fc2:	83 ec 0c             	sub    $0xc,%esp
c0008fc5:	ff 75 f0             	pushl  -0x10(%ebp)
c0008fc8:	e8 2a fc ff ff       	call   c0008bf7 <pcb_fd_install>
c0008fcd:	83 c4 10             	add    $0x10,%esp
c0008fd0:	eb 73                	jmp    c0009045 <file_create+0x2c0>
/work/x86_os_my/fs/file.c:191


rollback:
	switch (rollback_step) {
c0008fd2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0008fd6:	83 f8 02             	cmp    $0x2,%eax
c0008fd9:	74 2d                	je     c0009008 <file_create+0x283>
c0008fdb:	83 f8 03             	cmp    $0x3,%eax
c0008fde:	74 07                	je     c0008fe7 <file_create+0x262>
c0008fe0:	83 f8 01             	cmp    $0x1,%eax
c0008fe3:	74 31                	je     c0009016 <file_create+0x291>
c0008fe5:	eb 4b                	jmp    c0009032 <file_create+0x2ad>
/work/x86_os_my/fs/file.c:194
		case 3:
		/* file_table 相应位清空 */
		memset(&file_table[fd_idx], 0, sizeof(struct file)); 
c0008fe7:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0008fea:	89 d0                	mov    %edx,%eax
c0008fec:	01 c0                	add    %eax,%eax
c0008fee:	01 d0                	add    %edx,%eax
c0008ff0:	c1 e0 02             	shl    $0x2,%eax
c0008ff3:	05 e0 09 01 c0       	add    $0xc00109e0,%eax
c0008ff8:	83 ec 04             	sub    $0x4,%esp
c0008ffb:	6a 0c                	push   $0xc
c0008ffd:	6a 00                	push   $0x0
c0008fff:	50                   	push   %eax
c0009000:	e8 7f a7 ff ff       	call   c0003784 <memset>
c0009005:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:196
		case 2:
		sys_free(new_file_inode);
c0009008:	83 ec 0c             	sub    $0xc,%esp
c000900b:	ff 75 e4             	pushl  -0x1c(%ebp)
c000900e:	e8 a7 a2 ff ff       	call   c00032ba <sys_free>
c0009013:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:199
		case 1:
		/* inode位图 恢复 */
		bitmap_set(&cur_part->inode_bitmap, inode_no, 0);
c0009016:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0009019:	8b 15 d0 09 01 c0    	mov    0xc00109d0,%edx
c000901f:	83 c2 28             	add    $0x28,%edx
c0009022:	83 ec 04             	sub    $0x4,%esp
c0009025:	6a 00                	push   $0x0
c0009027:	50                   	push   %eax
c0009028:	52                   	push   %edx
c0009029:	e8 22 95 ff ff       	call   c0002550 <bitmap_set>
c000902e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:200
		break;
c0009031:	90                   	nop
/work/x86_os_my/fs/file.c:202
	}
	sys_free(io_buf);
c0009032:	83 ec 0c             	sub    $0xc,%esp
c0009035:	ff 75 ec             	pushl  -0x14(%ebp)
c0009038:	e8 7d a2 ff ff       	call   c00032ba <sys_free>
c000903d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:203
	return -1;
c0009040:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
/work/x86_os_my/fs/file.c:204 (discriminator 1)
}
c0009045:	c9                   	leave  
c0009046:	c3                   	ret    

c0009047 <file_open>:
file_open():
/work/x86_os_my/fs/file.c:207

/* 打开编号为inode_no的inode对应的文件,若成功则返回文件描述符,否则返回-1 */
int32_t file_open(uint32_t inode_no, uint8_t flag) {
c0009047:	55                   	push   %ebp
c0009048:	89 e5                	mov    %esp,%ebp
c000904a:	83 ec 28             	sub    $0x28,%esp
c000904d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0009050:	88 45 e4             	mov    %al,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:208
	int fd_idx = get_free_slot_in_global();
c0009053:	e8 4a fb ff ff       	call   c0008ba2 <get_free_slot_in_global>
c0009058:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:209
	if (fd_idx == -1) {
c000905b:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c000905f:	75 1a                	jne    c000907b <file_open+0x34>
/work/x86_os_my/fs/file.c:210
		printk("exceed max open files\n");
c0009061:	83 ec 0c             	sub    $0xc,%esp
c0009064:	68 c0 ca 00 c0       	push   $0xc000cac0
c0009069:	e8 e1 d3 ff ff       	call   c000644f <printk>
c000906e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:211
		return -1;
c0009071:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009076:	e9 e3 00 00 00       	jmp    c000915e <file_open+0x117>
/work/x86_os_my/fs/file.c:213
	}
	file_table[fd_idx].fd_inode = inode_open(cur_part, inode_no);
c000907b:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0009080:	83 ec 08             	sub    $0x8,%esp
c0009083:	ff 75 08             	pushl  0x8(%ebp)
c0009086:	50                   	push   %eax
c0009087:	e8 b3 f5 ff ff       	call   c000863f <inode_open>
c000908c:	83 c4 10             	add    $0x10,%esp
c000908f:	89 c1                	mov    %eax,%ecx
c0009091:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0009094:	89 d0                	mov    %edx,%eax
c0009096:	01 c0                	add    %eax,%eax
c0009098:	01 d0                	add    %edx,%eax
c000909a:	c1 e0 02             	shl    $0x2,%eax
c000909d:	05 e8 09 01 c0       	add    $0xc00109e8,%eax
c00090a2:	89 08                	mov    %ecx,(%eax)
/work/x86_os_my/fs/file.c:214
	file_table[fd_idx].fd_pos = 0;		// 每次打开文件,要将fd_pos还原为0,即让文件内的指针指向开头
c00090a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00090a7:	89 d0                	mov    %edx,%eax
c00090a9:	01 c0                	add    %eax,%eax
c00090ab:	01 d0                	add    %edx,%eax
c00090ad:	c1 e0 02             	shl    $0x2,%eax
c00090b0:	05 e0 09 01 c0       	add    $0xc00109e0,%eax
c00090b5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
/work/x86_os_my/fs/file.c:215
	file_table[fd_idx].fd_flag = flag;
c00090bb:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
c00090bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00090c2:	89 d0                	mov    %edx,%eax
c00090c4:	01 c0                	add    %eax,%eax
c00090c6:	01 d0                	add    %edx,%eax
c00090c8:	c1 e0 02             	shl    $0x2,%eax
c00090cb:	05 e4 09 01 c0       	add    $0xc00109e4,%eax
c00090d0:	89 08                	mov    %ecx,(%eax)
/work/x86_os_my/fs/file.c:216
	bool* write_deny = &file_table[fd_idx].fd_inode->write_deny;
c00090d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00090d5:	89 d0                	mov    %edx,%eax
c00090d7:	01 c0                	add    %eax,%eax
c00090d9:	01 d0                	add    %edx,%eax
c00090db:	c1 e0 02             	shl    $0x2,%eax
c00090de:	05 e8 09 01 c0       	add    $0xc00109e8,%eax
c00090e3:	8b 00                	mov    (%eax),%eax
c00090e5:	83 c0 0c             	add    $0xc,%eax
c00090e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:218

	if (flag & O_WRONLY || flag & O_RDWR) {	// 要写文件,需要判断是否有其它进程正写此文件。创建文件、读文件不考虑write_deny。
c00090eb:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c00090ef:	83 e0 01             	and    $0x1,%eax
c00090f2:	85 c0                	test   %eax,%eax
c00090f4:	75 0b                	jne    c0009101 <file_open+0xba>
/work/x86_os_my/fs/file.c:218 (discriminator 1)
c00090f6:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c00090fa:	83 e0 02             	and    $0x2,%eax
c00090fd:	85 c0                	test   %eax,%eax
c00090ff:	74 4f                	je     c0009150 <file_open+0x109>
/work/x86_os_my/fs/file.c:220
		/* 以下进入临界区前先关中断 */
		enum intr_status old_status = intr_disable();
c0009101:	e8 38 88 ff ff       	call   c000193e <intr_disable>
c0009106:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:221
		if (!(*write_deny)) {	// 若当前没有其它进程写该文件,将其占用.
c0009109:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000910c:	8b 00                	mov    (%eax),%eax
c000910e:	85 c0                	test   %eax,%eax
c0009110:	75 19                	jne    c000912b <file_open+0xe4>
/work/x86_os_my/fs/file.c:222
			*write_deny = true;
c0009112:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0009115:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
/work/x86_os_my/fs/file.c:223
			intr_set_status(old_status);
c000911b:	83 ec 0c             	sub    $0xc,%esp
c000911e:	ff 75 ec             	pushl  -0x14(%ebp)
c0009121:	e8 41 88 ff ff       	call   c0001967 <intr_set_status>
c0009126:	83 c4 10             	add    $0x10,%esp
c0009129:	eb 25                	jmp    c0009150 <file_open+0x109>
/work/x86_os_my/fs/file.c:225
		} else {
			intr_set_status(old_status);
c000912b:	83 ec 0c             	sub    $0xc,%esp
c000912e:	ff 75 ec             	pushl  -0x14(%ebp)
c0009131:	e8 31 88 ff ff       	call   c0001967 <intr_set_status>
c0009136:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:226
			printk("file can`t be write now, try again later\n");
c0009139:	83 ec 0c             	sub    $0xc,%esp
c000913c:	68 9c cb 00 c0       	push   $0xc000cb9c
c0009141:	e8 09 d3 ff ff       	call   c000644f <printk>
c0009146:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:227
			return -1;
c0009149:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000914e:	eb 0e                	jmp    c000915e <file_open+0x117>
/work/x86_os_my/fs/file.c:230
		}
	}
	return pcb_fd_install(fd_idx);
c0009150:	83 ec 0c             	sub    $0xc,%esp
c0009153:	ff 75 f4             	pushl  -0xc(%ebp)
c0009156:	e8 9c fa ff ff       	call   c0008bf7 <pcb_fd_install>
c000915b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:231
}
c000915e:	c9                   	leave  
c000915f:	c3                   	ret    

c0009160 <file_close>:
file_close():
/work/x86_os_my/fs/file.c:234

/* 关闭文件 */
int32_t file_close(struct file* file) {
c0009160:	55                   	push   %ebp
c0009161:	89 e5                	mov    %esp,%ebp
c0009163:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/fs/file.c:235
	if (file == NULL) {
c0009166:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c000916a:	75 07                	jne    c0009173 <file_close+0x13>
/work/x86_os_my/fs/file.c:236
		return -1;
c000916c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009171:	eb 2e                	jmp    c00091a1 <file_close+0x41>
/work/x86_os_my/fs/file.c:238
	}
	file->fd_inode->write_deny = false;
c0009173:	8b 45 08             	mov    0x8(%ebp),%eax
c0009176:	8b 40 08             	mov    0x8(%eax),%eax
c0009179:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
/work/x86_os_my/fs/file.c:239
	inode_close(file->fd_inode);
c0009180:	8b 45 08             	mov    0x8(%ebp),%eax
c0009183:	8b 40 08             	mov    0x8(%eax),%eax
c0009186:	83 ec 0c             	sub    $0xc,%esp
c0009189:	50                   	push   %eax
c000918a:	e8 f6 f5 ff ff       	call   c0008785 <inode_close>
c000918f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:240
	file->fd_inode = NULL;   // 使文件结构可用
c0009192:	8b 45 08             	mov    0x8(%ebp),%eax
c0009195:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
/work/x86_os_my/fs/file.c:241
	return 0;
c000919c:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/file.c:242
}
c00091a1:	c9                   	leave  
c00091a2:	c3                   	ret    

c00091a3 <file_write>:
file_write():
/work/x86_os_my/fs/file.c:245

/* 把buf中的count个字节写入file,成功则返回写入的字节数,失败则返回-1 */
int32_t file_write(struct file* file, const void* buf, uint32_t count) {
c00091a3:	55                   	push   %ebp
c00091a4:	89 e5                	mov    %esp,%ebp
c00091a6:	83 ec 58             	sub    $0x58,%esp
/work/x86_os_my/fs/file.c:246
	if ((file->fd_inode->i_size + count) > (BLOCK_SIZE * 140))	{	// 文件目前最大只支持512B*140块=71680字节【12直接块+128间接块】
c00091a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00091ac:	8b 40 08             	mov    0x8(%eax),%eax
c00091af:	8b 50 04             	mov    0x4(%eax),%edx
c00091b2:	8b 45 10             	mov    0x10(%ebp),%eax
c00091b5:	01 d0                	add    %edx,%eax
c00091b7:	3d 00 18 01 00       	cmp    $0x11800,%eax
c00091bc:	76 1a                	jbe    c00091d8 <file_write+0x35>
/work/x86_os_my/fs/file.c:247
		printk("exceed max file_size 71680 bytes, write file failed\n");
c00091be:	83 ec 0c             	sub    $0xc,%esp
c00091c1:	68 c8 cb 00 c0       	push   $0xc000cbc8
c00091c6:	e8 84 d2 ff ff       	call   c000644f <printk>
c00091cb:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:248
		return -1;
c00091ce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00091d3:	e9 5d 07 00 00       	jmp    c0009935 <file_write+0x792>
/work/x86_os_my/fs/file.c:250
	}
	uint8_t* io_buf = sys_malloc(BLOCK_SIZE);
c00091d8:	83 ec 0c             	sub    $0xc,%esp
c00091db:	68 00 02 00 00       	push   $0x200
c00091e0:	e8 a8 9a ff ff       	call   c0002c8d <sys_malloc>
c00091e5:	83 c4 10             	add    $0x10,%esp
c00091e8:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/file.c:251
	if (io_buf == NULL) {
c00091eb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c00091ef:	75 1a                	jne    c000920b <file_write+0x68>
/work/x86_os_my/fs/file.c:252
		printk("file_write: sys_malloc for io_buf failed\n");
c00091f1:	83 ec 0c             	sub    $0xc,%esp
c00091f4:	68 00 cc 00 c0       	push   $0xc000cc00
c00091f9:	e8 51 d2 ff ff       	call   c000644f <printk>
c00091fe:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:253
		return -1;
c0009201:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009206:	e9 2a 07 00 00       	jmp    c0009935 <file_write+0x792>
/work/x86_os_my/fs/file.c:255
	}
	uint32_t* all_blocks = (uint32_t*)sys_malloc(BLOCK_SIZE + 48);	  // 用来记录文件所有的块地址【560/4=160】
c000920b:	83 ec 0c             	sub    $0xc,%esp
c000920e:	68 30 02 00 00       	push   $0x230
c0009213:	e8 75 9a ff ff       	call   c0002c8d <sys_malloc>
c0009218:	83 c4 10             	add    $0x10,%esp
c000921b:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/file.c:256
	if (all_blocks == NULL) {
c000921e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0009222:	75 1a                	jne    c000923e <file_write+0x9b>
/work/x86_os_my/fs/file.c:257
		printk("file_write: sys_malloc for all_blocks failed\n");
c0009224:	83 ec 0c             	sub    $0xc,%esp
c0009227:	68 2c cc 00 c0       	push   $0xc000cc2c
c000922c:	e8 1e d2 ff ff       	call   c000644f <printk>
c0009231:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:258
		return -1;
c0009234:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009239:	e9 f7 06 00 00       	jmp    c0009935 <file_write+0x792>
/work/x86_os_my/fs/file.c:261
	}

	int32_t block_lba = -1;			// 块地址
c000923e:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
/work/x86_os_my/fs/file.c:262
	uint32_t block_bitmap_idx = 0;	// block_bitmap中的索引,做为参数传给bitmap_sync
c0009245:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
/work/x86_os_my/fs/file.c:267
	int32_t indirect_block_table;	// 一级间接表地址
	uint32_t block_idx;				// 块索引

	/* 判断文件是否是第一次写，如果是，先为其分配一个块 */
	if (file->fd_inode->i_sectors[0] == 0) {
c000924c:	8b 45 08             	mov    0x8(%ebp),%eax
c000924f:	8b 40 08             	mov    0x8(%eax),%eax
c0009252:	8b 40 10             	mov    0x10(%eax),%eax
c0009255:	85 c0                	test   %eax,%eax
c0009257:	0f 85 8d 00 00 00    	jne    c00092ea <file_write+0x147>
/work/x86_os_my/fs/file.c:268
		block_lba = block_bitmap_alloc(cur_part);
c000925d:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0009262:	83 ec 0c             	sub    $0xc,%esp
c0009265:	50                   	push   %eax
c0009266:	e8 40 fa ff ff       	call   c0008cab <block_bitmap_alloc>
c000926b:	83 c4 10             	add    $0x10,%esp
c000926e:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/file.c:269
		if (block_lba == -1) {
c0009271:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
c0009275:	75 1a                	jne    c0009291 <file_write+0xee>
/work/x86_os_my/fs/file.c:270
			printk("file_write: block_bitmap_alloc failed\n");
c0009277:	83 ec 0c             	sub    $0xc,%esp
c000927a:	68 5c cc 00 c0       	push   $0xc000cc5c
c000927f:	e8 cb d1 ff ff       	call   c000644f <printk>
c0009284:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:271
			return -1;
c0009287:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000928c:	e9 a4 06 00 00       	jmp    c0009935 <file_write+0x792>
/work/x86_os_my/fs/file.c:273
		}
		file->fd_inode->i_sectors[0] = block_lba;
c0009291:	8b 45 08             	mov    0x8(%ebp),%eax
c0009294:	8b 40 08             	mov    0x8(%eax),%eax
c0009297:	8b 55 d8             	mov    -0x28(%ebp),%edx
c000929a:	89 50 10             	mov    %edx,0x10(%eax)
/work/x86_os_my/fs/file.c:276

		/* 每分配一个块就将位图同步到硬盘 */
		block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c000929d:	8b 55 d8             	mov    -0x28(%ebp),%edx
c00092a0:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00092a5:	8b 40 1c             	mov    0x1c(%eax),%eax
c00092a8:	8b 40 28             	mov    0x28(%eax),%eax
c00092ab:	29 c2                	sub    %eax,%edx
c00092ad:	89 d0                	mov    %edx,%eax
c00092af:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/fs/file.c:277
		ASSERT(block_bitmap_idx != 0);
c00092b2:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c00092b6:	75 1c                	jne    c00092d4 <file_write+0x131>
/work/x86_os_my/fs/file.c:277 (discriminator 1)
c00092b8:	68 83 cc 00 c0       	push   $0xc000cc83
c00092bd:	68 c8 ce 00 c0       	push   $0xc000cec8
c00092c2:	68 15 01 00 00       	push   $0x115
c00092c7:	68 99 cc 00 c0       	push   $0xc000cc99
c00092cc:	e8 11 90 ff ff       	call   c00022e2 <panic_spin>
c00092d1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:278
		bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c00092d4:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00092d9:	83 ec 04             	sub    $0x4,%esp
c00092dc:	6a 01                	push   $0x1
c00092de:	ff 75 d4             	pushl  -0x2c(%ebp)
c00092e1:	50                   	push   %eax
c00092e2:	e8 16 fa ff ff       	call   c0008cfd <bitmap_sync>
c00092e7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:282
	}

	/* 写入count个字节前，该文件已占用的块数 */
	uint32_t file_has_used_blocks = file->fd_inode->i_size / BLOCK_SIZE + 1;
c00092ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00092ed:	8b 40 08             	mov    0x8(%eax),%eax
c00092f0:	8b 40 04             	mov    0x4(%eax),%eax
c00092f3:	c1 e8 09             	shr    $0x9,%eax
c00092f6:	83 c0 01             	add    $0x1,%eax
c00092f9:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/fs/file.c:284
	/* 写入count个字节后，该文件将占用的块数 */
	uint32_t file_will_use_blocks = (file->fd_inode->i_size + count) / BLOCK_SIZE + 1;
c00092fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00092ff:	8b 40 08             	mov    0x8(%eax),%eax
c0009302:	8b 50 04             	mov    0x4(%eax),%edx
c0009305:	8b 45 10             	mov    0x10(%ebp),%eax
c0009308:	01 d0                	add    %edx,%eax
c000930a:	c1 e8 09             	shr    $0x9,%eax
c000930d:	83 c0 01             	add    $0x1,%eax
c0009310:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/fs/file.c:285
	ASSERT(file_will_use_blocks <= 140);
c0009313:	81 7d cc 8c 00 00 00 	cmpl   $0x8c,-0x34(%ebp)
c000931a:	76 1c                	jbe    c0009338 <file_write+0x195>
/work/x86_os_my/fs/file.c:285 (discriminator 1)
c000931c:	68 a3 cc 00 c0       	push   $0xc000cca3
c0009321:	68 c8 ce 00 c0       	push   $0xc000cec8
c0009326:	68 1d 01 00 00       	push   $0x11d
c000932b:	68 99 cc 00 c0       	push   $0xc000cc99
c0009330:	e8 ad 8f ff ff       	call   c00022e2 <panic_spin>
c0009335:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:287
	/* 通过此增量判断是否需要分配扇区，若增量为0，表示原扇区够用 */
	uint32_t add_blocks = file_will_use_blocks - file_has_used_blocks;
c0009338:	8b 45 cc             	mov    -0x34(%ebp),%eax
c000933b:	2b 45 d0             	sub    -0x30(%ebp),%eax
c000933e:	89 45 c8             	mov    %eax,-0x38(%ebp)
/work/x86_os_my/fs/file.c:294
	/* 将文件所有块地址收集到all_blocks，后面都统一在all_blocks中获取要写入的扇区地址
	 * 没有新增的数据块时，只更新 all_blocks
	 * 需要新增数据块时，除了 all_blocks 还要更新 file->fd_inode->i_sectors[x]
	 */
	/* 在同一数据块（扇区）内写入数据，不涉及到分配新扇区 */
	if (add_blocks == 0) {
c0009341:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
c0009345:	0f 85 8c 00 00 00    	jne    c00093d7 <file_write+0x234>
/work/x86_os_my/fs/file.c:295
		if (file_has_used_blocks <= 12 ) {	// 文件数据量将在12块之内
c000934b:	83 7d d0 0c          	cmpl   $0xc,-0x30(%ebp)
c000934f:	77 2e                	ja     c000937f <file_write+0x1dc>
/work/x86_os_my/fs/file.c:296
			block_idx = file_has_used_blocks - 1;	// 指向最后一个已占用的数据块（扇区）
c0009351:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0009354:	83 e8 01             	sub    $0x1,%eax
c0009357:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:297
			all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
c000935a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000935d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0009364:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0009367:	01 c2                	add    %eax,%edx
c0009369:	8b 45 08             	mov    0x8(%ebp),%eax
c000936c:	8b 40 08             	mov    0x8(%eax),%eax
c000936f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0009372:	83 c1 04             	add    $0x4,%ecx
c0009375:	8b 04 88             	mov    (%eax,%ecx,4),%eax
c0009378:	89 02                	mov    %eax,(%edx)
c000937a:	e9 4e 04 00 00       	jmp    c00097cd <file_write+0x62a>
/work/x86_os_my/fs/file.c:300
		} else {
			/* 未写入新数据之前已经占用了间接块,需要将间接块地址读进来 */
			ASSERT(file->fd_inode->i_sectors[12] != 0);	//一级间接表存在
c000937f:	8b 45 08             	mov    0x8(%ebp),%eax
c0009382:	8b 40 08             	mov    0x8(%eax),%eax
c0009385:	8b 40 40             	mov    0x40(%eax),%eax
c0009388:	85 c0                	test   %eax,%eax
c000938a:	75 1c                	jne    c00093a8 <file_write+0x205>
/work/x86_os_my/fs/file.c:300 (discriminator 1)
c000938c:	68 c0 cc 00 c0       	push   $0xc000ccc0
c0009391:	68 c8 ce 00 c0       	push   $0xc000cec8
c0009396:	68 2c 01 00 00       	push   $0x12c
c000939b:	68 99 cc 00 c0       	push   $0xc000cc99
c00093a0:	e8 3d 8f ff ff       	call   c00022e2 <panic_spin>
c00093a5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:301
			indirect_block_table = file->fd_inode->i_sectors[12];
c00093a8:	8b 45 08             	mov    0x8(%ebp),%eax
c00093ab:	8b 40 08             	mov    0x8(%eax),%eax
c00093ae:	8b 40 40             	mov    0x40(%eax),%eax
c00093b1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
/work/x86_os_my/fs/file.c:302
			ide_read(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);	//读出整个一级间接表512字节（128个间接块的地址）
c00093b4:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00093b7:	8d 48 30             	lea    0x30(%eax),%ecx
c00093ba:	8b 55 c4             	mov    -0x3c(%ebp),%edx
c00093bd:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00093c2:	8b 40 08             	mov    0x8(%eax),%eax
c00093c5:	6a 01                	push   $0x1
c00093c7:	51                   	push   %ecx
c00093c8:	52                   	push   %edx
c00093c9:	50                   	push   %eax
c00093ca:	e8 07 c6 ff ff       	call   c00059d6 <ide_read>
c00093cf:	83 c4 10             	add    $0x10,%esp
c00093d2:	e9 f6 03 00 00       	jmp    c00097cd <file_write+0x62a>
/work/x86_os_my/fs/file.c:308
		}
	} else {
	/* 若有增量，便涉及到分配新数据块（扇区），以及是否分配一级间接块表。
	 * 分三种情况处理： */
		/* 第一种情况：12个直接块够用*/
		if (file_will_use_blocks <= 12 ) {
c00093d7:	83 7d cc 0c          	cmpl   $0xc,-0x34(%ebp)
c00093db:	0f 87 2b 01 00 00    	ja     c000950c <file_write+0x369>
/work/x86_os_my/fs/file.c:310
			/* 将有剩余空间的可继续用的数据块（扇区）地址写入all_blocks */
			block_idx = file_has_used_blocks - 1;	// 指向最后一个已占用的数据块（扇区）
c00093e1:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00093e4:	83 e8 01             	sub    $0x1,%eax
c00093e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:311
			ASSERT(file->fd_inode->i_sectors[block_idx] != 0);
c00093ea:	8b 45 08             	mov    0x8(%ebp),%eax
c00093ed:	8b 40 08             	mov    0x8(%eax),%eax
c00093f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00093f3:	83 c2 04             	add    $0x4,%edx
c00093f6:	8b 04 90             	mov    (%eax,%edx,4),%eax
c00093f9:	85 c0                	test   %eax,%eax
c00093fb:	75 1c                	jne    c0009419 <file_write+0x276>
/work/x86_os_my/fs/file.c:311 (discriminator 1)
c00093fd:	68 e4 cc 00 c0       	push   $0xc000cce4
c0009402:	68 c8 ce 00 c0       	push   $0xc000cec8
c0009407:	68 37 01 00 00       	push   $0x137
c000940c:	68 99 cc 00 c0       	push   $0xc000cc99
c0009411:	e8 cc 8e ff ff       	call   c00022e2 <panic_spin>
c0009416:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:312
			all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
c0009419:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000941c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0009423:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0009426:	01 c2                	add    %eax,%edx
c0009428:	8b 45 08             	mov    0x8(%ebp),%eax
c000942b:	8b 40 08             	mov    0x8(%eax),%eax
c000942e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0009431:	83 c1 04             	add    $0x4,%ecx
c0009434:	8b 04 88             	mov    (%eax,%ecx,4),%eax
c0009437:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/file.c:315

			/* 将未来要用的新数据块（扇区）分配好后写入all_blocks */
			block_idx = file_has_used_blocks;		// 指向第一个要分配的新数据块（扇区）
c0009439:	8b 45 d0             	mov    -0x30(%ebp),%eax
c000943c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:316
			while (block_idx < file_will_use_blocks) {
c000943f:	e9 b7 00 00 00       	jmp    c00094fb <file_write+0x358>
/work/x86_os_my/fs/file.c:317
				block_lba = block_bitmap_alloc(cur_part);
c0009444:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0009449:	83 ec 0c             	sub    $0xc,%esp
c000944c:	50                   	push   %eax
c000944d:	e8 59 f8 ff ff       	call   c0008cab <block_bitmap_alloc>
c0009452:	83 c4 10             	add    $0x10,%esp
c0009455:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/file.c:318
				if (block_lba == -1) {
c0009458:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
c000945c:	75 1a                	jne    c0009478 <file_write+0x2d5>
/work/x86_os_my/fs/file.c:319
					printk("file_write: block_bitmap_alloc for situation 1 failed\n");
c000945e:	83 ec 0c             	sub    $0xc,%esp
c0009461:	68 10 cd 00 c0       	push   $0xc000cd10
c0009466:	e8 e4 cf ff ff       	call   c000644f <printk>
c000946b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:320
					return -1;
c000946e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009473:	e9 bd 04 00 00       	jmp    c0009935 <file_write+0x792>
/work/x86_os_my/fs/file.c:324
				}

				/* 写文件时，数据块未使用时肯定有 i_sectors[x]==0。因为文件删除时，会把i_sectors[x]里的数据块地址清0 */
				ASSERT(file->fd_inode->i_sectors[block_idx] == 0);	// 确保尚未分配扇区地址
c0009478:	8b 45 08             	mov    0x8(%ebp),%eax
c000947b:	8b 40 08             	mov    0x8(%eax),%eax
c000947e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0009481:	83 c2 04             	add    $0x4,%edx
c0009484:	8b 04 90             	mov    (%eax,%edx,4),%eax
c0009487:	85 c0                	test   %eax,%eax
c0009489:	74 1c                	je     c00094a7 <file_write+0x304>
/work/x86_os_my/fs/file.c:324 (discriminator 1)
c000948b:	68 48 cd 00 c0       	push   $0xc000cd48
c0009490:	68 c8 ce 00 c0       	push   $0xc000cec8
c0009495:	68 44 01 00 00       	push   $0x144
c000949a:	68 99 cc 00 c0       	push   $0xc000cc99
c000949f:	e8 3e 8e ff ff       	call   c00022e2 <panic_spin>
c00094a4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:325
				file->fd_inode->i_sectors[block_idx] = all_blocks[block_idx] = block_lba;		//处理直接块
c00094a7:	8b 45 08             	mov    0x8(%ebp),%eax
c00094aa:	8b 50 08             	mov    0x8(%eax),%edx
c00094ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00094b0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c00094b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00094ba:	01 c8                	add    %ecx,%eax
c00094bc:	8b 4d d8             	mov    -0x28(%ebp),%ecx
c00094bf:	89 08                	mov    %ecx,(%eax)
c00094c1:	8b 00                	mov    (%eax),%eax
c00094c3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c00094c6:	83 c1 04             	add    $0x4,%ecx
c00094c9:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
/work/x86_os_my/fs/file.c:328

				/* 每分配一个块就将位图同步到硬盘 */
				block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c00094cc:	8b 55 d8             	mov    -0x28(%ebp),%edx
c00094cf:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00094d4:	8b 40 1c             	mov    0x1c(%eax),%eax
c00094d7:	8b 40 28             	mov    0x28(%eax),%eax
c00094da:	29 c2                	sub    %eax,%edx
c00094dc:	89 d0                	mov    %edx,%eax
c00094de:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/fs/file.c:330
				// 这回怎么没有这句了：ASSERT(block_bitmap_idx != 0);
				bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c00094e1:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00094e6:	83 ec 04             	sub    $0x4,%esp
c00094e9:	6a 01                	push   $0x1
c00094eb:	ff 75 d4             	pushl  -0x2c(%ebp)
c00094ee:	50                   	push   %eax
c00094ef:	e8 09 f8 ff ff       	call   c0008cfd <bitmap_sync>
c00094f4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:332

				block_idx++;   // 下一个分配的新扇区
c00094f7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/file.c:316
			ASSERT(file->fd_inode->i_sectors[block_idx] != 0);
			all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];

			/* 将未来要用的新数据块（扇区）分配好后写入all_blocks */
			block_idx = file_has_used_blocks;		// 指向第一个要分配的新数据块（扇区）
			while (block_idx < file_will_use_blocks) {
c00094fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00094fe:	3b 45 cc             	cmp    -0x34(%ebp),%eax
c0009501:	0f 82 3d ff ff ff    	jb     c0009444 <file_write+0x2a1>
c0009507:	e9 c1 02 00 00       	jmp    c00097cd <file_write+0x62a>
/work/x86_os_my/fs/file.c:334
				// 这回怎么没有这句了：ASSERT(block_bitmap_idx != 0);
				bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);

				block_idx++;   // 下一个分配的新扇区
			}
		} else if (file_has_used_blocks <= 12 && file_will_use_blocks > 12) {
c000950c:	83 7d d0 0c          	cmpl   $0xc,-0x30(%ebp)
c0009510:	0f 87 af 01 00 00    	ja     c00096c5 <file_write+0x522>
/work/x86_os_my/fs/file.c:334 (discriminator 1)
c0009516:	83 7d cc 0c          	cmpl   $0xc,-0x34(%ebp)
c000951a:	0f 86 a5 01 00 00    	jbe    c00096c5 <file_write+0x522>
/work/x86_os_my/fs/file.c:338
		/* 第二种情况：旧数据在12个直接块内，新数据将使用间接块【可能也使用一些直接块】 */

			/* 先将有剩余空间的可继续用的扇区地址收集到all_blocks */
			block_idx = file_has_used_blocks - 1;	// 指向最后一个已占用的数据块（扇区）
c0009520:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0009523:	83 e8 01             	sub    $0x1,%eax
c0009526:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:339
			all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];						//处理直接块
c0009529:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000952c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0009533:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0009536:	01 c2                	add    %eax,%edx
c0009538:	8b 45 08             	mov    0x8(%ebp),%eax
c000953b:	8b 40 08             	mov    0x8(%eax),%eax
c000953e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0009541:	83 c1 04             	add    $0x4,%ecx
c0009544:	8b 04 88             	mov    (%eax,%ecx,4),%eax
c0009547:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/file.c:342

			/* 创建一级间接块表 */
			block_lba = block_bitmap_alloc(cur_part);
c0009549:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000954e:	83 ec 0c             	sub    $0xc,%esp
c0009551:	50                   	push   %eax
c0009552:	e8 54 f7 ff ff       	call   c0008cab <block_bitmap_alloc>
c0009557:	83 c4 10             	add    $0x10,%esp
c000955a:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/file.c:343
			if (block_lba == -1) {
c000955d:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
c0009561:	75 1a                	jne    c000957d <file_write+0x3da>
/work/x86_os_my/fs/file.c:344
				printk("file_write: block_bitmap_alloc for situation 2 failed\n");
c0009563:	83 ec 0c             	sub    $0xc,%esp
c0009566:	68 74 cd 00 c0       	push   $0xc000cd74
c000956b:	e8 df ce ff ff       	call   c000644f <printk>
c0009570:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:345
				return -1;
c0009573:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009578:	e9 b8 03 00 00       	jmp    c0009935 <file_write+0x792>
/work/x86_os_my/fs/file.c:347
			}
			ASSERT(file->fd_inode->i_sectors[12] == 0);  // 一级间接块表未建立
c000957d:	8b 45 08             	mov    0x8(%ebp),%eax
c0009580:	8b 40 08             	mov    0x8(%eax),%eax
c0009583:	8b 40 40             	mov    0x40(%eax),%eax
c0009586:	85 c0                	test   %eax,%eax
c0009588:	74 1c                	je     c00095a6 <file_write+0x403>
/work/x86_os_my/fs/file.c:347 (discriminator 1)
c000958a:	68 ac cd 00 c0       	push   $0xc000cdac
c000958f:	68 c8 ce 00 c0       	push   $0xc000cec8
c0009594:	68 5b 01 00 00       	push   $0x15b
c0009599:	68 99 cc 00 c0       	push   $0xc000cc99
c000959e:	e8 3f 8d ff ff       	call   c00022e2 <panic_spin>
c00095a3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:348
			indirect_block_table = file->fd_inode->i_sectors[12] = block_lba;	// 一级间接块索引表建立了！
c00095a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00095a9:	8b 40 08             	mov    0x8(%eax),%eax
c00095ac:	8b 55 d8             	mov    -0x28(%ebp),%edx
c00095af:	89 50 40             	mov    %edx,0x40(%eax)
c00095b2:	8b 40 40             	mov    0x40(%eax),%eax
c00095b5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
/work/x86_os_my/fs/file.c:351
			//这里怎么没有同步一级间接块表占用的数据块到硬盘？？不是：每分配一个块就将位图同步到硬盘 吗？

			block_idx = file_has_used_blocks;		// 指向第一个要分配的新数据块（扇区）
c00095b8:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00095bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:352
			while (block_idx < file_will_use_blocks) {
c00095be:	e9 d3 00 00 00       	jmp    c0009696 <file_write+0x4f3>
/work/x86_os_my/fs/file.c:353
				block_lba = block_bitmap_alloc(cur_part);
c00095c3:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00095c8:	83 ec 0c             	sub    $0xc,%esp
c00095cb:	50                   	push   %eax
c00095cc:	e8 da f6 ff ff       	call   c0008cab <block_bitmap_alloc>
c00095d1:	83 c4 10             	add    $0x10,%esp
c00095d4:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/file.c:354
				if (block_lba == -1) {
c00095d7:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
c00095db:	75 1a                	jne    c00095f7 <file_write+0x454>
/work/x86_os_my/fs/file.c:355
					printk("file_write: block_bitmap_alloc for situation 2 failed\n");
c00095dd:	83 ec 0c             	sub    $0xc,%esp
c00095e0:	68 74 cd 00 c0       	push   $0xc000cd74
c00095e5:	e8 65 ce ff ff       	call   c000644f <printk>
c00095ea:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:356
					return -1;
c00095ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00095f2:	e9 3e 03 00 00       	jmp    c0009935 <file_write+0x792>
/work/x86_os_my/fs/file.c:359
				}

				if (block_idx < 12) {	// 新创建的数据块仍然是直接块！
c00095f7:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
c00095fb:	77 56                	ja     c0009653 <file_write+0x4b0>
/work/x86_os_my/fs/file.c:360
					ASSERT(file->fd_inode->i_sectors[block_idx] == 0);
c00095fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0009600:	8b 40 08             	mov    0x8(%eax),%eax
c0009603:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0009606:	83 c2 04             	add    $0x4,%edx
c0009609:	8b 04 90             	mov    (%eax,%edx,4),%eax
c000960c:	85 c0                	test   %eax,%eax
c000960e:	74 1c                	je     c000962c <file_write+0x489>
/work/x86_os_my/fs/file.c:360 (discriminator 1)
c0009610:	68 48 cd 00 c0       	push   $0xc000cd48
c0009615:	68 c8 ce 00 c0       	push   $0xc000cec8
c000961a:	68 68 01 00 00       	push   $0x168
c000961f:	68 99 cc 00 c0       	push   $0xc000cc99
c0009624:	e8 b9 8c ff ff       	call   c00022e2 <panic_spin>
c0009629:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:361
					file->fd_inode->i_sectors[block_idx] = all_blocks[block_idx] = block_lba;	//处理直接块
c000962c:	8b 45 08             	mov    0x8(%ebp),%eax
c000962f:	8b 50 08             	mov    0x8(%eax),%edx
c0009632:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0009635:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c000963c:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000963f:	01 c8                	add    %ecx,%eax
c0009641:	8b 4d d8             	mov    -0x28(%ebp),%ecx
c0009644:	89 08                	mov    %ecx,(%eax)
c0009646:	8b 00                	mov    (%eax),%eax
c0009648:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c000964b:	83 c1 04             	add    $0x4,%ecx
c000964e:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
c0009651:	eb 14                	jmp    c0009667 <file_write+0x4c4>
/work/x86_os_my/fs/file.c:363
				} else {	// 新创建的数据块，是间接块。间接块只写入到all_block数组中,待全部分配完成后一次性同步到硬盘
					all_blocks[block_idx] = block_lba;											//处理间接块
c0009653:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0009656:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000965d:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0009660:	01 c2                	add    %eax,%edx
c0009662:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0009665:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/file.c:367
				}

				/* 每分配一个块就将位图同步到硬盘 */
				block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c0009667:	8b 55 d8             	mov    -0x28(%ebp),%edx
c000966a:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000966f:	8b 40 1c             	mov    0x1c(%eax),%eax
c0009672:	8b 40 28             	mov    0x28(%eax),%eax
c0009675:	29 c2                	sub    %eax,%edx
c0009677:	89 d0                	mov    %edx,%eax
c0009679:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/fs/file.c:368
				bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c000967c:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0009681:	83 ec 04             	sub    $0x4,%esp
c0009684:	6a 01                	push   $0x1
c0009686:	ff 75 d4             	pushl  -0x2c(%ebp)
c0009689:	50                   	push   %eax
c000968a:	e8 6e f6 ff ff       	call   c0008cfd <bitmap_sync>
c000968f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:370

				block_idx++;   // 下一个新扇区
c0009692:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/file.c:352
			ASSERT(file->fd_inode->i_sectors[12] == 0);  // 一级间接块表未建立
			indirect_block_table = file->fd_inode->i_sectors[12] = block_lba;	// 一级间接块索引表建立了！
			//这里怎么没有同步一级间接块表占用的数据块到硬盘？？不是：每分配一个块就将位图同步到硬盘 吗？

			block_idx = file_has_used_blocks;		// 指向第一个要分配的新数据块（扇区）
			while (block_idx < file_will_use_blocks) {
c0009696:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0009699:	3b 45 cc             	cmp    -0x34(%ebp),%eax
c000969c:	0f 82 21 ff ff ff    	jb     c00095c3 <file_write+0x420>
/work/x86_os_my/fs/file.c:372
				block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
				bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);

				block_idx++;   // 下一个新扇区
			}
			ide_write(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);	// 整个一级间接块表的内容，同步到硬盘
c00096a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00096a5:	8d 48 30             	lea    0x30(%eax),%ecx
c00096a8:	8b 55 c4             	mov    -0x3c(%ebp),%edx
c00096ab:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00096b0:	8b 40 08             	mov    0x8(%eax),%eax
c00096b3:	6a 01                	push   $0x1
c00096b5:	51                   	push   %ecx
c00096b6:	52                   	push   %edx
c00096b7:	50                   	push   %eax
c00096b8:	e8 8d c4 ff ff       	call   c0005b4a <ide_write>
c00096bd:	83 c4 10             	add    $0x10,%esp
c00096c0:	e9 08 01 00 00       	jmp    c00097cd <file_write+0x62a>
/work/x86_os_my/fs/file.c:373
		} else if (file_has_used_blocks > 12) {
c00096c5:	83 7d d0 0c          	cmpl   $0xc,-0x30(%ebp)
c00096c9:	0f 86 fe 00 00 00    	jbe    c00097cd <file_write+0x62a>
/work/x86_os_my/fs/file.c:375
		/* 第三种情况：新数据使用间接块*/
			ASSERT(file->fd_inode->i_sectors[12] != 0);				// 一级间接块表已建立
c00096cf:	8b 45 08             	mov    0x8(%ebp),%eax
c00096d2:	8b 40 08             	mov    0x8(%eax),%eax
c00096d5:	8b 40 40             	mov    0x40(%eax),%eax
c00096d8:	85 c0                	test   %eax,%eax
c00096da:	75 1c                	jne    c00096f8 <file_write+0x555>
/work/x86_os_my/fs/file.c:375 (discriminator 1)
c00096dc:	68 c0 cc 00 c0       	push   $0xc000ccc0
c00096e1:	68 c8 ce 00 c0       	push   $0xc000cec8
c00096e6:	68 77 01 00 00       	push   $0x177
c00096eb:	68 99 cc 00 c0       	push   $0xc000cc99
c00096f0:	e8 ed 8b ff ff       	call   c00022e2 <panic_spin>
c00096f5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:376
			indirect_block_table = file->fd_inode->i_sectors[12];	// 一级间接表地址
c00096f8:	8b 45 08             	mov    0x8(%ebp),%eax
c00096fb:	8b 40 08             	mov    0x8(%eax),%eax
c00096fe:	8b 40 40             	mov    0x40(%eax),%eax
c0009701:	89 45 c4             	mov    %eax,-0x3c(%ebp)
/work/x86_os_my/fs/file.c:379

			/* 已使用的间接块也将被读入all_blocks，无须单独收录 */
			ide_read(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);	// 获取所有间接块地址
c0009704:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0009707:	8d 48 30             	lea    0x30(%eax),%ecx
c000970a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
c000970d:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0009712:	8b 40 08             	mov    0x8(%eax),%eax
c0009715:	6a 01                	push   $0x1
c0009717:	51                   	push   %ecx
c0009718:	52                   	push   %edx
c0009719:	50                   	push   %eax
c000971a:	e8 b7 c2 ff ff       	call   c00059d6 <ide_read>
c000971f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:381

			block_idx = file_has_used_blocks;		// 指向第一个要分配的新数据块（扇区）
c0009722:	8b 45 d0             	mov    -0x30(%ebp),%eax
c0009725:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:382
			while (block_idx < file_will_use_blocks) {
c0009728:	eb 79                	jmp    c00097a3 <file_write+0x600>
/work/x86_os_my/fs/file.c:383
				block_lba = block_bitmap_alloc(cur_part);
c000972a:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000972f:	83 ec 0c             	sub    $0xc,%esp
c0009732:	50                   	push   %eax
c0009733:	e8 73 f5 ff ff       	call   c0008cab <block_bitmap_alloc>
c0009738:	83 c4 10             	add    $0x10,%esp
c000973b:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/file.c:384
				if (block_lba == -1) {
c000973e:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
c0009742:	75 1a                	jne    c000975e <file_write+0x5bb>
/work/x86_os_my/fs/file.c:385
					printk("file_write: block_bitmap_alloc for situation 3 failed\n");
c0009744:	83 ec 0c             	sub    $0xc,%esp
c0009747:	68 d0 cd 00 c0       	push   $0xc000cdd0
c000974c:	e8 fe cc ff ff       	call   c000644f <printk>
c0009751:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:386
					return -1;
c0009754:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0009759:	e9 d7 01 00 00       	jmp    c0009935 <file_write+0x792>
/work/x86_os_my/fs/file.c:388
				}
				all_blocks[block_idx++] = block_lba;											//处理间接块
c000975e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0009761:	8d 50 01             	lea    0x1(%eax),%edx
c0009764:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0009767:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000976e:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0009771:	01 c2                	add    %eax,%edx
c0009773:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0009776:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/file.c:391

				/* 每分配一个块就将位图同步到硬盘 */
				block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c0009778:	8b 55 d8             	mov    -0x28(%ebp),%edx
c000977b:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0009780:	8b 40 1c             	mov    0x1c(%eax),%eax
c0009783:	8b 40 28             	mov    0x28(%eax),%eax
c0009786:	29 c2                	sub    %eax,%edx
c0009788:	89 d0                	mov    %edx,%eax
c000978a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/fs/file.c:392
				bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c000978d:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0009792:	83 ec 04             	sub    $0x4,%esp
c0009795:	6a 01                	push   $0x1
c0009797:	ff 75 d4             	pushl  -0x2c(%ebp)
c000979a:	50                   	push   %eax
c000979b:	e8 5d f5 ff ff       	call   c0008cfd <bitmap_sync>
c00097a0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:382

			/* 已使用的间接块也将被读入all_blocks，无须单独收录 */
			ide_read(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);	// 获取所有间接块地址

			block_idx = file_has_used_blocks;		// 指向第一个要分配的新数据块（扇区）
			while (block_idx < file_will_use_blocks) {
c00097a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00097a6:	3b 45 cc             	cmp    -0x34(%ebp),%eax
c00097a9:	0f 82 7b ff ff ff    	jb     c000972a <file_write+0x587>
/work/x86_os_my/fs/file.c:394

				/* 每分配一个块就将位图同步到硬盘 */
				block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
				bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
			}
			ide_write(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);	// 整个一级间接块表的内容，同步到硬盘
c00097af:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00097b2:	8d 48 30             	lea    0x30(%eax),%ecx
c00097b5:	8b 55 c4             	mov    -0x3c(%ebp),%edx
c00097b8:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00097bd:	8b 40 08             	mov    0x8(%eax),%eax
c00097c0:	6a 01                	push   $0x1
c00097c2:	51                   	push   %ecx
c00097c3:	52                   	push   %edx
c00097c4:	50                   	push   %eax
c00097c5:	e8 80 c3 ff ff       	call   c0005b4a <ide_write>
c00097ca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:400
		}
	}//块地址已经收集到all_blocks中


	/* 写数据 */
	const uint8_t* src = buf;		// 用src指向buf中待写入的数据
c00097cd:	8b 45 0c             	mov    0xc(%ebp),%eax
c00097d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:401
	uint32_t bytes_written = 0;		// 已写入数据的大小
c00097d3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/file.c:407
	uint32_t sec_idx;				// 扇区索引
	uint32_t sec_lba;				// 扇区地址
	uint32_t sec_off_bytes;			// 扇区内字节偏移量
	uint32_t sec_left_bytes;		// 扇区内剩余字节量
	uint32_t chunk_size;			// 每次写入硬盘的数据块大小
	uint32_t size_left = count;		// 未写入数据的大小
c00097da:	8b 45 10             	mov    0x10(%ebp),%eax
c00097dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:408
	bool first_write_block = true;	// 数据块（扇区）含有剩余空间的标识
c00097e0:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:409
	file->fd_pos = file->fd_inode->i_size - 1;	// 文件读写指针fd_pos为"文件大小-1"
c00097e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00097ea:	8b 40 08             	mov    0x8(%eax),%eax
c00097ed:	8b 40 04             	mov    0x4(%eax),%eax
c00097f0:	8d 50 ff             	lea    -0x1(%eax),%edx
c00097f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00097f6:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/file.c:410
	while (bytes_written < count) {	// 直到写完所有数据
c00097f8:	e9 f2 00 00 00       	jmp    c00098ef <file_write+0x74c>
/work/x86_os_my/fs/file.c:411
		memset(io_buf, 0, BLOCK_SIZE);
c00097fd:	83 ec 04             	sub    $0x4,%esp
c0009800:	68 00 02 00 00       	push   $0x200
c0009805:	6a 00                	push   $0x0
c0009807:	ff 75 e0             	pushl  -0x20(%ebp)
c000980a:	e8 75 9f ff ff       	call   c0003784 <memset>
c000980f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:412
		sec_idx = file->fd_inode->i_size / BLOCK_SIZE;	// 文件已占用的最后一个数据块
c0009812:	8b 45 08             	mov    0x8(%ebp),%eax
c0009815:	8b 40 08             	mov    0x8(%eax),%eax
c0009818:	8b 40 04             	mov    0x4(%eax),%eax
c000981b:	c1 e8 09             	shr    $0x9,%eax
c000981e:	89 45 c0             	mov    %eax,-0x40(%ebp)
/work/x86_os_my/fs/file.c:413
		sec_lba = all_blocks[sec_idx];
c0009821:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0009824:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c000982b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000982e:	01 d0                	add    %edx,%eax
c0009830:	8b 00                	mov    (%eax),%eax
c0009832:	89 45 bc             	mov    %eax,-0x44(%ebp)
/work/x86_os_my/fs/file.c:414
		sec_off_bytes = file->fd_inode->i_size % BLOCK_SIZE;
c0009835:	8b 45 08             	mov    0x8(%ebp),%eax
c0009838:	8b 40 08             	mov    0x8(%eax),%eax
c000983b:	8b 40 04             	mov    0x4(%eax),%eax
c000983e:	25 ff 01 00 00       	and    $0x1ff,%eax
c0009843:	89 45 b8             	mov    %eax,-0x48(%ebp)
/work/x86_os_my/fs/file.c:415
		sec_left_bytes = BLOCK_SIZE - sec_off_bytes;
c0009846:	b8 00 02 00 00       	mov    $0x200,%eax
c000984b:	2b 45 b8             	sub    -0x48(%ebp),%eax
c000984e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
/work/x86_os_my/fs/file.c:418

		/* 判断此次写入硬盘的数据大小 */
		chunk_size = size_left < sec_left_bytes ? size_left : sec_left_bytes;
c0009851:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0009854:	39 45 b4             	cmp    %eax,-0x4c(%ebp)
c0009857:	0f 46 45 b4          	cmovbe -0x4c(%ebp),%eax
c000985b:	89 45 b0             	mov    %eax,-0x50(%ebp)
/work/x86_os_my/fs/file.c:419
		if (first_write_block) {
c000985e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0009862:	74 20                	je     c0009884 <file_write+0x6e1>
/work/x86_os_my/fs/file.c:420
			ide_read(cur_part->my_disk, sec_lba, io_buf, 1);	//先读出
c0009864:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0009869:	8b 40 08             	mov    0x8(%eax),%eax
c000986c:	6a 01                	push   $0x1
c000986e:	ff 75 e0             	pushl  -0x20(%ebp)
c0009871:	ff 75 bc             	pushl  -0x44(%ebp)
c0009874:	50                   	push   %eax
c0009875:	e8 5c c1 ff ff       	call   c00059d6 <ide_read>
c000987a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:421
			first_write_block = false;
c000987d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:423
		}
		memcpy(io_buf + sec_off_bytes, src, chunk_size);		//再写入
c0009884:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0009887:	8b 45 b8             	mov    -0x48(%ebp),%eax
c000988a:	01 d0                	add    %edx,%eax
c000988c:	83 ec 04             	sub    $0x4,%esp
c000988f:	ff 75 b0             	pushl  -0x50(%ebp)
c0009892:	ff 75 f0             	pushl  -0x10(%ebp)
c0009895:	50                   	push   %eax
c0009896:	e8 3b 9f ff ff       	call   c00037d6 <memcpy>
c000989b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:424
		ide_write(cur_part->my_disk, sec_lba, io_buf, 1);
c000989e:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c00098a3:	8b 40 08             	mov    0x8(%eax),%eax
c00098a6:	6a 01                	push   $0x1
c00098a8:	ff 75 e0             	pushl  -0x20(%ebp)
c00098ab:	ff 75 bc             	pushl  -0x44(%ebp)
c00098ae:	50                   	push   %eax
c00098af:	e8 96 c2 ff ff       	call   c0005b4a <ide_write>
c00098b4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:427
		//printk("file write at lba 0x%x\n", sec_lba);

		src += chunk_size;
c00098b7:	8b 45 b0             	mov    -0x50(%ebp),%eax
c00098ba:	01 45 f0             	add    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:428
		file->fd_inode->i_size += chunk_size;	// 文件大小
c00098bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00098c0:	8b 40 08             	mov    0x8(%eax),%eax
c00098c3:	8b 55 08             	mov    0x8(%ebp),%edx
c00098c6:	8b 52 08             	mov    0x8(%edx),%edx
c00098c9:	8b 4a 04             	mov    0x4(%edx),%ecx
c00098cc:	8b 55 b0             	mov    -0x50(%ebp),%edx
c00098cf:	01 ca                	add    %ecx,%edx
c00098d1:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/file.c:429
		file->fd_pos += chunk_size;				// 文件指针位置
c00098d4:	8b 45 08             	mov    0x8(%ebp),%eax
c00098d7:	8b 10                	mov    (%eax),%edx
c00098d9:	8b 45 b0             	mov    -0x50(%ebp),%eax
c00098dc:	01 c2                	add    %eax,%edx
c00098de:	8b 45 08             	mov    0x8(%ebp),%eax
c00098e1:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/file.c:430
		bytes_written += chunk_size;
c00098e3:	8b 45 b0             	mov    -0x50(%ebp),%eax
c00098e6:	01 45 ec             	add    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:431
		size_left -= chunk_size;
c00098e9:	8b 45 b0             	mov    -0x50(%ebp),%eax
c00098ec:	29 45 e8             	sub    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:410
	uint32_t sec_left_bytes;		// 扇区内剩余字节量
	uint32_t chunk_size;			// 每次写入硬盘的数据块大小
	uint32_t size_left = count;		// 未写入数据的大小
	bool first_write_block = true;	// 数据块（扇区）含有剩余空间的标识
	file->fd_pos = file->fd_inode->i_size - 1;	// 文件读写指针fd_pos为"文件大小-1"
	while (bytes_written < count) {	// 直到写完所有数据
c00098ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00098f2:	3b 45 10             	cmp    0x10(%ebp),%eax
c00098f5:	0f 82 02 ff ff ff    	jb     c00097fd <file_write+0x65a>
/work/x86_os_my/fs/file.c:433
		file->fd_inode->i_size += chunk_size;	// 文件大小
		file->fd_pos += chunk_size;				// 文件指针位置
		bytes_written += chunk_size;
		size_left -= chunk_size;
	}
	inode_sync(cur_part, file->fd_inode, io_buf);	// 更新文件对应的inode结构，io_buf只是个缓冲区
c00098fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00098fe:	8b 50 08             	mov    0x8(%eax),%edx
c0009901:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0009906:	83 ec 04             	sub    $0x4,%esp
c0009909:	ff 75 e0             	pushl  -0x20(%ebp)
c000990c:	52                   	push   %edx
c000990d:	50                   	push   %eax
c000990e:	e8 05 ec ff ff       	call   c0008518 <inode_sync>
c0009913:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:434
	sys_free(all_blocks);
c0009916:	83 ec 0c             	sub    $0xc,%esp
c0009919:	ff 75 dc             	pushl  -0x24(%ebp)
c000991c:	e8 99 99 ff ff       	call   c00032ba <sys_free>
c0009921:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:435
	sys_free(io_buf);
c0009924:	83 ec 0c             	sub    $0xc,%esp
c0009927:	ff 75 e0             	pushl  -0x20(%ebp)
c000992a:	e8 8b 99 ff ff       	call   c00032ba <sys_free>
c000992f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:436
	return bytes_written;
c0009932:	8b 45 ec             	mov    -0x14(%ebp),%eax
/work/x86_os_my/fs/file.c:437
}
c0009935:	c9                   	leave  
c0009936:	c3                   	ret    

c0009937 <file_read>:
file_read():
/work/x86_os_my/fs/file.c:441


/* 从文件file中读取count个字节写入buf, 返回读出的字节数,若到文件尾则返回-1 */
int32_t file_read(struct file* file, void* buf, uint32_t count) {
c0009937:	55                   	push   %ebp
c0009938:	89 e5                	mov    %esp,%ebp
c000993a:	83 ec 48             	sub    $0x48,%esp
/work/x86_os_my/fs/file.c:442
	uint8_t* buf_dst = (uint8_t*)buf;
c000993d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0009940:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:443
	uint32_t size = count, size_left = size;
c0009943:	8b 45 10             	mov    0x10(%ebp),%eax
c0009946:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0009949:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000994c:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:446

	/* 若要读取的字节数超过了文件可读的剩余量, 就用剩余量做为待读取的字节数 */
	if ((file->fd_pos + count) > file->fd_inode->i_size) {
c000994f:	8b 45 08             	mov    0x8(%ebp),%eax
c0009952:	8b 10                	mov    (%eax),%edx
c0009954:	8b 45 10             	mov    0x10(%ebp),%eax
c0009957:	01 c2                	add    %eax,%edx
c0009959:	8b 45 08             	mov    0x8(%ebp),%eax
c000995c:	8b 40 08             	mov    0x8(%eax),%eax
c000995f:	8b 40 04             	mov    0x4(%eax),%eax
c0009962:	39 c2                	cmp    %eax,%edx
c0009964:	76 2b                	jbe    c0009991 <file_read+0x5a>
/work/x86_os_my/fs/file.c:447
		size = file->fd_inode->i_size - file->fd_pos;
c0009966:	8b 45 08             	mov    0x8(%ebp),%eax
c0009969:	8b 40 08             	mov    0x8(%eax),%eax
c000996c:	8b 50 04             	mov    0x4(%eax),%edx
c000996f:	8b 45 08             	mov    0x8(%ebp),%eax
c0009972:	8b 00                	mov    (%eax),%eax
c0009974:	29 c2                	sub    %eax,%edx
c0009976:	89 d0                	mov    %edx,%eax
c0009978:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/file.c:448
		size_left = size;
c000997b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000997e:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:449
		if (size == 0) {	// 若到文件尾则返回-1
c0009981:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0009985:	75 0a                	jne    c0009991 <file_read+0x5a>
/work/x86_os_my/fs/file.c:450
			return -1;
c0009987:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000998c:	e9 4d 03 00 00       	jmp    c0009cde <file_read+0x3a7>
/work/x86_os_my/fs/file.c:454
		}
	}

	uint8_t* io_buf = sys_malloc(BLOCK_SIZE);
c0009991:	83 ec 0c             	sub    $0xc,%esp
c0009994:	68 00 02 00 00       	push   $0x200
c0009999:	e8 ef 92 ff ff       	call   c0002c8d <sys_malloc>
c000999e:	83 c4 10             	add    $0x10,%esp
c00099a1:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/file.c:455
	if (io_buf == NULL) {
c00099a4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c00099a8:	75 10                	jne    c00099ba <file_read+0x83>
/work/x86_os_my/fs/file.c:456
		printk("file_read: sys_malloc for io_buf failed\n");
c00099aa:	83 ec 0c             	sub    $0xc,%esp
c00099ad:	68 08 ce 00 c0       	push   $0xc000ce08
c00099b2:	e8 98 ca ff ff       	call   c000644f <printk>
c00099b7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:458
	}
	uint32_t* all_blocks = (uint32_t*)sys_malloc(BLOCK_SIZE + 48);		// 用来记录文件所有的块地址【140*4=560字节】
c00099ba:	83 ec 0c             	sub    $0xc,%esp
c00099bd:	68 30 02 00 00       	push   $0x230
c00099c2:	e8 c6 92 ff ff       	call   c0002c8d <sys_malloc>
c00099c7:	83 c4 10             	add    $0x10,%esp
c00099ca:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/file.c:459
	if (all_blocks == NULL) {
c00099cd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c00099d1:	75 1a                	jne    c00099ed <file_read+0xb6>
/work/x86_os_my/fs/file.c:460
		printk("file_read: sys_malloc for all_blocks failed\n");
c00099d3:	83 ec 0c             	sub    $0xc,%esp
c00099d6:	68 34 ce 00 c0       	push   $0xc000ce34
c00099db:	e8 6f ca ff ff       	call   c000644f <printk>
c00099e0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:461
		return -1;
c00099e3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c00099e8:	e9 f1 02 00 00       	jmp    c0009cde <file_read+0x3a7>
/work/x86_os_my/fs/file.c:464
	}

	uint32_t block_read_start_idx = file->fd_pos / BLOCK_SIZE;			// 数据所在块的起始地址
c00099ed:	8b 45 08             	mov    0x8(%ebp),%eax
c00099f0:	8b 00                	mov    (%eax),%eax
c00099f2:	c1 e8 09             	shr    $0x9,%eax
c00099f5:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/file.c:465
	uint32_t block_read_end_idx = (file->fd_pos + size) / BLOCK_SIZE;	// 数据所在块的终止地址
c00099f8:	8b 45 08             	mov    0x8(%ebp),%eax
c00099fb:	8b 10                	mov    (%eax),%edx
c00099fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0009a00:	01 d0                	add    %edx,%eax
c0009a02:	c1 e8 09             	shr    $0x9,%eax
c0009a05:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/fs/file.c:466
	uint32_t read_blocks = block_read_start_idx - block_read_end_idx;	// 如增量为0,表示数据在同一扇区
c0009a08:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0009a0b:	2b 45 d4             	sub    -0x2c(%ebp),%eax
c0009a0e:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/fs/file.c:467
	ASSERT(block_read_start_idx < 139 && block_read_end_idx < 139);
c0009a11:	81 7d d8 8a 00 00 00 	cmpl   $0x8a,-0x28(%ebp)
c0009a18:	77 09                	ja     c0009a23 <file_read+0xec>
/work/x86_os_my/fs/file.c:467 (discriminator 1)
c0009a1a:	81 7d d4 8a 00 00 00 	cmpl   $0x8a,-0x2c(%ebp)
c0009a21:	76 1c                	jbe    c0009a3f <file_read+0x108>
/work/x86_os_my/fs/file.c:467 (discriminator 3)
c0009a23:	68 64 ce 00 c0       	push   $0xc000ce64
c0009a28:	68 d4 ce 00 c0       	push   $0xc000ced4
c0009a2d:	68 d3 01 00 00       	push   $0x1d3
c0009a32:	68 99 cc 00 c0       	push   $0xc000cc99
c0009a37:	e8 a6 88 ff ff       	call   c00022e2 <panic_spin>
c0009a3c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:474
	int32_t indirect_block_table;	// 获取一级间接表地址
	uint32_t block_idx;				// 获取待读的块地址

	/* 以下开始构建all_blocks块地址数组，专门存储用到的块地址 */
	// 在同一扇区内读数据,不涉及到跨扇区读取
	if (read_blocks == 0) {
c0009a3f:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
c0009a43:	0f 85 84 00 00 00    	jne    c0009acd <file_read+0x196>
/work/x86_os_my/fs/file.c:475
		ASSERT(block_read_end_idx == block_read_start_idx);
c0009a49:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0009a4c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c0009a4f:	74 1c                	je     c0009a6d <file_read+0x136>
/work/x86_os_my/fs/file.c:475 (discriminator 1)
c0009a51:	68 9c ce 00 c0       	push   $0xc000ce9c
c0009a56:	68 d4 ce 00 c0       	push   $0xc000ced4
c0009a5b:	68 db 01 00 00       	push   $0x1db
c0009a60:	68 99 cc 00 c0       	push   $0xc000cc99
c0009a65:	e8 78 88 ff ff       	call   c00022e2 <panic_spin>
c0009a6a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:476
		if (block_read_end_idx < 12 ) {	// 待读的数据在12个直接块之内
c0009a6d:	83 7d d4 0b          	cmpl   $0xb,-0x2c(%ebp)
c0009a71:	77 2b                	ja     c0009a9e <file_read+0x167>
/work/x86_os_my/fs/file.c:477
			block_idx = block_read_end_idx;
c0009a73:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c0009a76:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:478
			all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
c0009a79:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0009a7c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0009a83:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0009a86:	01 c2                	add    %eax,%edx
c0009a88:	8b 45 08             	mov    0x8(%ebp),%eax
c0009a8b:	8b 40 08             	mov    0x8(%eax),%eax
c0009a8e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0009a91:	83 c1 04             	add    $0x4,%ecx
c0009a94:	8b 04 88             	mov    (%eax,%ecx,4),%eax
c0009a97:	89 02                	mov    %eax,(%edx)
c0009a99:	e9 5c 01 00 00       	jmp    c0009bfa <file_read+0x2c3>
/work/x86_os_my/fs/file.c:480
		} else {	// 若用到了一级间接块表,需要将表中间接块读进来
			indirect_block_table = file->fd_inode->i_sectors[12];
c0009a9e:	8b 45 08             	mov    0x8(%ebp),%eax
c0009aa1:	8b 40 08             	mov    0x8(%eax),%eax
c0009aa4:	8b 40 40             	mov    0x40(%eax),%eax
c0009aa7:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/fs/file.c:481
			ide_read(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);
c0009aaa:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0009aad:	8d 48 30             	lea    0x30(%eax),%ecx
c0009ab0:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0009ab3:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0009ab8:	8b 40 08             	mov    0x8(%eax),%eax
c0009abb:	6a 01                	push   $0x1
c0009abd:	51                   	push   %ecx
c0009abe:	52                   	push   %edx
c0009abf:	50                   	push   %eax
c0009ac0:	e8 11 bf ff ff       	call   c00059d6 <ide_read>
c0009ac5:	83 c4 10             	add    $0x10,%esp
c0009ac8:	e9 2d 01 00 00       	jmp    c0009bfa <file_read+0x2c3>
/work/x86_os_my/fs/file.c:486
		}
	} else {
	// 若要读多个数据块（扇区）
		/* 第一种情况: 起始块和终止块属于直接块*/
		if (block_read_end_idx < 12 ) {	  // 数据结束所在的块属于直接块
c0009acd:	83 7d d4 0b          	cmpl   $0xb,-0x2c(%ebp)
c0009ad1:	77 39                	ja     c0009b0c <file_read+0x1d5>
/work/x86_os_my/fs/file.c:487
			block_idx = block_read_start_idx;
c0009ad3:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0009ad6:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:488
			while (block_idx <= block_read_end_idx) {
c0009ad9:	eb 24                	jmp    c0009aff <file_read+0x1c8>
/work/x86_os_my/fs/file.c:489
				all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
c0009adb:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0009ade:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0009ae5:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0009ae8:	01 c2                	add    %eax,%edx
c0009aea:	8b 45 08             	mov    0x8(%ebp),%eax
c0009aed:	8b 40 08             	mov    0x8(%eax),%eax
c0009af0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0009af3:	83 c1 04             	add    $0x4,%ecx
c0009af6:	8b 04 88             	mov    (%eax,%ecx,4),%eax
c0009af9:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/file.c:490
				block_idx++;
c0009afb:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
/work/x86_os_my/fs/file.c:488
	} else {
	// 若要读多个数据块（扇区）
		/* 第一种情况: 起始块和终止块属于直接块*/
		if (block_read_end_idx < 12 ) {	  // 数据结束所在的块属于直接块
			block_idx = block_read_start_idx;
			while (block_idx <= block_read_end_idx) {
c0009aff:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0009b02:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
c0009b05:	76 d4                	jbe    c0009adb <file_read+0x1a4>
c0009b07:	e9 ee 00 00 00       	jmp    c0009bfa <file_read+0x2c3>
/work/x86_os_my/fs/file.c:492
				all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
				block_idx++;
			}
		} else if (block_read_start_idx < 12 && block_read_end_idx >= 12) {
c0009b0c:	83 7d d8 0b          	cmpl   $0xb,-0x28(%ebp)
c0009b10:	0f 87 91 00 00 00    	ja     c0009ba7 <file_read+0x270>
/work/x86_os_my/fs/file.c:492 (discriminator 1)
c0009b16:	83 7d d4 0b          	cmpl   $0xb,-0x2c(%ebp)
c0009b1a:	0f 86 87 00 00 00    	jbe    c0009ba7 <file_read+0x270>
/work/x86_os_my/fs/file.c:495
		/* 第二种情况: 待读入的数据跨越直接块和间接块两类*/
			/* 先将直接块地址写入all_blocks */
			block_idx = block_read_start_idx;
c0009b20:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0009b23:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/file.c:496
			while (block_idx < 12) {
c0009b26:	eb 24                	jmp    c0009b4c <file_read+0x215>
/work/x86_os_my/fs/file.c:497
				all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
c0009b28:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0009b2b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0009b32:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0009b35:	01 c2                	add    %eax,%edx
c0009b37:	8b 45 08             	mov    0x8(%ebp),%eax
c0009b3a:	8b 40 08             	mov    0x8(%eax),%eax
c0009b3d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0009b40:	83 c1 04             	add    $0x4,%ecx
c0009b43:	8b 04 88             	mov    (%eax,%ecx,4),%eax
c0009b46:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/file.c:498
				block_idx++;
c0009b48:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
/work/x86_os_my/fs/file.c:496
			}
		} else if (block_read_start_idx < 12 && block_read_end_idx >= 12) {
		/* 第二种情况: 待读入的数据跨越直接块和间接块两类*/
			/* 先将直接块地址写入all_blocks */
			block_idx = block_read_start_idx;
			while (block_idx < 12) {
c0009b4c:	83 7d e8 0b          	cmpl   $0xb,-0x18(%ebp)
c0009b50:	76 d6                	jbe    c0009b28 <file_read+0x1f1>
/work/x86_os_my/fs/file.c:500
				all_blocks[block_idx] = file->fd_inode->i_sectors[block_idx];
				block_idx++;
			}
			ASSERT(file->fd_inode->i_sectors[12] != 0);	    // 确保已经分配了一级间接块表
c0009b52:	8b 45 08             	mov    0x8(%ebp),%eax
c0009b55:	8b 40 08             	mov    0x8(%eax),%eax
c0009b58:	8b 40 40             	mov    0x40(%eax),%eax
c0009b5b:	85 c0                	test   %eax,%eax
c0009b5d:	75 1c                	jne    c0009b7b <file_read+0x244>
/work/x86_os_my/fs/file.c:500 (discriminator 1)
c0009b5f:	68 c0 cc 00 c0       	push   $0xc000ccc0
c0009b64:	68 d4 ce 00 c0       	push   $0xc000ced4
c0009b69:	68 f4 01 00 00       	push   $0x1f4
c0009b6e:	68 99 cc 00 c0       	push   $0xc000cc99
c0009b73:	e8 6a 87 ff ff       	call   c00022e2 <panic_spin>
c0009b78:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:503

			/* 再将间接块地址写入all_blocks */
			indirect_block_table = file->fd_inode->i_sectors[12];
c0009b7b:	8b 45 08             	mov    0x8(%ebp),%eax
c0009b7e:	8b 40 08             	mov    0x8(%eax),%eax
c0009b81:	8b 40 40             	mov    0x40(%eax),%eax
c0009b84:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/fs/file.c:504
			ide_read(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);	      // 将一级间接块表读进来写入到第13个块的位置之后
c0009b87:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0009b8a:	8d 48 30             	lea    0x30(%eax),%ecx
c0009b8d:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0009b90:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0009b95:	8b 40 08             	mov    0x8(%eax),%eax
c0009b98:	6a 01                	push   $0x1
c0009b9a:	51                   	push   %ecx
c0009b9b:	52                   	push   %edx
c0009b9c:	50                   	push   %eax
c0009b9d:	e8 34 be ff ff       	call   c00059d6 <ide_read>
c0009ba2:	83 c4 10             	add    $0x10,%esp
c0009ba5:	eb 53                	jmp    c0009bfa <file_read+0x2c3>
/work/x86_os_my/fs/file.c:507
		} else {
		/* 第三种情况: 数据在间接块中*/
			ASSERT(file->fd_inode->i_sectors[12] != 0);	    // 确保已经分配了一级间接块表
c0009ba7:	8b 45 08             	mov    0x8(%ebp),%eax
c0009baa:	8b 40 08             	mov    0x8(%eax),%eax
c0009bad:	8b 40 40             	mov    0x40(%eax),%eax
c0009bb0:	85 c0                	test   %eax,%eax
c0009bb2:	75 1c                	jne    c0009bd0 <file_read+0x299>
/work/x86_os_my/fs/file.c:507 (discriminator 1)
c0009bb4:	68 c0 cc 00 c0       	push   $0xc000ccc0
c0009bb9:	68 d4 ce 00 c0       	push   $0xc000ced4
c0009bbe:	68 fb 01 00 00       	push   $0x1fb
c0009bc3:	68 99 cc 00 c0       	push   $0xc000cc99
c0009bc8:	e8 15 87 ff ff       	call   c00022e2 <panic_spin>
c0009bcd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:508
			indirect_block_table = file->fd_inode->i_sectors[12];	      // 获取一级间接表地址
c0009bd0:	8b 45 08             	mov    0x8(%ebp),%eax
c0009bd3:	8b 40 08             	mov    0x8(%eax),%eax
c0009bd6:	8b 40 40             	mov    0x40(%eax),%eax
c0009bd9:	89 45 cc             	mov    %eax,-0x34(%ebp)
/work/x86_os_my/fs/file.c:509
			ide_read(cur_part->my_disk, indirect_block_table, all_blocks + 12, 1);	      // 将一级间接块表读进来写入到第13个块的位置之后
c0009bdc:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0009bdf:	8d 48 30             	lea    0x30(%eax),%ecx
c0009be2:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0009be5:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0009bea:	8b 40 08             	mov    0x8(%eax),%eax
c0009bed:	6a 01                	push   $0x1
c0009bef:	51                   	push   %ecx
c0009bf0:	52                   	push   %edx
c0009bf1:	50                   	push   %eax
c0009bf2:	e8 df bd ff ff       	call   c00059d6 <ide_read>
c0009bf7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:516
	}//块地址已经收集到all_blocks中


	/* 读数据 */
	uint32_t sec_idx, sec_lba, sec_off_bytes, sec_left_bytes, chunk_size;
	uint32_t bytes_read = 0;
c0009bfa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:517
	while (bytes_read < size) {	// 直到读完为止
c0009c01:	e9 ad 00 00 00       	jmp    c0009cb3 <file_read+0x37c>
/work/x86_os_my/fs/file.c:518
		sec_idx = file->fd_pos / BLOCK_SIZE;
c0009c06:	8b 45 08             	mov    0x8(%ebp),%eax
c0009c09:	8b 00                	mov    (%eax),%eax
c0009c0b:	c1 e8 09             	shr    $0x9,%eax
c0009c0e:	89 45 c8             	mov    %eax,-0x38(%ebp)
/work/x86_os_my/fs/file.c:519
		sec_lba = all_blocks[sec_idx];
c0009c11:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0009c14:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0009c1b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0009c1e:	01 d0                	add    %edx,%eax
c0009c20:	8b 00                	mov    (%eax),%eax
c0009c22:	89 45 c4             	mov    %eax,-0x3c(%ebp)
/work/x86_os_my/fs/file.c:520
		sec_off_bytes = file->fd_pos % BLOCK_SIZE;
c0009c25:	8b 45 08             	mov    0x8(%ebp),%eax
c0009c28:	8b 00                	mov    (%eax),%eax
c0009c2a:	25 ff 01 00 00       	and    $0x1ff,%eax
c0009c2f:	89 45 c0             	mov    %eax,-0x40(%ebp)
/work/x86_os_my/fs/file.c:521
		sec_left_bytes = BLOCK_SIZE - sec_off_bytes;
c0009c32:	b8 00 02 00 00       	mov    $0x200,%eax
c0009c37:	2b 45 c0             	sub    -0x40(%ebp),%eax
c0009c3a:	89 45 bc             	mov    %eax,-0x44(%ebp)
/work/x86_os_my/fs/file.c:522
		chunk_size = size_left < sec_left_bytes ? size_left : sec_left_bytes;	// 待读入的数据大小
c0009c3d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0009c40:	39 45 bc             	cmp    %eax,-0x44(%ebp)
c0009c43:	0f 46 45 bc          	cmovbe -0x44(%ebp),%eax
c0009c47:	89 45 b8             	mov    %eax,-0x48(%ebp)
/work/x86_os_my/fs/file.c:524

		memset(io_buf, 0, BLOCK_SIZE);
c0009c4a:	83 ec 04             	sub    $0x4,%esp
c0009c4d:	68 00 02 00 00       	push   $0x200
c0009c52:	6a 00                	push   $0x0
c0009c54:	ff 75 e0             	pushl  -0x20(%ebp)
c0009c57:	e8 28 9b ff ff       	call   c0003784 <memset>
c0009c5c:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:525
		ide_read(cur_part->my_disk, sec_lba, io_buf, 1);
c0009c5f:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0009c64:	8b 40 08             	mov    0x8(%eax),%eax
c0009c67:	6a 01                	push   $0x1
c0009c69:	ff 75 e0             	pushl  -0x20(%ebp)
c0009c6c:	ff 75 c4             	pushl  -0x3c(%ebp)
c0009c6f:	50                   	push   %eax
c0009c70:	e8 61 bd ff ff       	call   c00059d6 <ide_read>
c0009c75:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:526
		memcpy(buf_dst, io_buf + sec_off_bytes, chunk_size);
c0009c78:	8b 55 e0             	mov    -0x20(%ebp),%edx
c0009c7b:	8b 45 c0             	mov    -0x40(%ebp),%eax
c0009c7e:	01 d0                	add    %edx,%eax
c0009c80:	83 ec 04             	sub    $0x4,%esp
c0009c83:	ff 75 b8             	pushl  -0x48(%ebp)
c0009c86:	50                   	push   %eax
c0009c87:	ff 75 f4             	pushl  -0xc(%ebp)
c0009c8a:	e8 47 9b ff ff       	call   c00037d6 <memcpy>
c0009c8f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:528

		buf_dst += chunk_size;
c0009c92:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0009c95:	01 45 f4             	add    %eax,-0xc(%ebp)
/work/x86_os_my/fs/file.c:529
		file->fd_pos += chunk_size;
c0009c98:	8b 45 08             	mov    0x8(%ebp),%eax
c0009c9b:	8b 10                	mov    (%eax),%edx
c0009c9d:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0009ca0:	01 c2                	add    %eax,%edx
c0009ca2:	8b 45 08             	mov    0x8(%ebp),%eax
c0009ca5:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/file.c:530
		bytes_read += chunk_size;
c0009ca7:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0009caa:	01 45 e4             	add    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/file.c:531
		size_left -= chunk_size;
c0009cad:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0009cb0:	29 45 ec             	sub    %eax,-0x14(%ebp)
/work/x86_os_my/fs/file.c:517


	/* 读数据 */
	uint32_t sec_idx, sec_lba, sec_off_bytes, sec_left_bytes, chunk_size;
	uint32_t bytes_read = 0;
	while (bytes_read < size) {	// 直到读完为止
c0009cb3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0009cb6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0009cb9:	0f 82 47 ff ff ff    	jb     c0009c06 <file_read+0x2cf>
/work/x86_os_my/fs/file.c:533
		buf_dst += chunk_size;
		file->fd_pos += chunk_size;
		bytes_read += chunk_size;
		size_left -= chunk_size;
	}
	sys_free(all_blocks);
c0009cbf:	83 ec 0c             	sub    $0xc,%esp
c0009cc2:	ff 75 dc             	pushl  -0x24(%ebp)
c0009cc5:	e8 f0 95 ff ff       	call   c00032ba <sys_free>
c0009cca:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:534
	sys_free(io_buf);
c0009ccd:	83 ec 0c             	sub    $0xc,%esp
c0009cd0:	ff 75 e0             	pushl  -0x20(%ebp)
c0009cd3:	e8 e2 95 ff ff       	call   c00032ba <sys_free>
c0009cd8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/file.c:535
	return bytes_read;
c0009cdb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
/work/x86_os_my/fs/file.c:536
}
c0009cde:	c9                   	leave  
c0009cdf:	c3                   	ret    

c0009ce0 <open_root_dir>:
open_root_dir():
/work/x86_os_my/fs/dir.c:17
#include "super_block.h"

struct dir root_dir;	// 根目录

/* 打开根目录 */
void open_root_dir(struct partition* part) {
c0009ce0:	55                   	push   %ebp
c0009ce1:	89 e5                	mov    %esp,%ebp
c0009ce3:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/fs/dir.c:18
	root_dir.inode = inode_open(part, part->sb->root_inode_no);
c0009ce6:	8b 45 08             	mov    0x8(%ebp),%eax
c0009ce9:	8b 40 1c             	mov    0x1c(%eax),%eax
c0009cec:	8b 40 2c             	mov    0x2c(%eax),%eax
c0009cef:	83 ec 08             	sub    $0x8,%esp
c0009cf2:	50                   	push   %eax
c0009cf3:	ff 75 08             	pushl  0x8(%ebp)
c0009cf6:	e8 44 e9 ff ff       	call   c000863f <inode_open>
c0009cfb:	83 c4 10             	add    $0x10,%esp
c0009cfe:	a3 60 0b 01 c0       	mov    %eax,0xc0010b60
/work/x86_os_my/fs/dir.c:19
	root_dir.dir_pos = 0;
c0009d03:	c7 05 64 0b 01 c0 00 	movl   $0x0,0xc0010b64
c0009d0a:	00 00 00 
/work/x86_os_my/fs/dir.c:20
}
c0009d0d:	90                   	nop
c0009d0e:	c9                   	leave  
c0009d0f:	c3                   	ret    

c0009d10 <dir_open>:
dir_open():
/work/x86_os_my/fs/dir.c:23

/* 在分区part上打开i结点为inode_no的目录，并返回目录指针 */
struct dir* dir_open(struct partition* part, uint32_t inode_no) {
c0009d10:	55                   	push   %ebp
c0009d11:	89 e5                	mov    %esp,%ebp
c0009d13:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/dir.c:24
	struct dir* pdir = (struct dir*)sys_malloc(sizeof(struct dir));	//除根目录以外的其他目录，要分配内存
c0009d16:	83 ec 0c             	sub    $0xc,%esp
c0009d19:	68 08 02 00 00       	push   $0x208
c0009d1e:	e8 6a 8f ff ff       	call   c0002c8d <sys_malloc>
c0009d23:	83 c4 10             	add    $0x10,%esp
c0009d26:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:25
	pdir->inode = inode_open(part, inode_no);
c0009d29:	83 ec 08             	sub    $0x8,%esp
c0009d2c:	ff 75 0c             	pushl  0xc(%ebp)
c0009d2f:	ff 75 08             	pushl  0x8(%ebp)
c0009d32:	e8 08 e9 ff ff       	call   c000863f <inode_open>
c0009d37:	83 c4 10             	add    $0x10,%esp
c0009d3a:	89 c2                	mov    %eax,%edx
c0009d3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0009d3f:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/fs/dir.c:26
	pdir->dir_pos = 0;
c0009d41:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0009d44:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
/work/x86_os_my/fs/dir.c:27
	return pdir;
c0009d4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
/work/x86_os_my/fs/dir.c:28
}
c0009d4e:	c9                   	leave  
c0009d4f:	c3                   	ret    

c0009d50 <search_dir_entry>:
search_dir_entry():
/work/x86_os_my/fs/dir.c:32

/* 在part分区内的pdir目录内，寻找名为name的目录项，
 * 找到后返回true，并将其目录项存入dir_e；否则返回false */
bool search_dir_entry(struct partition* part, struct dir* pdir, const char* name, struct dir_entry* dir_e) {
c0009d50:	55                   	push   %ebp
c0009d51:	89 e5                	mov    %esp,%ebp
c0009d53:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/fs/dir.c:34
	/* 1分配 */
	uint32_t block_cnt = 140;	 // 12个直接块+128个一级间接块 = 目录的inode管理的所有块 = 140块
c0009d56:	c7 45 e8 8c 00 00 00 	movl   $0x8c,-0x18(%ebp)
/work/x86_os_my/fs/dir.c:39

	/* 12个直接块大小+128个间接块,共560字节（140个块，inode需要管理块的地址，每个4字节）
	注意: all_blocks 里面并没有一级间接表的地址，只有直接块+间接块的地址！
	用all_blocks检索inode管理的所有块地址 */
	uint32_t* all_blocks = (uint32_t*)sys_malloc(48 + 512);
c0009d5d:	83 ec 0c             	sub    $0xc,%esp
c0009d60:	68 30 02 00 00       	push   $0x230
c0009d65:	e8 23 8f ff ff       	call   c0002c8d <sys_malloc>
c0009d6a:	83 c4 10             	add    $0x10,%esp
c0009d6d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/dir.c:40
	if (all_blocks == NULL) {
c0009d70:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0009d74:	75 1a                	jne    c0009d90 <search_dir_entry+0x40>
/work/x86_os_my/fs/dir.c:41
		printk("search_dir_entry: sys_malloc for all_blocks failed");
c0009d76:	83 ec 0c             	sub    $0xc,%esp
c0009d79:	68 e0 ce 00 c0       	push   $0xc000cee0
c0009d7e:	e8 cc c6 ff ff       	call   c000644f <printk>
c0009d83:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:42
		return false;
c0009d86:	b8 00 00 00 00       	mov    $0x0,%eax
c0009d8b:	e9 96 01 00 00       	jmp    c0009f26 <search_dir_entry+0x1d6>
/work/x86_os_my/fs/dir.c:45
	}

	uint32_t block_idx = 0;
c0009d90:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:46
	while (block_idx < 12) {
c0009d97:	eb 23                	jmp    c0009dbc <search_dir_entry+0x6c>
/work/x86_os_my/fs/dir.c:47
		all_blocks[block_idx] = pdir->inode->i_sectors[block_idx];
c0009d99:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0009d9c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0009da3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0009da6:	01 c2                	add    %eax,%edx
c0009da8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0009dab:	8b 00                	mov    (%eax),%eax
c0009dad:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c0009db0:	83 c1 04             	add    $0x4,%ecx
c0009db3:	8b 04 88             	mov    (%eax,%ecx,4),%eax
c0009db6:	89 02                	mov    %eax,(%edx)
/work/x86_os_my/fs/dir.c:48
		block_idx++;
c0009db8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:46
		printk("search_dir_entry: sys_malloc for all_blocks failed");
		return false;
	}

	uint32_t block_idx = 0;
	while (block_idx < 12) {
c0009dbc:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
c0009dc0:	76 d7                	jbe    c0009d99 <search_dir_entry+0x49>
/work/x86_os_my/fs/dir.c:50
		all_blocks[block_idx] = pdir->inode->i_sectors[block_idx];
		block_idx++;
	}
	block_idx = 0;
c0009dc2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:52

	if (pdir->inode->i_sectors[12] != 0) {	// i_sectors[12] != 0代表含有一级间接块表
c0009dc9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0009dcc:	8b 00                	mov    (%eax),%eax
c0009dce:	8b 40 40             	mov    0x40(%eax),%eax
c0009dd1:	85 c0                	test   %eax,%eax
c0009dd3:	74 21                	je     c0009df6 <search_dir_entry+0xa6>
/work/x86_os_my/fs/dir.c:54
		//从硬盘的扇区地址i_sectors[12]处获取 1 扇区数据，就是 128 个间接块的地址，将其复制到 all_blocks+12 处【复制的是整个一级间接表】
		ide_read(part->my_disk, pdir->inode->i_sectors[12], all_blocks + 12, 1);
c0009dd5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0009dd8:	8d 48 30             	lea    0x30(%eax),%ecx
c0009ddb:	8b 45 0c             	mov    0xc(%ebp),%eax
c0009dde:	8b 00                	mov    (%eax),%eax
c0009de0:	8b 50 40             	mov    0x40(%eax),%edx
c0009de3:	8b 45 08             	mov    0x8(%ebp),%eax
c0009de6:	8b 40 08             	mov    0x8(%eax),%eax
c0009de9:	6a 01                	push   $0x1
c0009deb:	51                   	push   %ecx
c0009dec:	52                   	push   %edx
c0009ded:	50                   	push   %eax
c0009dee:	e8 e3 bb ff ff       	call   c00059d6 <ide_read>
c0009df3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:62


	/* 2查找 */
	/* 写目录项的时候已保证目录项不跨扇区，这样读目录项时容易处理，只申请容纳1个扇区的内存
	 * 和处理inode_table不同，在往目录中写目录项的时候(sync_dir_entry)，避免了某个目录项 跨扇区的情况 */
	uint8_t* buf = (uint8_t*)sys_malloc(SECTOR_SIZE);
c0009df6:	83 ec 0c             	sub    $0xc,%esp
c0009df9:	68 00 02 00 00       	push   $0x200
c0009dfe:	e8 8a 8e ff ff       	call   c0002c8d <sys_malloc>
c0009e03:	83 c4 10             	add    $0x10,%esp
c0009e06:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:63
	struct dir_entry* p_de = (struct dir_entry*)buf;		// p_de为指向目录项的指针,值为buf起始地址
c0009e09:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0009e0c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:64
	uint32_t dir_entry_size = part->sb->dir_entry_size;
c0009e0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0009e12:	8b 40 1c             	mov    0x1c(%eax),%eax
c0009e15:	8b 40 30             	mov    0x30(%eax),%eax
c0009e18:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:65
	uint32_t dir_entry_cnt = SECTOR_SIZE / dir_entry_size;	// 1扇区内可容纳的目录项个数
c0009e1b:	b8 00 02 00 00       	mov    $0x200,%eax
c0009e20:	ba 00 00 00 00       	mov    $0x0,%edx
c0009e25:	f7 75 dc             	divl   -0x24(%ebp)
c0009e28:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/dir.c:67
	/* 在所有块中查找目录项 */
	while (block_idx < block_cnt) {
c0009e2b:	e9 c9 00 00 00       	jmp    c0009ef9 <search_dir_entry+0x1a9>
/work/x86_os_my/fs/dir.c:69
		/* 块地址为0时表示该块中无数据,继续在其它块中找 */
		if (all_blocks[block_idx] == 0) {
c0009e30:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0009e33:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0009e3a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0009e3d:	01 d0                	add    %edx,%eax
c0009e3f:	8b 00                	mov    (%eax),%eax
c0009e41:	85 c0                	test   %eax,%eax
c0009e43:	75 09                	jne    c0009e4e <search_dir_entry+0xfe>
/work/x86_os_my/fs/dir.c:70
			block_idx++;
c0009e45:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:71
			continue;
c0009e49:	e9 ab 00 00 00       	jmp    c0009ef9 <search_dir_entry+0x1a9>
/work/x86_os_my/fs/dir.c:73
		}
		ide_read(part->my_disk, all_blocks[block_idx], buf, 1);
c0009e4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0009e51:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0009e58:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0009e5b:	01 d0                	add    %edx,%eax
c0009e5d:	8b 10                	mov    (%eax),%edx
c0009e5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0009e62:	8b 40 08             	mov    0x8(%eax),%eax
c0009e65:	6a 01                	push   $0x1
c0009e67:	ff 75 e0             	pushl  -0x20(%ebp)
c0009e6a:	52                   	push   %edx
c0009e6b:	50                   	push   %eax
c0009e6c:	e8 65 bb ff ff       	call   c00059d6 <ide_read>
c0009e71:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:75

		uint32_t dir_entry_idx = 0;
c0009e74:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:77
		/* 遍历扇区中所有目录项 */
		while (dir_entry_idx < dir_entry_cnt) {
c0009e7b:	eb 55                	jmp    c0009ed2 <search_dir_entry+0x182>
/work/x86_os_my/fs/dir.c:79
			/* 若找到了,就直接复制整个目录项 */
			if (!strcmp(p_de->filename, name)) {
c0009e7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0009e80:	83 ec 08             	sub    $0x8,%esp
c0009e83:	ff 75 10             	pushl  0x10(%ebp)
c0009e86:	50                   	push   %eax
c0009e87:	e8 cd 9a ff ff       	call   c0003959 <strcmp>
c0009e8c:	83 c4 10             	add    $0x10,%esp
c0009e8f:	84 c0                	test   %al,%al
c0009e91:	75 37                	jne    c0009eca <search_dir_entry+0x17a>
/work/x86_os_my/fs/dir.c:80
				memcpy(dir_e, p_de, dir_entry_size);
c0009e93:	83 ec 04             	sub    $0x4,%esp
c0009e96:	ff 75 dc             	pushl  -0x24(%ebp)
c0009e99:	ff 75 f0             	pushl  -0x10(%ebp)
c0009e9c:	ff 75 14             	pushl  0x14(%ebp)
c0009e9f:	e8 32 99 ff ff       	call   c00037d6 <memcpy>
c0009ea4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:81
				sys_free(buf);
c0009ea7:	83 ec 0c             	sub    $0xc,%esp
c0009eaa:	ff 75 e0             	pushl  -0x20(%ebp)
c0009ead:	e8 08 94 ff ff       	call   c00032ba <sys_free>
c0009eb2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:82
				sys_free(all_blocks);
c0009eb5:	83 ec 0c             	sub    $0xc,%esp
c0009eb8:	ff 75 e4             	pushl  -0x1c(%ebp)
c0009ebb:	e8 fa 93 ff ff       	call   c00032ba <sys_free>
c0009ec0:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:83
				return true;
c0009ec3:	b8 01 00 00 00       	mov    $0x1,%eax
c0009ec8:	eb 5c                	jmp    c0009f26 <search_dir_entry+0x1d6>
/work/x86_os_my/fs/dir.c:85
			}
			dir_entry_idx++;
c0009eca:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:86
			p_de++;
c0009ece:	83 45 f0 18          	addl   $0x18,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:77
		}
		ide_read(part->my_disk, all_blocks[block_idx], buf, 1);

		uint32_t dir_entry_idx = 0;
		/* 遍历扇区中所有目录项 */
		while (dir_entry_idx < dir_entry_cnt) {
c0009ed2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0009ed5:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c0009ed8:	72 a3                	jb     c0009e7d <search_dir_entry+0x12d>
/work/x86_os_my/fs/dir.c:89
			}
			dir_entry_idx++;
			p_de++;
		}

		block_idx++;					// 目录inode管理的下一个数据块（扇区）【目录里面是目录项，所以buf赋给p_de】
c0009eda:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:90
		p_de = (struct dir_entry*)buf;	// p_de已经指向上一个扇区内，最后一个目录项，需要恢复p_de指向为buf
c0009ede:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0009ee1:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:91
		memset(buf, 0, SECTOR_SIZE);	// 将buf清0,下次再用
c0009ee4:	83 ec 04             	sub    $0x4,%esp
c0009ee7:	68 00 02 00 00       	push   $0x200
c0009eec:	6a 00                	push   $0x0
c0009eee:	ff 75 e0             	pushl  -0x20(%ebp)
c0009ef1:	e8 8e 98 ff ff       	call   c0003784 <memset>
c0009ef6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:67
	uint8_t* buf = (uint8_t*)sys_malloc(SECTOR_SIZE);
	struct dir_entry* p_de = (struct dir_entry*)buf;		// p_de为指向目录项的指针,值为buf起始地址
	uint32_t dir_entry_size = part->sb->dir_entry_size;
	uint32_t dir_entry_cnt = SECTOR_SIZE / dir_entry_size;	// 1扇区内可容纳的目录项个数
	/* 在所有块中查找目录项 */
	while (block_idx < block_cnt) {
c0009ef9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0009efc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0009eff:	0f 82 2b ff ff ff    	jb     c0009e30 <search_dir_entry+0xe0>
/work/x86_os_my/fs/dir.c:93

		block_idx++;					// 目录inode管理的下一个数据块（扇区）【目录里面是目录项，所以buf赋给p_de】
		p_de = (struct dir_entry*)buf;	// p_de已经指向上一个扇区内，最后一个目录项，需要恢复p_de指向为buf
		memset(buf, 0, SECTOR_SIZE);	// 将buf清0,下次再用
	}
	sys_free(buf);
c0009f05:	83 ec 0c             	sub    $0xc,%esp
c0009f08:	ff 75 e0             	pushl  -0x20(%ebp)
c0009f0b:	e8 aa 93 ff ff       	call   c00032ba <sys_free>
c0009f10:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:94
	sys_free(all_blocks);
c0009f13:	83 ec 0c             	sub    $0xc,%esp
c0009f16:	ff 75 e4             	pushl  -0x1c(%ebp)
c0009f19:	e8 9c 93 ff ff       	call   c00032ba <sys_free>
c0009f1e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:95
	return false;
c0009f21:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/dir.c:96
}
c0009f26:	c9                   	leave  
c0009f27:	c3                   	ret    

c0009f28 <dir_close>:
dir_close():
/work/x86_os_my/fs/dir.c:99

/* 关闭目录 */
void dir_close(struct dir* dir) {
c0009f28:	55                   	push   %ebp
c0009f29:	89 e5                	mov    %esp,%ebp
c0009f2b:	83 ec 08             	sub    $0x8,%esp
/work/x86_os_my/fs/dir.c:103
	/*************      根目录不能关闭     ***************
	*1 根目录自打开后就不应该关闭,否则还需要再次open_root_dir();
	*2 root_dir所在的内存是低端1M之内,并非在堆中,free会出问题 */
	if (dir == &root_dir) {
c0009f2e:	81 7d 08 60 0b 01 c0 	cmpl   $0xc0010b60,0x8(%ebp)
c0009f35:	74 21                	je     c0009f58 <dir_close+0x30>
/work/x86_os_my/fs/dir.c:106
		return;
	}
	inode_close(dir->inode);
c0009f37:	8b 45 08             	mov    0x8(%ebp),%eax
c0009f3a:	8b 00                	mov    (%eax),%eax
c0009f3c:	83 ec 0c             	sub    $0xc,%esp
c0009f3f:	50                   	push   %eax
c0009f40:	e8 40 e8 ff ff       	call   c0008785 <inode_close>
c0009f45:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:107
	sys_free(dir);
c0009f48:	83 ec 0c             	sub    $0xc,%esp
c0009f4b:	ff 75 08             	pushl  0x8(%ebp)
c0009f4e:	e8 67 93 ff ff       	call   c00032ba <sys_free>
c0009f53:	83 c4 10             	add    $0x10,%esp
c0009f56:	eb 01                	jmp    c0009f59 <dir_close+0x31>
/work/x86_os_my/fs/dir.c:104
void dir_close(struct dir* dir) {
	/*************      根目录不能关闭     ***************
	*1 根目录自打开后就不应该关闭,否则还需要再次open_root_dir();
	*2 root_dir所在的内存是低端1M之内,并非在堆中,free会出问题 */
	if (dir == &root_dir) {
		return;
c0009f58:	90                   	nop
/work/x86_os_my/fs/dir.c:108
	}
	inode_close(dir->inode);
	sys_free(dir);
}
c0009f59:	c9                   	leave  
c0009f5a:	c3                   	ret    

c0009f5b <create_dir_entry>:
create_dir_entry():
/work/x86_os_my/fs/dir.c:111

/* 在内存中初始化目录项p_de */
void create_dir_entry(char* filename, uint32_t inode_no, uint8_t file_type, struct dir_entry* p_de) {
c0009f5b:	55                   	push   %ebp
c0009f5c:	89 e5                	mov    %esp,%ebp
c0009f5e:	83 ec 18             	sub    $0x18,%esp
c0009f61:	8b 45 10             	mov    0x10(%ebp),%eax
c0009f64:	88 45 f4             	mov    %al,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:112
	ASSERT(strlen(filename) <=  MAX_FILE_NAME_LEN);
c0009f67:	83 ec 0c             	sub    $0xc,%esp
c0009f6a:	ff 75 08             	pushl  0x8(%ebp)
c0009f6d:	e8 9c 99 ff ff       	call   c000390e <strlen>
c0009f72:	83 c4 10             	add    $0x10,%esp
c0009f75:	83 f8 10             	cmp    $0x10,%eax
c0009f78:	76 19                	jbe    c0009f93 <create_dir_entry+0x38>
/work/x86_os_my/fs/dir.c:112 (discriminator 1)
c0009f7a:	68 14 cf 00 c0       	push   $0xc000cf14
c0009f7f:	68 a0 d0 00 c0       	push   $0xc000d0a0
c0009f84:	6a 70                	push   $0x70
c0009f86:	68 3a cf 00 c0       	push   $0xc000cf3a
c0009f8b:	e8 52 83 ff ff       	call   c00022e2 <panic_spin>
c0009f90:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:115

	/* 初始化目录项 */
	memcpy(p_de->filename, filename, strlen(filename));
c0009f93:	83 ec 0c             	sub    $0xc,%esp
c0009f96:	ff 75 08             	pushl  0x8(%ebp)
c0009f99:	e8 70 99 ff ff       	call   c000390e <strlen>
c0009f9e:	83 c4 10             	add    $0x10,%esp
c0009fa1:	89 c2                	mov    %eax,%edx
c0009fa3:	8b 45 14             	mov    0x14(%ebp),%eax
c0009fa6:	83 ec 04             	sub    $0x4,%esp
c0009fa9:	52                   	push   %edx
c0009faa:	ff 75 08             	pushl  0x8(%ebp)
c0009fad:	50                   	push   %eax
c0009fae:	e8 23 98 ff ff       	call   c00037d6 <memcpy>
c0009fb3:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:116
	p_de->i_no = inode_no;
c0009fb6:	8b 45 14             	mov    0x14(%ebp),%eax
c0009fb9:	8b 55 0c             	mov    0xc(%ebp),%edx
c0009fbc:	89 50 10             	mov    %edx,0x10(%eax)
/work/x86_os_my/fs/dir.c:117
	p_de->f_type = file_type;
c0009fbf:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c0009fc3:	8b 45 14             	mov    0x14(%ebp),%eax
c0009fc6:	89 50 14             	mov    %edx,0x14(%eax)
/work/x86_os_my/fs/dir.c:118
}
c0009fc9:	90                   	nop
c0009fca:	c9                   	leave  
c0009fcb:	c3                   	ret    

c0009fcc <sync_dir_entry>:
sync_dir_entry():
/work/x86_os_my/fs/dir.c:128
 * io_buf是由主调函数提供的，里面是一个一个的目录项
 */
// 全局变量 cur_part 定义在fs.c中
// 临时变量 all_blocks 保存目录中 所有数据块的地址【4*140=560字节，去掉前12个直接块的地址48字节，后边全是间接块，后边正好是512字节】
// 注意: all_blocks 里面并没有一级间接表的地址，只有直接块+间接块的地址！
bool sync_dir_entry(struct dir* parent_dir, struct dir_entry* p_de, void* io_buf) {
c0009fcc:	55                   	push   %ebp
c0009fcd:	89 e5                	mov    %esp,%ebp
c0009fcf:	57                   	push   %edi
c0009fd0:	81 ec 54 02 00 00    	sub    $0x254,%esp
/work/x86_os_my/fs/dir.c:129
	struct inode* dir_inode = parent_dir->inode;	//dir->inode：“已打开的 inode 队列”part->open_inodes 中的节点
c0009fd6:	8b 45 08             	mov    0x8(%ebp),%eax
c0009fd9:	8b 00                	mov    (%eax),%eax
c0009fdb:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:130
	uint32_t dir_size = dir_inode->i_size;			//inode->i_size：当inode是目录时，代表 目录下所有目录项大小之和
c0009fde:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0009fe1:	8b 40 04             	mov    0x4(%eax),%eax
c0009fe4:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:131
	uint32_t dir_entry_size = cur_part->sb->dir_entry_size;
c0009fe7:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c0009fec:	8b 40 1c             	mov    0x1c(%eax),%eax
c0009fef:	8b 40 30             	mov    0x30(%eax),%eax
c0009ff2:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/fs/dir.c:133

	ASSERT(dir_size % dir_entry_size == 0);	// dir_size应该是dir_entry_size的整数倍
c0009ff5:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0009ff8:	ba 00 00 00 00       	mov    $0x0,%edx
c0009ffd:	f7 75 e8             	divl   -0x18(%ebp)
c000a000:	89 d0                	mov    %edx,%eax
c000a002:	85 c0                	test   %eax,%eax
c000a004:	74 1c                	je     c000a022 <sync_dir_entry+0x56>
/work/x86_os_my/fs/dir.c:133 (discriminator 1)
c000a006:	68 44 cf 00 c0       	push   $0xc000cf44
c000a00b:	68 b4 d0 00 c0       	push   $0xc000d0b4
c000a010:	68 85 00 00 00       	push   $0x85
c000a015:	68 3a cf 00 c0       	push   $0xc000cf3a
c000a01a:	e8 c3 82 ff ff       	call   c00022e2 <panic_spin>
c000a01f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:135

	uint32_t dir_entrys_per_sec = (512 / dir_entry_size);	// 每扇区最多有几个目录项【保证了：写入目录项时不会跨扇区】
c000a022:	b8 00 02 00 00       	mov    $0x200,%eax
c000a027:	ba 00 00 00 00       	mov    $0x0,%edx
c000a02c:	f7 75 e8             	divl   -0x18(%ebp)
c000a02f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/dir.c:136
	int32_t block_lba = -1;
c000a032:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:140


	/* 将该目录inode管理的所有块(扇区)地址(12个直接块+ 128个间接块)存入all_blocks */
	uint8_t block_idx = 0;
c000a039:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/dir.c:143
	// all_blocks 保存目录中 所有数据块的地址【4*140=560字节，去掉前12个直接块的地址48字节，后边全是间接块，后边正好是512字节】
	// 注意: all_blocks 里面并没有一级间接表的地址，只有直接块+间接块的地址！
	uint32_t all_blocks[140] = {0};
c000a03d:	8d 95 a8 fd ff ff    	lea    -0x258(%ebp),%edx
c000a043:	b8 00 00 00 00       	mov    $0x0,%eax
c000a048:	b9 8c 00 00 00       	mov    $0x8c,%ecx
c000a04d:	89 d7                	mov    %edx,%edi
c000a04f:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/fs/dir.c:144
	while (block_idx < 12) {
c000a051:	eb 22                	jmp    c000a075 <sync_dir_entry+0xa9>
/work/x86_os_my/fs/dir.c:145
		all_blocks[block_idx] = dir_inode->i_sectors[block_idx];
c000a053:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000a057:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
c000a05b:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000a05e:	83 c1 04             	add    $0x4,%ecx
c000a061:	8b 14 8a             	mov    (%edx,%ecx,4),%edx
c000a064:	89 94 85 a8 fd ff ff 	mov    %edx,-0x258(%ebp,%eax,4)
/work/x86_os_my/fs/dir.c:146
		block_idx++;
c000a06b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000a06f:	83 c0 01             	add    $0x1,%eax
c000a072:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/dir.c:144
	/* 将该目录inode管理的所有块(扇区)地址(12个直接块+ 128个间接块)存入all_blocks */
	uint8_t block_idx = 0;
	// all_blocks 保存目录中 所有数据块的地址【4*140=560字节，去掉前12个直接块的地址48字节，后边全是间接块，后边正好是512字节】
	// 注意: all_blocks 里面并没有一级间接表的地址，只有直接块+间接块的地址！
	uint32_t all_blocks[140] = {0};
	while (block_idx < 12) {
c000a075:	80 7d f7 0b          	cmpb   $0xb,-0x9(%ebp)
c000a079:	76 d8                	jbe    c000a053 <sync_dir_entry+0x87>
/work/x86_os_my/fs/dir.c:151
		block_idx++;
	}


	/* 开始遍历所有块以寻找目录项空位 */
	block_idx = 0;
c000a07b:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
/work/x86_os_my/fs/dir.c:152
	while (block_idx < 140) {	// 文件(包括目录)最多管理140个块
c000a07f:	e9 3f 03 00 00       	jmp    c000a3c3 <sync_dir_entry+0x3f7>
/work/x86_os_my/fs/dir.c:155
		/* 一、若inode管理的第block_idx块是不存在的，需要分配。
		   下边是需要分配块的三种情况 @1 @2 @3 */
		int32_t block_bitmap_idx = -1;
c000a084:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:156
		if (all_blocks[block_idx] == 0) {
c000a08b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000a08f:	8b 84 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%eax
c000a096:	85 c0                	test   %eax,%eax
c000a098:	0f 85 58 02 00 00    	jne    c000a2f6 <sync_dir_entry+0x32a>
/work/x86_os_my/fs/dir.c:157
			block_lba = block_bitmap_alloc(cur_part);	// #1 从分区的block位图中，分配1个扇区，返回"扇区地址"
c000a09e:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000a0a3:	83 ec 0c             	sub    $0xc,%esp
c000a0a6:	50                   	push   %eax
c000a0a7:	e8 ff eb ff ff       	call   c0008cab <block_bitmap_alloc>
c000a0ac:	83 c4 10             	add    $0x10,%esp
c000a0af:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:158
			if (block_lba == -1) {
c000a0b2:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
c000a0b6:	75 1a                	jne    c000a0d2 <sync_dir_entry+0x106>
/work/x86_os_my/fs/dir.c:159
				printk("alloc block bitmap for sync_dir_entry failed\n");
c000a0b8:	83 ec 0c             	sub    $0xc,%esp
c000a0bb:	68 64 cf 00 c0       	push   $0xc000cf64
c000a0c0:	e8 8a c3 ff ff       	call   c000644f <printk>
c000a0c5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:160
				return false;
c000a0c8:	b8 00 00 00 00       	mov    $0x0,%eax
c000a0cd:	e9 10 03 00 00       	jmp    c000a3e2 <sync_dir_entry+0x416>
/work/x86_os_my/fs/dir.c:163
			}
			/* 每分配一个块就同步一次block_bitmap */
			block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c000a0d2:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000a0d5:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000a0da:	8b 40 1c             	mov    0x1c(%eax),%eax
c000a0dd:	8b 40 28             	mov    0x28(%eax),%eax
c000a0e0:	29 c2                	sub    %eax,%edx
c000a0e2:	89 d0                	mov    %edx,%eax
c000a0e4:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:164
			ASSERT(block_bitmap_idx != -1);	//怎么可能是-1啊。。。？
c000a0e7:	83 7d dc ff          	cmpl   $0xffffffff,-0x24(%ebp)
c000a0eb:	75 1c                	jne    c000a109 <sync_dir_entry+0x13d>
/work/x86_os_my/fs/dir.c:164 (discriminator 1)
c000a0ed:	68 92 cf 00 c0       	push   $0xc000cf92
c000a0f2:	68 b4 d0 00 c0       	push   $0xc000d0b4
c000a0f7:	68 a4 00 00 00       	push   $0xa4
c000a0fc:	68 3a cf 00 c0       	push   $0xc000cf3a
c000a101:	e8 dc 81 ff ff       	call   c00022e2 <panic_spin>
c000a106:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:165
			bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c000a109:	8b 55 dc             	mov    -0x24(%ebp),%edx
c000a10c:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000a111:	83 ec 04             	sub    $0x4,%esp
c000a114:	6a 01                	push   $0x1
c000a116:	52                   	push   %edx
c000a117:	50                   	push   %eax
c000a118:	e8 e0 eb ff ff       	call   c0008cfd <bitmap_sync>
c000a11d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:167

			block_bitmap_idx = -1;
c000a120:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:168
			if (block_idx < 12) {			// @1 若是直接块
c000a127:	80 7d f7 0b          	cmpb   $0xb,-0x9(%ebp)
c000a12b:	77 27                	ja     c000a154 <sync_dir_entry+0x188>
/work/x86_os_my/fs/dir.c:169
				dir_inode->i_sectors[block_idx] = all_blocks[block_idx] = block_lba;
c000a12d:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
c000a131:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000a135:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000a138:	89 94 85 a8 fd ff ff 	mov    %edx,-0x258(%ebp,%eax,4)
c000a13f:	8b 94 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%edx
c000a146:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000a149:	83 c1 04             	add    $0x4,%ecx
c000a14c:	89 14 88             	mov    %edx,(%eax,%ecx,4)
c000a14f:	e9 3c 01 00 00       	jmp    c000a290 <sync_dir_entry+0x2c4>
/work/x86_os_my/fs/dir.c:170
			} else if (block_idx == 12) {	// @2 若是未分配 一级间接块表(block_idx==12表示第0个间接块)
c000a154:	80 7d f7 0c          	cmpb   $0xc,-0x9(%ebp)
c000a158:	0f 85 ff 00 00 00    	jne    c000a25d <sync_dir_entry+0x291>
/work/x86_os_my/fs/dir.c:171
				dir_inode->i_sectors[12] = block_lba;		// 将 #1 分配的块做为"一级间接块表"地址
c000a15e:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000a161:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000a164:	89 50 40             	mov    %edx,0x40(%eax)
/work/x86_os_my/fs/dir.c:173
				
				block_lba = -1;
c000a167:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:174
				block_lba = block_bitmap_alloc(cur_part);	// #2 再分配一个块做为"第0个间接块"
c000a16e:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000a173:	83 ec 0c             	sub    $0xc,%esp
c000a176:	50                   	push   %eax
c000a177:	e8 2f eb ff ff       	call   c0008cab <block_bitmap_alloc>
c000a17c:	83 c4 10             	add    $0x10,%esp
c000a17f:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:175
				if (block_lba == -1) {
c000a182:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
c000a186:	75 57                	jne    c000a1df <sync_dir_entry+0x213>
/work/x86_os_my/fs/dir.c:177
					// 回滚block_bitmap
					block_bitmap_idx = dir_inode->i_sectors[12] - cur_part->sb->data_start_lba;
c000a188:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000a18b:	8b 50 40             	mov    0x40(%eax),%edx
c000a18e:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000a193:	8b 40 1c             	mov    0x1c(%eax),%eax
c000a196:	8b 40 28             	mov    0x28(%eax),%eax
c000a199:	29 c2                	sub    %eax,%edx
c000a19b:	89 d0                	mov    %edx,%eax
c000a19d:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:178
					bitmap_set(&cur_part->block_bitmap, block_bitmap_idx, 0);	//释放 #1
c000a1a0:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a1a3:	8b 15 d0 09 01 c0    	mov    0xc00109d0,%edx
c000a1a9:	83 c2 20             	add    $0x20,%edx
c000a1ac:	83 ec 04             	sub    $0x4,%esp
c000a1af:	6a 00                	push   $0x0
c000a1b1:	50                   	push   %eax
c000a1b2:	52                   	push   %edx
c000a1b3:	e8 98 83 ff ff       	call   c0002550 <bitmap_set>
c000a1b8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:180
					// 取消掉这个一级间接块表
					dir_inode->i_sectors[12] = 0;
c000a1bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000a1be:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
/work/x86_os_my/fs/dir.c:181
					printk("alloc block bitmap for sync_dir_entry failed\n");
c000a1c5:	83 ec 0c             	sub    $0xc,%esp
c000a1c8:	68 64 cf 00 c0       	push   $0xc000cf64
c000a1cd:	e8 7d c2 ff ff       	call   c000644f <printk>
c000a1d2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:182
					return false;
c000a1d5:	b8 00 00 00 00       	mov    $0x0,%eax
c000a1da:	e9 03 02 00 00       	jmp    c000a3e2 <sync_dir_entry+0x416>
/work/x86_os_my/fs/dir.c:185
				}
				/* 每分配一个块就同步一次block_bitmap */
				block_bitmap_idx = block_lba - cur_part->sb->data_start_lba;
c000a1df:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000a1e2:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000a1e7:	8b 40 1c             	mov    0x1c(%eax),%eax
c000a1ea:	8b 40 28             	mov    0x28(%eax),%eax
c000a1ed:	29 c2                	sub    %eax,%edx
c000a1ef:	89 d0                	mov    %edx,%eax
c000a1f1:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:186
				ASSERT(block_bitmap_idx != -1);
c000a1f4:	83 7d dc ff          	cmpl   $0xffffffff,-0x24(%ebp)
c000a1f8:	75 1c                	jne    c000a216 <sync_dir_entry+0x24a>
/work/x86_os_my/fs/dir.c:186 (discriminator 1)
c000a1fa:	68 92 cf 00 c0       	push   $0xc000cf92
c000a1ff:	68 b4 d0 00 c0       	push   $0xc000d0b4
c000a204:	68 ba 00 00 00       	push   $0xba
c000a209:	68 3a cf 00 c0       	push   $0xc000cf3a
c000a20e:	e8 cf 80 ff ff       	call   c00022e2 <panic_spin>
c000a213:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:187
				bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c000a216:	8b 55 dc             	mov    -0x24(%ebp),%edx
c000a219:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000a21e:	83 ec 04             	sub    $0x4,%esp
c000a221:	6a 01                	push   $0x1
c000a223:	52                   	push   %edx
c000a224:	50                   	push   %eax
c000a225:	e8 d3 ea ff ff       	call   c0008cfd <bitmap_sync>
c000a22a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:190

				/* 把新分配的"第0个间接块地址"写入硬盘中"一级间接块表" */
				all_blocks[12] = block_lba;
c000a22d:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000a230:	89 85 d8 fd ff ff    	mov    %eax,-0x228(%ebp)
/work/x86_os_my/fs/dir.c:194
				// all_blocks 共有4*140=560字节，去掉前12个直接块的地址48字节，后边全是间接块，后边正好是512字节】
				// 注意: all_blocks 里面并没有一级间接表的地址，只有直接块+间接块的地址！
				// 我们的一级间接表大小是和普通数据块大小一样的512字节，可以容纳128个数据块的地址！
				ide_write(cur_part->my_disk, dir_inode->i_sectors[12], all_blocks + 12, 1);
c000a236:	8d 85 a8 fd ff ff    	lea    -0x258(%ebp),%eax
c000a23c:	83 c0 30             	add    $0x30,%eax
c000a23f:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000a242:	8b 4a 40             	mov    0x40(%edx),%ecx
c000a245:	8b 15 d0 09 01 c0    	mov    0xc00109d0,%edx
c000a24b:	8b 52 08             	mov    0x8(%edx),%edx
c000a24e:	6a 01                	push   $0x1
c000a250:	50                   	push   %eax
c000a251:	51                   	push   %ecx
c000a252:	52                   	push   %edx
c000a253:	e8 f2 b8 ff ff       	call   c0005b4a <ide_write>
c000a258:	83 c4 10             	add    $0x10,%esp
c000a25b:	eb 33                	jmp    c000a290 <sync_dir_entry+0x2c4>
/work/x86_os_my/fs/dir.c:197
			} else {						// @3 若是未分配 间接块【父目录inode管理的只有前13个数据块需要特殊处理，后边的全是间接块】
				/* 把新分配的第(block_idx-12)个间接块地址"写入硬盘中"一级间接块表 */
				all_blocks[block_idx] = block_lba;
c000a25d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000a261:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000a264:	89 94 85 a8 fd ff ff 	mov    %edx,-0x258(%ebp,%eax,4)
/work/x86_os_my/fs/dir.c:198
				ide_write(cur_part->my_disk, dir_inode->i_sectors[12], all_blocks + 12, 1);
c000a26b:	8d 85 a8 fd ff ff    	lea    -0x258(%ebp),%eax
c000a271:	83 c0 30             	add    $0x30,%eax
c000a274:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000a277:	8b 4a 40             	mov    0x40(%edx),%ecx
c000a27a:	8b 15 d0 09 01 c0    	mov    0xc00109d0,%edx
c000a280:	8b 52 08             	mov    0x8(%edx),%edx
c000a283:	6a 01                	push   $0x1
c000a285:	50                   	push   %eax
c000a286:	51                   	push   %ecx
c000a287:	52                   	push   %edx
c000a288:	e8 bd b8 ff ff       	call   c0005b4a <ide_write>
c000a28d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:204
			}


			/* 这里才是重点，前边只是处理，父目录indoe管理的某个数据块为空的情况，需要新分配数据块，包括一级间接块表、间接块 */
			/* 再将硬盘中，新目录项p_de写入新分配的间接块 */
			memset(io_buf, 0, 512);
c000a290:	83 ec 04             	sub    $0x4,%esp
c000a293:	68 00 02 00 00       	push   $0x200
c000a298:	6a 00                	push   $0x0
c000a29a:	ff 75 10             	pushl  0x10(%ebp)
c000a29d:	e8 e2 94 ff ff       	call   c0003784 <memset>
c000a2a2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:205
			memcpy(io_buf, p_de, dir_entry_size);
c000a2a5:	83 ec 04             	sub    $0x4,%esp
c000a2a8:	ff 75 e8             	pushl  -0x18(%ebp)
c000a2ab:	ff 75 0c             	pushl  0xc(%ebp)
c000a2ae:	ff 75 10             	pushl  0x10(%ebp)
c000a2b1:	e8 20 95 ff ff       	call   c00037d6 <memcpy>
c000a2b6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:206
			ide_write(cur_part->my_disk, all_blocks[block_idx], io_buf, 1);
c000a2b9:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000a2bd:	8b 94 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%edx
c000a2c4:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000a2c9:	8b 40 08             	mov    0x8(%eax),%eax
c000a2cc:	6a 01                	push   $0x1
c000a2ce:	ff 75 10             	pushl  0x10(%ebp)
c000a2d1:	52                   	push   %edx
c000a2d2:	50                   	push   %eax
c000a2d3:	e8 72 b8 ff ff       	call   c0005b4a <ide_write>
c000a2d8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:207
			dir_inode->i_size += dir_entry_size;	//struct inode* dir_inode = parent_dir->inode;更新的是父目录的inode结构
c000a2db:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000a2de:	8b 50 04             	mov    0x4(%eax),%edx
c000a2e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000a2e4:	01 c2                	add    %eax,%edx
c000a2e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000a2e9:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/dir.c:208
			return true;
c000a2ec:	b8 01 00 00 00       	mov    $0x1,%eax
c000a2f1:	e9 ec 00 00 00       	jmp    c000a3e2 <sync_dir_entry+0x416>
/work/x86_os_my/fs/dir.c:213
		}//if (all_blocks[block_idx] == 0)


		/* 二、若inode管理的第block_idx块是存在的，不需要分配，将其读进内存，然后在该块中查找空目录项，将p_de填入 */
		ide_read(cur_part->my_disk, all_blocks[block_idx], io_buf, 1); 
c000a2f6:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000a2fa:	8b 94 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%edx
c000a301:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000a306:	8b 40 08             	mov    0x8(%eax),%eax
c000a309:	6a 01                	push   $0x1
c000a30b:	ff 75 10             	pushl  0x10(%ebp)
c000a30e:	52                   	push   %edx
c000a30f:	50                   	push   %eax
c000a310:	e8 c1 b6 ff ff       	call   c00059d6 <ide_read>
c000a315:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:215
		/* 在扇区内查找空目录项 */
		uint8_t dir_entry_idx = 0;
c000a318:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
/work/x86_os_my/fs/dir.c:216
		struct dir_entry* dir_e = (struct dir_entry*)io_buf;		// dir_e用来在io_buf中遍历目录项【io_buf里面是一个一个的目录项】
c000a31c:	8b 45 10             	mov    0x10(%ebp),%eax
c000a31f:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/dir.c:217
		while (dir_entry_idx < dir_entrys_per_sec) {
c000a322:	e9 85 00 00 00       	jmp    c000a3ac <sync_dir_entry+0x3e0>
/work/x86_os_my/fs/dir.c:218
			if ((dir_e + dir_entry_idx)->f_type == FT_UNKNOWN) {	// 无论是初始化或是删除文件，都会将f_type置为FT_UNKNOWN.
c000a327:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
c000a32b:	89 d0                	mov    %edx,%eax
c000a32d:	01 c0                	add    %eax,%eax
c000a32f:	01 d0                	add    %edx,%eax
c000a331:	c1 e0 03             	shl    $0x3,%eax
c000a334:	89 c2                	mov    %eax,%edx
c000a336:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000a339:	01 d0                	add    %edx,%eax
c000a33b:	8b 40 14             	mov    0x14(%eax),%eax
c000a33e:	85 c0                	test   %eax,%eax
c000a340:	75 60                	jne    c000a3a2 <sync_dir_entry+0x3d6>
/work/x86_os_my/fs/dir.c:219
				memcpy(dir_e + dir_entry_idx, p_de, dir_entry_size);    
c000a342:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
c000a346:	89 d0                	mov    %edx,%eax
c000a348:	01 c0                	add    %eax,%eax
c000a34a:	01 d0                	add    %edx,%eax
c000a34c:	c1 e0 03             	shl    $0x3,%eax
c000a34f:	89 c2                	mov    %eax,%edx
c000a351:	8b 45 d8             	mov    -0x28(%ebp),%eax
c000a354:	01 d0                	add    %edx,%eax
c000a356:	83 ec 04             	sub    $0x4,%esp
c000a359:	ff 75 e8             	pushl  -0x18(%ebp)
c000a35c:	ff 75 0c             	pushl  0xc(%ebp)
c000a35f:	50                   	push   %eax
c000a360:	e8 71 94 ff ff       	call   c00037d6 <memcpy>
c000a365:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:220
				ide_write(cur_part->my_disk, all_blocks[block_idx], io_buf, 1);
c000a368:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000a36c:	8b 94 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%edx
c000a373:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000a378:	8b 40 08             	mov    0x8(%eax),%eax
c000a37b:	6a 01                	push   $0x1
c000a37d:	ff 75 10             	pushl  0x10(%ebp)
c000a380:	52                   	push   %edx
c000a381:	50                   	push   %eax
c000a382:	e8 c3 b7 ff ff       	call   c0005b4a <ide_write>
c000a387:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:222

				dir_inode->i_size += dir_entry_size;
c000a38a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000a38d:	8b 50 04             	mov    0x4(%eax),%edx
c000a390:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000a393:	01 c2                	add    %eax,%edx
c000a395:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000a398:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/dir.c:223
				return true;
c000a39b:	b8 01 00 00 00       	mov    $0x1,%eax
c000a3a0:	eb 40                	jmp    c000a3e2 <sync_dir_entry+0x416>
/work/x86_os_my/fs/dir.c:225
			}
			dir_entry_idx++;
c000a3a2:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c000a3a6:	83 c0 01             	add    $0x1,%eax
c000a3a9:	88 45 f6             	mov    %al,-0xa(%ebp)
/work/x86_os_my/fs/dir.c:217
		/* 二、若inode管理的第block_idx块是存在的，不需要分配，将其读进内存，然后在该块中查找空目录项，将p_de填入 */
		ide_read(cur_part->my_disk, all_blocks[block_idx], io_buf, 1); 
		/* 在扇区内查找空目录项 */
		uint8_t dir_entry_idx = 0;
		struct dir_entry* dir_e = (struct dir_entry*)io_buf;		// dir_e用来在io_buf中遍历目录项【io_buf里面是一个一个的目录项】
		while (dir_entry_idx < dir_entrys_per_sec) {
c000a3ac:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
c000a3b0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c000a3b3:	0f 82 6e ff ff ff    	jb     c000a327 <sync_dir_entry+0x35b>
/work/x86_os_my/fs/dir.c:230
			dir_entry_idx++;
		}


		/* 三、若inode管理的第block_idx块是存在的，不需要分配，但是都不是空闲(FT_UNKNOWN)的 */
		block_idx++;	//下一个inode管理的block
c000a3b9:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c000a3bd:	83 c0 01             	add    $0x1,%eax
c000a3c0:	88 45 f7             	mov    %al,-0x9(%ebp)
/work/x86_os_my/fs/dir.c:152
	}


	/* 开始遍历所有块以寻找目录项空位 */
	block_idx = 0;
	while (block_idx < 140) {	// 文件(包括目录)最多管理140个块
c000a3c3:	80 7d f7 8b          	cmpb   $0x8b,-0x9(%ebp)
c000a3c7:	0f 86 b7 fc ff ff    	jbe    c000a084 <sync_dir_entry+0xb8>
/work/x86_os_my/fs/dir.c:233

		/* 三、若inode管理的第block_idx块是存在的，不需要分配，但是都不是空闲(FT_UNKNOWN)的 */
		block_idx++;	//下一个inode管理的block
	}//while (block_idx < 140)

	printk("directory is full!\n");
c000a3cd:	83 ec 0c             	sub    $0xc,%esp
c000a3d0:	68 a9 cf 00 c0       	push   $0xc000cfa9
c000a3d5:	e8 75 c0 ff ff       	call   c000644f <printk>
c000a3da:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:234
	return false;
c000a3dd:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/dir.c:235 (discriminator 1)
}
c000a3e2:	8b 7d fc             	mov    -0x4(%ebp),%edi
c000a3e5:	c9                   	leave  
c000a3e6:	c3                   	ret    

c000a3e7 <delete_dir_entry>:
delete_dir_entry():
/work/x86_os_my/fs/dir.c:244
（2）根目录是必须存在的，它是文件读写的根基，不应该被清空，它至少要保留 1 个块。
	 如果目录项独占 1个块，并且该块不是根目录最后一个块的话，将其回收。
（3）目录 inode 的 i_size 是目录项大小的总和，因此还要将 i_size 减去一个目录项的单位大小。
（4）目录 inode 改变后，要同步到硬盘。
 */
bool delete_dir_entry(struct partition* part, struct dir* pdir, uint32_t inode_no, void* io_buf) {
c000a3e7:	55                   	push   %ebp
c000a3e8:	89 e5                	mov    %esp,%ebp
c000a3ea:	57                   	push   %edi
c000a3eb:	81 ec 64 02 00 00    	sub    $0x264,%esp
/work/x86_os_my/fs/dir.c:245
	struct inode* dir_inode = pdir->inode;
c000a3f1:	8b 45 0c             	mov    0xc(%ebp),%eax
c000a3f4:	8b 00                	mov    (%eax),%eax
c000a3f6:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:246
	uint32_t block_idx = 0, all_blocks[140] = {0};
c000a3f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c000a400:	8d 95 9c fd ff ff    	lea    -0x264(%ebp),%edx
c000a406:	b8 00 00 00 00       	mov    $0x0,%eax
c000a40b:	b9 8c 00 00 00       	mov    $0x8c,%ecx
c000a410:	89 d7                	mov    %edx,%edi
c000a412:	f3 ab                	rep stos %eax,%es:(%edi)
/work/x86_os_my/fs/dir.c:249

	/* 收集目录全部块地址，存到到 all_blocks */
	while (block_idx < 12) {
c000a414:	eb 1a                	jmp    c000a430 <delete_dir_entry+0x49>
/work/x86_os_my/fs/dir.c:250
		all_blocks[block_idx] = dir_inode->i_sectors[block_idx];
c000a416:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000a419:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000a41c:	83 c2 04             	add    $0x4,%edx
c000a41f:	8b 14 90             	mov    (%eax,%edx,4),%edx
c000a422:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a425:	89 94 85 9c fd ff ff 	mov    %edx,-0x264(%ebp,%eax,4)
/work/x86_os_my/fs/dir.c:251
		block_idx++;
c000a42c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:249
bool delete_dir_entry(struct partition* part, struct dir* pdir, uint32_t inode_no, void* io_buf) {
	struct inode* dir_inode = pdir->inode;
	uint32_t block_idx = 0, all_blocks[140] = {0};

	/* 收集目录全部块地址，存到到 all_blocks */
	while (block_idx < 12) {
c000a430:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
c000a434:	76 e0                	jbe    c000a416 <delete_dir_entry+0x2f>
/work/x86_os_my/fs/dir.c:253
		all_blocks[block_idx] = dir_inode->i_sectors[block_idx];
		block_idx++;
	}
	if (dir_inode->i_sectors[12]) {
c000a436:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000a439:	8b 40 40             	mov    0x40(%eax),%eax
c000a43c:	85 c0                	test   %eax,%eax
c000a43e:	74 22                	je     c000a462 <delete_dir_entry+0x7b>
/work/x86_os_my/fs/dir.c:254
		ide_read(part->my_disk, dir_inode->i_sectors[12], all_blocks + 12, 1);
c000a440:	8d 85 9c fd ff ff    	lea    -0x264(%ebp),%eax
c000a446:	83 c0 30             	add    $0x30,%eax
c000a449:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000a44c:	8b 4a 40             	mov    0x40(%edx),%ecx
c000a44f:	8b 55 08             	mov    0x8(%ebp),%edx
c000a452:	8b 52 08             	mov    0x8(%edx),%edx
c000a455:	6a 01                	push   $0x1
c000a457:	50                   	push   %eax
c000a458:	51                   	push   %ecx
c000a459:	52                   	push   %edx
c000a45a:	e8 77 b5 ff ff       	call   c00059d6 <ide_read>
c000a45f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:258
	}

	/* 目录项在存储时保证不会跨扇区 */
	uint32_t dir_entry_size = part->sb->dir_entry_size;
c000a462:	8b 45 08             	mov    0x8(%ebp),%eax
c000a465:	8b 40 1c             	mov    0x1c(%eax),%eax
c000a468:	8b 40 30             	mov    0x30(%eax),%eax
c000a46b:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:259
	uint32_t dir_entrys_per_sec = (SECTOR_SIZE / dir_entry_size);	// 每扇区最大的目录项数目
c000a46e:	b8 00 02 00 00       	mov    $0x200,%eax
c000a473:	ba 00 00 00 00       	mov    $0x0,%edx
c000a478:	f7 75 dc             	divl   -0x24(%ebp)
c000a47b:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/dir.c:260
	struct dir_entry* dir_e = (struct dir_entry*)io_buf;
c000a47e:	8b 45 14             	mov    0x14(%ebp),%eax
c000a481:	89 45 d4             	mov    %eax,-0x2c(%ebp)
/work/x86_os_my/fs/dir.c:261
	struct dir_entry* dir_entry_found = NULL;
c000a484:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:263
	uint8_t dir_entry_idx, dir_entry_cnt;
	bool is_dir_first_block = false;	// 目录的第1个块
c000a48b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
/work/x86_os_my/fs/dir.c:266

	/* 遍历所有块，寻找目录项 */
	block_idx = 0;
c000a492:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:267
	while (block_idx < 140) {
c000a499:	e9 9a 03 00 00       	jmp    c000a838 <delete_dir_entry+0x451>
/work/x86_os_my/fs/dir.c:268
		is_dir_first_block = false;
c000a49e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
/work/x86_os_my/fs/dir.c:269
		if (all_blocks[block_idx] == 0) {
c000a4a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a4a8:	8b 84 85 9c fd ff ff 	mov    -0x264(%ebp,%eax,4),%eax
c000a4af:	85 c0                	test   %eax,%eax
c000a4b1:	75 09                	jne    c000a4bc <delete_dir_entry+0xd5>
/work/x86_os_my/fs/dir.c:270
			block_idx++;
c000a4b3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:271
			continue;
c000a4b7:	e9 7c 03 00 00       	jmp    c000a838 <delete_dir_entry+0x451>
/work/x86_os_my/fs/dir.c:273
		}
		dir_entry_idx = dir_entry_cnt = 0;
c000a4bc:	c6 45 ee 00          	movb   $0x0,-0x12(%ebp)
c000a4c0:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
c000a4c4:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/fs/dir.c:274
		memset(io_buf, 0, SECTOR_SIZE);
c000a4c7:	83 ec 04             	sub    $0x4,%esp
c000a4ca:	68 00 02 00 00       	push   $0x200
c000a4cf:	6a 00                	push   $0x0
c000a4d1:	ff 75 14             	pushl  0x14(%ebp)
c000a4d4:	e8 ab 92 ff ff       	call   c0003784 <memset>
c000a4d9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:276
		/* 读取目录inode管理的各个数据块（扇区），里面是目录项 */
		ide_read(part->my_disk, all_blocks[block_idx], io_buf, 1);	//dir_e = io_buf
c000a4dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a4df:	8b 94 85 9c fd ff ff 	mov    -0x264(%ebp,%eax,4),%edx
c000a4e6:	8b 45 08             	mov    0x8(%ebp),%eax
c000a4e9:	8b 40 08             	mov    0x8(%eax),%eax
c000a4ec:	6a 01                	push   $0x1
c000a4ee:	ff 75 14             	pushl  0x14(%ebp)
c000a4f1:	52                   	push   %edx
c000a4f2:	50                   	push   %eax
c000a4f3:	e8 de b4 ff ff       	call   c00059d6 <ide_read>
c000a4f8:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:279

		/* 遍历所有的目录项，统计该扇区的目录项数量 + 是否找到要删除的目录项 */
		while (dir_entry_idx < dir_entrys_per_sec) {
c000a4fb:	e9 13 01 00 00       	jmp    c000a613 <delete_dir_entry+0x22c>
/work/x86_os_my/fs/dir.c:280
			if ((dir_e + dir_entry_idx)->f_type != FT_UNKNOWN) {	// 初始化或是删除文件，会将f_type置为FT_UNKNOWN.
c000a500:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c000a504:	89 d0                	mov    %edx,%eax
c000a506:	01 c0                	add    %eax,%eax
c000a508:	01 d0                	add    %edx,%eax
c000a50a:	c1 e0 03             	shl    $0x3,%eax
c000a50d:	89 c2                	mov    %eax,%edx
c000a50f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000a512:	01 d0                	add    %edx,%eax
c000a514:	8b 40 14             	mov    0x14(%eax),%eax
c000a517:	85 c0                	test   %eax,%eax
c000a519:	0f 84 ea 00 00 00    	je     c000a609 <delete_dir_entry+0x222>
/work/x86_os_my/fs/dir.c:281
				if (!strcmp((dir_e + dir_entry_idx)->filename, ".")) {
c000a51f:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c000a523:	89 d0                	mov    %edx,%eax
c000a525:	01 c0                	add    %eax,%eax
c000a527:	01 d0                	add    %edx,%eax
c000a529:	c1 e0 03             	shl    $0x3,%eax
c000a52c:	89 c2                	mov    %eax,%edx
c000a52e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000a531:	01 d0                	add    %edx,%eax
c000a533:	83 ec 08             	sub    $0x8,%esp
c000a536:	68 bd cf 00 c0       	push   $0xc000cfbd
c000a53b:	50                   	push   %eax
c000a53c:	e8 18 94 ff ff       	call   c0003959 <strcmp>
c000a541:	83 c4 10             	add    $0x10,%esp
c000a544:	84 c0                	test   %al,%al
c000a546:	75 0c                	jne    c000a554 <delete_dir_entry+0x16d>
/work/x86_os_my/fs/dir.c:282
					is_dir_first_block = true;
c000a548:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
c000a54f:	e9 b5 00 00 00       	jmp    c000a609 <delete_dir_entry+0x222>
/work/x86_os_my/fs/dir.c:283
				} else if (strcmp((dir_e + dir_entry_idx)->filename, ".") && strcmp((dir_e + dir_entry_idx)->filename, "..")) {	//不是.和..
c000a554:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c000a558:	89 d0                	mov    %edx,%eax
c000a55a:	01 c0                	add    %eax,%eax
c000a55c:	01 d0                	add    %edx,%eax
c000a55e:	c1 e0 03             	shl    $0x3,%eax
c000a561:	89 c2                	mov    %eax,%edx
c000a563:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000a566:	01 d0                	add    %edx,%eax
c000a568:	83 ec 08             	sub    $0x8,%esp
c000a56b:	68 bd cf 00 c0       	push   $0xc000cfbd
c000a570:	50                   	push   %eax
c000a571:	e8 e3 93 ff ff       	call   c0003959 <strcmp>
c000a576:	83 c4 10             	add    $0x10,%esp
c000a579:	84 c0                	test   %al,%al
c000a57b:	0f 84 88 00 00 00    	je     c000a609 <delete_dir_entry+0x222>
/work/x86_os_my/fs/dir.c:283 (discriminator 1)
c000a581:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c000a585:	89 d0                	mov    %edx,%eax
c000a587:	01 c0                	add    %eax,%eax
c000a589:	01 d0                	add    %edx,%eax
c000a58b:	c1 e0 03             	shl    $0x3,%eax
c000a58e:	89 c2                	mov    %eax,%edx
c000a590:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000a593:	01 d0                	add    %edx,%eax
c000a595:	83 ec 08             	sub    $0x8,%esp
c000a598:	68 bf cf 00 c0       	push   $0xc000cfbf
c000a59d:	50                   	push   %eax
c000a59e:	e8 b6 93 ff ff       	call   c0003959 <strcmp>
c000a5a3:	83 c4 10             	add    $0x10,%esp
c000a5a6:	84 c0                	test   %al,%al
c000a5a8:	74 5f                	je     c000a609 <delete_dir_entry+0x222>
/work/x86_os_my/fs/dir.c:284
					dir_entry_cnt++;     // 统计此扇区内的目录项个数，用来判断删除目录项后是否回收该扇区
c000a5aa:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
c000a5ae:	83 c0 01             	add    $0x1,%eax
c000a5b1:	88 45 ee             	mov    %al,-0x12(%ebp)
/work/x86_os_my/fs/dir.c:286
					// 目录项的成员inode号和目标inode号一致，就将其记录在dir_entry_found！！！
					if ((dir_e + dir_entry_idx)->i_no == inode_no) {
c000a5b4:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c000a5b8:	89 d0                	mov    %edx,%eax
c000a5ba:	01 c0                	add    %eax,%eax
c000a5bc:	01 d0                	add    %edx,%eax
c000a5be:	c1 e0 03             	shl    $0x3,%eax
c000a5c1:	89 c2                	mov    %eax,%edx
c000a5c3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000a5c6:	01 d0                	add    %edx,%eax
c000a5c8:	8b 40 10             	mov    0x10(%eax),%eax
c000a5cb:	3b 45 10             	cmp    0x10(%ebp),%eax
c000a5ce:	75 39                	jne    c000a609 <delete_dir_entry+0x222>
/work/x86_os_my/fs/dir.c:287
						ASSERT(dir_entry_found == NULL);  // 确保目录中只有一个编号为inode_no的inode,找到一次后dir_entry_found就不再是NULL
c000a5d0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000a5d4:	74 1c                	je     c000a5f2 <delete_dir_entry+0x20b>
/work/x86_os_my/fs/dir.c:287 (discriminator 1)
c000a5d6:	68 c2 cf 00 c0       	push   $0xc000cfc2
c000a5db:	68 c4 d0 00 c0       	push   $0xc000d0c4
c000a5e0:	68 1f 01 00 00       	push   $0x11f
c000a5e5:	68 3a cf 00 c0       	push   $0xc000cf3a
c000a5ea:	e8 f3 7c ff ff       	call   c00022e2 <panic_spin>
c000a5ef:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:288
						dir_entry_found = dir_e + dir_entry_idx;
c000a5f2:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
c000a5f6:	89 d0                	mov    %edx,%eax
c000a5f8:	01 c0                	add    %eax,%eax
c000a5fa:	01 d0                	add    %edx,%eax
c000a5fc:	c1 e0 03             	shl    $0x3,%eax
c000a5ff:	89 c2                	mov    %eax,%edx
c000a601:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c000a604:	01 d0                	add    %edx,%eax
c000a606:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:293
						/* 找到后也继续遍历,统计总共的目录项数 */
					}
				}
			}
			dir_entry_idx++;
c000a609:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c000a60d:	83 c0 01             	add    $0x1,%eax
c000a610:	88 45 ef             	mov    %al,-0x11(%ebp)
/work/x86_os_my/fs/dir.c:279
		memset(io_buf, 0, SECTOR_SIZE);
		/* 读取目录inode管理的各个数据块（扇区），里面是目录项 */
		ide_read(part->my_disk, all_blocks[block_idx], io_buf, 1);	//dir_e = io_buf

		/* 遍历所有的目录项，统计该扇区的目录项数量 + 是否找到要删除的目录项 */
		while (dir_entry_idx < dir_entrys_per_sec) {
c000a613:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c000a617:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c000a61a:	0f 82 e0 fe ff ff    	jb     c000a500 <delete_dir_entry+0x119>
/work/x86_os_my/fs/dir.c:297
			}
			dir_entry_idx++;
		}

		/* 若此扇区未找到该目录项,继续在下个扇区中找 */
		if (dir_entry_found == NULL) {
c000a620:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000a624:	75 09                	jne    c000a62f <delete_dir_entry+0x248>
/work/x86_os_my/fs/dir.c:298
			block_idx++;
c000a626:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:299
			continue;
c000a62a:	e9 09 02 00 00       	jmp    c000a838 <delete_dir_entry+0x451>
/work/x86_os_my/fs/dir.c:303
		}

		/* 在此扇区中找到目录项后，清除该目录项并判断是否回收扇区，随后退出循环直接返回 */
		ASSERT(dir_entry_cnt >= 1);	//此扇区内的目录项个数
c000a62f:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c000a633:	75 1c                	jne    c000a651 <delete_dir_entry+0x26a>
/work/x86_os_my/fs/dir.c:303 (discriminator 1)
c000a635:	68 da cf 00 c0       	push   $0xc000cfda
c000a63a:	68 c4 d0 00 c0       	push   $0xc000d0c4
c000a63f:	68 2f 01 00 00       	push   $0x12f
c000a644:	68 3a cf 00 c0       	push   $0xc000cf3a
c000a649:	e8 94 7c ff ff       	call   c00022e2 <panic_spin>
c000a64e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:305
		/* 若该扇区上只有该目录项自己，则将整个扇区回收。如果目录只有第1个扇区，则不能回收 */
		if (dir_entry_cnt == 1 && !is_dir_first_block) {
c000a651:	80 7d ee 01          	cmpb   $0x1,-0x12(%ebp)
c000a655:	0f 85 43 01 00 00    	jne    c000a79e <delete_dir_entry+0x3b7>
/work/x86_os_my/fs/dir.c:305 (discriminator 1)
c000a65b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c000a65f:	0f 85 39 01 00 00    	jne    c000a79e <delete_dir_entry+0x3b7>
/work/x86_os_my/fs/dir.c:307
			/* a 在块位图中回收该块 */
			uint32_t block_bitmap_idx = all_blocks[block_idx] - part->sb->data_start_lba;
c000a665:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a668:	8b 94 85 9c fd ff ff 	mov    -0x264(%ebp,%eax,4),%edx
c000a66f:	8b 45 08             	mov    0x8(%ebp),%eax
c000a672:	8b 40 1c             	mov    0x1c(%eax),%eax
c000a675:	8b 40 28             	mov    0x28(%eax),%eax
c000a678:	29 c2                	sub    %eax,%edx
c000a67a:	89 d0                	mov    %edx,%eax
c000a67c:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/fs/dir.c:308
			bitmap_set(&part->block_bitmap, block_bitmap_idx, 0);
c000a67f:	8b 45 08             	mov    0x8(%ebp),%eax
c000a682:	83 c0 20             	add    $0x20,%eax
c000a685:	83 ec 04             	sub    $0x4,%esp
c000a688:	6a 00                	push   $0x0
c000a68a:	ff 75 d0             	pushl  -0x30(%ebp)
c000a68d:	50                   	push   %eax
c000a68e:	e8 bd 7e ff ff       	call   c0002550 <bitmap_set>
c000a693:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:309
			bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c000a696:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000a69b:	83 ec 04             	sub    $0x4,%esp
c000a69e:	6a 01                	push   $0x1
c000a6a0:	ff 75 d0             	pushl  -0x30(%ebp)
c000a6a3:	50                   	push   %eax
c000a6a4:	e8 54 e6 ff ff       	call   c0008cfd <bitmap_sync>
c000a6a9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:312

			/* b 将块地址从数组 i_sectors 或 从一级间接索引表中去掉 */
			if (block_idx < 12) {	//直接块
c000a6ac:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
c000a6b0:	77 15                	ja     c000a6c7 <delete_dir_entry+0x2e0>
/work/x86_os_my/fs/dir.c:313
				dir_inode->i_sectors[block_idx] = 0;
c000a6b2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000a6b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000a6b8:	83 c2 04             	add    $0x4,%edx
c000a6bb:	c7 04 90 00 00 00 00 	movl   $0x0,(%eax,%edx,4)
/work/x86_os_my/fs/dir.c:305
		}

		/* 在此扇区中找到目录项后，清除该目录项并判断是否回收扇区，随后退出循环直接返回 */
		ASSERT(dir_entry_cnt >= 1);	//此扇区内的目录项个数
		/* 若该扇区上只有该目录项自己，则将整个扇区回收。如果目录只有第1个扇区，则不能回收 */
		if (dir_entry_cnt == 1 && !is_dir_first_block) {
c000a6c2:	e9 09 01 00 00       	jmp    c000a7d0 <delete_dir_entry+0x3e9>
/work/x86_os_my/fs/dir.c:316
			/* b 将块地址从数组 i_sectors 或 从一级间接索引表中去掉 */
			if (block_idx < 12) {	//直接块
				dir_inode->i_sectors[block_idx] = 0;
			} else {	// 在一级间接索引表中擦除该间接块地址
				/*先判断一级间接索引表中间接块的数量：如果仅有这1个间接块，连同间接索引表所在的块一同回收 */
				uint32_t indirect_blocks = 0;
c000a6c7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
/work/x86_os_my/fs/dir.c:317
				uint32_t indirect_block_idx = 12;
c000a6ce:	c7 45 cc 0c 00 00 00 	movl   $0xc,-0x34(%ebp)
/work/x86_os_my/fs/dir.c:318
				while (indirect_block_idx < 140) {
c000a6d5:	eb 12                	jmp    c000a6e9 <delete_dir_entry+0x302>
/work/x86_os_my/fs/dir.c:319
					if (all_blocks[indirect_block_idx] != 0) {
c000a6d7:	8b 45 cc             	mov    -0x34(%ebp),%eax
c000a6da:	8b 84 85 9c fd ff ff 	mov    -0x264(%ebp,%eax,4),%eax
c000a6e1:	85 c0                	test   %eax,%eax
c000a6e3:	74 04                	je     c000a6e9 <delete_dir_entry+0x302>
/work/x86_os_my/fs/dir.c:320
						indirect_blocks++;	//间接块的数量
c000a6e5:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
/work/x86_os_my/fs/dir.c:318
				dir_inode->i_sectors[block_idx] = 0;
			} else {	// 在一级间接索引表中擦除该间接块地址
				/*先判断一级间接索引表中间接块的数量：如果仅有这1个间接块，连同间接索引表所在的块一同回收 */
				uint32_t indirect_blocks = 0;
				uint32_t indirect_block_idx = 12;
				while (indirect_block_idx < 140) {
c000a6e9:	81 7d cc 8b 00 00 00 	cmpl   $0x8b,-0x34(%ebp)
c000a6f0:	76 e5                	jbe    c000a6d7 <delete_dir_entry+0x2f0>
/work/x86_os_my/fs/dir.c:323
					if (all_blocks[indirect_block_idx] != 0) {
						indirect_blocks++;	//间接块的数量
					}
				}
				ASSERT(indirect_blocks >= 1);	// 包括当前间接块
c000a6f2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c000a6f6:	75 1c                	jne    c000a714 <delete_dir_entry+0x32d>
/work/x86_os_my/fs/dir.c:323 (discriminator 1)
c000a6f8:	68 ed cf 00 c0       	push   $0xc000cfed
c000a6fd:	68 c4 d0 00 c0       	push   $0xc000d0c4
c000a702:	68 43 01 00 00       	push   $0x143
c000a707:	68 3a cf 00 c0       	push   $0xc000cf3a
c000a70c:	e8 d1 7b ff ff       	call   c00022e2 <panic_spin>
c000a711:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:325

				if (indirect_blocks > 1) {	  // 一级间接索引表中还包括其它间接块,仅在索引表中擦除当前间接块地址
c000a714:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
c000a718:	76 35                	jbe    c000a74f <delete_dir_entry+0x368>
/work/x86_os_my/fs/dir.c:326
					all_blocks[block_idx] = 0;
c000a71a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a71d:	c7 84 85 9c fd ff ff 	movl   $0x0,-0x264(%ebp,%eax,4)
c000a724:	00 00 00 00 
/work/x86_os_my/fs/dir.c:327
					ide_write(part->my_disk, dir_inode->i_sectors[12], all_blocks + 12, 1);
c000a728:	8d 85 9c fd ff ff    	lea    -0x264(%ebp),%eax
c000a72e:	83 c0 30             	add    $0x30,%eax
c000a731:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000a734:	8b 4a 40             	mov    0x40(%edx),%ecx
c000a737:	8b 55 08             	mov    0x8(%ebp),%edx
c000a73a:	8b 52 08             	mov    0x8(%edx),%edx
c000a73d:	6a 01                	push   $0x1
c000a73f:	50                   	push   %eax
c000a740:	51                   	push   %ecx
c000a741:	52                   	push   %edx
c000a742:	e8 03 b4 ff ff       	call   c0005b4a <ide_write>
c000a747:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:305
		}

		/* 在此扇区中找到目录项后，清除该目录项并判断是否回收扇区，随后退出循环直接返回 */
		ASSERT(dir_entry_cnt >= 1);	//此扇区内的目录项个数
		/* 若该扇区上只有该目录项自己，则将整个扇区回收。如果目录只有第1个扇区，则不能回收 */
		if (dir_entry_cnt == 1 && !is_dir_first_block) {
c000a74a:	e9 81 00 00 00       	jmp    c000a7d0 <delete_dir_entry+0x3e9>
/work/x86_os_my/fs/dir.c:330
				if (indirect_blocks > 1) {	  // 一级间接索引表中还包括其它间接块,仅在索引表中擦除当前间接块地址
					all_blocks[block_idx] = 0;
					ide_write(part->my_disk, dir_inode->i_sectors[12], all_blocks + 12, 1);
				} else {	// 间接索引表中就当前这1个间接块,直接把间接索引表所在的块回收,然后擦除间接索引表块地址
					/* 回收一级间接索引表所在的块 */
					block_bitmap_idx = dir_inode->i_sectors[12] - part->sb->data_start_lba;
c000a74f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000a752:	8b 50 40             	mov    0x40(%eax),%edx
c000a755:	8b 45 08             	mov    0x8(%ebp),%eax
c000a758:	8b 40 1c             	mov    0x1c(%eax),%eax
c000a75b:	8b 40 28             	mov    0x28(%eax),%eax
c000a75e:	29 c2                	sub    %eax,%edx
c000a760:	89 d0                	mov    %edx,%eax
c000a762:	89 45 d0             	mov    %eax,-0x30(%ebp)
/work/x86_os_my/fs/dir.c:331
					bitmap_set(&part->block_bitmap, block_bitmap_idx, 0);
c000a765:	8b 45 08             	mov    0x8(%ebp),%eax
c000a768:	83 c0 20             	add    $0x20,%eax
c000a76b:	83 ec 04             	sub    $0x4,%esp
c000a76e:	6a 00                	push   $0x0
c000a770:	ff 75 d0             	pushl  -0x30(%ebp)
c000a773:	50                   	push   %eax
c000a774:	e8 d7 7d ff ff       	call   c0002550 <bitmap_set>
c000a779:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:332
					bitmap_sync(cur_part, block_bitmap_idx, BLOCK_BITMAP);
c000a77c:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000a781:	83 ec 04             	sub    $0x4,%esp
c000a784:	6a 01                	push   $0x1
c000a786:	ff 75 d0             	pushl  -0x30(%ebp)
c000a789:	50                   	push   %eax
c000a78a:	e8 6e e5 ff ff       	call   c0008cfd <bitmap_sync>
c000a78f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:335

					/* 将间接索引表地址清0 */
					dir_inode->i_sectors[12] = 0;
c000a792:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000a795:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
/work/x86_os_my/fs/dir.c:305
		}

		/* 在此扇区中找到目录项后，清除该目录项并判断是否回收扇区，随后退出循环直接返回 */
		ASSERT(dir_entry_cnt >= 1);	//此扇区内的目录项个数
		/* 若该扇区上只有该目录项自己，则将整个扇区回收。如果目录只有第1个扇区，则不能回收 */
		if (dir_entry_cnt == 1 && !is_dir_first_block) {
c000a79c:	eb 32                	jmp    c000a7d0 <delete_dir_entry+0x3e9>
/work/x86_os_my/fs/dir.c:340
					dir_inode->i_sectors[12] = 0;
				}
			}
		} else {
		/* 仅将该目录项清空 */
			memset(dir_entry_found, 0, dir_entry_size);	//要删除的目录项在 dir_entry_found 中
c000a79e:	83 ec 04             	sub    $0x4,%esp
c000a7a1:	ff 75 dc             	pushl  -0x24(%ebp)
c000a7a4:	6a 00                	push   $0x0
c000a7a6:	ff 75 f0             	pushl  -0x10(%ebp)
c000a7a9:	e8 d6 8f ff ff       	call   c0003784 <memset>
c000a7ae:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:341
			ide_write(part->my_disk, all_blocks[block_idx], io_buf, 1);	//io_buf中是所有的目录项
c000a7b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000a7b4:	8b 94 85 9c fd ff ff 	mov    -0x264(%ebp,%eax,4),%edx
c000a7bb:	8b 45 08             	mov    0x8(%ebp),%eax
c000a7be:	8b 40 08             	mov    0x8(%eax),%eax
c000a7c1:	6a 01                	push   $0x1
c000a7c3:	ff 75 14             	pushl  0x14(%ebp)
c000a7c6:	52                   	push   %edx
c000a7c7:	50                   	push   %eax
c000a7c8:	e8 7d b3 ff ff       	call   c0005b4a <ide_write>
c000a7cd:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:345
		}

		/* 更新inode信息并同步到硬盘 */
		ASSERT(dir_inode->i_size >= dir_entry_size);
c000a7d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000a7d3:	8b 40 04             	mov    0x4(%eax),%eax
c000a7d6:	3b 45 dc             	cmp    -0x24(%ebp),%eax
c000a7d9:	73 1c                	jae    c000a7f7 <delete_dir_entry+0x410>
/work/x86_os_my/fs/dir.c:345 (discriminator 1)
c000a7db:	68 04 d0 00 c0       	push   $0xc000d004
c000a7e0:	68 c4 d0 00 c0       	push   $0xc000d0c4
c000a7e5:	68 59 01 00 00       	push   $0x159
c000a7ea:	68 3a cf 00 c0       	push   $0xc000cf3a
c000a7ef:	e8 ee 7a ff ff       	call   c00022e2 <panic_spin>
c000a7f4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:346
		dir_inode->i_size -= dir_entry_size;
c000a7f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000a7fa:	8b 40 04             	mov    0x4(%eax),%eax
c000a7fd:	2b 45 dc             	sub    -0x24(%ebp),%eax
c000a800:	89 c2                	mov    %eax,%edx
c000a802:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000a805:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/dir.c:347
		memset(io_buf, 0, SECTOR_SIZE * 2);
c000a808:	83 ec 04             	sub    $0x4,%esp
c000a80b:	68 00 04 00 00       	push   $0x400
c000a810:	6a 00                	push   $0x0
c000a812:	ff 75 14             	pushl  0x14(%ebp)
c000a815:	e8 6a 8f ff ff       	call   c0003784 <memset>
c000a81a:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:349
		// 同步目录文件的inode到硬盘
		inode_sync(part, dir_inode, io_buf);
c000a81d:	83 ec 04             	sub    $0x4,%esp
c000a820:	ff 75 14             	pushl  0x14(%ebp)
c000a823:	ff 75 e0             	pushl  -0x20(%ebp)
c000a826:	ff 75 08             	pushl  0x8(%ebp)
c000a829:	e8 ea dc ff ff       	call   c0008518 <inode_sync>
c000a82e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:351

		return true;
c000a831:	b8 01 00 00 00       	mov    $0x1,%eax
c000a836:	eb 12                	jmp    c000a84a <delete_dir_entry+0x463>
/work/x86_os_my/fs/dir.c:267
	uint8_t dir_entry_idx, dir_entry_cnt;
	bool is_dir_first_block = false;	// 目录的第1个块

	/* 遍历所有块，寻找目录项 */
	block_idx = 0;
	while (block_idx < 140) {
c000a838:	81 7d f4 8b 00 00 00 	cmpl   $0x8b,-0xc(%ebp)
c000a83f:	0f 86 59 fc ff ff    	jbe    c000a49e <delete_dir_entry+0xb7>
/work/x86_os_my/fs/dir.c:355

		return true;
	}//while (block_idx < 140)

	/* 所有块中未找到则返回false，若出现这种情况应该是 serarch_file 出错了 */
	return false;
c000a845:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/dir.c:356 (discriminator 1)
}
c000a84a:	8b 7d fc             	mov    -0x4(%ebp),%edi
c000a84d:	c9                   	leave  
c000a84e:	c3                   	ret    

c000a84f <dir_read>:
dir_read():
/work/x86_os_my/fs/dir.c:361


/* 读取目录,成功返回1个目录项,失败返回NULL */
// dir->dir_pos 记录遍历目录时，"游标"在目录内的偏移【以前读到的目录项】
struct dir_entry* dir_read(struct dir* dir) {
c000a84f:	55                   	push   %ebp
c000a850:	89 e5                	mov    %esp,%ebp
c000a852:	57                   	push   %edi
c000a853:	81 ec 54 02 00 00    	sub    $0x254,%esp
/work/x86_os_my/fs/dir.c:362
	struct dir_entry* dir_e = (struct dir_entry*)dir->dir_buf;
c000a859:	8b 45 08             	mov    0x8(%ebp),%eax
c000a85c:	83 c0 08             	add    $0x8,%eax
c000a85f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/fs/dir.c:363
	struct inode* dir_inode = dir->inode;
c000a862:	8b 45 08             	mov    0x8(%ebp),%eax
c000a865:	8b 00                	mov    (%eax),%eax
c000a867:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/fs/dir.c:364
	uint32_t all_blocks[140] = {0}, block_cnt = 12;
c000a86a:	8d 95 a8 fd ff ff    	lea    -0x258(%ebp),%edx
c000a870:	b8 00 00 00 00       	mov    $0x0,%eax
c000a875:	b9 8c 00 00 00       	mov    $0x8c,%ecx
c000a87a:	89 d7                	mov    %edx,%edi
c000a87c:	f3 ab                	rep stos %eax,%es:(%edi)
c000a87e:	c7 45 f4 0c 00 00 00 	movl   $0xc,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:365
	uint32_t block_idx = 0, dir_entry_idx = 0;
c000a885:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c000a88c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:367
	// 所有数据块的地址，汇集到 all_blocks 中
	while (block_idx < 12) {
c000a893:	eb 1a                	jmp    c000a8af <dir_read+0x60>
/work/x86_os_my/fs/dir.c:368
		all_blocks[block_idx] = dir_inode->i_sectors[block_idx];
c000a895:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000a898:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000a89b:	83 c2 04             	add    $0x4,%edx
c000a89e:	8b 14 90             	mov    (%eax,%edx,4),%edx
c000a8a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000a8a4:	89 94 85 a8 fd ff ff 	mov    %edx,-0x258(%ebp,%eax,4)
/work/x86_os_my/fs/dir.c:369
		block_idx++;
c000a8ab:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:367
	struct dir_entry* dir_e = (struct dir_entry*)dir->dir_buf;
	struct inode* dir_inode = dir->inode;
	uint32_t all_blocks[140] = {0}, block_cnt = 12;
	uint32_t block_idx = 0, dir_entry_idx = 0;
	// 所有数据块的地址，汇集到 all_blocks 中
	while (block_idx < 12) {
c000a8af:	83 7d f0 0b          	cmpl   $0xb,-0x10(%ebp)
c000a8b3:	76 e0                	jbe    c000a895 <dir_read+0x46>
/work/x86_os_my/fs/dir.c:371
		all_blocks[block_idx] = dir_inode->i_sectors[block_idx];
		block_idx++;
	}
	if (dir_inode->i_sectors[12] != 0) {
c000a8b5:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000a8b8:	8b 40 40             	mov    0x40(%eax),%eax
c000a8bb:	85 c0                	test   %eax,%eax
c000a8bd:	74 2c                	je     c000a8eb <dir_read+0x9c>
/work/x86_os_my/fs/dir.c:372
		ide_read(cur_part->my_disk, dir_inode->i_sectors[12], all_blocks + 12, 1);
c000a8bf:	8d 85 a8 fd ff ff    	lea    -0x258(%ebp),%eax
c000a8c5:	83 c0 30             	add    $0x30,%eax
c000a8c8:	8b 55 e0             	mov    -0x20(%ebp),%edx
c000a8cb:	8b 4a 40             	mov    0x40(%edx),%ecx
c000a8ce:	8b 15 d0 09 01 c0    	mov    0xc00109d0,%edx
c000a8d4:	8b 52 08             	mov    0x8(%edx),%edx
c000a8d7:	6a 01                	push   $0x1
c000a8d9:	50                   	push   %eax
c000a8da:	51                   	push   %ecx
c000a8db:	52                   	push   %edx
c000a8dc:	e8 f5 b0 ff ff       	call   c00059d6 <ide_read>
c000a8e1:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:373
		block_cnt = 140;
c000a8e4:	c7 45 f4 8c 00 00 00 	movl   $0x8c,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:375
	}
	block_idx = 0;
c000a8eb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:377

	uint32_t cur_dir_entry_pos = 0;	// 当前目录项的偏移,此项用来判断是否是之前已经返回过的目录项
c000a8f2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
/work/x86_os_my/fs/dir.c:378
	uint32_t dir_entry_size = cur_part->sb->dir_entry_size;
c000a8f9:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000a8fe:	8b 40 1c             	mov    0x1c(%eax),%eax
c000a901:	8b 40 30             	mov    0x30(%eax),%eax
c000a904:	89 45 dc             	mov    %eax,-0x24(%ebp)
/work/x86_os_my/fs/dir.c:379
	uint32_t dir_entrys_per_sec = SECTOR_SIZE / dir_entry_size;	// 1扇区内可容纳的目录项个数
c000a907:	b8 00 02 00 00       	mov    $0x200,%eax
c000a90c:	ba 00 00 00 00       	mov    $0x0,%edx
c000a911:	f7 75 dc             	divl   -0x24(%ebp)
c000a914:	89 45 d8             	mov    %eax,-0x28(%ebp)
/work/x86_os_my/fs/dir.c:381
	/* 因为此目录内可能删除了某些文件或子目录,所以要遍历所有块 */
	while (block_idx < block_cnt) {
c000a917:	e9 05 01 00 00       	jmp    c000aa21 <dir_read+0x1d2>
/work/x86_os_my/fs/dir.c:382
		if (dir->dir_pos >= dir_inode->i_size) {	//dir_pos 记录遍历目录时，"游标"在目录内的偏移
c000a91c:	8b 45 08             	mov    0x8(%ebp),%eax
c000a91f:	8b 50 04             	mov    0x4(%eax),%edx
c000a922:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000a925:	8b 40 04             	mov    0x4(%eax),%eax
c000a928:	39 c2                	cmp    %eax,%edx
c000a92a:	72 0a                	jb     c000a936 <dir_read+0xe7>
/work/x86_os_my/fs/dir.c:383
			return NULL;
c000a92c:	b8 00 00 00 00       	mov    $0x0,%eax
c000a931:	e9 fc 00 00 00       	jmp    c000aa32 <dir_read+0x1e3>
/work/x86_os_my/fs/dir.c:385
		}
		if (all_blocks[block_idx] == 0) {	// 如果此块地址为0,即空块,继续读出下一块
c000a936:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000a939:	8b 84 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%eax
c000a940:	85 c0                	test   %eax,%eax
c000a942:	75 09                	jne    c000a94d <dir_read+0xfe>
/work/x86_os_my/fs/dir.c:386
			block_idx++;
c000a944:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:387
			continue;
c000a948:	e9 d4 00 00 00       	jmp    c000aa21 <dir_read+0x1d2>
/work/x86_os_my/fs/dir.c:389
		}
		memset(dir_e, 0, SECTOR_SIZE);
c000a94d:	83 ec 04             	sub    $0x4,%esp
c000a950:	68 00 02 00 00       	push   $0x200
c000a955:	6a 00                	push   $0x0
c000a957:	ff 75 e4             	pushl  -0x1c(%ebp)
c000a95a:	e8 25 8e ff ff       	call   c0003784 <memset>
c000a95f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:390
		ide_read(cur_part->my_disk, all_blocks[block_idx], dir_e, 1);
c000a962:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000a965:	8b 94 85 a8 fd ff ff 	mov    -0x258(%ebp,%eax,4),%edx
c000a96c:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000a971:	8b 40 08             	mov    0x8(%eax),%eax
c000a974:	6a 01                	push   $0x1
c000a976:	ff 75 e4             	pushl  -0x1c(%ebp)
c000a979:	52                   	push   %edx
c000a97a:	50                   	push   %eax
c000a97b:	e8 56 b0 ff ff       	call   c00059d6 <ide_read>
c000a980:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:391
		dir_entry_idx = 0;
c000a983:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:393
		/* 遍历扇区内所有目录项 */
		while (dir_entry_idx < dir_entrys_per_sec) {
c000a98a:	e9 82 00 00 00       	jmp    c000aa11 <dir_read+0x1c2>
/work/x86_os_my/fs/dir.c:394
			if ((dir_e + dir_entry_idx)->f_type) {	 // 如果f_type不等于0,即不等于FT_UNKNOWN
c000a98f:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000a992:	89 d0                	mov    %edx,%eax
c000a994:	01 c0                	add    %eax,%eax
c000a996:	01 d0                	add    %edx,%eax
c000a998:	c1 e0 03             	shl    $0x3,%eax
c000a99b:	89 c2                	mov    %eax,%edx
c000a99d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000a9a0:	01 d0                	add    %edx,%eax
c000a9a2:	8b 40 14             	mov    0x14(%eax),%eax
c000a9a5:	85 c0                	test   %eax,%eax
c000a9a7:	74 64                	je     c000aa0d <dir_read+0x1be>
/work/x86_os_my/fs/dir.c:396
				/* 判断是不是最新的目录项,避免返回曾经已经返回过的目录项 */
				if (cur_dir_entry_pos < dir->dir_pos) {
c000a9a9:	8b 45 08             	mov    0x8(%ebp),%eax
c000a9ac:	8b 40 04             	mov    0x4(%eax),%eax
c000a9af:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c000a9b2:	76 0c                	jbe    c000a9c0 <dir_read+0x171>
/work/x86_os_my/fs/dir.c:397
					cur_dir_entry_pos += dir_entry_size;
c000a9b4:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a9b7:	01 45 e8             	add    %eax,-0x18(%ebp)
/work/x86_os_my/fs/dir.c:398
					dir_entry_idx++;
c000a9ba:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:399
					continue;
c000a9be:	eb 51                	jmp    c000aa11 <dir_read+0x1c2>
/work/x86_os_my/fs/dir.c:401
				}
				ASSERT(cur_dir_entry_pos == dir->dir_pos);
c000a9c0:	8b 45 08             	mov    0x8(%ebp),%eax
c000a9c3:	8b 40 04             	mov    0x4(%eax),%eax
c000a9c6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c000a9c9:	74 1c                	je     c000a9e7 <dir_read+0x198>
/work/x86_os_my/fs/dir.c:401 (discriminator 1)
c000a9cb:	68 28 d0 00 c0       	push   $0xc000d028
c000a9d0:	68 d8 d0 00 c0       	push   $0xc000d0d8
c000a9d5:	68 91 01 00 00       	push   $0x191
c000a9da:	68 3a cf 00 c0       	push   $0xc000cf3a
c000a9df:	e8 fe 78 ff ff       	call   c00022e2 <panic_spin>
c000a9e4:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:402
				dir->dir_pos += dir_entry_size;	      // 更新为新位置,即下一个返回的目录项地址
c000a9e7:	8b 45 08             	mov    0x8(%ebp),%eax
c000a9ea:	8b 50 04             	mov    0x4(%eax),%edx
c000a9ed:	8b 45 dc             	mov    -0x24(%ebp),%eax
c000a9f0:	01 c2                	add    %eax,%edx
c000a9f2:	8b 45 08             	mov    0x8(%ebp),%eax
c000a9f5:	89 50 04             	mov    %edx,0x4(%eax)
/work/x86_os_my/fs/dir.c:403
				return dir_e + dir_entry_idx;
c000a9f8:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000a9fb:	89 d0                	mov    %edx,%eax
c000a9fd:	01 c0                	add    %eax,%eax
c000a9ff:	01 d0                	add    %edx,%eax
c000aa01:	c1 e0 03             	shl    $0x3,%eax
c000aa04:	89 c2                	mov    %eax,%edx
c000aa06:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000aa09:	01 d0                	add    %edx,%eax
c000aa0b:	eb 25                	jmp    c000aa32 <dir_read+0x1e3>
/work/x86_os_my/fs/dir.c:405
			}
			dir_entry_idx++;
c000aa0d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:393
		}
		memset(dir_e, 0, SECTOR_SIZE);
		ide_read(cur_part->my_disk, all_blocks[block_idx], dir_e, 1);
		dir_entry_idx = 0;
		/* 遍历扇区内所有目录项 */
		while (dir_entry_idx < dir_entrys_per_sec) {
c000aa11:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000aa14:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c000aa17:	0f 82 72 ff ff ff    	jb     c000a98f <dir_read+0x140>
/work/x86_os_my/fs/dir.c:407
				dir->dir_pos += dir_entry_size;	      // 更新为新位置,即下一个返回的目录项地址
				return dir_e + dir_entry_idx;
			}
			dir_entry_idx++;
		}
		block_idx++;
c000aa1d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:381

	uint32_t cur_dir_entry_pos = 0;	// 当前目录项的偏移,此项用来判断是否是之前已经返回过的目录项
	uint32_t dir_entry_size = cur_part->sb->dir_entry_size;
	uint32_t dir_entrys_per_sec = SECTOR_SIZE / dir_entry_size;	// 1扇区内可容纳的目录项个数
	/* 因为此目录内可能删除了某些文件或子目录,所以要遍历所有块 */
	while (block_idx < block_cnt) {
c000aa21:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000aa24:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c000aa27:	0f 82 ef fe ff ff    	jb     c000a91c <dir_read+0xcd>
/work/x86_os_my/fs/dir.c:409
			}
			dir_entry_idx++;
		}
		block_idx++;
	}
	return NULL;
c000aa2d:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/dir.c:410 (discriminator 1)
}
c000aa32:	8b 7d fc             	mov    -0x4(%ebp),%edi
c000aa35:	c9                   	leave  
c000aa36:	c3                   	ret    

c000aa37 <dir_is_empty>:
dir_is_empty():
/work/x86_os_my/fs/dir.c:413

/* 判断目录是否为空 */
bool dir_is_empty(struct dir* dir) {
c000aa37:	55                   	push   %ebp
c000aa38:	89 e5                	mov    %esp,%ebp
c000aa3a:	83 ec 10             	sub    $0x10,%esp
/work/x86_os_my/fs/dir.c:414
	struct inode* dir_inode = dir->inode;
c000aa3d:	8b 45 08             	mov    0x8(%ebp),%eax
c000aa40:	8b 00                	mov    (%eax),%eax
c000aa42:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/fs/dir.c:416
	/* 若目录下只有.和..这两个目录项则目录为空 */
	return (dir_inode->i_size == cur_part->sb->dir_entry_size * 2);
c000aa45:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000aa48:	8b 50 04             	mov    0x4(%eax),%edx
c000aa4b:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000aa50:	8b 40 1c             	mov    0x1c(%eax),%eax
c000aa53:	8b 40 30             	mov    0x30(%eax),%eax
c000aa56:	01 c0                	add    %eax,%eax
c000aa58:	39 c2                	cmp    %eax,%edx
c000aa5a:	0f 94 c0             	sete   %al
c000aa5d:	0f b6 c0             	movzbl %al,%eax
/work/x86_os_my/fs/dir.c:417
}
c000aa60:	c9                   	leave  
c000aa61:	c3                   	ret    

c000aa62 <dir_remove>:
dir_remove():
/work/x86_os_my/fs/dir.c:420

/* 在父目录parent_dir中删除child_dir */
int32_t dir_remove(struct dir* parent_dir, struct dir* child_dir) {
c000aa62:	55                   	push   %ebp
c000aa63:	89 e5                	mov    %esp,%ebp
c000aa65:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/fs/dir.c:421
	struct inode* child_dir_inode  = child_dir->inode;
c000aa68:	8b 45 0c             	mov    0xc(%ebp),%eax
c000aa6b:	8b 00                	mov    (%eax),%eax
c000aa6d:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/fs/dir.c:423
	/* 空目录只在inode->i_sectors[0]中有扇区,其它扇区都应该为空 */
	int32_t block_idx = 1;
c000aa70:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:424
	while (block_idx < 13) {
c000aa77:	eb 30                	jmp    c000aaa9 <dir_remove+0x47>
/work/x86_os_my/fs/dir.c:425
		ASSERT(child_dir_inode->i_sectors[block_idx] == 0);
c000aa79:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000aa7c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000aa7f:	83 c2 04             	add    $0x4,%edx
c000aa82:	8b 04 90             	mov    (%eax,%edx,4),%eax
c000aa85:	85 c0                	test   %eax,%eax
c000aa87:	74 1c                	je     c000aaa5 <dir_remove+0x43>
/work/x86_os_my/fs/dir.c:425 (discriminator 1)
c000aa89:	68 4c d0 00 c0       	push   $0xc000d04c
c000aa8e:	68 e4 d0 00 c0       	push   $0xc000d0e4
c000aa93:	68 a9 01 00 00       	push   $0x1a9
c000aa98:	68 3a cf 00 c0       	push   $0xc000cf3a
c000aa9d:	e8 40 78 ff ff       	call   c00022e2 <panic_spin>
c000aaa2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:426
		block_idx++;
c000aaa5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/fs/dir.c:424
/* 在父目录parent_dir中删除child_dir */
int32_t dir_remove(struct dir* parent_dir, struct dir* child_dir) {
	struct inode* child_dir_inode  = child_dir->inode;
	/* 空目录只在inode->i_sectors[0]中有扇区,其它扇区都应该为空 */
	int32_t block_idx = 1;
	while (block_idx < 13) {
c000aaa9:	83 7d f4 0c          	cmpl   $0xc,-0xc(%ebp)
c000aaad:	7e ca                	jle    c000aa79 <dir_remove+0x17>
/work/x86_os_my/fs/dir.c:428
		ASSERT(child_dir_inode->i_sectors[block_idx] == 0);
		block_idx++;
	}
	void* io_buf = sys_malloc(SECTOR_SIZE * 2);
c000aaaf:	83 ec 0c             	sub    $0xc,%esp
c000aab2:	68 00 04 00 00       	push   $0x400
c000aab7:	e8 d1 81 ff ff       	call   c0002c8d <sys_malloc>
c000aabc:	83 c4 10             	add    $0x10,%esp
c000aabf:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/fs/dir.c:429
	if (io_buf == NULL) {
c000aac2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c000aac6:	75 17                	jne    c000aadf <dir_remove+0x7d>
/work/x86_os_my/fs/dir.c:430
		printk("dir_remove: malloc for io_buf failed\n");
c000aac8:	83 ec 0c             	sub    $0xc,%esp
c000aacb:	68 78 d0 00 c0       	push   $0xc000d078
c000aad0:	e8 7a b9 ff ff       	call   c000644f <printk>
c000aad5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:431
		return -1;
c000aad8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000aadd:	eb 44                	jmp    c000ab23 <dir_remove+0xc1>
/work/x86_os_my/fs/dir.c:435
	}

	/* 在父目录parent_dir中删除子目录child_dir对应的"目录项" */
	delete_dir_entry(cur_part, parent_dir, child_dir_inode->i_no, io_buf);
c000aadf:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000aae2:	8b 10                	mov    (%eax),%edx
c000aae4:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000aae9:	ff 75 ec             	pushl  -0x14(%ebp)
c000aaec:	52                   	push   %edx
c000aaed:	ff 75 08             	pushl  0x8(%ebp)
c000aaf0:	50                   	push   %eax
c000aaf1:	e8 f1 f8 ff ff       	call   c000a3e7 <delete_dir_entry>
c000aaf6:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:438

	/* 回收inode中i_secotrs中所占用的扇区,并同步inode_bitmap和block_bitmap */
	inode_release(cur_part, child_dir_inode->i_no);
c000aaf9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000aafc:	8b 10                	mov    (%eax),%edx
c000aafe:	a1 d0 09 01 c0       	mov    0xc00109d0,%eax
c000ab03:	83 ec 08             	sub    $0x8,%esp
c000ab06:	52                   	push   %edx
c000ab07:	50                   	push   %eax
c000ab08:	e8 06 de ff ff       	call   c0008913 <inode_release>
c000ab0d:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:439
	sys_free(io_buf);
c000ab10:	83 ec 0c             	sub    $0xc,%esp
c000ab13:	ff 75 ec             	pushl  -0x14(%ebp)
c000ab16:	e8 9f 87 ff ff       	call   c00032ba <sys_free>
c000ab1b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/fs/dir.c:440
	return 0;
c000ab1e:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/fs/dir.c:441
}
c000ab23:	c9                   	leave  
c000ab24:	c3                   	ret    

c000ab25 <copy_pcb_vaddrbitmap_stack0>:
copy_pcb_vaddrbitmap_stack0():
/work/x86_os_my/userprog/fork.c:13
#include "file.h"

extern void intr_exit(void);

/* 将父进程的pcb、虚拟地址位图拷贝给子进程 */
static int32_t copy_pcb_vaddrbitmap_stack0(struct task_struct* child_thread, struct task_struct* parent_thread) {
c000ab25:	55                   	push   %ebp
c000ab26:	89 e5                	mov    %esp,%ebp
c000ab28:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/fork.c:15
	/* a 复制pcb所在的整个页,里面包含进程pcb信息及特级0极的栈,里面包含了返回地址, 然后再单独修改个别部分 */
	memcpy(child_thread, parent_thread, PG_SIZE);
c000ab2b:	83 ec 04             	sub    $0x4,%esp
c000ab2e:	68 00 10 00 00       	push   $0x1000
c000ab33:	ff 75 0c             	pushl  0xc(%ebp)
c000ab36:	ff 75 08             	pushl  0x8(%ebp)
c000ab39:	e8 98 8c ff ff       	call   c00037d6 <memcpy>
c000ab3e:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:16
	child_thread->pid = fork_pid();
c000ab41:	e8 95 90 ff ff       	call   c0003bdb <fork_pid>
c000ab46:	89 c2                	mov    %eax,%edx
c000ab48:	8b 45 08             	mov    0x8(%ebp),%eax
c000ab4b:	66 89 50 04          	mov    %dx,0x4(%eax)
/work/x86_os_my/userprog/fork.c:17
	child_thread->elapsed_ticks = 0;
c000ab4f:	8b 45 08             	mov    0x8(%ebp),%eax
c000ab52:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
/work/x86_os_my/userprog/fork.c:18
	child_thread->status = TASK_READY;
c000ab59:	8b 45 08             	mov    0x8(%ebp),%eax
c000ab5c:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)
/work/x86_os_my/userprog/fork.c:19
	child_thread->ticks = child_thread->priority;   // 为新进程把时间片充满
c000ab63:	8b 45 08             	mov    0x8(%ebp),%eax
c000ab66:	0f b6 50 1c          	movzbl 0x1c(%eax),%edx
c000ab6a:	8b 45 08             	mov    0x8(%ebp),%eax
c000ab6d:	88 50 1d             	mov    %dl,0x1d(%eax)
/work/x86_os_my/userprog/fork.c:20
	child_thread->parent_pid = parent_thread->pid;
c000ab70:	8b 45 0c             	mov    0xc(%ebp),%eax
c000ab73:	0f b7 50 04          	movzwl 0x4(%eax),%edx
c000ab77:	8b 45 08             	mov    0x8(%ebp),%eax
c000ab7a:	66 89 90 10 01 00 00 	mov    %dx,0x110(%eax)
/work/x86_os_my/userprog/fork.c:21
	child_thread->general_tag.prev = child_thread->general_tag.next = NULL;
c000ab81:	8b 45 08             	mov    0x8(%ebp),%eax
c000ab84:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
c000ab8b:	8b 45 08             	mov    0x8(%ebp),%eax
c000ab8e:	8b 50 48             	mov    0x48(%eax),%edx
c000ab91:	8b 45 08             	mov    0x8(%ebp),%eax
c000ab94:	89 50 44             	mov    %edx,0x44(%eax)
/work/x86_os_my/userprog/fork.c:22
	child_thread->all_list_tag.prev = child_thread->all_list_tag.next = NULL;
c000ab97:	8b 45 08             	mov    0x8(%ebp),%eax
c000ab9a:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
c000aba1:	8b 45 08             	mov    0x8(%ebp),%eax
c000aba4:	8b 50 50             	mov    0x50(%eax),%edx
c000aba7:	8b 45 08             	mov    0x8(%ebp),%eax
c000abaa:	89 50 4c             	mov    %edx,0x4c(%eax)
/work/x86_os_my/userprog/fork.c:23
	block_desc_init(child_thread->u_block_desc);
c000abad:	8b 45 08             	mov    0x8(%ebp),%eax
c000abb0:	83 c0 64             	add    $0x64,%eax
c000abb3:	83 ec 0c             	sub    $0xc,%esp
c000abb6:	50                   	push   %eax
c000abb7:	e8 e4 8a ff ff       	call   c00036a0 <block_desc_init>
c000abbc:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:25
	/* b 复制父进程的虚拟地址池的位图 */
	uint32_t bitmap_pg_cnt = DIV_ROUND_UP((0xc0000000 - USER_VADDR_START) / PG_SIZE / 8 , PG_SIZE);
c000abbf:	c7 45 f4 17 00 00 00 	movl   $0x17,-0xc(%ebp)
/work/x86_os_my/userprog/fork.c:26
	void* vaddr_btmp = get_kernel_pages(bitmap_pg_cnt);
c000abc6:	83 ec 0c             	sub    $0xc,%esp
c000abc9:	ff 75 f4             	pushl  -0xc(%ebp)
c000abcc:	e8 b9 7d ff ff       	call   c000298a <get_kernel_pages>
c000abd1:	83 c4 10             	add    $0x10,%esp
c000abd4:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:27
	if (vaddr_btmp == NULL)
c000abd7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000abdb:	75 07                	jne    c000abe4 <copy_pcb_vaddrbitmap_stack0+0xbf>
/work/x86_os_my/userprog/fork.c:28
		return -1;
c000abdd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000abe2:	eb 73                	jmp    c000ac57 <copy_pcb_vaddrbitmap_stack0+0x132>
/work/x86_os_my/userprog/fork.c:31
	/* 此时child_thread->userprog_vaddr.vaddr_bitmap.bits还是指向父进程虚拟地址的位图地址
	 * 下面将child_thread->userprog_vaddr.vaddr_bitmap.bits指向自己的位图vaddr_btmp */
	memcpy(vaddr_btmp, child_thread->userprog_vaddr.vaddr_bitmap.bits, bitmap_pg_cnt * PG_SIZE);	//复制父进程的虚拟地址位图
c000abe4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000abe7:	c1 e0 0c             	shl    $0xc,%eax
c000abea:	89 c2                	mov    %eax,%edx
c000abec:	8b 45 08             	mov    0x8(%ebp),%eax
c000abef:	8b 40 5c             	mov    0x5c(%eax),%eax
c000abf2:	83 ec 04             	sub    $0x4,%esp
c000abf5:	52                   	push   %edx
c000abf6:	50                   	push   %eax
c000abf7:	ff 75 f0             	pushl  -0x10(%ebp)
c000abfa:	e8 d7 8b ff ff       	call   c00037d6 <memcpy>
c000abff:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:32
	child_thread->userprog_vaddr.vaddr_bitmap.bits = vaddr_btmp;	//指向子进程自己的了
c000ac02:	8b 45 08             	mov    0x8(%ebp),%eax
c000ac05:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000ac08:	89 50 5c             	mov    %edx,0x5c(%eax)
/work/x86_os_my/userprog/fork.c:34
	/* 调试用 */
	ASSERT(strlen(child_thread->name) < 11);	// pcb.name的长度是16,为避免下面strcat越界
c000ac0b:	8b 45 08             	mov    0x8(%ebp),%eax
c000ac0e:	83 c0 0c             	add    $0xc,%eax
c000ac11:	83 ec 0c             	sub    $0xc,%esp
c000ac14:	50                   	push   %eax
c000ac15:	e8 f4 8c ff ff       	call   c000390e <strlen>
c000ac1a:	83 c4 10             	add    $0x10,%esp
c000ac1d:	83 f8 0a             	cmp    $0xa,%eax
c000ac20:	76 19                	jbe    c000ac3b <copy_pcb_vaddrbitmap_stack0+0x116>
/work/x86_os_my/userprog/fork.c:34 (discriminator 1)
c000ac22:	68 f0 d0 00 c0       	push   $0xc000d0f0
c000ac27:	68 f8 d1 00 c0       	push   $0xc000d1f8
c000ac2c:	6a 22                	push   $0x22
c000ac2e:	68 10 d1 00 c0       	push   $0xc000d110
c000ac33:	e8 aa 76 ff ff       	call   c00022e2 <panic_spin>
c000ac38:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:35
	strcat(child_thread->name,"_fork");
c000ac3b:	8b 45 08             	mov    0x8(%ebp),%eax
c000ac3e:	83 c0 0c             	add    $0xc,%eax
c000ac41:	83 ec 08             	sub    $0x8,%esp
c000ac44:	68 20 d1 00 c0       	push   $0xc000d120
c000ac49:	50                   	push   %eax
c000ac4a:	e8 39 8e ff ff       	call   c0003a88 <strcat>
c000ac4f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:36
	return 0;
c000ac52:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/userprog/fork.c:37
}
c000ac57:	c9                   	leave  
c000ac58:	c3                   	ret    

c000ac59 <copy_body_stack3>:
copy_body_stack3():
/work/x86_os_my/userprog/fork.c:46
用户使用的内存是用虚拟内存池来管理的，也就是 pcb 中的 userprog_vaddr
进程的内存布局，其中低 3GB 的虚拟地址空间中，
低地址处是进程的数据段、代码段，
其余部分是，堆从低地址往高地址发展，栈从 USER_STACK3_VADDR，即 0xc0000000 - 0x1000 处往低地址发展。
*/
static void copy_body_stack3(struct task_struct* child_thread, struct task_struct* parent_thread, void* buf_page) {
c000ac59:	55                   	push   %ebp
c000ac5a:	89 e5                	mov    %esp,%ebp
c000ac5c:	83 ec 28             	sub    $0x28,%esp
/work/x86_os_my/userprog/fork.c:47
	uint8_t* vaddr_btmp = parent_thread->userprog_vaddr.vaddr_bitmap.bits;
c000ac5f:	8b 45 0c             	mov    0xc(%ebp),%eax
c000ac62:	8b 40 5c             	mov    0x5c(%eax),%eax
c000ac65:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/userprog/fork.c:48
	uint32_t btmp_bytes_len = parent_thread->userprog_vaddr.vaddr_bitmap.btmp_bytes_len;
c000ac68:	8b 45 0c             	mov    0xc(%ebp),%eax
c000ac6b:	8b 40 58             	mov    0x58(%eax),%eax
c000ac6e:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/userprog/fork.c:49
	uint32_t vaddr_start = parent_thread->userprog_vaddr.vaddr_start;
c000ac71:	8b 45 0c             	mov    0xc(%ebp),%eax
c000ac74:	8b 40 60             	mov    0x60(%eax),%eax
c000ac77:	89 45 e4             	mov    %eax,-0x1c(%ebp)
/work/x86_os_my/userprog/fork.c:50
	uint32_t idx_byte = 0;
c000ac7a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
/work/x86_os_my/userprog/fork.c:51
	uint32_t idx_bit = 0;
c000ac81:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:52
	uint32_t prog_vaddr = 0;
c000ac88:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
/work/x86_os_my/userprog/fork.c:55

	/* 在父进程的用户空间中查找已有数据的页，按页一一拷贝给子进程 */
	while (idx_byte < btmp_bytes_len) {
c000ac8f:	e9 c5 00 00 00       	jmp    c000ad59 <copy_body_stack3+0x100>
/work/x86_os_my/userprog/fork.c:56
		if (vaddr_btmp[idx_byte]) {
c000ac94:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000ac97:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000ac9a:	01 d0                	add    %edx,%eax
c000ac9c:	0f b6 00             	movzbl (%eax),%eax
c000ac9f:	84 c0                	test   %al,%al
c000aca1:	0f 84 ae 00 00 00    	je     c000ad55 <copy_body_stack3+0xfc>
/work/x86_os_my/userprog/fork.c:57
			idx_bit = 0;
c000aca7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:58
			while (idx_bit < 8) {
c000acae:	e9 98 00 00 00       	jmp    c000ad4b <copy_body_stack3+0xf2>
/work/x86_os_my/userprog/fork.c:59
				if ((BITMAP_MASK << idx_bit) & vaddr_btmp[idx_byte]) {	//BITMAP_MASK=1
c000acb3:	8b 55 ec             	mov    -0x14(%ebp),%edx
c000acb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000acb9:	01 d0                	add    %edx,%eax
c000acbb:	0f b6 00             	movzbl (%eax),%eax
c000acbe:	0f b6 d0             	movzbl %al,%edx
c000acc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000acc4:	89 c1                	mov    %eax,%ecx
c000acc6:	d3 fa                	sar    %cl,%edx
c000acc8:	89 d0                	mov    %edx,%eax
c000acca:	83 e0 01             	and    $0x1,%eax
c000accd:	85 c0                	test   %eax,%eax
c000accf:	74 76                	je     c000ad47 <copy_body_stack3+0xee>
/work/x86_os_my/userprog/fork.c:60
					prog_vaddr = (idx_byte * 8 + idx_bit) * PG_SIZE + vaddr_start;
c000acd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000acd4:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c000acdb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000acde:	01 d0                	add    %edx,%eax
c000ace0:	c1 e0 0c             	shl    $0xc,%eax
c000ace3:	89 c2                	mov    %eax,%edx
c000ace5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c000ace8:	01 d0                	add    %edx,%eax
c000acea:	89 45 e0             	mov    %eax,-0x20(%ebp)
/work/x86_os_my/userprog/fork.c:65
					/* 下面的操作是将父进程用户空间中的数据通过内核空间做中转,最终复制到子进程的用户空间 */

					/* a 将父进程在用户空间中的数据复制到"内核缓冲区buf_page"
					目的：下面切换到子进程的页表后,还能访问到父进程的数据*/
					memcpy(buf_page, (void*)prog_vaddr, PG_SIZE);
c000aced:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000acf0:	83 ec 04             	sub    $0x4,%esp
c000acf3:	68 00 10 00 00       	push   $0x1000
c000acf8:	50                   	push   %eax
c000acf9:	ff 75 10             	pushl  0x10(%ebp)
c000acfc:	e8 d5 8a ff ff       	call   c00037d6 <memcpy>
c000ad01:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:68

					/* b 将页表切换到子进程，下面申请内存的函数，将pte及pde安装在子进程的页表中 */
					page_dir_activate(child_thread);
c000ad04:	83 ec 0c             	sub    $0xc,%esp
c000ad07:	ff 75 08             	pushl  0x8(%ebp)
c000ad0a:	e8 be a3 ff ff       	call   c00050cd <page_dir_activate>
c000ad0f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:70
					/* c 申请虚拟地址prog_vaddr */
					get_a_page_without_opvaddrbitmap(PF_USER, prog_vaddr);	//位图已经拷贝过了，当然不用再操作了...
c000ad12:	83 ec 08             	sub    $0x8,%esp
c000ad15:	ff 75 e0             	pushl  -0x20(%ebp)
c000ad18:	6a 02                	push   $0x2
c000ad1a:	e8 91 7e ff ff       	call   c0002bb0 <get_a_page_without_opvaddrbitmap>
c000ad1f:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:73

					/* d 从内核缓冲区中将父进程数据复制到子进程的用户空间 */
					memcpy((void*)prog_vaddr, buf_page, PG_SIZE);
c000ad22:	8b 45 e0             	mov    -0x20(%ebp),%eax
c000ad25:	83 ec 04             	sub    $0x4,%esp
c000ad28:	68 00 10 00 00       	push   $0x1000
c000ad2d:	ff 75 10             	pushl  0x10(%ebp)
c000ad30:	50                   	push   %eax
c000ad31:	e8 a0 8a ff ff       	call   c00037d6 <memcpy>
c000ad36:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:76

					/* e 恢复父进程页表 */
					page_dir_activate(parent_thread);
c000ad39:	83 ec 0c             	sub    $0xc,%esp
c000ad3c:	ff 75 0c             	pushl  0xc(%ebp)
c000ad3f:	e8 89 a3 ff ff       	call   c00050cd <page_dir_activate>
c000ad44:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:78
				}
				idx_bit++;
c000ad47:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:58

	/* 在父进程的用户空间中查找已有数据的页，按页一一拷贝给子进程 */
	while (idx_byte < btmp_bytes_len) {
		if (vaddr_btmp[idx_byte]) {
			idx_bit = 0;
			while (idx_bit < 8) {
c000ad4b:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
c000ad4f:	0f 86 5e ff ff ff    	jbe    c000acb3 <copy_body_stack3+0x5a>
/work/x86_os_my/userprog/fork.c:81
					page_dir_activate(parent_thread);
				}
				idx_bit++;
			}
		}
		idx_byte++;
c000ad55:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/userprog/fork.c:55
	uint32_t idx_byte = 0;
	uint32_t idx_bit = 0;
	uint32_t prog_vaddr = 0;

	/* 在父进程的用户空间中查找已有数据的页，按页一一拷贝给子进程 */
	while (idx_byte < btmp_bytes_len) {
c000ad59:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000ad5c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c000ad5f:	0f 82 2f ff ff ff    	jb     c000ac94 <copy_body_stack3+0x3b>
/work/x86_os_my/userprog/fork.c:83
				idx_bit++;
			}
		}
		idx_byte++;
	}
}
c000ad65:	90                   	nop
c000ad66:	c9                   	leave  
c000ad67:	c3                   	ret    

c000ad68 <build_child_stack>:
build_child_stack():
/work/x86_os_my/userprog/fork.c:146
为了让子进程也能继续 fork 之后的代码运行，必须让它同父进程一样，从中断退出，也就是要经过 intr_exit。

子进程是由调度器 schedule 调度执行的，它要用到 switch_to 函数，
而 switch_to 函数要从栈 thread_stack 中恢复上下文，因此我们要想办法构建出合适的 thread_stack
*/
static int32_t build_child_stack(struct task_struct* child_thread) {
c000ad68:	55                   	push   %ebp
c000ad69:	89 e5                	mov    %esp,%ebp
c000ad6b:	83 ec 20             	sub    $0x20,%esp
/work/x86_os_my/userprog/fork.c:149
	/* a 使子进程pid返回值为0 */
	/* 获取子进程0级栈栈顶 */
	struct intr_stack* intr_0_stack = (struct intr_stack*)((uint32_t)child_thread + PG_SIZE - sizeof(struct intr_stack));
c000ad6e:	8b 45 08             	mov    0x8(%ebp),%eax
c000ad71:	05 b4 0f 00 00       	add    $0xfb4,%eax
c000ad76:	89 45 fc             	mov    %eax,-0x4(%ebp)
/work/x86_os_my/userprog/fork.c:151
	/* 修改子进程的返回值为0 */
	intr_0_stack->eax = 0;	//根据 abi 约定，eax 寄存器中是函数返回值!!!
c000ad79:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000ad7c:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
/work/x86_os_my/userprog/fork.c:154

	/* b 为 switch_to 构建线程栈 struct thread_stack,将其构建在紧临intr_stack之下的空间*/
	uint32_t* ret_addr_in_thread_stack  = (uint32_t*)intr_0_stack - 1;	// 任务切换后新任务的返回地址 eip
c000ad83:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000ad86:	83 e8 04             	sub    $0x4,%eax
c000ad89:	89 45 f8             	mov    %eax,-0x8(%ebp)
/work/x86_os_my/userprog/fork.c:157

	/***   这三行不是必要的,只是为了梳理 thread_stack 中的关系 ***/
	uint32_t* esi_ptr_in_thread_stack = (uint32_t*)intr_0_stack - 2;
c000ad8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000ad8f:	83 e8 08             	sub    $0x8,%eax
c000ad92:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/fork.c:158
	uint32_t* edi_ptr_in_thread_stack = (uint32_t*)intr_0_stack - 3;
c000ad95:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000ad98:	83 e8 0c             	sub    $0xc,%eax
c000ad9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:159
	uint32_t* ebx_ptr_in_thread_stack = (uint32_t*)intr_0_stack - 4;
c000ad9e:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000ada1:	83 e8 10             	sub    $0x10,%eax
c000ada4:	89 45 ec             	mov    %eax,-0x14(%ebp)
/work/x86_os_my/userprog/fork.c:166

	/* ebp 在 thread_stack 中的地址便是当时的esp(0级栈的栈顶)，即栈顶esp = (uint32_t*)intr_0_stack - 5 */
	/* 指针 ebp_ptr_in_thread_stack，它是 thread_stack 的栈顶，
	 * 必须把它的值存放在 pcb 中偏移为 0 的地方，即 task_struct 中的 self_kstack 处，
	 * 将来 switch_to 要用它作为栈顶，并且执行一系列的 pop 来恢复上下文。 */
	uint32_t* ebp_ptr_in_thread_stack = (uint32_t*)intr_0_stack - 5;
c000ada7:	8b 45 fc             	mov    -0x4(%ebp),%eax
c000adaa:	83 e8 14             	sub    $0x14,%eax
c000adad:	89 45 e8             	mov    %eax,-0x18(%ebp)
/work/x86_os_my/userprog/fork.c:169

	/* switch_to的返回地址更新为intr_exit，直接从中断返回 */
	*ret_addr_in_thread_stack = (uint32_t)intr_exit;	// kernel.S
c000adb0:	ba 10 1c 00 c0       	mov    $0xc0001c10,%edx
c000adb5:	8b 45 f8             	mov    -0x8(%ebp),%eax
c000adb8:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/fork.c:173

	/* 下面这个赋值只是为了使构建的 thread_stack 更加清晰,其实也不需要,
	 * 因为在进入intr_exit后一系列的pop会把寄存器中的数据覆盖 */
	*ebp_ptr_in_thread_stack = *ebx_ptr_in_thread_stack = *edi_ptr_in_thread_stack = *esi_ptr_in_thread_stack = 0;
c000adba:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000adbd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c000adc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000adc6:	8b 10                	mov    (%eax),%edx
c000adc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000adcb:	89 10                	mov    %edx,(%eax)
c000adcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000add0:	8b 10                	mov    (%eax),%edx
c000add2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000add5:	89 10                	mov    %edx,(%eax)
c000add7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c000adda:	8b 10                	mov    (%eax),%edx
c000addc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c000addf:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/fork.c:177
	/*********************************************************/

	/* 把构建的 thread_stack 的栈顶做为 switch_to 恢复数据时的栈顶 */
	child_thread->self_kstack = ebp_ptr_in_thread_stack;	//线程内核栈栈顶 self_kstack 总是和 esp 来回赋值~
c000ade1:	8b 45 08             	mov    0x8(%ebp),%eax
c000ade4:	8b 55 e8             	mov    -0x18(%ebp),%edx
c000ade7:	89 10                	mov    %edx,(%eax)
/work/x86_os_my/userprog/fork.c:184
	在被换下处理器前，我们会把线程的上下文信息保存在 0 特权级栈中，
	self_kstack 便用来记录 0 特权级栈在保存线程上下文后，新的栈顶，
	在下一次此线程又被调度到处理器上时，
	把 self_kstack 的值加载到 esp 寄存器，这样便从 0 特权级栈中获取了线程上下文，从而可以加载到处理器中运行。
	*/
	return 0;
c000ade9:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/userprog/fork.c:185
}
c000adee:	c9                   	leave  
c000adef:	c3                   	ret    

c000adf0 <update_inode_open_cnts>:
update_inode_open_cnts():
/work/x86_os_my/userprog/fork.c:188

/* 更新inode打开数 */
static void update_inode_open_cnts(struct task_struct* thread) {
c000adf0:	55                   	push   %ebp
c000adf1:	89 e5                	mov    %esp,%ebp
c000adf3:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/fork.c:189
	int32_t local_fd = 3, global_fd = 0;
c000adf6:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
c000adfd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:190
	while (local_fd < MAX_FILES_OPEN_PER_PROC) {	//遍历线程打开的所有文件
c000ae04:	eb 58                	jmp    c000ae5e <update_inode_open_cnts+0x6e>
/work/x86_os_my/userprog/fork.c:191
		global_fd = thread->fd_table[local_fd];
c000ae06:	8b 45 08             	mov    0x8(%ebp),%eax
c000ae09:	8b 55 f4             	mov    -0xc(%ebp),%edx
c000ae0c:	83 c2 08             	add    $0x8,%edx
c000ae0f:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
c000ae13:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:192
		ASSERT(global_fd < MAX_FILE_OPEN);
c000ae16:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
c000ae1a:	7e 1c                	jle    c000ae38 <update_inode_open_cnts+0x48>
/work/x86_os_my/userprog/fork.c:192 (discriminator 1)
c000ae1c:	68 26 d1 00 c0       	push   $0xc000d126
c000ae21:	68 14 d2 00 c0       	push   $0xc000d214
c000ae26:	68 c0 00 00 00       	push   $0xc0
c000ae2b:	68 10 d1 00 c0       	push   $0xc000d110
c000ae30:	e8 ad 74 ff ff       	call   c00022e2 <panic_spin>
c000ae35:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:193
		if (global_fd != -1) {
c000ae38:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
c000ae3c:	74 1c                	je     c000ae5a <update_inode_open_cnts+0x6a>
/work/x86_os_my/userprog/fork.c:194
			file_table[global_fd].fd_inode->i_open_cnts++;	//线程打开的所有文件的inode->open_cnt加一
c000ae3e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c000ae41:	89 d0                	mov    %edx,%eax
c000ae43:	01 c0                	add    %eax,%eax
c000ae45:	01 d0                	add    %edx,%eax
c000ae47:	c1 e0 02             	shl    $0x2,%eax
c000ae4a:	05 e8 09 01 c0       	add    $0xc00109e8,%eax
c000ae4f:	8b 00                	mov    (%eax),%eax
c000ae51:	8b 50 08             	mov    0x8(%eax),%edx
c000ae54:	83 c2 01             	add    $0x1,%edx
c000ae57:	89 50 08             	mov    %edx,0x8(%eax)
/work/x86_os_my/userprog/fork.c:196
		}
		local_fd++;
c000ae5a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
/work/x86_os_my/userprog/fork.c:190
}

/* 更新inode打开数 */
static void update_inode_open_cnts(struct task_struct* thread) {
	int32_t local_fd = 3, global_fd = 0;
	while (local_fd < MAX_FILES_OPEN_PER_PROC) {	//遍历线程打开的所有文件
c000ae5e:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
c000ae62:	7e a2                	jle    c000ae06 <update_inode_open_cnts+0x16>
/work/x86_os_my/userprog/fork.c:198
		if (global_fd != -1) {
			file_table[global_fd].fd_inode->i_open_cnts++;	//线程打开的所有文件的inode->open_cnt加一
		}
		local_fd++;
	}
}
c000ae64:	90                   	nop
c000ae65:	c9                   	leave  
c000ae66:	c3                   	ret    

c000ae67 <copy_process>:
copy_process():
/work/x86_os_my/userprog/fork.c:201

/* 拷贝父进程本身所占资源给子进程 */
static int32_t copy_process(struct task_struct* child_thread, struct task_struct* parent_thread) {
c000ae67:	55                   	push   %ebp
c000ae68:	89 e5                	mov    %esp,%ebp
c000ae6a:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/fork.c:203
	/* 内核缓冲区,作为父进程用户空间的数据，复制到子进程用户空间，的中转 */
	void* buf_page = get_kernel_pages(1);
c000ae6d:	83 ec 0c             	sub    $0xc,%esp
c000ae70:	6a 01                	push   $0x1
c000ae72:	e8 13 7b ff ff       	call   c000298a <get_kernel_pages>
c000ae77:	83 c4 10             	add    $0x10,%esp
c000ae7a:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/fork.c:204
	if (buf_page == NULL) {
c000ae7d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c000ae81:	75 0a                	jne    c000ae8d <copy_process+0x26>
/work/x86_os_my/userprog/fork.c:205
		return -1;
c000ae83:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000ae88:	e9 82 00 00 00       	jmp    c000af0f <copy_process+0xa8>
/work/x86_os_my/userprog/fork.c:209
	}

	/* a 复制父进程的pcb、虚拟地址位图、内核栈到子进程 */
	if (copy_pcb_vaddrbitmap_stack0(child_thread, parent_thread) == -1) {
c000ae8d:	83 ec 08             	sub    $0x8,%esp
c000ae90:	ff 75 0c             	pushl  0xc(%ebp)
c000ae93:	ff 75 08             	pushl  0x8(%ebp)
c000ae96:	e8 8a fc ff ff       	call   c000ab25 <copy_pcb_vaddrbitmap_stack0>
c000ae9b:	83 c4 10             	add    $0x10,%esp
c000ae9e:	83 f8 ff             	cmp    $0xffffffff,%eax
c000aea1:	75 07                	jne    c000aeaa <copy_process+0x43>
/work/x86_os_my/userprog/fork.c:210
		return -1;
c000aea3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000aea8:	eb 65                	jmp    c000af0f <copy_process+0xa8>
/work/x86_os_my/userprog/fork.c:214
	}

	/* b 为子进程创建页表,此页表仅包括内核空间 */
	child_thread->pgdir = create_page_dir();
c000aeaa:	e8 a1 a2 ff ff       	call   c0005150 <create_page_dir>
c000aeaf:	89 c2                	mov    %eax,%edx
c000aeb1:	8b 45 08             	mov    0x8(%ebp),%eax
c000aeb4:	89 50 54             	mov    %edx,0x54(%eax)
/work/x86_os_my/userprog/fork.c:215
	if(child_thread->pgdir == NULL) {
c000aeb7:	8b 45 08             	mov    0x8(%ebp),%eax
c000aeba:	8b 40 54             	mov    0x54(%eax),%eax
c000aebd:	85 c0                	test   %eax,%eax
c000aebf:	75 07                	jne    c000aec8 <copy_process+0x61>
/work/x86_os_my/userprog/fork.c:216
		return -1;
c000aec1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000aec6:	eb 47                	jmp    c000af0f <copy_process+0xa8>
/work/x86_os_my/userprog/fork.c:220
	}

	/* c 复制父进程进程体及用户栈给子进程 */
	copy_body_stack3(child_thread, parent_thread, buf_page);
c000aec8:	83 ec 04             	sub    $0x4,%esp
c000aecb:	ff 75 f4             	pushl  -0xc(%ebp)
c000aece:	ff 75 0c             	pushl  0xc(%ebp)
c000aed1:	ff 75 08             	pushl  0x8(%ebp)
c000aed4:	e8 80 fd ff ff       	call   c000ac59 <copy_body_stack3>
c000aed9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:223

	/* d 构建子进程 thread_stack 和修改返回值pid */
	build_child_stack(child_thread);
c000aedc:	83 ec 0c             	sub    $0xc,%esp
c000aedf:	ff 75 08             	pushl  0x8(%ebp)
c000aee2:	e8 81 fe ff ff       	call   c000ad68 <build_child_stack>
c000aee7:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:226

	/* e 更新文件inode的打开数 */
	update_inode_open_cnts(child_thread);
c000aeea:	83 ec 0c             	sub    $0xc,%esp
c000aeed:	ff 75 08             	pushl  0x8(%ebp)
c000aef0:	e8 fb fe ff ff       	call   c000adf0 <update_inode_open_cnts>
c000aef5:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:228

	mfree_page(PF_KERNEL, buf_page, 1);
c000aef8:	83 ec 04             	sub    $0x4,%esp
c000aefb:	6a 01                	push   $0x1
c000aefd:	ff 75 f4             	pushl  -0xc(%ebp)
c000af00:	6a 01                	push   $0x1
c000af02:	e8 f2 81 ff ff       	call   c00030f9 <mfree_page>
c000af07:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:229
	return 0;
c000af0a:	b8 00 00 00 00       	mov    $0x0,%eax
/work/x86_os_my/userprog/fork.c:230
}
c000af0f:	c9                   	leave  
c000af10:	c3                   	ret    

c000af11 <sys_fork>:
sys_fork():
/work/x86_os_my/userprog/fork.c:233

/* fork子进程，内核线程不可直接调用 */
pid_t sys_fork(void) {
c000af11:	55                   	push   %ebp
c000af12:	89 e5                	mov    %esp,%ebp
c000af14:	83 ec 18             	sub    $0x18,%esp
/work/x86_os_my/userprog/fork.c:234
	struct task_struct* parent_thread = running_thread();
c000af17:	e8 4f 8c ff ff       	call   c0003b6b <running_thread>
c000af1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
/work/x86_os_my/userprog/fork.c:235
	struct task_struct* child_thread = get_kernel_pages(1);	// 为子进程创建pcb(task_struct结构)
c000af1f:	83 ec 0c             	sub    $0xc,%esp
c000af22:	6a 01                	push   $0x1
c000af24:	e8 61 7a ff ff       	call   c000298a <get_kernel_pages>
c000af29:	83 c4 10             	add    $0x10,%esp
c000af2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
/work/x86_os_my/userprog/fork.c:236
	if (child_thread == NULL) {
c000af2f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c000af33:	75 0a                	jne    c000af3f <sys_fork+0x2e>
/work/x86_os_my/userprog/fork.c:237
		return -1;
c000af35:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000af3a:	e9 f2 00 00 00       	jmp    c000b031 <sys_fork+0x120>
/work/x86_os_my/userprog/fork.c:239
	}
	ASSERT(INTR_OFF == intr_get_status() && parent_thread->pgdir != NULL);	//中断关了，并且是用户线程
c000af3f:	e8 41 6a ff ff       	call   c0001985 <intr_get_status>
c000af44:	85 c0                	test   %eax,%eax
c000af46:	75 0a                	jne    c000af52 <sys_fork+0x41>
/work/x86_os_my/userprog/fork.c:239 (discriminator 1)
c000af48:	8b 45 f4             	mov    -0xc(%ebp),%eax
c000af4b:	8b 40 54             	mov    0x54(%eax),%eax
c000af4e:	85 c0                	test   %eax,%eax
c000af50:	75 1c                	jne    c000af6e <sys_fork+0x5d>
/work/x86_os_my/userprog/fork.c:239 (discriminator 3)
c000af52:	68 40 d1 00 c0       	push   $0xc000d140
c000af57:	68 2c d2 00 c0       	push   $0xc000d22c
c000af5c:	68 ef 00 00 00       	push   $0xef
c000af61:	68 10 d1 00 c0       	push   $0xc000d110
c000af66:	e8 77 73 ff ff       	call   c00022e2 <panic_spin>
c000af6b:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:241

	if (copy_process(child_thread, parent_thread) == -1) {
c000af6e:	83 ec 08             	sub    $0x8,%esp
c000af71:	ff 75 f4             	pushl  -0xc(%ebp)
c000af74:	ff 75 f0             	pushl  -0x10(%ebp)
c000af77:	e8 eb fe ff ff       	call   c000ae67 <copy_process>
c000af7c:	83 c4 10             	add    $0x10,%esp
c000af7f:	83 f8 ff             	cmp    $0xffffffff,%eax
c000af82:	75 0a                	jne    c000af8e <sys_fork+0x7d>
/work/x86_os_my/userprog/fork.c:242
		return -1;
c000af84:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c000af89:	e9 a3 00 00 00       	jmp    c000b031 <sys_fork+0x120>
/work/x86_os_my/userprog/fork.c:246
	}

	/* 添加到就绪线程队列和所有线程队列，子进程由调度器安排运行 */
	ASSERT(!elem_find(&thread_ready_list, &child_thread->general_tag));
c000af8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000af91:	83 c0 44             	add    $0x44,%eax
c000af94:	83 ec 08             	sub    $0x8,%esp
c000af97:	50                   	push   %eax
c000af98:	68 8c fb 00 c0       	push   $0xc000fb8c
c000af9d:	e8 e6 93 ff ff       	call   c0004388 <elem_find>
c000afa2:	83 c4 10             	add    $0x10,%esp
c000afa5:	85 c0                	test   %eax,%eax
c000afa7:	74 1c                	je     c000afc5 <sys_fork+0xb4>
/work/x86_os_my/userprog/fork.c:246 (discriminator 1)
c000afa9:	68 80 d1 00 c0       	push   $0xc000d180
c000afae:	68 2c d2 00 c0       	push   $0xc000d22c
c000afb3:	68 f6 00 00 00       	push   $0xf6
c000afb8:	68 10 d1 00 c0       	push   $0xc000d110
c000afbd:	e8 20 73 ff ff       	call   c00022e2 <panic_spin>
c000afc2:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:247
	list_append(&thread_ready_list, &child_thread->general_tag);
c000afc5:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000afc8:	83 c0 44             	add    $0x44,%eax
c000afcb:	83 ec 08             	sub    $0x8,%esp
c000afce:	50                   	push   %eax
c000afcf:	68 8c fb 00 c0       	push   $0xc000fb8c
c000afd4:	e8 35 93 ff ff       	call   c000430e <list_append>
c000afd9:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:248
	ASSERT(!elem_find(&thread_all_list, &child_thread->all_list_tag));
c000afdc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000afdf:	83 c0 4c             	add    $0x4c,%eax
c000afe2:	83 ec 08             	sub    $0x8,%esp
c000afe5:	50                   	push   %eax
c000afe6:	68 9c fb 00 c0       	push   $0xc000fb9c
c000afeb:	e8 98 93 ff ff       	call   c0004388 <elem_find>
c000aff0:	83 c4 10             	add    $0x10,%esp
c000aff3:	85 c0                	test   %eax,%eax
c000aff5:	74 1c                	je     c000b013 <sys_fork+0x102>
/work/x86_os_my/userprog/fork.c:248 (discriminator 1)
c000aff7:	68 bc d1 00 c0       	push   $0xc000d1bc
c000affc:	68 2c d2 00 c0       	push   $0xc000d22c
c000b001:	68 f8 00 00 00       	push   $0xf8
c000b006:	68 10 d1 00 c0       	push   $0xc000d110
c000b00b:	e8 d2 72 ff ff       	call   c00022e2 <panic_spin>
c000b010:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:249
	list_append(&thread_all_list, &child_thread->all_list_tag);
c000b013:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000b016:	83 c0 4c             	add    $0x4c,%eax
c000b019:	83 ec 08             	sub    $0x8,%esp
c000b01c:	50                   	push   %eax
c000b01d:	68 9c fb 00 c0       	push   $0xc000fb9c
c000b022:	e8 e7 92 ff ff       	call   c000430e <list_append>
c000b027:	83 c4 10             	add    $0x10,%esp
/work/x86_os_my/userprog/fork.c:251

	return child_thread->pid;	// 父进程返回子进程的pid
c000b02a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c000b02d:	0f b7 40 04          	movzwl 0x4(%eax),%eax
/work/x86_os_my/userprog/fork.c:252
}
c000b031:	c9                   	leave  
c000b032:	c3                   	ret    
